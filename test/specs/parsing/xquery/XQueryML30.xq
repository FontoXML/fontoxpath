xquery version "1.0" encoding "UTF-8";

(: This file was generated on Mon Feb 11, 2013 14:37 (UTC+01) by REx v5.23 which is Copyright (c) 1979-2013 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: XQueryML30.ebnf -xquery -tree -backtrack :)

(:~
 : The parser that was generated for the XQueryML30 grammar.
 :)
module namespace p="XQueryML30";
declare default function namespace "http://www.w3.org/2005/xpath-functions";

(:~
 : The index of the parser state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk := 1;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the token that has been shifted.
 :)
declare variable $p:b0 := 2;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the token that has been shifted.
 :)
declare variable $p:e0 := 3;

(:~
 : The index of the parser state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 := 4;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 := 5;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 := 6;

(:~
 : The index of the parser state for accessing the code of the
 : level-2-lookahead token.
 :)
declare variable $p:l2 := 7;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-2-lookahead token.
 :)
declare variable $p:b2 := 8;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-2-lookahead token.
 :)
declare variable $p:e2 := 9;

(:~
 : The index of the parser state for accessing the code of the
 : level-3-lookahead token.
 :)
declare variable $p:l3 := 10;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-3-lookahead token.
 :)
declare variable $p:b3 := 11;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-3-lookahead token.
 :)
declare variable $p:e3 := 12;

(:~
 : The index of the parser state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error := 13;

(:~
 : The index of the parser state for accessing the memoization
 : of backtracking results.
 :)
declare variable $p:memo := 14;

(:~
 : The index of the parser state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result := 15;

(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  69, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7,
  8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
  29, 26, 30, 30, 30, 30, 30, 31, 32, 33, 30, 30, 30, 30, 30, 34, 30, 30, 30, 35, 30, 30, 36, 37, 38, 37, 39, 37, 40,
  41, 42, 43, 44, 45, 46, 47, 48, 30, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 37,
  37
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  108, 124, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 156, 181, 181, 181, 181, 181, 214,
  215, 213, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 247, 261, 277, 293, 309, 324, 370,
  386, 422, 422, 422, 414, 354, 346, 354, 346, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
  354, 354, 439, 439, 439, 439, 439, 439, 439, 339, 354, 354, 354, 354, 354, 354, 354, 354, 400, 422, 422, 423, 421,
  422, 422, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 422, 422, 422,
  422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422,
  422, 422, 422, 422, 422, 422, 353, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
  354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 422, 69, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
  0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,
  17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 26, 30, 30, 30, 30, 30, 31, 32,
  33, 30, 30, 30, 30, 34, 30, 30, 30, 35, 30, 30, 36, 37, 38, 37, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
  39, 37, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 37, 40, 41, 42, 43, 44, 45, 46, 47, 48, 30,
  49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
  37, 37, 39, 39, 37, 37, 37, 37, 37, 37, 37, 68, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 68,
  68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68
);

(:~
 : The codepoint to charclass mapping for codepoints above the surrogate block.
 :)
declare variable $p:MAP2 as xs:integer+ :=
(
  57344, 63744, 64976, 65008, 65536, 983040, 63743, 64975, 65007, 65533, 983039, 1114111, 37, 39, 37, 39, 39, 37
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  1, 16386, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,
  61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,
  90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114,
  115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137,
  138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160,
  161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183,
  184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206,
  207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229,
  230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252,
  253
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18876, 17932, 17965, 17965, 17965, 17962, 17965, 17965, 17965, 17965, 17920, 17965, 17965, 17965, 17948, 17968,
  17984, 18031, 18031, 18031, 37033, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18630,
  18031, 24751, 18031, 18031, 19552, 18030, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18231, 18031, 18031, 18031, 18031, 18028, 18031, 18031, 18031, 18031, 18048, 18082, 18095, 18108, 18124,
  26818, 24759, 18031, 18031, 18031, 37033, 18031, 18031, 20761, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18630, 18031, 27796, 18031, 18031, 19552, 18030, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18557, 18142, 18031, 18031, 18031, 18163, 18031, 18031, 18260, 22423, 18184, 25121, 18031, 18031,
  24249, 18218, 26512, 18031, 18031, 18031, 37033, 18031, 38082, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 35294, 18031, 18251, 25128, 18031, 19552, 18030, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 23025, 18031, 18031, 18031, 18280, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18299, 18410, 18031, 18031, 18031, 18334, 18031, 18031, 18412, 18031, 18048, 18371, 29465,
  18357, 18406, 19864, 24759, 18031, 18031, 18031, 21554, 18031, 18031, 18428, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18630, 18031, 25160, 18445, 18031, 19552, 18030, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 30408, 18031, 18031, 18031, 18464, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18231, 20696, 18031, 18031, 18031, 18485, 18031, 18031, 38218, 30366, 18519, 18031,
  31897, 20699, 31898, 18544, 24759, 18031, 18031, 18031, 37033, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18630, 18031, 24751, 18031, 18031, 19552, 18030, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18231, 18031, 18031, 18031, 18031, 18028, 18031, 18031, 21481, 21466, 18573,
  21476, 18031, 32596, 30001, 24026, 24759, 18031, 18031, 18031, 37033, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18630, 18031, 24751, 18031, 18031, 19552, 18030, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18231, 18031, 18031, 18031, 18031, 18028, 18031, 18031, 18031, 18031,
  18598, 18031, 18031, 18031, 18031, 18283, 36730, 18031, 18031, 18031, 37033, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 33057, 18031, 36722, 18031, 18031, 19552, 18030, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18705, 18623, 18031, 18031, 18031, 18646, 18031, 18031, 30109,
  23012, 18667, 25494, 18031, 18031, 24434, 18692, 27804, 18031, 18031, 18031, 37033, 18031, 18031, 18721, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 28742, 18031, 30097, 25498, 18031, 19552, 18030, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 24580, 18031, 18031, 18031, 19069, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18231, 18753, 18762, 18762, 18762, 18741, 18762, 18762,
  18793, 18804, 18781, 18847, 18765, 18820, 18835, 18863, 24759, 18031, 18031, 18031, 18892, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18630, 18031, 24751, 18031, 18031, 20077, 18030, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18231, 25999, 18031, 18031, 18031, 18913, 18031,
  18031, 23152, 18031, 18048, 18941, 18954, 18954, 18925, 18970, 18986, 18031, 18031, 18031, 21712, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18630, 18031, 24751, 18031, 18031, 19552, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18231, 20190, 18031, 18031, 18031, 18028,
  18031, 18031, 18031, 18031, 18048, 19056, 30660, 19027, 19042, 19091, 24759, 18031, 18031, 18031, 37033, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18630, 18031, 24751, 18031, 18031, 19552, 18030, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 31012, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 31014, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18231, 18031, 18031, 18031, 18031,
  18028, 18031, 18031, 18031, 18031, 18048, 19120, 31644, 19149, 19163, 31651, 24759, 18031, 18031, 18031, 37033, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18630, 18031, 24751, 18031, 18031, 19552, 18030,
  18031, 26730, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18231, 29621, 18031, 18031,
  18031, 19181, 18031, 18031, 29623, 18031, 19237, 19270, 19280, 19280, 19252, 20363, 24759, 18031, 18031, 18031, 37033,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18630, 18031, 24751, 18031, 18031, 19552,
  18030, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 19296, 18031, 18031,
  18031, 18031, 18028, 18031, 18031, 18031, 18031, 18048, 19319, 33202, 19370, 19384, 33209, 19402, 18031, 18031, 18031,
  37033, 18031, 18031, 18031, 18031, 18031, 19570, 35170, 18031, 18031, 18031, 30021, 24201, 24094, 25791, 18031, 19438,
  19552, 18897, 18031, 26730, 28453, 18031, 19572, 32235, 23769, 18031, 35460, 28265, 28265, 21312, 24094, 24094, 24094,
  28449, 18031, 18031, 18031, 18031, 18031, 19460, 18031, 35166, 32235, 24830, 25080, 28265, 28265, 28265, 21310, 19495,
  24094, 24094, 24094, 23306, 27995, 18031, 18031, 18031, 31296, 27232, 32235, 23768, 30020, 28265, 28265, 28266, 20007,
  24094, 24094, 24094, 26310, 18031, 18031, 18031, 19513, 35166, 37841, 23957, 28265, 26934, 22055, 24094, 36587, 18031,
  18031, 19531, 27233, 34104, 28265, 31781, 24094, 26301, 19551, 28763, 27232, 37115, 28265, 36582, 24984, 18031, 19568,
  33151, 34609, 19588, 18031, 19607, 19636, 19303, 19672, 21301, 19708, 23415, 19713, 31068, 35980, 35981, 36192, 26811,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18231, 18031,
  18031, 18031, 18031, 18028, 18031, 18031, 18031, 34727, 18048, 18031, 18031, 18031, 18031, 19729, 19771, 18031, 18031,
  18031, 37033, 18031, 38358, 18031, 18031, 18031, 19570, 35170, 18031, 18031, 18031, 30021, 24201, 24094, 27948, 18031,
  18031, 19552, 18030, 18031, 18031, 18031, 18031, 19572, 32235, 23769, 18031, 35460, 28265, 28265, 21312, 24094, 24094,
  24094, 26310, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 35166, 32235, 24830, 25080, 28265, 28265, 28265, 21310,
  19495, 24094, 24094, 24094, 26310, 18031, 18031, 18031, 18031, 18031, 27232, 32235, 23768, 30020, 28265, 28265, 28266,
  20007, 24094, 24094, 24094, 26310, 18031, 18031, 18031, 18031, 35166, 37841, 28265, 28265, 26934, 24094, 24094, 36587,
  18031, 18031, 18031, 27233, 34104, 28265, 22790, 24094, 36588, 18031, 18031, 27232, 37115, 28265, 36582, 36587, 18031,
  27233, 23411, 22791, 24095, 18031, 35458, 36585, 26667, 27406, 26669, 27408, 23415, 34564, 27403, 35980, 35981, 36192,
  26811, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18231,
  35709, 18031, 18031, 18031, 18028, 18031, 18031, 18031, 18031, 18048, 19820, 31934, 19806, 19857, 19880, 24759, 18031,
  18031, 18031, 37033, 18031, 18031, 34453, 18031, 19650, 18031, 18031, 18031, 18031, 18031, 18031, 18630, 18031, 24751,
  18031, 18031, 19552, 18030, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18231, 19914, 18031, 18031, 18031, 18028, 18031, 18031, 18031, 34033, 18048, 18031, 18031, 18031, 18031, 19933, 19967,
  18031, 18031, 18031, 37033, 18031, 21276, 18031, 18031, 18031, 19570, 35170, 18031, 18031, 18031, 30021, 24201, 24094,
  27041, 18031, 18031, 19552, 18030, 18031, 19998, 18031, 18031, 19572, 32235, 23769, 18031, 35460, 28265, 28265, 21312,
  24094, 24094, 24094, 32441, 18031, 18031, 18031, 18031, 19841, 18031, 18031, 35166, 32235, 24830, 25080, 28265, 28265,
  28265, 30922, 19495, 24094, 24094, 24094, 21607, 18031, 18031, 18031, 22352, 18031, 27232, 32235, 23768, 30020, 28265,
  28265, 28266, 20031, 24094, 24094, 24094, 21662, 18031, 18031, 18031, 18031, 35166, 37841, 28265, 28265, 37489, 24094,
  24094, 33835, 18031, 18031, 18031, 27233, 34104, 28265, 22790, 24094, 36588, 18031, 18031, 27232, 37115, 28265, 36582,
  36587, 18031, 27233, 23411, 22791, 24095, 18031, 35458, 36585, 26667, 27406, 26669, 27408, 23415, 34564, 27403, 35980,
  35981, 36192, 26811, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 19893, 18235, 18031, 18031, 18031, 20055, 20075, 18031, 20059, 18031, 18048, 18031, 18031, 25630, 20093, 18147,
  20110, 20166, 18031, 18031, 20183, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 20404, 20206,
  35789, 20289, 18031, 18031, 18031, 20238, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 20255, 20257, 20257,
  20274, 35789, 35789, 35789, 20334, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 35031, 20257,
  20257, 20257, 20356, 35787, 35789, 35789, 35789, 20220, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 20403,
  20257, 20257, 20258, 35781, 35789, 35789, 35789, 20220, 18031, 18031, 18031, 18031, 18031, 21093, 20257, 20257, 20379,
  35789, 35789, 20442, 18031, 18031, 18031, 18031, 21094, 20257, 20420, 35789, 20443, 18031, 18031, 18031, 21095, 20257,
  20437, 20442, 18031, 18031, 35031, 20421, 35790, 18031, 20404, 20440, 35028, 36478, 35030, 36480, 36469, 20394, 36475,
  25210, 25211, 20459, 20473, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18231, 32715, 18031, 18031, 18031, 20496, 20508, 18031, 18031, 18031, 20528, 20558, 20568, 20568, 20510,
  34520, 24759, 18031, 18031, 18031, 37033, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18630, 18031, 24751, 18031, 18031, 19552, 18030, 18031, 20602, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 27708, 18031, 18031, 18031, 18031, 35623, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 28223, 24270, 18031, 18031, 18031, 24465, 18031, 18031, 18031, 35623, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 24264, 18031, 18031, 18031, 20584, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18628, 18031, 18031, 19535, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18231, 18031, 18031, 18031, 18031, 18028, 18031, 18031, 18031, 18031, 28799, 20618, 20628, 20628,
  20644, 20662, 24759, 18031, 18031, 18031, 37033, 18031, 18031, 18031, 18031, 29006, 18031, 18031, 18031, 18031, 18031,
  18031, 18630, 18031, 26504, 18031, 18031, 19552, 18030, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 19742, 18126, 18031, 18031, 18031, 18028, 18031, 18031, 18031, 18031, 18048, 20715, 20725,
  20725, 20741, 20480, 24759, 20759, 18031, 18031, 37033, 18031, 18031, 18031, 18031, 38046, 18031, 18031, 18031, 18031,
  18031, 18031, 18630, 18031, 27282, 18031, 18031, 19552, 18030, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 19104, 19686, 18031, 18031, 18031, 18028, 18031, 18031, 18031, 18031, 18048, 20777,
  20787, 20787, 20803, 29013, 20826, 18031, 18031, 18031, 37033, 18031, 18031, 18031, 18031, 32855, 18031, 18031, 18031,
  18031, 18031, 18031, 18630, 18031, 35669, 18031, 18031, 19552, 18030, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18012, 18031, 18031, 18031, 18031, 20842, 18031, 18031, 18031, 18031, 18048,
  18031, 36022, 20847, 18031, 17999, 24759, 18031, 18031, 18031, 37033, 18031, 18031, 35366, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18630, 18031, 28058, 18031, 18031, 19552, 18030, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18231, 18031, 18031, 18031, 18031, 18028, 18031, 18031, 18031, 18031,
  18048, 18031, 18031, 18031, 18031, 20863, 24759, 18031, 18031, 18031, 37033, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18630, 18031, 24751, 18031, 18031, 19552, 18030, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 19893, 18031, 18031, 18031, 18031, 18028, 18031, 18031, 18031,
  18031, 18048, 22478, 18031, 38413, 24509, 22276, 19771, 18031, 18031, 18031, 37033, 18031, 18031, 31558, 18031, 18031,
  19570, 35170, 18031, 18031, 18031, 30021, 24201, 24094, 25940, 20879, 18031, 19552, 18030, 18031, 33315, 18031, 18031,
  19572, 32235, 23769, 18031, 25085, 28265, 28265, 35516, 24094, 24094, 24094, 27080, 18031, 18031, 18031, 18031, 22351,
  18031, 18031, 35166, 32235, 24830, 25080, 28265, 28265, 28265, 29446, 20898, 24094, 24094, 24094, 26781, 18031, 18031,
  18031, 22352, 18031, 27232, 32235, 23768, 30020, 28265, 28265, 28266, 20916, 24094, 24094, 24094, 32055, 18031, 18031,
  25862, 18031, 35166, 37841, 28265, 28265, 37489, 24094, 24094, 33835, 18031, 18031, 18031, 27233, 34104, 28265, 22790,
  24094, 36588, 18031, 37822, 27232, 37115, 28265, 36582, 36587, 18031, 27233, 23411, 22791, 24095, 18031, 35458, 36585,
  26667, 27406, 26669, 27408, 23415, 34564, 27403, 35980, 35981, 36192, 26811, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 19893, 18031, 18031, 18031, 18031, 18028, 18031, 18031,
  18031, 18031, 18048, 22478, 18031, 38413, 24509, 22276, 19771, 18031, 18031, 18031, 37033, 18031, 18031, 31558, 18031,
  18031, 19570, 35170, 18031, 18031, 18031, 30021, 24201, 24094, 25940, 20879, 18031, 19552, 18030, 18031, 33315, 18031,
  18031, 19572, 32235, 23769, 18031, 25085, 28265, 28265, 35516, 24094, 24094, 24094, 27080, 18031, 18031, 18031, 18031,
  22351, 18031, 18031, 35166, 32235, 24830, 25080, 28265, 28265, 28265, 29446, 20898, 24094, 24094, 24094, 26781, 18031,
  18031, 18031, 22352, 18031, 27232, 32235, 23768, 30020, 28265, 28265, 28266, 20916, 24094, 24094, 24094, 32055, 18031,
  18031, 18031, 18031, 35166, 37841, 28265, 28265, 37489, 24094, 24094, 33835, 18031, 18031, 18031, 27233, 34104, 28265,
  22790, 24094, 36588, 18031, 18031, 27232, 37115, 28265, 36582, 36587, 18031, 27233, 23411, 22791, 24095, 18031, 35458,
  36585, 26667, 27406, 26669, 27408, 23415, 34564, 27403, 35980, 35981, 36192, 26811, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 19893, 18031, 18031, 18031, 18031, 18028, 18031,
  18031, 18031, 18031, 18048, 22478, 18031, 38413, 24509, 22276, 19771, 18031, 18031, 18031, 37033, 18031, 18031, 31558,
  18031, 18031, 19570, 35170, 18031, 18031, 18031, 30021, 24201, 24094, 25940, 20879, 18031, 19552, 18030, 18031, 33315,
  18031, 18031, 19572, 32235, 23769, 18031, 25085, 28265, 28265, 35516, 24094, 24094, 24094, 27080, 18031, 18031, 18031,
  18031, 22351, 28315, 18031, 35166, 32235, 24830, 25080, 28265, 28265, 28265, 29446, 20898, 24094, 24094, 24094, 26781,
  18031, 18031, 18031, 22352, 18031, 27232, 32235, 23768, 30020, 28265, 28265, 28266, 20916, 24094, 24094, 24094, 32055,
  18031, 18031, 18031, 18031, 35166, 37841, 28265, 28265, 37489, 24094, 24094, 33835, 18031, 18031, 18031, 27233, 34104,
  28265, 22790, 24094, 36588, 18031, 18031, 27232, 37115, 28265, 36582, 36587, 18031, 27233, 23411, 22791, 24095, 18031,
  35458, 36585, 26667, 27406, 26669, 27408, 23415, 34564, 27403, 35980, 35981, 36192, 26811, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 19893, 18031, 18031, 18031, 18031, 18028,
  18031, 18031, 18031, 18031, 18048, 22478, 18031, 38413, 24509, 22276, 19771, 18031, 18031, 18031, 37033, 18031, 18031,
  31558, 18031, 18031, 19570, 35170, 18031, 18031, 18031, 30021, 24201, 24094, 25940, 20879, 18031, 19552, 18030, 18031,
  33315, 18031, 18031, 19572, 32235, 23769, 18031, 25085, 28265, 28265, 35516, 24094, 24094, 24094, 27080, 18031, 18031,
  18031, 18031, 22351, 18031, 18031, 35166, 32235, 24830, 25080, 28265, 28265, 28265, 29446, 20898, 24094, 24094, 24094,
  26781, 18031, 18031, 18031, 22352, 20940, 27232, 32235, 23768, 30020, 28265, 28265, 28266, 20916, 24094, 24094, 24094,
  32055, 18031, 18031, 18031, 18031, 35166, 37841, 28265, 28265, 37489, 24094, 24094, 33835, 18031, 18031, 18031, 27233,
  34104, 28265, 22790, 24094, 36588, 18031, 18031, 27232, 37115, 28265, 36582, 36587, 18031, 27233, 23411, 22791, 24095,
  18031, 35458, 36585, 26667, 27406, 26669, 27408, 23415, 34564, 27403, 35980, 35981, 36192, 26811, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 19893, 18031, 18031, 18031, 18031,
  18028, 18031, 18031, 18031, 18031, 18048, 22478, 18031, 38413, 24509, 22276, 19771, 18031, 18031, 18031, 37033, 18031,
  19692, 31558, 18031, 18031, 19570, 35170, 18031, 18031, 18031, 30021, 24201, 24094, 25940, 20879, 18031, 19552, 18030,
  18031, 31549, 18031, 18031, 19572, 32235, 23769, 18031, 25085, 28265, 28265, 35516, 24094, 24094, 24094, 27080, 18031,
  18031, 18031, 18031, 22351, 18031, 18031, 35166, 32235, 24830, 25080, 28265, 28265, 28265, 29446, 20898, 24094, 24094,
  24094, 26781, 18031, 18031, 18031, 22352, 18031, 27232, 32235, 23768, 30020, 28265, 28265, 28266, 20916, 24094, 24094,
  24094, 32055, 18031, 18031, 18031, 18031, 35166, 37841, 28265, 28265, 37489, 24094, 24094, 33835, 18031, 18031, 18031,
  27233, 34104, 28265, 22790, 24094, 36588, 18031, 18031, 27232, 37115, 28265, 36582, 36587, 18031, 27233, 23411, 22791,
  24095, 18031, 35458, 36585, 26667, 27406, 26669, 27408, 23415, 34564, 27403, 35980, 35981, 36192, 26811, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 19893, 18031, 18031, 18031,
  18031, 18028, 18031, 18031, 18031, 18031, 18048, 22478, 18031, 38413, 24509, 22276, 19771, 18031, 18031, 18031, 37033,
  18031, 18031, 31558, 18031, 18031, 19570, 35170, 18031, 18031, 18031, 30021, 24201, 24094, 25940, 20879, 18031, 19552,
  18030, 18031, 33315, 18031, 18031, 19572, 32235, 23769, 18031, 25085, 28265, 28265, 35516, 24094, 24094, 24094, 27080,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 35166, 32235, 24830, 25080, 28265, 28265, 28265, 29446, 20898, 24094,
  24094, 24094, 28124, 18031, 18031, 18031, 18031, 18031, 27232, 32235, 23768, 30020, 28265, 28265, 28266, 20007, 24094,
  24094, 24094, 26310, 18031, 18031, 18031, 18031, 35166, 37841, 28265, 28265, 26934, 24094, 24094, 36587, 18031, 18031,
  18031, 27233, 34104, 28265, 22790, 24094, 36588, 18031, 18031, 27232, 37115, 28265, 36582, 36587, 18031, 27233, 23411,
  22791, 24095, 18031, 35458, 36585, 26667, 27406, 26669, 27408, 23415, 34564, 27403, 35980, 35981, 36192, 26811, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 19893, 18031, 18031,
  18031, 18031, 18028, 18031, 18031, 18031, 18031, 18048, 22478, 18031, 38413, 24509, 22276, 19771, 18031, 18031, 18031,
  37033, 18031, 18031, 31558, 18031, 18031, 19570, 35170, 18031, 18031, 18031, 30021, 24201, 24094, 33769, 20879, 18031,
  19552, 18030, 18031, 33315, 18031, 18031, 19572, 32235, 23769, 18031, 25085, 28265, 28265, 35516, 24094, 24094, 24094,
  27080, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 35166, 32235, 24830, 25080, 28265, 28265, 28265, 29446, 20898,
  24094, 24094, 24094, 28124, 18031, 18031, 18031, 18031, 18031, 27232, 32235, 23768, 30020, 28265, 28265, 28266, 20007,
  24094, 24094, 24094, 26310, 18031, 18031, 18031, 18031, 35166, 37841, 28265, 28265, 26934, 24094, 24094, 36587, 18031,
  18031, 18031, 27233, 34104, 28265, 22790, 24094, 36588, 18031, 18031, 27232, 37115, 28265, 36582, 36587, 18031, 27233,
  23411, 22791, 24095, 18031, 35458, 36585, 26667, 27406, 26669, 27408, 23415, 34564, 27403, 35980, 35981, 36192, 26811,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 19893, 18031,
  18031, 18031, 18031, 18028, 18031, 18031, 18031, 18031, 18048, 22478, 18031, 38413, 24509, 22276, 20958, 18031, 18031,
  18031, 37033, 18031, 18031, 31558, 18031, 18031, 19570, 35170, 18031, 18031, 18031, 30021, 24201, 24094, 25940, 20879,
  18031, 19552, 18030, 18031, 33315, 18031, 18031, 19572, 32235, 23769, 18031, 25085, 28265, 28265, 35516, 24094, 24094,
  24094, 27080, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 35166, 32235, 24830, 25080, 28265, 28265, 28265, 29446,
  20898, 24094, 24094, 24094, 28124, 18031, 18031, 18031, 18031, 18031, 27232, 32235, 23768, 30020, 28265, 28265, 28266,
  20007, 24094, 24094, 24094, 26310, 18031, 18031, 18031, 18031, 35166, 37841, 28265, 28265, 26934, 24094, 24094, 36587,
  18031, 18031, 18031, 27233, 34104, 28265, 22790, 24094, 36588, 18031, 18031, 27232, 37115, 28265, 36582, 36587, 18031,
  27233, 23411, 22791, 24095, 18031, 35458, 36585, 26667, 27406, 26669, 27408, 23415, 34564, 27403, 35980, 35981, 36192,
  26811, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 19893,
  18031, 18031, 18031, 18031, 18028, 18031, 18031, 18031, 18031, 21006, 22478, 18031, 38413, 24509, 22276, 19771, 18031,
  18031, 18031, 37033, 18031, 18031, 31558, 18031, 18031, 19570, 35170, 18031, 18031, 18031, 30021, 24201, 24094, 25940,
  20879, 18031, 19552, 18030, 18031, 33315, 25175, 18031, 19572, 32235, 23769, 18031, 25085, 28265, 28265, 35516, 24094,
  24094, 24094, 27080, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 35166, 32235, 24830, 25080, 28265, 28265, 28265,
  29446, 20898, 24094, 24094, 24094, 28124, 18031, 18031, 18031, 18031, 18031, 27232, 32235, 23768, 30020, 28265, 28265,
  28266, 20007, 24094, 24094, 24094, 26310, 18031, 18031, 18031, 18031, 35166, 37841, 28265, 28265, 26934, 24094, 24094,
  36587, 18031, 18031, 18031, 27233, 34104, 28265, 22790, 24094, 36588, 18031, 18031, 27232, 37115, 28265, 36582, 36587,
  18031, 27233, 23411, 22791, 24095, 18031, 35458, 36585, 26667, 27406, 26669, 27408, 23415, 34564, 27403, 35980, 35981,
  36192, 26811, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  19893, 18031, 18031, 18031, 18031, 18028, 18031, 18031, 18031, 18031, 18048, 22478, 18031, 38413, 24509, 22276, 19771,
  18031, 18031, 18031, 37033, 18031, 18031, 31558, 18031, 18031, 19570, 35170, 18031, 18031, 18031, 30021, 24201, 24094,
  25940, 20879, 18031, 19552, 18030, 18031, 33315, 18031, 18031, 19572, 32235, 23769, 18031, 25085, 28265, 28265, 35516,
  24094, 24094, 24094, 27080, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 35166, 32235, 24830, 25080, 28265, 28265,
  28265, 29446, 20898, 24094, 24094, 24094, 28124, 18031, 18031, 18031, 18031, 18031, 27232, 32235, 23768, 30020, 28265,
  28265, 28266, 20007, 24094, 24094, 24094, 26310, 18031, 18031, 18031, 18031, 35166, 37841, 28265, 28265, 26934, 24094,
  24094, 36587, 18031, 18031, 18057, 27233, 34104, 28265, 22790, 24094, 36588, 18031, 18031, 27232, 37115, 28265, 36582,
  36587, 18031, 27233, 23411, 22791, 24095, 18031, 35458, 36585, 26667, 27406, 26669, 27408, 23415, 34564, 27403, 35980,
  35981, 36192, 26811, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 19946, 18031, 18031, 18031, 18031, 18028, 18031, 18031, 18031, 18031, 18048, 22478, 18031, 38413, 24509, 22276,
  19771, 18031, 18031, 18031, 37033, 18031, 18031, 31558, 18031, 18031, 19570, 35170, 18031, 18031, 18031, 30021, 24201,
  24094, 25940, 20879, 18031, 19552, 18030, 18031, 33315, 18031, 18031, 19572, 32235, 23769, 18031, 25085, 28265, 28265,
  35516, 24094, 24094, 24094, 27080, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 35166, 32235, 24830, 25080, 28265,
  28265, 28265, 29446, 20898, 24094, 24094, 24094, 28124, 18031, 18031, 18031, 18031, 18031, 27232, 32235, 23768, 30020,
  28265, 28265, 28266, 20007, 24094, 24094, 24094, 26310, 18031, 18031, 18031, 18031, 35166, 37841, 28265, 28265, 26934,
  24094, 24094, 36587, 18031, 18031, 18031, 27233, 34104, 28265, 22790, 24094, 36588, 18031, 18031, 27232, 37115, 28265,
  36582, 36587, 18031, 27233, 23411, 22791, 24095, 18031, 35458, 36585, 26667, 27406, 26669, 27408, 23415, 34564, 27403,
  35980, 35981, 36192, 26811, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18231, 18031, 18031, 18031, 18031, 18028, 18031, 18031, 18031, 18031, 18048, 21056, 32801, 21042, 21091,
  20810, 24759, 18031, 18031, 18031, 37033, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18630, 18031, 24751, 18031, 18031, 19552, 18030, 18031, 18031, 21111, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 32819, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18231, 18031, 18031, 18031, 18031, 18028, 18031, 18031, 18031, 18031, 18048, 18031, 18031, 18031,
  18031, 18283, 24759, 18031, 18031, 18031, 37033, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18630, 18031, 24751, 18031, 18031, 19552, 18030, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 20675, 18031, 18031, 18031, 18031, 18028, 18031, 18031, 18031, 18031, 18048, 21130, 21143,
  21143, 21159, 21404, 21177, 18031, 18031, 18031, 37033, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18630, 18031, 26343, 18031, 18031, 19552, 18030, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 19893, 18031, 18031, 18031, 18031, 18028, 18031, 18031, 18031, 18031, 18048, 22478,
  18031, 38413, 24509, 22276, 19771, 18031, 18031, 18031, 37033, 18031, 18031, 18031, 18031, 18031, 19570, 35170, 18031,
  18031, 18031, 30021, 24201, 24094, 25791, 18031, 18031, 19552, 18030, 18031, 18031, 18031, 18031, 19572, 32235, 23769,
  18031, 25085, 28265, 28265, 24949, 24094, 24094, 24094, 26310, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 35166,
  32235, 24830, 25080, 28265, 28265, 28265, 28542, 19495, 24094, 24094, 24094, 26310, 18031, 18031, 18031, 18031, 18031,
  27232, 32235, 23768, 30020, 28265, 28265, 28266, 20007, 24094, 24094, 24094, 26310, 18031, 18031, 18031, 18031, 35166,
  37841, 28265, 28265, 26934, 24094, 24094, 36587, 18031, 18031, 18031, 27233, 34104, 28265, 22790, 24094, 36588, 18031,
  18031, 27232, 37115, 28265, 36582, 36587, 18031, 27233, 23411, 22791, 24095, 18031, 35458, 36585, 26667, 27406, 26669,
  27408, 23415, 34564, 27403, 35980, 35981, 36192, 26811, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 19893, 18031, 21216, 18031, 18031, 21234, 21268, 18031, 36818, 29071, 21292,
  21328, 21341, 21349, 21365, 21381, 19771, 24017, 23464, 18031, 27319, 20686, 19332, 21397, 21420, 21456, 21497, 21539,
  19833, 29921, 24478, 21577, 21593, 21648, 21697, 20879, 31872, 37021, 18030, 19917, 33315, 21734, 27485, 19572, 32235,
  21775, 18031, 21838, 28265, 24526, 35516, 24094, 24094, 29550, 27080, 19479, 21440, 18031, 21856, 22351, 18031, 18031,
  21883, 21921, 36064, 21969, 24194, 25087, 21998, 29446, 22029, 22053, 32287, 25412, 26781, 22071, 30862, 18031, 22089,
  18031, 23398, 22130, 34219, 28590, 22156, 22175, 28266, 22225, 22270, 36257, 22292, 24685, 22310, 22348, 35681, 20594,
  35166, 37841, 28265, 28265, 22368, 24094, 24094, 22240, 31861, 22409, 18031, 22471, 22500, 23270, 22529, 31831, 36588,
  35022, 18031, 27232, 37115, 22553, 31789, 37937, 18031, 27233, 23411, 22791, 24095, 18031, 35458, 36585, 26667, 22633,
  22569, 37897, 22593, 24158, 27403, 22627, 35981, 36192, 26811, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 19893, 18031, 22649, 18031, 18031, 18028, 32748, 18031, 18031, 18031,
  22670, 22706, 22719, 22720, 22736, 22752, 19771, 18031, 18031, 18031, 37033, 18031, 18031, 31558, 18031, 18031, 19570,
  35170, 18031, 18031, 18031, 30021, 24201, 24094, 25940, 20879, 18031, 19552, 18030, 18031, 33315, 18031, 18031, 19572,
  32235, 23769, 18031, 25085, 28265, 28265, 35516, 24094, 24094, 24094, 27080, 18031, 18031, 18031, 22770, 22351, 22768,
  24704, 35166, 37176, 24830, 25080, 28265, 28265, 36921, 29446, 20898, 24094, 24094, 31610, 26781, 18031, 18031, 18031,
  22352, 18031, 27232, 32235, 23768, 30020, 28265, 28265, 28266, 20916, 24094, 24094, 24094, 32055, 18031, 18031, 32926,
  32200, 34319, 37841, 22786, 28265, 37489, 22807, 24094, 33835, 18031, 18031, 18031, 27233, 34104, 28265, 22790, 24094,
  36588, 18031, 18031, 27232, 37115, 28265, 36582, 36587, 18031, 27233, 23411, 22791, 24095, 18031, 35458, 36585, 26667,
  27406, 26669, 27408, 22828, 22856, 27403, 35980, 35981, 36192, 26811, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 19893, 18031, 22436, 18031, 18031, 18028, 18031, 18031, 18032,
  18032, 22889, 22905, 22918, 22931, 22947, 22963, 19771, 18031, 18031, 22982, 37033, 18031, 22979, 31558, 18031, 18031,
  19570, 35170, 20942, 18031, 18031, 30021, 35845, 26626, 25940, 22998, 18031, 19552, 23059, 34350, 33315, 24071, 23079,
  23133, 23098, 23769, 23118, 23168, 23198, 28265, 35516, 23217, 24094, 24094, 27080, 23233, 18031, 25180, 18031, 27555,
  19951, 29653, 33725, 32235, 24830, 21523, 35549, 23252, 23268, 29446, 23286, 33756, 29877, 24094, 26781, 18031, 19790,
  18031, 27966, 18031, 27232, 32235, 23768, 30020, 28265, 28265, 28534, 20916, 24094, 24094, 22037, 32055, 18031, 18031,
  18031, 23043, 35166, 37841, 28265, 28265, 23322, 24094, 24094, 23371, 18031, 26370, 18031, 18390, 23431, 34254, 37995,
  29255, 28494, 23460, 18031, 35098, 23480, 35259, 36582, 23503, 18031, 35158, 23411, 37555, 32350, 18031, 35458, 36585,
  26667, 27406, 26669, 34993, 23524, 23549, 27403, 35980, 35981, 23592, 26811, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 19893, 18031, 18264, 18031, 18031, 18028, 34510, 18031,
  23628, 25129, 23644, 23694, 23707, 23715, 23731, 23747, 19771, 18031, 18031, 18031, 37033, 18031, 18031, 31558, 18031,
  28456, 19570, 23763, 18031, 28459, 34713, 26229, 24201, 25338, 25940, 20879, 23785, 19552, 37620, 23846, 33315, 18031,
  37514, 23864, 23890, 32845, 21748, 23918, 23938, 23954, 35516, 23973, 29557, 24094, 27080, 18031, 18031, 28790, 21114,
  22351, 18031, 18031, 35166, 32235, 24003, 25080, 28265, 28265, 28265, 36990, 20898, 24094, 24094, 24094, 24042, 18031,
  18031, 24058, 22352, 18031, 27232, 32235, 27853, 37122, 28265, 28265, 26588, 20916, 24093, 24094, 30499, 32055, 18031,
  18031, 18031, 33631, 34836, 29422, 28265, 31955, 37489, 24111, 33528, 33835, 33441, 36002, 18031, 22682, 24128, 28409,
  22790, 26139, 36588, 36277, 18031, 27232, 37115, 28265, 36582, 36587, 33563, 27233, 23411, 36502, 27251, 18031, 35458,
  36585, 26667, 27406, 18607, 24153, 34648, 24174, 27403, 35980, 35981, 36192, 26811, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 19893, 18031, 20222, 24217, 18031, 18028, 24234,
  18031, 19075, 21718, 24287, 24303, 24318, 24326, 24342, 24358, 19771, 20646, 33859, 24374, 37443, 24419, 19692, 27829,
  24450, 37731, 24494, 24542, 24558, 35654, 28175, 24596, 24612, 24642, 25940, 24720, 21069, 25831, 24736, 18031, 24775,
  24807, 18031, 27168, 32235, 24825, 18031, 24848, 24938, 24863, 24965, 34890, 25304, 25000, 31043, 25038, 25068, 34941,
  25103, 25145, 28902, 25196, 31741, 25227, 31726, 25256, 33687, 21632, 27012, 27919, 25286, 25328, 25361, 25394, 25428,
  25485, 22455, 18503, 22352, 25518, 25552, 25599, 25621, 25646, 25754, 34682, 25662, 20916, 25678, 32523, 23987, 32055,
  25991, 37602, 38336, 26174, 34800, 25712, 25742, 29815, 34770, 25778, 33508, 25817, 18031, 32973, 25859, 28674, 25878,
  27110, 25903, 25927, 25956, 18193, 25981, 26015, 26046, 25270, 26062, 29358, 26078, 26101, 27002, 26125, 28111, 18202,
  35746, 26155, 26190, 23533, 26225, 26245, 26273, 36404, 26289, 35980, 26328, 36192, 26811, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 19893, 18031, 18031, 26368, 18031, 18028,
  35715, 26386, 27684, 29788, 26403, 26418, 26433, 26441, 26457, 26473, 19771, 18031, 38171, 18031, 37033, 18031, 18031,
  31558, 34732, 18031, 20318, 23102, 18031, 34737, 34742, 35238, 23576, 32280, 25940, 26489, 18031, 19552, 26528, 18031,
  33315, 35348, 26548, 18528, 32235, 23144, 18031, 26570, 28265, 28265, 35516, 30788, 24094, 24094, 27080, 18031, 18031,
  18031, 18031, 22351, 18031, 18031, 35166, 32235, 26604, 25080, 28265, 28265, 32407, 29446, 20898, 24094, 24094, 26623,
  26781, 18031, 18031, 18031, 22352, 18031, 26642, 34806, 23768, 30020, 28265, 37316, 28266, 20916, 24094, 25405, 24094,
  32055, 18031, 18031, 18031, 24809, 35166, 26663, 28265, 28265, 26685, 24094, 24094, 26716, 18031, 18031, 18031, 27233,
  34104, 28265, 22790, 24094, 36588, 18031, 18031, 27232, 37115, 28265, 36582, 36587, 26751, 27233, 23411, 22791, 24095,
  18031, 35458, 36585, 26667, 27406, 26669, 27408, 23415, 34564, 27403, 35980, 26768, 26797, 26811, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 19893, 18031, 18031, 18031, 18031,
  18028, 18031, 26834, 18031, 26835, 26852, 26867, 26880, 26881, 26897, 26913, 19771, 18031, 18031, 18031, 37033, 18031,
  18031, 31558, 18031, 18031, 19570, 35170, 18031, 18031, 18031, 30021, 24201, 24094, 25940, 20879, 18031, 19552, 18030,
  18031, 33315, 24396, 18031, 19572, 32235, 23769, 18031, 25085, 28265, 28265, 35516, 24094, 24094, 24094, 27080, 18031,
  18031, 18031, 18031, 18031, 23848, 18031, 35166, 32235, 21511, 25080, 28265, 28265, 28265, 29446, 20898, 24094, 24094,
  24094, 28124, 18031, 19422, 23236, 18031, 18031, 27232, 36042, 23768, 26929, 28265, 35541, 28266, 20007, 24094, 36536,
  24094, 26310, 18031, 18031, 18031, 18031, 35166, 37841, 28265, 28265, 26934, 24094, 24094, 36587, 18031, 24832, 18031,
  26950, 34104, 28265, 22790, 24094, 36588, 19196, 21803, 26970, 37115, 28265, 36582, 36587, 18031, 26989, 30707, 27028,
  27067, 19165, 27096, 27154, 26667, 27406, 26669, 27408, 23415, 34564, 27403, 35980, 35981, 27192, 26811, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 19893, 18031, 18031, 18031,
  18031, 18028, 18031, 18031, 18031, 18031, 18048, 22478, 18031, 38413, 24509, 22276, 19771, 18031, 18031, 18651, 37033,
  18031, 18031, 24784, 18031, 32554, 19570, 34841, 24791, 32921, 27229, 23347, 36379, 27249, 27267, 20879, 18031, 27307,
  30397, 19898, 33315, 18031, 18031, 19572, 32235, 23769, 18031, 25085, 28265, 23569, 35516, 24094, 24094, 33831, 27080,
  18031, 18031, 18031, 18031, 18031, 18031, 24403, 35166, 32235, 27335, 25080, 28265, 28265, 28265, 35324, 20898, 24094,
  24094, 37748, 28124, 27359, 18031, 18031, 18031, 18031, 27232, 32235, 27176, 23487, 28265, 28265, 28266, 28808, 24094,
  24094, 24094, 26310, 18031, 33079, 18031, 18031, 35166, 37841, 28265, 28265, 30480, 24094, 24094, 23296, 32217, 18031,
  18031, 27233, 34104, 28265, 22790, 24094, 36588, 18031, 18031, 27232, 37115, 28265, 36582, 36587, 31518, 27233, 27376,
  27399, 29386, 18031, 27424, 27444, 26667, 27406, 26669, 27408, 23415, 34564, 27403, 35980, 35981, 36192, 26811, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 19893, 18031, 18031,
  27479, 18031, 18028, 27569, 27501, 27521, 27525, 27541, 27593, 27606, 27614, 27630, 27646, 19771, 18031, 18031, 18031,
  27662, 18031, 18031, 31558, 27700, 33365, 29501, 31581, 21867, 35493, 27724, 35505, 22513, 27745, 27781, 20879, 18031,
  21075, 18030, 24385, 27820, 18031, 18031, 27845, 27869, 27893, 18031, 27909, 37391, 28382, 35516, 25371, 36130, 27935,
  27080, 25536, 33376, 18031, 27982, 25801, 27675, 29779, 35166, 28017, 34190, 25080, 28265, 34373, 36915, 28043, 20898,
  24094, 34885, 28083, 28124, 18031, 21946, 28146, 28165, 18031, 27232, 32235, 23768, 34112, 28265, 28265, 28266, 27291,
  24094, 24094, 24094, 26310, 31318, 32955, 28200, 28216, 28239, 22484, 37148, 28264, 26934, 33026, 28282, 36587, 28301,
  18031, 18031, 28336, 28367, 28398, 28425, 28475, 28510, 18031, 30678, 28558, 28583, 28606, 22537, 22383, 28635, 33717,
  23411, 22791, 24095, 28669, 35458, 36585, 32863, 27406, 18582, 28690, 23415, 34564, 27403, 21905, 35981, 36192, 28735,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 19893, 18031,
  18031, 18031, 18031, 18028, 18031, 18031, 18031, 18031, 18048, 22478, 18031, 38413, 24509, 22276, 19771, 18031, 18031,
  18031, 37033, 18031, 21245, 31558, 18031, 18031, 19570, 35170, 18031, 18031, 18031, 30021, 24201, 24094, 25940, 20879,
  18031, 19552, 18030, 18031, 33315, 18031, 18031, 19572, 32235, 23769, 18031, 25085, 28265, 28265, 35516, 24094, 24094,
  24094, 27080, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 35166, 32235, 24830, 25080, 28265, 28265, 28265, 29446,
  20898, 24094, 24094, 24094, 28124, 18031, 18031, 18031, 18031, 18031, 27232, 32235, 23768, 30020, 28265, 28265, 28266,
  20007, 24094, 24094, 24094, 26310, 18031, 18031, 18031, 18031, 35166, 37841, 28265, 28265, 26934, 24094, 24094, 36587,
  18031, 18031, 18031, 27233, 34104, 28265, 22790, 24094, 36588, 18031, 18031, 27232, 37115, 28265, 36582, 36587, 18031,
  27233, 23411, 22791, 24095, 18031, 35458, 36585, 26667, 27406, 26669, 27408, 23415, 34564, 27403, 35980, 35981, 36192,
  26811, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 19893,
  18031, 18031, 36810, 18031, 18028, 20094, 28758, 18031, 28779, 28824, 28839, 28852, 28853, 28869, 28885, 19771, 18031,
  28901, 18031, 37033, 26532, 28918, 31558, 26387, 18031, 36319, 35170, 28965, 28956, 28981, 34588, 24201, 24980, 33769,
  29029, 18031, 27505, 29054, 29087, 33315, 29034, 28653, 26647, 37863, 23769, 29122, 29148, 25578, 29176, 29200, 31077,
  29236, 33003, 27080, 29271, 18031, 29291, 26836, 18031, 18031, 18031, 34095, 32235, 24830, 26257, 29307, 29329, 34250,
  29446, 29346, 29374, 20900, 24094, 28124, 23082, 29996, 18031, 29402, 18031, 27232, 32235, 29418, 30020, 28265, 37484,
  29438, 20007, 24094, 30806, 25689, 26310, 29462, 18031, 21200, 18031, 21681, 37841, 29184, 28265, 26934, 25696, 24094,
  36587, 34283, 18031, 32065, 18066, 34104, 29481, 23922, 24094, 36588, 32131, 18031, 29498, 37115, 28265, 36582, 36587,
  26607, 27233, 23411, 37888, 27765, 18031, 35458, 36585, 26667, 27406, 26669, 27408, 23415, 34564, 29517, 20139, 35981,
  29573, 26811, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  19893, 18031, 18031, 30453, 18031, 18028, 18031, 29616, 18031, 29610, 29639, 29674, 29687, 29695, 29711, 29727, 20958,
  18031, 29751, 18031, 37033, 31559, 18031, 31558, 20239, 18031, 26973, 35170, 29752, 29743, 23063, 24137, 24201, 25015,
  25940, 20879, 24077, 19552, 18030, 32740, 33315, 18031, 18031, 19572, 32235, 29768, 36301, 29804, 35462, 32415, 35516,
  31086, 29966, 29530, 27080, 34289, 22073, 18031, 18031, 21434, 18031, 18031, 35166, 32235, 24830, 25080, 29831, 37987,
  28265, 29446, 29858, 29871, 29893, 24094, 28124, 32775, 28931, 18031, 29100, 29912, 27232, 32235, 23768, 30020, 32467,
  23201, 29937, 20007, 25378, 24094, 29961, 26310, 18031, 18031, 18031, 18031, 35166, 37841, 28265, 28265, 26934, 24094,
  24094, 36587, 18031, 18031, 18031, 27233, 34104, 28265, 22790, 24094, 32578, 18031, 18031, 27232, 37115, 28265, 36582,
  36587, 18031, 27233, 23411, 22791, 24095, 18031, 35458, 36585, 35974, 29982, 30017, 27408, 23415, 34564, 27403, 35980,
  35981, 36192, 26811, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 19893, 18031, 18031, 28001, 18031, 30037, 18031, 30057, 19786, 23659, 30082, 30129, 30142, 30158, 30173, 30189,
  19771, 18031, 33308, 18031, 20973, 30205, 18031, 31558, 33295, 30292, 35129, 30230, 30265, 30281, 30308, 36656, 30338,
  26700, 25940, 30354, 18031, 30382, 30424, 26169, 35815, 34135, 21218, 38268, 32236, 23874, 30445, 30469, 28713, 35251,
  35516, 33017, 30496, 30515, 27080, 30536, 18031, 30553, 18031, 27360, 18031, 18031, 28567, 32235, 34500, 25080, 37280,
  28265, 28265, 29446, 30575, 24094, 24094, 24094, 28124, 22654, 18031, 36431, 18031, 30988, 30591, 32235, 30626, 22865,
  28265, 37399, 37578, 28067, 24094, 26209, 35945, 22393, 30648, 30892, 30676, 30975, 30694, 30723, 29160, 30753, 30773,
  20150, 22204, 30830, 27729, 30856, 30878, 18318, 34104, 30913, 22790, 30938, 36588, 33334, 18031, 37455, 33122, 31145,
  21982, 30961, 31010, 38054, 25565, 25726, 31030, 23678, 31059, 31110, 21561, 25911, 31133, 34659, 36345, 23337, 27403,
  35980, 31173, 36192, 27206, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 19893, 18031, 18031, 30113, 18031, 18028, 18031, 21953, 18429, 18429, 31202, 31218, 31234, 31242, 31258,
  31274, 19771, 19133, 19656, 38316, 31290, 31312, 18031, 31334, 34159, 31350, 31432, 31366, 30066, 31419, 31405, 31448,
  36116, 31464, 31499, 20879, 18031, 22102, 18030, 31534, 21759, 37345, 18031, 19572, 31575, 28248, 18031, 25085, 24519,
  32096, 35516, 24094, 31479, 31597, 27080, 29275, 18031, 29106, 18031, 31632, 30041, 31667, 31687, 31711, 30632, 28522,
  28265, 35888, 28265, 31757, 31805, 24112, 31828, 22209, 28124, 18031, 31847, 18031, 18031, 18031, 27232, 32235, 27877,
  30020, 27428, 28265, 28266, 20007, 36152, 24094, 24094, 26310, 18031, 20299, 21822, 18031, 35166, 37841, 28265, 28265,
  26934, 24094, 24094, 36587, 18031, 32126, 18031, 27233, 28027, 23612, 30757, 35587, 22812, 31895, 18031, 28149, 37115,
  31914, 22602, 36587, 18031, 27233, 23411, 22791, 24095, 31931, 31950, 31971, 31987, 19620, 18676, 32016, 23415, 34564,
  27403, 35980, 32042, 32081, 29587, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 19893, 18031, 18031, 18031, 18031, 18028, 18031, 19354, 29063, 23800, 32112, 23385, 37064, 23815,
  23830, 32147, 19771, 18031, 24271, 18031, 37033, 18031, 18031, 31558, 28130, 18031, 21252, 35170, 20340, 18031, 18031,
  30021, 24201, 24094, 25940, 32163, 32199, 19552, 18030, 33174, 29594, 18031, 32216, 19572, 32233, 35427, 18031, 32252,
  25762, 28619, 35516, 22611, 36530, 32268, 27080, 18031, 26312, 18031, 27458, 35287, 18031, 18031, 35166, 32235, 24830,
  25080, 28265, 28265, 32303, 29446, 20898, 24094, 31483, 24094, 28124, 30994, 18031, 19515, 37194, 23673, 21672, 32322,
  23768, 30020, 28719, 28265, 28266, 20007, 29896, 32347, 24094, 26310, 20990, 18031, 18031, 18031, 35166, 37841, 28265,
  36370, 26934, 24094, 33034, 36587, 18031, 18031, 18031, 27233, 34104, 28265, 22790, 24094, 36588, 18031, 32366, 27232,
  32386, 36086, 36582, 32431, 18031, 27233, 23411, 22791, 24095, 18031, 35458, 22840, 32457, 27406, 37382, 27408, 23415,
  34564, 27403, 35980, 35981, 36192, 26811, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 19893, 18031, 18031, 18031, 18031, 18028, 18031, 18031, 18031, 18031, 18048, 22478, 18031,
  38413, 24509, 22276, 19771, 18031, 18031, 18031, 37033, 18031, 18031, 31558, 18031, 32503, 20542, 35170, 32499, 32490,
  32502, 24184, 22577, 32519, 32539, 20879, 18031, 19552, 18030, 18031, 33315, 18031, 18031, 19572, 32235, 23769, 18031,
  25085, 28265, 28265, 35516, 24094, 24094, 24094, 27080, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 35166, 32235,
  24830, 25080, 28265, 28265, 28265, 29446, 20898, 24094, 24094, 24094, 28124, 18031, 18031, 18031, 18031, 18031, 27232,
  32235, 23768, 30020, 28265, 28265, 28266, 20007, 24094, 24094, 24094, 26310, 18031, 18031, 18031, 18031, 35166, 37841,
  28265, 28265, 26934, 24094, 24094, 36587, 18031, 18031, 18031, 27233, 34104, 28265, 22790, 24094, 36588, 18031, 18031,
  27232, 37115, 28265, 36582, 36587, 18031, 27233, 25240, 22791, 32574, 18031, 35458, 36585, 26667, 27406, 26669, 27408,
  23415, 34564, 27403, 35980, 35981, 36192, 26811, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 19893, 18031, 18031, 18031, 32594, 32612, 18031, 20512, 32615, 18031, 32631, 32646,
  32659, 32665, 32681, 32697, 19771, 18031, 18031, 32713, 25843, 24572, 32731, 32764, 32798, 32817, 32835, 32879, 32906,
  32942, 25052, 34972, 32989, 34918, 25940, 20879, 18031, 21161, 33050, 33073, 33095, 28320, 18031, 19572, 33138, 33167,
  33190, 33225, 23607, 33244, 33816, 24094, 33264, 24094, 33280, 18031, 20882, 18031, 36769, 18031, 33331, 32183, 35166,
  25605, 21935, 28702, 22159, 28265, 29313, 33350, 33399, 20039, 24094, 35859, 28124, 18031, 33421, 28994, 33437, 29658,
  33457, 34326, 31695, 21621, 29482, 33473, 21840, 28184, 24094, 33489, 33524, 33544, 18031, 32370, 33579, 33599, 22690,
  36180, 33678, 36559, 26934, 25312, 33405, 19591, 18031, 33618, 18031, 27233, 34104, 28265, 36675, 24094, 25022, 34470,
  18031, 27232, 22140, 28265, 26204, 36587, 21026, 27233, 23411, 22791, 24095, 18031, 35458, 36585, 33658, 33703, 26669,
  27408, 33741, 23508, 27403, 35980, 33785, 33801, 26811, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 19893, 18031, 18031, 18031, 33851, 18028, 25502, 19982, 37800, 33875, 33910,
  33926, 33939, 33952, 33968, 33984, 19771, 34000, 18031, 20743, 37033, 18031, 36963, 31558, 30429, 34003, 18341, 34019,
  34062, 34054, 34081, 37267, 27383, 24915, 25940, 34128, 36800, 19552, 34151, 18031, 33315, 18031, 25442, 34175, 34211,
  35773, 29038, 34235, 37155, 28265, 35516, 24903, 28485, 24094, 27080, 30610, 34270, 34305, 21816, 18031, 18031, 18031,
  35166, 32235, 30606, 25080, 29330, 28265, 28265, 29446, 20898, 31616, 24094, 24094, 28124, 30537, 38189, 27577, 18031,
  19472, 30244, 37532, 34342, 34366, 28265, 26582, 34389, 26352, 24094, 20924, 34405, 34451, 32176, 34469, 18031, 18031,
  34486, 21895, 28265, 24877, 26934, 24094, 27138, 36587, 18031, 19344, 33583, 27233, 34104, 36626, 34536, 31094, 34560,
  18031, 25112, 33109, 34580, 34604, 34544, 36587, 29132, 34625, 34675, 34984, 24922, 34698, 34758, 34786, 38225, 34822,
  26669, 27408, 34857, 34564, 27124, 34906, 35981, 36192, 26811, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 19893, 18031, 18031, 18031, 37353, 18028, 18031, 20167, 34934, 19011,
  34957, 35009, 37090, 35047, 35062, 35078, 19771, 35094, 31381, 37790, 37033, 26735, 35114, 35145, 18031, 35186, 19570,
  35224, 35197, 35208, 35275, 35310, 22013, 28097, 25940, 35340, 25456, 19552, 35364, 18031, 36438, 26554, 35382, 35418,
  35443, 35478, 25469, 35532, 32474, 36669, 35565, 35581, 29540, 35603, 27080, 19209, 35619, 35639, 35697, 18031, 30559,
  30897, 35731, 35762, 35806, 35831, 35875, 33669, 23355, 29446, 35911, 30797, 35941, 37928, 28124, 35961, 28645, 35997,
  27051, 36018, 26085, 36038, 36058, 36080, 36102, 28265, 30737, 20007, 24657, 36151, 34435, 30840, 30322, 18031, 19001,
  18031, 36168, 23902, 23182, 36208, 25583, 24626, 36243, 36587, 36293, 25528, 34195, 36317, 36335, 36361, 24891, 36395,
  36420, 36454, 18031, 27232, 37962, 36496, 36518, 30945, 33558, 27463, 36552, 36575, 24672, 21789, 36604, 36642, 26667,
  27406, 26669, 27408, 23415, 31117, 29842, 36691, 36707, 36746, 36762, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 19893, 18031, 18031, 18031, 18725, 18028, 18031, 18469, 18031,
  18031, 36785, 36834, 36848, 36856, 36872, 36888, 19771, 18031, 18031, 18031, 22114, 19441, 18031, 31558, 18031, 18031,
  19570, 35170, 32782, 18031, 19444, 36904, 24201, 29250, 25940, 36937, 18031, 19552, 18030, 18031, 27213, 36959, 18031,
  30249, 32235, 23769, 36959, 36979, 28265, 28265, 32000, 25295, 24094, 24094, 37006, 18031, 37054, 18031, 18495, 18031,
  37080, 18031, 35166, 37106, 32890, 25080, 35895, 37138, 36221, 29446, 20898, 34871, 35925, 24094, 28124, 27958, 18031,
  18031, 18031, 31671, 27232, 37171, 23768, 30020, 36619, 28265, 28266, 20007, 33499, 24094, 24094, 32026, 18031, 37192,
  18031, 18031, 35166, 34637, 28265, 28265, 26934, 24094, 24094, 36587, 37210, 18031, 24697, 27233, 32331, 28265, 37320,
  24094, 36588, 33894, 18031, 27232, 37115, 28265, 36582, 36587, 18031, 27233, 23411, 22791, 24095, 18031, 37228, 37253,
  26667, 27406, 26669, 27408, 23415, 34564, 31157, 35980, 35981, 37301, 26811, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 19893, 18031, 18031, 18031, 18031, 18028, 18168, 20307,
  18031, 28940, 37336, 37369, 18031, 20313, 26030, 37415, 19771, 18031, 18031, 18031, 37033, 18031, 18031, 31558, 18031,
  18031, 19570, 35170, 18031, 18031, 18031, 25887, 24201, 27760, 25940, 20879, 20982, 37431, 18030, 18031, 33315, 18031,
  19254, 26954, 32235, 23769, 18031, 37471, 28265, 28265, 35516, 31812, 24094, 24094, 27080, 18031, 18031, 18031, 18031,
  37505, 18031, 37212, 35166, 37530, 24830, 25080, 28265, 37548, 37571, 29446, 20898, 22294, 30520, 24094, 28124, 18031,
  18031, 18031, 18031, 18031, 27232, 32235, 23768, 30020, 28265, 28265, 28266, 20007, 24094, 24094, 24094, 26310, 18031,
  18031, 18031, 18031, 35166, 37841, 28265, 28265, 26934, 24094, 24094, 36587, 18031, 36943, 18031, 27233, 34104, 28265,
  22790, 24094, 36588, 22448, 18031, 27232, 37115, 28265, 36582, 36587, 18031, 27233, 23411, 22791, 24095, 37594, 35458,
  36585, 26667, 27406, 26669, 27408, 23415, 34564, 27403, 35980, 35981, 36192, 26811, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 19893, 18031, 18031, 18031, 18448, 37618, 18031,
  18384, 18031, 20125, 37636, 37652, 37666, 37679, 37695, 37711, 19771, 18031, 18031, 18031, 37033, 18031, 18031, 31558,
  18031, 18031, 19570, 35170, 18031, 18031, 18031, 30021, 22190, 28285, 25940, 20879, 18031, 19552, 18030, 18031, 33315,
  26752, 18031, 19572, 32235, 23769, 18031, 25085, 28265, 28265, 35516, 24094, 24094, 24094, 27080, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 35166, 32235, 24830, 25080, 28265, 28265, 28265, 29446, 20898, 24094, 24094, 24094, 28124,
  18031, 18031, 18031, 18311, 18031, 27232, 32235, 23768, 30020, 28265, 28265, 28266, 20007, 24094, 24094, 24094, 26310,
  18031, 37727, 18031, 18031, 35166, 37841, 31915, 28265, 37237, 24094, 37747, 30814, 18031, 18031, 18031, 27233, 34104,
  28265, 22790, 24094, 36588, 18031, 18031, 27232, 37115, 28265, 36582, 36587, 18031, 27233, 23411, 22791, 24095, 18031,
  35458, 36585, 26667, 27406, 26669, 27408, 23415, 34564, 27403, 35980, 35981, 36192, 26811, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 19946, 18031, 18031, 18031, 18031, 18028,
  18031, 18031, 18031, 18031, 18048, 22478, 18031, 38413, 28351, 37764, 19771, 18031, 18031, 18031, 21192, 18031, 31514,
  31558, 18031, 34038, 19755, 35170, 24218, 37780, 32558, 23559, 24201, 29215, 25940, 20879, 18031, 30214, 37038, 19386,
  31389, 18031, 18031, 19572, 32235, 23769, 18031, 25085, 28265, 37285, 35516, 24094, 24094, 20015, 31186, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 35166, 32235, 24830, 25080, 28265, 28265, 28265, 29945, 20898, 24094, 24094, 24094,
  36271, 18031, 18031, 18031, 18031, 18031, 27232, 32235, 23768, 30020, 28265, 28265, 28266, 20007, 24094, 24094, 24094,
  25965, 18031, 18031, 18031, 18031, 35166, 37841, 28265, 28265, 26934, 24094, 24094, 36587, 18031, 18031, 18031, 27233,
  34104, 28265, 22790, 24094, 36588, 18031, 18031, 27232, 37115, 28265, 36582, 36587, 18031, 27233, 23411, 22791, 24095,
  18031, 35458, 36585, 26667, 27406, 26669, 27408, 23415, 34564, 27403, 35980, 35981, 36192, 26811, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 19893, 18031, 18031, 18031, 18031,
  18028, 18031, 18031, 18031, 18031, 18048, 22478, 18031, 38413, 24509, 22276, 19771, 33887, 18031, 18031, 37033, 18031,
  18031, 37816, 18031, 18031, 19570, 35170, 18031, 18031, 18031, 31772, 23444, 19497, 25940, 20879, 18031, 33642, 18030,
  18031, 33315, 18031, 18031, 19572, 32235, 37838, 31879, 25085, 28265, 33228, 35516, 24094, 24094, 25345, 27080, 23035,
  18031, 18031, 18031, 18031, 18031, 32965, 35166, 37857, 24830, 25080, 37879, 33248, 28265, 29446, 37913, 24094, 34426,
  24094, 28124, 27343, 18031, 18031, 18031, 18031, 27232, 37953, 23768, 30020, 22873, 28265, 28266, 20007, 29220, 24094,
  24094, 26310, 18031, 18031, 18031, 34065, 26109, 37841, 37978, 32398, 36227, 38011, 34417, 38016, 18031, 18031, 21020,
  27233, 34104, 28265, 22790, 24094, 36135, 18031, 33602, 27232, 37115, 32306, 36582, 28439, 18031, 27233, 23411, 22791,
  24095, 18031, 35458, 36585, 26667, 27406, 26669, 27408, 23415, 34564, 27403, 35980, 35981, 36192, 26811, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 19893, 18031, 18031, 18031,
  18031, 18028, 18031, 18031, 18031, 18031, 38032, 22478, 18031, 38413, 24509, 22276, 19771, 18031, 18031, 18031, 37033,
  18031, 18031, 31558, 18031, 18031, 19570, 35170, 18031, 18031, 18031, 30021, 24201, 24094, 25940, 20879, 18031, 19552,
  18030, 18031, 33315, 18031, 18031, 19572, 32235, 23769, 18031, 25085, 28265, 28265, 35516, 24094, 24094, 24094, 27080,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 35166, 32235, 24830, 25080, 28265, 28265, 28265, 29446, 20898, 24094,
  24094, 24094, 28124, 18031, 18031, 18031, 18031, 18031, 27232, 32235, 23768, 30020, 28265, 28265, 28266, 20007, 24094,
  24094, 24094, 26310, 18031, 18031, 18031, 18031, 35166, 37841, 28265, 28265, 26934, 24094, 24094, 36587, 18031, 18031,
  18031, 27233, 34104, 28265, 22790, 24094, 36588, 18031, 18031, 27232, 37115, 28265, 36582, 36587, 18031, 27233, 23411,
  22791, 24095, 18031, 35458, 36585, 26667, 27406, 26669, 27408, 23415, 34564, 27403, 35980, 35981, 36192, 26811, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18231, 18031, 18031,
  18031, 18031, 38070, 22324, 38098, 38123, 22332, 38144, 38153, 38081, 38128, 38107, 22254, 24759, 18031, 18031, 18031,
  37033, 18031, 18031, 38169, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18630, 18031, 24751, 18031, 18031,
  19552, 18030, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18231, 18031,
  18031, 18031, 18031, 18028, 18031, 38243, 38187, 18031, 18048, 38205, 35394, 35402, 38241, 33383, 24759, 18031, 18031,
  18031, 37033, 18031, 18031, 18031, 18031, 18031, 19417, 18031, 18031, 18031, 18031, 18031, 18630, 18031, 24751, 18031,
  18031, 19552, 18030, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18231,
  18031, 18031, 18031, 18031, 18028, 18031, 18031, 18031, 18031, 38259, 38284, 38297, 38297, 38313, 19221, 24759, 18031,
  18031, 18031, 37033, 18031, 18031, 38332, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18630, 18031, 24751,
  18031, 18031, 19552, 18030, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18231, 18031, 18031, 18031, 18031, 18028, 18031, 18031, 18031, 18031, 18048, 18031, 18031, 18031, 18031, 18283, 19771,
  18031, 18031, 18031, 37033, 18031, 18031, 18031, 18031, 18031, 19570, 35170, 18031, 18031, 18031, 30021, 24201, 24094,
  25791, 18031, 18031, 19552, 18030, 18031, 18031, 18031, 18031, 19572, 32235, 23769, 18031, 35460, 28265, 28265, 21312,
  24094, 24094, 24094, 26310, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 35166, 32235, 24830, 25080, 28265, 28265,
  28265, 21310, 19495, 24094, 24094, 24094, 26310, 18031, 18031, 18031, 18031, 18031, 27232, 32235, 23768, 30020, 28265,
  28265, 28266, 20007, 24094, 24094, 24094, 26310, 18031, 18031, 18031, 18031, 35166, 37841, 28265, 28265, 26934, 24094,
  24094, 36587, 18031, 18031, 18031, 27233, 34104, 28265, 22790, 24094, 36588, 18031, 18031, 27232, 37115, 28265, 36582,
  36587, 18031, 27233, 23411, 22791, 24095, 18031, 35458, 36585, 26667, 27406, 26669, 27408, 23415, 34564, 27403, 35980,
  35981, 36192, 26811, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 38412, 18031, 18031, 18031, 18031, 18031, 18031, 38352, 18031, 18031, 38374, 38384, 38384, 38411, 38400,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031, 18031,
  18031, 18031, 102665, 73728, 77824, 102665, 102665, 102665, 102665, 102665, 69632, 102665, 102665, 102665, 102665,
  102665, 102665, 102665, 98568, 98568, 102665, 102665, 102665, 102665, 102665, 102665, 102665, 102665, 102665, 102665,
  102665, 102665, 0, 0, 98568, 102665, 98568, 102665, 102665, 102665, 102665, 102665, 102665, 102665, 102665, 102665,
  324, 102665, 102665, 102665, 102665, 102665, 102665, 102665, 102665, 102665, 102665, 102665, 102665, 102665, 102665,
  102665, 102665, 1, 16386, 3, 4, 0, 0, 0, 0, 0, 0, 98568, 102665, 0, 267, 268, 0, 270, 271, 0, 0, 0, 0, 266240, 0, 0,
  0, 0, 266240, 0, 0, 0, 1, 16386, 2117888, 4, 0, 0, 0, 0, 0, 262, 0, 0, 0, 0, 262, 0, 0, 0, 324, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 282, 0, 73728, 77824, 0, 0, 0, 0, 0, 69632, 0, 0, 0, 0, 0, 0, 0, 0, 1835, 0, 0, 0, 0, 0, 0,
  0, 0, 1850, 0, 0, 0, 90539, 91967, 90539, 90539, 0, 110997, 110997, 110997, 110997, 0, 0, 0, 0, 0, 405, 405, 110997,
  405, 405, 405, 405, 405, 405, 405, 405, 405, 405, 405, 405, 405, 110997, 110997, 110997, 110997, 110997, 110997,
  110997, 110997, 405, 110997, 110997, 405, 110997, 110997, 405, 110997, 110997, 110997, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 249856, 0, 267, 0, 270, 118784, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 273, 0, 1, 16386, 3, 0, 0, 324, 267,
  267, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 332, 0, 0, 0, 0, 270, 119152, 77824, 0, 0, 0, 0, 0, 69632, 0, 0, 0, 0, 0, 0, 0,
  0, 1927, 0, 0, 0, 0, 0, 0, 0, 0, 2054, 2055, 0, 0, 2057, 0, 0, 0, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548,
  522, 522, 548, 1, 16386, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 273, 274, 0, 0, 0, 0, 0, 54115, 549, 0, 0, 0, 4, 0,
  0, 0, 267, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 287, 288, 0, 0, 0, 0, 548, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
  16386, 3, 2109694, 16386, 3, 4, 0, 260, 0, 0, 0, 0, 0, 260, 0, 0, 0, 0, 0, 0, 1512, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1851,
  0, 0, 90539, 90539, 90539, 91969, 0, 0, 324, 0, 0, 122880, 122880, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 90539, 324283, 90539,
  90539, 90539, 90539, 122880, 122880, 122880, 0, 122880, 122880, 0, 0, 0, 122880, 0, 0, 122880, 122880, 0, 122880,
  122880, 122880, 122880, 0, 0, 0, 122880, 122880, 0, 0, 122880, 0, 0, 0, 0, 0, 320, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1852,
  0, 90539, 90539, 90539, 90539, 122880, 122880, 0, 0, 0, 0, 0, 0, 0, 0, 122880, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 649,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 305, 0, 876, 878, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 320, 321, 322,
  0, 0, 0, 1187, 1189, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 345, 0, 0, 0, 0, 0, 0, 324, 0, 0, 0, 0, 131072, 131072, 131072,
  0, 0, 0, 0, 0, 0, 0, 1243, 0, 0, 0, 0, 0, 0, 0, 0, 1501, 0, 999424, 0, 0, 0, 1505, 0, 0, 73728, 77824, 131072, 0, 0,
  0, 0, 69632, 0, 0, 0, 0, 0, 0, 0, 0, 90539, 90539, 90539, 91111, 90539, 90539, 91116, 90539, 131072, 131072, 131072,
  131072, 131072, 131072, 131072, 131072, 131072, 131072, 0, 0, 131072, 1, 16386, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  118784, 0, 73728, 77824, 0, 135168, 0, 0, 0, 69632, 0, 0, 0, 0, 0, 0, 0, 0, 94709, 94709, 94709, 94709, 96328, 94709,
  96330, 96331, 0, 369, 369, 0, 0, 0, 0, 0, 369, 0, 0, 0, 0, 0, 0, 0, 0, 94709, 94709, 96326, 94709, 94709, 94709,
  94709, 94709, 0, 268, 0, 271, 139264, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 522, 523, 524, 525, 0, 0, 0, 0, 0, 324, 268,
  268, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 601, 602, 0, 0, 604, 271, 73728, 139636, 0, 0, 0, 0, 0, 69632, 0, 0, 0, 0, 0, 0,
  0, 0, 94709, 96325, 94709, 94709, 94709, 96329, 94709, 94709, 549, 549, 549, 549, 549, 549, 549, 549, 549, 549, 523,
  523, 549, 1, 16386, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 139264, 0, 0, 0, 65536, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  319, 0, 0, 0, 266, 266, 325, 266, 266, 143626, 266, 266, 266, 266, 143626, 327, 266, 266, 266, 266, 0, 0, 266, 266,
  143626, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 143626, 143626, 143626,
  143687, 73728, 77824, 266, 266, 266, 266, 266, 69632, 266, 266, 266, 266, 266, 266, 266, 143626, 266, 266, 266,
  143626, 266, 266, 266, 266, 266, 266, 266, 143687, 266, 266, 266, 266, 266, 266, 143687, 266, 143626, 266, 143626,
  143626, 143626, 266, 143626, 266, 143626, 266, 266, 143626, 143626, 143626, 143626, 143626, 266, 143626, 143626, 0, 0,
  0, 266, 0, 266, 266, 143626, 266, 143626, 266, 143626, 143626, 143626, 143626, 266, 266, 266, 266, 143626, 266, 266,
  143626, 266, 266, 266, 143626, 143687, 143687, 143687, 143687, 143687, 143687, 143687, 143687, 143687, 143626, 143626,
  143626, 1, 16386, 3, 4, 0, 0, 0, 0, 0, 0, 0, 98568, 98568, 98568, 98568, 0, 0, 0, 0, 2204256, 2204256, 324, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 931, 0, 933, 0, 0, 0, 0, 324, 0, 0, 0, 0, 155648, 0, 0, 0, 0, 155648, 155648, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 155648, 0, 155648, 155648, 155648, 0, 0, 0, 0, 0, 0, 155648, 0, 0, 155648, 155648, 0, 155648, 155648,
  155648, 155648, 155648, 155648, 155648, 155648, 155648, 155648, 155648, 155648, 155648, 155648, 155648, 155648, 0, 0,
  0, 155648, 0, 0, 0, 0, 0, 155648, 155648, 155648, 155648, 0, 16386, 3, 4, 0, 0, 126976, 0, 0, 0, 0, 0, 0, 267, 268, 0,
  270, 271, 0, 0, 0, 0, 602112, 1699, 0, 0, 0, 921600, 0, 0, 0, 0, 0, 0, 350, 0, 0, 0, 0, 317, 0, 0, 0, 0, 159744,
  159744, 159744, 159744, 159744, 159744, 159744, 159744, 163840, 159744, 159744, 163840, 159744, 159744, 163840,
  159744, 159744, 0, 0, 0, 0, 0, 29198, 0, 29198, 0, 0, 159744, 0, 0, 159744, 159744, 159744, 159744, 0, 0, 0, 0, 0, 0,
  0, 159744, 0, 0, 0, 0, 0, 549, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 289, 328, 0, 328, 356, 0, 29198, 29198, 29198, 29198,
  29198, 29198, 29198, 29198, 29198, 29198, 159744, 159744, 29198, 1, 16386, 3, 4, 0, 0, 0, 0, 253952, 0, 0, 0, 0,
  253952, 0, 0, 0, 167936, 167936, 167936, 167936, 0, 0, 0, 0, 0, 0, 0, 167936, 0, 0, 0, 0, 0, 566, 0, 0, 0, 569, 570,
  571, 572, 573, 0, 0, 167936, 167936, 167936, 167936, 167936, 167936, 167936, 167936, 167936, 167936, 167936, 167936,
  167936, 167936, 167936, 167936, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 446464, 0, 0, 324, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 172032, 0, 172032, 0, 0, 0, 0, 774144, 0, 0, 913408, 0, 0, 0, 0, 495616, 0, 0, 0, 0, 0, 1204, 1205, 0, 0, 0, 0,
  1210, 0, 0, 0, 0, 0, 0, 1073152, 0, 0, 0, 1073152, 1073152, 1073152, 1, 16386, 3, 0, 73728, 77824, 0, 0, 0, 0, 0,
  69632, 172032, 172032, 0, 172032, 0, 0, 172032, 172032, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 466944, 172032,
  172032, 172032, 172032, 172032, 0, 0, 0, 0, 0, 172032, 172032, 172032, 172032, 172032, 172032, 172032, 172032, 172032,
  172032, 172032, 172032, 172032, 172032, 172032, 172032, 1, 255, 3, 4, 0, 0, 261, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 94709,
  96298, 94709, 94709, 94709, 94709, 0, 176128, 176128, 176128, 176128, 0, 0, 0, 0, 0, 0, 0, 176128, 0, 0, 0, 0, 0, 640,
  0, 0, 0, 0, 0, 646, 0, 0, 0, 0, 0, 0, 1823, 0, 0, 1825, 0, 0, 0, 0, 0, 0, 341, 0, 0, 0, 0, 0, 346, 341, 0, 0, 176128,
  176128, 176128, 176128, 176128, 176128, 176128, 176128, 176128, 176128, 176128, 176128, 176128, 176128, 176128,
  176128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 655360, 4, 82178, 82178, 0, 555, 0, 0, 0, 0, 0, 267, 268, 0, 270,
  271, 0, 0, 0, 0, 1069056, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 991232, 0, 0, 0, 0, 0, 0, 893, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 632, 0, 0, 0, 613, 0, 0, 0, 0, 225280, 0, 0, 0, 0, 0, 0, 0, 1273, 0, 0, 0, 0, 0, 0, 1522, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1208, 0, 0, 0, 0, 0, 0, 0, 29794, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735,
  94735, 94735, 94735, 94735, 95068, 94735, 0, 1709, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 925696, 0, 0, 0, 1831,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 548, 549, 0, 0, 1921, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 324, 2011, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 94735, 96245, 94735, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 0, 0, 1804, 1805, 90539, 90539, 0, 0,
  94709, 94709, 94709, 94709, 94709, 96271, 96272, 94709, 96273, 94709, 94709, 94709, 94709, 94735, 94735, 96309, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 0, 0, 94709, 94735, 94735, 94735, 94735, 94735, 96281, 96282, 94735, 96283,
  94735, 94735, 94735, 94735, 0, 0, 0, 0, 0, 196608, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 585, 586, 0, 588, 0, 0, 94709, 96304,
  94709, 94709, 94735, 96308, 94735, 94735, 94735, 94735, 94735, 96314, 94735, 94735, 0, 0, 0, 0, 0, 253952, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 645, 0, 0, 0, 0, 0, 94709, 94709, 96334, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735,
  94735, 0, 0, 0, 0, 0, 0, 0, 94709, 96374, 184870, 184870, 184870, 184870, 184870, 184870, 184870, 184870, 184870,
  184870, 0, 0, 184870, 1, 16386, 3, 4, 0, 0, 0, 249856, 0, 0, 0, 0, 249856, 0, 0, 0, 0, 0, 689, 0, 0, 0, 0, 90539,
  90539, 90539, 90539, 90539, 90820, 4, 82178, 82178, 0, 0, 0, 0, 0, 0, 0, 267, 268, 0, 270, 271, 0, 0, 0, 301, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1491, 0, 0, 0, 192918, 192918, 192918, 192918, 192918, 192918, 192918, 192918, 0, 192918,
  192918, 0, 192918, 192918, 0, 192918, 192918, 192918, 192918, 0, 0, 0, 0, 0, 0, 0, 192918, 0, 0, 0, 0, 0, 731, 0, 686,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 50106, 0, 0, 957, 1261, 0, 0, 192918, 192918, 0, 0, 0, 0, 272, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 122880, 122880, 0, 2109694, 16386, 3, 0, 192918, 192918, 192918, 192918, 192918, 192918, 192918, 192918, 192918,
  192918, 192918, 0, 1, 16386, 3, 4, 82178, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 947, 0, 0, 0, 0, 0, 0, 41229, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 949, 0, 0, 41323, 41323, 41323, 41323, 41323, 41323, 41323, 41323, 41323, 41323, 0, 0,
  41323, 1, 16386, 3, 4, 82179, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1274, 0, 1276, 0, 0, 4, 82178, 82178, 0, 0, 0, 0, 0, 0,
  0, 267, 268, 41229, 270, 271, 0, 0, 0, 310, 0, 0, 0, 0, 0, 0, 0, 0, 347, 348, 0, 349, 0, 0, 0, 45700, 50106, 0, 0, 0,
  957, 0, 0, 0, 0, 0, 0, 0, 0, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 95384, 94735, 94735, 94735,
  94735, 94735, 94735, 94735, 1393, 1612, 1395, 1613, 1397, 1614, 1399, 1615, 94735, 94735, 94735, 94735, 94735, 94735,
  94735, 94735, 95629, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 0, 0, 326, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  274, 0, 0, 0, 0, 274, 274, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2204256, 273, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 334, 4, 82178, 82178, 0, 0, 0, 0, 0, 0, 151552, 267, 268, 0, 270, 271, 0, 0, 0, 320, 0, 0, 0, 0, 0, 320,
  0, 321, 0, 320, 0, 0, 0, 0, 96388, 94709, 94709, 94709, 94709, 94709, 96394, 94735, 94735, 94735, 94735, 94735, 94735,
  95986, 94735, 94735, 94735, 94735, 95990, 94735, 95992, 94735, 94735, 208896, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 350, 0, 0, 0, 2204257, 151552, 2204257, 151552, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159744, 0, 0, 0, 0, 0, 754, 754,
  754, 754, 754, 754, 754, 754, 754, 522, 523, 524, 525, 814, 815, 815, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 289,
  290, 2204257, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 577, 0, 0, 754, 754, 754, 754, 754, 754, 754, 754, 754,
  754, 754, 754, 754, 754, 754, 754, 0, 754, 754, 754, 754, 754, 1112, 0, 0, 1112, 1117, 0, 0, 1117, 0, 0, 815, 815,
  815, 548, 549, 0, 0, 0, 4, 82178, 0, 0, 0, 0, 0, 0, 0, 1686, 0, 0, 0, 0, 0, 0, 0, 0, 343, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 90539, 90809, 90539, 90539, 90539, 90539, 815, 815, 1117, 0, 0, 1117, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 589, 0,
  0, 0, 0, 0, 754, 754, 754, 754, 754, 754, 754, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 172032, 172032, 172032, 1, 16386, 3, 754,
  754, 754, 754, 754, 754, 754, 754, 754, 754, 754, 0, 0, 0, 0, 815, 815, 815, 815, 815, 815, 815, 0, 0, 0, 0, 0, 0, 0,
  754, 754, 754, 754, 754, 754, 754, 754, 754, 754, 754, 754, 754, 754, 754, 754, 754, 754, 754, 754, 754, 754, 754,
  754, 815, 815, 815, 815, 815, 754, 754, 754, 754, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 0,
  0, 0, 0, 0, 0, 0, 754, 754, 754, 754, 815, 815, 815, 815, 0, 754, 754, 815, 815, 754, 815, 754, 815, 754, 815, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 249856, 249856, 249856, 1, 16386, 3, 0, 0, 324, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 217088,
  217088, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 307, 0, 0, 73728, 77824, 0, 0, 0, 0, 0, 69632, 0, 0, 0, 0, 217088,
  0, 0, 0, 0, 0, 507904, 0, 0, 0, 0, 90539, 90539, 90539, 90539, 90539, 508331, 217088, 217088, 217088, 217088, 217088,
  0, 0, 0, 0, 0, 217088, 217088, 217088, 217088, 217088, 217088, 217088, 217088, 217088, 217088, 217088, 217088, 217088,
  217088, 217088, 217088, 0, 0, 548, 0, 549, 0, 267, 268, 270, 271, 0, 0, 0, 0, 0, 0, 0, 1715, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 57344, 0, 0, 0, 0, 0, 0, 0, 221591, 221591, 221591, 221591, 0, 0, 0, 0, 0, 221591, 221591, 221591, 221591, 221591,
  221591, 221591, 221591, 221591, 221591, 221591, 221591, 221591, 221591, 221591, 221591, 221591, 221591, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 574, 575, 221735, 221735, 221735, 221735, 221735, 221735, 221735, 221735, 221735, 221735,
  221591, 221591, 221736, 1, 16386, 3, 257, 0, 0, 0, 0, 0, 0, 263, 0, 0, 0, 0, 0, 0, 625, 0, 0, 628, 0, 0, 0, 0, 0, 0,
  0, 131072, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 249856, 249856, 249856, 249856, 0, 0, 0, 0, 0, 249856, 249856, 249856,
  249856, 249856, 249856, 249856, 249856, 249856, 249856, 249856, 249856, 249856, 249856, 249856, 249856, 249856,
  249856, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 603, 0, 0, 212992, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 659, 0,
  0, 254360, 254360, 254360, 254360, 0, 0, 0, 0, 0, 254360, 254360, 254360, 254360, 254360, 254360, 254360, 254360,
  254360, 254360, 254360, 254360, 254360, 254360, 254360, 254360, 254360, 254360, 0, 0, 0, 0, 253952, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 282624, 282624, 0, 1, 16386, 3, 4, 0, 0, 0, 0, 270336, 0, 0, 0, 0, 267, 268, 0, 270, 271, 200704, 0, 0,
  324, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 266240, 0, 0, 266240, 0, 0, 266240, 0, 274432, 274432, 274432, 274432, 274432,
  274432, 274432, 274432, 274432, 274432, 0, 0, 274432, 1, 16386, 3, 0, 877, 879, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1224, 0, 0, 1121, 29794, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735,
  94735, 95650, 94735, 0, 1612, 0, 1613, 0, 1614, 0, 1615, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735,
  95849, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 0, 1518, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 737, 0, 4,
  82178, 82474, 0, 0, 0, 0, 0, 0, 0, 267, 268, 0, 270, 271, 0, 0, 0, 324, 324, 324, 0, 0, 611, 0, 0, 0, 0, 0, 0, 0, 898,
  0, 0, 0, 0, 0, 0, 0, 0, 1675, 0, 0, 0, 0, 0, 0, 0, 0, 73728, 77824, 0, 0, 0, 0, 0, 69632, 0, 0, 0, 0, 385, 0, 0, 0, 0,
  0, 516096, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2008, 0, 0, 0, 0, 0, 282624, 282624, 282624, 282624, 282624, 282624, 282624,
  282624, 0, 282624, 282624, 0, 282624, 282624, 0, 282624, 282624, 282624, 282624, 0, 0, 0, 0, 0, 0, 0, 282624, 0, 0, 0,
  0, 0, 896, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 917, 0, 0, 0, 0, 324, 282624, 282624, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 754, 754, 754, 754, 0, 0, 965, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1249, 0, 0, 286720, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 286720, 286720, 0, 286720, 286720, 286720, 286720, 286720, 286720, 286720, 286720, 286720, 286720, 286720, 286720,
  286720, 286720, 286720, 286720, 286720, 286720, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 921, 324, 4219433, 0, 0, 0,
  0, 0, 556, 0, 0, 0, 267, 268, 0, 270, 271, 0, 0, 0, 324, 324, 324, 0, 610, 0, 0, 0, 0, 0, 0, 0, 0, 1702, 0, 0, 0, 0,
  0, 0, 0, 275, 276, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 989, 0, 0, 0, 324, 0, 0, 0, 0, 0, 0, 0, 276, 0, 0, 0, 0,
  0, 0, 641, 0, 0, 0, 0, 0, 0, 0, 0, 0, 589, 90539, 90539, 90539, 90539, 90539, 90539, 275, 0, 276, 0, 275, 275, 276,
  276, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45700, 41323, 0, 0, 0, 0, 0, 0, 73728, 77824, 276, 0, 275, 0, 0, 69632, 0, 0, 0, 0, 0,
  0, 0, 0, 96324, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 94735, 396, 409, 409,
  409, 409, 90540, 90540, 90540, 90540, 90540, 446, 446, 409, 446, 446, 446, 446, 446, 446, 471, 482, 471, 471, 471,
  471, 471, 471, 471, 471, 492, 471, 471, 492, 471, 471, 492, 90540, 90540, 471, 94710, 94710, 94710, 94710, 94710,
  94736, 94710, 94736, 94710, 94710, 94710, 94710, 94710, 94710, 94736, 94736, 94736, 94736, 94736, 94736, 94736, 94736,
  94736, 94736, 94710, 94710, 94736, 1, 16386, 3, 650, 0, 0, 0, 0, 0, 565, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 286720, 286720,
  286720, 1, 16386, 3, 661, 0, 0, 0, 0, 667, 0, 0, 671, 0, 0, 0, 0, 677, 0, 0, 0, 0, 0, 544768, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1221, 0, 0, 0, 0, 0, 0, 0, 682, 0, 0, 0, 0, 0, 0, 686, 0, 0, 0, 0, 0, 0, 0, 135168, 0, 0, 0, 0, 0, 0, 135168, 0,
  0, 0, 0, 0, 0, 0, 135168, 0, 0, 0, 0, 0, 0, 0, 0, 587, 0, 0, 0, 0, 0, 0, 0, 686, 0, 90539, 90539, 90539, 90813, 90539,
  90539, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1327, 0, 0, 0, 0, 0, 0, 95255, 94709, 94709, 94709, 94709, 94709, 94709, 94709,
  95549, 94709, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90829, 90539, 90831, 90539, 90539, 90539, 0, 567, 0, 0,
  0, 324, 324, 324, 147456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 94709, 94709, 94709, 94709, 94709, 96302, 0, 640, 682, 0,
  94709, 94709, 94709, 94969, 94709, 94709, 94709, 94709, 94709, 94988, 94709, 94991, 94709, 94995, 94709, 94998, 94709,
  94709, 95009, 94709, 94709, 522, 523, 524, 525, 0, 94735, 94735, 1459, 0, 1461, 0, 1191, 1463, 1193, 1464, 1195, 1465,
  1197, 1466, 0, 0, 0, 0, 0, 295413, 94709, 94709, 94709, 95778, 95779, 94709, 94709, 94709, 94709, 94709, 95569, 95571,
  94709, 94709, 94709, 95574, 733685, 94709, 95575, 95577, 94709, 94735, 95030, 94735, 94735, 94735, 94735, 94735,
  95049, 94735, 95052, 94735, 95056, 94735, 95059, 94735, 94735, 1459, 1661, 1461, 1662, 1463, 1464, 1465, 1466, 0, 0,
  0, 0, 0, 0, 0, 1538, 0, 0, 0, 0, 0, 90539, 90539, 90539, 90539, 90539, 91841, 90539, 90539, 90539, 90539, 90539,
  90539, 95070, 94735, 94735, 548, 549, 0, 0, 0, 4, 82178, 0, 0, 0, 873, 875, 0, 0, 0, 324, 324, 204800, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 291, 0, 0, 0, 0, 289, 962, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 974, 0, 0, 0, 0, 0, 689111, 0, 0, 0, 0,
  315392, 0, 0, 0, 0, 0, 0, 912, 0, 0, 650, 0, 0, 0, 0, 961, 0, 91132, 90539, 90539, 90539, 90539, 90539, 90539, 0, 0,
  0, 0, 0, 0, 1034, 0, 0, 0, 0, 0, 929792, 724992, 0, 0, 0, 0, 0, 0, 1052672, 0, 0, 0, 0, 0, 966656, 0, 303104, 0, 0, 0,
  0, 1937, 0, 0, 0, 0, 0, 1241, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1703, 0, 0, 0, 0, 0, 986, 95255, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 95819, 34160, 1237, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1246, 0, 0, 0, 0, 0, 0, 732, 0, 688, 0, 0, 0, 0, 732, 0, 0, 0, 1291, 0, 0, 90539, 90539, 90539, 90539, 90539,
  90539, 90539, 91413, 90539, 90539, 90539, 90539, 0, 0, 0, 0, 0, 745472, 0, 0, 0, 0, 94709, 94709, 96390, 96391, 94709,
  94709, 94735, 94735, 96396, 96397, 94735, 94735, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 91422, 90539, 90539,
  90539, 90539, 90539, 91429, 90539, 90539, 0, 0, 0, 0, 0, 0, 0, 0, 561152, 0, 0, 0, 0, 0, 0, 1487, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 303, 305, 344, 0, 0, 0, 0, 1330, 0, 0, 1333, 0, 0, 95255, 94709, 94709, 94709, 94709, 94709, 95547, 94709,
  94709, 94709, 94709, 94735, 96189, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 96196, 569871, 94735, 94709,
  94709, 95582, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 95592, 94709, 94709, 94709,
  95002, 94709, 94709, 94709, 94709, 94709, 522, 523, 524, 525, 0, 94735, 95027, 1121, 29794, 94735, 94735, 94735,
  94735, 94735, 95614, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 95864, 94735, 94735, 94735, 94735, 94735,
  94735, 94735, 94735, 95623, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735,
  94735, 95993, 94735, 0, 1469, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1225, 0, 0, 0, 1508, 0, 1510, 0, 0, 0, 0, 0,
  1516, 0, 1261, 0, 0, 0, 0, 0, 912, 0, 0, 0, 0, 0, 0, 0, 0, 0, 324, 324, 324, 0, 0, 0, 0, 613, 0, 0, 0, 617, 0, 91655,
  91656, 91657, 90539, 90539, 90539, 90539, 90539, 90539, 91661, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 0, 0,
  0, 0, 0, 309160, 94709, 94709, 94709, 95783, 94709, 95784, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 95562, 94709, 94709, 94709, 95796, 94709, 94709, 94709, 94709, 94709, 94709, 94709,
  94709, 95805, 94709, 94709, 94709, 95809, 94709, 94709, 94709, 95003, 94709, 94709, 94709, 94709, 94709, 522, 523,
  524, 525, 0, 94735, 94735, 94735, 94735, 95996, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735,
  94735, 95661, 94735, 94735, 94735, 94735, 0, 1612, 0, 1613, 0, 1614, 0, 1615, 94735, 94735, 94735, 94735, 94735,
  94735, 95829, 94735, 94735, 94735, 94735, 96007, 94735, 94735, 94735, 94735, 94735, 96011, 94735, 1661, 1662, 0, 0, 0,
  0, 0, 1056768, 0, 0, 1056768, 0, 1056768, 1056768, 0, 1, 16386, 3, 94735, 95830, 94735, 95832, 94735, 95833, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94709, 94709, 94735, 1, 16386, 3, 94735, 95858, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 594447, 94735, 0, 1670, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 864256, 0, 0, 0, 0, 0, 1056768, 0, 0, 1056768, 0, 0, 0, 0, 1056768, 1056768, 0, 0, 0, 0,
  0, 1056768, 0, 0, 0, 0, 0, 1682, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1261, 0, 0, 0, 94709, 94709, 94709, 95976,
  94709, 94709, 94709, 94709, 94709, 95980, 94709, 1612, 1613, 1614, 1615, 94735, 94735, 94735, 94735, 96201, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1667, 0, 0, 0, 1820, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1828, 0, 0, 0, 0, 270, 270, 0, 0, 0, 0, 0, 0, 270, 0, 0, 0, 0, 0, 280, 281, 282, 283, 284, 285, 286, 0, 0,
  0, 0, 0, 0, 1926, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1489, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1845, 1846, 0, 0, 0, 0, 0, 0, 0, 90539,
  90539, 90539, 90539, 90539, 0, 0, 0, 0, 0, 0, 1739, 0, 0, 0, 94709, 94709, 90539, 90539, 90539, 90539, 91973, 90539,
  90539, 0, 0, 0, 0, 1867, 0, 94709, 94709, 94709, 94709, 95005, 94709, 94709, 95011, 94709, 522, 523, 524, 525, 0,
  94735, 94735, 96091, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94735, 94735, 94735,
  94735, 94735, 94735, 96193, 94735, 94735, 94735, 94735, 94735, 94709, 94709, 96172, 94709, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 94709, 96183, 2110, 0, 0, 0, 2113, 0, 2115, 0, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 95013, 522, 523, 524, 525, 0, 94735, 94735, 0, 2141, 0, 94709, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 94735, 94735, 94735, 94735, 96191, 94735, 94735, 94735, 94735, 94735, 94735, 94735,
  95343, 94735, 94735, 94735, 94735, 95352, 94735, 94735, 94735, 0, 0, 2178, 0, 94709, 94709, 94709, 94709, 94709,
  94709, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 2109, 0, 0, 0, 277, 278, 279, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1478, 0, 0, 0, 0, 0, 73728, 77824, 0, 0, 0, 375, 0, 69632, 0, 0, 375, 0, 0, 0, 0, 0, 0, 1848, 0,
  0, 0, 0, 0, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 91845, 397, 0, 0, 0, 0,
  90541, 90541, 90541, 90541, 90541, 397, 397, 375, 397, 397, 397, 397, 397, 397, 397, 397, 397, 397, 397, 397, 397,
  397, 397, 397, 90541, 90541, 397, 94711, 94711, 94711, 94711, 94711, 94737, 94711, 94737, 94711, 94711, 94711, 94711,
  94711, 94711, 94737, 94737, 94737, 94737, 94737, 94737, 94737, 94737, 94737, 94737, 94711, 94711, 94737, 1, 16386, 3,
  0, 1264, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1250, 0, 95952, 94709, 94709, 95953, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94735, 94735, 94735, 94735, 94735, 94735, 95983, 94735, 94735,
  95984, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 0, 0, 1918, 0, 0, 0, 0, 0, 94709,
  94709, 94709, 94709, 96354, 94709, 96356, 94709, 96358, 94709, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735,
  94735, 94735, 94735, 94735, 94735, 2079, 0, 94735, 96363, 94735, 96365, 94735, 96367, 94735, 0, 0, 0, 0, 0, 0, 0,
  94709, 94709, 95776, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 489006, 512501, 94709, 94709, 94709,
  94709, 94709, 94709, 0, 73728, 77824, 0, 285, 0, 376, 377, 69632, 377, 384, 376, 384, 0, 280, 384, 398, 410, 410, 410,
  425, 90542, 90542, 90542, 90542, 90542, 447, 447, 456, 447, 447, 447, 447, 447, 447, 472, 447, 472, 472, 486, 487,
  486, 487, 487, 487, 487, 487, 487, 487, 487, 472, 487, 487, 472, 487, 487, 472, 90542, 90542, 487, 94712, 94712,
  94712, 94712, 94712, 94738, 94712, 94738, 94712, 94712, 94712, 94712, 94712, 94712, 94738, 94738, 94738, 94738, 94738,
  94738, 94738, 94738, 94738, 94738, 94712, 94712, 94738, 1, 16386, 3, 0, 636, 0, 0, 0, 0, 0, 594, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 877, 879, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 889, 0, 0, 0, 0, 271, 271, 0, 0, 0, 0, 0, 0, 271, 0, 0, 0, 0,
  0, 522, 0, 0, 0, 524, 0, 0, 0, 0, 0, 0, 0, 1206, 0, 0, 0, 0, 0, 0, 0, 0, 1716, 1717, 0, 0, 0, 0, 0, 0, 324, 0, 923,
  889, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 577, 0, 0, 0, 0, 0, 979, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1479, 1480,
  0, 90539, 90539, 90539, 91120, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539,
  90539, 674, 0, 0, 1037, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 990, 0, 0, 0, 0, 0, 0, 0, 90539, 90539, 91110,
  90539, 90539, 90539, 90539, 90539, 90539, 90539, 1027, 0, 0, 0, 0, 0, 0, 0, 0, 0, 155648, 155648, 0, 0, 0, 0, 0, 0,
  95255, 94709, 95257, 95258, 94709, 94709, 94709, 94709, 94709, 94709, 95270, 94709, 95274, 94709, 94709, 94709, 94709,
  95954, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 520693, 94709, 94709, 94709, 95279, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 95808, 94709, 94709, 95332, 95333,
  94735, 94735, 94735, 94735, 94735, 94735, 95345, 94735, 95349, 94735, 94735, 94735, 94735, 95354, 0, 0, 1201, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1504, 0, 0, 94709, 95566, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 95578, 94709, 95580, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 96090, 94709, 1121, 29794, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 95616, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 934415, 94735, 94735, 94735, 94735, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1467, 0, 95974, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 1612, 1613, 1614, 1615, 94735,
  94735, 94735, 94735, 96366, 94735, 96368, 0, 0, 0, 0, 0, 0, 0, 94709, 94709, 94709, 94970, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 95587, 94709, 94709, 95590, 938485, 94709, 94709, 94709, 94735, 96005, 94735, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 1661, 1662, 0, 0, 0, 0, 353, 90552, 90552, 90552, 90552,
  90552, 0, 0, 353, 0, 0, 0, 0, 0, 1536, 1537, 0, 1539, 0, 0, 0, 1537, 90539, 90539, 90539, 0, 0, 0, 0, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94735, 94735, 94735, 90539, 90539, 91971, 90539, 90539, 90539,
  91975, 0, 1865, 0, 0, 0, 1868, 94709, 94709, 94709, 94709, 95007, 94709, 94709, 94709, 94709, 522, 523, 524, 525, 0,
  94735, 94735, 0, 0, 0, 1924, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 587, 0, 0, 0, 90539, 90539, 90539, 92064, 90539,
  90539, 90539, 0, 0, 0, 0, 0, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 373237, 94709, 94709, 94709, 96197,
  96198, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 0, 0, 0, 0, 0, 2163, 0, 94709, 94709, 0,
  0, 0, 94709, 94709, 94709, 96353, 94709, 94709, 94709, 94709, 94709, 94709, 94735, 94735, 94735, 96310, 94735, 94735,
  94735, 94735, 94735, 94735, 0, 0, 96362, 94735, 94735, 94735, 94735, 94735, 94735, 0, 0, 0, 0, 0, 0, 0, 94709, 94709,
  94709, 94709, 94709, 94979, 94709, 94709, 94709, 94709, 94709, 94709, 95303, 94709, 94709, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 522, 523, 524, 525, 0, 94735, 95024, 0, 0, 94709, 94709, 94709, 94709, 94735, 94735, 94735,
  94735, 0, 94709, 96416, 94735, 96417, 94709, 94709, 94709, 95280, 541173, 94709, 94709, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 96087, 94709, 94709, 94709, 94709, 0, 0, 351, 288, 0, 0, 0, 0, 288, 0, 0, 0, 0, 0,
  0, 287, 0, 73728, 77824, 0, 0, 0, 330, 0, 69632, 0, 0, 330, 0, 386, 392, 0, 0, 0, 339, 0, 0, 0, 0, 0, 339, 0, 0, 0,
  339, 0, 0, 0, 0, 1520, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 684032, 0, 0, 0, 0, 399, 411, 411, 411, 411, 90543, 90543,
  90543, 90543, 90543, 448, 448, 457, 448, 448, 448, 448, 448, 448, 473, 448, 473, 473, 473, 473, 473, 473, 473, 473,
  473, 473, 473, 473, 473, 473, 473, 90543, 90543, 473, 94713, 94713, 94713, 94713, 94713, 94739, 94713, 94739, 94713,
  94713, 94713, 94713, 94713, 94713, 94739, 94739, 94739, 94739, 94739, 94739, 94739, 94739, 94739, 94739, 94713, 94713,
  94739, 1, 16386, 3, 90539, 90539, 90823, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 499712, 0, 0, 0, 0, 0, 0, 899, 0, 0, 902, 0, 904, 905, 0, 0, 0, 361, 0, 0, 0, 353, 0, 361, 0,
  0, 0, 361, 353, 0, 0, 0, 478, 0, 478, 478, 478, 478, 478, 478, 478, 478, 478, 496, 90552, 478, 94722, 94722, 94722,
  94722, 94722, 94748, 94722, 94748, 94722, 94722, 94722, 94722, 94722, 94722, 0, 937, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1277, 0, 0, 0, 0, 688128, 0, 0, 689027, 0, 90539, 315819, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 0,
  0, 0, 0, 920, 1033, 0, 0, 0, 90539, 90539, 500139, 90539, 90539, 90539, 90539, 90539, 90539, 689141, 90539, 91127,
  90539, 90539, 90539, 90539, 0, 0, 0, 0, 1011712, 0, 0, 0, 0, 0, 95950, 94709, 0, 95255, 94709, 315893, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94735, 94735, 94735, 96104, 500213, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 689210, 94709, 95292, 94709, 95294,
  94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 95962, 94709, 94709,
  315919, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 500239, 94735, 94735,
  94735, 94735, 94735, 95862, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 1020431, 90539, 91432, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1040384, 0, 0, 0, 0, 565, 0, 0, 567, 568, 0, 0, 0, 0, 0, 0, 0, 0, 135168, 0, 0, 0, 0, 1,
  16386, 3, 95665, 94735, 0, 1188, 0, 1190, 0, 1463, 0, 1464, 0, 1465, 0, 1466, 0, 1468, 1494, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1503, 0, 0, 0, 0, 0, 966, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 901, 0, 0, 0, 0, 0, 377359, 94735, 94735, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 0, 95982, 94735, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 95635, 90539, 91970, 90539,
  90539, 90539, 90539, 90539, 0, 0, 0, 0, 0, 0, 94709, 94709, 94709, 94709, 94709, 94976, 94709, 94709, 94985, 94709,
  94709, 94709, 94709, 94709, 94735, 94735, 96336, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 0, 0, 0, 0, 2162, 0,
  2164, 94709, 94709, 94735, 94735, 96364, 94735, 94735, 94735, 94735, 0, 0, 0, 0, 0, 0, 0, 94709, 94709, 94709, 94709,
  94709, 508405, 94709, 94709, 94709, 94709, 94709, 94709, 95556, 94709, 94709, 94709, 94709, 94709, 94709, 94709,
  94709, 94709, 522, 523, 524, 525, 0, 94735, 94735, 291, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 638, 0, 328, 0,
  329, 0, 0, 0, 0, 0, 0, 289, 329, 291, 291, 328, 0, 0, 0, 522, 522, 522, 0, 524, 522, 524, 522, 522, 522, 522, 522,
  522, 0, 523, 0, 524, 0, 525, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 589, 0, 73728, 77824, 0, 0, 0, 0, 0, 69632,
  0, 0, 0, 290, 0, 0, 290, 400, 412, 422, 412, 412, 90544, 90544, 90544, 90544, 90544, 449, 449, 412, 449, 449, 449,
  464, 466, 449, 449, 464, 474, 449, 474, 474, 474, 474, 474, 474, 474, 474, 493, 474, 474, 493, 474, 474, 493, 90544,
  90544, 474, 94714, 94714, 94714, 94714, 94714, 94740, 94714, 94740, 94714, 94714, 94714, 94714, 94714, 94714, 94740,
  94740, 94740, 94740, 94740, 94740, 94740, 94740, 94740, 94740, 94714, 94714, 94740, 1, 16386, 3, 0, 0, 592, 593, 0,
  595, 0, 0, 0, 0, 600, 0, 0, 0, 0, 0, 0, 942, 0, 0, 0, 946, 0, 0, 0, 0, 0, 0, 967, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1032192, 0, 0, 0, 0, 0, 0, 0, 621, 0, 0, 0, 0, 0, 0, 0, 629, 0, 0, 0, 633, 0, 0, 0, 523, 523, 523, 0, 525, 523, 525,
  523, 523, 523, 523, 523, 523, 0, 662, 0, 0, 0, 668, 669, 0, 0, 0, 0, 0, 676, 0, 678, 0, 0, 0, 548, 0, 549, 267, 0,
  268, 0, 270, 0, 271, 0, 0, 0, 0, 0, 750, 751, 0, 0, 682, 0, 0, 0, 0, 0, 743, 712704, 0, 0, 0, 0, 0, 712704, 0, 0, 0,
  90539, 90539, 90812, 90539, 90815, 90539, 0, 94709, 94709, 94709, 94709, 94709, 94735, 94709, 94735, 94709, 94709,
  94709, 94709, 94709, 94709, 95283, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 95307, 94709, 94709,
  94709, 94709, 94709, 94709, 90539, 573867, 90539, 660169, 90539, 713131, 90539, 90539, 90830, 90832, 90539, 90539,
  90539, 0, 0, 678, 0, 573440, 0, 660112, 0, 0, 0, 0, 612, 0, 0, 0, 712704, 736, 0, 0, 0, 0, 623, 0, 0, 626, 0, 0, 0, 0,
  0, 0, 0, 0, 523, 0, 0, 0, 525, 0, 0, 0, 0, 660112, 744, 0, 94709, 94709, 94967, 94709, 94972, 94709, 94709, 573941,
  94709, 660237, 94709, 713205, 94709, 94709, 94997, 95000, 95004, 94709, 94709, 94709, 94709, 522, 523, 524, 525, 0,
  94735, 94735, 94735, 94735, 94735, 95985, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 520719,
  95028, 94735, 95033, 94735, 94735, 573967, 94735, 660298, 94735, 713231, 94735, 94735, 95058, 95061, 95065, 94735,
  94735, 94735, 94735, 414223, 94735, 94735, 95835, 94735, 94735, 94735, 94735, 94735, 94735, 528911, 94735, 94735,
  94735, 94735, 631311, 94735, 94735, 94735, 94735, 94735, 96252, 94735, 94735, 94735, 94735, 0, 1661, 0, 1662, 1463,
  1464, 1465, 1466, 0, 1664, 0, 0, 0, 0, 0, 0, 1833, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1264, 0, 0, 0, 0, 0, 0, 0, 877, 879, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 891, 324, 0, 0, 0, 0, 0, 0, 0, 0, 929, 0, 0, 0, 0, 934, 0, 0, 0, 548, 549, 0, 0, 0,
  4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 267, 268, 0, 270, 271, 0, 0, 0, 953, 645, 0, 0, 911, 0, 0, 650, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 658, 0, 0, 0, 0, 0, 0, 658, 0, 0, 0, 963, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1720, 0, 90539, 90539,
  91134, 90539, 91136, 90539, 90539, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 897024, 0, 95255, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 95275, 94709, 94709, 94709, 95296, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 95311, 94709, 94709, 94709, 94709, 95966, 94709, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 95972, 94709, 94709, 94709, 94709, 96094, 94709, 94709, 94709, 94709, 94709, 94709, 96100, 94735,
  94735, 94735, 94735, 94735, 95337, 94735, 94735, 95348, 94735, 94735, 95351, 94735, 94735, 94735, 94735, 94735, 94735,
  639503, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 860687, 94735, 94735, 889359, 94735, 94735,
  2047, 94709, 95278, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 95288, 94709, 94709, 94709, 94709, 94709,
  0, 0, 0, 0, 0, 0, 0, 0, 29794, 95255, 94735, 94709, 95316, 94709, 94709, 94709, 0, 1114, 1116, 0, 0, 1119, 1121, 0,
  29794, 95255, 94735, 94735, 94735, 95036, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735,
  94735, 2000, 0, 0, 0, 95371, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 95386, 94735, 94735,
  94735, 95391, 94735, 94735, 94735, 95037, 94735, 94735, 95046, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735,
  94735, 96123, 94735, 0, 0, 0, 0, 0, 0, 360448, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1212, 0, 0, 0, 0, 693, 0, 0, 0, 0, 0,
  693, 0, 0, 0, 0, 635, 0, 1214, 0, 0, 1216, 733184, 0, 1218, 1219, 0, 0, 1222, 0, 0, 0, 0, 0, 0, 95255, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 95576, 94709, 0, 1238, 0, 0, 0, 0,
  734426, 0, 1244, 0, 0, 0, 0, 0, 0, 0, 0, 819200, 0, 0, 0, 0, 0, 0, 0, 270, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 287, 0, 0, 1254, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1261, 970752, 0, 0, 0, 548, 549, 0, 0, 0, 4, 0, 0, 0, 0, 872, 874,
  0, 0, 0, 0, 278528, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1234, 0, 0, 0, 0, 1279, 1280, 1281, 0, 0, 483328, 0, 0, 0, 0, 0,
  0, 0, 1288, 0, 0, 0, 0, 754, 754, 754, 754, 754, 754, 815, 815, 815, 815, 815, 815, 0, 90539, 90539, 90539, 91419,
  90539, 90539, 91421, 90539, 90539, 90539, 90539, 90539, 91428, 90539, 90539, 90539, 0, 0, 0, 0, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 96233, 94709, 0, 0, 1332, 0, 360448, 360448, 95255, 95542, 95543, 95544, 94709, 94709,
  94709, 360949, 94709, 94709, 94709, 94709, 96175, 94709, 94709, 627189, 94709, 94709, 94709, 94709, 94709, 94709,
  96182, 96184, 1121, 29794, 95609, 95610, 95611, 94735, 94735, 94735, 360975, 94735, 94735, 94735, 94735, 94735, 94735,
  94735, 95344, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 95363, 94735, 94735, 94735, 94735, 94735, 94735,
  94735, 94735, 95988, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 95624, 94735, 94735, 94735,
  483855, 94735, 94735, 95630, 94735, 94735, 94735, 94735, 94735, 94735, 95045, 94735, 94735, 94735, 94735, 94735,
  94735, 94735, 94735, 94735, 94735, 963087, 94735, 94735, 94735, 94735, 94735, 95636, 95638, 94735, 94735, 94735,
  95641, 733711, 94735, 95642, 95644, 94735, 94735, 94735, 94735, 94735, 94735, 95339, 94735, 94735, 94735, 94735,
  94735, 94735, 94735, 94735, 94735, 95837, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 95653, 94735, 94735,
  901647, 94735, 94735, 94735, 95658, 94735, 95660, 94735, 94735, 94735, 94735, 94735, 94735, 95847, 94735, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 95659, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 95666, 0,
  1188, 0, 1190, 0, 1463, 0, 1464, 0, 1465, 0, 1466, 0, 0, 0, 0, 882, 981, 982, 0, 0, 0, 0, 0, 0, 988, 0, 0, 0, 0, 895,
  0, 0, 0, 0, 0, 0, 0, 903, 0, 0, 906, 0, 1040, 0, 0, 0, 0, 0, 0, 0, 1040, 0, 0, 922, 0, 0, 0, 1471, 1472, 0, 0, 0,
  1476, 0, 0, 0, 0, 0, 0, 0, 271, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 311, 0, 0, 0, 1019904, 0, 0, 0, 0, 0, 0, 1523, 0,
  1525, 0, 0, 0, 0, 0, 0, 0, 614400, 0, 0, 0, 0, 0, 0, 0, 0, 1207, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1533, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1472, 90539, 90539, 90539, 0, 0, 0, 0, 94709, 94709, 94709, 381429, 96230, 96231, 94709, 94709, 94709, 94709,
  95281, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 0, 0, 0, 0, 95981, 90539, 90539,
  90539, 90539, 90539, 91659, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 91427, 90539,
  90539, 90539, 91431, 91667, 90539, 90539, 90539, 90539, 90539, 1020331, 90539, 1557, 0, 0, 0, 0, 0, 0, 0, 273, 274, 0,
  273, 274, 273, 0, 274, 0, 0, 0, 1565, 0, 0, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709,
  95782, 94709, 94709, 95813, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 1020405, 94709, 94709,
  34160, 94735, 94735, 95831, 94735, 94735, 94735, 94735, 94735, 95836, 94735, 95838, 94735, 94735, 94735, 94735, 94735,
  94735, 95863, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 95989, 94735, 94735, 94735, 94735, 94735,
  94735, 90539, 90539, 90539, 905643, 0, 0, 503808, 0, 0, 0, 0, 0, 0, 802816, 94709, 94709, 94709, 94709, 96238, 94709,
  94709, 94709, 94709, 94709, 94709, 94735, 94735, 94735, 381455, 96243, 94709, 344565, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 434677, 94709, 95960, 94709, 94709, 94709, 94709, 94709, 95787, 94709, 95789, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 95285, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94735, 94735,
  344591, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 434703, 94735, 95991, 94735, 94735, 94735, 548, 549, 0, 0, 0,
  4, 82178, 0, 0, 0, 0, 0, 0, 0, 1257, 0, 0, 1259, 0, 0, 0, 0, 0, 840207, 94735, 94735, 94735, 94735, 94735, 905743,
  94735, 94735, 96010, 94735, 94735, 1661, 1662, 0, 0, 0, 0, 911, 0, 0, 0, 915, 916, 0, 918, 0, 0, 0, 324, 324, 324, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 618, 0, 425984, 823296, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1705, 0, 0, 90539, 90539,
  90539, 91972, 90539, 90539, 90539, 1864, 0, 0, 0, 0, 0, 94709, 94709, 94709, 94709, 94709, 94978, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 823797, 94709, 94709, 844277, 94709, 94709, 94709, 94709, 94709, 94709, 94735,
  94735, 94735, 94735, 94735, 96312, 94735, 94735, 94735, 94735, 0, 389120, 94735, 94735, 94735, 426511, 94735, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 96113, 94735, 94735, 94735, 548, 549, 0, 0, 0, 4, 82178, 0, 0, 0, 873, 875,
  0, 94735, 823823, 94735, 94735, 844303, 94735, 94735, 94735, 94735, 94735, 94735, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1668, 1931, 815104, 1932, 0, 884736, 0, 1934, 0, 0, 1003520, 0, 0, 0, 0, 0, 0, 0, 696320, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 155648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 647168, 0, 0, 0, 0, 1947, 368640, 0, 626688, 0, 90539, 369067, 90539, 0, 94727,
  94727, 94727, 94727, 94727, 94753, 94727, 94753, 94727, 94727, 94727, 94727, 94727, 94727, 90539, 90539, 627115,
  90539, 90539, 92066, 92067, 0, 462848, 0, 0, 1959, 94709, 94709, 94709, 369141, 96185, 94709, 96187, 995829, 94735,
  94735, 94735, 369167, 94735, 94735, 94735, 94735, 96195, 94735, 94735, 627215, 0, 0, 0, 704512, 0, 880640, 2006, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 958464, 0, 0, 90539, 90539, 90539, 0, 0, 0, 794624, 0, 0, 675840, 987136, 0, 0, 0, 0, 90539,
  90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 692651, 90539, 94709, 706539, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 94735, 94735, 336399, 94735, 94735, 94735, 94735, 94735, 96107, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 770575, 94735, 94709, 94735, 94735, 94735, 94735, 94735, 94735,
  94735, 94735, 94735, 94735, 94735, 96286, 94735, 0, 0, 0, 0, 940, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 344064, 0, 0, 0, 0,
  0, 0, 618496, 0, 729088, 0, 0, 2086, 0, 0, 94709, 94709, 94709, 96300, 94709, 94709, 94709, 94709, 309180, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 95852, 94735, 94735, 94735, 94735, 0, 0, 0,
  2112, 0, 0, 0, 0, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94984, 94709, 94709, 94709, 94709, 96333,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 96343, 0, 0, 0, 0, 0, 0, 95255, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 95550, 0, 0, 0, 94709, 94709, 475637, 94709, 94709, 94709, 94709, 94709, 94709,
  94709, 94735, 94735, 475663, 492021, 94709, 709109, 94709, 94709, 94709, 94709, 96379, 94735, 492047, 94735, 709135,
  94735, 94735, 94735, 94735, 94735, 94735, 96120, 94735, 94735, 94735, 94735, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 917504, 0, 0, 0, 94709, 96403, 94709, 94709, 94709, 868853, 94735, 96407, 94735, 94735, 94735, 868879, 0, 0, 0,
  548, 549, 0, 0, 0, 4219433, 0, 0, 0, 0, 0, 0, 0, 0, 94735, 95824, 94735, 94735, 94735, 94735, 94735, 94735, 0, 292, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1829, 0, 335, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 679, 367, 73728,
  77824, 0, 331, 335, 0, 378, 69632, 378, 378, 292, 378, 0, 0, 378, 0, 0, 0, 331, 90545, 90545, 90545, 90545, 90545,
  378, 378, 458, 460, 460, 460, 465, 460, 460, 460, 465, 378, 460, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378,
  378, 378, 378, 378, 495, 90545, 90545, 497, 94715, 94715, 94715, 94715, 94715, 94741, 94715, 94741, 94715, 94715,
  94715, 94715, 94715, 94715, 94741, 94741, 94741, 94741, 94741, 94741, 94741, 94741, 94741, 94741, 94715, 94715, 94741,
  1, 16386, 3, 0, 877, 879, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 890, 0, 0, 0, 548, 549, 0, 0, 237568, 4, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 37421, 268, 0, 53809, 271, 0, 324, 0, 0, 890, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 631, 0, 0, 0, 0, 0, 0, 980,
  0, 890, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 971, 0, 0, 0, 0, 0, 0, 95255, 94709, 94709, 94709, 94709, 95260, 94709, 94709,
  94709, 94709, 95271, 94709, 94709, 94709, 94709, 94709, 95800, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709,
  94709, 94709, 95817, 95818, 94709, 94709, 94709, 34160, 90539, 90539, 1321, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  2009, 0, 0, 94735, 94735, 877071, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735,
  94735, 95060, 94735, 94735, 0, 0, 0, 1534, 0, 0, 0, 0, 0, 0, 0, 0, 0, 90539, 90539, 90539, 90539, 90539, 91113, 90539,
  90539, 90539, 91846, 90539, 90539, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 94709, 94709, 94709, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 95975, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 1612, 1613, 1614, 1615, 94735,
  94735, 94735, 95038, 94735, 94735, 95047, 94735, 94735, 94735, 95054, 94735, 94735, 94735, 94735, 95069, 94735, 94735,
  94735, 96006, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 1661, 1662, 0, 0, 0, 0, 954, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 630, 0, 0, 0, 0, 2003, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 976, 0, 0, 0, 311797, 94709, 94709,
  94709, 94709, 94709, 311823, 94735, 94735, 94735, 94735, 94735, 0, 1188, 0, 1190, 0, 1463, 0, 1464, 0, 1465, 0, 1466,
  0, 0, 0, 0, 94709, 94709, 94709, 94709, 94735, 94735, 94735, 94735, 0, 442869, 94709, 442895, 94735, 94709, 94735,
  94709, 94735, 94709, 94735, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 110997, 110997, 405, 1, 16386, 3, 0, 336, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1251, 0, 73728, 77824, 0, 0, 0, 0, 379, 69632, 379, 379, 0, 379, 387, 0, 379, 413, 413,
  413, 413, 90546, 90546, 90546, 90546, 90546, 450, 450, 413, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450,
  450, 450, 450, 450, 450, 90546, 90546, 450, 94716, 94716, 94716, 94716, 94716, 94742, 94716, 94742, 94716, 94716,
  94716, 94716, 94716, 94716, 94742, 94742, 94742, 94742, 94742, 94742, 94742, 94742, 94742, 94742, 94716, 94716, 94742,
  1, 16386, 3, 0, 1564, 0, 0, 0, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 0, 0, 0,
  0, 94735, 0, 0, 1844, 0, 0, 0, 0, 0, 0, 0, 0, 0, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 467371, 0, 1941, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 90539, 90539, 90539, 90539, 90539, 90818, 0, 2012, 0, 0, 0, 0, 0, 0, 327680, 0, 0, 0,
  328107, 90539, 90539, 90539, 0, 0, 0, 0, 94709, 94709, 336373, 94709, 94709, 94709, 94709, 94709, 94709, 95586, 94709,
  94709, 901621, 94709, 94709, 94709, 95591, 94709, 95593, 94709, 94709, 94709, 808941, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 94735, 328207, 94735, 94735, 94735, 548, 549, 45700, 0, 0, 4, 82178, 0, 0, 0, 0, 0, 0, 0, 1513,
  0, 0, 0, 557056, 0, 413696, 0, 0, 94735, 94735, 94735, 534519, 94735, 94735, 94735, 808954, 94735, 94735, 94735,
  94735, 94735, 94735, 94735, 0, 1188, 1190, 0, 0, 0, 873, 0, 875, 0, 877, 0, 879, 0, 446891, 90539, 0, 0, 94709, 94709,
  446965, 94709, 94709, 94709, 94709, 94709, 94709, 96274, 94709, 94709, 94709, 94709, 426485, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 96089, 94709, 94709, 94709, 94709, 96377, 94709, 94709, 94735, 94735, 94735, 94735,
  94735, 94735, 96383, 94735, 94735, 94735, 94735, 94735, 95997, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735,
  96003, 94735, 94709, 94735, 94735, 446991, 94735, 94735, 94735, 94735, 94735, 94735, 96284, 94735, 94735, 94735, 0, 0,
  0, 0, 994, 0, 0, 0, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 0, 0, 0, 0, 0, 0, 1561, 0, 0, 0, 94709,
  537077, 811509, 94709, 94735, 537103, 811535, 94735, 0, 94709, 94709, 94735, 94735, 94709, 94735, 94709, 94735,
  827893, 827919, 0, 0, 0, 0, 0, 0, 0, 0, 0, 650, 0, 0, 960, 0, 0, 0, 658, 0, 748, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 90539, 90539, 90539, 90539, 94735, 95031, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735,
  94735, 94735, 94735, 94735, 983567, 0, 94735, 95071, 94735, 548, 549, 0, 0, 0, 4, 82178, 0, 0, 0, 873, 875, 0, 0, 0,
  548, 549, 0, 0, 241664, 4, 0, 0, 0, 0, 0, 0, 0, 0, 94735, 94735, 94735, 95826, 94735, 94735, 94735, 94735, 0, 908, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 324, 324, 324, 0, 0, 0, 0, 0, 0, 0, 616, 0, 0, 1032619, 90539, 0, 0, 0, 0, 0,
  1033517, 0, 0, 0, 0, 0, 0, 0, 0, 0, 487424, 0, 0, 0, 0, 0, 0, 372736, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1262, 92130, 90539, 90539, 0, 0, 2020, 0, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 522, 523,
  524, 525, 0, 94735, 324402, 94709, 94709, 96236, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94735, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 0, 0, 0, 0, 90539, 90539, 2058, 0, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 95792, 94709, 94709, 94709, 975349, 94735, 94735, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 975375, 0, 0, 0, 0, 1240, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 630784, 90539, 90539, 90539, 631211, 0, 0, 293, 294, 295, 296, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 986, 0, 0, 0, 0, 0, 0,
  0, 337, 294, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 919, 0, 0, 324, 0, 0, 352, 0, 0, 0, 0, 0, 0, 0, 0, 0, 293, 0, 0, 0,
  0, 0, 0, 0, 0, 73728, 77824, 0, 0, 0, 0, 0, 69632, 0, 0, 0, 0, 388, 0, 0, 0, 0, 1256, 0, 0, 0, 0, 0, 0, 0, 0, 1261, 0,
  0, 0, 0, 293, 0, 0, 293, 0, 0, 0, 0, 0, 0, 0, 0, 0, 737280, 0, 0, 0, 0, 0, 0, 295, 414, 414, 414, 414, 90547, 90547,
  90547, 90547, 90547, 451, 451, 414, 451, 451, 451, 451, 451, 451, 475, 451, 484, 484, 484, 484, 484, 484, 484, 484,
  494, 484, 484, 494, 484, 484, 494, 90547, 90547, 484, 94717, 94717, 94717, 94717, 94717, 94743, 94717, 94743, 94717,
  94717, 94717, 94717, 94717, 94717, 94743, 94743, 94743, 94743, 94743, 94743, 94743, 94743, 94743, 94743, 94717, 94717,
  94743, 1, 16386, 3, 605, 606, 0, 324, 324, 324, 0, 0, 0, 0, 0, 0, 615, 0, 0, 0, 0, 0, 1267, 1268, 0, 1270, 0, 0, 0, 0,
  0, 0, 0, 331, 0, 0, 0, 0, 0, 0, 357, 0, 0, 663, 0, 0, 666, 0, 0, 670, 0, 0, 0, 0, 0, 0, 0, 0, 267, 0, 268, 0, 270, 0,
  271, 0, 684, 0, 0, 0, 745, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1813, 0, 0, 1816, 0, 95029, 94735, 95034, 94735, 95041,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 95066, 94735, 94735, 94735, 95039, 94735, 94735, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 96253, 94735, 94735, 94735, 0, 94735, 95072, 94735,
  548, 549, 0, 0, 0, 4, 82178, 0, 0, 0, 873, 875, 0, 0, 0, 548, 549, 0, 871, 871, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 267,
  37424, 0, 270, 53812, 0, 951, 0, 0, 0, 0, 0, 0, 0, 0, 650, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 656, 0, 0, 0, 0, 0, 991, 0,
  0, 0, 995, 0, 0, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 0, 0, 0, 0, 0, 552960, 0, 0, 90539, 90539,
  90539, 90539, 90539, 90539, 91122, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 0, 0, 0, 0, 1560, 0,
  0, 0, 90539, 90539, 90539, 91135, 90539, 90539, 90539, 0, 0, 0, 0, 0, 0, 0, 0, 1036, 0, 95255, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 95264, 94709, 94709, 94709, 94709, 94709, 94709, 95599, 34160, 0, 1114, 0, 1116, 34160, 0,
  1119, 0, 95372, 94735, 94735, 94735, 94735, 94735, 94735, 95383, 94735, 94735, 94735, 94735, 95388, 94735, 94735,
  94735, 548, 549, 188416, 0, 0, 4, 82178, 0, 0, 0, 0, 0, 0, 0, 1475, 0, 0, 0, 0, 0, 0, 0, 0, 1514, 0, 0, 0, 1261, 0, 0,
  0, 0, 0, 1239, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1248, 0, 0, 0, 0, 0, 1473, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 301, 302, 0, 0, 0,
  0, 90539, 90539, 90539, 90539, 91420, 90539, 90539, 90539, 90539, 91424, 90539, 90539, 90539, 90539, 90539, 90539,
  90539, 0, 0, 0, 1866, 0, 0, 96077, 94709, 94709, 94709, 94709, 95596, 94709, 94709, 94709, 94709, 34160, 0, 1114, 0,
  1116, 34160, 0, 1119, 0, 0, 0, 548, 549, 0, 245760, 245760, 4, 0, 0, 0, 0, 0, 0, 0, 0, 94735, 94735, 95825, 94735,
  94735, 94735, 94735, 94735, 95652, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735,
  95663, 94735, 94735, 94735, 94735, 94735, 590351, 95048, 680463, 94735, 94735, 94735, 94735, 94735, 95063, 94735,
  94735, 94735, 94735, 94735, 706552, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 0, 1188, 0, 1190,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 673, 0, 0, 0, 0, 0, 0, 0, 1496, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 90539, 90539,
  92062, 1506, 0, 0, 0, 0, 0, 0, 0, 0, 1515, 0, 0, 0, 0, 0, 0, 0, 712704, 712704, 0, 0, 0, 0, 0, 0, 0, 0, 295439, 94735,
  94735, 94735, 95827, 95828, 94735, 94735, 0, 0, 1697, 0, 0, 0, 0, 1701, 0, 0, 0, 0, 0, 0, 0, 1707, 1708, 0, 0, 1711,
  0, 0, 1714, 0, 0, 0, 0, 0, 0, 0, 0, 0, 522, 0, 523, 0, 0, 524, 0, 1722, 0, 0, 0, 90539, 90539, 90539, 90539, 91840,
  90539, 90539, 90539, 90539, 90539, 90539, 90539, 0, 0, 0, 0, 0, 0, 1035, 0, 0, 95964, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 34160, 94735, 95995, 94735, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 95064, 94735, 94735, 1806, 0, 0,
  0, 0, 0, 0, 0, 1810, 1811, 0, 0, 0, 1815, 0, 0, 0, 0, 1266, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 972, 973, 0, 0, 0, 1842,
  0, 0, 0, 0, 1847, 0, 1849, 0, 0, 0, 0, 91966, 90539, 91968, 90539, 0, 94729, 94729, 94729, 94729, 94729, 94755, 94729,
  94755, 94729, 94729, 94729, 94729, 94729, 94729, 90539, 90539, 90539, 90539, 90539, 91974, 90539, 0, 0, 0, 0, 0, 0,
  94709, 96078, 94709, 94709, 94709, 95297, 94709, 94709, 94709, 94709, 94709, 94709, 95308, 94709, 94709, 94709, 94709,
  95313, 94709, 96081, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 96086, 94709, 94709, 94709, 94709, 94709,
  94709, 96083, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 770549, 94709, 96092, 94709, 94709, 94709,
  94709, 96095, 94709, 94709, 96098, 94709, 94709, 94735, 96102, 94735, 94735, 94735, 94735, 94735, 832015, 94735,
  94735, 94735, 94735, 94735, 94735, 0, 0, 0, 0, 964, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 690, 0, 0, 0, 0, 0, 96105,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 96110, 94735, 94735, 94735, 94735, 94735, 94735, 95361, 94735,
  95364, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 96121, 94735, 94735, 94735, 0, 0, 0, 1919, 0, 96116, 94735,
  94735, 94735, 94735, 96119, 94735, 94735, 96122, 94735, 94735, 339968, 0, 0, 0, 0, 0, 0, 95255, 94709, 94709, 94709,
  94709, 95546, 94709, 94709, 94709, 94709, 94709, 95815, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709,
  34160, 0, 0, 0, 0, 34160, 0, 0, 0, 0, 0, 1942, 0, 0, 0, 0, 1946, 0, 0, 0, 0, 0, 90539, 90539, 90539, 90539, 90539,
  90539, 91412, 90539, 90539, 90539, 90539, 90539, 90539, 92063, 90539, 90539, 90539, 90539, 90539, 0, 0, 0, 0, 0,
  94709, 94709, 94709, 94709, 94709, 94709, 95780, 94709, 94709, 95781, 94709, 94709, 94709, 96173, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 96181, 94709, 94709, 94709, 94709, 95300, 94709, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 95312, 94709, 0, 0, 2004, 0, 0, 0, 0, 0, 0, 2007, 0, 0, 0, 0, 0, 0, 0, 909312, 0, 0, 0, 0,
  0, 0, 0, 0, 984, 0, 0, 0, 0, 0, 0, 0, 2048, 0, 0, 0, 2052, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1853, 90539, 90539, 90539,
  90539, 96332, 94709, 94735, 94735, 94735, 94735, 96338, 94735, 96340, 96341, 96342, 94735, 0, 0, 0, 0, 0, 0, 95255,
  94709, 94709, 94709, 95545, 94709, 94709, 94709, 94709, 94709, 95282, 94709, 94709, 94709, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 95791, 94709, 94709, 94709, 582133, 94709, 94735, 96420, 96421, 94709, 94735, 94709, 94735, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 522, 809, 524, 813, 0, 0, 0, 0, 297, 0, 0, 297, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1936, 0, 0, 0,
  1939, 297, 358, 0, 0, 0, 0, 0, 0, 0, 0, 297, 0, 0, 0, 0, 0, 0, 1229, 1230, 1231, 0, 0, 0, 0, 0, 0, 0, 0, 221567, 0, 0,
  0, 0, 0, 0, 0, 0, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 373263, 0, 73728, 77824, 0, 0, 358, 0, 380, 69632,
  380, 380, 0, 380, 0, 393, 380, 415, 415, 415, 415, 90548, 90548, 90548, 90548, 90548, 452, 452, 415, 452, 452, 452,
  452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 90548, 90548, 498, 94718, 94718, 94718, 94718, 94718,
  94744, 94718, 94744, 94718, 94718, 94718, 94718, 94718, 94718, 94744, 94744, 94744, 94744, 94744, 94744, 94744, 94744,
  94744, 94744, 94718, 94718, 94744, 1, 16386, 3, 576, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1278, 0, 0, 637, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 637, 0, 0, 0, 0, 0, 1486, 0, 0, 1488, 0, 0, 0, 0, 0, 0, 0, 364, 0, 0, 0, 0, 0, 0, 364, 0, 0,
  679, 0, 0, 0, 0, 0, 0, 0, 679, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 679, 0, 746, 0, 0, 0, 0, 0, 0, 0, 631, 0,
  637, 679, 0, 0, 0, 0, 0, 1498, 0, 1500, 0, 0, 0, 1502, 0, 0, 0, 0, 0, 0, 237568, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 254360,
  254360, 254360, 1, 16386, 0, 0, 877, 879, 0, 0, 0, 0, 0, 884, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 992, 1045, 1046, 0,
  324, 0, 0, 0, 0, 0, 0, 0, 928, 0, 0, 0, 0, 0, 0, 0, 353, 0, 0, 0, 0, 0, 0, 0, 0, 365, 276, 0, 0, 0, 276, 0, 0, 936, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 948, 0, 0, 0, 0, 0, 1511, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1233, 0, 0, 0, 0, 0, 0, 0, 1039,
  884, 0, 0, 0, 0, 0, 299008, 0, 0, 0, 0, 0, 0, 0, 946176, 1024000, 0, 0, 0, 0, 0, 0, 2010, 0, 95255, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 95265, 95272, 94709, 94709, 94709, 94709, 94709, 95955, 94709, 94709, 94709,
  94709, 95959, 94709, 95961, 94709, 94709, 94709, 95293, 94709, 94709, 94709, 94709, 94709, 94709, 95304, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 95958, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 95315, 94709, 94709,
  94709, 94709, 0, 1114, 1116, 0, 0, 1119, 1121, 0, 29794, 95255, 94735, 94735, 94735, 95040, 94735, 94735, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 489055, 512527, 94735, 94735, 94735, 94735, 95356,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 95368, 94735, 94735, 94735, 94735, 95043,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 96112, 94735, 94735, 94735, 94735, 0, 0,
  0, 1202, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1211, 0, 634880, 0, 1226, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  565248, 95551, 94709, 94709, 94709, 94709, 95555, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709,
  94709, 95589, 94709, 94709, 94709, 94709, 94709, 95565, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 95564, 1121, 29794, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735,
  95617, 95618, 94735, 94735, 94735, 94735, 94735, 94735, 96202, 96204, 96205, 94735, 96207, 995855, 0, 0, 0, 2002,
  95622, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 95632, 94735, 94735, 94735, 94735, 94735,
  94735, 96249, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 0, 0, 1507, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1517, 90539, 91668, 90539, 90539, 90539, 90539, 90539, 90539, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 94709, 95951, 94709,
  94709, 94709, 95814, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 34160, 0, 1114, 0,
  1116, 34160, 0, 1119, 0, 0, 0, 1671, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 122880, 122880, 122880, 96080, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 95794, 1940, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 90539, 90539, 90539, 90539, 90816, 90539, 94709, 96375, 94709, 96376, 94709, 94709,
  94709, 94735, 94735, 94735, 96381, 94735, 96382, 94735, 94735, 94735, 94735, 94735, 95381, 94735, 94735, 94735, 95385,
  94735, 94735, 94735, 94735, 94735, 94735, 95362, 94735, 94735, 668175, 94735, 94735, 94735, 94735, 94735, 94735,
  95382, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 689285, 94735, 95367, 94735, 95369,
  94735, 0, 0, 96412, 94709, 94709, 94709, 96414, 94735, 94735, 94735, 0, 94709, 94709, 94735, 94735, 94709, 94735,
  96422, 96423, 94709, 94735, 0, 0, 0, 0, 0, 0, 0, 0, 0, 650, 959, 888, 0, 0, 0, 0, 0, 0, 299, 0, 0, 0, 0, 0, 0, 0, 300,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 172032, 0, 0, 0, 0, 0, 0, 0, 73728, 77824, 0, 0, 0, 0, 0, 69632, 0, 0, 0, 0, 389, 0,
  0, 0, 0, 1283, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1527, 0, 1529, 1530, 294912, 401, 416, 416, 424, 416, 90549, 90549,
  90549, 90549, 90549, 401, 401, 416, 401, 401, 401, 401, 401, 401, 476, 401, 476, 476, 476, 476, 476, 476, 476, 476,
  476, 476, 476, 476, 476, 476, 476, 90549, 90549, 476, 94719, 94719, 94719, 94719, 94719, 94745, 94719, 94745, 94719,
  94719, 94719, 94719, 94719, 94719, 94745, 94745, 94745, 94745, 94745, 94745, 94745, 94745, 94745, 94745, 94719, 94719,
  94745, 1, 16386, 3, 0, 577, 0, 0, 0, 0, 0, 0, 0, 577, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 577, 90539, 91133,
  90539, 90539, 90539, 90539, 90539, 0, 0, 0, 1031, 0, 0, 0, 0, 0, 0, 1284, 0, 1285, 0, 0, 0, 0, 0, 0, 0, 331, 0, 0, 0,
  0, 367, 0, 331, 331, 0, 95255, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 95266, 94709, 94709, 94709,
  94709, 94709, 94709, 696821, 94709, 95968, 94709, 94709, 94709, 94709, 94709, 94709, 840181, 94709, 95552, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 94709, 95560, 94709, 94709, 94709, 94709, 94709, 94709, 872949, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 872975, 1121, 29794, 94735, 94735, 94735, 94735, 94735, 94735, 94735,
  94735, 94735, 94735, 95619, 94735, 94735, 94735, 94735, 94735, 95627, 94735, 94735, 94735, 94735, 94735, 94735, 94735,
  94735, 94735, 94735, 95645, 94735, 95647, 94735, 94735, 94735, 94735, 94735, 643599, 94735, 94735, 94735, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 95840, 94735, 94735, 0, 0, 1519, 0, 0, 0, 0, 0, 1524,
  0, 0, 0, 0, 0, 0, 0, 567, 0, 0, 0, 0, 0, 743, 682, 0, 94709, 95812, 94709, 94709, 94709, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 34160, 1394, 1114, 1396, 1116, 34160, 1398, 1119, 1400, 95857, 94735, 94735,
  94735, 95861, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 95366, 94735, 94735, 94735,
  94735, 94709, 94709, 94709, 96306, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 96316, 0, 0, 0, 0,
  1485, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 135168, 0, 135168, 135168, 135168, 0, 2111, 0, 0, 0, 0, 0, 0, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 0, 0, 324, 301, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1275, 0, 0, 0, 0, 0, 338, 0, 0, 339, 340, 342, 302, 0, 0, 0, 0, 0, 0, 0, 733, 0, 0, 0, 654, 735, 0, 0, 0, 0, 73728,
  77824, 339, 0, 0, 0, 0, 69632, 0, 0, 301, 0, 0, 394, 0, 0, 0, 548, 54118, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 268, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 303, 304, 305, 306, 0, 417, 423, 423, 423, 90550, 90550, 90550, 90550, 90550, 423, 423,
  417, 461, 461, 461, 461, 461, 461, 423, 461, 423, 423, 423, 423, 423, 423, 423, 488, 423, 489, 488, 423, 423, 423,
  423, 423, 423, 423, 423, 423, 423, 423, 423, 90550, 423, 94720, 94720, 94720, 94720, 94720, 94746, 94720, 94746,
  94720, 94720, 94720, 94720, 94720, 94720, 94746, 94746, 94746, 94746, 94746, 94746, 94746, 94746, 94746, 94746, 94720,
  94720, 94746, 1, 16386, 3, 619, 0, 0, 0, 0, 0, 0, 0, 627, 0, 0, 0, 0, 0, 0, 0, 914, 0, 0, 0, 0, 0, 0, 0, 324, 90539,
  90539, 90824, 90539, 90539, 90539, 90827, 90539, 90539, 90539, 90539, 90836, 90539, 685, 0, 0, 0, 0, 1535, 0, 0, 0, 0,
  0, 0, 0, 0, 90539, 90539, 90539, 90539, 90539, 91115, 90539, 90539, 729, 0, 581, 0, 681, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  681, 729, 0, 729, 694, 0, 0, 0, 685, 0, 0, 578, 741, 0, 681, 0, 0, 0, 0, 0, 0, 685, 0, 0, 0, 0, 691, 0, 0, 0, 747, 0,
  749, 0, 0, 0, 0, 0, 0, 0, 685, 578, 606957, 0, 0, 0, 0, 1673, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1678, 0, 94993, 94709, 94709,
  94709, 94709, 95008, 94709, 94709, 94709, 522, 523, 524, 525, 0, 94735, 95025, 0, 877, 879, 0, 0, 0, 0, 0, 0, 885,
  886, 887, 0, 0, 0, 0, 0, 0, 131072, 0, 0, 0, 0, 0, 0, 131072, 0, 0, 0, 0, 909, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 920, 0,
  324, 0, 0, 0, 0, 0, 0, 0, 0, 0, 930, 0, 0, 0, 0, 0, 0, 1113, 1115, 0, 0, 1118, 1120, 0, 0, 0, 0, 324, 0, 0, 0, 924, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 324259, 0, 0, 0, 0, 0, 0, 0, 989, 0, 0, 0, 1042, 0, 0, 0, 0, 0, 0, 0, 0, 299, 300, 0, 0,
  0, 0, 0, 0, 0, 95255, 94709, 94709, 94709, 94709, 94709, 95261, 94709, 94709, 95267, 94709, 94709, 94709, 94709,
  94709, 94709, 934389, 94709, 94709, 94709, 94709, 0, 0, 0, 0, 94735, 94735, 94735, 95357, 94735, 94735, 94735, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 95866, 95867, 94735, 94735, 95374, 94735, 94735, 95380,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 95646, 94735, 94735, 94735, 94735, 1200,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1481, 0, 0, 942080, 0, 1228, 1015808, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1272,
  0, 0, 0, 0, 0, 1121, 29794, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735,
  95621, 1531, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 978944, 0, 90539, 91653, 90539, 90539, 0, 0, 0, 0, 0, 0, 1203, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 90539, 90539, 90539, 90539, 90539, 979371, 90539, 90539, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  634880, 1669, 0, 0, 1672, 0, 0, 0, 0, 0, 757760, 0, 847872, 0, 0, 0, 0, 0, 0, 159744, 0, 159744, 159744, 159744,
  159744, 163840, 159744, 159744, 159744, 1695, 1696, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1938, 0, 0, 0, 1723, 0,
  90539, 90539, 90539, 90539, 90539, 90539, 91842, 90539, 91843, 90539, 90539, 90539, 0, 0, 0, 0, 94709, 328181, 94709,
  94709, 94709, 94709, 94709, 94709, 534506, 848299, 90539, 91847, 90539, 0, 1737, 0, 0, 0, 0, 0, 0, 1741, 0, 94709,
  94709, 94709, 94709, 909813, 94709, 94709, 958965, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 34160, 94709,
  94709, 94709, 95965, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 96101, 94735,
  94735, 94735, 94709, 848373, 94709, 94709, 95977, 94709, 94709, 94709, 94709, 94709, 94709, 0, 0, 0, 0, 94735, 94735,
  94735, 95335, 94735, 94735, 94735, 94735, 95346, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 95628, 94735, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 95848, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 96009, 94735,
  94735, 94735, 0, 0, 0, 0, 94735, 94735, 848399, 94735, 94735, 96008, 94735, 94735, 94735, 94735, 94735, 94735, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1665, 0, 0, 0, 0, 0, 0, 1821, 0, 1007616, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1490, 0, 0, 0, 0, 0,
  1830, 0, 0, 0, 1832, 0, 0, 0, 0, 0, 1837, 0, 0, 1840, 0, 0, 0, 0, 1683, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 365830, 1287,
  0, 0, 1289, 94709, 94709, 94709, 96082, 94709, 94709, 94709, 96084, 94709, 94709, 94709, 94709, 94709, 94709, 94709,
  94709, 0, 1393, 0, 1395, 0, 0, 1397, 0, 1399, 94735, 94735, 96106, 94735, 94735, 94735, 96108, 94735, 94735, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 96206, 94735, 94735, 0, 0, 2001, 0, 94735, 94735, 94735, 96200, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 0, 380928, 0, 0, 0, 0, 1712, 0, 0, 0, 0, 0, 0, 0, 1719, 0, 0, 0, 0,
  0, 1521, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1477, 0, 0, 0, 0, 0, 0, 548864, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  28672, 0, 0, 0, 96244, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 96251, 94735, 94735, 94735, 94735, 94735,
  94735, 0, 1188, 1190, 0, 0, 0, 873, 0, 875, 0, 877, 0, 879, 1199, 90539, 90539, 0, 0, 94709, 94709, 94709, 96269,
  94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94735, 96380, 94735, 94735, 94735, 94735, 94735, 94735, 94735,
  95340, 95347, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 95341, 94735, 94735, 94735, 94735, 94735, 94735, 94735,
  94735, 96109, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94709, 94735, 94735, 94735, 96279, 94735, 94735, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 0, 0, 417792, 872448, 0, 0, 0, 94709, 94709, 0, 0, 851968, 0, 0, 0, 0, 0,
  94709, 94709, 94709, 96327, 94709, 94709, 94709, 94709, 94709, 96176, 569845, 94709, 94709, 94709, 94709, 96180,
  94709, 94709, 94709, 94709, 94709, 96378, 94709, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 96384, 94735, 0, 0,
  0, 94709, 94709, 96404, 96405, 94709, 94709, 94735, 94735, 96408, 96409, 94735, 94735, 0, 1188, 1190, 0, 0, 1192, 873,
  1194, 875, 1196, 877, 1198, 879, 0, 0, 73728, 77824, 0, 304, 0, 306, 305, 69632, 305, 305, 306, 305, 0, 304, 305, 402,
  418, 418, 418, 426, 90551, 90551, 90551, 90551, 90551, 453, 453, 459, 453, 453, 463, 453, 453, 453, 463, 463, 453,
  477, 463, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 477, 90551, 90551, 477, 94721, 94721,
  94721, 94721, 94721, 94747, 94721, 94747, 94721, 94721, 94721, 94721, 94721, 94721, 94747, 94747, 94747, 94747, 94747,
  94747, 94747, 94747, 94747, 94747, 94721, 94721, 94747, 1, 16386, 3, 0, 0, 607, 324, 324, 324, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1526, 0, 0, 0, 0, 0, 0, 620, 0, 622, 0, 624, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1676, 0, 1677, 0, 0, 1679, 650, 0, 0,
  0, 0, 0, 566, 652, 653, 654, 0, 0, 0, 0, 0, 660, 680, 0, 0, 0, 0, 0, 0, 0, 0, 687, 0, 0, 0, 0, 0, 692, 90821, 90539,
  90539, 90539, 90826, 90539, 90539, 90539, 90539, 90539, 954795, 90539, 90839, 0, 660, 0, 0, 0, 579, 0, 0, 0, 582, 0,
  0, 0, 0, 0, 0, 0, 0, 958, 650, 0, 0, 0, 0, 0, 0, 607, 0, 0, 0, 954368, 740, 740, 588, 624, 0, 954368, 0, 0, 0, 654, 0,
  0, 738, 607, 0, 0, 740, 0, 0, 0, 742, 0, 0, 0, 954368, 0, 0, 0, 0, 695, 696, 0, 90539, 90539, 90539, 90814, 90539,
  90539, 654, 0, 0, 954368, 94709, 94709, 94709, 94971, 94974, 94709, 94981, 94709, 94709, 94709, 94990, 94992, 94735,
  95032, 95035, 94735, 95042, 94735, 94735, 94735, 95051, 95053, 94735, 94735, 94735, 95062, 954895, 94735, 94735,
  94735, 95358, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 95648, 94735, 94735,
  94735, 94735, 95073, 94735, 548, 549, 0, 0, 0, 4, 82178, 0, 0, 0, 873, 875, 0, 0, 0, 638, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 778240, 0, 0, 0, 0, 0, 938, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 950, 0, 0, 0, 645, 0, 0, 0, 0, 0, 650, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 634, 90539, 90539, 90539, 90539, 90539, 91121, 90539, 90539, 90539, 90539, 90539,
  90539, 90539, 90539, 90539, 90539, 90834, 90539, 90838, 0, 0, 728, 95373, 94735, 94735, 94735, 94735, 94735, 94735,
  94735, 94735, 94735, 94735, 94735, 95389, 94735, 94735, 94735, 94735, 94735, 95655, 94735, 94735, 94735, 94735, 94735,
  94735, 94735, 94735, 94735, 94735, 95631, 94735, 94735, 94735, 94735, 94735, 1252, 0, 0, 1255, 0, 0, 0, 0, 0, 0, 0,
  1260, 0, 0, 0, 0, 0, 0, 167936, 0, 167936, 167936, 167936, 167936, 167936, 167936, 167936, 167936, 167936, 167936,
  167936, 167936, 1, 16386, 3, 0, 0, 0, 1282, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1528, 0, 0, 0, 0, 0, 1292, 0, 90539,
  90539, 91408, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 0, 0, 1559, 767454, 0, 0, 0, 1562, 90539,
  90539, 90539, 635307, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 91430, 90539, 90539, 0, 0,
  0, 1324, 856064, 0, 0, 0, 0, 0, 0, 0, 0, 1290, 0, 0, 0, 91406, 91407, 90539, 360875, 90539, 90539, 90539, 90539,
  90539, 483755, 90539, 91416, 95594, 94709, 94709, 94709, 94709, 94709, 94709, 34160, 0, 1114, 0, 1116, 34160, 0, 1119,
  0, 0, 0, 651, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 96096, 94709, 94709,
  94709, 94709, 94735, 94735, 94735, 94735, 94735, 94735, 96192, 94735, 94735, 94735, 94735, 94735, 1121, 29794, 94735,
  94735, 94735, 94735, 95613, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 467471, 94735, 94735,
  94735, 94735, 94735, 94735, 94735, 635407, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735,
  94735, 94735, 94735, 94735, 96114, 94735, 96115, 1482, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1492, 0, 0, 0, 0, 1808, 0,
  0, 0, 0, 0, 1812, 0, 0, 0, 0, 0, 0, 897, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 319488, 0, 0, 0, 0, 0, 0, 1922, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 131072, 0, 0, 96171, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 95963, 0, 0, 2050, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 192918, 192918, 192918,
  90539, 90539, 0, 0, 96267, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 95970, 94709,
  94709, 94709, 94709, 94709, 96277, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735,
  0, 2080, 0, 0, 0, 2083, 0, 0, 0, 0, 0, 0, 94709, 94709, 96299, 94709, 94709, 94709, 94709, 95319, 0, 1114, 1116, 0, 0,
  1119, 1121, 0, 29794, 95255, 94735, 94709, 94709, 94735, 96335, 94735, 94735, 94735, 96339, 94735, 94735, 94735,
  94735, 0, 0, 0, 0, 0, 0, 0, 0, 1663, 0, 0, 0, 0, 0, 2192, 0, 2194, 94709, 94709, 94709, 94709, 94709, 94709, 94735,
  94735, 94735, 94735, 94735, 94735, 0, 1661, 0, 1662, 1463, 1464, 1465, 1466, 0, 0, 0, 0, 0, 0, 0, 1834, 0, 1836, 0, 0,
  0, 0, 1841, 0, 2203, 0, 94709, 94709, 94709, 94709, 94735, 94735, 94735, 94735, 0, 94709, 94709, 94735, 94735, 94709,
  94709, 94709, 95298, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 95314, 0, 73728,
  77824, 361, 353, 0, 0, 0, 69632, 0, 0, 0, 0, 390, 0, 0, 0, 0, 1822, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 524288, 0, 0, 0,
  0, 94748, 94748, 94748, 94748, 94748, 94748, 94748, 94748, 94748, 94748, 94722, 94722, 94748, 1, 16386, 3, 0, 877,
  879, 0, 0, 0, 0, 0, 0, 0, 0, 0, 888, 0, 0, 0, 0, 0, 1674, 671744, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1224, 0, 0, 0, 0, 0, 0,
  892, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1721, 977, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1817, 90539,
  91119, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539,
  91131, 0, 95255, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 95268, 94709, 94709, 94709, 94709, 95277,
  94735, 95375, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 95387, 94735, 94735, 94735, 94735, 94735,
  94735, 598543, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 95643, 94735, 94735, 94735, 95649,
  94735, 94735, 94709, 95581, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709,
  94709, 831989, 94709, 94709, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 91660, 582059, 90539, 90539, 90539,
  90539, 90539, 90539, 90539, 0, 0, 0, 0, 0, 0, 94709, 94709, 96079, 94735, 582159, 94735, 94735, 94735, 94735, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 96254, 94735, 0, 0, 0, 0, 1933, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1691, 0, 0, 1694, 90539, 90539, 90539, 90539, 92065, 90539, 90539, 0, 0, 0, 1958, 0, 94709, 94709, 94709,
  94709, 94709, 692725, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 877045, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 95306, 94709, 94709, 94709, 95310, 94709, 94709, 94709, 94735, 94735, 96199,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 0, 0, 0, 0, 0, 1191, 0, 1193, 0, 1195, 0, 1197, 0, 0,
  2081, 0, 0, 0, 0, 0, 2085, 0, 2087, 0, 94709, 94709, 94709, 94709, 94709, 94709, 95788, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 95287, 94709, 94709, 668149, 94709, 94709, 94709, 0, 507904, 0, 0, 0, 0, 0, 0, 0,
  507904, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 507904, 0, 0, 0, 0, 94735, 94735, 94735, 508431, 94735, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 95853, 94735, 95855, 95856, 94735, 94735, 95074,
  548, 549, 0, 0, 0, 4, 82178, 0, 0, 0, 873, 875, 0, 0, 0, 658, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 752, 0, 0, 0, 94735,
  94735, 96246, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 0, 0, 0, 0, 1920,
  307, 308, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 135168, 0, 0, 0, 324, 0, 0, 0, 0, 0, 307, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 73728, 77824, 0, 0, 0, 308, 307, 69632, 307, 307, 308, 307, 0, 0, 307, 0, 0, 0, 0, 90553, 90553, 90553,
  90553, 90553, 307, 307, 308, 307, 307, 307, 307, 307, 470, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307,
  307, 307, 307, 90553, 90553, 307, 94723, 94723, 94723, 94723, 94723, 94749, 94723, 94749, 94723, 94723, 94723, 94723,
  94723, 94723, 94749, 94749, 94749, 94749, 94749, 94749, 94749, 94749, 94749, 94749, 94723, 94723, 94749, 1, 16386, 3,
  590, 591, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 217088, 0, 635, 0, 0, 0, 639, 0, 0, 0, 643, 0, 0, 0, 0, 0, 0, 0,
  943, 0, 0, 0, 0, 0, 0, 0, 0, 279, 0, 0, 0, 0, 0, 0, 0, 650, 0, 0, 0, 0, 0, 0, 0, 0, 0, 655, 0, 0, 0, 0, 0, 0, 1474, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 613, 0, 0, 0, 0, 0, 0, 0, 0, 664, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 282624, 282624,
  282624, 0, 590, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 229376, 0, 0, 761856, 693, 0, 0, 0, 0, 0, 0, 761856, 90539,
  90539, 90539, 90539, 90539, 90539, 90539, 0, 499712, 1030, 0, 0, 0, 0, 0, 0, 0, 262144, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  2088, 94709, 94709, 94709, 94709, 94709, 94709, 90539, 90822, 90539, 90539, 90539, 90539, 762572, 90539, 90539, 90539,
  90835, 90539, 90539, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1328, 0, 0, 0, 0, 655, 0, 0, 762586, 0, 0, 0, 0, 0, 762447, 0, 0,
  0, 762586, 0, 0, 0, 658, 658, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1704, 0, 0, 0, 0, 639, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  762446, 0, 0, 0, 0, 0, 1684, 1685, 0, 0, 1688, 0, 0, 0, 0, 0, 0, 0, 753664, 0, 0, 0, 0, 0, 0, 0, 0, 1824, 0, 0, 0, 0,
  0, 0, 0, 762642, 94996, 94709, 94709, 95006, 94709, 94709, 94709, 94709, 522, 523, 524, 525, 0, 94735, 94735, 94735,
  94735, 95379, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 95390, 94735, 94735, 94735, 94735, 95336, 94735,
  94735, 95342, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 95987, 94735, 94735, 94735, 94735, 94735, 94735,
  94735, 94735, 95998, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 324, 0, 0, 0, 0, 925, 926, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 807, 808, 811, 812, 0, 0, 0, 0, 0, 0, 939, 0, 941, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1689, 0, 0, 0, 0, 0, 0, 952, 0,
  0, 0, 955, 0, 0, 0, 650, 0, 0, 0, 540672, 0, 0, 0, 0, 1943, 1944, 0, 0, 0, 0, 393216, 0, 0, 90539, 90539, 90539,
  90539, 90539, 90539, 90539, 1956, 0, 1957, 0, 0, 94709, 96169, 94709, 94709, 90539, 90539, 90539, 90539, 541099,
  90539, 90539, 90539, 90539, 90539, 90539, 90539, 91128, 90539, 90539, 90539, 0, 0, 0, 0, 96229, 94709, 94709, 94709,
  94709, 94709, 96232, 94709, 94709, 90539, 90539, 90539, 90539, 90539, 90539, 91138, 0, 0, 0, 0, 0, 0, 0, 0, 0, 945, 0,
  0, 0, 0, 0, 0, 0, 1038, 0, 0, 0, 0, 1041, 0, 0, 0, 0, 1044, 0, 0, 0, 0, 0, 0, 176128, 0, 176128, 176128, 176128,
  176128, 176128, 176128, 176128, 176128, 176128, 176128, 176128, 176128, 1, 0, 3, 952, 95255, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 963061, 94709, 94709, 94709, 94709,
  95295, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 754165, 94709,
  94709, 94709, 95355, 541199, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735,
  94735, 95370, 95393, 94735, 0, 1188, 1190, 0, 0, 0, 873, 0, 875, 0, 877, 0, 879, 0, 0, 0, 665, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 578, 0, 606208, 580, 581, 0, 0, 0, 0, 0, 0, 0, 0, 0, 650, 0, 0, 0, 0, 0, 0, 0, 0, 1265, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 569344, 0, 0, 94709, 95595, 94709, 95597, 94709, 94709, 94709, 34160, 0, 1114, 0, 1116, 34160, 0,
  1119, 0, 0, 0, 684, 0, 0, 0, 0, 0, 0, 688, 0, 0, 0, 0, 0, 0, 1217, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1065381, 1065381,
  1065381, 1, 16386, 3, 1121, 29794, 94735, 94735, 94735, 95612, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735,
  94735, 94735, 96000, 94735, 94735, 94735, 94735, 96004, 0, 765952, 1483, 1484, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1493,
  0, 0, 0, 1509, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1814, 0, 0, 0, 0, 1532, 0, 0, 0, 0, 0, 0, 0, 1540, 0, 0, 0, 295339,
  90539, 91654, 95795, 94709, 95797, 94709, 94709, 94709, 767545, 94709, 94709, 94709, 94709, 94709, 94709, 94709,
  94709, 95810, 94735, 94735, 95843, 95844, 94735, 95846, 94735, 94735, 94735, 767594, 94735, 94735, 94735, 94735,
  94735, 94735, 95834, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 696847, 94735, 95999, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 95859, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735,
  94735, 94735, 94735, 94735, 96001, 94735, 94735, 94735, 94735, 95868, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1666, 0, 0, 0,
  0, 2005, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 983040, 0, 0, 0, 0, 0, 0, 0, 1698, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1839,
  0, 0, 0, 0, 0, 1710, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 610304, 0, 0, 1818, 1819, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1827, 0, 0, 0, 0, 0, 1713, 0, 0, 0, 0, 1718, 0, 0, 0, 0, 0, 0, 913, 0, 0, 0, 0, 0, 0, 0, 0, 324, 0, 2082, 0, 0, 0, 0,
  0, 0, 0, 0, 96297, 94709, 94709, 94709, 94709, 94709, 95570, 94709, 94709, 651765, 94709, 94709, 94709, 94709, 94709,
  94709, 94709, 95957, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 95557, 94709, 94709, 94709, 483829,
  94709, 94709, 95563, 94709, 94709, 94709, 96305, 94709, 96307, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 96315,
  94735, 0, 0, 0, 0, 2014, 0, 0, 0, 0, 0, 0, 0, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 91414, 90539,
  90539, 90539, 2140, 0, 2142, 94709, 96352, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94735, 96361,
  94735, 94735, 94735, 95625, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 95633, 94735, 94735, 94735, 548,
  549, 0, 0, 0, 4, 258, 0, 0, 0, 873, 875, 0, 0, 0, 0, 94709, 94709, 94709, 94709, 96406, 94709, 94735, 94735, 94735,
  94735, 96410, 94735, 421888, 0, 790528, 94709, 94709, 94709, 94709, 94735, 94735, 94735, 94735, 585728, 94709, 94709,
  94735, 94735, 94709, 94709, 94709, 95318, 94709, 0, 1114, 1116, 0, 0, 1119, 1121, 0, 29794, 95255, 94735, 94735,
  94735, 95378, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 1661, 1662, 0, 0, 0,
  0, 309, 310, 311, 312, 313, 314, 0, 0, 0, 0, 0, 0, 0, 0, 583, 584, 0, 0, 0, 0, 0, 0, 0, 359, 360, 0, 0, 0, 349, 0, 0,
  0, 311, 366, 0, 0, 0, 0, 0, 0, 356352, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1928, 0, 0, 0, 0, 0, 0, 0, 73728, 77824, 0, 0, 373,
  0, 381, 69632, 381, 381, 0, 381, 0, 366, 381, 403, 0, 0, 360, 0, 90554, 90554, 90554, 90554, 90554, 454, 454, 0, 454,
  454, 454, 454, 454, 454, 479, 454, 479, 479, 479, 479, 479, 403, 403, 403, 479, 490, 479, 479, 479, 479, 479, 479,
  479, 479, 479, 479, 90554, 90554, 499, 94724, 94724, 94724, 94724, 94724, 94750, 94724, 94750, 94724, 94724, 94724,
  94724, 94724, 94724, 94750, 94750, 94750, 94750, 94750, 94750, 94750, 94750, 94750, 94750, 94724, 94724, 94750, 1,
  16386, 3, 0, 0, 323584, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 638976, 0, 0, 90539, 90539, 639403, 90539, 90539,
  90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 324259, 0, 0, 0, 0, 41323, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  689, 0, 0, 0, 0, 0, 0, 603, 0, 0, 0, 324259, 0, 0, 0, 638976, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 692224, 0, 0, 0,
  324259, 0, 638976, 0, 0, 0, 0, 0, 0, 0, 324259, 0, 638976, 0, 0, 0, 0, 90539, 90539, 90539, 90539, 91410, 90539,
  90539, 90539, 90539, 90539, 90539, 90539, 0, 0, 0, 0, 0, 0, 94709, 94709, 94709, 95777, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 0, 877, 879, 0, 880, 0, 882, 0, 0, 0, 0, 0, 0, 0, 0, 0, 970, 0, 0, 0, 0, 975, 0, 324, 0, 0, 0, 0,
  0, 0, 927, 0, 0, 0, 0, 0, 0, 0, 0, 672, 720896, 0, 0, 0, 660, 0, 0, 0, 0, 992, 0, 0, 0, 0, 0, 90539, 90539, 90539,
  90539, 91112, 90539, 91117, 90539, 90539, 0, 0, 1323, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1838, 0, 0, 0, 798720, 91118,
  90539, 90539, 90539, 90539, 90539, 90539, 91123, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 0, 1558, 0,
  0, 0, 0, 0, 0, 0, 95255, 94709, 94709, 94709, 94709, 94709, 94709, 95262, 94709, 94709, 95273, 94709, 94709, 95276,
  94709, 94709, 94709, 95583, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 96088,
  94709, 94709, 94709, 1213, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1223, 0, 0, 0, 0, 0, 1809, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1209, 0, 0, 0, 0, 643072, 0, 0, 0, 1227, 0, 0, 0, 0, 0, 0, 0, 0, 1235, 1236, 0, 0, 0, 0, 90539, 90539, 91838, 90539,
  90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 91662, 90539, 766379, 90539, 91665, 90539, 90539,
  90539, 90539, 950699, 90539, 90539, 90539, 1044907, 0, 0, 0, 0, 0, 0, 0, 0, 944, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 950272,
  1566, 94709, 95775, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 95572, 94709, 94709, 94709, 94709,
  94709, 94709, 95811, 94709, 94709, 94709, 94709, 94709, 950773, 94709, 95816, 94709, 94709, 94709, 94709, 1044981,
  94709, 34160, 94735, 94735, 94735, 95860, 94735, 94735, 94735, 94735, 94735, 950799, 94735, 95865, 94735, 94735,
  94735, 94735, 94735, 94735, 692751, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 754191, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 909839, 94735, 94735, 958991, 94735, 94735, 94735, 94735, 94735,
  1045007, 94735, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 233472, 0, 1680, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1930, 0, 0, 0, 1724, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 91844, 90539, 90539, 0, 0, 0,
  0, 0, 0, 0, 1326, 0, 0, 0, 0, 0, 0, 288, 0, 0, 330, 0, 0, 0, 0, 0, 0, 0, 217088, 0, 0, 217088, 217088, 217088, 1,
  16386, 3, 94709, 94709, 94709, 96093, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94735, 94735, 94735,
  94735, 94735, 393743, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 96117, 94735, 94735, 94735, 94735,
  94735, 94735, 94735, 94735, 0, 0, 0, 0, 0, 0, 0, 94709, 94709, 393643, 90539, 90539, 90539, 90539, 90539, 90539, 0, 0,
  0, 0, 0, 94709, 94709, 94709, 94709, 94709, 94975, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 393717, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 96242, 94735, 94735, 94735,
  94735, 0, 0, 2013, 0, 0, 0, 0, 0, 0, 0, 860160, 0, 90539, 90539, 90539, 90539, 0, 0, 0, 1738, 0, 0, 0, 0, 0, 0, 94709,
  94709, 94709, 94709, 94709, 96355, 94709, 94709, 94709, 94709, 94735, 94735, 94735, 96337, 94735, 94735, 94735, 94735,
  94735, 94735, 0, 0, 0, 2139, 90539, 860587, 889259, 0, 2019, 0, 888832, 94709, 94709, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 95804, 94709, 95806, 95807, 94709, 94709, 94709, 0, 2049, 0, 0, 0, 0, 0, 0, 0, 0, 2056, 0, 0, 0,
  450560, 0, 0, 0, 690, 0, 0, 0, 0, 0, 0, 0, 0, 0, 690, 0, 0, 0, 0, 362, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 674, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 674, 0, 0, 0, 0, 90539, 782763, 0, 782336, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 782837,
  94709, 94709, 94709, 94709, 94709, 905717, 94709, 94709, 95979, 94709, 94709, 1612, 1613, 1614, 1615, 94735, 94709,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 782863, 94735, 94735, 94735, 94735, 94735, 0, 0, 0, 0, 90539, 344491,
  90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 91663, 90539, 90539, 90539, 90539, 96303,
  94709, 94709, 94709, 94735, 94735, 94735, 94735, 96311, 94735, 96313, 94735, 94735, 94735, 0, 0, 0, 0, 91837, 90539,
  90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90837, 0, 0, 0, 0, 0, 0, 96351, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 96360, 94735, 94735, 94735, 94735, 95626, 94735, 94735, 94735,
  94735, 94735, 94735, 94735, 94735, 95634, 94735, 94735, 94735, 94735, 95639, 94735, 94735, 94735, 94735, 94735, 94735,
  94735, 94735, 94735, 94735, 94735, 95350, 94735, 94735, 95353, 94735, 409600, 0, 0, 0, 94709, 96389, 94709, 94709,
  94709, 94709, 94735, 96395, 94735, 94735, 94735, 94735, 94735, 95044, 94735, 94735, 94735, 94735, 762703, 95057,
  94735, 94735, 95067, 94735, 315, 0, 0, 0, 0, 0, 350, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1232, 0, 0, 0, 0, 0, 0, 0, 73728,
  77824, 0, 0, 374, 0, 0, 69632, 0, 0, 0, 0, 0, 317, 0, 0, 0, 693, 94709, 94709, 94709, 94709, 94709, 94709, 94709,
  94983, 94709, 94709, 94709, 94709, 94709, 860661, 94709, 94709, 889333, 94709, 94709, 94735, 94735, 94735, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 2136, 2137, 0, 0, 0, 419, 419, 419, 419, 90555, 90555, 90555, 90555, 90555,
  0, 0, 419, 0, 0, 0, 0, 0, 1925, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 754, 754, 754, 754, 754, 754, 754, 754, 754, 419, 419,
  419, 485, 491, 485, 485, 485, 480, 485, 485, 480, 485, 485, 480, 90555, 500, 94725, 94725, 94725, 94725, 94725, 94751,
  94725, 94751, 94725, 94725, 94725, 94725, 94725, 94725, 94751, 94751, 94751, 94751, 94751, 94751, 94751, 94751, 94751,
  94751, 94725, 94725, 94751, 1, 16386, 3, 0, 0, 0, 331776, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1948, 90539, 90539,
  90539, 0, 0, 331776, 0, 0, 0, 642, 599, 0, 0, 0, 0, 331776, 647, 648, 0, 0, 0, 694, 0, 611, 0, 0, 0, 0, 90539, 90810,
  90539, 90539, 90539, 90819, 650, 0, 0, 0, 642, 0, 0, 0, 0, 0, 0, 0, 657, 0, 0, 0, 0, 0, 2015, 0, 0, 0, 0, 0, 0, 90539,
  90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 0, 0, 0, 0, 0, 683, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 589824, 0, 679936, 0, 683, 0, 0, 0, 579, 0, 734, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 683, 0, 90539,
  590251, 90539, 680363, 90539, 90539, 90539, 90539, 90539, 90833, 90539, 90539, 90539, 331776, 0, 0, 0, 0, 94709,
  94963, 94709, 94709, 94709, 94709, 94709, 94709, 598517, 94709, 94709, 94709, 94709, 95299, 94709, 94709, 95305,
  94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 96177, 96178, 94709, 94709, 94709, 94709, 94709, 94709, 0,
  331776, 0, 0, 0, 0, 0, 0, 0, 683, 0, 331776, 0, 0, 0, 0, 0, 0, 892928, 0, 0, 0, 0, 0, 0, 0, 0, 0, 806, 523, 810, 525,
  0, 0, 0, 0, 679936, 753, 0, 94709, 94966, 94709, 94709, 94709, 94709, 94709, 590325, 94987, 680437, 94709, 94709,
  94709, 94709, 1032693, 94709, 94709, 34160, 0, 1114, 0, 1116, 34160, 0, 1119, 0, 0, 877, 879, 0, 0, 0, 0, 883, 0, 0,
  0, 0, 0, 0, 0, 0, 969, 0, 0, 0, 0, 0, 0, 0, 324, 922, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 245760, 0, 0, 978, 0,
  0, 883, 0, 0, 0, 0, 985, 0, 987, 0, 0, 0, 0, 0, 0, 1065381, 0, 1065381, 1065381, 1065381, 1065381, 1065381, 1065381,
  1065381, 1065381, 1065381, 1065381, 1065381, 1065381, 1065381, 1065381, 1065381, 1065381, 0, 0, 993, 0, 0, 0, 0, 0,
  91109, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 0, 0, 0, 0, 0, 888, 0, 0, 0, 90539, 90539, 90539, 90539,
  90539, 90539, 90539, 91124, 668075, 90539, 90539, 90539, 90539, 91129, 91130, 90539, 90539, 0, 0, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 95291, 94709, 90539, 90539, 90539, 90539,
  90539, 91137, 90539, 0, 1029, 0, 985, 1032, 0, 0, 741376, 0, 0, 0, 732, 732, 0, 0, 0, 688, 0, 0, 0, 0, 0, 0, 745,
  94709, 94709, 94968, 94709, 94973, 94709, 94980, 94709, 94709, 94709, 94709, 94709, 0, 1114, 1116, 0, 0, 1119, 1121,
  0, 29794, 95255, 94735, 0, 95255, 95256, 94709, 94709, 95259, 94709, 94709, 95263, 94709, 94709, 94709, 94709, 94709,
  94709, 94709, 95802, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 95558, 94709, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 95317, 94709, 94709, 0, 1114, 1116, 0, 0, 1119, 1121, 0, 29794, 95255, 95331, 94735,
  94735, 95334, 94735, 94735, 95338, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 96111, 94735,
  94735, 94735, 94735, 94735, 94735, 95376, 95377, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735,
  94735, 94735, 95392, 0, 0, 0, 700416, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86016, 0, 0, 0, 0, 937984, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 651264, 0, 0, 0, 736, 736, 739, 0, 0, 678, 0, 0, 0, 0, 0, 744, 0, 0, 0, 548, 549, 0, 0, 0, 0, 0,
  180224, 290816, 0, 0, 0, 0, 0, 0, 1700, 0, 0, 0, 0, 0, 0, 0, 1706, 0, 0, 0, 0, 716800, 0, 0, 0, 0, 0, 0, 0, 1247, 0,
  0, 0, 0, 0, 272, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 331, 0, 0, 0, 0, 333, 0, 0, 0, 1293, 90539, 90539, 90539, 365841,
  90539, 91411, 90539, 90539, 90539, 90539, 91415, 90539, 90539, 0, 0, 94709, 94709, 94709, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 96276, 90539, 90539, 91418, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 91425, 90539,
  90539, 90539, 90539, 90539, 90539, 90539, 1028, 0, 0, 0, 0, 0, 0, 0, 0, 815, 815, 815, 815, 815, 815, 815, 815, 815,
  815, 815, 815, 815, 815, 815, 815, 0, 90539, 90539, 0, 1322, 0, 0, 0, 0, 1293, 0, 0, 0, 0, 0, 0, 0, 956, 0, 650, 0,
  885, 0, 0, 0, 0, 0, 1331, 0, 0, 1286, 365830, 95255, 94709, 94709, 94709, 94709, 94709, 94709, 365884, 94709, 94709,
  94709, 94999, 94709, 94709, 94709, 94709, 94709, 522, 523, 524, 525, 0, 94735, 94735, 94735, 94735, 94735, 95656,
  94735, 94735, 94735, 94735, 94735, 94735, 95662, 94735, 95664, 94735, 94709, 94709, 95553, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 95561, 94709, 94709, 94709, 94709, 95568, 94709, 635381, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 95559, 94709, 94709, 94709, 94709, 94709, 94709, 1121, 29794, 94735, 94735,
  94735, 94735, 94735, 94735, 365951, 94735, 94735, 94735, 94735, 95620, 94735, 94735, 94735, 94735, 95640, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 95651, 95637, 94735, 94735, 651791, 94735, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 979471, 94735, 94735, 94735, 0, 0, 1470, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 663552, 0, 0, 0, 0, 0, 2084, 0, 0, 0, 0, 94709, 94709, 94709, 94709, 94709, 94709, 94735, 94735,
  94735, 94735, 94735, 94735, 0, 0, 1495, 0, 528384, 1497, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 770048, 0, 0, 0, 0, 0, 0, 0,
  458752, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 266240, 0, 0, 0, 90539, 90539, 90539, 414123, 90539, 90539, 90539, 90539,
  90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 91664, 90539, 90539, 90539, 90539, 909739, 90539,
  958891, 90539, 90539, 90539, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1329, 0, 1563, 0, 0, 0, 0, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 96179, 94709, 94709, 94709, 94709, 94709, 94709, 414197,
  94709, 94709, 95786, 94709, 94709, 94709, 94709, 94709, 94709, 528885, 94709, 95793, 94709, 94709, 94709, 95001,
  954869, 94709, 94709, 95012, 94709, 522, 523, 524, 525, 0, 94735, 94735, 94735, 94735, 95359, 94735, 94735, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 0, 1917, 0, 0, 0, 95842, 94735, 94735, 94735, 94735, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 95841, 0, 520192, 0, 0, 90539, 90539, 90539,
  91839, 90539, 90539, 90539, 520619, 90539, 90539, 90539, 90539, 1736, 0, 0, 0, 0, 0, 0, 1740, 0, 0, 94709, 94709,
  94709, 94709, 94735, 94735, 94735, 94735, 0, 94709, 94709, 94735, 94735, 94709, 94709, 602613, 623093, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 786933, 94709, 95971, 94709, 94709, 94709, 94709, 95584, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 1049077, 0, 0, 0, 0, 94735, 94735, 94735, 602639, 623119,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 786959, 94735, 96002, 94735, 94735, 94735, 94735, 95845, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 95854, 94735, 94735, 1460, 1188, 1462, 1190, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1929, 0, 0, 0, 0, 0, 0, 0, 397312, 401408, 0, 0, 430080, 479232, 0, 0, 0, 0, 0, 0, 0, 0, 1043, 0, 0, 0, 0, 0, 0,
  0, 0, 1843, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 90539, 90539, 90539, 90539, 90539, 90817, 430507, 90539, 90539, 90539,
  90539, 90539, 90539, 0, 0, 1036288, 0, 0, 0, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 96357, 94709, 96359,
  94735, 94735, 94735, 94709, 94709, 385525, 94709, 94709, 430581, 94709, 94709, 479733, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 95967, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 95010, 94709, 522, 523, 524, 525,
  0, 94735, 94735, 94735, 385551, 94735, 94735, 430607, 94735, 94735, 479759, 94735, 94735, 94735, 94735, 94735, 94735,
  94735, 94735, 352256, 2161, 0, 0, 0, 0, 0, 96373, 94709, 94735, 94735, 94735, 96118, 94735, 94735, 94735, 94735,
  94735, 94735, 96124, 0, 0, 0, 0, 0, 0, 1499, 0, 0, 0, 0, 0, 0, 0, 0, 0, 650, 0, 0, 0, 0, 0, 667648, 0, 0, 1923, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 577536, 0, 0, 0, 754, 754, 754, 754, 754, 754, 754, 754, 754, 754, 815, 815, 815, 815, 815,
  815, 815, 815, 815, 815, 0, 0, 0, 0, 94709, 94709, 94709, 473006, 94709, 94709, 94709, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 983541, 94735, 94735, 94735, 94735, 94735, 94709, 96186, 94709, 94709, 94735,
  94735, 96190, 94735, 94735, 94735, 94735, 473026, 94735, 94735, 94735, 94735, 94735, 95360, 94735, 94735, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 95851, 94735, 94735, 94735, 94735, 94735, 90539, 90539, 90539,
  454656, 0, 0, 0, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 95969, 94709, 94709, 94709, 94709,
  95973, 94709, 631285, 94709, 94709, 94709, 94709, 94709, 96239, 94709, 94709, 94709, 94709, 94735, 94735, 94735,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 0, 0, 0, 0, 0, 90539, 90539, 0, 0, 94709,
  440332, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 96275, 94709, 94709, 94709, 95785, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 96085, 94709, 94709, 94709, 94709, 94709, 94709,
  94709, 94735, 440342, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 96285, 94735, 94735, 0, 0, 0, 0, 94709,
  94964, 94709, 94709, 94709, 94977, 94709, 94709, 94986, 94709, 94709, 94709, 94709, 95301, 95302, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 94709, 96099, 94709, 94735, 94735, 94735, 94735, 0, 2177, 0, 2179, 94709,
  94709, 94709, 94709, 96392, 96393, 94735, 94735, 94735, 94735, 96398, 96399, 0, 2193, 0, 94709, 94709, 94709, 94709,
  94709, 94709, 94735, 94735, 94735, 94735, 94735, 94735, 0, 0, 0, 868, 869, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 558,
  559, 0, 562, 563, 0, 0, 0, 94709, 94709, 94709, 94709, 94735, 94735, 94735, 94735, 0, 94709, 94709, 94735, 94735,
  96418, 96419, 94709, 94735, 94709, 94735, 94709, 94735, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1245, 0, 0, 0, 0, 0, 0, 0, 73728,
  77824, 0, 0, 0, 0, 0, 69632, 0, 0, 0, 0, 0, 395, 0, 0, 0, 894, 0, 0, 0, 0, 0, 900, 0, 0, 0, 0, 0, 0, 297, 298, 0, 0,
  0, 0, 0, 0, 0, 0, 276, 275, 0, 275, 355, 275, 276, 0, 0, 420, 420, 420, 420, 90556, 90556, 90556, 90556, 90556, 0, 0,
  420, 0, 319, 319, 467, 319, 319, 319, 420, 319, 420, 420, 420, 420, 420, 420, 420, 420, 420, 420, 420, 420, 420, 420,
  420, 90556, 90556, 420, 94726, 94726, 94726, 94726, 94726, 94752, 94726, 94752, 94726, 94726, 94726, 94726, 94726,
  94726, 94752, 94752, 94752, 94752, 94752, 94752, 94752, 94752, 94752, 94752, 94726, 94726, 94752, 1, 16386, 3, 617, 0,
  0, 0, 94709, 94709, 94709, 94709, 94709, 94709, 94982, 94709, 94709, 94709, 94709, 94709, 95585, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 94709, 95588, 94709, 94709, 94709, 94709, 94709, 0, 877, 879, 0, 0, 881, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1826, 0, 0, 0, 0, 0, 0, 0, 0, 960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 323584, 0, 0, 0, 0,
  95255, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 95269, 94709, 94709, 94709, 94709, 94709, 95598, 94709,
  34160, 0, 1114, 0, 1116, 34160, 0, 1119, 0, 94735, 95394, 0, 1188, 1190, 0, 0, 0, 873, 0, 875, 0, 877, 0, 879, 0, 0,
  0, 910, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 324, 324, 324, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 932, 0, 0, 0, 0, 0, 1215, 0,
  0, 0, 0, 0, 0, 1220, 0, 0, 0, 0, 0, 0, 478, 483, 478, 478, 478, 478, 478, 0, 0, 0, 1263, 0, 0, 0, 0, 0, 0, 1269, 0,
  1271, 0, 0, 0, 0, 0, 0, 480, 0, 480, 485, 485, 485, 485, 419, 419, 419, 91417, 90539, 90539, 90539, 90539, 90539,
  90539, 90539, 91423, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 0, 0, 0, 0, 0, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 377333, 94709, 94709, 94709, 94709, 95567, 94709, 94709, 94709, 94709, 94709, 94709,
  95573, 94709, 94709, 94709, 94709, 94709, 94709, 95956, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709,
  95286, 94709, 95289, 94709, 94709, 94709, 94709, 90539, 90539, 90539, 90539, 91658, 90539, 90539, 90539, 90539, 90539,
  90539, 90539, 90539, 90539, 90539, 90539, 91426, 90539, 90539, 90539, 90539, 0, 1681, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 581632, 0, 0, 1807, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 593920, 0, 90539, 90539, 0, 0, 94709, 94709,
  94709, 94709, 96270, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 95978, 94709, 94709, 94709, 0, 0, 0, 0, 94735,
  94709, 94735, 94735, 94735, 94735, 96280, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 0, 0, 0, 0, 94709,
  324341, 94709, 94709, 94709, 94709, 94709, 94709, 639477, 94709, 94709, 94709, 94709, 95554, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 95309, 94709, 94709, 94709, 94709, 0, 0, 94709, 94709, 94709,
  96413, 94735, 94735, 94735, 96415, 0, 94709, 94709, 94735, 94735, 94709, 94709, 94709, 95798, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94735, 94735, 96103, 94735, 0, 73728, 77824, 0, 364, 0,
  0, 0, 69632, 0, 0, 0, 0, 0, 0, 0, 968, 0, 0, 0, 0, 0, 0, 0, 0, 315, 316, 317, 318, 0, 0, 0, 0, 0, 0, 332, 0, 364,
  90539, 90539, 90539, 90539, 90539, 0, 0, 364, 0, 0, 0, 0, 0, 2114, 0, 835584, 94709, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 95284, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 95803, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 94753, 94753, 94753, 94753, 94753, 94753, 94753, 94753, 94753, 94753, 94727, 94727, 94753, 1,
  16386, 3, 907, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 324, 324, 324, 0, 0, 0, 612, 0, 614, 0, 0, 0, 0, 0, 0, 1945,
  0, 0, 0, 0, 0, 0, 92061, 90539, 90539, 0, 95255, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709,
  467445, 94709, 94709, 94709, 94709, 95799, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709,
  94709, 1612, 1613, 1614, 1615, 94735, 0, 1253, 0, 0, 0, 0, 0, 0, 1258, 0, 0, 0, 0, 0, 0, 0, 983, 0, 0, 0, 0, 315392,
  0, 0, 0, 90539, 594347, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539,
  90539, 90539, 91666, 94709, 94709, 94709, 594421, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 96241, 94709, 94735, 94735, 94735, 94735, 94735, 95579, 94709, 94709, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 979445, 94709, 94709, 94709, 94709, 94709, 34160, 0, 0,
  0, 2051, 0, 0, 0, 2053, 0, 0, 0, 0, 0, 0, 0, 0, 1687, 0, 0, 1690, 0, 1692, 1693, 0, 323, 0, 324, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 935, 0, 73728, 77824, 320, 0, 0, 0, 382, 69632, 382, 382, 0, 382, 0, 321, 382, 404, 0, 0, 0, 0,
  90557, 90557, 90557, 90557, 90557, 455, 455, 0, 455, 462, 462, 462, 468, 469, 462, 481, 462, 481, 481, 481, 481, 481,
  404, 404, 404, 481, 404, 481, 481, 481, 481, 481, 481, 481, 481, 481, 481, 90557, 90557, 481, 94728, 94728, 94728,
  94728, 94728, 94754, 94728, 94754, 94728, 94728, 94728, 94728, 94728, 94728, 94754, 94754, 94754, 94754, 94754, 94754,
  94754, 94754, 94754, 94754, 94728, 94728, 94754, 1, 16386, 3, 0, 0, 0, 1028096, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  573440, 0, 659456, 0, 95994, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735,
  94735, 94735, 94735, 1032719, 94755, 94755, 94755, 94755, 94755, 94755, 94755, 94755, 94755, 94755, 94729, 94729,
  94755, 1, 16386, 3, 0, 689, 0, 0, 0, 0, 0, 0, 0, 689, 0, 0, 0, 0, 0, 0, 596, 597, 598, 599, 0, 0, 0, 0, 0, 0, 349, 0,
  0, 0, 354, 0, 0, 0, 0, 0, 650, 0, 0, 0, 0, 651, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1935, 0, 0, 0, 0, 0, 90539, 90539,
  962987, 90539, 90539, 90539, 90539, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 94709, 94709, 90539, 90539, 90539, 90539, 90539,
  754091, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 90539, 91126, 90539, 90539, 90539, 90539,
  90539, 94709, 94709, 94709, 406005, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709,
  94709, 96240, 94709, 94709, 94709, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 0, 0, 2138,
  0, 1121, 29794, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 406031, 94735,
  94735, 94735, 95654, 94735, 94735, 95657, 938511, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 96203,
  94735, 94735, 94735, 94735, 0, 0, 0, 0, 90539, 90539, 90539, 90539, 90539, 90539, 487851, 90539, 90539, 90539, 90539,
  90539, 90539, 90539, 90539, 90539, 0, 0, 0, 0, 0, 94709, 94709, 96170, 94709, 94709, 94709, 348661, 94709, 94709,
  94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 94709, 643573, 94709, 94709, 94709, 94709,
  94709, 94709, 94709, 94709, 96097, 94709, 94709, 94709, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 348687,
  94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 94735, 1049103, 0, 0, 0, 0, 0, 73728,
  77824, 0, 0, 0, 0, 0, 69632, 0, 0, 0, 0, 391, 0, 0, 0, 0, 114688, 0, 241664, 258048, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2016,
  0, 0, 90539, 381355, 92129, 90539, 0, 1056768, 324, 0, 1056768, 0, 1056768, 0, 0, 1056768, 0, 1056768, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 61440, 1056768, 0, 0, 0, 0, 0, 0, 0, 0, 1056768, 1056768, 0, 0, 0, 0, 0, 0, 1056768, 0,
  1056768, 0, 0, 0, 0, 0, 1056768, 1056768, 0, 0, 1056768, 1056768, 0, 0, 0, 0, 0, 0, 0, 1056768, 0, 0, 1056768, 0,
  1056768, 1056768, 1056768, 1056768, 1057138, 1057138, 1056768, 0, 1056768, 0, 0, 1057138, 0, 0, 0, 0, 0, 0, 1056768,
  0, 1056768, 1056768, 0, 1056768, 0, 0, 0, 0, 0, 1060864, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 749568, 0, 0,
  1064960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1044480, 0, 0, 1065381, 1065381, 1065381, 1065381, 0, 0, 0, 0, 0,
  0, 0, 1065381, 0, 0, 0, 0, 0, 131072, 131072, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 94709, 94709, 94709, 94709, 96301, 94709,
  1065381, 1065381, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1064960, 0, 1073152, 371, 371, 0, 0, 0, 0, 0, 371, 0, 0,
  0, 0, 0, 0, 0, 996, 90539, 90539, 90539, 90539, 90539, 91114, 90539, 90539, 1073152, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1073152, 1073152, 0, 1073152, 1073152, 1073152, 1073152, 1073152, 1073152, 1073152, 1073152, 1073152, 1073152,
  1073152, 1073152, 1073152, 1073152, 1073152, 1073152, 1073152, 1073152, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  954368, 0, 0, 0, 0, 1077248, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 905216, 0, 0, 0, 0, 0, 8192, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 45700, 0, 0, 0, 0, 0, 8192, 8192, 8192, 8192, 8192, 0, 0, 0, 0, 0, 8192, 8192, 8192, 8192, 8192,
  8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 0, 0, 8192, 0, 0, 0, 0, 8192, 0, 0, 8192, 8192,
  8192, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 90539
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  623, 626, 628, 626, 632, 636, 640, 644, 648, 655, 654, 996, 1462, 1561, 655, 897, 700, 660, 1524, 1321, 670, 1071,
  693, 2060, 725, 676, 707, 685, 655, 1264, 655, 691, 697, 725, 727, 706, 707, 712, 655, 904, 1873, 1876, 725, 728, 707,
  702, 655, 655, 719, 725, 1879, 708, 655, 971, 723, 735, 679, 2078, 732, 736, 971, 740, 1882, 744, 1391, 1632, 748,
  752, 756, 760, 764, 765, 769, 772, 776, 780, 784, 788, 655, 964, 655, 792, 655, 655, 655, 655, 796, 655, 655, 857,
  655, 655, 655, 655, 655, 655, 803, 655, 655, 1435, 655, 655, 655, 655, 655, 655, 655, 655, 1578, 655, 655, 655, 655,
  655, 655, 655, 663, 655, 655, 655, 655, 655, 809, 655, 655, 655, 1437, 655, 655, 805, 655, 655, 655, 655, 655, 655,
  655, 655, 1679, 1932, 655, 993, 1026, 815, 819, 823, 827, 834, 655, 811, 840, 844, 1281, 848, 852, 930, 856, 655,
  1420, 861, 865, 1284, 871, 1615, 877, 1054, 882, 655, 887, 901, 966, 910, 655, 919, 655, 883, 835, 1116, 830, 912,
  917, 655, 923, 655, 1309, 1378, 1388, 1918, 878, 929, 1300, 1419, 934, 925, 1590, 1378, 938, 1884, 1329, 1773, 942,
  1302, 1141, 946, 1144, 952, 961, 655, 1479, 970, 1311, 975, 979, 983, 987, 990, 957, 1649, 1728, 1921, 1006, 1010,
  1014, 1018, 1024, 1245, 1468, 1915, 1030, 1034, 1044, 1048, 655, 1558, 655, 1385, 1534, 1058, 1062, 1066, 1250, 1070,
  655, 1075, 655, 1376, 1081, 1088, 1092, 1020, 655, 1255, 1096, 1344, 1410, 1155, 1779, 1101, 1942, 1474, 1106, 1110,
  1114, 1417, 1130, 1120, 1124, 1128, 1134, 1138, 1148, 1152, 1159, 1163, 1167, 1171, 1175, 655, 1051, 655, 1185, 1189,
  1193, 1197, 1201, 913, 1205, 1210, 1214, 1084, 1221, 1225, 1513, 1290, 1954, 1053, 1229, 1233, 955, 1239, 1243, 1249,
  687, 1254, 1662, 1331, 1809, 1235, 2058, 1259, 1268, 655, 1840, 655, 1955, 1945, 890, 1278, 895, 1288, 655, 1294, 655,
  1306, 1315, 1576, 1319, 906, 1577, 1326, 1217, 799, 1519, 1040, 1697, 1180, 1181, 1739, 1335, 1339, 1348, 1352, 1361,
  1365, 1369, 1373, 655, 1904, 1382, 1935, 948, 1395, 1399, 1403, 655, 1407, 1536, 1722, 1414, 1424, 1428, 1432, 1441,
  655, 1445, 1297, 1969, 1452, 1456, 1460, 1629, 655, 1820, 655, 1466, 1472, 1448, 867, 1855, 1097, 1478, 655, 1483,
  1678, 1490, 893, 1494, 1037, 873, 655, 656, 655, 1891, 1498, 1502, 1987, 655, 1967, 1506, 1510, 1517, 1523, 1528,
  1540, 1547, 1584, 1551, 1555, 1690, 1565, 1569, 1707, 1573, 1582, 655, 655, 655, 1588, 1594, 1598, 1602, 1606, 1610,
  1614, 2033, 1619, 1626, 1636, 655, 1640, 1644, 1178, 1648, 1982, 1960, 1653, 1673, 1997, 1657, 2020, 1661, 1102, 1666,
  1357, 1754, 1671, 1677, 1683, 655, 1687, 655, 1002, 655, 1694, 1701, 1705, 1711, 655, 1715, 655, 2072, 2003, 1622,
  1858, 1721, 1726, 2070, 1776, 1732, 1736, 1531, 1743, 1747, 1751, 1758, 1762, 1766, 1770, 1783, 1787, 1794, 1790,
  1798, 1802, 1806, 655, 1667, 1813, 1817, 1827, 1831, 1835, 1838, 655, 1543, 1844, 1848, 1852, 1823, 1862, 1866, 1870,
  655, 1888, 1895, 1899, 1903, 1908, 2077, 1912, 655, 999, 655, 1925, 1929, 1939, 1949, 1953, 836, 1959, 655, 1964, 650,
  1973, 1977, 1077, 1981, 1717, 655, 672, 1986, 1991, 1342, 1995, 666, 655, 2001, 2007, 2011, 714, 681, 2015, 2019, 715,
  2024, 1355, 2028, 2032, 2037, 655, 655, 655, 655, 655, 655, 655, 1271, 2043, 1274, 2047, 2051, 2055, 655, 655, 655,
  2064, 1206, 655, 655, 655, 655, 655, 655, 655, 1261, 655, 655, 655, 655, 655, 655, 655, 655, 655, 1263, 655, 655, 655,
  655, 655, 655, 655, 655, 2039, 655, 655, 655, 655, 655, 655, 655, 1486, 655, 655, 655, 655, 655, 2068, 655, 655, 655,
  2076, 655, 655, 1262, 655, 1485, 655, 655, 655, 655, 655, 1322, 2082, 2089, 2093, 2102, 2102, 2102, 2102, 2097, 2101,
  2106, 2102, 2118, 2112, 2110, 2116, 2122, 2126, 2129, 2131, 2135, 2139, 2143, 2147, 2151, 2155, 2168, 2172, 2176,
  2176, 2176, 4061, 3272, 2176, 2176, 2176, 2176, 2246, 2207, 2216, 2264, 2176, 2176, 3869, 2176, 2176, 4051, 4098,
  2410, 2223, 2176, 2176, 2176, 4071, 2984, 2229, 3049, 3049, 2302, 2176, 2176, 2176, 4128, 2243, 2219, 2176, 2176,
  2176, 4100, 2562, 2564, 2564, 2564, 2565, 2176, 2281, 2176, 3044, 2982, 2199, 3049, 3049, 2260, 2265, 2201, 3049,
  3049, 3049, 3049, 2232, 2260, 2263, 2176, 2176, 2176, 4120, 2176, 2562, 2564, 2280, 3044, 2565, 2979, 2982, 2982,
  2982, 2982, 2983, 2256, 3049, 2565, 3045, 2982, 2982, 3047, 3049, 3049, 2203, 2567, 2982, 2982, 2295, 2291, 2982,
  2296, 2202, 2980, 2294, 3050, 3044, 2293, 3049, 3045, 3048, 2980, 2300, 3046, 2308, 2311, 3255, 4149, 2370, 2315,
  2325, 2325, 2325, 2319, 2373, 2323, 2325, 2325, 4193, 2331, 2327, 2334, 2338, 2342, 2346, 2350, 2352, 2356, 2359,
  2363, 2367, 2377, 2381, 2385, 3617, 2395, 2658, 4079, 2176, 2176, 2417, 2176, 4027, 2421, 2176, 2176, 4123, 3210,
  2176, 3625, 2176, 2176, 2435, 2176, 2176, 3976, 2176, 2176, 2524, 2810, 2741, 2688, 2468, 2480, 2484, 2488, 2490,
  2494, 2496, 2500, 2504, 2505, 2509, 2513, 3681, 2176, 2212, 2645, 2085, 2519, 2599, 2176, 2176, 2176, 2304, 3558,
  4136, 2176, 2530, 2995, 2176, 2438, 2536, 3479, 2817, 3033, 2543, 2164, 2176, 2176, 2163, 2845, 2176, 2176, 2176,
  2428, 4138, 3119, 2554, 2842, 2283, 2560, 2176, 2176, 2600, 3423, 2589, 2593, 2176, 2176, 2606, 3446, 3406, 2176,
  2176, 2176, 2430, 2598, 2176, 2176, 2176, 2476, 2892, 2176, 2176, 3119, 2401, 3196, 2761, 2176, 2176, 2549, 2176,
  2176, 3045, 2982, 2605, 2610, 2616, 2176, 2275, 2176, 2176, 2176, 4124, 3438, 2620, 2611, 2176, 2176, 2176, 2525,
  3403, 2628, 2176, 2176, 2624, 2638, 3376, 2635, 2639, 2176, 2176, 2235, 2663, 2176, 2176, 2176, 2549, 2803, 2876,
  2176, 2431, 2545, 2631, 2176, 2252, 2176, 3890, 2176, 3499, 2669, 2682, 2735, 2176, 3893, 2464, 3522, 2668, 3616,
  2176, 2391, 2176, 2176, 2925, 2176, 2669, 2670, 3618, 2176, 2407, 2176, 2176, 2266, 2176, 2926, 2176, 2176, 2176,
  2562, 2699, 2176, 3119, 3553, 2249, 3096, 3487, 4190, 2706, 2710, 2714, 2718, 2721, 2723, 2727, 2731, 2731, 2734,
  2176, 2442, 2449, 2176, 2185, 2193, 2176, 2158, 3485, 2176, 2176, 3832, 3706, 2471, 2822, 2740, 2745, 3668, 2176,
  2755, 2766, 3712, 3667, 2176, 3190, 2776, 3137, 2176, 2176, 2751, 2930, 3136, 2782, 2176, 2176, 2777, 2459, 2389,
  2793, 2401, 2474, 2807, 4039, 2691, 2599, 3010, 2913, 2176, 2526, 2176, 3227, 2176, 4047, 2816, 2821, 2267, 3780,
  2826, 2176, 2532, 3101, 2176, 2176, 2176, 2869, 2178, 3058, 2849, 2462, 2401, 4025, 4159, 3812, 2854, 2176, 3745,
  2873, 2898, 2176, 2176, 2176, 2564, 3755, 2904, 2176, 2176, 2812, 2678, 3967, 2176, 3119, 2454, 2176, 2176, 3114,
  2850, 3009, 2402, 4158, 4164, 2921, 2176, 3528, 2906, 2176, 2176, 2176, 2585, 2888, 2176, 2176, 2176, 2772, 2282,
  2939, 2177, 2455, 2422, 4156, 2601, 3462, 2176, 3541, 2176, 2176, 2908, 2176, 4230, 3251, 3250, 3462, 2550, 2977,
  2176, 2550, 2977, 2176, 2989, 2176, 3969, 2176, 2971, 2424, 4156, 3249, 4142, 2176, 4140, 2176, 2682, 2176, 2670,
  2800, 2421, 3617, 2988, 2270, 3039, 4141, 2429, 2993, 2999, 3731, 3042, 4157, 3948, 4018, 4017, 2999, 3732, 2994,
  4018, 3003, 3516, 3515, 2999, 3512, 3597, 4052, 2669, 2412, 3618, 2271, 3617, 2583, 2176, 2702, 2176, 2176, 3240,
  2176, 2526, 3015, 3026, 2176, 3288, 2666, 3030, 2656, 3054, 3064, 3068, 3072, 3076, 3080, 3082, 3084, 3088, 3091,
  3091, 3091, 3095, 3100, 2176, 2176, 2176, 2849, 2612, 3142, 2176, 3426, 3276, 2179, 3106, 3262, 2453, 2224, 2224,
  2176, 3878, 2176, 3110, 3175, 4067, 3381, 3473, 3141, 2176, 3425, 3275, 3459, 3108, 2187, 2760, 2176, 4086, 3146,
  2176, 2176, 3152, 3158, 3163, 2176, 3164, 3610, 2176, 3169, 2176, 2176, 2176, 2885, 2398, 2176, 2176, 2176, 2934,
  3278, 3955, 2176, 2176, 3021, 2176, 2176, 2176, 4014, 2176, 3649, 3187, 2176, 2747, 4163, 4033, 3685, 4039, 4178,
  2225, 2176, 3202, 2176, 2769, 2195, 2176, 2268, 2571, 2577, 3164, 3206, 2176, 2176, 3134, 2176, 2176, 4002, 3210,
  2176, 2777, 3358, 2176, 2795, 2176, 2176, 2669, 3254, 3217, 2176, 3017, 2176, 2797, 2176, 2176, 2659, 2695, 4122,
  2187, 3057, 2224, 2176, 3851, 3242, 2176, 2176, 2176, 2282, 3449, 2176, 3018, 2176, 2860, 2176, 2176, 2671, 3179,
  2176, 3775, 2176, 3222, 3242, 2978, 3785, 2176, 2879, 2176, 2176, 3608, 2867, 3212, 2176, 3220, 3970, 3260, 3220,
  3219, 2176, 2880, 2176, 2176, 3747, 3447, 3261, 3221, 3220, 3259, 3412, 3212, 2176, 3411, 3218, 3785, 3220, 3266,
  3413, 3786, 3213, 2176, 2917, 2176, 2176, 2890, 2176, 3286, 2176, 2735, 2176, 2924, 2452, 2176, 2644, 2649, 2176,
  2292, 3047, 2202, 2445, 3293, 3297, 3301, 3305, 3309, 3317, 3311, 3313, 3321, 3321, 3321, 2176, 3701, 3285, 2176,
  2938, 2176, 3056, 3277, 3007, 2573, 2176, 2966, 2176, 2176, 2909, 2176, 3942, 3325, 3335, 3232, 3343, 3642, 3349,
  3353, 4174, 2599, 4107, 2685, 2176, 2969, 2176, 2176, 2437, 2176, 4204, 2176, 2176, 4203, 2176, 3702, 3101, 2176,
  2971, 3364, 3417, 3364, 3369, 2177, 3375, 2176, 3725, 2176, 3011, 3556, 3380, 2176, 2176, 3148, 2176, 3701, 2161,
  2176, 2176, 3153, 2787, 3345, 3400, 2176, 2176, 3164, 2960, 3387, 2176, 2176, 2176, 3059, 2640, 3395, 2176, 2176,
  3165, 2176, 2176, 3435, 2176, 2176, 3442, 3365, 2176, 2176, 3718, 3360, 2176, 2971, 3466, 3472, 2176, 3477, 2912,
  2176, 3883, 2176, 3331, 2761, 3277, 3839, 2176, 3124, 3388, 3135, 3939, 2788, 2176, 2176, 3223, 3242, 3491, 2176,
  2176, 2176, 3096, 3497, 2176, 2239, 2176, 3127, 3795, 2176, 3153, 2176, 2176, 2778, 3359, 2758, 2176, 3005, 2176,
  3182, 3937, 2799, 3939, 3940, 2176, 3229, 2735, 3371, 2971, 3503, 3941, 2599, 3229, 2176, 3192, 2830, 2176, 2563,
  2564, 2566, 2789, 2403, 2176, 3520, 2822, 2176, 3252, 3251, 2176, 4156, 4155, 2176, 3210, 2176, 2176, 2176, 2994,
  4155, 3250, 2176, 2176, 3229, 2176, 2176, 3958, 2611, 2176, 2176, 2676, 3248, 2176, 2453, 3625, 2973, 3527, 3532,
  3269, 3538, 3550, 3562, 3566, 3584, 3570, 3574, 3578, 3582, 3588, 3590, 3590, 3591, 2176, 2176, 2176, 3120, 3595,
  2176, 2176, 2270, 2863, 2189, 3060, 3636, 3546, 3601, 2176, 3211, 3385, 2176, 2982, 3048, 2203, 2881, 3243, 2176,
  3605, 3614, 3824, 2176, 2594, 2176, 3631, 3623, 3629, 2701, 2176, 2176, 2176, 3154, 3545, 3338, 2269, 4181, 3646,
  2900, 3818, 3988, 3653, 2176, 2176, 2176, 3173, 3641, 2176, 2176, 2176, 3183, 3339, 4172, 3505, 2176, 2839, 2176,
  3659, 2176, 2176, 2176, 3197, 3683, 3672, 2176, 2880, 2836, 2176, 3691, 3698, 2176, 3231, 2176, 3509, 2176, 3746,
  3710, 2176, 3236, 3102, 4088, 2972, 3544, 3459, 4173, 3716, 3115, 2176, 2176, 3253, 3252, 2176, 3722, 2176, 3791,
  3991, 3768, 2176, 2176, 3354, 4057, 2736, 2176, 2176, 2176, 3218, 3990, 3767, 2176, 2176, 3459, 2761, 2971, 3772,
  2180, 3717, 3784, 2822, 3790, 2176, 3247, 3096, 3328, 2176, 3801, 3739, 2893, 3744, 2413, 3805, 3811, 3117, 2822,
  3816, 2176, 3277, 3977, 2865, 3655, 3795, 2176, 3655, 3795, 2783, 2940, 3419, 3116, 2833, 2939, 3661, 3665, 2176,
  3663, 2544, 3761, 3619, 3287, 2176, 2783, 2599, 2944, 2176, 4183, 2276, 2668, 3943, 3947, 2539, 2894, 3822, 3945,
  3828, 2539, 2538, 3944, 2556, 3823, 3946, 2962, 2538, 3534, 3836, 3844, 3848, 3858, 3855, 3860, 3864, 2910, 2176,
  3289, 3467, 2423, 3938, 2176, 2176, 2799, 3868, 3873, 3882, 2176, 3392, 3396, 2176, 3036, 3740, 4112, 3887, 3897,
  3901, 3905, 3909, 3912, 3916, 3919, 3922, 3926, 3930, 3932, 3933, 2176, 2176, 3504, 3130, 4165, 2956, 3164, 3952,
  2181, 3159, 2176, 4110, 3797, 2176, 3409, 2176, 3430, 3941, 2176, 3118, 2176, 3752, 2857, 2176, 3962, 2210, 3675,
  2176, 4094, 3975, 2176, 4093, 3974, 2176, 3431, 2564, 2564, 2176, 2979, 2982, 2287, 3049, 3049, 3050, 2176, 2176,
  2252, 2176, 3211, 4007, 2911, 2176, 3453, 2176, 3330, 2955, 2670, 3022, 4156, 3456, 2176, 4111, 3148, 2946, 2176,
  2176, 2176, 3282, 3981, 3985, 4045, 3460, 2176, 3995, 3999, 2176, 3458, 2760, 2176, 2515, 2653, 2176, 2387, 3840,
  2423, 4006, 3728, 2176, 4011, 2176, 4022, 3778, 2176, 3461, 2520, 2176, 2176, 4130, 3694, 4111, 3965, 4031, 2176,
  3468, 2951, 2176, 2672, 3019, 2868, 2176, 3807, 4037, 4043, 3459, 2176, 2176, 2176, 3448, 2176, 4073, 2176, 2176,
  2176, 3635, 4051, 4056, 3485, 2176, 3483, 2176, 2176, 3220, 2971, 3523, 2954, 3876, 4065, 3779, 2390, 2176, 2947,
  2178, 2176, 2176, 2176, 3748, 4077, 2176, 2176, 2176, 3758, 4083, 2801, 3617, 3678, 2176, 4092, 2176, 2176, 3745,
  3640, 2176, 4104, 2176, 2176, 3746, 3744, 4116, 2802, 2421, 2867, 4109, 2176, 2176, 4181, 2176, 4134, 2580, 3533,
  2762, 2176, 2176, 2176, 3763, 2176, 4120, 3211, 4146, 2176, 4153, 2176, 4225, 3218, 2176, 2176, 2176, 3957, 3043,
  2422, 2176, 2176, 3829, 2176, 3685, 2750, 3687, 4169, 4187, 4197, 4208, 4212, 4217, 4216, 4221, 4224, 2749, 3198,
  4200, 2176, 3493, 2176, 2176, 2981, 2982, 2176, 4229, 2176, 3020, 2176, 3830, 2176, 2176, 3831, 3736, 2238, 2176,
  2176, 3838, 2176, 2176, 2176, 3431, 4303, 4671, 4234, 5076, 4236, 5072, 4592, 5076, 5047, 5074, 4741, 4242, 4253,
  4256, 4244, 4267, 4632, 4243, 4244, 4245, 4267, 4267, 4267, 4267, 4267, 4242, 4244, 4246, 4262, 4264, 4267, 4267,
  4254, 4267, 4266, 4267, 4267, 4267, 4261, 4246, 4271, 4278, 4272, 4273, 4275, 4280, 4279, 4280, 4280, 4280, 4280,
  4281, 4277, 4278, 4282, 4277, 4287, 4281, 4283, 4278, 4284, 4285, 4898, 4289, 4396, 4294, 4292, 4290, 4293, 4296,
  4298, 4296, 4297, 4296, 4300, 4302, 4248, 5069, 4392, 4613, 4783, 5076, 5076, 4578, 4542, 5076, 5085, 4234, 5076,
  5034, 4744, 4336, 4420, 4681, 5076, 5076, 5076, 5076, 4237, 5076, 5076, 4745, 4681, 4331, 4309, 5076, 4926, 5036,
  5076, 4237, 4892, 4659, 4449, 5076, 5076, 4240, 5076, 4677, 4718, 4719, 4314, 4314, 4314, 5076, 5076, 4314, 4320,
  4321, 5076, 4316, 5076, 5076, 4716, 5072, 5085, 5076, 4336, 4336, 4426, 4427, 4681, 4329, 5076, 5076, 5076, 4268,
  5076, 4718, 4318, 4719, 4314, 4314, 4347, 5076, 4322, 5055, 4563, 5076, 5076, 5076, 4916, 4314, 4347, 4347, 4335,
  4507, 4914, 4306, 4250, 4672, 5076, 4322, 5055, 4742, 4717, 4717, 4318, 4318, 4314, 4347, 4347, 4336, 4427, 4427,
  5076, 5076, 5076, 4239, 5076, 5076, 5076, 4258, 4667, 5076, 5076, 5036, 5076, 4746, 4367, 4367, 5076, 5076, 5076,
  4305, 4572, 4665, 4677, 4718, 4319, 4367, 5076, 4665, 4665, 4665, 4896, 4314, 4314, 4314, 4896, 4314, 4314, 4315,
  5076, 5076, 4248, 4325, 4314, 4676, 4896, 4897, 4897, 4897, 4315, 4378, 4353, 4349, 4355, 4384, 4688, 4692, 4683,
  4349, 4350, 4688, 4688, 4688, 4688, 4670, 4690, 4377, 4383, 4688, 4688, 4669, 4693, 4669, 4747, 4689, 4688, 4398,
  4352, 4351, 4350, 4400, 4402, 4403, 4688, 4683, 5040, 4405, 5041, 5041, 5042, 5042, 5043, 5044, 4408, 4408, 4407,
  4407, 4412, 4409, 4414, 4442, 4409, 4416, 5076, 4423, 4688, 4684, 4424, 4691, 4376, 4380, 4382, 4692, 4432, 4694,
  4434, 4437, 4436, 4437, 4439, 4441, 4410, 5076, 5076, 4248, 5076, 5076, 5076, 4539, 4569, 5038, 5076, 5076, 4628,
  4838, 4509, 5076, 4330, 5076, 5076, 4893, 4509, 5076, 5037, 4451, 5076, 4331, 4475, 5076, 4713, 5076, 5075, 5076,
  5076, 4924, 4239, 4667, 5076, 5076, 5076, 4330, 5076, 4681, 4699, 5076, 5076, 5076, 4331, 4450, 4592, 5076, 5076,
  5034, 5076, 5076, 5076, 4334, 4480, 4745, 5076, 4927, 4361, 5076, 4846, 4480, 4499, 4497, 4666, 5076, 5076, 5076,
  4585, 5076, 4258, 4926, 4478, 4483, 5076, 4343, 5076, 5076, 4430, 5076, 4539, 4926, 4617, 5076, 4356, 4662, 5076,
  4357, 5076, 5076, 4394, 4783, 4616, 4784, 4741, 4512, 4513, 4514, 4515, 4515, 4518, 4517, 4518, 4518, 4521, 4520,
  4523, 4525, 4528, 4528, 4528, 4527, 4526, 4528, 4527, 4528, 4530, 4530, 4530, 4530, 4532, 4532, 4534, 4532, 4533,
  4536, 4538, 5076, 5076, 4322, 4372, 4479, 4394, 4630, 4783, 4509, 4544, 5076, 5076, 5076, 4338, 4666, 4510, 4983,
  5076, 5076, 4338, 4895, 4618, 5086, 5076, 5076, 4338, 4982, 5036, 4548, 5076, 5076, 5076, 4344, 4711, 4713, 5076,
  5076, 5076, 4362, 5072, 4557, 5076, 5076, 4364, 5076, 5072, 4730, 5076, 5076, 4367, 4367, 4367, 4367, 4368, 5076,
  4676, 4307, 5076, 5076, 4335, 4557, 5076, 4577, 4728, 4611, 5076, 4449, 5076, 4475, 4475, 5076, 5076, 4464, 4490,
  4580, 4450, 4328, 4583, 4471, 5076, 5076, 5076, 4447, 4783, 4509, 5076, 5076, 5076, 4335, 4681, 5072, 5076, 5076,
  5076, 4455, 4776, 4306, 5076, 5076, 5076, 4460, 4305, 4590, 4610, 4742, 4372, 4781, 4492, 4563, 4786, 4450, 4328,
  4782, 4624, 4492, 4563, 4306, 4449, 4592, 4306, 4450, 4328, 4503, 4615, 4251, 5076, 5076, 5076, 4463, 5072, 5076,
  4711, 4306, 5076, 5076, 5072, 4592, 4306, 4624, 4563, 4306, 5076, 4472, 4373, 5076, 5076, 5076, 4306, 4328, 4592,
  4251, 5076, 4472, 5076, 5076, 4475, 5076, 5076, 5076, 4472, 4745, 4612, 4574, 4509, 5076, 4891, 4676, 5076, 5076,
  4971, 5076, 4509, 4890, 5076, 4539, 4891, 5076, 4356, 4559, 4502, 4744, 4335, 5076, 4605, 4268, 4269, 5076, 5076,
  4369, 4961, 5076, 4311, 4626, 4312, 4634, 4636, 4641, 4641, 4644, 4646, 4645, 4645, 4638, 4645, 4640, 4648, 4641,
  4641, 4641, 4641, 4642, 4641, 4643, 4642, 4641, 4649, 4650, 4650, 4650, 4650, 5076, 5076, 5076, 4475, 4247, 4675,
  5076, 5076, 5076, 4496, 5076, 5033, 4747, 5076, 4748, 4748, 5076, 5076, 5076, 5068, 5076, 5037, 4705, 5076, 4540,
  5076, 4585, 5076, 5076, 5076, 4480, 5076, 5076, 5093, 5076, 4545, 4554, 5076, 4370, 4541, 4967, 5077, 5076, 5076,
  5076, 4498, 4715, 4727, 5076, 5076, 5076, 4501, 4652, 5076, 5076, 5076, 4509, 4509, 5038, 4343, 5076, 5076, 4394,
  4575, 5076, 5076, 4368, 5076, 5076, 4449, 5076, 4269, 5076, 5076, 4980, 5076, 4547, 5076, 5076, 4325, 4846, 5092,
  5076, 5076, 5076, 4555, 5038, 5076, 5076, 5076, 4558, 4388, 4734, 4700, 4575, 4735, 4592, 4509, 5076, 4558, 4744,
  4475, 4708, 5088, 5076, 4558, 4798, 5076, 4568, 4306, 5076, 4394, 4491, 4575, 5076, 5076, 5038, 5076, 4713, 4426,
  4664, 4509, 5076, 4570, 5030, 5076, 4574, 4509, 5076, 4491, 5076, 4335, 5036, 5076, 5076, 5076, 4612, 4358, 4737,
  5076, 4747, 5076, 4591, 4742, 5076, 4480, 5076, 5076, 5076, 4892, 4687, 4678, 4552, 4623, 4987, 5076, 5076, 4457,
  5076, 5076, 5076, 4449, 4653, 4395, 4575, 5076, 5076, 4448, 5076, 4488, 4366, 4655, 4509, 5076, 5076, 4456, 5076,
  5076, 5076, 4368, 4509, 5076, 4596, 5089, 4599, 4666, 4425, 4826, 4509, 5076, 4596, 5089, 4599, 4502, 5076, 4455,
  4488, 4654, 4575, 5037, 4678, 4552, 4623, 4305, 4744, 5076, 5076, 5076, 4653, 4926, 4737, 5076, 5076, 4457, 4927,
  5076, 4488, 4606, 4509, 5076, 4609, 4449, 5076, 4748, 4475, 4505, 4454, 5036, 5076, 5036, 4745, 4678, 4488, 4606,
  5076, 4630, 5076, 5076, 4258, 5076, 5076, 4257, 4740, 5076, 5076, 5076, 4676, 4665, 4665, 4665, 4665, 4677, 4717,
  5076, 5076, 5076, 5089, 5076, 4894, 5075, 5076, 5076, 5076, 4333, 5076, 5076, 5088, 4672, 5076, 5089, 4713, 5076,
  5076, 5037, 4344, 5076, 5076, 5076, 4608, 5076, 4373, 4609, 5076, 4460, 4573, 5076, 5076, 5076, 4746, 5076, 5036,
  5076, 5028, 4420, 4664, 4373, 5038, 4421, 5076, 4673, 5087, 5076, 4374, 5024, 5076, 4391, 4427, 5076, 4391, 5076,
  5076, 5076, 4665, 4665, 4314, 4314, 4314, 4314, 4315, 4237, 4473, 4237, 5076, 4958, 5076, 5076, 5076, 4596, 4750,
  4753, 4417, 4417, 4418, 4603, 4602, 4755, 4756, 4758, 4770, 4770, 4761, 4763, 4764, 4765, 4764, 4765, 4767, 4770,
  4770, 4770, 4770, 4772, 4771, 4770, 4769, 4759, 4774, 4774, 4774, 4774, 4775, 5076, 5076, 5076, 4711, 4895, 4783,
  5076, 5076, 5076, 4708, 5076, 5076, 5088, 4330, 5076, 5076, 4481, 4608, 4788, 5076, 5076, 5076, 4715, 5076, 5076,
  5076, 4716, 4363, 4851, 4801, 4804, 5076, 4682, 4455, 4829, 4628, 4832, 4575, 4806, 4808, 5076, 5076, 5076, 4725,
  4727, 4460, 4778, 4420, 4368, 5076, 4812, 4817, 5076, 5076, 4493, 5076, 4928, 5076, 5076, 5076, 4743, 4652, 4925,
  5076, 5076, 5076, 4744, 4818, 5076, 5076, 5076, 4745, 5076, 4824, 4627, 4837, 4575, 4810, 4783, 5076, 5076, 4494,
  4660, 4745, 4551, 4573, 5076, 4687, 4342, 4974, 4631, 4831, 4562, 4509, 5076, 4688, 5076, 5076, 4387, 4389, 4780,
  5076, 5076, 5076, 4747, 4672, 5076, 5076, 5060, 4712, 4752, 4830, 4359, 4712, 4268, 5076, 5076, 5076, 4749, 5076,
  4927, 4810, 5076, 5076, 5076, 4750, 5076, 5076, 5076, 4751, 4840, 4472, 4681, 5076, 5076, 4508, 5076, 5076, 5076,
  4879, 4780, 5076, 5076, 4958, 4751, 4840, 4712, 5076, 5076, 5076, 4259, 5076, 5076, 4927, 5076, 5076, 5076, 4681,
  5076, 5076, 5076, 4667, 4563, 5076, 5076, 4926, 5076, 5076, 5076, 4780, 4750, 5076, 4926, 5076, 4711, 4324, 5076,
  4711, 4701, 5076, 4249, 5076, 5076, 5076, 4713, 4337, 4747, 4506, 4474, 4629, 4360, 4892, 5076, 5076, 5076, 4466,
  5076, 4891, 4850, 4849, 4848, 4720, 4853, 4855, 4857, 4859, 4859, 4871, 4872, 4865, 4864, 4865, 4863, 4866, 4870,
  4859, 4859, 4859, 4859, 4860, 4861, 4868, 4875, 4874, 4867, 4861, 4861, 4861, 4861, 4345, 4877, 4712, 5076, 4711,
  5076, 5076, 4539, 4715, 4493, 4391, 4462, 4569, 5076, 4712, 4237, 5076, 5076, 4882, 4509, 5076, 5076, 4539, 5054,
  5076, 5076, 4950, 4658, 4802, 5076, 5076, 5076, 4785, 4715, 4390, 4493, 4585, 5076, 5076, 5076, 5038, 5076, 5076,
  4337, 5076, 4904, 5076, 5076, 4540, 4958, 4461, 5076, 5076, 5076, 4786, 4906, 5076, 5076, 5076, 4795, 4468, 4490,
  4588, 5076, 5076, 5076, 4806, 5076, 5076, 4908, 4465, 4607, 4239, 5076, 5076, 4622, 4796, 4958, 5076, 4716, 4322,
  4372, 4582, 4470, 5076, 4463, 4927, 5076, 4749, 5076, 5076, 4749, 4335, 5075, 5076, 5076, 4596, 5076, 4491, 4509,
  5076, 5076, 4612, 5076, 5076, 4608, 5076, 5076, 4663, 4367, 4506, 4910, 4783, 5076, 4729, 4716, 4322, 4539, 4715,
  4373, 4493, 4587, 4235, 5076, 5076, 5076, 4810, 5076, 5088, 4326, 4815, 5076, 4744, 5076, 5076, 4716, 5076, 5076,
  5076, 4479, 5076, 5076, 5037, 5076, 5076, 4716, 4455, 4337, 5076, 5076, 5076, 4819, 4335, 4509, 5076, 5076, 4619,
  5076, 4335, 4507, 4968, 4306, 5076, 5076, 4621, 5076, 4586, 4968, 5076, 5076, 4627, 4561, 4469, 4509, 5076, 5076,
  4663, 4509, 5037, 5076, 5076, 5076, 4834, 5076, 4539, 4715, 5076, 4258, 5076, 4986, 5076, 4667, 5073, 5076, 5076,
  5076, 4918, 5076, 5076, 4663, 5076, 5076, 4920, 5076, 5076, 4926, 4737, 4486, 5076, 5036, 5076, 5076, 4419, 4486,
  4716, 4564, 4716, 4487, 4623, 5075, 4361, 5076, 4599, 5076, 5076, 4337, 5076, 4716, 4337, 5076, 4335, 4653, 4663,
  5076, 5076, 4550, 5076, 4922, 4933, 4923, 4566, 4565, 4932, 4612, 4930, 4936, 4936, 4936, 4937, 4942, 4941, 4941,
  4931, 4939, 4939, 4940, 4944, 4941, 4941, 4941, 4941, 4936, 4935, 4946, 4941, 4948, 4948, 4948, 4948, 4949, 4959,
  4306, 5076, 5076, 4667, 5075, 4702, 4237, 5076, 4238, 5076, 5076, 4952, 5076, 4745, 4505, 4454, 4600, 4712, 5076,
  4956, 5076, 5076, 4667, 5076, 5076, 4667, 4450, 5076, 4994, 5076, 5076, 4676, 5076, 4335, 5076, 4957, 5076, 4304,
  5076, 4258, 5076, 5076, 5075, 4361, 4814, 4798, 5076, 5076, 5076, 4884, 5076, 5076, 4963, 5076, 4745, 4752, 4627,
  4966, 4797, 5076, 5076, 4682, 4459, 5076, 4975, 5076, 5076, 4682, 4979, 4328, 4744, 5076, 5076, 4696, 4698, 5076,
  5076, 5054, 4844, 5076, 4745, 5046, 5076, 4746, 5036, 5076, 4747, 4258, 5076, 4748, 5076, 4747, 4748, 5076, 4304,
  4682, 4679, 4428, 5054, 4489, 4485, 4584, 4970, 4614, 4798, 5076, 4747, 4506, 4474, 4613, 4429, 4541, 4560, 4797,
  4601, 4509, 5076, 5076, 4707, 4722, 4745, 4686, 5076, 5076, 5076, 4912, 5054, 4815, 4585, 5076, 4749, 4880, 4738,
  5076, 4663, 5076, 4713, 5076, 5076, 4327, 4459, 4428, 5054, 4977, 5076, 5076, 5076, 4953, 4827, 5076, 5076, 5076,
  4926, 4323, 4601, 4235, 5076, 5054, 4815, 5076, 4749, 5068, 4455, 4469, 4235, 5076, 4594, 5076, 5076, 4369, 4371,
  4825, 4429, 4541, 4815, 4585, 4491, 5076, 4599, 5076, 4751, 4712, 5076, 4708, 5076, 5076, 5076, 5039, 4558, 5076,
  5076, 5076, 4927, 4749, 4744, 5076, 4475, 4744, 4304, 4541, 4744, 5076, 5076, 4710, 5076, 5076, 4973, 4459, 4813,
  5036, 4237, 5076, 5076, 4716, 5053, 4745, 4748, 5076, 5076, 5037, 4744, 4667, 4708, 5076, 5088, 5076, 5076, 4985,
  5076, 5076, 5076, 4964, 4653, 5076, 4746, 5076, 5076, 5076, 4973, 4680, 4328, 5076, 4745, 5076, 5076, 5076, 5038,
  4657, 4338, 4982, 5076, 4338, 4982, 5076, 4746, 5076, 4751, 4836, 4359, 4373, 4745, 5076, 4419, 4373, 5076, 4419,
  5076, 4456, 4458, 4458, 4458, 4458, 5076, 5076, 5076, 5075, 5076, 4609, 5076, 4344, 4748, 4475, 5076, 5076, 4790,
  4820, 4668, 5076, 5076, 4667, 4892, 5076, 4989, 5075, 4667, 4450, 4892, 5076, 4504, 4457, 4927, 5036, 5075, 4993,
  5035, 5076, 5076, 5035, 4996, 4744, 4267, 4708, 4723, 4709, 4999, 5001, 5003, 5004, 4954, 5005, 5006, 5007, 5009,
  5011, 5015, 5015, 5018, 5019, 5013, 5015, 5016, 5015, 5012, 5016, 5003, 5021, 5022, 5022, 5022, 5022, 5076, 4631,
  4738, 5076, 5076, 5076, 4997, 5076, 5076, 5076, 4419, 4328, 5076, 5076, 5076, 4426, 4750, 5076, 5036, 5076, 4793,
  5076, 5076, 4500, 4629, 4959, 5032, 5076, 4467, 5076, 4796, 5076, 5076, 4743, 5076, 5076, 5076, 4666, 4393, 5025,
  5076, 5076, 5076, 5034, 4821, 5076, 5069, 4846, 4968, 5076, 5076, 5051, 5076, 4798, 5076, 5076, 4682, 4455, 4825,
  5076, 5088, 5068, 5070, 4393, 4614, 4235, 5076, 4834, 4829, 4490, 4749, 4671, 4714, 4631, 4738, 4373, 4344, 4747,
  4667, 5076, 4365, 5076, 4327, 5075, 5076, 5076, 4746, 4653, 5076, 4893, 4368, 5076, 5076, 4444, 4446, 5076, 5053,
  5076, 5076, 4747, 5076, 4614, 4509, 5076, 5076, 4748, 5076, 5057, 5076, 4666, 4585, 5076, 5076, 4732, 5076, 5076,
  5076, 5076, 5088, 4258, 5068, 5059, 4500, 4613, 4235, 5076, 4990, 5055, 4738, 4745, 4653, 5076, 5076, 4792, 5076,
  5088, 4325, 4429, 4323, 4614, 4235, 5061, 4306, 5076, 5076, 4799, 5076, 4749, 4991, 4361, 5076, 4843, 4712, 5076,
  5076, 4268, 4484, 5076, 5076, 5076, 5049, 4393, 5071, 4703, 5076, 5076, 4823, 4829, 4812, 4323, 4306, 5076, 4888,
  5076, 5076, 4539, 5076, 5076, 5076, 5027, 4990, 4712, 5076, 4368, 5076, 5071, 4466, 5076, 5076, 5076, 4752, 4490,
  4391, 4323, 5076, 5076, 4842, 4476, 4749, 4991, 5076, 5076, 4891, 4304, 5076, 5076, 4332, 5073, 5076, 5076, 4991,
  5076, 4344, 5076, 4891, 4585, 5067, 5076, 5071, 5076, 5076, 4893, 5076, 5076, 4509, 5076, 5076, 4747, 4747, 5076,
  5076, 5076, 4609, 4597, 5076, 4685, 5076, 4891, 5076, 5076, 5076, 4886, 5063, 5066, 4747, 5076, 4892, 5076, 5076,
  4678, 4552, 5064, 5076, 4745, 4747, 4310, 5038, 4688, 4691, 4688, 4386, 5090, 4452, 5091, 4748, 5095, 5080, 5076,
  4900, 4902, 4239, 5076, 4685, 4340, 4453, 4339, 4341, 4339, 4339, 5084, 5083, 5079, 5079, 5079, 5079, 5083, 5082,
  5082, 5095, 5076, 5076, 5076, 5071, 4749, 4258, 5076, 5076, 4391, 524288, 1073741824, -2147483648, 128, 0,
  -1073741824, 0, -1023410176, 16777218, 16777472, 553648128, -2130706432, -2130706432, 16777216, 8, 16, -2147483648,
  536870912, -2147483648, 16777728, 16781312, -2130706432, 276824064, 8388608, 64, 0, 7, 16784896, 16781312, 269639680,
  1351680, -2130706432, 1122304, 16777216, 16777216, 33554432, -2147483648, 16777218, 754974722, 18874368, 18878464,
  555745280, 555745280, -1392508926, 754974722, 754974722, 150994946, 150994946, 754974722, 218103810, 150994946,
  757071874, 754974722, 218103810, 218103810, 12583040, 20971648, -2126512000, 557842560, 20971648, 20971648, 20971712,
  -2126504256, -2126504256, -2126504254, -2126504256, 759169154, 759169154, -1992286526, 4, 8, 0, -2147483648, 0,
  -1879048192, 3584, 0, 296, 4194320, 39850256, 4194368, 4194368, 0, 2816, 192, 192, 4194368, 4288, 3072, 32768, 262144,
  128, 512, 2048, 524288, 1048576, 8192, 0, 3072, 4096, -2097152000, 0, 256, 256, 0, 32, 32, 34, 32, 64, 32768, 0, 33,
  4288, 4288, 524304, 1048592, 16, 528, 528, 262160, 268435472, 16, 4352, 2097152, 8388608, 16777216, 67108864, 0, 7168,
  32768, 1048576, 1048576, 2097152, 2097152, 0, 1840, 28672, 131072, 524288, 0, 1920, 24, 560, 48, 80, 48, 1049104,
  1572880, 524304, 16, 131088, 17, 20, 8064, 131072, 786432, 0, 8192, 49152, 262144, 2097152, 12582912, 20971712, 16,
  165675008, 528, 1049136, -164575404, -164575404, -164575403, -164625872, -164575403, -164575376, -164575372,
  -164575372, -164313228, -26200268, -164313232, -164100176, -164100172, -164313228, -164575372, 0, 8200, 32, 512, 4096,
  -2147483648, 16, 536936448, 16, 256, 4096, 4096, 8192, 16384, 1026, 21, 112, 117, 140521492, 140571964, 140571932,
  140571932, 141620508, 140571933, 140571964, -164575372, -164100175, 8192, 138412032, 239075328, 0, 18432, 0, 32768,
  131072, 24, 24, 32, 256, 512, 0, 512, 512, 1024, 0, 640, 0, 768, 6144, 262144, 0, 896, 6144, 134217728, -1342177280,
  0, 1024, 1024, 2048, 0, 1026, 66048, 16384, 65536, 0, 43008, 65536, 268435456, 4194304, 67108864, 256, 7168, 786432,
  262144, 8388608, 67108864, 134217728, 0, 1056, 82432, 65536, 65536, 16384, 16384, 32768, 4194304, 33554432, 67108864,
  2, 8, 512, 6144, 1073741824, 0, 49280, 344506528, -2097147888, -2097147888, -1819750272, -1819750272, -1021046768,
  277467296, 277467296, -1870081888, -1870081888, 277475744, -1836527456, -1819750240, -1836527455, -1819750224,
  -1870015839, -1819750224, -1819750224, -1080370048, -1080370048, -1080370044, -1080370044, -1080370043, -1080370044,
  -1080370000, -1080370000, -1080370012, 0, 65536, 131072, 1572864, -1082130432, 66048, 0, 118912, 82432, 0, 119424,
  2359296, 1073741824, 512, 7168, 276824064, 0, 127360, 75497472, 0, 131072, 2097152, 16777216, 100663296, 268435456,
  536870912, -1073741824, 268451840, 7, 4096, 50331648, 0, 147456, 128, 4096, 2097152, 268435456, 1073741824, 12288, 0,
  187520, 128, 7168, 1048576, 125829120, 134217728, 536870912, 0, 6144, 201326592, -1073741824, 128, 32768, 33554432,
  268435456, 32768, 268435456, 1, 2, 10, 256, 1048576, 4194304, 536870912, 8200, 1064960, 288, 1048576, 8388608,
  201326592, 0, 524288, 58720256, 0, 262144, 16777216, 134217728, 268435456, 1076101120, 0, 53376, -1870659584, 1048608,
  0, 786432, 1048576, 33554432, 32832, 8192, 65536, 262144, 4194304, 8388608, 33554432, 16777472, 1208090624,
  1224867840, 1208090624, 1208090626, 778129680, 1315000592, 778129680, 1247940880, 1247940880, -899542768, 1247940880,
  241258768, 241258768, 1208090922, 241258768, 1247940880, 1526603668, 1526603668, 288, 0, 1048576, 12582912, 268435456,
  32832, 0, 1056768, 0, 328, 39845888, 0, 2097152, 4194304, 4194304, 0, 2048, 16, 28, 16, 32, 0, -1837105152,
  1207959552, 0, 4194304, 128, 256, 1536, 4096, 0, 48, 16, 2, 2, 4, 16, 16, 17, 16, 20, 16, 21, 53, 16, 135424,
  1247805440, 0, 12582912, 33554432, 33554432, 262144, -2147483648, 86272, 241172480, 778043392, 0, 16777216, 150994944,
  0, 33554432, 0, 64, 131072, 0, 128, 128, 192, 64, 16810000, 1314914304, 0, 33620032, 20, 925568, 1525678080, 0,
  41943040, 58720256, -1879048192, 81920, 100663296, 786432, 3145728, 12582912, 65536, 67108864, 1073741824, 786432,
  8388608, 268435456, -2147483648, 16777216, 0, 1, 0, 2, 0, 4, 0, 6, 1024, -2147483136, 67117064, 184649728, 184649728,
  184650752, 251766792, -1895716344, 201369608, 201369608, 184650784, 201369928, 201369928, 201369944, 234989576,
  201369928, 252292104, 251766792, 251766792, 252291080, 251766792, 1602726927, 1602726927, 0, 50331648, 1, 1073741824,
  16384, 1048576, 58720256, 67108864, 268435456, 8, 128, 3072, 34816, 184614912, 8, 43008, 344, 0, 100663296, 234946560,
  0, 134217728, 805306368, 0, 163577856, 1032, 0, 245366784, 520, -2147483648, 1039, 43008, 528941056, 1073741824, 32,
  4194304, 8, 8192, 131072, 16777216, 268435456, 65536, 117440512, 0, 251723776, 0, 67108864, 1, 14, 1024, 4096,
  4194304, 1073741824, 1024, 8192, 262144, 25165824, 100663296, 1, 6, 1024, 262144, 125829120, 268435456, 1024,
  16777216, 2, 65536, 16777216, 805306368, 16384, 16777216, 268437504, 67108868, 67108868, 0, 252248064, 67108868,
  75497732, 33564833, 33562785, 33563297, 50340001, 1182802341, 1182802341, -830194779, -830194779, 246423845,
  246423845, 244326693, 244326693, 1182802341, 109060517, 109060517, 246423845, 1182802341, 243278117, 318777505,
  109846949, 109322661, 109060517, 128, 10240, 37, 384, 8388608, 8192, 109051904, 37, 243269632, 384, 109051904, 270336,
  794624, 37, 0, 268435456, 0, 4096, 524288, 4194304, 4194368, 4194304, 4194432, 37, 896, 276480, 243269632, 256,
  8388608, 384, 1073741824, 4, 896, 2048, 16777216, 256, 67108864, 201326592, 1073741824, 2048, 268435456, 4096,
  1073741824, 16384, 67108864, 32768, 268451840, 32768, 100663296, 0, 16384, 0, 320, 256, 822231040, 805453824, 0,
  268451840, 33024, 805519360, 805519360, 805521408, 805453824, 805453824, 822231040, 822231040, 805519368, 872562688,
  822231040, 822231296, 822231040, 960132912, 960132912, 0, 318767104, 805437440, 0, 486539264, 1065728, 16384,
  822214656, 0, 536870912, 1073741824, 28672, 960102400, 196608, 0, 805502976, 1572864, 18874368, 134217728, 1073741824,
  1572864, 2097152, 1073741824, 48, 256, 131072, 805306368, 1572864, 16777216, 512, 131072, 1073741824, 512, 524288,
  343932928, 1, 2048, 8388608, 1073741824, 1, 4, 64, 33554432, 33554496, 0, 872546304, 4097, 0, 1073741824, 17152,
  2114304, 17156, 1065728, 1224755072, 1224755072, 486539264, 490864640, 490864640, 490881024, 1027735552, 1564606464,
  490864640, 1224753536, 1224754048, 151014144, 1224754048, 1224754048, 1224753536, 151012096, 151012096, 151536384,
  1224758145, -922425448, -922425448, 16384, 1224736768, -2147483648, 490733568, 0, 1073741825, 1027604480, 1564475392,
  384, 1224736768, 0, 8388608, 1048576, 0, 16, 0, 20, -164625872, -164625872, -164624528, -164624528, -164624464, 4992,
  0, 1082130432, 8, 10128, 469762048, 0, 512, 16384, 131072, 33554432, 402653184, 0, 512, 8192, 16777216, 1073741824,
  34, 70, 0, 70, 2, 16, 128, 1536, 8192, 32768, 524288, 8388608, 8388608, 0, 0, -899678208, 56, 56, 0, 56, 58, 56, 32,
  524288, -1820327936, 0, 8, 32, 24, 0, 10, 131360, 58, 58
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "(0)",
  "EOF",
  "PragmaContents",
  "DirCommentContents",
  "DirPIContents",
  "CDataSectionContents",
  "Wildcard",
  "URIQualifiedName",
  "URILiteral",
  "IntegerLiteral",
  "DecimalLiteral",
  "DoubleLiteral",
  "StringLiteral",
  "PredefinedEntityRef",
  "'""""'",
  "EscapeApos",
  "ElementContentChar",
  "QuotAttrContentChar",
  "AposAttrContentChar",
  "PITarget",
  "CharRef",
  "NCName",
  "QName",
  "S",
  "S",
  "CommentContents",
  "'!'",
  "'!='",
  "'""'",
  "'#'",
  "'#)'",
  "'$'",
  "'%'",
  "''''",
  "'('",
  "'(#'",
  "'(:'",
  "')'",
  "'*'",
  "'*'",
  "'+'",
  "','",
  "'-'",
  "'-->'",
  "'.'",
  "'..'",
  "'/'",
  "'//'",
  "'/>'",
  "':)'",
  "'::'",
  "':='",
  "';'",
  "'<'",
  "'<!--'",
  "'<![CDATA['",
  "'</'",
  "'<<'",
  "'<='",
  "'<?'",
  "'='",
  "'>'",
  "'>='",
  "'>>'",
  "'?'",
  "'?>'",
  "'@'",
  "'NaN'",
  "'['",
  "']'",
  "']]>'",
  "'after'",
  "'all'",
  "'allowing'",
  "'ancestor'",
  "'ancestor-or-self'",
  "'and'",
  "'any'",
  "'as'",
  "'ascending'",
  "'at'",
  "'attribute'",
  "'base-uri'",
  "'before'",
  "'binary'",
  "'boundary-space'",
  "'by'",
  "'case'",
  "'cast'",
  "'castable'",
  "'catch'",
  "'child'",
  "'collation'",
  "'comment'",
  "'construction'",
  "'contains'",
  "'content'",
  "'context'",
  "'copy'",
  "'copy-namespaces'",
  "'count'",
  "'decimal-format'",
  "'decimal-separator'",
  "'declare'",
  "'default'",
  "'delete'",
  "'descendant'",
  "'descendant-or-self'",
  "'descending'",
  "'diacritics'",
  "'different'",
  "'digit'",
  "'distance'",
  "'div'",
  "'document'",
  "'document-node'",
  "'element'",
  "'else'",
  "'empty'",
  "'empty-sequence'",
  "'encoding'",
  "'end'",
  "'entire'",
  "'eq'",
  "'every'",
  "'exactly'",
  "'except'",
  "'external'",
  "'first'",
  "'following'",
  "'following-sibling'",
  "'for'",
  "'from'",
  "'ft-option'",
  "'ftand'",
  "'ftnot'",
  "'ftor'",
  "'full'",
  "'function'",
  "'ge'",
  "'greatest'",
  "'group'",
  "'grouping-separator'",
  "'gt'",
  "'idiv'",
  "'if'",
  "'import'",
  "'in'",
  "'infinity'",
  "'inherit'",
  "'insensitive'",
  "'insert'",
  "'instance'",
  "'intersect'",
  "'into'",
  "'is'",
  "'item'",
  "'language'",
  "'last'",
  "'lax'",
  "'le'",
  "'least'",
  "'let'",
  "'levels'",
  "'lowercase'",
  "'lt'",
  "'minus-sign'",
  "'mod'",
  "'modify'",
  "'module'",
  "'most'",
  "'namespace'",
  "'namespace-node'",
  "'ne'",
  "'next'",
  "'no'",
  "'no-inherit'",
  "'no-preserve'",
  "'node'",
  "'nodes'",
  "'not'",
  "'occurs'",
  "'of'",
  "'only'",
  "'option'",
  "'or'",
  "'order'",
  "'ordered'",
  "'ordering'",
  "'paragraph'",
  "'paragraphs'",
  "'parent'",
  "'pattern-separator'",
  "'per-mille'",
  "'percent'",
  "'phrase'",
  "'preceding'",
  "'preceding-sibling'",
  "'preserve'",
  "'previous'",
  "'private'",
  "'processing-instruction'",
  "'property'",
  "'relationship'",
  "'rename'",
  "'replace'",
  "'return'",
  "'revalidation'",
  "'same'",
  "'satisfies'",
  "'schema'",
  "'schema-attribute'",
  "'schema-element'",
  "'self'",
  "'sensitive'",
  "'sentence'",
  "'sentences'",
  "'skip'",
  "'sliding'",
  "'some'",
  "'stable'",
  "'start'",
  "'stemming'",
  "'stop'",
  "'strict'",
  "'strip'",
  "'stylesheet'",
  "'switch'",
  "'text'",
  "'then'",
  "'thesaurus'",
  "'times'",
  "'to'",
  "'treat'",
  "'try'",
  "'tumbling'",
  "'type'",
  "'typeswitch'",
  "'union'",
  "'unordered'",
  "'uppercase'",
  "'using'",
  "'validate'",
  "'value'",
  "'variable'",
  "'version'",
  "'weight'",
  "'when'",
  "'where'",
  "'wildcards'",
  "'window'",
  "'with'",
  "'without'",
  "'word'",
  "'words'",
  "'xquery'",
  "'zero-digit'",
  "'{'",
  "'{{'",
  "'|'",
  "'||'",
  "'}'",
  "'}}'"
);

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer) as xs:integer+
{
  let $result := $p:INITIAL[1 + $token-set]
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 4096,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer) as xs:integer+
{
  if ($current-state = 0) then
    let $result := $result idiv 4096
    return
      if ($result != 0) then
      (
        $result mod 512 - 1,
        $begin,
        $end - $result idiv 512
      )
      else
      (
        -$previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    let $c1 :=
      if ($c0 < 128) then
        $p:MAP0[1 + $c0]
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 16
        let $c2 := $c1 idiv 32
        return $p:MAP1[1 + $c0 mod 16 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]
      else
        p:map2($c0, 1, 6)
    let $current := $current + 1
    let $i0 := 4096 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 16
    let $next-state := $p:TRANSITION[$i0 mod 16 + $p:TRANSITION[$i1 + 1] + 1]
    return
      if ($next-state > 4095) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 4096, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer) as xs:string*
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 8
    let $i0 := $t * 2215 + $state - 1
    let $i1 := $i0 idiv 2
    let $i2 := $i1 idiv 4
    let $i3 := $i2 idiv 4
    return p:token((), $p:EXPECTED[$i0 mod 2 + $p:EXPECTED[$i1 mod 4 + $p:EXPECTED[$i2 mod 4 + $p:EXPECTED[$i3 + 1] + 1] + 1] + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Classify codepoint by doing a tail recursive binary search for a
 : matching codepoint range entry in MAP2, the codepoint to charclass
 : map for codepoints above the surrogate block.
 :
 : @param $c the codepoint.
 : @param $lo the binary search lower bound map index.
 : @param $hi the binary search upper bound map index.
 : @return the character class.
 :)
declare function p:map2($c as xs:integer, $lo as xs:integer, $hi as xs:integer) as xs:integer
{
  if ($lo > $hi) then
    0
  else
    let $m := ($hi + $lo) idiv 2
    return
      if ($p:MAP2[$m] > $c) then
        p:map2($c, $lo, $m - 1)
      else if ($p:MAP2[6 + $m] < $c) then
        p:map2($c, $m + 1, $hi)
      else
        $p:MAP2[12 + $m]
};

(:~
 : Try parsing the 1st loop of production Comment (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Comment-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(82, $input, $state)          (: CommentContents | ('(' ':') | (':' ')') :)
    return
      if ($state[$p:l1] = 49) then                          (: (':' ')') :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 25) then                      (: CommentContents :)
            let $state := p:shiftT(25, $input, $state)      (: CommentContents :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:try-Comment($input, $state)
            return $state
        return p:try-Comment-1($input, $state)
};

(:~
 : Try parsing Comment.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Comment($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(36, $input, $state)                (: ('(' ':') :)
  let $state := p:try-Comment-1($input, $state)
  let $state := p:shiftT(49, $input, $state)                (: (':' ')') :)
  return $state
};

(:~
 : Try parsing Whitespace.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Whitespace($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 24) then                            (: S^WS :)
      let $state := p:shiftT(24, $input, $state)            (: S^WS :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-Comment($input, $state)
      return $state
  return $state
};

(:~
 : Parse QueryBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QueryBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Expr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "QueryBody", $count, $begin, $end)
};

(:~
 : Parse MainModule.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MainModule($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Prolog($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-QueryBody($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "MainModule", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production MainModuleSequence (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MainModuleSequence-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] = 52) then                          (: ';' :)
        let $state := p:lookahead2W(247, $input, $state)    (: EOF | Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | ';' | '<' | '<!--' |
                                                               '<?' | '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] = 1                                 (: EOF :)
       or $state[$p:lk] = 564                               (: ';' EOF :)
       or $state[$p:lk] = 26676) then                       (: ';' ';' :)
        $state
      else
        let $state := p:shift(52, $input, $state)           (: ';' :)
        let $state := p:lookahead1W(241, $input, $state)    (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
        let $state :=
          if ($state[$p:l1] = 255) then                     (: 'xquery' :)
            let $state := p:lookahead2W(178, $input, $state) (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | '*' |
                                                                '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                                '=' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                                'castable' | 'contains' | 'div' | 'encoding' | 'eq' |
                                                                'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                                'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' |
                                                                'to' | 'treat' | 'union' | 'version' | '|' | '||' :)
            return $state
          else
            ($state[$p:l1], subsequence($state, $p:lk + 1))
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:lk] = 61695                    (: 'xquery' 'encoding' :)
                or $state[$p:lk] = 125695) then             (: 'xquery' 'version' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-VersionDecl($input, $state)
            return $state
          else
            $state
        let $state := p:lookahead1W(241, $input, $state)    (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-MainModule($input, $state)
        return p:parse-MainModuleSequence-1($input, $state)
};

(:~
 : Parse MainModuleSequence.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MainModuleSequence($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-MainModule($input, $state)
  let $state := p:parse-MainModuleSequence-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 52) then                       (: ';' :)
      let $state := p:shift(52, $input, $state)             (: ';' :)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "MainModuleSequence", $count, $begin, $end)
};

(:~
 : Parse OptionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OptionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(103, $input, $state)                (: 'declare' :)
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | ('(' ':') | 'option' :)
  let $state := p:shift(184, $input, $state)                (: 'option' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:shift(12, $input, $state)                 (: StringLiteral :)
  let $end := $state[$p:e0]
  return p:reduce($state, "OptionDecl", $count, $begin, $end)
};

(:~
 : Parse FunctionBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EnclosedExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionBody", $count, $begin, $end)
};

(:~
 : Parse FunctionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(138, $input, $state)                (: 'function' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(87, $input, $state)           (: S^WS | '$' | ('(' ':') | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(141, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'external' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:shift(78, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(235, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(110, $input, $state)          (: S^WS | ('(' ':') | 'external' | '{' :)
  let $state :=
    if ($state[$p:l1] = 257) then                           (: '{' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FunctionBody($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(127, $input, $state)            (: 'external' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionDecl", $count, $begin, $end)
};

(:~
 : Parse VarDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(244, $input, $state)                (: 'variable' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(139, $input, $state)          (: S^WS | ('(' ':') | ':=' | 'as' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(97, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'external' :)
  let $state :=
    if ($state[$p:l1] = 51) then                            (: ':=' :)
      let $state := p:shift(51, $input, $state)             (: ':=' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VarValue($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(127, $input, $state)            (: 'external' :)
      let $state := p:lookahead1W(95, $input, $state)       (: S^WS | ('(' ':') | ':=' | ';' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 51) then                   (: ':=' :)
          let $state := p:shift(51, $input, $state)         (: ':=' :)
          let $state := p:lookahead1W(241, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-VarDefaultValue($input, $state)
          return $state
        else
          $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "VarDecl", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production AnnotatedDecl (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnnotatedDecl-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(151, $input, $state)        (: S^WS | '%' | ('(' ':') | 'function' | 'private' |
                                                               'variable' :)
    return
      if ($state[$p:l1] != 32                               (: '%' :)
      and $state[$p:l1] != 200) then                        (: 'private' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Annotation($input, $state)
        return p:parse-AnnotatedDecl-1($input, $state)
};

(:~
 : Parse AnnotatedDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnnotatedDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(103, $input, $state)                (: 'declare' :)
  let $state := p:parse-AnnotatedDecl-1($input, $state)
  let $state :=
    if ($state[$p:l1] = 244) then                           (: 'variable' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VarDecl($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FunctionDecl($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "AnnotatedDecl", $count, $begin, $end)
};

(:~
 : Parse VarDefaultValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarDefaultValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VarDefaultValue", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production TransformExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TransformExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 41) then                           (: ',' :)
      $state
    else
      let $state := p:shift(41, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VarName($input, $state)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | ':=' :)
      let $state := p:shift(51, $input, $state)             (: ':=' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ExprSingle($input, $state)
      return p:parse-TransformExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production TransformExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-TransformExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 41) then                           (: ',' :)
      $state
    else
      let $state := p:shiftT(41, $input, $state)            (: ',' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:shiftT(31, $input, $state)            (: '$' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-VarName($input, $state)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | ':=' :)
      let $state := p:shiftT(51, $input, $state)            (: ':=' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-ExprSingle($input, $state)
      return p:try-TransformExpr-1($input, $state)
};

(:~
 : Parse TransformExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TransformExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(98, $input, $state)                 (: 'copy' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:shift(51, $input, $state)                 (: ':=' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-TransformExpr-1($input, $state)
  let $state := p:shift(168, $input, $state)                (: 'modify' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:shift(206, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TransformExpr", $count, $begin, $end)
};

(:~
 : Try parsing TransformExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-TransformExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(98, $input, $state)                (: 'copy' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shiftT(31, $input, $state)                (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-VarName($input, $state)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:shiftT(51, $input, $state)                (: ':=' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  let $state := p:try-TransformExpr-1($input, $state)
  let $state := p:shiftT(168, $input, $state)               (: 'modify' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  let $state := p:shiftT(206, $input, $state)               (: 'return' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse ReplaceExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReplaceExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(205, $input, $state)                (: 'replace' :)
  let $state := p:lookahead1W(120, $input, $state)          (: S^WS | ('(' ':') | 'node' | 'value' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 243) then                      (: 'value' :)
      let $state := p:shift(243, $input, $state)            (: 'value' :)
      let $state := p:lookahead1W(60, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      let $state := p:shift(182, $input, $state)            (: 'of' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(59, $input, $state)           (: S^WS | ('(' ':') | 'node' :)
  let $state := p:shift(178, $input, $state)                (: 'node' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-TargetExpr($input, $state)
  let $state := p:shift(251, $input, $state)                (: 'with' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ReplaceExpr", $count, $begin, $end)
};

(:~
 : Try parsing ReplaceExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ReplaceExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(205, $input, $state)               (: 'replace' :)
  let $state := p:lookahead1W(120, $input, $state)          (: S^WS | ('(' ':') | 'node' | 'value' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 243) then                      (: 'value' :)
      let $state := p:shiftT(243, $input, $state)           (: 'value' :)
      let $state := p:lookahead1W(60, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      let $state := p:shiftT(182, $input, $state)           (: 'of' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(59, $input, $state)           (: S^WS | ('(' ':') | 'node' :)
  let $state := p:shiftT(178, $input, $state)               (: 'node' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-TargetExpr($input, $state)
  let $state := p:shiftT(251, $input, $state)               (: 'with' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse NewNameExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NewNameExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "NewNameExpr", $count, $begin, $end)
};

(:~
 : Try parsing NewNameExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-NewNameExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse RenameExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RenameExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(204, $input, $state)                (: 'rename' :)
  let $state := p:lookahead1W(59, $input, $state)           (: S^WS | ('(' ':') | 'node' :)
  let $state := p:shift(178, $input, $state)                (: 'node' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-TargetExpr($input, $state)
  let $state := p:shift(78, $input, $state)                 (: 'as' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-NewNameExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "RenameExpr", $count, $begin, $end)
};

(:~
 : Try parsing RenameExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-RenameExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(204, $input, $state)               (: 'rename' :)
  let $state := p:lookahead1W(59, $input, $state)           (: S^WS | ('(' ':') | 'node' :)
  let $state := p:shiftT(178, $input, $state)               (: 'node' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-TargetExpr($input, $state)
  let $state := p:shiftT(78, $input, $state)                (: 'as' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-NewNameExpr($input, $state)
  return $state
};

(:~
 : Parse DeleteExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DeleteExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(105, $input, $state)                (: 'delete' :)
  let $state := p:lookahead1W(119, $input, $state)          (: S^WS | ('(' ':') | 'node' | 'nodes' :)
  let $state :=
    if ($state[$p:l1] = 178) then                           (: 'node' :)
      let $state := p:shift(178, $input, $state)            (: 'node' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(179, $input, $state)            (: 'nodes' :)
      return $state
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-TargetExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "DeleteExpr", $count, $begin, $end)
};

(:~
 : Try parsing DeleteExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-DeleteExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(105, $input, $state)               (: 'delete' :)
  let $state := p:lookahead1W(119, $input, $state)          (: S^WS | ('(' ':') | 'node' | 'nodes' :)
  let $state :=
    if ($state[$p:l1] = 178) then                           (: 'node' :)
      let $state := p:shiftT(178, $input, $state)           (: 'node' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(179, $input, $state)           (: 'nodes' :)
      return $state
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-TargetExpr($input, $state)
  return $state
};

(:~
 : Parse TargetExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TargetExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TargetExpr", $count, $begin, $end)
};

(:~
 : Try parsing TargetExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-TargetExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse InsertExprTargetChoice.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InsertExprTargetChoice($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 71) then                            (: 'after' :)
      let $state := p:shift(71, $input, $state)             (: 'after' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'before' :)
      let $state := p:shift(83, $input, $state)             (: 'before' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 78) then                   (: 'as' :)
          let $state := p:shift(78, $input, $state)         (: 'as' :)
          let $state := p:lookahead1W(111, $input, $state)  (: S^WS | ('(' ':') | 'first' | 'last' :)
          let $state :=
            if ($state[$p:l1] = 128) then                   (: 'first' :)
              let $state := p:shift(128, $input, $state)    (: 'first' :)
              return $state
            else if ($state[$p:error]) then
              $state
            else
              let $state := p:shift(158, $input, $state)    (: 'last' :)
              return $state
          return $state
        else
          $state
      let $state := p:lookahead1W(52, $input, $state)       (: S^WS | ('(' ':') | 'into' :)
      let $state := p:shift(154, $input, $state)            (: 'into' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "InsertExprTargetChoice", $count, $begin, $end)
};

(:~
 : Try parsing InsertExprTargetChoice.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-InsertExprTargetChoice($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 71) then                            (: 'after' :)
      let $state := p:shiftT(71, $input, $state)            (: 'after' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'before' :)
      let $state := p:shiftT(83, $input, $state)            (: 'before' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 78) then                   (: 'as' :)
          let $state := p:shiftT(78, $input, $state)        (: 'as' :)
          let $state := p:lookahead1W(111, $input, $state)  (: S^WS | ('(' ':') | 'first' | 'last' :)
          let $state :=
            if ($state[$p:l1] = 128) then                   (: 'first' :)
              let $state := p:shiftT(128, $input, $state)   (: 'first' :)
              return $state
            else if ($state[$p:error]) then
              $state
            else
              let $state := p:shiftT(158, $input, $state)   (: 'last' :)
              return $state
          return $state
        else
          $state
      let $state := p:lookahead1W(52, $input, $state)       (: S^WS | ('(' ':') | 'into' :)
      let $state := p:shiftT(154, $input, $state)           (: 'into' :)
      return $state
  return $state
};

(:~
 : Parse SourceExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SourceExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SourceExpr", $count, $begin, $end)
};

(:~
 : Try parsing SourceExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-SourceExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse InsertExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InsertExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(151, $input, $state)                (: 'insert' :)
  let $state := p:lookahead1W(119, $input, $state)          (: S^WS | ('(' ':') | 'node' | 'nodes' :)
  let $state :=
    if ($state[$p:l1] = 178) then                           (: 'node' :)
      let $state := p:shift(178, $input, $state)            (: 'node' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(179, $input, $state)            (: 'nodes' :)
      return $state
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-SourceExpr($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-InsertExprTargetChoice($input, $state)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-TargetExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "InsertExpr", $count, $begin, $end)
};

(:~
 : Try parsing InsertExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-InsertExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(151, $input, $state)               (: 'insert' :)
  let $state := p:lookahead1W(119, $input, $state)          (: S^WS | ('(' ':') | 'node' | 'nodes' :)
  let $state :=
    if ($state[$p:l1] = 178) then                           (: 'node' :)
      let $state := p:shiftT(178, $input, $state)           (: 'node' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(179, $input, $state)           (: 'nodes' :)
      return $state
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-SourceExpr($input, $state)
  let $state := p:try-InsertExprTargetChoice($input, $state)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-TargetExpr($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production CatchErrorList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CatchErrorList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(129, $input, $state)        (: S^WS | ('(' ':') | '{' | '|' :)
    return
      if ($state[$p:l1] != 259) then                        (: '|' :)
        $state
      else
        let $state := p:shift(259, $input, $state)          (: '|' :)
        let $state := p:lookahead1W(231, $input, $state)    (: Wildcard | URIQualifiedName | QName^Token | S^WS |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-NameTest($input, $state)
        return p:parse-CatchErrorList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production CatchErrorList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CatchErrorList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(129, $input, $state)        (: S^WS | ('(' ':') | '{' | '|' :)
    return
      if ($state[$p:l1] != 259) then                        (: '|' :)
        $state
      else
        let $state := p:shiftT(259, $input, $state)         (: '|' :)
        let $state := p:lookahead1W(231, $input, $state)    (: Wildcard | URIQualifiedName | QName^Token | S^WS |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
        let $state := p:try-NameTest($input, $state)
        return p:try-CatchErrorList-1($input, $state)
};

(:~
 : Parse CatchErrorList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CatchErrorList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-NameTest($input, $state)
  let $state := p:parse-CatchErrorList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CatchErrorList", $count, $begin, $end)
};

(:~
 : Try parsing CatchErrorList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CatchErrorList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-NameTest($input, $state)
  let $state := p:try-CatchErrorList-1($input, $state)
  return $state
};

(:~
 : Parse CatchClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CatchClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(90, $input, $state)                 (: 'catch' :)
  let $state := p:lookahead1W(233, $input, $state)          (: Wildcard | URIQualifiedName | QName^Token | S^WS | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 34) then                            (: '(' :)
      let $state := p:shift(34, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VarName($input, $state)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:shift(37, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-CatchErrorList($input, $state)
      return $state
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EnclosedExprExtended($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CatchClause", $count, $begin, $end)
};

(:~
 : Try parsing CatchClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CatchClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(90, $input, $state)                (: 'catch' :)
  let $state := p:lookahead1W(233, $input, $state)          (: Wildcard | URIQualifiedName | QName^Token | S^WS | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 34) then                            (: '(' :)
      let $state := p:shiftT(34, $input, $state)            (: '(' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:shiftT(31, $input, $state)            (: '$' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-VarName($input, $state)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:shiftT(37, $input, $state)            (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-CatchErrorList($input, $state)
      return $state
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:try-EnclosedExprExtended($input, $state)
  return $state
};

(:~
 : Parse TryTargetExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TryTargetExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Expr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TryTargetExpr", $count, $begin, $end)
};

(:~
 : Try parsing TryTargetExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-TryTargetExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-Expr($input, $state)
  return $state
};

(:~
 : Parse TryClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TryClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(234, $input, $state)                (: 'try' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(257, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-TryTargetExpr($input, $state)
  let $state := p:shift(261, $input, $state)                (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "TryClause", $count, $begin, $end)
};

(:~
 : Try parsing TryClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-TryClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(234, $input, $state)               (: 'try' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shiftT(257, $input, $state)               (: '{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-TryTargetExpr($input, $state)
  let $state := p:shiftT(261, $input, $state)               (: '}' :)
  return $state
};

(:~
 : Parse the 1st loop of production TryCatchExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TryCatchExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(38, $input, $state)         (: S^WS | ('(' ':') | 'catch' :)
    let $state := p:whitespace($input, $state)
    let $state := p:parse-CatchClause($input, $state)
    let $state := p:lookahead1W(176, $input, $state)        (: EOF | S^WS | ('(' ':') | ')' | ',' | ';' | ']' |
                                                               'after' | 'as' | 'ascending' | 'before' | 'case' |
                                                               'catch' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'else' | 'empty' | 'end' | 'for' |
                                                               'group' | 'into' | 'let' | 'modify' | 'only' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'where' |
                                                               'with' | '}' :)
    return
      if ($state[$p:l1] != 90) then                         (: 'catch' :)
        $state
      else
        p:parse-TryCatchExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production TryCatchExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-TryCatchExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(38, $input, $state)         (: S^WS | ('(' ':') | 'catch' :)
    let $state := p:try-CatchClause($input, $state)
    let $state := p:lookahead1W(176, $input, $state)        (: EOF | S^WS | ('(' ':') | ')' | ',' | ';' | ']' |
                                                               'after' | 'as' | 'ascending' | 'before' | 'case' |
                                                               'catch' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'else' | 'empty' | 'end' | 'for' |
                                                               'group' | 'into' | 'let' | 'modify' | 'only' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'where' |
                                                               'with' | '}' :)
    return
      if ($state[$p:l1] != 90) then                         (: 'catch' :)
        $state
      else
        p:try-TryCatchExpr-1($input, $state)
};

(:~
 : Parse TryCatchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TryCatchExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-TryClause($input, $state)
  let $state := p:parse-TryCatchExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TryCatchExpr", $count, $begin, $end)
};

(:~
 : Try parsing TryCatchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-TryCatchExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-TryClause($input, $state)
  let $state := p:try-TryCatchExpr-1($input, $state)
  return $state
};

(:~
 : Parse NodeComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NodeComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 155) then                           (: 'is' :)
      let $state := p:shift(155, $input, $state)            (: 'is' :)
      return $state
    else if ($state[$p:l1] = 57) then                       (: '<<' :)
      let $state := p:shift(57, $input, $state)             (: '<<' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(63, $input, $state)             (: '>>' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NodeComp", $count, $begin, $end)
};

(:~
 : Try parsing NodeComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-NodeComp($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 155) then                           (: 'is' :)
      let $state := p:shiftT(155, $input, $state)           (: 'is' :)
      return $state
    else if ($state[$p:l1] = 57) then                       (: '<<' :)
      let $state := p:shiftT(57, $input, $state)            (: '<<' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(63, $input, $state)            (: '>>' :)
      return $state
  return $state
};

(:~
 : Parse GeneralComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GeneralComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 60) then                            (: '=' :)
      let $state := p:shift(60, $input, $state)             (: '=' :)
      return $state
    else if ($state[$p:l1] = 27) then                       (: '!=' :)
      let $state := p:shift(27, $input, $state)             (: '!=' :)
      return $state
    else if ($state[$p:l1] = 53) then                       (: '<' :)
      let $state := p:shift(53, $input, $state)             (: '<' :)
      return $state
    else if ($state[$p:l1] = 58) then                       (: '<=' :)
      let $state := p:shift(58, $input, $state)             (: '<=' :)
      return $state
    else if ($state[$p:l1] = 61) then                       (: '>' :)
      let $state := p:shift(61, $input, $state)             (: '>' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(62, $input, $state)             (: '>=' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "GeneralComp", $count, $begin, $end)
};

(:~
 : Try parsing GeneralComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-GeneralComp($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 60) then                            (: '=' :)
      let $state := p:shiftT(60, $input, $state)            (: '=' :)
      return $state
    else if ($state[$p:l1] = 27) then                       (: '!=' :)
      let $state := p:shiftT(27, $input, $state)            (: '!=' :)
      return $state
    else if ($state[$p:l1] = 53) then                       (: '<' :)
      let $state := p:shiftT(53, $input, $state)            (: '<' :)
      return $state
    else if ($state[$p:l1] = 58) then                       (: '<=' :)
      let $state := p:shiftT(58, $input, $state)            (: '<=' :)
      return $state
    else if ($state[$p:l1] = 61) then                       (: '>' :)
      let $state := p:shiftT(61, $input, $state)            (: '>' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(62, $input, $state)            (: '>=' :)
      return $state
  return $state
};

(:~
 : Parse ValueComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValueComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 123) then                           (: 'eq' :)
      let $state := p:shift(123, $input, $state)            (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 173) then                      (: 'ne' :)
      let $state := p:shift(173, $input, $state)            (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'lt' :)
      let $state := p:shift(165, $input, $state)            (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'le' :)
      let $state := p:shift(160, $input, $state)            (: 'le' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'gt' :)
      let $state := p:shift(143, $input, $state)            (: 'gt' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(139, $input, $state)            (: 'ge' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ValueComp", $count, $begin, $end)
};

(:~
 : Try parsing ValueComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ValueComp($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 123) then                           (: 'eq' :)
      let $state := p:shiftT(123, $input, $state)           (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 173) then                      (: 'ne' :)
      let $state := p:shiftT(173, $input, $state)           (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'lt' :)
      let $state := p:shiftT(165, $input, $state)           (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'le' :)
      let $state := p:shiftT(160, $input, $state)           (: 'le' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'gt' :)
      let $state := p:shiftT(143, $input, $state)           (: 'gt' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(139, $input, $state)           (: 'ge' :)
      return $state
  return $state
};

(:~
 : Parse FTIgnoreOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTIgnoreOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(252, $input, $state)                (: 'without' :)
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | 'content' :)
  let $state := p:shift(96, $input, $state)                 (: 'content' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-UnionExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTIgnoreOption", $count, $begin, $end)
};

(:~
 : Try parsing FTIgnoreOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTIgnoreOption($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(252, $input, $state)               (: 'without' :)
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | 'content' :)
  let $state := p:shiftT(96, $input, $state)                (: 'content' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-UnionExpr($input, $state)
  return $state
};

(:~
 : Parse FTContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 80) then                            (: 'at' :)
      let $state := p:lookahead2W(108, $input, $state)      (: S^WS | ('(' ':') | 'end' | 'start' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 113232) then                        (: 'at' 'start' :)
      let $state := p:shift(80, $input, $state)             (: 'at' :)
      let $state := p:lookahead1W(68, $input, $state)       (: S^WS | ('(' ':') | 'start' :)
      let $state := p:shift(221, $input, $state)            (: 'start' :)
      return $state
    else if ($state[$p:lk] = 62032) then                    (: 'at' 'end' :)
      let $state := p:shift(80, $input, $state)             (: 'at' :)
      let $state := p:lookahead1W(48, $input, $state)       (: S^WS | ('(' ':') | 'end' :)
      let $state := p:shift(121, $input, $state)            (: 'end' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(122, $input, $state)            (: 'entire' :)
      let $state := p:lookahead1W(41, $input, $state)       (: S^WS | ('(' ':') | 'content' :)
      let $state := p:shift(96, $input, $state)             (: 'content' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTContent", $count, $begin, $end)
};

(:~
 : Try parsing FTContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 80) then                            (: 'at' :)
      let $state := p:lookahead2W(108, $input, $state)      (: S^WS | ('(' ':') | 'end' | 'start' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 113232) then                        (: 'at' 'start' :)
      let $state := p:shiftT(80, $input, $state)            (: 'at' :)
      let $state := p:lookahead1W(68, $input, $state)       (: S^WS | ('(' ':') | 'start' :)
      let $state := p:shiftT(221, $input, $state)           (: 'start' :)
      return $state
    else if ($state[$p:lk] = 62032) then                    (: 'at' 'end' :)
      let $state := p:shiftT(80, $input, $state)            (: 'at' :)
      let $state := p:lookahead1W(48, $input, $state)       (: S^WS | ('(' ':') | 'end' :)
      let $state := p:shiftT(121, $input, $state)           (: 'end' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(122, $input, $state)           (: 'entire' :)
      let $state := p:lookahead1W(41, $input, $state)       (: S^WS | ('(' ':') | 'content' :)
      let $state := p:shiftT(96, $input, $state)            (: 'content' :)
      return $state
  return $state
};

(:~
 : Parse FTBigUnit.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTBigUnit($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 215) then                           (: 'sentence' :)
      let $state := p:shift(215, $input, $state)            (: 'sentence' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(189, $input, $state)            (: 'paragraph' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTBigUnit", $count, $begin, $end)
};

(:~
 : Try parsing FTBigUnit.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTBigUnit($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 215) then                           (: 'sentence' :)
      let $state := p:shiftT(215, $input, $state)           (: 'sentence' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(189, $input, $state)           (: 'paragraph' :)
      return $state
  return $state
};

(:~
 : Parse FTScope.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTScope($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 208) then                           (: 'same' :)
      let $state := p:shift(208, $input, $state)            (: 'same' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(110, $input, $state)            (: 'different' :)
      return $state
  let $state := p:lookahead1W(124, $input, $state)          (: S^WS | ('(' ':') | 'paragraph' | 'sentence' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-FTBigUnit($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTScope", $count, $begin, $end)
};

(:~
 : Try parsing FTScope.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTScope($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 208) then                           (: 'same' :)
      let $state := p:shiftT(208, $input, $state)           (: 'same' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(110, $input, $state)           (: 'different' :)
      return $state
  let $state := p:lookahead1W(124, $input, $state)          (: S^WS | ('(' ':') | 'paragraph' | 'sentence' :)
  let $state := p:try-FTBigUnit($input, $state)
  return $state
};

(:~
 : Parse FTDistance.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTDistance($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(112, $input, $state)                (: 'distance' :)
  let $state := p:lookahead1W(142, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'exactly' | 'from' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-FTRange($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-FTUnit($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTDistance", $count, $begin, $end)
};

(:~
 : Try parsing FTDistance.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTDistance($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(112, $input, $state)               (: 'distance' :)
  let $state := p:lookahead1W(142, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'exactly' | 'from' :)
  let $state := p:try-FTRange($input, $state)
  let $state := p:try-FTUnit($input, $state)
  return $state
};

(:~
 : Parse FTUnit.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTUnit($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 254) then                           (: 'words' :)
      let $state := p:shift(254, $input, $state)            (: 'words' :)
      return $state
    else if ($state[$p:l1] = 216) then                      (: 'sentences' :)
      let $state := p:shift(216, $input, $state)            (: 'sentences' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(190, $input, $state)            (: 'paragraphs' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTUnit", $count, $begin, $end)
};

(:~
 : Try parsing FTUnit.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTUnit($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 254) then                           (: 'words' :)
      let $state := p:shiftT(254, $input, $state)           (: 'words' :)
      return $state
    else if ($state[$p:l1] = 216) then                      (: 'sentences' :)
      let $state := p:shiftT(216, $input, $state)           (: 'sentences' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(190, $input, $state)           (: 'paragraphs' :)
      return $state
  return $state
};

(:~
 : Parse FTWindow.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTWindow($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(250, $input, $state)                (: 'window' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-AdditiveExpr($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-FTUnit($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTWindow", $count, $begin, $end)
};

(:~
 : Try parsing FTWindow.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTWindow($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(250, $input, $state)               (: 'window' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-AdditiveExpr($input, $state)
  let $state := p:try-FTUnit($input, $state)
  return $state
};

(:~
 : Parse FTOrder.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTOrder($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(187, $input, $state)                (: 'ordered' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTOrder", $count, $begin, $end)
};

(:~
 : Try parsing FTOrder.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTOrder($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(187, $input, $state)               (: 'ordered' :)
  return $state
};

(:~
 : Parse FTPosFilter.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTPosFilter($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 187) then                           (: 'ordered' :)
      let $state := p:parse-FTOrder($input, $state)
      return $state
    else if ($state[$p:l1] = 250) then                      (: 'window' :)
      let $state := p:parse-FTWindow($input, $state)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'distance' :)
      let $state := p:parse-FTDistance($input, $state)
      return $state
    else if ($state[$p:l1] = 110                            (: 'different' :)
          or $state[$p:l1] = 208) then                      (: 'same' :)
      let $state := p:parse-FTScope($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FTContent($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTPosFilter", $count, $begin, $end)
};

(:~
 : Try parsing FTPosFilter.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTPosFilter($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 187) then                           (: 'ordered' :)
      let $state := p:try-FTOrder($input, $state)
      return $state
    else if ($state[$p:l1] = 250) then                      (: 'window' :)
      let $state := p:try-FTWindow($input, $state)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'distance' :)
      let $state := p:try-FTDistance($input, $state)
      return $state
    else if ($state[$p:l1] = 110                            (: 'different' :)
          or $state[$p:l1] = 208) then                      (: 'same' :)
      let $state := p:try-FTScope($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-FTContent($input, $state)
      return $state
  return $state
};

(:~
 : Parse FTWeight.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTWeight($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(246, $input, $state)                (: 'weight' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(257, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(261, $input, $state)                (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTWeight", $count, $begin, $end)
};

(:~
 : Try parsing FTWeight.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTWeight($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(246, $input, $state)               (: 'weight' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shiftT(257, $input, $state)               (: '{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-Expr($input, $state)
  let $state := p:shiftT(261, $input, $state)               (: '}' :)
  return $state
};

(:~
 : Parse the 1st loop of production FTExtensionSelection (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTExtensionSelection-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:whitespace($input, $state)
    let $state := p:parse-Pragma($input, $state)
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | '(#' | ('(' ':') | '{' :)
    return
      if ($state[$p:l1] != 35) then                         (: '(#' :)
        $state
      else
        p:parse-FTExtensionSelection-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTExtensionSelection (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTExtensionSelection-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:try-Pragma($input, $state)
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | '(#' | ('(' ':') | '{' :)
    return
      if ($state[$p:l1] != 35) then                         (: '(#' :)
        $state
      else
        p:try-FTExtensionSelection-1($input, $state)
};

(:~
 : Parse FTExtensionSelection.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTExtensionSelection($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FTExtensionSelection-1($input, $state)
  let $state := p:shift(257, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(160, $input, $state)          (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 261) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FTSelection($input, $state)
      return $state
    else
      $state
  let $state := p:shift(261, $input, $state)                (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTExtensionSelection", $count, $begin, $end)
};

(:~
 : Try parsing FTExtensionSelection.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTExtensionSelection($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-FTExtensionSelection-1($input, $state)
  let $state := p:shiftT(257, $input, $state)               (: '{' :)
  let $state := p:lookahead1W(160, $input, $state)          (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 261) then                     (: '}' :)
      let $state := p:try-FTSelection($input, $state)
      return $state
    else
      $state
  let $state := p:shiftT(261, $input, $state)               (: '}' :)
  return $state
};

(:~
 : Parse FTRange.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTRange($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 80) then                            (: 'at' :)
      let $state := p:lookahead2W(116, $input, $state)      (: S^WS | ('(' ':') | 'least' | 'most' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 125) then                           (: 'exactly' :)
      let $state := p:shift(125, $input, $state)            (: 'exactly' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AdditiveExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 82512) then                    (: 'at' 'least' :)
      let $state := p:shift(80, $input, $state)             (: 'at' :)
      let $state := p:lookahead1W(54, $input, $state)       (: S^WS | ('(' ':') | 'least' :)
      let $state := p:shift(161, $input, $state)            (: 'least' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AdditiveExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 87120) then                    (: 'at' 'most' :)
      let $state := p:shift(80, $input, $state)             (: 'at' :)
      let $state := p:lookahead1W(57, $input, $state)       (: S^WS | ('(' ':') | 'most' :)
      let $state := p:shift(170, $input, $state)            (: 'most' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AdditiveExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(132, $input, $state)            (: 'from' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AdditiveExpr($input, $state)
      let $state := p:shift(232, $input, $state)            (: 'to' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AdditiveExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTRange", $count, $begin, $end)
};

(:~
 : Try parsing FTRange.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTRange($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 80) then                            (: 'at' :)
      let $state := p:lookahead2W(116, $input, $state)      (: S^WS | ('(' ':') | 'least' | 'most' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 125) then                           (: 'exactly' :)
      let $state := p:shiftT(125, $input, $state)           (: 'exactly' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-AdditiveExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 82512) then                    (: 'at' 'least' :)
      let $state := p:shiftT(80, $input, $state)            (: 'at' :)
      let $state := p:lookahead1W(54, $input, $state)       (: S^WS | ('(' ':') | 'least' :)
      let $state := p:shiftT(161, $input, $state)           (: 'least' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-AdditiveExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 87120) then                    (: 'at' 'most' :)
      let $state := p:shiftT(80, $input, $state)            (: 'at' :)
      let $state := p:lookahead1W(57, $input, $state)       (: S^WS | ('(' ':') | 'most' :)
      let $state := p:shiftT(170, $input, $state)           (: 'most' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-AdditiveExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(132, $input, $state)           (: 'from' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-AdditiveExpr($input, $state)
      let $state := p:shiftT(232, $input, $state)           (: 'to' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-AdditiveExpr($input, $state)
      return $state
  return $state
};

(:~
 : Parse FTTimes.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTTimes($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(181, $input, $state)                (: 'occurs' :)
  let $state := p:lookahead1W(142, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'exactly' | 'from' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-FTRange($input, $state)
  let $state := p:shift(231, $input, $state)                (: 'times' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTTimes", $count, $begin, $end)
};

(:~
 : Try parsing FTTimes.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTTimes($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(181, $input, $state)               (: 'occurs' :)
  let $state := p:lookahead1W(142, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'exactly' | 'from' :)
  let $state := p:try-FTRange($input, $state)
  let $state := p:shiftT(231, $input, $state)               (: 'times' :)
  return $state
};

(:~
 : Parse FTAnyallOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTAnyallOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 77) then                            (: 'any' :)
      let $state := p:shift(77, $input, $state)             (: 'any' :)
      let $state := p:lookahead1W(195, $input, $state)      (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'occurs' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'return' | 'same' | 'satisfies' |
                                                               'stable' | 'start' | 'using' | 'weight' | 'where' |
                                                               'window' | 'with' | 'without' | 'word' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 253) then                  (: 'word' :)
          let $state := p:shift(253, $input, $state)        (: 'word' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 72) then                       (: 'all' :)
      let $state := p:shift(72, $input, $state)             (: 'all' :)
      let $state := p:lookahead1W(196, $input, $state)      (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'occurs' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'return' | 'same' | 'satisfies' |
                                                               'stable' | 'start' | 'using' | 'weight' | 'where' |
                                                               'window' | 'with' | 'without' | 'words' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 254) then                  (: 'words' :)
          let $state := p:shift(254, $input, $state)        (: 'words' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(195, $input, $state)            (: 'phrase' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTAnyallOption", $count, $begin, $end)
};

(:~
 : Try parsing FTAnyallOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTAnyallOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 77) then                            (: 'any' :)
      let $state := p:shiftT(77, $input, $state)            (: 'any' :)
      let $state := p:lookahead1W(195, $input, $state)      (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'occurs' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'return' | 'same' | 'satisfies' |
                                                               'stable' | 'start' | 'using' | 'weight' | 'where' |
                                                               'window' | 'with' | 'without' | 'word' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 253) then                  (: 'word' :)
          let $state := p:shiftT(253, $input, $state)       (: 'word' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 72) then                       (: 'all' :)
      let $state := p:shiftT(72, $input, $state)            (: 'all' :)
      let $state := p:lookahead1W(196, $input, $state)      (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'occurs' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'return' | 'same' | 'satisfies' |
                                                               'stable' | 'start' | 'using' | 'weight' | 'where' |
                                                               'window' | 'with' | 'without' | 'words' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 254) then                  (: 'words' :)
          let $state := p:shiftT(254, $input, $state)       (: 'words' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(195, $input, $state)           (: 'phrase' :)
      return $state
  return $state
};

(:~
 : Parse FTWordsValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTWordsValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 12) then                            (: StringLiteral :)
      let $state := p:shift(12, $input, $state)             (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(257, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expr($input, $state)
      let $state := p:shift(261, $input, $state)            (: '}' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTWordsValue", $count, $begin, $end)
};

(:~
 : Try parsing FTWordsValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTWordsValue($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 12) then                            (: StringLiteral :)
      let $state := p:shiftT(12, $input, $state)            (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(257, $input, $state)           (: '{' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-Expr($input, $state)
      let $state := p:shiftT(261, $input, $state)           (: '}' :)
      return $state
  return $state
};

(:~
 : Parse FTWords.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTWords($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FTWordsValue($input, $state)
  let $state := p:lookahead1W(199, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'all' | 'and' | 'any' | 'as' | 'ascending' | 'at' |
                                                               'before' | 'case' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'else' |
                                                               'empty' | 'end' | 'entire' | 'eq' | 'for' | 'ftand' |
                                                               'ftor' | 'ge' | 'group' | 'gt' | 'into' | 'is' | 'le' |
                                                               'let' | 'lt' | 'modify' | 'ne' | 'not' | 'occurs' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'phrase' |
                                                               'return' | 'same' | 'satisfies' | 'stable' | 'start' |
                                                               'using' | 'weight' | 'where' | 'window' | 'with' |
                                                               'without' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 72                             (: 'all' :)
          or $state[$p:l1] = 77                             (: 'any' :)
          or $state[$p:l1] = 195) then                      (: 'phrase' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FTAnyallOption($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTWords", $count, $begin, $end)
};

(:~
 : Try parsing FTWords.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTWords($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-FTWordsValue($input, $state)
  let $state := p:lookahead1W(199, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'all' | 'and' | 'any' | 'as' | 'ascending' | 'at' |
                                                               'before' | 'case' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'else' |
                                                               'empty' | 'end' | 'entire' | 'eq' | 'for' | 'ftand' |
                                                               'ftor' | 'ge' | 'group' | 'gt' | 'into' | 'is' | 'le' |
                                                               'let' | 'lt' | 'modify' | 'ne' | 'not' | 'occurs' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'phrase' |
                                                               'return' | 'same' | 'satisfies' | 'stable' | 'start' |
                                                               'using' | 'weight' | 'where' | 'window' | 'with' |
                                                               'without' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 72                             (: 'all' :)
          or $state[$p:l1] = 77                             (: 'any' :)
          or $state[$p:l1] = 195) then                      (: 'phrase' :)
      let $state := p:try-FTAnyallOption($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse FTPrimary.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTPrimary($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 34) then                            (: '(' :)
      let $state := p:shift(34, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(156, $input, $state)      (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FTSelection($input, $state)
      let $state := p:shift(37, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:l1] = 35) then                       (: '(#' :)
      let $state := p:parse-FTExtensionSelection($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FTWords($input, $state)
      let $state := p:lookahead1W(191, $input, $state)      (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'occurs' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'return' | 'same' | 'satisfies' |
                                                               'stable' | 'start' | 'using' | 'weight' | 'where' |
                                                               'window' | 'with' | 'without' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 181) then                  (: 'occurs' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-FTTimes($input, $state)
          return $state
        else
          $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTPrimary", $count, $begin, $end)
};

(:~
 : Try parsing FTPrimary.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTPrimary($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 34) then                            (: '(' :)
      let $state := p:shiftT(34, $input, $state)            (: '(' :)
      let $state := p:lookahead1W(156, $input, $state)      (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state := p:try-FTSelection($input, $state)
      let $state := p:shiftT(37, $input, $state)            (: ')' :)
      return $state
    else if ($state[$p:l1] = 35) then                       (: '(#' :)
      let $state := p:try-FTExtensionSelection($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-FTWords($input, $state)
      let $state := p:lookahead1W(191, $input, $state)      (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'occurs' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'return' | 'same' | 'satisfies' |
                                                               'stable' | 'start' | 'using' | 'weight' | 'where' |
                                                               'window' | 'with' | 'without' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 181) then                  (: 'occurs' :)
          let $state := p:try-FTTimes($input, $state)
          return $state
        else
          $state
      return $state
  return $state
};

(:~
 : Parse FTPrimaryWithOptions.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTPrimaryWithOptions($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FTPrimary($input, $state)
  let $state := p:lookahead1W(190, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'return' | 'same' | 'satisfies' | 'stable' |
                                                               'start' | 'using' | 'weight' | 'where' | 'window' |
                                                               'with' | 'without' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 241) then                      (: 'using' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FTMatchOptions($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 246) then                      (: 'weight' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FTWeight($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTPrimaryWithOptions", $count, $begin, $end)
};

(:~
 : Try parsing FTPrimaryWithOptions.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTPrimaryWithOptions($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-FTPrimary($input, $state)
  let $state := p:lookahead1W(190, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'return' | 'same' | 'satisfies' | 'stable' |
                                                               'start' | 'using' | 'weight' | 'where' | 'window' |
                                                               'with' | 'without' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 241) then                      (: 'using' :)
      let $state := p:try-FTMatchOptions($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 246) then                      (: 'weight' :)
      let $state := p:try-FTWeight($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse FTUnaryNot.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTUnaryNot($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 135) then                      (: 'ftnot' :)
      let $state := p:shift(135, $input, $state)            (: 'ftnot' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(149, $input, $state)          (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | '{' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-FTPrimaryWithOptions($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTUnaryNot", $count, $begin, $end)
};

(:~
 : Try parsing FTUnaryNot.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTUnaryNot($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 135) then                      (: 'ftnot' :)
      let $state := p:shiftT(135, $input, $state)           (: 'ftnot' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(149, $input, $state)          (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | '{' :)
  let $state := p:try-FTPrimaryWithOptions($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production FTMildNot (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTMildNot-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(189, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'return' | 'same' | 'satisfies' | 'stable' |
                                                               'start' | 'where' | 'window' | 'with' | 'without' | '}' :)
    return
      if ($state[$p:l1] != 180) then                        (: 'not' :)
        $state
      else
        let $state := p:shift(180, $input, $state)          (: 'not' :)
        let $state := p:lookahead1W(50, $input, $state)     (: S^WS | ('(' ':') | 'in' :)
        let $state := p:shift(147, $input, $state)          (: 'in' :)
        let $state := p:lookahead1W(156, $input, $state)    (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-FTUnaryNot($input, $state)
        return p:parse-FTMildNot-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTMildNot (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTMildNot-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(189, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'return' | 'same' | 'satisfies' | 'stable' |
                                                               'start' | 'where' | 'window' | 'with' | 'without' | '}' :)
    return
      if ($state[$p:l1] != 180) then                        (: 'not' :)
        $state
      else
        let $state := p:shiftT(180, $input, $state)         (: 'not' :)
        let $state := p:lookahead1W(50, $input, $state)     (: S^WS | ('(' ':') | 'in' :)
        let $state := p:shiftT(147, $input, $state)         (: 'in' :)
        let $state := p:lookahead1W(156, $input, $state)    (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
        let $state := p:try-FTUnaryNot($input, $state)
        return p:try-FTMildNot-1($input, $state)
};

(:~
 : Parse FTMildNot.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTMildNot($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FTUnaryNot($input, $state)
  let $state := p:parse-FTMildNot-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTMildNot", $count, $begin, $end)
};

(:~
 : Try parsing FTMildNot.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTMildNot($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-FTUnaryNot($input, $state)
  let $state := p:try-FTMildNot-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production FTAnd (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTAnd-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 134) then                          (: 'ftand' :)
      $state
    else
      let $state := p:shift(134, $input, $state)            (: 'ftand' :)
      let $state := p:lookahead1W(156, $input, $state)      (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FTMildNot($input, $state)
      return p:parse-FTAnd-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTAnd (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTAnd-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 134) then                          (: 'ftand' :)
      $state
    else
      let $state := p:shiftT(134, $input, $state)           (: 'ftand' :)
      let $state := p:lookahead1W(156, $input, $state)      (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state := p:try-FTMildNot($input, $state)
      return p:try-FTAnd-1($input, $state)
};

(:~
 : Parse FTAnd.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTAnd($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FTMildNot($input, $state)
  let $state := p:parse-FTAnd-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTAnd", $count, $begin, $end)
};

(:~
 : Try parsing FTAnd.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTAnd($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-FTMildNot($input, $state)
  let $state := p:try-FTAnd-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production FTOr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTOr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 136) then                          (: 'ftor' :)
      $state
    else
      let $state := p:shift(136, $input, $state)            (: 'ftor' :)
      let $state := p:lookahead1W(156, $input, $state)      (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FTAnd($input, $state)
      return p:parse-FTOr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTOr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTOr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 136) then                          (: 'ftor' :)
      $state
    else
      let $state := p:shiftT(136, $input, $state)           (: 'ftor' :)
      let $state := p:lookahead1W(156, $input, $state)      (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state := p:try-FTAnd($input, $state)
      return p:try-FTOr-1($input, $state)
};

(:~
 : Parse FTOr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTOr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FTAnd($input, $state)
  let $state := p:parse-FTOr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTOr", $count, $begin, $end)
};

(:~
 : Try parsing FTOr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTOr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-FTAnd($input, $state)
  let $state := p:try-FTOr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production FTSelection (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTSelection-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(186, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'modify' | 'ne' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'return' | 'same' |
                                                               'satisfies' | 'stable' | 'start' | 'where' | 'window' |
                                                               'with' | 'without' | '}' :)
    return
      if ($state[$p:l1] != 80                               (: 'at' :)
      and $state[$p:l1] != 110                              (: 'different' :)
      and $state[$p:l1] != 112                              (: 'distance' :)
      and $state[$p:l1] != 122                              (: 'entire' :)
      and $state[$p:l1] != 187                              (: 'ordered' :)
      and $state[$p:l1] != 208                              (: 'same' :)
      and $state[$p:l1] != 250) then                        (: 'window' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-FTPosFilter($input, $state)
        return p:parse-FTSelection-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTSelection (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTSelection-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(186, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'modify' | 'ne' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'return' | 'same' |
                                                               'satisfies' | 'stable' | 'start' | 'where' | 'window' |
                                                               'with' | 'without' | '}' :)
    return
      if ($state[$p:l1] != 80                               (: 'at' :)
      and $state[$p:l1] != 110                              (: 'different' :)
      and $state[$p:l1] != 112                              (: 'distance' :)
      and $state[$p:l1] != 122                              (: 'entire' :)
      and $state[$p:l1] != 187                              (: 'ordered' :)
      and $state[$p:l1] != 208                              (: 'same' :)
      and $state[$p:l1] != 250) then                        (: 'window' :)
        $state
      else
        let $state := p:try-FTPosFilter($input, $state)
        return p:try-FTSelection-1($input, $state)
};

(:~
 : Parse FTSelection.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTSelection($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FTOr($input, $state)
  let $state := p:parse-FTSelection-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTSelection", $count, $begin, $end)
};

(:~
 : Try parsing FTSelection.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTSelection($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-FTOr($input, $state)
  let $state := p:try-FTSelection-1($input, $state)
  return $state
};

(:~
 : Parse SingleType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SingleType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-AtomicOrUnionType($input, $state)
  let $state := p:lookahead1W(204, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '*' | '+' |
                                                               ',' | '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '?' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'treat' | 'union' |
                                                               'where' | 'with' | 'words' | '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 39                             (: '*' :)
          or $state[$p:l1] = 64) then                       (: '?' :)
      let $state :=
        if ($state[$p:l1] = 64) then                        (: '?' :)
          let $state := p:shift(64, $input, $state)         (: '?' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(39, $input, $state)         (: '*' :)
          return $state
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SingleType", $count, $begin, $end)
};

(:~
 : Try parsing SingleType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-SingleType($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-AtomicOrUnionType($input, $state)
  let $state := p:lookahead1W(204, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '*' | '+' |
                                                               ',' | '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '?' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'treat' | 'union' |
                                                               'where' | 'with' | 'words' | '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 39                             (: '*' :)
          or $state[$p:l1] = 64) then                       (: '?' :)
      let $state :=
        if ($state[$p:l1] = 64) then                        (: '?' :)
          let $state := p:shiftT(64, $input, $state)        (: '?' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shiftT(39, $input, $state)        (: '*' :)
          return $state
      return $state
    else
      $state
  return $state
};

(:~
 : Parse Pragma.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Pragma($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(35, $input, $state)                 (: '(#' :)
  let $state := p:lookahead1(228, $input, $state)           (: URIQualifiedName | QName^Token | S | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 23) then                       (: S :)
      let $state := p:shift(23, $input, $state)             (: S :)
      return $state
    else
      $state
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1(11, $input, $state)            (: S | '#)' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 23) then                       (: S :)
      let $state := p:shift(23, $input, $state)             (: S :)
      let $state := p:lookahead1(0, $input, $state)         (: PragmaContents :)
      let $state := p:shift(2, $input, $state)              (: PragmaContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(5, $input, $state)             (: '#)' :)
  let $state := p:shift(30, $input, $state)                 (: '#)' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Pragma", $count, $begin, $end)
};

(:~
 : Try parsing Pragma.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Pragma($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(35, $input, $state)                (: '(#' :)
  let $state := p:lookahead1(228, $input, $state)           (: URIQualifiedName | QName^Token | S | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 23) then                       (: S :)
      let $state := p:shiftT(23, $input, $state)            (: S :)
      return $state
    else
      $state
  let $state := p:try-EQName($input, $state)
  let $state := p:lookahead1(11, $input, $state)            (: S | '#)' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 23) then                       (: S :)
      let $state := p:shiftT(23, $input, $state)            (: S :)
      let $state := p:lookahead1(0, $input, $state)         (: PragmaContents :)
      let $state := p:shiftT(2, $input, $state)             (: PragmaContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(5, $input, $state)             (: '#)' :)
  let $state := p:shiftT(30, $input, $state)                (: '#)' :)
  return $state
};

(:~
 : Parse the 1st loop of production ExtensionExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExtensionExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:whitespace($input, $state)
    let $state := p:parse-Pragma($input, $state)
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | '(#' | ('(' ':') | '{' :)
    return
      if ($state[$p:l1] != 35) then                         (: '(#' :)
        $state
      else
        p:parse-ExtensionExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ExtensionExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ExtensionExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:try-Pragma($input, $state)
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | '(#' | ('(' ':') | '{' :)
    return
      if ($state[$p:l1] != 35) then                         (: '(#' :)
        $state
      else
        p:try-ExtensionExpr-1($input, $state)
};

(:~
 : Parse ExtensionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExtensionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExtensionExpr-1($input, $state)
  let $state := p:shift(257, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(246, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 261) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:shift(261, $input, $state)                (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ExtensionExpr", $count, $begin, $end)
};

(:~
 : Try parsing ExtensionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ExtensionExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-ExtensionExpr-1($input, $state)
  let $state := p:shiftT(257, $input, $state)               (: '{' :)
  let $state := p:lookahead1W(246, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 261) then                     (: '}' :)
      let $state := p:try-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:shiftT(261, $input, $state)               (: '}' :)
  return $state
};

(:~
 : Parse the 1st loop of production PredicateList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PredicateList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(211, $input, $state)        (: EOF | S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' | 'as' |
                                                               'ascending' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
    return
      if ($state[$p:l1] != 68) then                         (: '[' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Predicate($input, $state)
        return p:parse-PredicateList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production PredicateList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-PredicateList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(211, $input, $state)        (: EOF | S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' | 'as' |
                                                               'ascending' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
    return
      if ($state[$p:l1] != 68) then                         (: '[' :)
        $state
      else
        let $state := p:try-Predicate($input, $state)
        return p:try-PredicateList-1($input, $state)
};

(:~
 : Parse PredicateList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PredicateList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-PredicateList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PredicateList", $count, $begin, $end)
};

(:~
 : Try parsing PredicateList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-PredicateList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-PredicateList-1($input, $state)
  return $state
};

(:~
 : Parse AbbrevForwardStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AbbrevForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 66) then                       (: '@' :)
      let $state := p:shift(66, $input, $state)             (: '@' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(231, $input, $state)          (: Wildcard | URIQualifiedName | QName^Token | S^WS |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-NodeTest($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AbbrevForwardStep", $count, $begin, $end)
};

(:~
 : Try parsing AbbrevForwardStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AbbrevForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 66) then                       (: '@' :)
      let $state := p:shiftT(66, $input, $state)            (: '@' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(231, $input, $state)          (: Wildcard | URIQualifiedName | QName^Token | S^WS |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-NodeTest($input, $state)
  return $state
};

(:~
 : Parse ForwardAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForwardAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 91) then                            (: 'child' :)
      let $state := p:shift(91, $input, $state)             (: 'child' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'descendant' :)
      let $state := p:shift(106, $input, $state)            (: 'descendant' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'attribute' :)
      let $state := p:shift(81, $input, $state)             (: 'attribute' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 171) then                      (: 'namespace' :)
      let $state := p:shift(171, $input, $state)            (: 'namespace' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 213) then                      (: 'self' :)
      let $state := p:shift(213, $input, $state)            (: 'self' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 202) then                      (: 'property' :)
      let $state := p:shift(202, $input, $state)            (: 'property' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'descendant-or-self' :)
      let $state := p:shift(107, $input, $state)            (: 'descendant-or-self' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 130) then                      (: 'following-sibling' :)
      let $state := p:shift(130, $input, $state)            (: 'following-sibling' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(129, $input, $state)            (: 'following' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ForwardAxis", $count, $begin, $end)
};

(:~
 : Try parsing ForwardAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ForwardAxis($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 91) then                            (: 'child' :)
      let $state := p:shiftT(91, $input, $state)            (: 'child' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shiftT(50, $input, $state)            (: '::' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'descendant' :)
      let $state := p:shiftT(106, $input, $state)           (: 'descendant' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shiftT(50, $input, $state)            (: '::' :)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'attribute' :)
      let $state := p:shiftT(81, $input, $state)            (: 'attribute' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shiftT(50, $input, $state)            (: '::' :)
      return $state
    else if ($state[$p:l1] = 171) then                      (: 'namespace' :)
      let $state := p:shiftT(171, $input, $state)           (: 'namespace' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shiftT(50, $input, $state)            (: '::' :)
      return $state
    else if ($state[$p:l1] = 213) then                      (: 'self' :)
      let $state := p:shiftT(213, $input, $state)           (: 'self' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shiftT(50, $input, $state)            (: '::' :)
      return $state
    else if ($state[$p:l1] = 202) then                      (: 'property' :)
      let $state := p:shiftT(202, $input, $state)           (: 'property' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shiftT(50, $input, $state)            (: '::' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'descendant-or-self' :)
      let $state := p:shiftT(107, $input, $state)           (: 'descendant-or-self' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shiftT(50, $input, $state)            (: '::' :)
      return $state
    else if ($state[$p:l1] = 130) then                      (: 'following-sibling' :)
      let $state := p:shiftT(130, $input, $state)           (: 'following-sibling' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shiftT(50, $input, $state)            (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(129, $input, $state)           (: 'following' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shiftT(50, $input, $state)            (: '::' :)
      return $state
  return $state
};

(:~
 : Parse ForwardStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 81) then                            (: 'attribute' :)
      let $state := p:lookahead2W(218, $input, $state)      (: EOF | S^WS | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 91                             (: 'descendant' :)
          or $state[$p:l1] = 106                            (: 'descendant-or-self' :)
          or $state[$p:l1] = 107                            (: 'following' :)
          or $state[$p:l1] = 129                            (: 'following-sibling' :)
          or $state[$p:l1] = 130                            (: 'namespace' :)
          or $state[$p:l1] = 171                            (: 'property' :)
          or $state[$p:l1] = 202                            (: 'self' :)
          or $state[$p:l1] = 213) then                      (: 'self' :)
      let $state := p:lookahead2W(215, $input, $state)      (: EOF | S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 25681                               (: 'attribute' '::' :)
     or $state[$p:lk] = 25691                               (: 'child' '::' :)
     or $state[$p:lk] = 25706                               (: 'descendant' '::' :)
     or $state[$p:lk] = 25707                               (: 'descendant-or-self' '::' :)
     or $state[$p:lk] = 25729                               (: 'following' '::' :)
     or $state[$p:lk] = 25730                               (: 'following-sibling' '::' :)
     or $state[$p:lk] = 25771                               (: 'namespace' '::' :)
     or $state[$p:lk] = 25802                               (: 'property' '::' :)
     or $state[$p:lk] = 25813) then                         (: 'self' '::' :)
      let $state := p:parse-ForwardAxis($input, $state)
      let $state := p:lookahead1W(231, $input, $state)      (: Wildcard | URIQualifiedName | QName^Token | S^WS |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-NodeTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AbbrevForwardStep($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ForwardStep", $count, $begin, $end)
};

(:~
 : Try parsing ForwardStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 81) then                            (: 'attribute' :)
      let $state := p:lookahead2W(218, $input, $state)      (: EOF | S^WS | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 91                             (: 'descendant' :)
          or $state[$p:l1] = 106                            (: 'descendant-or-self' :)
          or $state[$p:l1] = 107                            (: 'following' :)
          or $state[$p:l1] = 129                            (: 'following-sibling' :)
          or $state[$p:l1] = 130                            (: 'namespace' :)
          or $state[$p:l1] = 171                            (: 'property' :)
          or $state[$p:l1] = 202                            (: 'self' :)
          or $state[$p:l1] = 213) then                      (: 'self' :)
      let $state := p:lookahead2W(215, $input, $state)      (: EOF | S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 25681                               (: 'attribute' '::' :)
     or $state[$p:lk] = 25691                               (: 'child' '::' :)
     or $state[$p:lk] = 25706                               (: 'descendant' '::' :)
     or $state[$p:lk] = 25707                               (: 'descendant-or-self' '::' :)
     or $state[$p:lk] = 25729                               (: 'following' '::' :)
     or $state[$p:lk] = 25730                               (: 'following-sibling' '::' :)
     or $state[$p:lk] = 25771                               (: 'namespace' '::' :)
     or $state[$p:lk] = 25802                               (: 'property' '::' :)
     or $state[$p:lk] = 25813) then                         (: 'self' '::' :)
      let $state := p:try-ForwardAxis($input, $state)
      let $state := p:lookahead1W(231, $input, $state)      (: Wildcard | URIQualifiedName | QName^Token | S^WS |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-NodeTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-AbbrevForwardStep($input, $state)
      return $state
  return $state
};

(:~
 : Parse AbbrevReverseStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AbbrevReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(45, $input, $state)                 (: '..' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AbbrevReverseStep", $count, $begin, $end)
};

(:~
 : Try parsing AbbrevReverseStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AbbrevReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(45, $input, $state)                (: '..' :)
  return $state
};

(:~
 : Parse NameTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NameTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 6) then                             (: Wildcard :)
      let $state := p:shift(6, $input, $state)              (: Wildcard :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-EQName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NameTest", $count, $begin, $end)
};

(:~
 : Try parsing NameTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-NameTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 6) then                             (: Wildcard :)
      let $state := p:shiftT(6, $input, $state)             (: Wildcard :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-EQName($input, $state)
      return $state
  return $state
};

(:~
 : Parse NodeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NodeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 81                                  (: 'binary' :)
     or $state[$p:l1] = 84                                  (: 'comment' :)
     or $state[$p:l1] = 93                                  (: 'document-node' :)
     or $state[$p:l1] = 115                                 (: 'element' :)
     or $state[$p:l1] = 116                                 (: 'namespace-node' :)
     or $state[$p:l1] = 172                                 (: 'node' :)
     or $state[$p:l1] = 178                                 (: 'processing-instruction' :)
     or $state[$p:l1] = 201                                 (: 'schema-attribute' :)
     or $state[$p:l1] = 211                                 (: 'schema-element' :)
     or $state[$p:l1] = 212                                 (: 'text' :)
     or $state[$p:l1] = 228) then                           (: 'text' :)
      let $state := p:lookahead2W(214, $input, $state)      (: EOF | S^WS | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 17489                               (: 'attribute' '(' :)
     or $state[$p:lk] = 17492                               (: 'binary' '(' :)
     or $state[$p:lk] = 17501                               (: 'comment' '(' :)
     or $state[$p:lk] = 17523                               (: 'document-node' '(' :)
     or $state[$p:lk] = 17524                               (: 'element' '(' :)
     or $state[$p:lk] = 17580                               (: 'namespace-node' '(' :)
     or $state[$p:lk] = 17586                               (: 'node' '(' :)
     or $state[$p:lk] = 17609                               (: 'processing-instruction' '(' :)
     or $state[$p:lk] = 17619                               (: 'schema-attribute' '(' :)
     or $state[$p:lk] = 17620                               (: 'schema-element' '(' :)
     or $state[$p:lk] = 17636) then                         (: 'text' '(' :)
      let $state := p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NameTest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NodeTest", $count, $begin, $end)
};

(:~
 : Try parsing NodeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-NodeTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 81                                  (: 'binary' :)
     or $state[$p:l1] = 84                                  (: 'comment' :)
     or $state[$p:l1] = 93                                  (: 'document-node' :)
     or $state[$p:l1] = 115                                 (: 'element' :)
     or $state[$p:l1] = 116                                 (: 'namespace-node' :)
     or $state[$p:l1] = 172                                 (: 'node' :)
     or $state[$p:l1] = 178                                 (: 'processing-instruction' :)
     or $state[$p:l1] = 201                                 (: 'schema-attribute' :)
     or $state[$p:l1] = 211                                 (: 'schema-element' :)
     or $state[$p:l1] = 212                                 (: 'text' :)
     or $state[$p:l1] = 228) then                           (: 'text' :)
      let $state := p:lookahead2W(214, $input, $state)      (: EOF | S^WS | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 17489                               (: 'attribute' '(' :)
     or $state[$p:lk] = 17492                               (: 'binary' '(' :)
     or $state[$p:lk] = 17501                               (: 'comment' '(' :)
     or $state[$p:lk] = 17523                               (: 'document-node' '(' :)
     or $state[$p:lk] = 17524                               (: 'element' '(' :)
     or $state[$p:lk] = 17580                               (: 'namespace-node' '(' :)
     or $state[$p:lk] = 17586                               (: 'node' '(' :)
     or $state[$p:lk] = 17609                               (: 'processing-instruction' '(' :)
     or $state[$p:lk] = 17619                               (: 'schema-attribute' '(' :)
     or $state[$p:lk] = 17620                               (: 'schema-element' '(' :)
     or $state[$p:lk] = 17636) then                         (: 'text' '(' :)
      let $state := p:try-KindTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-NameTest($input, $state)
      return $state
  return $state
};

(:~
 : Parse ReverseAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReverseAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 191) then                           (: 'parent' :)
      let $state := p:shift(191, $input, $state)            (: 'parent' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 74) then                       (: 'ancestor' :)
      let $state := p:shift(74, $input, $state)             (: 'ancestor' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 197) then                      (: 'preceding-sibling' :)
      let $state := p:shift(197, $input, $state)            (: 'preceding-sibling' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 196) then                      (: 'preceding' :)
      let $state := p:shift(196, $input, $state)            (: 'preceding' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(75, $input, $state)             (: 'ancestor-or-self' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ReverseAxis", $count, $begin, $end)
};

(:~
 : Try parsing ReverseAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ReverseAxis($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 191) then                           (: 'parent' :)
      let $state := p:shiftT(191, $input, $state)           (: 'parent' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shiftT(50, $input, $state)            (: '::' :)
      return $state
    else if ($state[$p:l1] = 74) then                       (: 'ancestor' :)
      let $state := p:shiftT(74, $input, $state)            (: 'ancestor' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shiftT(50, $input, $state)            (: '::' :)
      return $state
    else if ($state[$p:l1] = 197) then                      (: 'preceding-sibling' :)
      let $state := p:shiftT(197, $input, $state)           (: 'preceding-sibling' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shiftT(50, $input, $state)            (: '::' :)
      return $state
    else if ($state[$p:l1] = 196) then                      (: 'preceding' :)
      let $state := p:shiftT(196, $input, $state)           (: 'preceding' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shiftT(50, $input, $state)            (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(75, $input, $state)            (: 'ancestor-or-self' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shiftT(50, $input, $state)            (: '::' :)
      return $state
  return $state
};

(:~
 : Parse ReverseStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 45) then                            (: '..' :)
      let $state := p:parse-AbbrevReverseStep($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ReverseAxis($input, $state)
      let $state := p:lookahead1W(231, $input, $state)      (: Wildcard | URIQualifiedName | QName^Token | S^WS |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-NodeTest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ReverseStep", $count, $begin, $end)
};

(:~
 : Try parsing ReverseStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 45) then                            (: '..' :)
      let $state := p:try-AbbrevReverseStep($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-ReverseAxis($input, $state)
      let $state := p:lookahead1W(231, $input, $state)      (: Wildcard | URIQualifiedName | QName^Token | S^WS |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-NodeTest($input, $state)
      return $state
  return $state
};

(:~
 : Parse AxisStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AxisStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 74                                  (: 'ancestor-or-self' :)
     or $state[$p:l1] = 75                                  (: 'parent' :)
     or $state[$p:l1] = 191                                 (: 'preceding' :)
     or $state[$p:l1] = 196                                 (: 'preceding-sibling' :)
     or $state[$p:l1] = 197) then                           (: 'preceding-sibling' :)
      let $state := p:lookahead2W(215, $input, $state)      (: EOF | S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 45                                  (: '..' :)
     or $state[$p:lk] = 25674                               (: 'ancestor' '::' :)
     or $state[$p:lk] = 25675                               (: 'ancestor-or-self' '::' :)
     or $state[$p:lk] = 25791                               (: 'parent' '::' :)
     or $state[$p:lk] = 25796                               (: 'preceding' '::' :)
     or $state[$p:lk] = 25797) then                         (: 'preceding-sibling' '::' :)
      let $state := p:parse-ReverseStep($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ForwardStep($input, $state)
      return $state
  let $state := p:lookahead1W(211, $input, $state)          (: EOF | S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' | 'as' |
                                                               'ascending' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-PredicateList($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AxisStep", $count, $begin, $end)
};

(:~
 : Try parsing AxisStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AxisStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 74                                  (: 'ancestor-or-self' :)
     or $state[$p:l1] = 75                                  (: 'parent' :)
     or $state[$p:l1] = 191                                 (: 'preceding' :)
     or $state[$p:l1] = 196                                 (: 'preceding-sibling' :)
     or $state[$p:l1] = 197) then                           (: 'preceding-sibling' :)
      let $state := p:lookahead2W(215, $input, $state)      (: EOF | S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 45                                  (: '..' :)
     or $state[$p:lk] = 25674                               (: 'ancestor' '::' :)
     or $state[$p:lk] = 25675                               (: 'ancestor-or-self' '::' :)
     or $state[$p:lk] = 25791                               (: 'parent' '::' :)
     or $state[$p:lk] = 25796                               (: 'preceding' '::' :)
     or $state[$p:lk] = 25797) then                         (: 'preceding-sibling' '::' :)
      let $state := p:try-ReverseStep($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-ForwardStep($input, $state)
      return $state
  let $state := p:lookahead1W(211, $input, $state)          (: EOF | S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' | 'as' |
                                                               'ascending' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
  let $state := p:try-PredicateList($input, $state)
  return $state
};

(:~
 : Parse Predicate.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Predicate($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(68, $input, $state)                 (: '[' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(69, $input, $state)                 (: ']' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Predicate", $count, $begin, $end)
};

(:~
 : Try parsing Predicate.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Predicate($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(68, $input, $state)                (: '[' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-Expr($input, $state)
  let $state := p:shiftT(69, $input, $state)                (: ']' :)
  return $state
};

(:~
 : Parse Param.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Param($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1W(137, $input, $state)          (: S^WS | ('(' ':') | ')' | ',' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Param", $count, $begin, $end)
};

(:~
 : Try parsing Param.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Param($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(31, $input, $state)                (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-EQName($input, $state)
  let $state := p:lookahead1W(137, $input, $state)          (: S^WS | ('(' ':') | ')' | ',' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:try-TypeDeclaration($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production ParamList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParamList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(92, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(23, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Param($input, $state)
        return p:parse-ParamList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ParamList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ParamList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(92, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shiftT(41, $input, $state)          (: ',' :)
        let $state := p:lookahead1W(23, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state := p:try-Param($input, $state)
        return p:try-ParamList-1($input, $state)
};

(:~
 : Parse ParamList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParamList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Param($input, $state)
  let $state := p:parse-ParamList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ParamList", $count, $begin, $end)
};

(:~
 : Try parsing ParamList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ParamList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-Param($input, $state)
  let $state := p:try-ParamList-1($input, $state)
  return $state
};

(:~
 : Parse InlineFunction.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InlineFunction($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(138, $input, $state)                (: 'function' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(87, $input, $state)           (: S^WS | '$' | ('(' ':') | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(101, $input, $state)          (: S^WS | ('(' ':') | 'as' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:shift(78, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(235, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EnclosedExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "InlineFunction", $count, $begin, $end)
};

(:~
 : Try parsing InlineFunction.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-InlineFunction($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(138, $input, $state)               (: 'function' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(87, $input, $state)           (: S^WS | '$' | ('(' ':') | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:try-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  let $state := p:lookahead1W(101, $input, $state)          (: S^WS | ('(' ':') | 'as' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:shiftT(78, $input, $state)            (: 'as' :)
      let $state := p:lookahead1W(235, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-SequenceType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:try-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Parse LiteralFunctionItem.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LiteralFunctionItem($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '#' | ('(' ':') :)
  let $state := p:shift(29, $input, $state)                 (: '#' :)
  let $state := p:lookahead1W(18, $input, $state)           (: IntegerLiteral | S^WS | ('(' ':') :)
  let $state := p:shift(9, $input, $state)                  (: IntegerLiteral :)
  let $end := $state[$p:e0]
  return p:reduce($state, "LiteralFunctionItem", $count, $begin, $end)
};

(:~
 : Try parsing LiteralFunctionItem.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-LiteralFunctionItem($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-EQName($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '#' | ('(' ':') :)
  let $state := p:shiftT(29, $input, $state)                (: '#' :)
  let $state := p:lookahead1W(18, $input, $state)           (: IntegerLiteral | S^WS | ('(' ':') :)
  let $state := p:shiftT(9, $input, $state)                 (: IntegerLiteral :)
  return $state
};

(:~
 : Parse FunctionItemExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 138) then                           (: 'function' :)
      let $state := p:lookahead2W(85, $input, $state)       (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 17546) then                         (: 'function' '(' :)
      let $state := p:parse-InlineFunction($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-LiteralFunctionItem($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionItemExpr", $count, $begin, $end)
};

(:~
 : Try parsing FunctionItemExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FunctionItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 138) then                           (: 'function' :)
      let $state := p:lookahead2W(85, $input, $state)       (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 17546) then                         (: 'function' '(' :)
      let $state := p:try-InlineFunction($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-LiteralFunctionItem($input, $state)
      return $state
  return $state
};

(:~
 : Parse PrefixExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PrefixExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Expr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PrefixExpr", $count, $begin, $end)
};

(:~
 : Try parsing PrefixExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-PrefixExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-Expr($input, $state)
  return $state
};

(:~
 : Parse Prefix.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Prefix($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-NCName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "Prefix", $count, $begin, $end)
};

(:~
 : Try parsing Prefix.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Prefix($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-NCName($input, $state)
  return $state
};

(:~
 : Parse CompNamespaceConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompNamespaceConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(171, $input, $state)                (: 'namespace' :)
  let $state := p:lookahead1W(182, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' | 'with' | 'words' |
                                                               '{' :)
  let $state :=
    if ($state[$p:l1] = 257) then                           (: '{' :)
      let $state := p:shift(257, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-PrefixExpr($input, $state)
      let $state := p:shift(261, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Prefix($input, $state)
      return $state
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EnclosedExprExtended($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompNamespaceConstructor", $count, $begin, $end)
};

(:~
 : Try parsing CompNamespaceConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CompNamespaceConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(171, $input, $state)               (: 'namespace' :)
  let $state := p:lookahead1W(182, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' | 'with' | 'words' |
                                                               '{' :)
  let $state :=
    if ($state[$p:l1] = 257) then                           (: '{' :)
      let $state := p:shiftT(257, $input, $state)           (: '{' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-PrefixExpr($input, $state)
      let $state := p:shiftT(261, $input, $state)           (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-Prefix($input, $state)
      return $state
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:try-EnclosedExprExtended($input, $state)
  return $state
};

(:~
 : Parse CompBinaryConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompBinaryConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(84, $input, $state)                 (: 'binary' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EnclosedExprExtended($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompBinaryConstructor", $count, $begin, $end)
};

(:~
 : Try parsing CompBinaryConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CompBinaryConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(84, $input, $state)                (: 'binary' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:try-EnclosedExprExtended($input, $state)
  return $state
};

(:~
 : Parse CompPIConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(201, $input, $state)                (: 'processing-instruction' :)
  let $state := p:lookahead1W(182, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' | 'with' | 'words' |
                                                               '{' :)
  let $state :=
    if ($state[$p:l1] = 257) then                           (: '{' :)
      let $state := p:shift(257, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expr($input, $state)
      let $state := p:shift(261, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-NCName($input, $state)
      return $state
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(257, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(246, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 261) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:shift(261, $input, $state)                (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompPIConstructor", $count, $begin, $end)
};

(:~
 : Try parsing CompPIConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CompPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(201, $input, $state)               (: 'processing-instruction' :)
  let $state := p:lookahead1W(182, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' | 'with' | 'words' |
                                                               '{' :)
  let $state :=
    if ($state[$p:l1] = 257) then                           (: '{' :)
      let $state := p:shiftT(257, $input, $state)           (: '{' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-Expr($input, $state)
      let $state := p:shiftT(261, $input, $state)           (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-NCName($input, $state)
      return $state
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shiftT(257, $input, $state)               (: '{' :)
  let $state := p:lookahead1W(246, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 261) then                     (: '}' :)
      let $state := p:try-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:shiftT(261, $input, $state)               (: '}' :)
  return $state
};

(:~
 : Parse CompCommentConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(93, $input, $state)                 (: 'comment' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(257, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(261, $input, $state)                (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompCommentConstructor", $count, $begin, $end)
};

(:~
 : Try parsing CompCommentConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CompCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(93, $input, $state)                (: 'comment' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shiftT(257, $input, $state)               (: '{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-Expr($input, $state)
  let $state := p:shiftT(261, $input, $state)               (: '}' :)
  return $state
};

(:~
 : Parse EnclosedExprExtended.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EnclosedExprExtended($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(257, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(246, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 261) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:shift(261, $input, $state)                (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "EnclosedExprExtended", $count, $begin, $end)
};

(:~
 : Try parsing EnclosedExprExtended.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-EnclosedExprExtended($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(257, $input, $state)               (: '{' :)
  let $state := p:lookahead1W(246, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 261) then                     (: '}' :)
      let $state := p:try-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:shiftT(261, $input, $state)               (: '}' :)
  return $state
};

(:~
 : Parse CompTextConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompTextConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(228, $input, $state)                (: 'text' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EnclosedExprExtended($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompTextConstructor", $count, $begin, $end)
};

(:~
 : Try parsing CompTextConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CompTextConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(228, $input, $state)               (: 'text' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:try-EnclosedExprExtended($input, $state)
  return $state
};

(:~
 : Parse CompAttrConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompAttrConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(81, $input, $state)                 (: 'attribute' :)
  let $state := p:lookahead1W(232, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:l1] = 257) then                           (: '{' :)
      let $state := p:shift(257, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expr($input, $state)
      let $state := p:shift(261, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-EQName($input, $state)
      return $state
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(257, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(246, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 261) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:shift(261, $input, $state)                (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompAttrConstructor", $count, $begin, $end)
};

(:~
 : Try parsing CompAttrConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CompAttrConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(81, $input, $state)                (: 'attribute' :)
  let $state := p:lookahead1W(232, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:l1] = 257) then                           (: '{' :)
      let $state := p:shiftT(257, $input, $state)           (: '{' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-Expr($input, $state)
      let $state := p:shiftT(261, $input, $state)           (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-EQName($input, $state)
      return $state
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shiftT(257, $input, $state)               (: '{' :)
  let $state := p:lookahead1W(246, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 261) then                     (: '}' :)
      let $state := p:try-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:shiftT(261, $input, $state)               (: '}' :)
  return $state
};

(:~
 : Parse ContentExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContentExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Expr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ContentExpr", $count, $begin, $end)
};

(:~
 : Try parsing ContentExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ContentExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-Expr($input, $state)
  return $state
};

(:~
 : Parse CompElemConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(116, $input, $state)                (: 'element' :)
  let $state := p:lookahead1W(232, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:l1] = 257) then                           (: '{' :)
      let $state := p:shift(257, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expr($input, $state)
      let $state := p:shift(261, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-EQName($input, $state)
      return $state
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(257, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(246, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 261) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ContentExpr($input, $state)
      return $state
    else
      $state
  let $state := p:shift(261, $input, $state)                (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompElemConstructor", $count, $begin, $end)
};

(:~
 : Try parsing CompElemConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CompElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(116, $input, $state)               (: 'element' :)
  let $state := p:lookahead1W(232, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:l1] = 257) then                           (: '{' :)
      let $state := p:shiftT(257, $input, $state)           (: '{' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-Expr($input, $state)
      let $state := p:shiftT(261, $input, $state)           (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-EQName($input, $state)
      return $state
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shiftT(257, $input, $state)               (: '{' :)
  let $state := p:lookahead1W(246, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 261) then                     (: '}' :)
      let $state := p:try-ContentExpr($input, $state)
      return $state
    else
      $state
  let $state := p:shiftT(261, $input, $state)               (: '}' :)
  return $state
};

(:~
 : Parse CompDocConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompDocConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(114, $input, $state)                (: 'document' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(257, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(261, $input, $state)                (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompDocConstructor", $count, $begin, $end)
};

(:~
 : Try parsing CompDocConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CompDocConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(114, $input, $state)               (: 'document' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shiftT(257, $input, $state)               (: '{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-Expr($input, $state)
  let $state := p:shiftT(261, $input, $state)               (: '}' :)
  return $state
};

(:~
 : Parse ComputedConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ComputedConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 114) then                           (: 'document' :)
      let $state := p:parse-CompDocConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'element' :)
      let $state := p:parse-CompElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'attribute' :)
      let $state := p:parse-CompAttrConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 228) then                      (: 'text' :)
      let $state := p:parse-CompTextConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'comment' :)
      let $state := p:parse-CompCommentConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 201) then                      (: 'processing-instruction' :)
      let $state := p:parse-CompPIConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'binary' :)
      let $state := p:parse-CompBinaryConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CompNamespaceConstructor($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ComputedConstructor", $count, $begin, $end)
};

(:~
 : Try parsing ComputedConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ComputedConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 114) then                           (: 'document' :)
      let $state := p:try-CompDocConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'element' :)
      let $state := p:try-CompElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'attribute' :)
      let $state := p:try-CompAttrConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 228) then                      (: 'text' :)
      let $state := p:try-CompTextConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'comment' :)
      let $state := p:try-CompCommentConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 201) then                      (: 'processing-instruction' :)
      let $state := p:try-CompPIConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'binary' :)
      let $state := p:try-CompBinaryConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-CompNamespaceConstructor($input, $state)
      return $state
  return $state
};

(:~
 : Parse DirPIConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(59, $input, $state)                 (: '<?' :)
  let $state := p:lookahead1(4, $input, $state)             (: PITarget :)
  let $state := p:shift(19, $input, $state)                 (: PITarget :)
  let $state := p:lookahead1(14, $input, $state)            (: S | '?>' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 23) then                       (: S :)
      let $state := p:shift(23, $input, $state)             (: S :)
      let $state := p:lookahead1(2, $input, $state)         (: DirPIContents :)
      let $state := p:shift(4, $input, $state)              (: DirPIContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(9, $input, $state)             (: '?>' :)
  let $state := p:shift(65, $input, $state)                 (: '?>' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "DirPIConstructor", $count, $begin, $end)
};

(:~
 : Try parsing DirPIConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-DirPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(59, $input, $state)                (: '<?' :)
  let $state := p:lookahead1(4, $input, $state)             (: PITarget :)
  let $state := p:shiftT(19, $input, $state)                (: PITarget :)
  let $state := p:lookahead1(14, $input, $state)            (: S | '?>' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 23) then                       (: S :)
      let $state := p:shiftT(23, $input, $state)            (: S :)
      let $state := p:lookahead1(2, $input, $state)         (: DirPIContents :)
      let $state := p:shiftT(4, $input, $state)             (: DirPIContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(9, $input, $state)             (: '?>' :)
  let $state := p:shiftT(65, $input, $state)                (: '?>' :)
  return $state
};

(:~
 : Parse DirCommentConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(54, $input, $state)                 (: '<!--' :)
  let $state := p:lookahead1(1, $input, $state)             (: DirCommentContents :)
  let $state := p:shift(3, $input, $state)                  (: DirCommentContents :)
  let $state := p:lookahead1(6, $input, $state)             (: '-->' :)
  let $state := p:shift(43, $input, $state)                 (: '-->' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "DirCommentConstructor", $count, $begin, $end)
};

(:~
 : Try parsing DirCommentConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-DirCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(54, $input, $state)                (: '<!--' :)
  let $state := p:lookahead1(1, $input, $state)             (: DirCommentContents :)
  let $state := p:shiftT(3, $input, $state)                 (: DirCommentContents :)
  let $state := p:lookahead1(6, $input, $state)             (: '-->' :)
  let $state := p:shiftT(43, $input, $state)                (: '-->' :)
  return $state
};

(:~
 : Parse CDataSection.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CDataSection($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(55, $input, $state)                 (: '<![CDATA[' :)
  let $state := p:lookahead1(3, $input, $state)             (: CDataSectionContents :)
  let $state := p:shift(5, $input, $state)                  (: CDataSectionContents :)
  let $state := p:lookahead1(10, $input, $state)            (: ']]>' :)
  let $state := p:shift(70, $input, $state)                 (: ']]>' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CDataSection", $count, $begin, $end)
};

(:~
 : Try parsing CDataSection.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CDataSection($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(55, $input, $state)                (: '<![CDATA[' :)
  let $state := p:lookahead1(3, $input, $state)             (: CDataSectionContents :)
  let $state := p:shiftT(5, $input, $state)                 (: CDataSectionContents :)
  let $state := p:lookahead1(10, $input, $state)            (: ']]>' :)
  let $state := p:shiftT(70, $input, $state)                (: ']]>' :)
  return $state
};

(:~
 : Parse DirElemContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 53                                  (: '<' :)
     or $state[$p:l1] = 54                                  (: '<!--' :)
     or $state[$p:l1] = 59) then                            (: '<?' :)
      let $state := p:parse-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 55) then                       (: '<![CDATA[' :)
      let $state := p:parse-CDataSection($input, $state)
      return $state
    else if ($state[$p:l1] = 16) then                       (: ElementContentChar :)
      let $state := p:shift(16, $input, $state)             (: ElementContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "DirElemContent", $count, $begin, $end)
};

(:~
 : Try parsing DirElemContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-DirElemContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 53                                  (: '<' :)
     or $state[$p:l1] = 54                                  (: '<!--' :)
     or $state[$p:l1] = 59) then                            (: '<?' :)
      let $state := p:try-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 55) then                       (: '<![CDATA[' :)
      let $state := p:try-CDataSection($input, $state)
      return $state
    else if ($state[$p:l1] = 16) then                       (: ElementContentChar :)
      let $state := p:shiftT(16, $input, $state)            (: ElementContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-CommonContent($input, $state)
      return $state
  return $state
};

(:~
 : Parse AposAttrValueContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AposAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 18) then                            (: AposAttrContentChar :)
      let $state := p:shift(18, $input, $state)             (: AposAttrContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "AposAttrValueContent", $count, $begin, $end)
};

(:~
 : Try parsing AposAttrValueContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AposAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 18) then                            (: AposAttrContentChar :)
      let $state := p:shiftT(18, $input, $state)            (: AposAttrContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-CommonContent($input, $state)
      return $state
  return $state
};

(:~
 : Parse EnclosedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EnclosedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(257, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(261, $input, $state)                (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "EnclosedExpr", $count, $begin, $end)
};

(:~
 : Try parsing EnclosedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-EnclosedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(257, $input, $state)               (: '{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-Expr($input, $state)
  let $state := p:shiftT(261, $input, $state)               (: '}' :)
  return $state
};

(:~
 : Parse CommonContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CommonContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 13) then                            (: PredefinedEntityRef :)
      let $state := p:shift(13, $input, $state)             (: PredefinedEntityRef :)
      return $state
    else if ($state[$p:l1] = 20) then                       (: CharRef :)
      let $state := p:shift(20, $input, $state)             (: CharRef :)
      return $state
    else if ($state[$p:l1] = 258) then                      (: '{{' :)
      let $state := p:shift(258, $input, $state)            (: '{{' :)
      return $state
    else if ($state[$p:l1] = 262) then                      (: '}}' :)
      let $state := p:shift(262, $input, $state)            (: '}}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-EnclosedExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "CommonContent", $count, $begin, $end)
};

(:~
 : Try parsing CommonContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CommonContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 13) then                            (: PredefinedEntityRef :)
      let $state := p:shiftT(13, $input, $state)            (: PredefinedEntityRef :)
      return $state
    else if ($state[$p:l1] = 20) then                       (: CharRef :)
      let $state := p:shiftT(20, $input, $state)            (: CharRef :)
      return $state
    else if ($state[$p:l1] = 258) then                      (: '{{' :)
      let $state := p:shiftT(258, $input, $state)           (: '{{' :)
      return $state
    else if ($state[$p:l1] = 262) then                      (: '}}' :)
      let $state := p:shiftT(262, $input, $state)           (: '}}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-EnclosedExpr($input, $state)
      return $state
  return $state
};

(:~
 : Parse QuotAttrValueContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuotAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 17) then                            (: QuotAttrContentChar :)
      let $state := p:shift(17, $input, $state)             (: QuotAttrContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "QuotAttrValueContent", $count, $begin, $end)
};

(:~
 : Try parsing QuotAttrValueContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-QuotAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 17) then                            (: QuotAttrContentChar :)
      let $state := p:shiftT(17, $input, $state)            (: QuotAttrContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-CommonContent($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(161, $input, $state)         (: PredefinedEntityRef | EscapeQuot | QuotAttrContentChar |
                                                               CharRef | '"' | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 28) then                          (: '"' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 14) then                      (: EscapeQuot :)
            let $state := p:shift(14, $input, $state)       (: EscapeQuot :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-QuotAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-DirAttributeValue-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(161, $input, $state)         (: PredefinedEntityRef | EscapeQuot | QuotAttrContentChar |
                                                               CharRef | '"' | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 28) then                          (: '"' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 14) then                      (: EscapeQuot :)
            let $state := p:shiftT(14, $input, $state)      (: EscapeQuot :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:try-QuotAttrValueContent($input, $state)
            return $state
        return p:try-DirAttributeValue-1($input, $state)
};

(:~
 : Parse the 2nd loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(162, $input, $state)         (: PredefinedEntityRef | EscapeApos | AposAttrContentChar |
                                                               CharRef | "'" | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 33) then                          (: "'" :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 15) then                      (: EscapeApos :)
            let $state := p:shift(15, $input, $state)       (: EscapeApos :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-AposAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-2($input, $state)
};

(:~
 : Try parsing the 2nd loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-DirAttributeValue-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(162, $input, $state)         (: PredefinedEntityRef | EscapeApos | AposAttrContentChar |
                                                               CharRef | "'" | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 33) then                          (: "'" :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 15) then                      (: EscapeApos :)
            let $state := p:shiftT(15, $input, $state)      (: EscapeApos :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:try-AposAttrValueContent($input, $state)
            return $state
        return p:try-DirAttributeValue-2($input, $state)
};

(:~
 : Parse DirAttributeValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1(15, $input, $state)            (: '"' | "'" :)
  let $state :=
    if ($state[$p:l1] = 28) then                            (: '"' :)
      let $state := p:shift(28, $input, $state)             (: '"' :)
      let $state := p:parse-DirAttributeValue-1($input, $state)
      let $state := p:shift(28, $input, $state)             (: '"' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(33, $input, $state)             (: "'" :)
      let $state := p:parse-DirAttributeValue-2($input, $state)
      let $state := p:shift(33, $input, $state)             (: "'" :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "DirAttributeValue", $count, $begin, $end)
};

(:~
 : Try parsing DirAttributeValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-DirAttributeValue($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1(15, $input, $state)            (: '"' | "'" :)
  let $state :=
    if ($state[$p:l1] = 28) then                            (: '"' :)
      let $state := p:shiftT(28, $input, $state)            (: '"' :)
      let $state := p:try-DirAttributeValue-1($input, $state)
      let $state := p:shiftT(28, $input, $state)            (: '"' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(33, $input, $state)            (: "'" :)
      let $state := p:try-DirAttributeValue-2($input, $state)
      let $state := p:shiftT(33, $input, $state)            (: "'" :)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production DirAttributeList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(21, $input, $state)          (: S | '/>' | '>' :)
    return
      if ($state[$p:l1] != 23) then                         (: S :)
        $state
      else
        let $state := p:shift(23, $input, $state)           (: S :)
        let $state := p:lookahead1(230, $input, $state)     (: QName^Token | S | '/>' | '>' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] != 23                      (: S :)
               and $state[$p:l1] != 48                      (: '/>' :)
               and $state[$p:l1] != 61) then                (: '>' :)
            let $state := p:parse-QName($input, $state)
            let $state := p:lookahead1(12, $input, $state)  (: S | '=' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 23) then             (: S :)
                let $state := p:shift(23, $input, $state)   (: S :)
                return $state
              else
                $state
            let $state := p:lookahead1(7, $input, $state)   (: '=' :)
            let $state := p:shift(60, $input, $state)       (: '=' :)
            let $state := p:lookahead1(20, $input, $state)  (: S | '"' | "'" :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 23) then             (: S :)
                let $state := p:shift(23, $input, $state)   (: S :)
                return $state
              else
                $state
            let $state := p:parse-DirAttributeValue($input, $state)
            return $state
          else
            $state
        return p:parse-DirAttributeList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production DirAttributeList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-DirAttributeList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(21, $input, $state)          (: S | '/>' | '>' :)
    return
      if ($state[$p:l1] != 23) then                         (: S :)
        $state
      else
        let $state := p:shiftT(23, $input, $state)          (: S :)
        let $state := p:lookahead1(230, $input, $state)     (: QName^Token | S | '/>' | '>' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] != 23                      (: S :)
               and $state[$p:l1] != 48                      (: '/>' :)
               and $state[$p:l1] != 61) then                (: '>' :)
            let $state := p:try-QName($input, $state)
            let $state := p:lookahead1(12, $input, $state)  (: S | '=' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 23) then             (: S :)
                let $state := p:shiftT(23, $input, $state)  (: S :)
                return $state
              else
                $state
            let $state := p:lookahead1(7, $input, $state)   (: '=' :)
            let $state := p:shiftT(60, $input, $state)      (: '=' :)
            let $state := p:lookahead1(20, $input, $state)  (: S | '"' | "'" :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 23) then             (: S :)
                let $state := p:shiftT(23, $input, $state)  (: S :)
                return $state
              else
                $state
            let $state := p:try-DirAttributeValue($input, $state)
            return $state
          else
            $state
        return p:try-DirAttributeList-1($input, $state)
};

(:~
 : Parse DirAttributeList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-DirAttributeList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "DirAttributeList", $count, $begin, $end)
};

(:~
 : Try parsing DirAttributeList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-DirAttributeList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-DirAttributeList-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production DirElemConstructor (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemConstructor-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(168, $input, $state)         (: PredefinedEntityRef | ElementContentChar | CharRef |
                                                               '<' | '<!--' | '<![CDATA[' | '</' | '<?' | '{' | '{{' |
                                                               '}}' :)
    return
      if ($state[$p:l1] = 56) then                          (: '</' :)
        $state
      else
        let $state := p:parse-DirElemContent($input, $state)
        return p:parse-DirElemConstructor-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production DirElemConstructor (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-DirElemConstructor-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(168, $input, $state)         (: PredefinedEntityRef | ElementContentChar | CharRef |
                                                               '<' | '<!--' | '<![CDATA[' | '</' | '<?' | '{' | '{{' |
                                                               '}}' :)
    return
      if ($state[$p:l1] = 56) then                          (: '</' :)
        $state
      else
        let $state := p:try-DirElemContent($input, $state)
        return p:try-DirElemConstructor-1($input, $state)
};

(:~
 : Parse DirElemConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(53, $input, $state)                 (: '<' :)
  let $state := p:parse-QName($input, $state)
  let $state := p:parse-DirAttributeList($input, $state)
  let $state :=
    if ($state[$p:l1] = 48) then                            (: '/>' :)
      let $state := p:shift(48, $input, $state)             (: '/>' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(61, $input, $state)             (: '>' :)
      let $state := p:parse-DirElemConstructor-1($input, $state)
      let $state := p:shift(56, $input, $state)             (: '</' :)
      let $state := p:parse-QName($input, $state)
      let $state := p:lookahead1(13, $input, $state)        (: S | '>' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 23) then                   (: S :)
          let $state := p:shift(23, $input, $state)         (: S :)
          return $state
        else
          $state
      let $state := p:lookahead1(8, $input, $state)         (: '>' :)
      let $state := p:shift(61, $input, $state)             (: '>' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "DirElemConstructor", $count, $begin, $end)
};

(:~
 : Try parsing DirElemConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-DirElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(53, $input, $state)                (: '<' :)
  let $state := p:try-QName($input, $state)
  let $state := p:try-DirAttributeList($input, $state)
  let $state :=
    if ($state[$p:l1] = 48) then                            (: '/>' :)
      let $state := p:shiftT(48, $input, $state)            (: '/>' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(61, $input, $state)            (: '>' :)
      let $state := p:try-DirElemConstructor-1($input, $state)
      let $state := p:shiftT(56, $input, $state)            (: '</' :)
      let $state := p:try-QName($input, $state)
      let $state := p:lookahead1(13, $input, $state)        (: S | '>' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 23) then                   (: S :)
          let $state := p:shiftT(23, $input, $state)        (: S :)
          return $state
        else
          $state
      let $state := p:lookahead1(8, $input, $state)         (: '>' :)
      let $state := p:shiftT(61, $input, $state)            (: '>' :)
      return $state
  return $state
};

(:~
 : Parse DirectConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirectConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 53) then                            (: '<' :)
      let $state := p:parse-DirElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 54) then                       (: '<!--' :)
      let $state := p:parse-DirCommentConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-DirPIConstructor($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "DirectConstructor", $count, $begin, $end)
};

(:~
 : Try parsing DirectConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-DirectConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 53) then                            (: '<' :)
      let $state := p:try-DirElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 54) then                       (: '<!--' :)
      let $state := p:try-DirCommentConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-DirPIConstructor($input, $state)
      return $state
  return $state
};

(:~
 : Parse Constructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Constructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 53                                  (: '<' :)
     or $state[$p:l1] = 54                                  (: '<!--' :)
     or $state[$p:l1] = 59) then                            (: '<?' :)
      let $state := p:parse-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ComputedConstructor($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Constructor", $count, $begin, $end)
};

(:~
 : Try parsing Constructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Constructor($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 53                                  (: '<' :)
     or $state[$p:l1] = 54                                  (: '<!--' :)
     or $state[$p:l1] = 59) then                            (: '<?' :)
      let $state := p:try-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-ComputedConstructor($input, $state)
      return $state
  return $state
};

(:~
 : Parse UnorderedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnorderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(239, $input, $state)                (: 'unordered' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(257, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(261, $input, $state)                (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "UnorderedExpr", $count, $begin, $end)
};

(:~
 : Try parsing UnorderedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-UnorderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(239, $input, $state)               (: 'unordered' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shiftT(257, $input, $state)               (: '{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-Expr($input, $state)
  let $state := p:shiftT(261, $input, $state)               (: '}' :)
  return $state
};

(:~
 : Parse OrderedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(187, $input, $state)                (: 'ordered' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(257, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(261, $input, $state)                (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderedExpr", $count, $begin, $end)
};

(:~
 : Try parsing OrderedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-OrderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(187, $input, $state)               (: 'ordered' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shiftT(257, $input, $state)               (: '{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-Expr($input, $state)
  let $state := p:shiftT(261, $input, $state)               (: '}' :)
  return $state
};

(:~
 : Parse ArgumentPlaceholder.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArgumentPlaceholder($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(64, $input, $state)                 (: '?' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ArgumentPlaceholder", $count, $begin, $end)
};

(:~
 : Try parsing ArgumentPlaceholder.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ArgumentPlaceholder($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(64, $input, $state)                (: '?' :)
  return $state
};

(:~
 : Parse Argument.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Argument($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 64) then                            (: '?' :)
      let $state := p:parse-ArgumentPlaceholder($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ExprSingle($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Argument", $count, $begin, $end)
};

(:~
 : Try parsing Argument.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Argument($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 64) then                            (: '?' :)
      let $state := p:try-ArgumentPlaceholder($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-ExprSingle($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production ArgumentList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArgumentList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(92, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(244, $input, $state)    (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Argument($input, $state)
        return p:parse-ArgumentList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ArgumentList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ArgumentList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(92, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shiftT(41, $input, $state)          (: ',' :)
        let $state := p:lookahead1W(244, $input, $state)    (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
        let $state := p:try-Argument($input, $state)
        return p:try-ArgumentList-1($input, $state)
};

(:~
 : Parse ArgumentList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArgumentList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(249, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | ')' |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '?' | '@' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Argument($input, $state)
      let $state := p:parse-ArgumentList-1($input, $state)
      return $state
    else
      $state
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ArgumentList", $count, $begin, $end)
};

(:~
 : Try parsing ArgumentList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ArgumentList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(249, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | ')' |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '?' | '@' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:try-Argument($input, $state)
      let $state := p:try-ArgumentList-1($input, $state)
      return $state
    else
      $state
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  return $state
};

(:~
 : Parse FunctionName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 7) then                             (: URIQualifiedName :)
      let $state := p:shift(7, $input, $state)              (: URIQualifiedName :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FunctionQName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionName", $count, $begin, $end)
};

(:~
 : Try parsing FunctionName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FunctionName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 7) then                             (: URIQualifiedName :)
      let $state := p:shiftT(7, $input, $state)             (: URIQualifiedName :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-FunctionQName($input, $state)
      return $state
  return $state
};

(:~
 : Parse FunctionCall.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionCall($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FunctionName($input, $state)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ArgumentList($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionCall", $count, $begin, $end)
};

(:~
 : Try parsing FunctionCall.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FunctionCall($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-FunctionName($input, $state)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:try-ArgumentList($input, $state)
  return $state
};

(:~
 : Parse ContextItemExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContextItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(44, $input, $state)                 (: '.' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ContextItemExpr", $count, $begin, $end)
};

(:~
 : Try parsing ContextItemExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ContextItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(44, $input, $state)                (: '.' :)
  return $state
};

(:~
 : Parse ParenthesizedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParenthesizedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(243, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | ')' |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ParenthesizedExpr", $count, $begin, $end)
};

(:~
 : Try parsing ParenthesizedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ParenthesizedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(243, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | ')' |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:try-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  return $state
};

(:~
 : Parse VarRef.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarRef($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VarRef", $count, $begin, $end)
};

(:~
 : Try parsing VarRef.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-VarRef($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(31, $input, $state)                (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-VarName($input, $state)
  return $state
};

(:~
 : Parse PrimaryExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PrimaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 171) then                           (: 'namespace' :)
      let $state := p:lookahead2W(185, $input, $state)      (: NCName^Token | S^WS | '#' | '(' | ('(' ':') | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' | 'with' | 'words' |
                                                               '{' :)
      return $state
    else if ($state[$p:l1] = 201) then                      (: 'processing-instruction' :)
      let $state := p:lookahead2W(184, $input, $state)      (: NCName^Token | S^WS | '#' | ('(' ':') | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' | 'with' | 'words' |
                                                               '{' :)
      return $state
    else if ($state[$p:l1] = 81                             (: 'element' :)
          or $state[$p:l1] = 116) then                      (: 'element' :)
      let $state := p:lookahead2W(234, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '#' | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
      return $state
    else if ($state[$p:l1] = 84                             (: 'comment' :)
          or $state[$p:l1] = 93                             (: 'text' :)
          or $state[$p:l1] = 228) then                      (: 'text' :)
      let $state := p:lookahead2W(86, $input, $state)       (: S^WS | '#' | ('(' ':') | '{' :)
      return $state
    else if ($state[$p:l1] = 114                            (: 'ordered' :)
          or $state[$p:l1] = 187                            (: 'unordered' :)
          or $state[$p:l1] = 239) then                      (: 'unordered' :)
      let $state := p:lookahead2W(132, $input, $state)      (: S^WS | '#' | '(' | ('(' ':') | '{' :)
      return $state
    else if ($state[$p:l1] = 7                              (: QName^Token :)
          or $state[$p:l1] = 22                             (: 'after' :)
          or $state[$p:l1] = 71                             (: 'ancestor' :)
          or $state[$p:l1] = 74                             (: 'ancestor-or-self' :)
          or $state[$p:l1] = 75                             (: 'and' :)
          or $state[$p:l1] = 76                             (: 'as' :)
          or $state[$p:l1] = 78                             (: 'ascending' :)
          or $state[$p:l1] = 79                             (: 'before' :)
          or $state[$p:l1] = 83                             (: 'case' :)
          or $state[$p:l1] = 87                             (: 'cast' :)
          or $state[$p:l1] = 88                             (: 'castable' :)
          or $state[$p:l1] = 89                             (: 'catch' :)
          or $state[$p:l1] = 90                             (: 'child' :)
          or $state[$p:l1] = 91                             (: 'collation' :)
          or $state[$p:l1] = 92                             (: 'contains' :)
          or $state[$p:l1] = 95                             (: 'copy' :)
          or $state[$p:l1] = 98                             (: 'count' :)
          or $state[$p:l1] = 100                            (: 'declare' :)
          or $state[$p:l1] = 103                            (: 'default' :)
          or $state[$p:l1] = 104                            (: 'delete' :)
          or $state[$p:l1] = 105                            (: 'descendant' :)
          or $state[$p:l1] = 106                            (: 'descendant-or-self' :)
          or $state[$p:l1] = 107                            (: 'descending' :)
          or $state[$p:l1] = 108                            (: 'div' :)
          or $state[$p:l1] = 113                            (: 'else' :)
          or $state[$p:l1] = 117                            (: 'empty' :)
          or $state[$p:l1] = 118                            (: 'end' :)
          or $state[$p:l1] = 121                            (: 'eq' :)
          or $state[$p:l1] = 123                            (: 'every' :)
          or $state[$p:l1] = 124                            (: 'except' :)
          or $state[$p:l1] = 126                            (: 'first' :)
          or $state[$p:l1] = 128                            (: 'following' :)
          or $state[$p:l1] = 129                            (: 'following-sibling' :)
          or $state[$p:l1] = 130                            (: 'for' :)
          or $state[$p:l1] = 131                            (: 'ge' :)
          or $state[$p:l1] = 139                            (: 'group' :)
          or $state[$p:l1] = 141                            (: 'gt' :)
          or $state[$p:l1] = 143                            (: 'idiv' :)
          or $state[$p:l1] = 144                            (: 'import' :)
          or $state[$p:l1] = 146                            (: 'insert' :)
          or $state[$p:l1] = 151                            (: 'instance' :)
          or $state[$p:l1] = 152                            (: 'intersect' :)
          or $state[$p:l1] = 153                            (: 'into' :)
          or $state[$p:l1] = 154                            (: 'is' :)
          or $state[$p:l1] = 155                            (: 'last' :)
          or $state[$p:l1] = 158                            (: 'le' :)
          or $state[$p:l1] = 160                            (: 'let' :)
          or $state[$p:l1] = 162                            (: 'lt' :)
          or $state[$p:l1] = 165                            (: 'mod' :)
          or $state[$p:l1] = 167                            (: 'modify' :)
          or $state[$p:l1] = 168                            (: 'module' :)
          or $state[$p:l1] = 169                            (: 'ne' :)
          or $state[$p:l1] = 173                            (: 'only' :)
          or $state[$p:l1] = 183                            (: 'or' :)
          or $state[$p:l1] = 185                            (: 'order' :)
          or $state[$p:l1] = 186                            (: 'paragraphs' :)
          or $state[$p:l1] = 190                            (: 'parent' :)
          or $state[$p:l1] = 191                            (: 'preceding' :)
          or $state[$p:l1] = 196                            (: 'preceding-sibling' :)
          or $state[$p:l1] = 197                            (: 'private' :)
          or $state[$p:l1] = 200                            (: 'property' :)
          or $state[$p:l1] = 202                            (: 'rename' :)
          or $state[$p:l1] = 204                            (: 'replace' :)
          or $state[$p:l1] = 205                            (: 'return' :)
          or $state[$p:l1] = 206                            (: 'satisfies' :)
          or $state[$p:l1] = 209                            (: 'self' :)
          or $state[$p:l1] = 213                            (: 'sentences' :)
          or $state[$p:l1] = 216                            (: 'some' :)
          or $state[$p:l1] = 219                            (: 'stable' :)
          or $state[$p:l1] = 220                            (: 'start' :)
          or $state[$p:l1] = 221                            (: 'times' :)
          or $state[$p:l1] = 231                            (: 'to' :)
          or $state[$p:l1] = 232                            (: 'treat' :)
          or $state[$p:l1] = 233                            (: 'try' :)
          or $state[$p:l1] = 234                            (: 'union' :)
          or $state[$p:l1] = 238                            (: 'validate' :)
          or $state[$p:l1] = 242                            (: 'where' :)
          or $state[$p:l1] = 248                            (: 'with' :)
          or $state[$p:l1] = 251                            (: 'words' :)
          or $state[$p:l1] = 254                            (: 'xquery' :)
          or $state[$p:l1] = 255) then                      (: 'xquery' :)
      let $state := p:lookahead2W(85, $input, $state)       (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 9                                   (: IntegerLiteral :)
     or $state[$p:lk] = 10                                  (: DecimalLiteral :)
     or $state[$p:lk] = 11                                  (: DoubleLiteral :)
     or $state[$p:lk] = 12) then                            (: StringLiteral :)
      let $state := p:parse-Literal($input, $state)
      return $state
    else if ($state[$p:lk] = 31) then                       (: '$' :)
      let $state := p:parse-VarRef($input, $state)
      return $state
    else if ($state[$p:lk] = 34) then                       (: '(' :)
      let $state := p:parse-ParenthesizedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 44) then                       (: '.' :)
      let $state := p:parse-ContextItemExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 17415                          (: URIQualifiedName '(' :)
          or $state[$p:lk] = 17430                          (: QName^Token '(' :)
          or $state[$p:lk] = 17479                          (: 'after' '(' :)
          or $state[$p:lk] = 17482                          (: 'ancestor' '(' :)
          or $state[$p:lk] = 17483                          (: 'ancestor-or-self' '(' :)
          or $state[$p:lk] = 17484                          (: 'and' '(' :)
          or $state[$p:lk] = 17486                          (: 'as' '(' :)
          or $state[$p:lk] = 17487                          (: 'ascending' '(' :)
          or $state[$p:lk] = 17491                          (: 'before' '(' :)
          or $state[$p:lk] = 17495                          (: 'case' '(' :)
          or $state[$p:lk] = 17496                          (: 'cast' '(' :)
          or $state[$p:lk] = 17497                          (: 'castable' '(' :)
          or $state[$p:lk] = 17498                          (: 'catch' '(' :)
          or $state[$p:lk] = 17499                          (: 'child' '(' :)
          or $state[$p:lk] = 17500                          (: 'collation' '(' :)
          or $state[$p:lk] = 17503                          (: 'contains' '(' :)
          or $state[$p:lk] = 17506                          (: 'copy' '(' :)
          or $state[$p:lk] = 17508                          (: 'count' '(' :)
          or $state[$p:lk] = 17511                          (: 'declare' '(' :)
          or $state[$p:lk] = 17512                          (: 'default' '(' :)
          or $state[$p:lk] = 17513                          (: 'delete' '(' :)
          or $state[$p:lk] = 17514                          (: 'descendant' '(' :)
          or $state[$p:lk] = 17515                          (: 'descendant-or-self' '(' :)
          or $state[$p:lk] = 17516                          (: 'descending' '(' :)
          or $state[$p:lk] = 17521                          (: 'div' '(' :)
          or $state[$p:lk] = 17522                          (: 'document' '(' :)
          or $state[$p:lk] = 17525                          (: 'else' '(' :)
          or $state[$p:lk] = 17526                          (: 'empty' '(' :)
          or $state[$p:lk] = 17529                          (: 'end' '(' :)
          or $state[$p:lk] = 17531                          (: 'eq' '(' :)
          or $state[$p:lk] = 17532                          (: 'every' '(' :)
          or $state[$p:lk] = 17534                          (: 'except' '(' :)
          or $state[$p:lk] = 17536                          (: 'first' '(' :)
          or $state[$p:lk] = 17537                          (: 'following' '(' :)
          or $state[$p:lk] = 17538                          (: 'following-sibling' '(' :)
          or $state[$p:lk] = 17539                          (: 'for' '(' :)
          or $state[$p:lk] = 17547                          (: 'ge' '(' :)
          or $state[$p:lk] = 17549                          (: 'group' '(' :)
          or $state[$p:lk] = 17551                          (: 'gt' '(' :)
          or $state[$p:lk] = 17552                          (: 'idiv' '(' :)
          or $state[$p:lk] = 17554                          (: 'import' '(' :)
          or $state[$p:lk] = 17559                          (: 'insert' '(' :)
          or $state[$p:lk] = 17560                          (: 'instance' '(' :)
          or $state[$p:lk] = 17561                          (: 'intersect' '(' :)
          or $state[$p:lk] = 17562                          (: 'into' '(' :)
          or $state[$p:lk] = 17563                          (: 'is' '(' :)
          or $state[$p:lk] = 17566                          (: 'last' '(' :)
          or $state[$p:lk] = 17568                          (: 'le' '(' :)
          or $state[$p:lk] = 17570                          (: 'let' '(' :)
          or $state[$p:lk] = 17573                          (: 'lt' '(' :)
          or $state[$p:lk] = 17575                          (: 'mod' '(' :)
          or $state[$p:lk] = 17576                          (: 'modify' '(' :)
          or $state[$p:lk] = 17577                          (: 'module' '(' :)
          or $state[$p:lk] = 17579                          (: 'namespace' '(' :)
          or $state[$p:lk] = 17581                          (: 'ne' '(' :)
          or $state[$p:lk] = 17591                          (: 'only' '(' :)
          or $state[$p:lk] = 17593                          (: 'or' '(' :)
          or $state[$p:lk] = 17594                          (: 'order' '(' :)
          or $state[$p:lk] = 17595                          (: 'ordered' '(' :)
          or $state[$p:lk] = 17598                          (: 'paragraphs' '(' :)
          or $state[$p:lk] = 17599                          (: 'parent' '(' :)
          or $state[$p:lk] = 17604                          (: 'preceding' '(' :)
          or $state[$p:lk] = 17605                          (: 'preceding-sibling' '(' :)
          or $state[$p:lk] = 17608                          (: 'private' '(' :)
          or $state[$p:lk] = 17610                          (: 'property' '(' :)
          or $state[$p:lk] = 17612                          (: 'rename' '(' :)
          or $state[$p:lk] = 17613                          (: 'replace' '(' :)
          or $state[$p:lk] = 17614                          (: 'return' '(' :)
          or $state[$p:lk] = 17617                          (: 'satisfies' '(' :)
          or $state[$p:lk] = 17621                          (: 'self' '(' :)
          or $state[$p:lk] = 17624                          (: 'sentences' '(' :)
          or $state[$p:lk] = 17627                          (: 'some' '(' :)
          or $state[$p:lk] = 17628                          (: 'stable' '(' :)
          or $state[$p:lk] = 17629                          (: 'start' '(' :)
          or $state[$p:lk] = 17639                          (: 'times' '(' :)
          or $state[$p:lk] = 17640                          (: 'to' '(' :)
          or $state[$p:lk] = 17641                          (: 'treat' '(' :)
          or $state[$p:lk] = 17642                          (: 'try' '(' :)
          or $state[$p:lk] = 17646                          (: 'union' '(' :)
          or $state[$p:lk] = 17647                          (: 'unordered' '(' :)
          or $state[$p:lk] = 17650                          (: 'validate' '(' :)
          or $state[$p:lk] = 17656                          (: 'where' '(' :)
          or $state[$p:lk] = 17659                          (: 'with' '(' :)
          or $state[$p:lk] = 17662                          (: 'words' '(' :)
          or $state[$p:lk] = 17663) then                    (: 'xquery' '(' :)
      let $state := p:parse-FunctionCall($input, $state)
      return $state
    else if ($state[$p:lk] = 131771) then                   (: 'ordered' '{' :)
      let $state := p:parse-OrderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 131823) then                   (: 'unordered' '{' :)
      let $state := p:parse-UnorderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 115                            (: 'document-node' :)
          or $state[$p:lk] = 119                            (: 'empty-sequence' :)
          or $state[$p:lk] = 138                            (: 'function' :)
          or $state[$p:lk] = 145                            (: 'if' :)
          or $state[$p:lk] = 156                            (: 'item' :)
          or $state[$p:lk] = 172                            (: 'namespace-node' :)
          or $state[$p:lk] = 178                            (: 'node' :)
          or $state[$p:lk] = 211                            (: 'schema-attribute' :)
          or $state[$p:lk] = 212                            (: 'schema-element' :)
          or $state[$p:lk] = 227                            (: 'switch' :)
          or $state[$p:lk] = 237                            (: 'typeswitch' :)
          or $state[$p:lk] = 14855                          (: URIQualifiedName '#' :)
          or $state[$p:lk] = 14870                          (: QName^Token '#' :)
          or $state[$p:lk] = 14919                          (: 'after' '#' :)
          or $state[$p:lk] = 14922                          (: 'ancestor' '#' :)
          or $state[$p:lk] = 14923                          (: 'ancestor-or-self' '#' :)
          or $state[$p:lk] = 14924                          (: 'and' '#' :)
          or $state[$p:lk] = 14926                          (: 'as' '#' :)
          or $state[$p:lk] = 14927                          (: 'ascending' '#' :)
          or $state[$p:lk] = 14929                          (: 'attribute' '#' :)
          or $state[$p:lk] = 14931                          (: 'before' '#' :)
          or $state[$p:lk] = 14932                          (: 'binary' '#' :)
          or $state[$p:lk] = 14935                          (: 'case' '#' :)
          or $state[$p:lk] = 14936                          (: 'cast' '#' :)
          or $state[$p:lk] = 14937                          (: 'castable' '#' :)
          or $state[$p:lk] = 14938                          (: 'catch' '#' :)
          or $state[$p:lk] = 14939                          (: 'child' '#' :)
          or $state[$p:lk] = 14940                          (: 'collation' '#' :)
          or $state[$p:lk] = 14941                          (: 'comment' '#' :)
          or $state[$p:lk] = 14943                          (: 'contains' '#' :)
          or $state[$p:lk] = 14946                          (: 'copy' '#' :)
          or $state[$p:lk] = 14948                          (: 'count' '#' :)
          or $state[$p:lk] = 14951                          (: 'declare' '#' :)
          or $state[$p:lk] = 14952                          (: 'default' '#' :)
          or $state[$p:lk] = 14953                          (: 'delete' '#' :)
          or $state[$p:lk] = 14954                          (: 'descendant' '#' :)
          or $state[$p:lk] = 14955                          (: 'descendant-or-self' '#' :)
          or $state[$p:lk] = 14956                          (: 'descending' '#' :)
          or $state[$p:lk] = 14961                          (: 'div' '#' :)
          or $state[$p:lk] = 14962                          (: 'document' '#' :)
          or $state[$p:lk] = 14964                          (: 'element' '#' :)
          or $state[$p:lk] = 14965                          (: 'else' '#' :)
          or $state[$p:lk] = 14966                          (: 'empty' '#' :)
          or $state[$p:lk] = 14969                          (: 'end' '#' :)
          or $state[$p:lk] = 14971                          (: 'eq' '#' :)
          or $state[$p:lk] = 14972                          (: 'every' '#' :)
          or $state[$p:lk] = 14974                          (: 'except' '#' :)
          or $state[$p:lk] = 14976                          (: 'first' '#' :)
          or $state[$p:lk] = 14977                          (: 'following' '#' :)
          or $state[$p:lk] = 14978                          (: 'following-sibling' '#' :)
          or $state[$p:lk] = 14979                          (: 'for' '#' :)
          or $state[$p:lk] = 14987                          (: 'ge' '#' :)
          or $state[$p:lk] = 14989                          (: 'group' '#' :)
          or $state[$p:lk] = 14991                          (: 'gt' '#' :)
          or $state[$p:lk] = 14992                          (: 'idiv' '#' :)
          or $state[$p:lk] = 14994                          (: 'import' '#' :)
          or $state[$p:lk] = 14999                          (: 'insert' '#' :)
          or $state[$p:lk] = 15000                          (: 'instance' '#' :)
          or $state[$p:lk] = 15001                          (: 'intersect' '#' :)
          or $state[$p:lk] = 15002                          (: 'into' '#' :)
          or $state[$p:lk] = 15003                          (: 'is' '#' :)
          or $state[$p:lk] = 15006                          (: 'last' '#' :)
          or $state[$p:lk] = 15008                          (: 'le' '#' :)
          or $state[$p:lk] = 15010                          (: 'let' '#' :)
          or $state[$p:lk] = 15013                          (: 'lt' '#' :)
          or $state[$p:lk] = 15015                          (: 'mod' '#' :)
          or $state[$p:lk] = 15016                          (: 'modify' '#' :)
          or $state[$p:lk] = 15017                          (: 'module' '#' :)
          or $state[$p:lk] = 15019                          (: 'namespace' '#' :)
          or $state[$p:lk] = 15021                          (: 'ne' '#' :)
          or $state[$p:lk] = 15031                          (: 'only' '#' :)
          or $state[$p:lk] = 15033                          (: 'or' '#' :)
          or $state[$p:lk] = 15034                          (: 'order' '#' :)
          or $state[$p:lk] = 15035                          (: 'ordered' '#' :)
          or $state[$p:lk] = 15038                          (: 'paragraphs' '#' :)
          or $state[$p:lk] = 15039                          (: 'parent' '#' :)
          or $state[$p:lk] = 15044                          (: 'preceding' '#' :)
          or $state[$p:lk] = 15045                          (: 'preceding-sibling' '#' :)
          or $state[$p:lk] = 15048                          (: 'private' '#' :)
          or $state[$p:lk] = 15049                          (: 'processing-instruction' '#' :)
          or $state[$p:lk] = 15050                          (: 'property' '#' :)
          or $state[$p:lk] = 15052                          (: 'rename' '#' :)
          or $state[$p:lk] = 15053                          (: 'replace' '#' :)
          or $state[$p:lk] = 15054                          (: 'return' '#' :)
          or $state[$p:lk] = 15057                          (: 'satisfies' '#' :)
          or $state[$p:lk] = 15061                          (: 'self' '#' :)
          or $state[$p:lk] = 15064                          (: 'sentences' '#' :)
          or $state[$p:lk] = 15067                          (: 'some' '#' :)
          or $state[$p:lk] = 15068                          (: 'stable' '#' :)
          or $state[$p:lk] = 15069                          (: 'start' '#' :)
          or $state[$p:lk] = 15076                          (: 'text' '#' :)
          or $state[$p:lk] = 15079                          (: 'times' '#' :)
          or $state[$p:lk] = 15080                          (: 'to' '#' :)
          or $state[$p:lk] = 15081                          (: 'treat' '#' :)
          or $state[$p:lk] = 15082                          (: 'try' '#' :)
          or $state[$p:lk] = 15086                          (: 'union' '#' :)
          or $state[$p:lk] = 15087                          (: 'unordered' '#' :)
          or $state[$p:lk] = 15090                          (: 'validate' '#' :)
          or $state[$p:lk] = 15096                          (: 'where' '#' :)
          or $state[$p:lk] = 15099                          (: 'with' '#' :)
          or $state[$p:lk] = 15102                          (: 'words' '#' :)
          or $state[$p:lk] = 15103) then                    (: 'xquery' '#' :)
      let $state := p:parse-FunctionItemExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-Constructor($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PrimaryExpr", $count, $begin, $end)
};

(:~
 : Try parsing PrimaryExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-PrimaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 171) then                           (: 'namespace' :)
      let $state := p:lookahead2W(185, $input, $state)      (: NCName^Token | S^WS | '#' | '(' | ('(' ':') | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' | 'with' | 'words' |
                                                               '{' :)
      return $state
    else if ($state[$p:l1] = 201) then                      (: 'processing-instruction' :)
      let $state := p:lookahead2W(184, $input, $state)      (: NCName^Token | S^WS | '#' | ('(' ':') | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' | 'with' | 'words' |
                                                               '{' :)
      return $state
    else if ($state[$p:l1] = 81                             (: 'element' :)
          or $state[$p:l1] = 116) then                      (: 'element' :)
      let $state := p:lookahead2W(234, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '#' | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
      return $state
    else if ($state[$p:l1] = 84                             (: 'comment' :)
          or $state[$p:l1] = 93                             (: 'text' :)
          or $state[$p:l1] = 228) then                      (: 'text' :)
      let $state := p:lookahead2W(86, $input, $state)       (: S^WS | '#' | ('(' ':') | '{' :)
      return $state
    else if ($state[$p:l1] = 114                            (: 'ordered' :)
          or $state[$p:l1] = 187                            (: 'unordered' :)
          or $state[$p:l1] = 239) then                      (: 'unordered' :)
      let $state := p:lookahead2W(132, $input, $state)      (: S^WS | '#' | '(' | ('(' ':') | '{' :)
      return $state
    else if ($state[$p:l1] = 7                              (: QName^Token :)
          or $state[$p:l1] = 22                             (: 'after' :)
          or $state[$p:l1] = 71                             (: 'ancestor' :)
          or $state[$p:l1] = 74                             (: 'ancestor-or-self' :)
          or $state[$p:l1] = 75                             (: 'and' :)
          or $state[$p:l1] = 76                             (: 'as' :)
          or $state[$p:l1] = 78                             (: 'ascending' :)
          or $state[$p:l1] = 79                             (: 'before' :)
          or $state[$p:l1] = 83                             (: 'case' :)
          or $state[$p:l1] = 87                             (: 'cast' :)
          or $state[$p:l1] = 88                             (: 'castable' :)
          or $state[$p:l1] = 89                             (: 'catch' :)
          or $state[$p:l1] = 90                             (: 'child' :)
          or $state[$p:l1] = 91                             (: 'collation' :)
          or $state[$p:l1] = 92                             (: 'contains' :)
          or $state[$p:l1] = 95                             (: 'copy' :)
          or $state[$p:l1] = 98                             (: 'count' :)
          or $state[$p:l1] = 100                            (: 'declare' :)
          or $state[$p:l1] = 103                            (: 'default' :)
          or $state[$p:l1] = 104                            (: 'delete' :)
          or $state[$p:l1] = 105                            (: 'descendant' :)
          or $state[$p:l1] = 106                            (: 'descendant-or-self' :)
          or $state[$p:l1] = 107                            (: 'descending' :)
          or $state[$p:l1] = 108                            (: 'div' :)
          or $state[$p:l1] = 113                            (: 'else' :)
          or $state[$p:l1] = 117                            (: 'empty' :)
          or $state[$p:l1] = 118                            (: 'end' :)
          or $state[$p:l1] = 121                            (: 'eq' :)
          or $state[$p:l1] = 123                            (: 'every' :)
          or $state[$p:l1] = 124                            (: 'except' :)
          or $state[$p:l1] = 126                            (: 'first' :)
          or $state[$p:l1] = 128                            (: 'following' :)
          or $state[$p:l1] = 129                            (: 'following-sibling' :)
          or $state[$p:l1] = 130                            (: 'for' :)
          or $state[$p:l1] = 131                            (: 'ge' :)
          or $state[$p:l1] = 139                            (: 'group' :)
          or $state[$p:l1] = 141                            (: 'gt' :)
          or $state[$p:l1] = 143                            (: 'idiv' :)
          or $state[$p:l1] = 144                            (: 'import' :)
          or $state[$p:l1] = 146                            (: 'insert' :)
          or $state[$p:l1] = 151                            (: 'instance' :)
          or $state[$p:l1] = 152                            (: 'intersect' :)
          or $state[$p:l1] = 153                            (: 'into' :)
          or $state[$p:l1] = 154                            (: 'is' :)
          or $state[$p:l1] = 155                            (: 'last' :)
          or $state[$p:l1] = 158                            (: 'le' :)
          or $state[$p:l1] = 160                            (: 'let' :)
          or $state[$p:l1] = 162                            (: 'lt' :)
          or $state[$p:l1] = 165                            (: 'mod' :)
          or $state[$p:l1] = 167                            (: 'modify' :)
          or $state[$p:l1] = 168                            (: 'module' :)
          or $state[$p:l1] = 169                            (: 'ne' :)
          or $state[$p:l1] = 173                            (: 'only' :)
          or $state[$p:l1] = 183                            (: 'or' :)
          or $state[$p:l1] = 185                            (: 'order' :)
          or $state[$p:l1] = 186                            (: 'paragraphs' :)
          or $state[$p:l1] = 190                            (: 'parent' :)
          or $state[$p:l1] = 191                            (: 'preceding' :)
          or $state[$p:l1] = 196                            (: 'preceding-sibling' :)
          or $state[$p:l1] = 197                            (: 'private' :)
          or $state[$p:l1] = 200                            (: 'property' :)
          or $state[$p:l1] = 202                            (: 'rename' :)
          or $state[$p:l1] = 204                            (: 'replace' :)
          or $state[$p:l1] = 205                            (: 'return' :)
          or $state[$p:l1] = 206                            (: 'satisfies' :)
          or $state[$p:l1] = 209                            (: 'self' :)
          or $state[$p:l1] = 213                            (: 'sentences' :)
          or $state[$p:l1] = 216                            (: 'some' :)
          or $state[$p:l1] = 219                            (: 'stable' :)
          or $state[$p:l1] = 220                            (: 'start' :)
          or $state[$p:l1] = 221                            (: 'times' :)
          or $state[$p:l1] = 231                            (: 'to' :)
          or $state[$p:l1] = 232                            (: 'treat' :)
          or $state[$p:l1] = 233                            (: 'try' :)
          or $state[$p:l1] = 234                            (: 'union' :)
          or $state[$p:l1] = 238                            (: 'validate' :)
          or $state[$p:l1] = 242                            (: 'where' :)
          or $state[$p:l1] = 248                            (: 'with' :)
          or $state[$p:l1] = 251                            (: 'words' :)
          or $state[$p:l1] = 254                            (: 'xquery' :)
          or $state[$p:l1] = 255) then                      (: 'xquery' :)
      let $state := p:lookahead2W(85, $input, $state)       (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 9                                   (: IntegerLiteral :)
     or $state[$p:lk] = 10                                  (: DecimalLiteral :)
     or $state[$p:lk] = 11                                  (: DoubleLiteral :)
     or $state[$p:lk] = 12) then                            (: StringLiteral :)
      let $state := p:try-Literal($input, $state)
      return $state
    else if ($state[$p:lk] = 31) then                       (: '$' :)
      let $state := p:try-VarRef($input, $state)
      return $state
    else if ($state[$p:lk] = 34) then                       (: '(' :)
      let $state := p:try-ParenthesizedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 44) then                       (: '.' :)
      let $state := p:try-ContextItemExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 17415                          (: URIQualifiedName '(' :)
          or $state[$p:lk] = 17430                          (: QName^Token '(' :)
          or $state[$p:lk] = 17479                          (: 'after' '(' :)
          or $state[$p:lk] = 17482                          (: 'ancestor' '(' :)
          or $state[$p:lk] = 17483                          (: 'ancestor-or-self' '(' :)
          or $state[$p:lk] = 17484                          (: 'and' '(' :)
          or $state[$p:lk] = 17486                          (: 'as' '(' :)
          or $state[$p:lk] = 17487                          (: 'ascending' '(' :)
          or $state[$p:lk] = 17491                          (: 'before' '(' :)
          or $state[$p:lk] = 17495                          (: 'case' '(' :)
          or $state[$p:lk] = 17496                          (: 'cast' '(' :)
          or $state[$p:lk] = 17497                          (: 'castable' '(' :)
          or $state[$p:lk] = 17498                          (: 'catch' '(' :)
          or $state[$p:lk] = 17499                          (: 'child' '(' :)
          or $state[$p:lk] = 17500                          (: 'collation' '(' :)
          or $state[$p:lk] = 17503                          (: 'contains' '(' :)
          or $state[$p:lk] = 17506                          (: 'copy' '(' :)
          or $state[$p:lk] = 17508                          (: 'count' '(' :)
          or $state[$p:lk] = 17511                          (: 'declare' '(' :)
          or $state[$p:lk] = 17512                          (: 'default' '(' :)
          or $state[$p:lk] = 17513                          (: 'delete' '(' :)
          or $state[$p:lk] = 17514                          (: 'descendant' '(' :)
          or $state[$p:lk] = 17515                          (: 'descendant-or-self' '(' :)
          or $state[$p:lk] = 17516                          (: 'descending' '(' :)
          or $state[$p:lk] = 17521                          (: 'div' '(' :)
          or $state[$p:lk] = 17522                          (: 'document' '(' :)
          or $state[$p:lk] = 17525                          (: 'else' '(' :)
          or $state[$p:lk] = 17526                          (: 'empty' '(' :)
          or $state[$p:lk] = 17529                          (: 'end' '(' :)
          or $state[$p:lk] = 17531                          (: 'eq' '(' :)
          or $state[$p:lk] = 17532                          (: 'every' '(' :)
          or $state[$p:lk] = 17534                          (: 'except' '(' :)
          or $state[$p:lk] = 17536                          (: 'first' '(' :)
          or $state[$p:lk] = 17537                          (: 'following' '(' :)
          or $state[$p:lk] = 17538                          (: 'following-sibling' '(' :)
          or $state[$p:lk] = 17539                          (: 'for' '(' :)
          or $state[$p:lk] = 17547                          (: 'ge' '(' :)
          or $state[$p:lk] = 17549                          (: 'group' '(' :)
          or $state[$p:lk] = 17551                          (: 'gt' '(' :)
          or $state[$p:lk] = 17552                          (: 'idiv' '(' :)
          or $state[$p:lk] = 17554                          (: 'import' '(' :)
          or $state[$p:lk] = 17559                          (: 'insert' '(' :)
          or $state[$p:lk] = 17560                          (: 'instance' '(' :)
          or $state[$p:lk] = 17561                          (: 'intersect' '(' :)
          or $state[$p:lk] = 17562                          (: 'into' '(' :)
          or $state[$p:lk] = 17563                          (: 'is' '(' :)
          or $state[$p:lk] = 17566                          (: 'last' '(' :)
          or $state[$p:lk] = 17568                          (: 'le' '(' :)
          or $state[$p:lk] = 17570                          (: 'let' '(' :)
          or $state[$p:lk] = 17573                          (: 'lt' '(' :)
          or $state[$p:lk] = 17575                          (: 'mod' '(' :)
          or $state[$p:lk] = 17576                          (: 'modify' '(' :)
          or $state[$p:lk] = 17577                          (: 'module' '(' :)
          or $state[$p:lk] = 17579                          (: 'namespace' '(' :)
          or $state[$p:lk] = 17581                          (: 'ne' '(' :)
          or $state[$p:lk] = 17591                          (: 'only' '(' :)
          or $state[$p:lk] = 17593                          (: 'or' '(' :)
          or $state[$p:lk] = 17594                          (: 'order' '(' :)
          or $state[$p:lk] = 17595                          (: 'ordered' '(' :)
          or $state[$p:lk] = 17598                          (: 'paragraphs' '(' :)
          or $state[$p:lk] = 17599                          (: 'parent' '(' :)
          or $state[$p:lk] = 17604                          (: 'preceding' '(' :)
          or $state[$p:lk] = 17605                          (: 'preceding-sibling' '(' :)
          or $state[$p:lk] = 17608                          (: 'private' '(' :)
          or $state[$p:lk] = 17610                          (: 'property' '(' :)
          or $state[$p:lk] = 17612                          (: 'rename' '(' :)
          or $state[$p:lk] = 17613                          (: 'replace' '(' :)
          or $state[$p:lk] = 17614                          (: 'return' '(' :)
          or $state[$p:lk] = 17617                          (: 'satisfies' '(' :)
          or $state[$p:lk] = 17621                          (: 'self' '(' :)
          or $state[$p:lk] = 17624                          (: 'sentences' '(' :)
          or $state[$p:lk] = 17627                          (: 'some' '(' :)
          or $state[$p:lk] = 17628                          (: 'stable' '(' :)
          or $state[$p:lk] = 17629                          (: 'start' '(' :)
          or $state[$p:lk] = 17639                          (: 'times' '(' :)
          or $state[$p:lk] = 17640                          (: 'to' '(' :)
          or $state[$p:lk] = 17641                          (: 'treat' '(' :)
          or $state[$p:lk] = 17642                          (: 'try' '(' :)
          or $state[$p:lk] = 17646                          (: 'union' '(' :)
          or $state[$p:lk] = 17647                          (: 'unordered' '(' :)
          or $state[$p:lk] = 17650                          (: 'validate' '(' :)
          or $state[$p:lk] = 17656                          (: 'where' '(' :)
          or $state[$p:lk] = 17659                          (: 'with' '(' :)
          or $state[$p:lk] = 17662                          (: 'words' '(' :)
          or $state[$p:lk] = 17663) then                    (: 'xquery' '(' :)
      let $state := p:try-FunctionCall($input, $state)
      return $state
    else if ($state[$p:lk] = 131771) then                   (: 'ordered' '{' :)
      let $state := p:try-OrderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 131823) then                   (: 'unordered' '{' :)
      let $state := p:try-UnorderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 115                            (: 'document-node' :)
          or $state[$p:lk] = 119                            (: 'empty-sequence' :)
          or $state[$p:lk] = 138                            (: 'function' :)
          or $state[$p:lk] = 145                            (: 'if' :)
          or $state[$p:lk] = 156                            (: 'item' :)
          or $state[$p:lk] = 172                            (: 'namespace-node' :)
          or $state[$p:lk] = 178                            (: 'node' :)
          or $state[$p:lk] = 211                            (: 'schema-attribute' :)
          or $state[$p:lk] = 212                            (: 'schema-element' :)
          or $state[$p:lk] = 227                            (: 'switch' :)
          or $state[$p:lk] = 237                            (: 'typeswitch' :)
          or $state[$p:lk] = 14855                          (: URIQualifiedName '#' :)
          or $state[$p:lk] = 14870                          (: QName^Token '#' :)
          or $state[$p:lk] = 14919                          (: 'after' '#' :)
          or $state[$p:lk] = 14922                          (: 'ancestor' '#' :)
          or $state[$p:lk] = 14923                          (: 'ancestor-or-self' '#' :)
          or $state[$p:lk] = 14924                          (: 'and' '#' :)
          or $state[$p:lk] = 14926                          (: 'as' '#' :)
          or $state[$p:lk] = 14927                          (: 'ascending' '#' :)
          or $state[$p:lk] = 14929                          (: 'attribute' '#' :)
          or $state[$p:lk] = 14931                          (: 'before' '#' :)
          or $state[$p:lk] = 14932                          (: 'binary' '#' :)
          or $state[$p:lk] = 14935                          (: 'case' '#' :)
          or $state[$p:lk] = 14936                          (: 'cast' '#' :)
          or $state[$p:lk] = 14937                          (: 'castable' '#' :)
          or $state[$p:lk] = 14938                          (: 'catch' '#' :)
          or $state[$p:lk] = 14939                          (: 'child' '#' :)
          or $state[$p:lk] = 14940                          (: 'collation' '#' :)
          or $state[$p:lk] = 14941                          (: 'comment' '#' :)
          or $state[$p:lk] = 14943                          (: 'contains' '#' :)
          or $state[$p:lk] = 14946                          (: 'copy' '#' :)
          or $state[$p:lk] = 14948                          (: 'count' '#' :)
          or $state[$p:lk] = 14951                          (: 'declare' '#' :)
          or $state[$p:lk] = 14952                          (: 'default' '#' :)
          or $state[$p:lk] = 14953                          (: 'delete' '#' :)
          or $state[$p:lk] = 14954                          (: 'descendant' '#' :)
          or $state[$p:lk] = 14955                          (: 'descendant-or-self' '#' :)
          or $state[$p:lk] = 14956                          (: 'descending' '#' :)
          or $state[$p:lk] = 14961                          (: 'div' '#' :)
          or $state[$p:lk] = 14962                          (: 'document' '#' :)
          or $state[$p:lk] = 14964                          (: 'element' '#' :)
          or $state[$p:lk] = 14965                          (: 'else' '#' :)
          or $state[$p:lk] = 14966                          (: 'empty' '#' :)
          or $state[$p:lk] = 14969                          (: 'end' '#' :)
          or $state[$p:lk] = 14971                          (: 'eq' '#' :)
          or $state[$p:lk] = 14972                          (: 'every' '#' :)
          or $state[$p:lk] = 14974                          (: 'except' '#' :)
          or $state[$p:lk] = 14976                          (: 'first' '#' :)
          or $state[$p:lk] = 14977                          (: 'following' '#' :)
          or $state[$p:lk] = 14978                          (: 'following-sibling' '#' :)
          or $state[$p:lk] = 14979                          (: 'for' '#' :)
          or $state[$p:lk] = 14987                          (: 'ge' '#' :)
          or $state[$p:lk] = 14989                          (: 'group' '#' :)
          or $state[$p:lk] = 14991                          (: 'gt' '#' :)
          or $state[$p:lk] = 14992                          (: 'idiv' '#' :)
          or $state[$p:lk] = 14994                          (: 'import' '#' :)
          or $state[$p:lk] = 14999                          (: 'insert' '#' :)
          or $state[$p:lk] = 15000                          (: 'instance' '#' :)
          or $state[$p:lk] = 15001                          (: 'intersect' '#' :)
          or $state[$p:lk] = 15002                          (: 'into' '#' :)
          or $state[$p:lk] = 15003                          (: 'is' '#' :)
          or $state[$p:lk] = 15006                          (: 'last' '#' :)
          or $state[$p:lk] = 15008                          (: 'le' '#' :)
          or $state[$p:lk] = 15010                          (: 'let' '#' :)
          or $state[$p:lk] = 15013                          (: 'lt' '#' :)
          or $state[$p:lk] = 15015                          (: 'mod' '#' :)
          or $state[$p:lk] = 15016                          (: 'modify' '#' :)
          or $state[$p:lk] = 15017                          (: 'module' '#' :)
          or $state[$p:lk] = 15019                          (: 'namespace' '#' :)
          or $state[$p:lk] = 15021                          (: 'ne' '#' :)
          or $state[$p:lk] = 15031                          (: 'only' '#' :)
          or $state[$p:lk] = 15033                          (: 'or' '#' :)
          or $state[$p:lk] = 15034                          (: 'order' '#' :)
          or $state[$p:lk] = 15035                          (: 'ordered' '#' :)
          or $state[$p:lk] = 15038                          (: 'paragraphs' '#' :)
          or $state[$p:lk] = 15039                          (: 'parent' '#' :)
          or $state[$p:lk] = 15044                          (: 'preceding' '#' :)
          or $state[$p:lk] = 15045                          (: 'preceding-sibling' '#' :)
          or $state[$p:lk] = 15048                          (: 'private' '#' :)
          or $state[$p:lk] = 15049                          (: 'processing-instruction' '#' :)
          or $state[$p:lk] = 15050                          (: 'property' '#' :)
          or $state[$p:lk] = 15052                          (: 'rename' '#' :)
          or $state[$p:lk] = 15053                          (: 'replace' '#' :)
          or $state[$p:lk] = 15054                          (: 'return' '#' :)
          or $state[$p:lk] = 15057                          (: 'satisfies' '#' :)
          or $state[$p:lk] = 15061                          (: 'self' '#' :)
          or $state[$p:lk] = 15064                          (: 'sentences' '#' :)
          or $state[$p:lk] = 15067                          (: 'some' '#' :)
          or $state[$p:lk] = 15068                          (: 'stable' '#' :)
          or $state[$p:lk] = 15069                          (: 'start' '#' :)
          or $state[$p:lk] = 15076                          (: 'text' '#' :)
          or $state[$p:lk] = 15079                          (: 'times' '#' :)
          or $state[$p:lk] = 15080                          (: 'to' '#' :)
          or $state[$p:lk] = 15081                          (: 'treat' '#' :)
          or $state[$p:lk] = 15082                          (: 'try' '#' :)
          or $state[$p:lk] = 15086                          (: 'union' '#' :)
          or $state[$p:lk] = 15087                          (: 'unordered' '#' :)
          or $state[$p:lk] = 15090                          (: 'validate' '#' :)
          or $state[$p:lk] = 15096                          (: 'where' '#' :)
          or $state[$p:lk] = 15099                          (: 'with' '#' :)
          or $state[$p:lk] = 15102                          (: 'words' '#' :)
          or $state[$p:lk] = 15103) then                    (: 'xquery' '#' :)
      let $state := p:try-FunctionItemExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-Constructor($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production PostfixExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PostfixExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(214, $input, $state)        (: EOF | S^WS | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
    return
      if ($state[$p:l1] != 34                               (: '(' :)
      and $state[$p:l1] != 68) then                         (: '[' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 68) then                      (: '[' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-Predicate($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:whitespace($input, $state)
            let $state := p:parse-ArgumentList($input, $state)
            return $state
        return p:parse-PostfixExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production PostfixExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-PostfixExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(214, $input, $state)        (: EOF | S^WS | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
    return
      if ($state[$p:l1] != 34                               (: '(' :)
      and $state[$p:l1] != 68) then                         (: '[' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 68) then                      (: '[' :)
            let $state := p:try-Predicate($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:try-ArgumentList($input, $state)
            return $state
        return p:try-PostfixExpr-1($input, $state)
};

(:~
 : Parse PostfixExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PostfixExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-PrimaryExpr($input, $state)
  let $state := p:parse-PostfixExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PostfixExpr", $count, $begin, $end)
};

(:~
 : Try parsing PostfixExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-PostfixExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-PrimaryExpr($input, $state)
  let $state := p:try-PostfixExpr-1($input, $state)
  return $state
};

(:~
 : Parse StepExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StepExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 81) then                            (: 'attribute' :)
      let $state := p:lookahead2W(251, $input, $state)      (: EOF | URIQualifiedName | QName^Token | S^WS | '!' |
                                                               '!=' | '#' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' |
                                                               '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:lk] = 44625) then                     (: 'attribute' 'case' :)
          let $state := p:lookahead3W(248, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 47185) then                (: 'attribute' 'collation' :)
          let $state := p:lookahead3W(84, $input, $state)   (: URILiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 48721) then                (: 'attribute' 'contains' :)
          let $state := p:lookahead3W(128, $input, $state)  (: S^WS | ('(' ':') | 'text' | '{' :)
          return $state
        else if ($state[$p:lk] = 53329) then                (: 'attribute' 'default' :)
          let $state := p:lookahead3W(133, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 60497) then                (: 'attribute' 'empty' :)
          let $state := p:lookahead3W(144, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 67153) then                (: 'attribute' 'for' :)
          let $state := p:lookahead3W(150, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] = 77905) then                (: 'attribute' 'instance' :)
          let $state := p:lookahead3W(121, $input, $state)  (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 93777) then                (: 'attribute' 'only' :)
          let $state := p:lookahead3W(109, $input, $state)  (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] = 112721) then               (: 'attribute' 'stable' :)
          let $state := p:lookahead3W(122, $input, $state)  (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 118353) then               (: 'attribute' 'times' :)
          let $state := p:lookahead3W(192, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'return' | 'same' | 'satisfies' | 'stable' |
                                                               'start' | 'using' | 'weight' | 'where' | 'window' |
                                                               'with' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = 40529                      (: 'attribute' 'descending' :)
              or $state[$p:lk] = 55377) then                (: 'attribute' 'descending' :)
          let $state := p:lookahead3W(175, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = 51281                      (: 'attribute' 'let' :)
              or $state[$p:lk] = 83025) then                (: 'attribute' 'let' :)
          let $state := p:lookahead3W(89, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 62033                      (: 'attribute' 'start' :)
              or $state[$p:lk] = 113233) then               (: 'attribute' 'start' :)
          let $state := p:lookahead3W(163, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = 72273                      (: 'attribute' 'order' :)
              or $state[$p:lk] = 95313) then                (: 'attribute' 'order' :)
          let $state := p:lookahead3W(104, $input, $state)  (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 45137                      (: 'attribute' 'castable' :)
              or $state[$p:lk] = 45649                      (: 'attribute' 'treat' :)
              or $state[$p:lk] = 119377) then               (: 'attribute' 'treat' :)
          let $state := p:lookahead3W(101, $input, $state)  (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 97361                      (: 'attribute' 'sentences' :)
              or $state[$p:lk] = 110673                     (: 'attribute' 'words' :)
              or $state[$p:lk] = 130129) then               (: 'attribute' 'words' :)
          let $state := p:lookahead3W(187, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'modify' | 'ne' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'return' | 'same' |
                                                               'satisfies' | 'stable' | 'start' | 'where' | 'window' |
                                                               'with' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = 36433                      (: 'attribute' 'and' :)
              or $state[$p:lk] = 38993                      (: 'attribute' 'as' :)
              or $state[$p:lk] = 40017                      (: 'attribute' 'before' :)
              or $state[$p:lk] = 42577                      (: 'attribute' 'div' :)
              or $state[$p:lk] = 57937                      (: 'attribute' 'else' :)
              or $state[$p:lk] = 59985                      (: 'attribute' 'eq' :)
              or $state[$p:lk] = 63057                      (: 'attribute' 'except' :)
              or $state[$p:lk] = 64593                      (: 'attribute' 'ge' :)
              or $state[$p:lk] = 71249                      (: 'attribute' 'gt' :)
              or $state[$p:lk] = 73297                      (: 'attribute' 'idiv' :)
              or $state[$p:lk] = 73809                      (: 'attribute' 'intersect' :)
              or $state[$p:lk] = 78417                      (: 'attribute' 'into' :)
              or $state[$p:lk] = 78929                      (: 'attribute' 'is' :)
              or $state[$p:lk] = 79441                      (: 'attribute' 'le' :)
              or $state[$p:lk] = 82001                      (: 'attribute' 'lt' :)
              or $state[$p:lk] = 84561                      (: 'attribute' 'mod' :)
              or $state[$p:lk] = 85585                      (: 'attribute' 'modify' :)
              or $state[$p:lk] = 86097                      (: 'attribute' 'ne' :)
              or $state[$p:lk] = 88657                      (: 'attribute' 'or' :)
              or $state[$p:lk] = 94801                      (: 'attribute' 'return' :)
              or $state[$p:lk] = 105553                     (: 'attribute' 'satisfies' :)
              or $state[$p:lk] = 107089                     (: 'attribute' 'to' :)
              or $state[$p:lk] = 118865                     (: 'attribute' 'union' :)
              or $state[$p:lk] = 121937                     (: 'attribute' 'where' :)
              or $state[$p:lk] = 127057                     (: 'attribute' 'with' :)
              or $state[$p:lk] = 128593) then               (: 'attribute' 'with' :)
          let $state := p:lookahead3W(245, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'element' :)
      let $state := p:lookahead2W(250, $input, $state)      (: EOF | URIQualifiedName | QName^Token | S^WS | '!' |
                                                               '!=' | '#' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' |
                                                               '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:lk] = 44660) then                     (: 'element' 'case' :)
          let $state := p:lookahead3W(248, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 47220) then                (: 'element' 'collation' :)
          let $state := p:lookahead3W(84, $input, $state)   (: URILiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 48756) then                (: 'element' 'contains' :)
          let $state := p:lookahead3W(128, $input, $state)  (: S^WS | ('(' ':') | 'text' | '{' :)
          return $state
        else if ($state[$p:lk] = 53364) then                (: 'element' 'default' :)
          let $state := p:lookahead3W(133, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 60532) then                (: 'element' 'empty' :)
          let $state := p:lookahead3W(144, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 67188) then                (: 'element' 'for' :)
          let $state := p:lookahead3W(150, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] = 77940) then                (: 'element' 'instance' :)
          let $state := p:lookahead3W(121, $input, $state)  (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 93812) then                (: 'element' 'only' :)
          let $state := p:lookahead3W(109, $input, $state)  (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] = 112756) then               (: 'element' 'stable' :)
          let $state := p:lookahead3W(122, $input, $state)  (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 118388) then               (: 'element' 'times' :)
          let $state := p:lookahead3W(192, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'return' | 'same' | 'satisfies' | 'stable' |
                                                               'start' | 'using' | 'weight' | 'where' | 'window' |
                                                               'with' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = 40564                      (: 'element' 'descending' :)
              or $state[$p:lk] = 55412) then                (: 'element' 'descending' :)
          let $state := p:lookahead3W(175, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = 51316                      (: 'element' 'let' :)
              or $state[$p:lk] = 83060) then                (: 'element' 'let' :)
          let $state := p:lookahead3W(89, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 62068                      (: 'element' 'start' :)
              or $state[$p:lk] = 113268) then               (: 'element' 'start' :)
          let $state := p:lookahead3W(163, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = 72308                      (: 'element' 'order' :)
              or $state[$p:lk] = 95348) then                (: 'element' 'order' :)
          let $state := p:lookahead3W(104, $input, $state)  (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 45172                      (: 'element' 'castable' :)
              or $state[$p:lk] = 45684                      (: 'element' 'treat' :)
              or $state[$p:lk] = 119412) then               (: 'element' 'treat' :)
          let $state := p:lookahead3W(101, $input, $state)  (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 97396                      (: 'element' 'sentences' :)
              or $state[$p:lk] = 110708                     (: 'element' 'words' :)
              or $state[$p:lk] = 130164) then               (: 'element' 'words' :)
          let $state := p:lookahead3W(187, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'modify' | 'ne' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'return' | 'same' |
                                                               'satisfies' | 'stable' | 'start' | 'where' | 'window' |
                                                               'with' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = 36468                      (: 'element' 'and' :)
              or $state[$p:lk] = 39028                      (: 'element' 'as' :)
              or $state[$p:lk] = 40052                      (: 'element' 'before' :)
              or $state[$p:lk] = 42612                      (: 'element' 'div' :)
              or $state[$p:lk] = 57972                      (: 'element' 'else' :)
              or $state[$p:lk] = 60020                      (: 'element' 'eq' :)
              or $state[$p:lk] = 63092                      (: 'element' 'except' :)
              or $state[$p:lk] = 64628                      (: 'element' 'ge' :)
              or $state[$p:lk] = 71284                      (: 'element' 'gt' :)
              or $state[$p:lk] = 73332                      (: 'element' 'idiv' :)
              or $state[$p:lk] = 73844                      (: 'element' 'intersect' :)
              or $state[$p:lk] = 78452                      (: 'element' 'into' :)
              or $state[$p:lk] = 78964                      (: 'element' 'is' :)
              or $state[$p:lk] = 79476                      (: 'element' 'le' :)
              or $state[$p:lk] = 82036                      (: 'element' 'lt' :)
              or $state[$p:lk] = 84596                      (: 'element' 'mod' :)
              or $state[$p:lk] = 85620                      (: 'element' 'modify' :)
              or $state[$p:lk] = 86132                      (: 'element' 'ne' :)
              or $state[$p:lk] = 88692                      (: 'element' 'or' :)
              or $state[$p:lk] = 94836                      (: 'element' 'return' :)
              or $state[$p:lk] = 105588                     (: 'element' 'satisfies' :)
              or $state[$p:lk] = 107124                     (: 'element' 'to' :)
              or $state[$p:lk] = 118900                     (: 'element' 'union' :)
              or $state[$p:lk] = 121972                     (: 'element' 'where' :)
              or $state[$p:lk] = 127092                     (: 'element' 'with' :)
              or $state[$p:lk] = 128628) then               (: 'element' 'with' :)
          let $state := p:lookahead3W(245, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 171) then                      (: 'namespace' :)
      let $state := p:lookahead2W(224, $input, $state)      (: EOF | NCName^Token | S^WS | '!' | '!=' | '#' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' | '//' |
                                                               '::' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'treat' | 'try' |
                                                               'union' | 'where' | 'with' | 'words' | '{' | '|' | '||' |
                                                               '}' :)
      let $state :=
        if ($state[$p:lk] = 44715) then                     (: 'namespace' 'case' :)
          let $state := p:lookahead3W(248, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 47275) then                (: 'namespace' 'collation' :)
          let $state := p:lookahead3W(84, $input, $state)   (: URILiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 48811) then                (: 'namespace' 'contains' :)
          let $state := p:lookahead3W(128, $input, $state)  (: S^WS | ('(' ':') | 'text' | '{' :)
          return $state
        else if ($state[$p:lk] = 53419) then                (: 'namespace' 'default' :)
          let $state := p:lookahead3W(133, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 60587) then                (: 'namespace' 'empty' :)
          let $state := p:lookahead3W(144, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 67243) then                (: 'namespace' 'for' :)
          let $state := p:lookahead3W(150, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] = 77995) then                (: 'namespace' 'instance' :)
          let $state := p:lookahead3W(121, $input, $state)  (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 93867) then                (: 'namespace' 'only' :)
          let $state := p:lookahead3W(109, $input, $state)  (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] = 112811) then               (: 'namespace' 'stable' :)
          let $state := p:lookahead3W(122, $input, $state)  (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 118443) then               (: 'namespace' 'times' :)
          let $state := p:lookahead3W(192, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'return' | 'same' | 'satisfies' | 'stable' |
                                                               'start' | 'using' | 'weight' | 'where' | 'window' |
                                                               'with' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = 40619                      (: 'namespace' 'descending' :)
              or $state[$p:lk] = 55467) then                (: 'namespace' 'descending' :)
          let $state := p:lookahead3W(175, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = 51371                      (: 'namespace' 'let' :)
              or $state[$p:lk] = 83115) then                (: 'namespace' 'let' :)
          let $state := p:lookahead3W(89, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 62123                      (: 'namespace' 'start' :)
              or $state[$p:lk] = 113323) then               (: 'namespace' 'start' :)
          let $state := p:lookahead3W(163, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = 72363                      (: 'namespace' 'order' :)
              or $state[$p:lk] = 95403) then                (: 'namespace' 'order' :)
          let $state := p:lookahead3W(104, $input, $state)  (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 45227                      (: 'namespace' 'castable' :)
              or $state[$p:lk] = 45739                      (: 'namespace' 'treat' :)
              or $state[$p:lk] = 119467) then               (: 'namespace' 'treat' :)
          let $state := p:lookahead3W(101, $input, $state)  (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 97451                      (: 'namespace' 'sentences' :)
              or $state[$p:lk] = 110763                     (: 'namespace' 'words' :)
              or $state[$p:lk] = 130219) then               (: 'namespace' 'words' :)
          let $state := p:lookahead3W(187, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'modify' | 'ne' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'return' | 'same' |
                                                               'satisfies' | 'stable' | 'start' | 'where' | 'window' |
                                                               'with' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = 36523                      (: 'namespace' 'and' :)
              or $state[$p:lk] = 39083                      (: 'namespace' 'as' :)
              or $state[$p:lk] = 40107                      (: 'namespace' 'before' :)
              or $state[$p:lk] = 42667                      (: 'namespace' 'div' :)
              or $state[$p:lk] = 58027                      (: 'namespace' 'else' :)
              or $state[$p:lk] = 60075                      (: 'namespace' 'eq' :)
              or $state[$p:lk] = 63147                      (: 'namespace' 'except' :)
              or $state[$p:lk] = 64683                      (: 'namespace' 'ge' :)
              or $state[$p:lk] = 71339                      (: 'namespace' 'gt' :)
              or $state[$p:lk] = 73387                      (: 'namespace' 'idiv' :)
              or $state[$p:lk] = 73899                      (: 'namespace' 'intersect' :)
              or $state[$p:lk] = 78507                      (: 'namespace' 'into' :)
              or $state[$p:lk] = 79019                      (: 'namespace' 'is' :)
              or $state[$p:lk] = 79531                      (: 'namespace' 'le' :)
              or $state[$p:lk] = 82091                      (: 'namespace' 'lt' :)
              or $state[$p:lk] = 84651                      (: 'namespace' 'mod' :)
              or $state[$p:lk] = 85675                      (: 'namespace' 'modify' :)
              or $state[$p:lk] = 86187                      (: 'namespace' 'ne' :)
              or $state[$p:lk] = 88747                      (: 'namespace' 'or' :)
              or $state[$p:lk] = 94891                      (: 'namespace' 'return' :)
              or $state[$p:lk] = 105643                     (: 'namespace' 'satisfies' :)
              or $state[$p:lk] = 107179                     (: 'namespace' 'to' :)
              or $state[$p:lk] = 118955                     (: 'namespace' 'union' :)
              or $state[$p:lk] = 122027                     (: 'namespace' 'where' :)
              or $state[$p:lk] = 127147                     (: 'namespace' 'with' :)
              or $state[$p:lk] = 128683) then               (: 'namespace' 'with' :)
          let $state := p:lookahead3W(245, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 201) then                      (: 'processing-instruction' :)
      let $state := p:lookahead2W(223, $input, $state)      (: EOF | NCName^Token | S^WS | '!' | '!=' | '#' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' | '//' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'treat' | 'try' | 'union' |
                                                               'where' | 'with' | 'words' | '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:lk] = 44745) then                     (: 'processing-instruction' 'case' :)
          let $state := p:lookahead3W(248, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 47305) then                (: 'processing-instruction' 'collation' :)
          let $state := p:lookahead3W(84, $input, $state)   (: URILiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 48841) then                (: 'processing-instruction' 'contains' :)
          let $state := p:lookahead3W(128, $input, $state)  (: S^WS | ('(' ':') | 'text' | '{' :)
          return $state
        else if ($state[$p:lk] = 53449) then                (: 'processing-instruction' 'default' :)
          let $state := p:lookahead3W(133, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 60617) then                (: 'processing-instruction' 'empty' :)
          let $state := p:lookahead3W(144, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 67273) then                (: 'processing-instruction' 'for' :)
          let $state := p:lookahead3W(150, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] = 78025) then                (: 'processing-instruction' 'instance' :)
          let $state := p:lookahead3W(121, $input, $state)  (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 93897) then                (: 'processing-instruction' 'only' :)
          let $state := p:lookahead3W(109, $input, $state)  (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] = 112841) then               (: 'processing-instruction' 'stable' :)
          let $state := p:lookahead3W(122, $input, $state)  (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 118473) then               (: 'processing-instruction' 'times' :)
          let $state := p:lookahead3W(192, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'return' | 'same' | 'satisfies' | 'stable' |
                                                               'start' | 'using' | 'weight' | 'where' | 'window' |
                                                               'with' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = 40649                      (: 'processing-instruction' 'descending' :)
              or $state[$p:lk] = 55497) then                (: 'processing-instruction' 'descending' :)
          let $state := p:lookahead3W(175, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = 51401                      (: 'processing-instruction' 'let' :)
              or $state[$p:lk] = 83145) then                (: 'processing-instruction' 'let' :)
          let $state := p:lookahead3W(89, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 62153                      (: 'processing-instruction' 'start' :)
              or $state[$p:lk] = 113353) then               (: 'processing-instruction' 'start' :)
          let $state := p:lookahead3W(163, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = 72393                      (: 'processing-instruction' 'order' :)
              or $state[$p:lk] = 95433) then                (: 'processing-instruction' 'order' :)
          let $state := p:lookahead3W(104, $input, $state)  (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 45257                      (: 'processing-instruction' 'castable' :)
              or $state[$p:lk] = 45769                      (: 'processing-instruction' 'treat' :)
              or $state[$p:lk] = 119497) then               (: 'processing-instruction' 'treat' :)
          let $state := p:lookahead3W(101, $input, $state)  (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 97481                      (: 'processing-instruction' 'sentences' :)
              or $state[$p:lk] = 110793                     (: 'processing-instruction' 'words' :)
              or $state[$p:lk] = 130249) then               (: 'processing-instruction' 'words' :)
          let $state := p:lookahead3W(187, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'modify' | 'ne' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'return' | 'same' |
                                                               'satisfies' | 'stable' | 'start' | 'where' | 'window' |
                                                               'with' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = 36553                      (: 'processing-instruction' 'and' :)
              or $state[$p:lk] = 39113                      (: 'processing-instruction' 'as' :)
              or $state[$p:lk] = 40137                      (: 'processing-instruction' 'before' :)
              or $state[$p:lk] = 42697                      (: 'processing-instruction' 'div' :)
              or $state[$p:lk] = 58057                      (: 'processing-instruction' 'else' :)
              or $state[$p:lk] = 60105                      (: 'processing-instruction' 'eq' :)
              or $state[$p:lk] = 63177                      (: 'processing-instruction' 'except' :)
              or $state[$p:lk] = 64713                      (: 'processing-instruction' 'ge' :)
              or $state[$p:lk] = 71369                      (: 'processing-instruction' 'gt' :)
              or $state[$p:lk] = 73417                      (: 'processing-instruction' 'idiv' :)
              or $state[$p:lk] = 73929                      (: 'processing-instruction' 'intersect' :)
              or $state[$p:lk] = 78537                      (: 'processing-instruction' 'into' :)
              or $state[$p:lk] = 79049                      (: 'processing-instruction' 'is' :)
              or $state[$p:lk] = 79561                      (: 'processing-instruction' 'le' :)
              or $state[$p:lk] = 82121                      (: 'processing-instruction' 'lt' :)
              or $state[$p:lk] = 84681                      (: 'processing-instruction' 'mod' :)
              or $state[$p:lk] = 85705                      (: 'processing-instruction' 'modify' :)
              or $state[$p:lk] = 86217                      (: 'processing-instruction' 'ne' :)
              or $state[$p:lk] = 88777                      (: 'processing-instruction' 'or' :)
              or $state[$p:lk] = 94921                      (: 'processing-instruction' 'return' :)
              or $state[$p:lk] = 105673                     (: 'processing-instruction' 'satisfies' :)
              or $state[$p:lk] = 107209                     (: 'processing-instruction' 'to' :)
              or $state[$p:lk] = 118985                     (: 'processing-instruction' 'union' :)
              or $state[$p:lk] = 122057                     (: 'processing-instruction' 'where' :)
              or $state[$p:lk] = 127177                     (: 'processing-instruction' 'with' :)
              or $state[$p:lk] = 128713) then               (: 'processing-instruction' 'with' :)
          let $state := p:lookahead3W(245, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 119                            (: 'if' :)
          or $state[$p:l1] = 145                            (: 'item' :)
          or $state[$p:l1] = 156                            (: 'switch' :)
          or $state[$p:l1] = 227                            (: 'typeswitch' :)
          or $state[$p:l1] = 237) then                      (: 'typeswitch' :)
      let $state := p:lookahead2W(213, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 84                             (: 'comment' :)
          or $state[$p:l1] = 93                             (: 'document' :)
          or $state[$p:l1] = 114                            (: 'ordered' :)
          or $state[$p:l1] = 187                            (: 'text' :)
          or $state[$p:l1] = 228                            (: 'unordered' :)
          or $state[$p:l1] = 239) then                      (: 'unordered' :)
      let $state := p:lookahead2W(221, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '{' |
                                                               '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 74                             (: 'ancestor-or-self' :)
          or $state[$p:l1] = 75                             (: 'child' :)
          or $state[$p:l1] = 91                             (: 'descendant' :)
          or $state[$p:l1] = 106                            (: 'descendant-or-self' :)
          or $state[$p:l1] = 107                            (: 'following' :)
          or $state[$p:l1] = 129                            (: 'following-sibling' :)
          or $state[$p:l1] = 130                            (: 'parent' :)
          or $state[$p:l1] = 191                            (: 'preceding' :)
          or $state[$p:l1] = 196                            (: 'preceding-sibling' :)
          or $state[$p:l1] = 197                            (: 'property' :)
          or $state[$p:l1] = 202                            (: 'self' :)
          or $state[$p:l1] = 213) then                      (: 'self' :)
      let $state := p:lookahead2W(220, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'treat' | 'union' | 'where' |
                                                               'with' | 'words' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 7                              (: QName^Token :)
          or $state[$p:l1] = 22                             (: 'after' :)
          or $state[$p:l1] = 71                             (: 'and' :)
          or $state[$p:l1] = 76                             (: 'as' :)
          or $state[$p:l1] = 78                             (: 'ascending' :)
          or $state[$p:l1] = 79                             (: 'before' :)
          or $state[$p:l1] = 83                             (: 'case' :)
          or $state[$p:l1] = 87                             (: 'cast' :)
          or $state[$p:l1] = 88                             (: 'castable' :)
          or $state[$p:l1] = 89                             (: 'catch' :)
          or $state[$p:l1] = 90                             (: 'collation' :)
          or $state[$p:l1] = 92                             (: 'contains' :)
          or $state[$p:l1] = 95                             (: 'copy' :)
          or $state[$p:l1] = 98                             (: 'count' :)
          or $state[$p:l1] = 100                            (: 'declare' :)
          or $state[$p:l1] = 103                            (: 'default' :)
          or $state[$p:l1] = 104                            (: 'delete' :)
          or $state[$p:l1] = 105                            (: 'descending' :)
          or $state[$p:l1] = 108                            (: 'div' :)
          or $state[$p:l1] = 113                            (: 'document-node' :)
          or $state[$p:l1] = 115                            (: 'else' :)
          or $state[$p:l1] = 117                            (: 'empty' :)
          or $state[$p:l1] = 118                            (: 'end' :)
          or $state[$p:l1] = 121                            (: 'eq' :)
          or $state[$p:l1] = 123                            (: 'every' :)
          or $state[$p:l1] = 124                            (: 'except' :)
          or $state[$p:l1] = 126                            (: 'first' :)
          or $state[$p:l1] = 128                            (: 'for' :)
          or $state[$p:l1] = 131                            (: 'function' :)
          or $state[$p:l1] = 138                            (: 'ge' :)
          or $state[$p:l1] = 139                            (: 'group' :)
          or $state[$p:l1] = 141                            (: 'gt' :)
          or $state[$p:l1] = 143                            (: 'idiv' :)
          or $state[$p:l1] = 144                            (: 'import' :)
          or $state[$p:l1] = 146                            (: 'insert' :)
          or $state[$p:l1] = 151                            (: 'instance' :)
          or $state[$p:l1] = 152                            (: 'intersect' :)
          or $state[$p:l1] = 153                            (: 'into' :)
          or $state[$p:l1] = 154                            (: 'is' :)
          or $state[$p:l1] = 155                            (: 'last' :)
          or $state[$p:l1] = 158                            (: 'le' :)
          or $state[$p:l1] = 160                            (: 'let' :)
          or $state[$p:l1] = 162                            (: 'lt' :)
          or $state[$p:l1] = 165                            (: 'mod' :)
          or $state[$p:l1] = 167                            (: 'modify' :)
          or $state[$p:l1] = 168                            (: 'module' :)
          or $state[$p:l1] = 169                            (: 'namespace-node' :)
          or $state[$p:l1] = 172                            (: 'ne' :)
          or $state[$p:l1] = 173                            (: 'node' :)
          or $state[$p:l1] = 178                            (: 'only' :)
          or $state[$p:l1] = 183                            (: 'or' :)
          or $state[$p:l1] = 185                            (: 'order' :)
          or $state[$p:l1] = 186                            (: 'paragraphs' :)
          or $state[$p:l1] = 190                            (: 'private' :)
          or $state[$p:l1] = 200                            (: 'rename' :)
          or $state[$p:l1] = 204                            (: 'replace' :)
          or $state[$p:l1] = 205                            (: 'return' :)
          or $state[$p:l1] = 206                            (: 'satisfies' :)
          or $state[$p:l1] = 209                            (: 'schema-attribute' :)
          or $state[$p:l1] = 211                            (: 'schema-element' :)
          or $state[$p:l1] = 212                            (: 'sentences' :)
          or $state[$p:l1] = 216                            (: 'some' :)
          or $state[$p:l1] = 219                            (: 'stable' :)
          or $state[$p:l1] = 220                            (: 'start' :)
          or $state[$p:l1] = 221                            (: 'times' :)
          or $state[$p:l1] = 231                            (: 'to' :)
          or $state[$p:l1] = 232                            (: 'treat' :)
          or $state[$p:l1] = 233                            (: 'try' :)
          or $state[$p:l1] = 234                            (: 'union' :)
          or $state[$p:l1] = 238                            (: 'validate' :)
          or $state[$p:l1] = 242                            (: 'where' :)
          or $state[$p:l1] = 248                            (: 'with' :)
          or $state[$p:l1] = 251                            (: 'words' :)
          or $state[$p:l1] = 254                            (: 'xquery' :)
          or $state[$p:l1] = 255) then                      (: 'xquery' :)
      let $state := p:lookahead2W(217, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 9                                   (: IntegerLiteral :)
     or $state[$p:lk] = 10                                  (: DecimalLiteral :)
     or $state[$p:lk] = 11                                  (: DoubleLiteral :)
     or $state[$p:lk] = 12                                  (: StringLiteral :)
     or $state[$p:lk] = 31                                  (: '$' :)
     or $state[$p:lk] = 34                                  (: '(' :)
     or $state[$p:lk] = 44                                  (: '.' :)
     or $state[$p:lk] = 53                                  (: '<' :)
     or $state[$p:lk] = 54                                  (: '<!--' :)
     or $state[$p:lk] = 59                                  (: '<?' :)
     or $state[$p:lk] = 3665                                (: 'attribute' URIQualifiedName :)
     or $state[$p:lk] = 3700                                (: 'element' URIQualifiedName :)
     or $state[$p:lk] = 10923                               (: 'namespace' NCName^Token :)
     or $state[$p:lk] = 10953                               (: 'processing-instruction' NCName^Token :)
     or $state[$p:lk] = 11345                               (: 'attribute' QName^Token :)
     or $state[$p:lk] = 11380                               (: 'element' QName^Token :)
     or $state[$p:lk] = 14855                               (: URIQualifiedName '#' :)
     or $state[$p:lk] = 14870                               (: QName^Token '#' :)
     or $state[$p:lk] = 14919                               (: 'after' '#' :)
     or $state[$p:lk] = 14922                               (: 'ancestor' '#' :)
     or $state[$p:lk] = 14923                               (: 'ancestor-or-self' '#' :)
     or $state[$p:lk] = 14924                               (: 'and' '#' :)
     or $state[$p:lk] = 14926                               (: 'as' '#' :)
     or $state[$p:lk] = 14927                               (: 'ascending' '#' :)
     or $state[$p:lk] = 14929                               (: 'attribute' '#' :)
     or $state[$p:lk] = 14931                               (: 'before' '#' :)
     or $state[$p:lk] = 14932                               (: 'binary' '#' :)
     or $state[$p:lk] = 14935                               (: 'case' '#' :)
     or $state[$p:lk] = 14936                               (: 'cast' '#' :)
     or $state[$p:lk] = 14937                               (: 'castable' '#' :)
     or $state[$p:lk] = 14938                               (: 'catch' '#' :)
     or $state[$p:lk] = 14939                               (: 'child' '#' :)
     or $state[$p:lk] = 14940                               (: 'collation' '#' :)
     or $state[$p:lk] = 14941                               (: 'comment' '#' :)
     or $state[$p:lk] = 14943                               (: 'contains' '#' :)
     or $state[$p:lk] = 14946                               (: 'copy' '#' :)
     or $state[$p:lk] = 14948                               (: 'count' '#' :)
     or $state[$p:lk] = 14951                               (: 'declare' '#' :)
     or $state[$p:lk] = 14952                               (: 'default' '#' :)
     or $state[$p:lk] = 14953                               (: 'delete' '#' :)
     or $state[$p:lk] = 14954                               (: 'descendant' '#' :)
     or $state[$p:lk] = 14955                               (: 'descendant-or-self' '#' :)
     or $state[$p:lk] = 14956                               (: 'descending' '#' :)
     or $state[$p:lk] = 14961                               (: 'div' '#' :)
     or $state[$p:lk] = 14962                               (: 'document' '#' :)
     or $state[$p:lk] = 14963                               (: 'document-node' '#' :)
     or $state[$p:lk] = 14964                               (: 'element' '#' :)
     or $state[$p:lk] = 14965                               (: 'else' '#' :)
     or $state[$p:lk] = 14966                               (: 'empty' '#' :)
     or $state[$p:lk] = 14967                               (: 'empty-sequence' '#' :)
     or $state[$p:lk] = 14969                               (: 'end' '#' :)
     or $state[$p:lk] = 14971                               (: 'eq' '#' :)
     or $state[$p:lk] = 14972                               (: 'every' '#' :)
     or $state[$p:lk] = 14974                               (: 'except' '#' :)
     or $state[$p:lk] = 14976                               (: 'first' '#' :)
     or $state[$p:lk] = 14977                               (: 'following' '#' :)
     or $state[$p:lk] = 14978                               (: 'following-sibling' '#' :)
     or $state[$p:lk] = 14979                               (: 'for' '#' :)
     or $state[$p:lk] = 14986                               (: 'function' '#' :)
     or $state[$p:lk] = 14987                               (: 'ge' '#' :)
     or $state[$p:lk] = 14989                               (: 'group' '#' :)
     or $state[$p:lk] = 14991                               (: 'gt' '#' :)
     or $state[$p:lk] = 14992                               (: 'idiv' '#' :)
     or $state[$p:lk] = 14993                               (: 'if' '#' :)
     or $state[$p:lk] = 14994                               (: 'import' '#' :)
     or $state[$p:lk] = 14999                               (: 'insert' '#' :)
     or $state[$p:lk] = 15000                               (: 'instance' '#' :)
     or $state[$p:lk] = 15001                               (: 'intersect' '#' :)
     or $state[$p:lk] = 15002                               (: 'into' '#' :)
     or $state[$p:lk] = 15003                               (: 'is' '#' :)
     or $state[$p:lk] = 15004                               (: 'item' '#' :)
     or $state[$p:lk] = 15006                               (: 'last' '#' :)
     or $state[$p:lk] = 15008                               (: 'le' '#' :)
     or $state[$p:lk] = 15010                               (: 'let' '#' :)
     or $state[$p:lk] = 15013                               (: 'lt' '#' :)
     or $state[$p:lk] = 15015                               (: 'mod' '#' :)
     or $state[$p:lk] = 15016                               (: 'modify' '#' :)
     or $state[$p:lk] = 15017                               (: 'module' '#' :)
     or $state[$p:lk] = 15019                               (: 'namespace' '#' :)
     or $state[$p:lk] = 15020                               (: 'namespace-node' '#' :)
     or $state[$p:lk] = 15021                               (: 'ne' '#' :)
     or $state[$p:lk] = 15026                               (: 'node' '#' :)
     or $state[$p:lk] = 15031                               (: 'only' '#' :)
     or $state[$p:lk] = 15033                               (: 'or' '#' :)
     or $state[$p:lk] = 15034                               (: 'order' '#' :)
     or $state[$p:lk] = 15035                               (: 'ordered' '#' :)
     or $state[$p:lk] = 15038                               (: 'paragraphs' '#' :)
     or $state[$p:lk] = 15039                               (: 'parent' '#' :)
     or $state[$p:lk] = 15044                               (: 'preceding' '#' :)
     or $state[$p:lk] = 15045                               (: 'preceding-sibling' '#' :)
     or $state[$p:lk] = 15048                               (: 'private' '#' :)
     or $state[$p:lk] = 15049                               (: 'processing-instruction' '#' :)
     or $state[$p:lk] = 15050                               (: 'property' '#' :)
     or $state[$p:lk] = 15052                               (: 'rename' '#' :)
     or $state[$p:lk] = 15053                               (: 'replace' '#' :)
     or $state[$p:lk] = 15054                               (: 'return' '#' :)
     or $state[$p:lk] = 15057                               (: 'satisfies' '#' :)
     or $state[$p:lk] = 15059                               (: 'schema-attribute' '#' :)
     or $state[$p:lk] = 15060                               (: 'schema-element' '#' :)
     or $state[$p:lk] = 15061                               (: 'self' '#' :)
     or $state[$p:lk] = 15064                               (: 'sentences' '#' :)
     or $state[$p:lk] = 15067                               (: 'some' '#' :)
     or $state[$p:lk] = 15068                               (: 'stable' '#' :)
     or $state[$p:lk] = 15069                               (: 'start' '#' :)
     or $state[$p:lk] = 15075                               (: 'switch' '#' :)
     or $state[$p:lk] = 15076                               (: 'text' '#' :)
     or $state[$p:lk] = 15079                               (: 'times' '#' :)
     or $state[$p:lk] = 15080                               (: 'to' '#' :)
     or $state[$p:lk] = 15081                               (: 'treat' '#' :)
     or $state[$p:lk] = 15082                               (: 'try' '#' :)
     or $state[$p:lk] = 15085                               (: 'typeswitch' '#' :)
     or $state[$p:lk] = 15086                               (: 'union' '#' :)
     or $state[$p:lk] = 15087                               (: 'unordered' '#' :)
     or $state[$p:lk] = 15090                               (: 'validate' '#' :)
     or $state[$p:lk] = 15096                               (: 'where' '#' :)
     or $state[$p:lk] = 15099                               (: 'with' '#' :)
     or $state[$p:lk] = 15102                               (: 'words' '#' :)
     or $state[$p:lk] = 15103                               (: 'xquery' '#' :)
     or $state[$p:lk] = 17415                               (: URIQualifiedName '(' :)
     or $state[$p:lk] = 17430                               (: QName^Token '(' :)
     or $state[$p:lk] = 17479                               (: 'after' '(' :)
     or $state[$p:lk] = 17482                               (: 'ancestor' '(' :)
     or $state[$p:lk] = 17483                               (: 'ancestor-or-self' '(' :)
     or $state[$p:lk] = 17484                               (: 'and' '(' :)
     or $state[$p:lk] = 17486                               (: 'as' '(' :)
     or $state[$p:lk] = 17487                               (: 'ascending' '(' :)
     or $state[$p:lk] = 17491                               (: 'before' '(' :)
     or $state[$p:lk] = 17495                               (: 'case' '(' :)
     or $state[$p:lk] = 17496                               (: 'cast' '(' :)
     or $state[$p:lk] = 17497                               (: 'castable' '(' :)
     or $state[$p:lk] = 17498                               (: 'catch' '(' :)
     or $state[$p:lk] = 17499                               (: 'child' '(' :)
     or $state[$p:lk] = 17500                               (: 'collation' '(' :)
     or $state[$p:lk] = 17503                               (: 'contains' '(' :)
     or $state[$p:lk] = 17506                               (: 'copy' '(' :)
     or $state[$p:lk] = 17508                               (: 'count' '(' :)
     or $state[$p:lk] = 17511                               (: 'declare' '(' :)
     or $state[$p:lk] = 17512                               (: 'default' '(' :)
     or $state[$p:lk] = 17513                               (: 'delete' '(' :)
     or $state[$p:lk] = 17514                               (: 'descendant' '(' :)
     or $state[$p:lk] = 17515                               (: 'descendant-or-self' '(' :)
     or $state[$p:lk] = 17516                               (: 'descending' '(' :)
     or $state[$p:lk] = 17521                               (: 'div' '(' :)
     or $state[$p:lk] = 17522                               (: 'document' '(' :)
     or $state[$p:lk] = 17525                               (: 'else' '(' :)
     or $state[$p:lk] = 17526                               (: 'empty' '(' :)
     or $state[$p:lk] = 17529                               (: 'end' '(' :)
     or $state[$p:lk] = 17531                               (: 'eq' '(' :)
     or $state[$p:lk] = 17532                               (: 'every' '(' :)
     or $state[$p:lk] = 17534                               (: 'except' '(' :)
     or $state[$p:lk] = 17536                               (: 'first' '(' :)
     or $state[$p:lk] = 17537                               (: 'following' '(' :)
     or $state[$p:lk] = 17538                               (: 'following-sibling' '(' :)
     or $state[$p:lk] = 17539                               (: 'for' '(' :)
     or $state[$p:lk] = 17546                               (: 'function' '(' :)
     or $state[$p:lk] = 17547                               (: 'ge' '(' :)
     or $state[$p:lk] = 17549                               (: 'group' '(' :)
     or $state[$p:lk] = 17551                               (: 'gt' '(' :)
     or $state[$p:lk] = 17552                               (: 'idiv' '(' :)
     or $state[$p:lk] = 17554                               (: 'import' '(' :)
     or $state[$p:lk] = 17559                               (: 'insert' '(' :)
     or $state[$p:lk] = 17560                               (: 'instance' '(' :)
     or $state[$p:lk] = 17561                               (: 'intersect' '(' :)
     or $state[$p:lk] = 17562                               (: 'into' '(' :)
     or $state[$p:lk] = 17563                               (: 'is' '(' :)
     or $state[$p:lk] = 17566                               (: 'last' '(' :)
     or $state[$p:lk] = 17568                               (: 'le' '(' :)
     or $state[$p:lk] = 17570                               (: 'let' '(' :)
     or $state[$p:lk] = 17573                               (: 'lt' '(' :)
     or $state[$p:lk] = 17575                               (: 'mod' '(' :)
     or $state[$p:lk] = 17576                               (: 'modify' '(' :)
     or $state[$p:lk] = 17577                               (: 'module' '(' :)
     or $state[$p:lk] = 17579                               (: 'namespace' '(' :)
     or $state[$p:lk] = 17581                               (: 'ne' '(' :)
     or $state[$p:lk] = 17591                               (: 'only' '(' :)
     or $state[$p:lk] = 17593                               (: 'or' '(' :)
     or $state[$p:lk] = 17594                               (: 'order' '(' :)
     or $state[$p:lk] = 17595                               (: 'ordered' '(' :)
     or $state[$p:lk] = 17598                               (: 'paragraphs' '(' :)
     or $state[$p:lk] = 17599                               (: 'parent' '(' :)
     or $state[$p:lk] = 17604                               (: 'preceding' '(' :)
     or $state[$p:lk] = 17605                               (: 'preceding-sibling' '(' :)
     or $state[$p:lk] = 17608                               (: 'private' '(' :)
     or $state[$p:lk] = 17610                               (: 'property' '(' :)
     or $state[$p:lk] = 17612                               (: 'rename' '(' :)
     or $state[$p:lk] = 17613                               (: 'replace' '(' :)
     or $state[$p:lk] = 17614                               (: 'return' '(' :)
     or $state[$p:lk] = 17617                               (: 'satisfies' '(' :)
     or $state[$p:lk] = 17621                               (: 'self' '(' :)
     or $state[$p:lk] = 17624                               (: 'sentences' '(' :)
     or $state[$p:lk] = 17627                               (: 'some' '(' :)
     or $state[$p:lk] = 17628                               (: 'stable' '(' :)
     or $state[$p:lk] = 17629                               (: 'start' '(' :)
     or $state[$p:lk] = 17639                               (: 'times' '(' :)
     or $state[$p:lk] = 17640                               (: 'to' '(' :)
     or $state[$p:lk] = 17641                               (: 'treat' '(' :)
     or $state[$p:lk] = 17642                               (: 'try' '(' :)
     or $state[$p:lk] = 17646                               (: 'union' '(' :)
     or $state[$p:lk] = 17647                               (: 'unordered' '(' :)
     or $state[$p:lk] = 17650                               (: 'validate' '(' :)
     or $state[$p:lk] = 17656                               (: 'where' '(' :)
     or $state[$p:lk] = 17659                               (: 'with' '(' :)
     or $state[$p:lk] = 17662                               (: 'words' '(' :)
     or $state[$p:lk] = 17663                               (: 'xquery' '(' :)
     or $state[$p:lk] = 37969                               (: 'attribute' 'ancestor' :)
     or $state[$p:lk] = 38004                               (: 'element' 'ancestor' :)
     or $state[$p:lk] = 38481                               (: 'attribute' 'ancestor-or-self' :)
     or $state[$p:lk] = 38516                               (: 'element' 'ancestor-or-self' :)
     or $state[$p:lk] = 41553                               (: 'attribute' 'attribute' :)
     or $state[$p:lk] = 41588                               (: 'element' 'attribute' :)
     or $state[$p:lk] = 43089                               (: 'attribute' 'binary' :)
     or $state[$p:lk] = 43124                               (: 'element' 'binary' :)
     or $state[$p:lk] = 46161                               (: 'attribute' 'catch' :)
     or $state[$p:lk] = 46196                               (: 'element' 'catch' :)
     or $state[$p:lk] = 46673                               (: 'attribute' 'child' :)
     or $state[$p:lk] = 46708                               (: 'element' 'child' :)
     or $state[$p:lk] = 47697                               (: 'attribute' 'comment' :)
     or $state[$p:lk] = 47732                               (: 'element' 'comment' :)
     or $state[$p:lk] = 50257                               (: 'attribute' 'copy' :)
     or $state[$p:lk] = 50292                               (: 'element' 'copy' :)
     or $state[$p:lk] = 52817                               (: 'attribute' 'declare' :)
     or $state[$p:lk] = 52852                               (: 'element' 'declare' :)
     or $state[$p:lk] = 53841                               (: 'attribute' 'delete' :)
     or $state[$p:lk] = 53876                               (: 'element' 'delete' :)
     or $state[$p:lk] = 54353                               (: 'attribute' 'descendant' :)
     or $state[$p:lk] = 54388                               (: 'element' 'descendant' :)
     or $state[$p:lk] = 54865                               (: 'attribute' 'descendant-or-self' :)
     or $state[$p:lk] = 54900                               (: 'element' 'descendant-or-self' :)
     or $state[$p:lk] = 58449                               (: 'attribute' 'document' :)
     or $state[$p:lk] = 58484                               (: 'element' 'document' :)
     or $state[$p:lk] = 58961                               (: 'attribute' 'document-node' :)
     or $state[$p:lk] = 58996                               (: 'element' 'document-node' :)
     or $state[$p:lk] = 59473                               (: 'attribute' 'element' :)
     or $state[$p:lk] = 59508                               (: 'element' 'element' :)
     or $state[$p:lk] = 61009                               (: 'attribute' 'empty-sequence' :)
     or $state[$p:lk] = 61044                               (: 'element' 'empty-sequence' :)
     or $state[$p:lk] = 63569                               (: 'attribute' 'every' :)
     or $state[$p:lk] = 63604                               (: 'element' 'every' :)
     or $state[$p:lk] = 65617                               (: 'attribute' 'first' :)
     or $state[$p:lk] = 65652                               (: 'element' 'first' :)
     or $state[$p:lk] = 66129                               (: 'attribute' 'following' :)
     or $state[$p:lk] = 66164                               (: 'element' 'following' :)
     or $state[$p:lk] = 66641                               (: 'attribute' 'following-sibling' :)
     or $state[$p:lk] = 66676                               (: 'element' 'following-sibling' :)
     or $state[$p:lk] = 70737                               (: 'attribute' 'function' :)
     or $state[$p:lk] = 70772                               (: 'element' 'function' :)
     or $state[$p:lk] = 74321                               (: 'attribute' 'if' :)
     or $state[$p:lk] = 74356                               (: 'element' 'if' :)
     or $state[$p:lk] = 74833                               (: 'attribute' 'import' :)
     or $state[$p:lk] = 74868                               (: 'element' 'import' :)
     or $state[$p:lk] = 77393                               (: 'attribute' 'insert' :)
     or $state[$p:lk] = 77428                               (: 'element' 'insert' :)
     or $state[$p:lk] = 79953                               (: 'attribute' 'item' :)
     or $state[$p:lk] = 79988                               (: 'element' 'item' :)
     or $state[$p:lk] = 80977                               (: 'attribute' 'last' :)
     or $state[$p:lk] = 81012                               (: 'element' 'last' :)
     or $state[$p:lk] = 86609                               (: 'attribute' 'module' :)
     or $state[$p:lk] = 86644                               (: 'element' 'module' :)
     or $state[$p:lk] = 87633                               (: 'attribute' 'namespace' :)
     or $state[$p:lk] = 87668                               (: 'element' 'namespace' :)
     or $state[$p:lk] = 88145                               (: 'attribute' 'namespace-node' :)
     or $state[$p:lk] = 88180                               (: 'element' 'namespace-node' :)
     or $state[$p:lk] = 91217                               (: 'attribute' 'node' :)
     or $state[$p:lk] = 91252                               (: 'element' 'node' :)
     or $state[$p:lk] = 95825                               (: 'attribute' 'ordered' :)
     or $state[$p:lk] = 95860                               (: 'element' 'ordered' :)
     or $state[$p:lk] = 97873                               (: 'attribute' 'parent' :)
     or $state[$p:lk] = 97908                               (: 'element' 'parent' :)
     or $state[$p:lk] = 100433                              (: 'attribute' 'preceding' :)
     or $state[$p:lk] = 100468                              (: 'element' 'preceding' :)
     or $state[$p:lk] = 100945                              (: 'attribute' 'preceding-sibling' :)
     or $state[$p:lk] = 100980                              (: 'element' 'preceding-sibling' :)
     or $state[$p:lk] = 102481                              (: 'attribute' 'private' :)
     or $state[$p:lk] = 102516                              (: 'element' 'private' :)
     or $state[$p:lk] = 102993                              (: 'attribute' 'processing-instruction' :)
     or $state[$p:lk] = 103028                              (: 'element' 'processing-instruction' :)
     or $state[$p:lk] = 103505                              (: 'attribute' 'property' :)
     or $state[$p:lk] = 103540                              (: 'element' 'property' :)
     or $state[$p:lk] = 104529                              (: 'attribute' 'rename' :)
     or $state[$p:lk] = 104564                              (: 'element' 'rename' :)
     or $state[$p:lk] = 105041                              (: 'attribute' 'replace' :)
     or $state[$p:lk] = 105076                              (: 'element' 'replace' :)
     or $state[$p:lk] = 108113                              (: 'attribute' 'schema-attribute' :)
     or $state[$p:lk] = 108148                              (: 'element' 'schema-attribute' :)
     or $state[$p:lk] = 108625                              (: 'attribute' 'schema-element' :)
     or $state[$p:lk] = 108660                              (: 'element' 'schema-element' :)
     or $state[$p:lk] = 109137                              (: 'attribute' 'self' :)
     or $state[$p:lk] = 109172                              (: 'element' 'self' :)
     or $state[$p:lk] = 112209                              (: 'attribute' 'some' :)
     or $state[$p:lk] = 112244                              (: 'element' 'some' :)
     or $state[$p:lk] = 116305                              (: 'attribute' 'switch' :)
     or $state[$p:lk] = 116340                              (: 'element' 'switch' :)
     or $state[$p:lk] = 116817                              (: 'attribute' 'text' :)
     or $state[$p:lk] = 116852                              (: 'element' 'text' :)
     or $state[$p:lk] = 119889                              (: 'attribute' 'try' :)
     or $state[$p:lk] = 119924                              (: 'element' 'try' :)
     or $state[$p:lk] = 119979                              (: 'namespace' 'try' :)
     or $state[$p:lk] = 120009                              (: 'processing-instruction' 'try' :)
     or $state[$p:lk] = 121425                              (: 'attribute' 'typeswitch' :)
     or $state[$p:lk] = 121460                              (: 'element' 'typeswitch' :)
     or $state[$p:lk] = 122449                              (: 'attribute' 'unordered' :)
     or $state[$p:lk] = 122484                              (: 'element' 'unordered' :)
     or $state[$p:lk] = 123985                              (: 'attribute' 'validate' :)
     or $state[$p:lk] = 124020                              (: 'element' 'validate' :)
     or $state[$p:lk] = 130641                              (: 'attribute' 'xquery' :)
     or $state[$p:lk] = 130676                              (: 'element' 'xquery' :)
     or $state[$p:lk] = 131665                              (: 'attribute' '{' :)
     or $state[$p:lk] = 131668                              (: 'binary' '{' :)
     or $state[$p:lk] = 131677                              (: 'comment' '{' :)
     or $state[$p:lk] = 131698                              (: 'document' '{' :)
     or $state[$p:lk] = 131700                              (: 'element' '{' :)
     or $state[$p:lk] = 131755                              (: 'namespace' '{' :)
     or $state[$p:lk] = 131771                              (: 'ordered' '{' :)
     or $state[$p:lk] = 131785                              (: 'processing-instruction' '{' :)
     or $state[$p:lk] = 131812                              (: 'text' '{' :)
     or $state[$p:lk] = 131823                              (: 'unordered' '{' :)
     or $state[$p:lk] = 67407441                            (: 'attribute' 'after' '{' :)
     or $state[$p:lk] = 67407476                            (: 'element' 'after' '{' :)
     or $state[$p:lk] = 67407531                            (: 'namespace' 'after' '{' :)
     or $state[$p:lk] = 67407561                            (: 'processing-instruction' 'after' '{' :)
     or $state[$p:lk] = 67410001                            (: 'attribute' 'and' '{' :)
     or $state[$p:lk] = 67410036                            (: 'element' 'and' '{' :)
     or $state[$p:lk] = 67410091                            (: 'namespace' 'and' '{' :)
     or $state[$p:lk] = 67410121                            (: 'processing-instruction' 'and' '{' :)
     or $state[$p:lk] = 67411025                            (: 'attribute' 'as' '{' :)
     or $state[$p:lk] = 67411060                            (: 'element' 'as' '{' :)
     or $state[$p:lk] = 67411115                            (: 'namespace' 'as' '{' :)
     or $state[$p:lk] = 67411145                            (: 'processing-instruction' 'as' '{' :)
     or $state[$p:lk] = 67411537                            (: 'attribute' 'ascending' '{' :)
     or $state[$p:lk] = 67411572                            (: 'element' 'ascending' '{' :)
     or $state[$p:lk] = 67411627                            (: 'namespace' 'ascending' '{' :)
     or $state[$p:lk] = 67411657                            (: 'processing-instruction' 'ascending' '{' :)
     or $state[$p:lk] = 67413585                            (: 'attribute' 'before' '{' :)
     or $state[$p:lk] = 67413620                            (: 'element' 'before' '{' :)
     or $state[$p:lk] = 67413675                            (: 'namespace' 'before' '{' :)
     or $state[$p:lk] = 67413705                            (: 'processing-instruction' 'before' '{' :)
     or $state[$p:lk] = 67415633                            (: 'attribute' 'case' '{' :)
     or $state[$p:lk] = 67415668                            (: 'element' 'case' '{' :)
     or $state[$p:lk] = 67415723                            (: 'namespace' 'case' '{' :)
     or $state[$p:lk] = 67415753                            (: 'processing-instruction' 'case' '{' :)
     or $state[$p:lk] = 67416145                            (: 'attribute' 'cast' '{' :)
     or $state[$p:lk] = 67416180                            (: 'element' 'cast' '{' :)
     or $state[$p:lk] = 67416235                            (: 'namespace' 'cast' '{' :)
     or $state[$p:lk] = 67416265                            (: 'processing-instruction' 'cast' '{' :)
     or $state[$p:lk] = 67416657                            (: 'attribute' 'castable' '{' :)
     or $state[$p:lk] = 67416692                            (: 'element' 'castable' '{' :)
     or $state[$p:lk] = 67416747                            (: 'namespace' 'castable' '{' :)
     or $state[$p:lk] = 67416777                            (: 'processing-instruction' 'castable' '{' :)
     or $state[$p:lk] = 67418193                            (: 'attribute' 'collation' '{' :)
     or $state[$p:lk] = 67418228                            (: 'element' 'collation' '{' :)
     or $state[$p:lk] = 67418283                            (: 'namespace' 'collation' '{' :)
     or $state[$p:lk] = 67418313                            (: 'processing-instruction' 'collation' '{' :)
     or $state[$p:lk] = 67419729                            (: 'attribute' 'contains' '{' :)
     or $state[$p:lk] = 67419764                            (: 'element' 'contains' '{' :)
     or $state[$p:lk] = 67419819                            (: 'namespace' 'contains' '{' :)
     or $state[$p:lk] = 67419849                            (: 'processing-instruction' 'contains' '{' :)
     or $state[$p:lk] = 67422289                            (: 'attribute' 'count' '{' :)
     or $state[$p:lk] = 67422324                            (: 'element' 'count' '{' :)
     or $state[$p:lk] = 67422379                            (: 'namespace' 'count' '{' :)
     or $state[$p:lk] = 67422409                            (: 'processing-instruction' 'count' '{' :)
     or $state[$p:lk] = 67424337                            (: 'attribute' 'default' '{' :)
     or $state[$p:lk] = 67424372                            (: 'element' 'default' '{' :)
     or $state[$p:lk] = 67424427                            (: 'namespace' 'default' '{' :)
     or $state[$p:lk] = 67424457                            (: 'processing-instruction' 'default' '{' :)
     or $state[$p:lk] = 67426385                            (: 'attribute' 'descending' '{' :)
     or $state[$p:lk] = 67426420                            (: 'element' 'descending' '{' :)
     or $state[$p:lk] = 67426475                            (: 'namespace' 'descending' '{' :)
     or $state[$p:lk] = 67426505                            (: 'processing-instruction' 'descending' '{' :)
     or $state[$p:lk] = 67428945                            (: 'attribute' 'div' '{' :)
     or $state[$p:lk] = 67428980                            (: 'element' 'div' '{' :)
     or $state[$p:lk] = 67429035                            (: 'namespace' 'div' '{' :)
     or $state[$p:lk] = 67429065                            (: 'processing-instruction' 'div' '{' :)
     or $state[$p:lk] = 67430993                            (: 'attribute' 'else' '{' :)
     or $state[$p:lk] = 67431028                            (: 'element' 'else' '{' :)
     or $state[$p:lk] = 67431083                            (: 'namespace' 'else' '{' :)
     or $state[$p:lk] = 67431113                            (: 'processing-instruction' 'else' '{' :)
     or $state[$p:lk] = 67431505                            (: 'attribute' 'empty' '{' :)
     or $state[$p:lk] = 67431540                            (: 'element' 'empty' '{' :)
     or $state[$p:lk] = 67431595                            (: 'namespace' 'empty' '{' :)
     or $state[$p:lk] = 67431625                            (: 'processing-instruction' 'empty' '{' :)
     or $state[$p:lk] = 67433041                            (: 'attribute' 'end' '{' :)
     or $state[$p:lk] = 67433076                            (: 'element' 'end' '{' :)
     or $state[$p:lk] = 67433131                            (: 'namespace' 'end' '{' :)
     or $state[$p:lk] = 67433161                            (: 'processing-instruction' 'end' '{' :)
     or $state[$p:lk] = 67434065                            (: 'attribute' 'eq' '{' :)
     or $state[$p:lk] = 67434100                            (: 'element' 'eq' '{' :)
     or $state[$p:lk] = 67434155                            (: 'namespace' 'eq' '{' :)
     or $state[$p:lk] = 67434185                            (: 'processing-instruction' 'eq' '{' :)
     or $state[$p:lk] = 67435601                            (: 'attribute' 'except' '{' :)
     or $state[$p:lk] = 67435636                            (: 'element' 'except' '{' :)
     or $state[$p:lk] = 67435691                            (: 'namespace' 'except' '{' :)
     or $state[$p:lk] = 67435721                            (: 'processing-instruction' 'except' '{' :)
     or $state[$p:lk] = 67438161                            (: 'attribute' 'for' '{' :)
     or $state[$p:lk] = 67438196                            (: 'element' 'for' '{' :)
     or $state[$p:lk] = 67438251                            (: 'namespace' 'for' '{' :)
     or $state[$p:lk] = 67438281                            (: 'processing-instruction' 'for' '{' :)
     or $state[$p:lk] = 67442257                            (: 'attribute' 'ge' '{' :)
     or $state[$p:lk] = 67442292                            (: 'element' 'ge' '{' :)
     or $state[$p:lk] = 67442347                            (: 'namespace' 'ge' '{' :)
     or $state[$p:lk] = 67442377                            (: 'processing-instruction' 'ge' '{' :)
     or $state[$p:lk] = 67443281                            (: 'attribute' 'group' '{' :)
     or $state[$p:lk] = 67443316                            (: 'element' 'group' '{' :)
     or $state[$p:lk] = 67443371                            (: 'namespace' 'group' '{' :)
     or $state[$p:lk] = 67443401                            (: 'processing-instruction' 'group' '{' :)
     or $state[$p:lk] = 67444305                            (: 'attribute' 'gt' '{' :)
     or $state[$p:lk] = 67444340                            (: 'element' 'gt' '{' :)
     or $state[$p:lk] = 67444395                            (: 'namespace' 'gt' '{' :)
     or $state[$p:lk] = 67444425                            (: 'processing-instruction' 'gt' '{' :)
     or $state[$p:lk] = 67444817                            (: 'attribute' 'idiv' '{' :)
     or $state[$p:lk] = 67444852                            (: 'element' 'idiv' '{' :)
     or $state[$p:lk] = 67444907                            (: 'namespace' 'idiv' '{' :)
     or $state[$p:lk] = 67444937                            (: 'processing-instruction' 'idiv' '{' :)
     or $state[$p:lk] = 67448913                            (: 'attribute' 'instance' '{' :)
     or $state[$p:lk] = 67448948                            (: 'element' 'instance' '{' :)
     or $state[$p:lk] = 67449003                            (: 'namespace' 'instance' '{' :)
     or $state[$p:lk] = 67449033                            (: 'processing-instruction' 'instance' '{' :)
     or $state[$p:lk] = 67449425                            (: 'attribute' 'intersect' '{' :)
     or $state[$p:lk] = 67449460                            (: 'element' 'intersect' '{' :)
     or $state[$p:lk] = 67449515                            (: 'namespace' 'intersect' '{' :)
     or $state[$p:lk] = 67449545                            (: 'processing-instruction' 'intersect' '{' :)
     or $state[$p:lk] = 67449937                            (: 'attribute' 'into' '{' :)
     or $state[$p:lk] = 67449972                            (: 'element' 'into' '{' :)
     or $state[$p:lk] = 67450027                            (: 'namespace' 'into' '{' :)
     or $state[$p:lk] = 67450057                            (: 'processing-instruction' 'into' '{' :)
     or $state[$p:lk] = 67450449                            (: 'attribute' 'is' '{' :)
     or $state[$p:lk] = 67450484                            (: 'element' 'is' '{' :)
     or $state[$p:lk] = 67450539                            (: 'namespace' 'is' '{' :)
     or $state[$p:lk] = 67450569                            (: 'processing-instruction' 'is' '{' :)
     or $state[$p:lk] = 67453009                            (: 'attribute' 'le' '{' :)
     or $state[$p:lk] = 67453044                            (: 'element' 'le' '{' :)
     or $state[$p:lk] = 67453099                            (: 'namespace' 'le' '{' :)
     or $state[$p:lk] = 67453129                            (: 'processing-instruction' 'le' '{' :)
     or $state[$p:lk] = 67454033                            (: 'attribute' 'let' '{' :)
     or $state[$p:lk] = 67454068                            (: 'element' 'let' '{' :)
     or $state[$p:lk] = 67454123                            (: 'namespace' 'let' '{' :)
     or $state[$p:lk] = 67454153                            (: 'processing-instruction' 'let' '{' :)
     or $state[$p:lk] = 67455569                            (: 'attribute' 'lt' '{' :)
     or $state[$p:lk] = 67455604                            (: 'element' 'lt' '{' :)
     or $state[$p:lk] = 67455659                            (: 'namespace' 'lt' '{' :)
     or $state[$p:lk] = 67455689                            (: 'processing-instruction' 'lt' '{' :)
     or $state[$p:lk] = 67456593                            (: 'attribute' 'mod' '{' :)
     or $state[$p:lk] = 67456628                            (: 'element' 'mod' '{' :)
     or $state[$p:lk] = 67456683                            (: 'namespace' 'mod' '{' :)
     or $state[$p:lk] = 67456713                            (: 'processing-instruction' 'mod' '{' :)
     or $state[$p:lk] = 67457105                            (: 'attribute' 'modify' '{' :)
     or $state[$p:lk] = 67457140                            (: 'element' 'modify' '{' :)
     or $state[$p:lk] = 67457195                            (: 'namespace' 'modify' '{' :)
     or $state[$p:lk] = 67457225                            (: 'processing-instruction' 'modify' '{' :)
     or $state[$p:lk] = 67459665                            (: 'attribute' 'ne' '{' :)
     or $state[$p:lk] = 67459700                            (: 'element' 'ne' '{' :)
     or $state[$p:lk] = 67459755                            (: 'namespace' 'ne' '{' :)
     or $state[$p:lk] = 67459785                            (: 'processing-instruction' 'ne' '{' :)
     or $state[$p:lk] = 67464785                            (: 'attribute' 'only' '{' :)
     or $state[$p:lk] = 67464820                            (: 'element' 'only' '{' :)
     or $state[$p:lk] = 67464875                            (: 'namespace' 'only' '{' :)
     or $state[$p:lk] = 67464905                            (: 'processing-instruction' 'only' '{' :)
     or $state[$p:lk] = 67465809                            (: 'attribute' 'or' '{' :)
     or $state[$p:lk] = 67465844                            (: 'element' 'or' '{' :)
     or $state[$p:lk] = 67465899                            (: 'namespace' 'or' '{' :)
     or $state[$p:lk] = 67465929                            (: 'processing-instruction' 'or' '{' :)
     or $state[$p:lk] = 67466321                            (: 'attribute' 'order' '{' :)
     or $state[$p:lk] = 67466356                            (: 'element' 'order' '{' :)
     or $state[$p:lk] = 67466411                            (: 'namespace' 'order' '{' :)
     or $state[$p:lk] = 67466441                            (: 'processing-instruction' 'order' '{' :)
     or $state[$p:lk] = 67468369                            (: 'attribute' 'paragraphs' '{' :)
     or $state[$p:lk] = 67468404                            (: 'element' 'paragraphs' '{' :)
     or $state[$p:lk] = 67468459                            (: 'namespace' 'paragraphs' '{' :)
     or $state[$p:lk] = 67468489                            (: 'processing-instruction' 'paragraphs' '{' :)
     or $state[$p:lk] = 67476561                            (: 'attribute' 'return' '{' :)
     or $state[$p:lk] = 67476596                            (: 'element' 'return' '{' :)
     or $state[$p:lk] = 67476651                            (: 'namespace' 'return' '{' :)
     or $state[$p:lk] = 67476681                            (: 'processing-instruction' 'return' '{' :)
     or $state[$p:lk] = 67478097                            (: 'attribute' 'satisfies' '{' :)
     or $state[$p:lk] = 67478132                            (: 'element' 'satisfies' '{' :)
     or $state[$p:lk] = 67478187                            (: 'namespace' 'satisfies' '{' :)
     or $state[$p:lk] = 67478217                            (: 'processing-instruction' 'satisfies' '{' :)
     or $state[$p:lk] = 67481681                            (: 'attribute' 'sentences' '{' :)
     or $state[$p:lk] = 67481716                            (: 'element' 'sentences' '{' :)
     or $state[$p:lk] = 67481771                            (: 'namespace' 'sentences' '{' :)
     or $state[$p:lk] = 67481801                            (: 'processing-instruction' 'sentences' '{' :)
     or $state[$p:lk] = 67483729                            (: 'attribute' 'stable' '{' :)
     or $state[$p:lk] = 67483764                            (: 'element' 'stable' '{' :)
     or $state[$p:lk] = 67483819                            (: 'namespace' 'stable' '{' :)
     or $state[$p:lk] = 67483849                            (: 'processing-instruction' 'stable' '{' :)
     or $state[$p:lk] = 67484241                            (: 'attribute' 'start' '{' :)
     or $state[$p:lk] = 67484276                            (: 'element' 'start' '{' :)
     or $state[$p:lk] = 67484331                            (: 'namespace' 'start' '{' :)
     or $state[$p:lk] = 67484361                            (: 'processing-instruction' 'start' '{' :)
     or $state[$p:lk] = 67489361                            (: 'attribute' 'times' '{' :)
     or $state[$p:lk] = 67489396                            (: 'element' 'times' '{' :)
     or $state[$p:lk] = 67489451                            (: 'namespace' 'times' '{' :)
     or $state[$p:lk] = 67489481                            (: 'processing-instruction' 'times' '{' :)
     or $state[$p:lk] = 67489873                            (: 'attribute' 'to' '{' :)
     or $state[$p:lk] = 67489908                            (: 'element' 'to' '{' :)
     or $state[$p:lk] = 67489963                            (: 'namespace' 'to' '{' :)
     or $state[$p:lk] = 67489993                            (: 'processing-instruction' 'to' '{' :)
     or $state[$p:lk] = 67490385                            (: 'attribute' 'treat' '{' :)
     or $state[$p:lk] = 67490420                            (: 'element' 'treat' '{' :)
     or $state[$p:lk] = 67490475                            (: 'namespace' 'treat' '{' :)
     or $state[$p:lk] = 67490505                            (: 'processing-instruction' 'treat' '{' :)
     or $state[$p:lk] = 67492945                            (: 'attribute' 'union' '{' :)
     or $state[$p:lk] = 67492980                            (: 'element' 'union' '{' :)
     or $state[$p:lk] = 67493035                            (: 'namespace' 'union' '{' :)
     or $state[$p:lk] = 67493065                            (: 'processing-instruction' 'union' '{' :)
     or $state[$p:lk] = 67498065                            (: 'attribute' 'where' '{' :)
     or $state[$p:lk] = 67498100                            (: 'element' 'where' '{' :)
     or $state[$p:lk] = 67498155                            (: 'namespace' 'where' '{' :)
     or $state[$p:lk] = 67498185                            (: 'processing-instruction' 'where' '{' :)
     or $state[$p:lk] = 67499601                            (: 'attribute' 'with' '{' :)
     or $state[$p:lk] = 67499636                            (: 'element' 'with' '{' :)
     or $state[$p:lk] = 67499691                            (: 'namespace' 'with' '{' :)
     or $state[$p:lk] = 67499721                            (: 'processing-instruction' 'with' '{' :)
     or $state[$p:lk] = 67501137                            (: 'attribute' 'words' '{' :)
     or $state[$p:lk] = 67501172                            (: 'element' 'words' '{' :)
     or $state[$p:lk] = 67501227                            (: 'namespace' 'words' '{' :)
     or $state[$p:lk] = 67501257) then                      (: 'processing-instruction' 'words' '{' :)
      let $state := p:parse-PostfixExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AxisStep($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "StepExpr", $count, $begin, $end)
};

(:~
 : Try parsing StepExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-StepExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 81) then                            (: 'attribute' :)
      let $state := p:lookahead2W(251, $input, $state)      (: EOF | URIQualifiedName | QName^Token | S^WS | '!' |
                                                               '!=' | '#' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' |
                                                               '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:lk] = 44625) then                     (: 'attribute' 'case' :)
          let $state := p:lookahead3W(248, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 47185) then                (: 'attribute' 'collation' :)
          let $state := p:lookahead3W(84, $input, $state)   (: URILiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 48721) then                (: 'attribute' 'contains' :)
          let $state := p:lookahead3W(128, $input, $state)  (: S^WS | ('(' ':') | 'text' | '{' :)
          return $state
        else if ($state[$p:lk] = 53329) then                (: 'attribute' 'default' :)
          let $state := p:lookahead3W(133, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 60497) then                (: 'attribute' 'empty' :)
          let $state := p:lookahead3W(144, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 67153) then                (: 'attribute' 'for' :)
          let $state := p:lookahead3W(150, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] = 77905) then                (: 'attribute' 'instance' :)
          let $state := p:lookahead3W(121, $input, $state)  (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 93777) then                (: 'attribute' 'only' :)
          let $state := p:lookahead3W(109, $input, $state)  (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] = 112721) then               (: 'attribute' 'stable' :)
          let $state := p:lookahead3W(122, $input, $state)  (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 118353) then               (: 'attribute' 'times' :)
          let $state := p:lookahead3W(192, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'return' | 'same' | 'satisfies' | 'stable' |
                                                               'start' | 'using' | 'weight' | 'where' | 'window' |
                                                               'with' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = 40529                      (: 'attribute' 'descending' :)
              or $state[$p:lk] = 55377) then                (: 'attribute' 'descending' :)
          let $state := p:lookahead3W(175, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = 51281                      (: 'attribute' 'let' :)
              or $state[$p:lk] = 83025) then                (: 'attribute' 'let' :)
          let $state := p:lookahead3W(89, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 62033                      (: 'attribute' 'start' :)
              or $state[$p:lk] = 113233) then               (: 'attribute' 'start' :)
          let $state := p:lookahead3W(163, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = 72273                      (: 'attribute' 'order' :)
              or $state[$p:lk] = 95313) then                (: 'attribute' 'order' :)
          let $state := p:lookahead3W(104, $input, $state)  (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 45137                      (: 'attribute' 'castable' :)
              or $state[$p:lk] = 45649                      (: 'attribute' 'treat' :)
              or $state[$p:lk] = 119377) then               (: 'attribute' 'treat' :)
          let $state := p:lookahead3W(101, $input, $state)  (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 97361                      (: 'attribute' 'sentences' :)
              or $state[$p:lk] = 110673                     (: 'attribute' 'words' :)
              or $state[$p:lk] = 130129) then               (: 'attribute' 'words' :)
          let $state := p:lookahead3W(187, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'modify' | 'ne' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'return' | 'same' |
                                                               'satisfies' | 'stable' | 'start' | 'where' | 'window' |
                                                               'with' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = 36433                      (: 'attribute' 'and' :)
              or $state[$p:lk] = 38993                      (: 'attribute' 'as' :)
              or $state[$p:lk] = 40017                      (: 'attribute' 'before' :)
              or $state[$p:lk] = 42577                      (: 'attribute' 'div' :)
              or $state[$p:lk] = 57937                      (: 'attribute' 'else' :)
              or $state[$p:lk] = 59985                      (: 'attribute' 'eq' :)
              or $state[$p:lk] = 63057                      (: 'attribute' 'except' :)
              or $state[$p:lk] = 64593                      (: 'attribute' 'ge' :)
              or $state[$p:lk] = 71249                      (: 'attribute' 'gt' :)
              or $state[$p:lk] = 73297                      (: 'attribute' 'idiv' :)
              or $state[$p:lk] = 73809                      (: 'attribute' 'intersect' :)
              or $state[$p:lk] = 78417                      (: 'attribute' 'into' :)
              or $state[$p:lk] = 78929                      (: 'attribute' 'is' :)
              or $state[$p:lk] = 79441                      (: 'attribute' 'le' :)
              or $state[$p:lk] = 82001                      (: 'attribute' 'lt' :)
              or $state[$p:lk] = 84561                      (: 'attribute' 'mod' :)
              or $state[$p:lk] = 85585                      (: 'attribute' 'modify' :)
              or $state[$p:lk] = 86097                      (: 'attribute' 'ne' :)
              or $state[$p:lk] = 88657                      (: 'attribute' 'or' :)
              or $state[$p:lk] = 94801                      (: 'attribute' 'return' :)
              or $state[$p:lk] = 105553                     (: 'attribute' 'satisfies' :)
              or $state[$p:lk] = 107089                     (: 'attribute' 'to' :)
              or $state[$p:lk] = 118865                     (: 'attribute' 'union' :)
              or $state[$p:lk] = 121937                     (: 'attribute' 'where' :)
              or $state[$p:lk] = 127057                     (: 'attribute' 'with' :)
              or $state[$p:lk] = 128593) then               (: 'attribute' 'with' :)
          let $state := p:lookahead3W(245, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'element' :)
      let $state := p:lookahead2W(250, $input, $state)      (: EOF | URIQualifiedName | QName^Token | S^WS | '!' |
                                                               '!=' | '#' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' |
                                                               '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:lk] = 44660) then                     (: 'element' 'case' :)
          let $state := p:lookahead3W(248, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 47220) then                (: 'element' 'collation' :)
          let $state := p:lookahead3W(84, $input, $state)   (: URILiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 48756) then                (: 'element' 'contains' :)
          let $state := p:lookahead3W(128, $input, $state)  (: S^WS | ('(' ':') | 'text' | '{' :)
          return $state
        else if ($state[$p:lk] = 53364) then                (: 'element' 'default' :)
          let $state := p:lookahead3W(133, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 60532) then                (: 'element' 'empty' :)
          let $state := p:lookahead3W(144, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 67188) then                (: 'element' 'for' :)
          let $state := p:lookahead3W(150, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] = 77940) then                (: 'element' 'instance' :)
          let $state := p:lookahead3W(121, $input, $state)  (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 93812) then                (: 'element' 'only' :)
          let $state := p:lookahead3W(109, $input, $state)  (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] = 112756) then               (: 'element' 'stable' :)
          let $state := p:lookahead3W(122, $input, $state)  (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 118388) then               (: 'element' 'times' :)
          let $state := p:lookahead3W(192, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'return' | 'same' | 'satisfies' | 'stable' |
                                                               'start' | 'using' | 'weight' | 'where' | 'window' |
                                                               'with' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = 40564                      (: 'element' 'descending' :)
              or $state[$p:lk] = 55412) then                (: 'element' 'descending' :)
          let $state := p:lookahead3W(175, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = 51316                      (: 'element' 'let' :)
              or $state[$p:lk] = 83060) then                (: 'element' 'let' :)
          let $state := p:lookahead3W(89, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 62068                      (: 'element' 'start' :)
              or $state[$p:lk] = 113268) then               (: 'element' 'start' :)
          let $state := p:lookahead3W(163, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = 72308                      (: 'element' 'order' :)
              or $state[$p:lk] = 95348) then                (: 'element' 'order' :)
          let $state := p:lookahead3W(104, $input, $state)  (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 45172                      (: 'element' 'castable' :)
              or $state[$p:lk] = 45684                      (: 'element' 'treat' :)
              or $state[$p:lk] = 119412) then               (: 'element' 'treat' :)
          let $state := p:lookahead3W(101, $input, $state)  (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 97396                      (: 'element' 'sentences' :)
              or $state[$p:lk] = 110708                     (: 'element' 'words' :)
              or $state[$p:lk] = 130164) then               (: 'element' 'words' :)
          let $state := p:lookahead3W(187, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'modify' | 'ne' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'return' | 'same' |
                                                               'satisfies' | 'stable' | 'start' | 'where' | 'window' |
                                                               'with' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = 36468                      (: 'element' 'and' :)
              or $state[$p:lk] = 39028                      (: 'element' 'as' :)
              or $state[$p:lk] = 40052                      (: 'element' 'before' :)
              or $state[$p:lk] = 42612                      (: 'element' 'div' :)
              or $state[$p:lk] = 57972                      (: 'element' 'else' :)
              or $state[$p:lk] = 60020                      (: 'element' 'eq' :)
              or $state[$p:lk] = 63092                      (: 'element' 'except' :)
              or $state[$p:lk] = 64628                      (: 'element' 'ge' :)
              or $state[$p:lk] = 71284                      (: 'element' 'gt' :)
              or $state[$p:lk] = 73332                      (: 'element' 'idiv' :)
              or $state[$p:lk] = 73844                      (: 'element' 'intersect' :)
              or $state[$p:lk] = 78452                      (: 'element' 'into' :)
              or $state[$p:lk] = 78964                      (: 'element' 'is' :)
              or $state[$p:lk] = 79476                      (: 'element' 'le' :)
              or $state[$p:lk] = 82036                      (: 'element' 'lt' :)
              or $state[$p:lk] = 84596                      (: 'element' 'mod' :)
              or $state[$p:lk] = 85620                      (: 'element' 'modify' :)
              or $state[$p:lk] = 86132                      (: 'element' 'ne' :)
              or $state[$p:lk] = 88692                      (: 'element' 'or' :)
              or $state[$p:lk] = 94836                      (: 'element' 'return' :)
              or $state[$p:lk] = 105588                     (: 'element' 'satisfies' :)
              or $state[$p:lk] = 107124                     (: 'element' 'to' :)
              or $state[$p:lk] = 118900                     (: 'element' 'union' :)
              or $state[$p:lk] = 121972                     (: 'element' 'where' :)
              or $state[$p:lk] = 127092                     (: 'element' 'with' :)
              or $state[$p:lk] = 128628) then               (: 'element' 'with' :)
          let $state := p:lookahead3W(245, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 171) then                      (: 'namespace' :)
      let $state := p:lookahead2W(224, $input, $state)      (: EOF | NCName^Token | S^WS | '!' | '!=' | '#' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' | '//' |
                                                               '::' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'treat' | 'try' |
                                                               'union' | 'where' | 'with' | 'words' | '{' | '|' | '||' |
                                                               '}' :)
      let $state :=
        if ($state[$p:lk] = 44715) then                     (: 'namespace' 'case' :)
          let $state := p:lookahead3W(248, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 47275) then                (: 'namespace' 'collation' :)
          let $state := p:lookahead3W(84, $input, $state)   (: URILiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 48811) then                (: 'namespace' 'contains' :)
          let $state := p:lookahead3W(128, $input, $state)  (: S^WS | ('(' ':') | 'text' | '{' :)
          return $state
        else if ($state[$p:lk] = 53419) then                (: 'namespace' 'default' :)
          let $state := p:lookahead3W(133, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 60587) then                (: 'namespace' 'empty' :)
          let $state := p:lookahead3W(144, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 67243) then                (: 'namespace' 'for' :)
          let $state := p:lookahead3W(150, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] = 77995) then                (: 'namespace' 'instance' :)
          let $state := p:lookahead3W(121, $input, $state)  (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 93867) then                (: 'namespace' 'only' :)
          let $state := p:lookahead3W(109, $input, $state)  (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] = 112811) then               (: 'namespace' 'stable' :)
          let $state := p:lookahead3W(122, $input, $state)  (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 118443) then               (: 'namespace' 'times' :)
          let $state := p:lookahead3W(192, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'return' | 'same' | 'satisfies' | 'stable' |
                                                               'start' | 'using' | 'weight' | 'where' | 'window' |
                                                               'with' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = 40619                      (: 'namespace' 'descending' :)
              or $state[$p:lk] = 55467) then                (: 'namespace' 'descending' :)
          let $state := p:lookahead3W(175, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = 51371                      (: 'namespace' 'let' :)
              or $state[$p:lk] = 83115) then                (: 'namespace' 'let' :)
          let $state := p:lookahead3W(89, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 62123                      (: 'namespace' 'start' :)
              or $state[$p:lk] = 113323) then               (: 'namespace' 'start' :)
          let $state := p:lookahead3W(163, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = 72363                      (: 'namespace' 'order' :)
              or $state[$p:lk] = 95403) then                (: 'namespace' 'order' :)
          let $state := p:lookahead3W(104, $input, $state)  (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 45227                      (: 'namespace' 'castable' :)
              or $state[$p:lk] = 45739                      (: 'namespace' 'treat' :)
              or $state[$p:lk] = 119467) then               (: 'namespace' 'treat' :)
          let $state := p:lookahead3W(101, $input, $state)  (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 97451                      (: 'namespace' 'sentences' :)
              or $state[$p:lk] = 110763                     (: 'namespace' 'words' :)
              or $state[$p:lk] = 130219) then               (: 'namespace' 'words' :)
          let $state := p:lookahead3W(187, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'modify' | 'ne' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'return' | 'same' |
                                                               'satisfies' | 'stable' | 'start' | 'where' | 'window' |
                                                               'with' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = 36523                      (: 'namespace' 'and' :)
              or $state[$p:lk] = 39083                      (: 'namespace' 'as' :)
              or $state[$p:lk] = 40107                      (: 'namespace' 'before' :)
              or $state[$p:lk] = 42667                      (: 'namespace' 'div' :)
              or $state[$p:lk] = 58027                      (: 'namespace' 'else' :)
              or $state[$p:lk] = 60075                      (: 'namespace' 'eq' :)
              or $state[$p:lk] = 63147                      (: 'namespace' 'except' :)
              or $state[$p:lk] = 64683                      (: 'namespace' 'ge' :)
              or $state[$p:lk] = 71339                      (: 'namespace' 'gt' :)
              or $state[$p:lk] = 73387                      (: 'namespace' 'idiv' :)
              or $state[$p:lk] = 73899                      (: 'namespace' 'intersect' :)
              or $state[$p:lk] = 78507                      (: 'namespace' 'into' :)
              or $state[$p:lk] = 79019                      (: 'namespace' 'is' :)
              or $state[$p:lk] = 79531                      (: 'namespace' 'le' :)
              or $state[$p:lk] = 82091                      (: 'namespace' 'lt' :)
              or $state[$p:lk] = 84651                      (: 'namespace' 'mod' :)
              or $state[$p:lk] = 85675                      (: 'namespace' 'modify' :)
              or $state[$p:lk] = 86187                      (: 'namespace' 'ne' :)
              or $state[$p:lk] = 88747                      (: 'namespace' 'or' :)
              or $state[$p:lk] = 94891                      (: 'namespace' 'return' :)
              or $state[$p:lk] = 105643                     (: 'namespace' 'satisfies' :)
              or $state[$p:lk] = 107179                     (: 'namespace' 'to' :)
              or $state[$p:lk] = 118955                     (: 'namespace' 'union' :)
              or $state[$p:lk] = 122027                     (: 'namespace' 'where' :)
              or $state[$p:lk] = 127147                     (: 'namespace' 'with' :)
              or $state[$p:lk] = 128683) then               (: 'namespace' 'with' :)
          let $state := p:lookahead3W(245, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 201) then                      (: 'processing-instruction' :)
      let $state := p:lookahead2W(223, $input, $state)      (: EOF | NCName^Token | S^WS | '!' | '!=' | '#' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' | '//' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'treat' | 'try' | 'union' |
                                                               'where' | 'with' | 'words' | '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:lk] = 44745) then                     (: 'processing-instruction' 'case' :)
          let $state := p:lookahead3W(248, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 47305) then                (: 'processing-instruction' 'collation' :)
          let $state := p:lookahead3W(84, $input, $state)   (: URILiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 48841) then                (: 'processing-instruction' 'contains' :)
          let $state := p:lookahead3W(128, $input, $state)  (: S^WS | ('(' ':') | 'text' | '{' :)
          return $state
        else if ($state[$p:lk] = 53449) then                (: 'processing-instruction' 'default' :)
          let $state := p:lookahead3W(133, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 60617) then                (: 'processing-instruction' 'empty' :)
          let $state := p:lookahead3W(144, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 67273) then                (: 'processing-instruction' 'for' :)
          let $state := p:lookahead3W(150, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] = 78025) then                (: 'processing-instruction' 'instance' :)
          let $state := p:lookahead3W(121, $input, $state)  (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 93897) then                (: 'processing-instruction' 'only' :)
          let $state := p:lookahead3W(109, $input, $state)  (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] = 112841) then               (: 'processing-instruction' 'stable' :)
          let $state := p:lookahead3W(122, $input, $state)  (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 118473) then               (: 'processing-instruction' 'times' :)
          let $state := p:lookahead3W(192, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'return' | 'same' | 'satisfies' | 'stable' |
                                                               'start' | 'using' | 'weight' | 'where' | 'window' |
                                                               'with' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = 40649                      (: 'processing-instruction' 'descending' :)
              or $state[$p:lk] = 55497) then                (: 'processing-instruction' 'descending' :)
          let $state := p:lookahead3W(175, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = 51401                      (: 'processing-instruction' 'let' :)
              or $state[$p:lk] = 83145) then                (: 'processing-instruction' 'let' :)
          let $state := p:lookahead3W(89, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 62153                      (: 'processing-instruction' 'start' :)
              or $state[$p:lk] = 113353) then               (: 'processing-instruction' 'start' :)
          let $state := p:lookahead3W(163, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = 72393                      (: 'processing-instruction' 'order' :)
              or $state[$p:lk] = 95433) then                (: 'processing-instruction' 'order' :)
          let $state := p:lookahead3W(104, $input, $state)  (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 45257                      (: 'processing-instruction' 'castable' :)
              or $state[$p:lk] = 45769                      (: 'processing-instruction' 'treat' :)
              or $state[$p:lk] = 119497) then               (: 'processing-instruction' 'treat' :)
          let $state := p:lookahead3W(101, $input, $state)  (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 97481                      (: 'processing-instruction' 'sentences' :)
              or $state[$p:lk] = 110793                     (: 'processing-instruction' 'words' :)
              or $state[$p:lk] = 130249) then               (: 'processing-instruction' 'words' :)
          let $state := p:lookahead3W(187, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'modify' | 'ne' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'return' | 'same' |
                                                               'satisfies' | 'stable' | 'start' | 'where' | 'window' |
                                                               'with' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = 36553                      (: 'processing-instruction' 'and' :)
              or $state[$p:lk] = 39113                      (: 'processing-instruction' 'as' :)
              or $state[$p:lk] = 40137                      (: 'processing-instruction' 'before' :)
              or $state[$p:lk] = 42697                      (: 'processing-instruction' 'div' :)
              or $state[$p:lk] = 58057                      (: 'processing-instruction' 'else' :)
              or $state[$p:lk] = 60105                      (: 'processing-instruction' 'eq' :)
              or $state[$p:lk] = 63177                      (: 'processing-instruction' 'except' :)
              or $state[$p:lk] = 64713                      (: 'processing-instruction' 'ge' :)
              or $state[$p:lk] = 71369                      (: 'processing-instruction' 'gt' :)
              or $state[$p:lk] = 73417                      (: 'processing-instruction' 'idiv' :)
              or $state[$p:lk] = 73929                      (: 'processing-instruction' 'intersect' :)
              or $state[$p:lk] = 78537                      (: 'processing-instruction' 'into' :)
              or $state[$p:lk] = 79049                      (: 'processing-instruction' 'is' :)
              or $state[$p:lk] = 79561                      (: 'processing-instruction' 'le' :)
              or $state[$p:lk] = 82121                      (: 'processing-instruction' 'lt' :)
              or $state[$p:lk] = 84681                      (: 'processing-instruction' 'mod' :)
              or $state[$p:lk] = 85705                      (: 'processing-instruction' 'modify' :)
              or $state[$p:lk] = 86217                      (: 'processing-instruction' 'ne' :)
              or $state[$p:lk] = 88777                      (: 'processing-instruction' 'or' :)
              or $state[$p:lk] = 94921                      (: 'processing-instruction' 'return' :)
              or $state[$p:lk] = 105673                     (: 'processing-instruction' 'satisfies' :)
              or $state[$p:lk] = 107209                     (: 'processing-instruction' 'to' :)
              or $state[$p:lk] = 118985                     (: 'processing-instruction' 'union' :)
              or $state[$p:lk] = 122057                     (: 'processing-instruction' 'where' :)
              or $state[$p:lk] = 127177                     (: 'processing-instruction' 'with' :)
              or $state[$p:lk] = 128713) then               (: 'processing-instruction' 'with' :)
          let $state := p:lookahead3W(245, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 119                            (: 'if' :)
          or $state[$p:l1] = 145                            (: 'item' :)
          or $state[$p:l1] = 156                            (: 'switch' :)
          or $state[$p:l1] = 227                            (: 'typeswitch' :)
          or $state[$p:l1] = 237) then                      (: 'typeswitch' :)
      let $state := p:lookahead2W(213, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 84                             (: 'comment' :)
          or $state[$p:l1] = 93                             (: 'document' :)
          or $state[$p:l1] = 114                            (: 'ordered' :)
          or $state[$p:l1] = 187                            (: 'text' :)
          or $state[$p:l1] = 228                            (: 'unordered' :)
          or $state[$p:l1] = 239) then                      (: 'unordered' :)
      let $state := p:lookahead2W(221, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '{' |
                                                               '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 74                             (: 'ancestor-or-self' :)
          or $state[$p:l1] = 75                             (: 'child' :)
          or $state[$p:l1] = 91                             (: 'descendant' :)
          or $state[$p:l1] = 106                            (: 'descendant-or-self' :)
          or $state[$p:l1] = 107                            (: 'following' :)
          or $state[$p:l1] = 129                            (: 'following-sibling' :)
          or $state[$p:l1] = 130                            (: 'parent' :)
          or $state[$p:l1] = 191                            (: 'preceding' :)
          or $state[$p:l1] = 196                            (: 'preceding-sibling' :)
          or $state[$p:l1] = 197                            (: 'property' :)
          or $state[$p:l1] = 202                            (: 'self' :)
          or $state[$p:l1] = 213) then                      (: 'self' :)
      let $state := p:lookahead2W(220, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'treat' | 'union' | 'where' |
                                                               'with' | 'words' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 7                              (: QName^Token :)
          or $state[$p:l1] = 22                             (: 'after' :)
          or $state[$p:l1] = 71                             (: 'and' :)
          or $state[$p:l1] = 76                             (: 'as' :)
          or $state[$p:l1] = 78                             (: 'ascending' :)
          or $state[$p:l1] = 79                             (: 'before' :)
          or $state[$p:l1] = 83                             (: 'case' :)
          or $state[$p:l1] = 87                             (: 'cast' :)
          or $state[$p:l1] = 88                             (: 'castable' :)
          or $state[$p:l1] = 89                             (: 'catch' :)
          or $state[$p:l1] = 90                             (: 'collation' :)
          or $state[$p:l1] = 92                             (: 'contains' :)
          or $state[$p:l1] = 95                             (: 'copy' :)
          or $state[$p:l1] = 98                             (: 'count' :)
          or $state[$p:l1] = 100                            (: 'declare' :)
          or $state[$p:l1] = 103                            (: 'default' :)
          or $state[$p:l1] = 104                            (: 'delete' :)
          or $state[$p:l1] = 105                            (: 'descending' :)
          or $state[$p:l1] = 108                            (: 'div' :)
          or $state[$p:l1] = 113                            (: 'document-node' :)
          or $state[$p:l1] = 115                            (: 'else' :)
          or $state[$p:l1] = 117                            (: 'empty' :)
          or $state[$p:l1] = 118                            (: 'end' :)
          or $state[$p:l1] = 121                            (: 'eq' :)
          or $state[$p:l1] = 123                            (: 'every' :)
          or $state[$p:l1] = 124                            (: 'except' :)
          or $state[$p:l1] = 126                            (: 'first' :)
          or $state[$p:l1] = 128                            (: 'for' :)
          or $state[$p:l1] = 131                            (: 'function' :)
          or $state[$p:l1] = 138                            (: 'ge' :)
          or $state[$p:l1] = 139                            (: 'group' :)
          or $state[$p:l1] = 141                            (: 'gt' :)
          or $state[$p:l1] = 143                            (: 'idiv' :)
          or $state[$p:l1] = 144                            (: 'import' :)
          or $state[$p:l1] = 146                            (: 'insert' :)
          or $state[$p:l1] = 151                            (: 'instance' :)
          or $state[$p:l1] = 152                            (: 'intersect' :)
          or $state[$p:l1] = 153                            (: 'into' :)
          or $state[$p:l1] = 154                            (: 'is' :)
          or $state[$p:l1] = 155                            (: 'last' :)
          or $state[$p:l1] = 158                            (: 'le' :)
          or $state[$p:l1] = 160                            (: 'let' :)
          or $state[$p:l1] = 162                            (: 'lt' :)
          or $state[$p:l1] = 165                            (: 'mod' :)
          or $state[$p:l1] = 167                            (: 'modify' :)
          or $state[$p:l1] = 168                            (: 'module' :)
          or $state[$p:l1] = 169                            (: 'namespace-node' :)
          or $state[$p:l1] = 172                            (: 'ne' :)
          or $state[$p:l1] = 173                            (: 'node' :)
          or $state[$p:l1] = 178                            (: 'only' :)
          or $state[$p:l1] = 183                            (: 'or' :)
          or $state[$p:l1] = 185                            (: 'order' :)
          or $state[$p:l1] = 186                            (: 'paragraphs' :)
          or $state[$p:l1] = 190                            (: 'private' :)
          or $state[$p:l1] = 200                            (: 'rename' :)
          or $state[$p:l1] = 204                            (: 'replace' :)
          or $state[$p:l1] = 205                            (: 'return' :)
          or $state[$p:l1] = 206                            (: 'satisfies' :)
          or $state[$p:l1] = 209                            (: 'schema-attribute' :)
          or $state[$p:l1] = 211                            (: 'schema-element' :)
          or $state[$p:l1] = 212                            (: 'sentences' :)
          or $state[$p:l1] = 216                            (: 'some' :)
          or $state[$p:l1] = 219                            (: 'stable' :)
          or $state[$p:l1] = 220                            (: 'start' :)
          or $state[$p:l1] = 221                            (: 'times' :)
          or $state[$p:l1] = 231                            (: 'to' :)
          or $state[$p:l1] = 232                            (: 'treat' :)
          or $state[$p:l1] = 233                            (: 'try' :)
          or $state[$p:l1] = 234                            (: 'union' :)
          or $state[$p:l1] = 238                            (: 'validate' :)
          or $state[$p:l1] = 242                            (: 'where' :)
          or $state[$p:l1] = 248                            (: 'with' :)
          or $state[$p:l1] = 251                            (: 'words' :)
          or $state[$p:l1] = 254                            (: 'xquery' :)
          or $state[$p:l1] = 255) then                      (: 'xquery' :)
      let $state := p:lookahead2W(217, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 9                                   (: IntegerLiteral :)
     or $state[$p:lk] = 10                                  (: DecimalLiteral :)
     or $state[$p:lk] = 11                                  (: DoubleLiteral :)
     or $state[$p:lk] = 12                                  (: StringLiteral :)
     or $state[$p:lk] = 31                                  (: '$' :)
     or $state[$p:lk] = 34                                  (: '(' :)
     or $state[$p:lk] = 44                                  (: '.' :)
     or $state[$p:lk] = 53                                  (: '<' :)
     or $state[$p:lk] = 54                                  (: '<!--' :)
     or $state[$p:lk] = 59                                  (: '<?' :)
     or $state[$p:lk] = 3665                                (: 'attribute' URIQualifiedName :)
     or $state[$p:lk] = 3700                                (: 'element' URIQualifiedName :)
     or $state[$p:lk] = 10923                               (: 'namespace' NCName^Token :)
     or $state[$p:lk] = 10953                               (: 'processing-instruction' NCName^Token :)
     or $state[$p:lk] = 11345                               (: 'attribute' QName^Token :)
     or $state[$p:lk] = 11380                               (: 'element' QName^Token :)
     or $state[$p:lk] = 14855                               (: URIQualifiedName '#' :)
     or $state[$p:lk] = 14870                               (: QName^Token '#' :)
     or $state[$p:lk] = 14919                               (: 'after' '#' :)
     or $state[$p:lk] = 14922                               (: 'ancestor' '#' :)
     or $state[$p:lk] = 14923                               (: 'ancestor-or-self' '#' :)
     or $state[$p:lk] = 14924                               (: 'and' '#' :)
     or $state[$p:lk] = 14926                               (: 'as' '#' :)
     or $state[$p:lk] = 14927                               (: 'ascending' '#' :)
     or $state[$p:lk] = 14929                               (: 'attribute' '#' :)
     or $state[$p:lk] = 14931                               (: 'before' '#' :)
     or $state[$p:lk] = 14932                               (: 'binary' '#' :)
     or $state[$p:lk] = 14935                               (: 'case' '#' :)
     or $state[$p:lk] = 14936                               (: 'cast' '#' :)
     or $state[$p:lk] = 14937                               (: 'castable' '#' :)
     or $state[$p:lk] = 14938                               (: 'catch' '#' :)
     or $state[$p:lk] = 14939                               (: 'child' '#' :)
     or $state[$p:lk] = 14940                               (: 'collation' '#' :)
     or $state[$p:lk] = 14941                               (: 'comment' '#' :)
     or $state[$p:lk] = 14943                               (: 'contains' '#' :)
     or $state[$p:lk] = 14946                               (: 'copy' '#' :)
     or $state[$p:lk] = 14948                               (: 'count' '#' :)
     or $state[$p:lk] = 14951                               (: 'declare' '#' :)
     or $state[$p:lk] = 14952                               (: 'default' '#' :)
     or $state[$p:lk] = 14953                               (: 'delete' '#' :)
     or $state[$p:lk] = 14954                               (: 'descendant' '#' :)
     or $state[$p:lk] = 14955                               (: 'descendant-or-self' '#' :)
     or $state[$p:lk] = 14956                               (: 'descending' '#' :)
     or $state[$p:lk] = 14961                               (: 'div' '#' :)
     or $state[$p:lk] = 14962                               (: 'document' '#' :)
     or $state[$p:lk] = 14963                               (: 'document-node' '#' :)
     or $state[$p:lk] = 14964                               (: 'element' '#' :)
     or $state[$p:lk] = 14965                               (: 'else' '#' :)
     or $state[$p:lk] = 14966                               (: 'empty' '#' :)
     or $state[$p:lk] = 14967                               (: 'empty-sequence' '#' :)
     or $state[$p:lk] = 14969                               (: 'end' '#' :)
     or $state[$p:lk] = 14971                               (: 'eq' '#' :)
     or $state[$p:lk] = 14972                               (: 'every' '#' :)
     or $state[$p:lk] = 14974                               (: 'except' '#' :)
     or $state[$p:lk] = 14976                               (: 'first' '#' :)
     or $state[$p:lk] = 14977                               (: 'following' '#' :)
     or $state[$p:lk] = 14978                               (: 'following-sibling' '#' :)
     or $state[$p:lk] = 14979                               (: 'for' '#' :)
     or $state[$p:lk] = 14986                               (: 'function' '#' :)
     or $state[$p:lk] = 14987                               (: 'ge' '#' :)
     or $state[$p:lk] = 14989                               (: 'group' '#' :)
     or $state[$p:lk] = 14991                               (: 'gt' '#' :)
     or $state[$p:lk] = 14992                               (: 'idiv' '#' :)
     or $state[$p:lk] = 14993                               (: 'if' '#' :)
     or $state[$p:lk] = 14994                               (: 'import' '#' :)
     or $state[$p:lk] = 14999                               (: 'insert' '#' :)
     or $state[$p:lk] = 15000                               (: 'instance' '#' :)
     or $state[$p:lk] = 15001                               (: 'intersect' '#' :)
     or $state[$p:lk] = 15002                               (: 'into' '#' :)
     or $state[$p:lk] = 15003                               (: 'is' '#' :)
     or $state[$p:lk] = 15004                               (: 'item' '#' :)
     or $state[$p:lk] = 15006                               (: 'last' '#' :)
     or $state[$p:lk] = 15008                               (: 'le' '#' :)
     or $state[$p:lk] = 15010                               (: 'let' '#' :)
     or $state[$p:lk] = 15013                               (: 'lt' '#' :)
     or $state[$p:lk] = 15015                               (: 'mod' '#' :)
     or $state[$p:lk] = 15016                               (: 'modify' '#' :)
     or $state[$p:lk] = 15017                               (: 'module' '#' :)
     or $state[$p:lk] = 15019                               (: 'namespace' '#' :)
     or $state[$p:lk] = 15020                               (: 'namespace-node' '#' :)
     or $state[$p:lk] = 15021                               (: 'ne' '#' :)
     or $state[$p:lk] = 15026                               (: 'node' '#' :)
     or $state[$p:lk] = 15031                               (: 'only' '#' :)
     or $state[$p:lk] = 15033                               (: 'or' '#' :)
     or $state[$p:lk] = 15034                               (: 'order' '#' :)
     or $state[$p:lk] = 15035                               (: 'ordered' '#' :)
     or $state[$p:lk] = 15038                               (: 'paragraphs' '#' :)
     or $state[$p:lk] = 15039                               (: 'parent' '#' :)
     or $state[$p:lk] = 15044                               (: 'preceding' '#' :)
     or $state[$p:lk] = 15045                               (: 'preceding-sibling' '#' :)
     or $state[$p:lk] = 15048                               (: 'private' '#' :)
     or $state[$p:lk] = 15049                               (: 'processing-instruction' '#' :)
     or $state[$p:lk] = 15050                               (: 'property' '#' :)
     or $state[$p:lk] = 15052                               (: 'rename' '#' :)
     or $state[$p:lk] = 15053                               (: 'replace' '#' :)
     or $state[$p:lk] = 15054                               (: 'return' '#' :)
     or $state[$p:lk] = 15057                               (: 'satisfies' '#' :)
     or $state[$p:lk] = 15059                               (: 'schema-attribute' '#' :)
     or $state[$p:lk] = 15060                               (: 'schema-element' '#' :)
     or $state[$p:lk] = 15061                               (: 'self' '#' :)
     or $state[$p:lk] = 15064                               (: 'sentences' '#' :)
     or $state[$p:lk] = 15067                               (: 'some' '#' :)
     or $state[$p:lk] = 15068                               (: 'stable' '#' :)
     or $state[$p:lk] = 15069                               (: 'start' '#' :)
     or $state[$p:lk] = 15075                               (: 'switch' '#' :)
     or $state[$p:lk] = 15076                               (: 'text' '#' :)
     or $state[$p:lk] = 15079                               (: 'times' '#' :)
     or $state[$p:lk] = 15080                               (: 'to' '#' :)
     or $state[$p:lk] = 15081                               (: 'treat' '#' :)
     or $state[$p:lk] = 15082                               (: 'try' '#' :)
     or $state[$p:lk] = 15085                               (: 'typeswitch' '#' :)
     or $state[$p:lk] = 15086                               (: 'union' '#' :)
     or $state[$p:lk] = 15087                               (: 'unordered' '#' :)
     or $state[$p:lk] = 15090                               (: 'validate' '#' :)
     or $state[$p:lk] = 15096                               (: 'where' '#' :)
     or $state[$p:lk] = 15099                               (: 'with' '#' :)
     or $state[$p:lk] = 15102                               (: 'words' '#' :)
     or $state[$p:lk] = 15103                               (: 'xquery' '#' :)
     or $state[$p:lk] = 17415                               (: URIQualifiedName '(' :)
     or $state[$p:lk] = 17430                               (: QName^Token '(' :)
     or $state[$p:lk] = 17479                               (: 'after' '(' :)
     or $state[$p:lk] = 17482                               (: 'ancestor' '(' :)
     or $state[$p:lk] = 17483                               (: 'ancestor-or-self' '(' :)
     or $state[$p:lk] = 17484                               (: 'and' '(' :)
     or $state[$p:lk] = 17486                               (: 'as' '(' :)
     or $state[$p:lk] = 17487                               (: 'ascending' '(' :)
     or $state[$p:lk] = 17491                               (: 'before' '(' :)
     or $state[$p:lk] = 17495                               (: 'case' '(' :)
     or $state[$p:lk] = 17496                               (: 'cast' '(' :)
     or $state[$p:lk] = 17497                               (: 'castable' '(' :)
     or $state[$p:lk] = 17498                               (: 'catch' '(' :)
     or $state[$p:lk] = 17499                               (: 'child' '(' :)
     or $state[$p:lk] = 17500                               (: 'collation' '(' :)
     or $state[$p:lk] = 17503                               (: 'contains' '(' :)
     or $state[$p:lk] = 17506                               (: 'copy' '(' :)
     or $state[$p:lk] = 17508                               (: 'count' '(' :)
     or $state[$p:lk] = 17511                               (: 'declare' '(' :)
     or $state[$p:lk] = 17512                               (: 'default' '(' :)
     or $state[$p:lk] = 17513                               (: 'delete' '(' :)
     or $state[$p:lk] = 17514                               (: 'descendant' '(' :)
     or $state[$p:lk] = 17515                               (: 'descendant-or-self' '(' :)
     or $state[$p:lk] = 17516                               (: 'descending' '(' :)
     or $state[$p:lk] = 17521                               (: 'div' '(' :)
     or $state[$p:lk] = 17522                               (: 'document' '(' :)
     or $state[$p:lk] = 17525                               (: 'else' '(' :)
     or $state[$p:lk] = 17526                               (: 'empty' '(' :)
     or $state[$p:lk] = 17529                               (: 'end' '(' :)
     or $state[$p:lk] = 17531                               (: 'eq' '(' :)
     or $state[$p:lk] = 17532                               (: 'every' '(' :)
     or $state[$p:lk] = 17534                               (: 'except' '(' :)
     or $state[$p:lk] = 17536                               (: 'first' '(' :)
     or $state[$p:lk] = 17537                               (: 'following' '(' :)
     or $state[$p:lk] = 17538                               (: 'following-sibling' '(' :)
     or $state[$p:lk] = 17539                               (: 'for' '(' :)
     or $state[$p:lk] = 17546                               (: 'function' '(' :)
     or $state[$p:lk] = 17547                               (: 'ge' '(' :)
     or $state[$p:lk] = 17549                               (: 'group' '(' :)
     or $state[$p:lk] = 17551                               (: 'gt' '(' :)
     or $state[$p:lk] = 17552                               (: 'idiv' '(' :)
     or $state[$p:lk] = 17554                               (: 'import' '(' :)
     or $state[$p:lk] = 17559                               (: 'insert' '(' :)
     or $state[$p:lk] = 17560                               (: 'instance' '(' :)
     or $state[$p:lk] = 17561                               (: 'intersect' '(' :)
     or $state[$p:lk] = 17562                               (: 'into' '(' :)
     or $state[$p:lk] = 17563                               (: 'is' '(' :)
     or $state[$p:lk] = 17566                               (: 'last' '(' :)
     or $state[$p:lk] = 17568                               (: 'le' '(' :)
     or $state[$p:lk] = 17570                               (: 'let' '(' :)
     or $state[$p:lk] = 17573                               (: 'lt' '(' :)
     or $state[$p:lk] = 17575                               (: 'mod' '(' :)
     or $state[$p:lk] = 17576                               (: 'modify' '(' :)
     or $state[$p:lk] = 17577                               (: 'module' '(' :)
     or $state[$p:lk] = 17579                               (: 'namespace' '(' :)
     or $state[$p:lk] = 17581                               (: 'ne' '(' :)
     or $state[$p:lk] = 17591                               (: 'only' '(' :)
     or $state[$p:lk] = 17593                               (: 'or' '(' :)
     or $state[$p:lk] = 17594                               (: 'order' '(' :)
     or $state[$p:lk] = 17595                               (: 'ordered' '(' :)
     or $state[$p:lk] = 17598                               (: 'paragraphs' '(' :)
     or $state[$p:lk] = 17599                               (: 'parent' '(' :)
     or $state[$p:lk] = 17604                               (: 'preceding' '(' :)
     or $state[$p:lk] = 17605                               (: 'preceding-sibling' '(' :)
     or $state[$p:lk] = 17608                               (: 'private' '(' :)
     or $state[$p:lk] = 17610                               (: 'property' '(' :)
     or $state[$p:lk] = 17612                               (: 'rename' '(' :)
     or $state[$p:lk] = 17613                               (: 'replace' '(' :)
     or $state[$p:lk] = 17614                               (: 'return' '(' :)
     or $state[$p:lk] = 17617                               (: 'satisfies' '(' :)
     or $state[$p:lk] = 17621                               (: 'self' '(' :)
     or $state[$p:lk] = 17624                               (: 'sentences' '(' :)
     or $state[$p:lk] = 17627                               (: 'some' '(' :)
     or $state[$p:lk] = 17628                               (: 'stable' '(' :)
     or $state[$p:lk] = 17629                               (: 'start' '(' :)
     or $state[$p:lk] = 17639                               (: 'times' '(' :)
     or $state[$p:lk] = 17640                               (: 'to' '(' :)
     or $state[$p:lk] = 17641                               (: 'treat' '(' :)
     or $state[$p:lk] = 17642                               (: 'try' '(' :)
     or $state[$p:lk] = 17646                               (: 'union' '(' :)
     or $state[$p:lk] = 17647                               (: 'unordered' '(' :)
     or $state[$p:lk] = 17650                               (: 'validate' '(' :)
     or $state[$p:lk] = 17656                               (: 'where' '(' :)
     or $state[$p:lk] = 17659                               (: 'with' '(' :)
     or $state[$p:lk] = 17662                               (: 'words' '(' :)
     or $state[$p:lk] = 17663                               (: 'xquery' '(' :)
     or $state[$p:lk] = 37969                               (: 'attribute' 'ancestor' :)
     or $state[$p:lk] = 38004                               (: 'element' 'ancestor' :)
     or $state[$p:lk] = 38481                               (: 'attribute' 'ancestor-or-self' :)
     or $state[$p:lk] = 38516                               (: 'element' 'ancestor-or-self' :)
     or $state[$p:lk] = 41553                               (: 'attribute' 'attribute' :)
     or $state[$p:lk] = 41588                               (: 'element' 'attribute' :)
     or $state[$p:lk] = 43089                               (: 'attribute' 'binary' :)
     or $state[$p:lk] = 43124                               (: 'element' 'binary' :)
     or $state[$p:lk] = 46161                               (: 'attribute' 'catch' :)
     or $state[$p:lk] = 46196                               (: 'element' 'catch' :)
     or $state[$p:lk] = 46673                               (: 'attribute' 'child' :)
     or $state[$p:lk] = 46708                               (: 'element' 'child' :)
     or $state[$p:lk] = 47697                               (: 'attribute' 'comment' :)
     or $state[$p:lk] = 47732                               (: 'element' 'comment' :)
     or $state[$p:lk] = 50257                               (: 'attribute' 'copy' :)
     or $state[$p:lk] = 50292                               (: 'element' 'copy' :)
     or $state[$p:lk] = 52817                               (: 'attribute' 'declare' :)
     or $state[$p:lk] = 52852                               (: 'element' 'declare' :)
     or $state[$p:lk] = 53841                               (: 'attribute' 'delete' :)
     or $state[$p:lk] = 53876                               (: 'element' 'delete' :)
     or $state[$p:lk] = 54353                               (: 'attribute' 'descendant' :)
     or $state[$p:lk] = 54388                               (: 'element' 'descendant' :)
     or $state[$p:lk] = 54865                               (: 'attribute' 'descendant-or-self' :)
     or $state[$p:lk] = 54900                               (: 'element' 'descendant-or-self' :)
     or $state[$p:lk] = 58449                               (: 'attribute' 'document' :)
     or $state[$p:lk] = 58484                               (: 'element' 'document' :)
     or $state[$p:lk] = 58961                               (: 'attribute' 'document-node' :)
     or $state[$p:lk] = 58996                               (: 'element' 'document-node' :)
     or $state[$p:lk] = 59473                               (: 'attribute' 'element' :)
     or $state[$p:lk] = 59508                               (: 'element' 'element' :)
     or $state[$p:lk] = 61009                               (: 'attribute' 'empty-sequence' :)
     or $state[$p:lk] = 61044                               (: 'element' 'empty-sequence' :)
     or $state[$p:lk] = 63569                               (: 'attribute' 'every' :)
     or $state[$p:lk] = 63604                               (: 'element' 'every' :)
     or $state[$p:lk] = 65617                               (: 'attribute' 'first' :)
     or $state[$p:lk] = 65652                               (: 'element' 'first' :)
     or $state[$p:lk] = 66129                               (: 'attribute' 'following' :)
     or $state[$p:lk] = 66164                               (: 'element' 'following' :)
     or $state[$p:lk] = 66641                               (: 'attribute' 'following-sibling' :)
     or $state[$p:lk] = 66676                               (: 'element' 'following-sibling' :)
     or $state[$p:lk] = 70737                               (: 'attribute' 'function' :)
     or $state[$p:lk] = 70772                               (: 'element' 'function' :)
     or $state[$p:lk] = 74321                               (: 'attribute' 'if' :)
     or $state[$p:lk] = 74356                               (: 'element' 'if' :)
     or $state[$p:lk] = 74833                               (: 'attribute' 'import' :)
     or $state[$p:lk] = 74868                               (: 'element' 'import' :)
     or $state[$p:lk] = 77393                               (: 'attribute' 'insert' :)
     or $state[$p:lk] = 77428                               (: 'element' 'insert' :)
     or $state[$p:lk] = 79953                               (: 'attribute' 'item' :)
     or $state[$p:lk] = 79988                               (: 'element' 'item' :)
     or $state[$p:lk] = 80977                               (: 'attribute' 'last' :)
     or $state[$p:lk] = 81012                               (: 'element' 'last' :)
     or $state[$p:lk] = 86609                               (: 'attribute' 'module' :)
     or $state[$p:lk] = 86644                               (: 'element' 'module' :)
     or $state[$p:lk] = 87633                               (: 'attribute' 'namespace' :)
     or $state[$p:lk] = 87668                               (: 'element' 'namespace' :)
     or $state[$p:lk] = 88145                               (: 'attribute' 'namespace-node' :)
     or $state[$p:lk] = 88180                               (: 'element' 'namespace-node' :)
     or $state[$p:lk] = 91217                               (: 'attribute' 'node' :)
     or $state[$p:lk] = 91252                               (: 'element' 'node' :)
     or $state[$p:lk] = 95825                               (: 'attribute' 'ordered' :)
     or $state[$p:lk] = 95860                               (: 'element' 'ordered' :)
     or $state[$p:lk] = 97873                               (: 'attribute' 'parent' :)
     or $state[$p:lk] = 97908                               (: 'element' 'parent' :)
     or $state[$p:lk] = 100433                              (: 'attribute' 'preceding' :)
     or $state[$p:lk] = 100468                              (: 'element' 'preceding' :)
     or $state[$p:lk] = 100945                              (: 'attribute' 'preceding-sibling' :)
     or $state[$p:lk] = 100980                              (: 'element' 'preceding-sibling' :)
     or $state[$p:lk] = 102481                              (: 'attribute' 'private' :)
     or $state[$p:lk] = 102516                              (: 'element' 'private' :)
     or $state[$p:lk] = 102993                              (: 'attribute' 'processing-instruction' :)
     or $state[$p:lk] = 103028                              (: 'element' 'processing-instruction' :)
     or $state[$p:lk] = 103505                              (: 'attribute' 'property' :)
     or $state[$p:lk] = 103540                              (: 'element' 'property' :)
     or $state[$p:lk] = 104529                              (: 'attribute' 'rename' :)
     or $state[$p:lk] = 104564                              (: 'element' 'rename' :)
     or $state[$p:lk] = 105041                              (: 'attribute' 'replace' :)
     or $state[$p:lk] = 105076                              (: 'element' 'replace' :)
     or $state[$p:lk] = 108113                              (: 'attribute' 'schema-attribute' :)
     or $state[$p:lk] = 108148                              (: 'element' 'schema-attribute' :)
     or $state[$p:lk] = 108625                              (: 'attribute' 'schema-element' :)
     or $state[$p:lk] = 108660                              (: 'element' 'schema-element' :)
     or $state[$p:lk] = 109137                              (: 'attribute' 'self' :)
     or $state[$p:lk] = 109172                              (: 'element' 'self' :)
     or $state[$p:lk] = 112209                              (: 'attribute' 'some' :)
     or $state[$p:lk] = 112244                              (: 'element' 'some' :)
     or $state[$p:lk] = 116305                              (: 'attribute' 'switch' :)
     or $state[$p:lk] = 116340                              (: 'element' 'switch' :)
     or $state[$p:lk] = 116817                              (: 'attribute' 'text' :)
     or $state[$p:lk] = 116852                              (: 'element' 'text' :)
     or $state[$p:lk] = 119889                              (: 'attribute' 'try' :)
     or $state[$p:lk] = 119924                              (: 'element' 'try' :)
     or $state[$p:lk] = 119979                              (: 'namespace' 'try' :)
     or $state[$p:lk] = 120009                              (: 'processing-instruction' 'try' :)
     or $state[$p:lk] = 121425                              (: 'attribute' 'typeswitch' :)
     or $state[$p:lk] = 121460                              (: 'element' 'typeswitch' :)
     or $state[$p:lk] = 122449                              (: 'attribute' 'unordered' :)
     or $state[$p:lk] = 122484                              (: 'element' 'unordered' :)
     or $state[$p:lk] = 123985                              (: 'attribute' 'validate' :)
     or $state[$p:lk] = 124020                              (: 'element' 'validate' :)
     or $state[$p:lk] = 130641                              (: 'attribute' 'xquery' :)
     or $state[$p:lk] = 130676                              (: 'element' 'xquery' :)
     or $state[$p:lk] = 131665                              (: 'attribute' '{' :)
     or $state[$p:lk] = 131668                              (: 'binary' '{' :)
     or $state[$p:lk] = 131677                              (: 'comment' '{' :)
     or $state[$p:lk] = 131698                              (: 'document' '{' :)
     or $state[$p:lk] = 131700                              (: 'element' '{' :)
     or $state[$p:lk] = 131755                              (: 'namespace' '{' :)
     or $state[$p:lk] = 131771                              (: 'ordered' '{' :)
     or $state[$p:lk] = 131785                              (: 'processing-instruction' '{' :)
     or $state[$p:lk] = 131812                              (: 'text' '{' :)
     or $state[$p:lk] = 131823                              (: 'unordered' '{' :)
     or $state[$p:lk] = 67407441                            (: 'attribute' 'after' '{' :)
     or $state[$p:lk] = 67407476                            (: 'element' 'after' '{' :)
     or $state[$p:lk] = 67407531                            (: 'namespace' 'after' '{' :)
     or $state[$p:lk] = 67407561                            (: 'processing-instruction' 'after' '{' :)
     or $state[$p:lk] = 67410001                            (: 'attribute' 'and' '{' :)
     or $state[$p:lk] = 67410036                            (: 'element' 'and' '{' :)
     or $state[$p:lk] = 67410091                            (: 'namespace' 'and' '{' :)
     or $state[$p:lk] = 67410121                            (: 'processing-instruction' 'and' '{' :)
     or $state[$p:lk] = 67411025                            (: 'attribute' 'as' '{' :)
     or $state[$p:lk] = 67411060                            (: 'element' 'as' '{' :)
     or $state[$p:lk] = 67411115                            (: 'namespace' 'as' '{' :)
     or $state[$p:lk] = 67411145                            (: 'processing-instruction' 'as' '{' :)
     or $state[$p:lk] = 67411537                            (: 'attribute' 'ascending' '{' :)
     or $state[$p:lk] = 67411572                            (: 'element' 'ascending' '{' :)
     or $state[$p:lk] = 67411627                            (: 'namespace' 'ascending' '{' :)
     or $state[$p:lk] = 67411657                            (: 'processing-instruction' 'ascending' '{' :)
     or $state[$p:lk] = 67413585                            (: 'attribute' 'before' '{' :)
     or $state[$p:lk] = 67413620                            (: 'element' 'before' '{' :)
     or $state[$p:lk] = 67413675                            (: 'namespace' 'before' '{' :)
     or $state[$p:lk] = 67413705                            (: 'processing-instruction' 'before' '{' :)
     or $state[$p:lk] = 67415633                            (: 'attribute' 'case' '{' :)
     or $state[$p:lk] = 67415668                            (: 'element' 'case' '{' :)
     or $state[$p:lk] = 67415723                            (: 'namespace' 'case' '{' :)
     or $state[$p:lk] = 67415753                            (: 'processing-instruction' 'case' '{' :)
     or $state[$p:lk] = 67416145                            (: 'attribute' 'cast' '{' :)
     or $state[$p:lk] = 67416180                            (: 'element' 'cast' '{' :)
     or $state[$p:lk] = 67416235                            (: 'namespace' 'cast' '{' :)
     or $state[$p:lk] = 67416265                            (: 'processing-instruction' 'cast' '{' :)
     or $state[$p:lk] = 67416657                            (: 'attribute' 'castable' '{' :)
     or $state[$p:lk] = 67416692                            (: 'element' 'castable' '{' :)
     or $state[$p:lk] = 67416747                            (: 'namespace' 'castable' '{' :)
     or $state[$p:lk] = 67416777                            (: 'processing-instruction' 'castable' '{' :)
     or $state[$p:lk] = 67418193                            (: 'attribute' 'collation' '{' :)
     or $state[$p:lk] = 67418228                            (: 'element' 'collation' '{' :)
     or $state[$p:lk] = 67418283                            (: 'namespace' 'collation' '{' :)
     or $state[$p:lk] = 67418313                            (: 'processing-instruction' 'collation' '{' :)
     or $state[$p:lk] = 67419729                            (: 'attribute' 'contains' '{' :)
     or $state[$p:lk] = 67419764                            (: 'element' 'contains' '{' :)
     or $state[$p:lk] = 67419819                            (: 'namespace' 'contains' '{' :)
     or $state[$p:lk] = 67419849                            (: 'processing-instruction' 'contains' '{' :)
     or $state[$p:lk] = 67422289                            (: 'attribute' 'count' '{' :)
     or $state[$p:lk] = 67422324                            (: 'element' 'count' '{' :)
     or $state[$p:lk] = 67422379                            (: 'namespace' 'count' '{' :)
     or $state[$p:lk] = 67422409                            (: 'processing-instruction' 'count' '{' :)
     or $state[$p:lk] = 67424337                            (: 'attribute' 'default' '{' :)
     or $state[$p:lk] = 67424372                            (: 'element' 'default' '{' :)
     or $state[$p:lk] = 67424427                            (: 'namespace' 'default' '{' :)
     or $state[$p:lk] = 67424457                            (: 'processing-instruction' 'default' '{' :)
     or $state[$p:lk] = 67426385                            (: 'attribute' 'descending' '{' :)
     or $state[$p:lk] = 67426420                            (: 'element' 'descending' '{' :)
     or $state[$p:lk] = 67426475                            (: 'namespace' 'descending' '{' :)
     or $state[$p:lk] = 67426505                            (: 'processing-instruction' 'descending' '{' :)
     or $state[$p:lk] = 67428945                            (: 'attribute' 'div' '{' :)
     or $state[$p:lk] = 67428980                            (: 'element' 'div' '{' :)
     or $state[$p:lk] = 67429035                            (: 'namespace' 'div' '{' :)
     or $state[$p:lk] = 67429065                            (: 'processing-instruction' 'div' '{' :)
     or $state[$p:lk] = 67430993                            (: 'attribute' 'else' '{' :)
     or $state[$p:lk] = 67431028                            (: 'element' 'else' '{' :)
     or $state[$p:lk] = 67431083                            (: 'namespace' 'else' '{' :)
     or $state[$p:lk] = 67431113                            (: 'processing-instruction' 'else' '{' :)
     or $state[$p:lk] = 67431505                            (: 'attribute' 'empty' '{' :)
     or $state[$p:lk] = 67431540                            (: 'element' 'empty' '{' :)
     or $state[$p:lk] = 67431595                            (: 'namespace' 'empty' '{' :)
     or $state[$p:lk] = 67431625                            (: 'processing-instruction' 'empty' '{' :)
     or $state[$p:lk] = 67433041                            (: 'attribute' 'end' '{' :)
     or $state[$p:lk] = 67433076                            (: 'element' 'end' '{' :)
     or $state[$p:lk] = 67433131                            (: 'namespace' 'end' '{' :)
     or $state[$p:lk] = 67433161                            (: 'processing-instruction' 'end' '{' :)
     or $state[$p:lk] = 67434065                            (: 'attribute' 'eq' '{' :)
     or $state[$p:lk] = 67434100                            (: 'element' 'eq' '{' :)
     or $state[$p:lk] = 67434155                            (: 'namespace' 'eq' '{' :)
     or $state[$p:lk] = 67434185                            (: 'processing-instruction' 'eq' '{' :)
     or $state[$p:lk] = 67435601                            (: 'attribute' 'except' '{' :)
     or $state[$p:lk] = 67435636                            (: 'element' 'except' '{' :)
     or $state[$p:lk] = 67435691                            (: 'namespace' 'except' '{' :)
     or $state[$p:lk] = 67435721                            (: 'processing-instruction' 'except' '{' :)
     or $state[$p:lk] = 67438161                            (: 'attribute' 'for' '{' :)
     or $state[$p:lk] = 67438196                            (: 'element' 'for' '{' :)
     or $state[$p:lk] = 67438251                            (: 'namespace' 'for' '{' :)
     or $state[$p:lk] = 67438281                            (: 'processing-instruction' 'for' '{' :)
     or $state[$p:lk] = 67442257                            (: 'attribute' 'ge' '{' :)
     or $state[$p:lk] = 67442292                            (: 'element' 'ge' '{' :)
     or $state[$p:lk] = 67442347                            (: 'namespace' 'ge' '{' :)
     or $state[$p:lk] = 67442377                            (: 'processing-instruction' 'ge' '{' :)
     or $state[$p:lk] = 67443281                            (: 'attribute' 'group' '{' :)
     or $state[$p:lk] = 67443316                            (: 'element' 'group' '{' :)
     or $state[$p:lk] = 67443371                            (: 'namespace' 'group' '{' :)
     or $state[$p:lk] = 67443401                            (: 'processing-instruction' 'group' '{' :)
     or $state[$p:lk] = 67444305                            (: 'attribute' 'gt' '{' :)
     or $state[$p:lk] = 67444340                            (: 'element' 'gt' '{' :)
     or $state[$p:lk] = 67444395                            (: 'namespace' 'gt' '{' :)
     or $state[$p:lk] = 67444425                            (: 'processing-instruction' 'gt' '{' :)
     or $state[$p:lk] = 67444817                            (: 'attribute' 'idiv' '{' :)
     or $state[$p:lk] = 67444852                            (: 'element' 'idiv' '{' :)
     or $state[$p:lk] = 67444907                            (: 'namespace' 'idiv' '{' :)
     or $state[$p:lk] = 67444937                            (: 'processing-instruction' 'idiv' '{' :)
     or $state[$p:lk] = 67448913                            (: 'attribute' 'instance' '{' :)
     or $state[$p:lk] = 67448948                            (: 'element' 'instance' '{' :)
     or $state[$p:lk] = 67449003                            (: 'namespace' 'instance' '{' :)
     or $state[$p:lk] = 67449033                            (: 'processing-instruction' 'instance' '{' :)
     or $state[$p:lk] = 67449425                            (: 'attribute' 'intersect' '{' :)
     or $state[$p:lk] = 67449460                            (: 'element' 'intersect' '{' :)
     or $state[$p:lk] = 67449515                            (: 'namespace' 'intersect' '{' :)
     or $state[$p:lk] = 67449545                            (: 'processing-instruction' 'intersect' '{' :)
     or $state[$p:lk] = 67449937                            (: 'attribute' 'into' '{' :)
     or $state[$p:lk] = 67449972                            (: 'element' 'into' '{' :)
     or $state[$p:lk] = 67450027                            (: 'namespace' 'into' '{' :)
     or $state[$p:lk] = 67450057                            (: 'processing-instruction' 'into' '{' :)
     or $state[$p:lk] = 67450449                            (: 'attribute' 'is' '{' :)
     or $state[$p:lk] = 67450484                            (: 'element' 'is' '{' :)
     or $state[$p:lk] = 67450539                            (: 'namespace' 'is' '{' :)
     or $state[$p:lk] = 67450569                            (: 'processing-instruction' 'is' '{' :)
     or $state[$p:lk] = 67453009                            (: 'attribute' 'le' '{' :)
     or $state[$p:lk] = 67453044                            (: 'element' 'le' '{' :)
     or $state[$p:lk] = 67453099                            (: 'namespace' 'le' '{' :)
     or $state[$p:lk] = 67453129                            (: 'processing-instruction' 'le' '{' :)
     or $state[$p:lk] = 67454033                            (: 'attribute' 'let' '{' :)
     or $state[$p:lk] = 67454068                            (: 'element' 'let' '{' :)
     or $state[$p:lk] = 67454123                            (: 'namespace' 'let' '{' :)
     or $state[$p:lk] = 67454153                            (: 'processing-instruction' 'let' '{' :)
     or $state[$p:lk] = 67455569                            (: 'attribute' 'lt' '{' :)
     or $state[$p:lk] = 67455604                            (: 'element' 'lt' '{' :)
     or $state[$p:lk] = 67455659                            (: 'namespace' 'lt' '{' :)
     or $state[$p:lk] = 67455689                            (: 'processing-instruction' 'lt' '{' :)
     or $state[$p:lk] = 67456593                            (: 'attribute' 'mod' '{' :)
     or $state[$p:lk] = 67456628                            (: 'element' 'mod' '{' :)
     or $state[$p:lk] = 67456683                            (: 'namespace' 'mod' '{' :)
     or $state[$p:lk] = 67456713                            (: 'processing-instruction' 'mod' '{' :)
     or $state[$p:lk] = 67457105                            (: 'attribute' 'modify' '{' :)
     or $state[$p:lk] = 67457140                            (: 'element' 'modify' '{' :)
     or $state[$p:lk] = 67457195                            (: 'namespace' 'modify' '{' :)
     or $state[$p:lk] = 67457225                            (: 'processing-instruction' 'modify' '{' :)
     or $state[$p:lk] = 67459665                            (: 'attribute' 'ne' '{' :)
     or $state[$p:lk] = 67459700                            (: 'element' 'ne' '{' :)
     or $state[$p:lk] = 67459755                            (: 'namespace' 'ne' '{' :)
     or $state[$p:lk] = 67459785                            (: 'processing-instruction' 'ne' '{' :)
     or $state[$p:lk] = 67464785                            (: 'attribute' 'only' '{' :)
     or $state[$p:lk] = 67464820                            (: 'element' 'only' '{' :)
     or $state[$p:lk] = 67464875                            (: 'namespace' 'only' '{' :)
     or $state[$p:lk] = 67464905                            (: 'processing-instruction' 'only' '{' :)
     or $state[$p:lk] = 67465809                            (: 'attribute' 'or' '{' :)
     or $state[$p:lk] = 67465844                            (: 'element' 'or' '{' :)
     or $state[$p:lk] = 67465899                            (: 'namespace' 'or' '{' :)
     or $state[$p:lk] = 67465929                            (: 'processing-instruction' 'or' '{' :)
     or $state[$p:lk] = 67466321                            (: 'attribute' 'order' '{' :)
     or $state[$p:lk] = 67466356                            (: 'element' 'order' '{' :)
     or $state[$p:lk] = 67466411                            (: 'namespace' 'order' '{' :)
     or $state[$p:lk] = 67466441                            (: 'processing-instruction' 'order' '{' :)
     or $state[$p:lk] = 67468369                            (: 'attribute' 'paragraphs' '{' :)
     or $state[$p:lk] = 67468404                            (: 'element' 'paragraphs' '{' :)
     or $state[$p:lk] = 67468459                            (: 'namespace' 'paragraphs' '{' :)
     or $state[$p:lk] = 67468489                            (: 'processing-instruction' 'paragraphs' '{' :)
     or $state[$p:lk] = 67476561                            (: 'attribute' 'return' '{' :)
     or $state[$p:lk] = 67476596                            (: 'element' 'return' '{' :)
     or $state[$p:lk] = 67476651                            (: 'namespace' 'return' '{' :)
     or $state[$p:lk] = 67476681                            (: 'processing-instruction' 'return' '{' :)
     or $state[$p:lk] = 67478097                            (: 'attribute' 'satisfies' '{' :)
     or $state[$p:lk] = 67478132                            (: 'element' 'satisfies' '{' :)
     or $state[$p:lk] = 67478187                            (: 'namespace' 'satisfies' '{' :)
     or $state[$p:lk] = 67478217                            (: 'processing-instruction' 'satisfies' '{' :)
     or $state[$p:lk] = 67481681                            (: 'attribute' 'sentences' '{' :)
     or $state[$p:lk] = 67481716                            (: 'element' 'sentences' '{' :)
     or $state[$p:lk] = 67481771                            (: 'namespace' 'sentences' '{' :)
     or $state[$p:lk] = 67481801                            (: 'processing-instruction' 'sentences' '{' :)
     or $state[$p:lk] = 67483729                            (: 'attribute' 'stable' '{' :)
     or $state[$p:lk] = 67483764                            (: 'element' 'stable' '{' :)
     or $state[$p:lk] = 67483819                            (: 'namespace' 'stable' '{' :)
     or $state[$p:lk] = 67483849                            (: 'processing-instruction' 'stable' '{' :)
     or $state[$p:lk] = 67484241                            (: 'attribute' 'start' '{' :)
     or $state[$p:lk] = 67484276                            (: 'element' 'start' '{' :)
     or $state[$p:lk] = 67484331                            (: 'namespace' 'start' '{' :)
     or $state[$p:lk] = 67484361                            (: 'processing-instruction' 'start' '{' :)
     or $state[$p:lk] = 67489361                            (: 'attribute' 'times' '{' :)
     or $state[$p:lk] = 67489396                            (: 'element' 'times' '{' :)
     or $state[$p:lk] = 67489451                            (: 'namespace' 'times' '{' :)
     or $state[$p:lk] = 67489481                            (: 'processing-instruction' 'times' '{' :)
     or $state[$p:lk] = 67489873                            (: 'attribute' 'to' '{' :)
     or $state[$p:lk] = 67489908                            (: 'element' 'to' '{' :)
     or $state[$p:lk] = 67489963                            (: 'namespace' 'to' '{' :)
     or $state[$p:lk] = 67489993                            (: 'processing-instruction' 'to' '{' :)
     or $state[$p:lk] = 67490385                            (: 'attribute' 'treat' '{' :)
     or $state[$p:lk] = 67490420                            (: 'element' 'treat' '{' :)
     or $state[$p:lk] = 67490475                            (: 'namespace' 'treat' '{' :)
     or $state[$p:lk] = 67490505                            (: 'processing-instruction' 'treat' '{' :)
     or $state[$p:lk] = 67492945                            (: 'attribute' 'union' '{' :)
     or $state[$p:lk] = 67492980                            (: 'element' 'union' '{' :)
     or $state[$p:lk] = 67493035                            (: 'namespace' 'union' '{' :)
     or $state[$p:lk] = 67493065                            (: 'processing-instruction' 'union' '{' :)
     or $state[$p:lk] = 67498065                            (: 'attribute' 'where' '{' :)
     or $state[$p:lk] = 67498100                            (: 'element' 'where' '{' :)
     or $state[$p:lk] = 67498155                            (: 'namespace' 'where' '{' :)
     or $state[$p:lk] = 67498185                            (: 'processing-instruction' 'where' '{' :)
     or $state[$p:lk] = 67499601                            (: 'attribute' 'with' '{' :)
     or $state[$p:lk] = 67499636                            (: 'element' 'with' '{' :)
     or $state[$p:lk] = 67499691                            (: 'namespace' 'with' '{' :)
     or $state[$p:lk] = 67499721                            (: 'processing-instruction' 'with' '{' :)
     or $state[$p:lk] = 67501137                            (: 'attribute' 'words' '{' :)
     or $state[$p:lk] = 67501172                            (: 'element' 'words' '{' :)
     or $state[$p:lk] = 67501227                            (: 'namespace' 'words' '{' :)
     or $state[$p:lk] = 67501257) then                      (: 'processing-instruction' 'words' '{' :)
      let $state := p:try-PostfixExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-AxisStep($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production RelativePathExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelativePathExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 26                                 (: '!' :)
    and $state[$p:l1] != 46                                 (: '/' :)
    and $state[$p:l1] != 47) then                           (: '//' :)
      $state
    else
      let $state :=
        if ($state[$p:l1] = 46) then                        (: '/' :)
          let $state := p:shift(46, $input, $state)         (: '/' :)
          return $state
        else if ($state[$p:l1] = 47) then                   (: '//' :)
          let $state := p:shift(47, $input, $state)         (: '//' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(26, $input, $state)         (: '!' :)
          return $state
      let $state := p:lookahead1W(240, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | ('(' ':') | '.' | '..' |
                                                               '<' | '<!--' | '<?' | '@' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-StepExpr($input, $state)
      return p:parse-RelativePathExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production RelativePathExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-RelativePathExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 26                                 (: '!' :)
    and $state[$p:l1] != 46                                 (: '/' :)
    and $state[$p:l1] != 47) then                           (: '//' :)
      $state
    else
      let $state :=
        if ($state[$p:l1] = 46) then                        (: '/' :)
          let $state := p:shiftT(46, $input, $state)        (: '/' :)
          return $state
        else if ($state[$p:l1] = 47) then                   (: '//' :)
          let $state := p:shiftT(47, $input, $state)        (: '//' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shiftT(26, $input, $state)        (: '!' :)
          return $state
      let $state := p:lookahead1W(240, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | ('(' ':') | '.' | '..' |
                                                               '<' | '<!--' | '<?' | '@' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-StepExpr($input, $state)
      return p:try-RelativePathExpr-1($input, $state)
};

(:~
 : Parse RelativePathExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelativePathExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-StepExpr($input, $state)
  let $state := p:parse-RelativePathExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "RelativePathExpr", $count, $begin, $end)
};

(:~
 : Try parsing RelativePathExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-RelativePathExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-StepExpr($input, $state)
  let $state := p:try-RelativePathExpr-1($input, $state)
  return $state
};

(:~
 : Parse PathExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PathExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 46) then                            (: '/' :)
      let $state := p:shift(46, $input, $state)             (: '/' :)
      let $state := p:lookahead1W(252, $input, $state)      (: EOF | Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '!=' | '$' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '.' | '..' | ';' | '<' | '<!--' |
                                                               '<<' | '<=' | '<?' | '=' | '>' | '>=' | '>>' | '@' |
                                                               ']' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' |
                                                               '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:l1] = 1                               (: EOF :)
         or $state[$p:l1] = 27                              (: '!=' :)
         or $state[$p:l1] = 37                              (: ')' :)
         or $state[$p:l1] = 38                              (: '*' :)
         or $state[$p:l1] = 40                              (: '+' :)
         or $state[$p:l1] = 41                              (: ',' :)
         or $state[$p:l1] = 42                              (: '-' :)
         or $state[$p:l1] = 52                              (: ';' :)
         or $state[$p:l1] = 57                              (: '<<' :)
         or $state[$p:l1] = 58                              (: '<=' :)
         or $state[$p:l1] = 60                              (: '=' :)
         or $state[$p:l1] = 61                              (: '>' :)
         or $state[$p:l1] = 62                              (: '>=' :)
         or $state[$p:l1] = 63                              (: '>>' :)
         or $state[$p:l1] = 69                              (: ']' :)
         or $state[$p:l1] = 259                             (: '|' :)
         or $state[$p:l1] = 260                             (: '||' :)
         or $state[$p:l1] = 261) then                       (: '}' :)
          $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:whitespace($input, $state)
          let $state := p:parse-RelativePathExpr($input, $state)
          return $state
      return $state
    else if ($state[$p:l1] = 47) then                       (: '//' :)
      let $state := p:shift(47, $input, $state)             (: '//' :)
      let $state := p:lookahead1W(240, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | ('(' ':') | '.' | '..' |
                                                               '<' | '<!--' | '<?' | '@' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-RelativePathExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-RelativePathExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PathExpr", $count, $begin, $end)
};

(:~
 : Try parsing PathExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-PathExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 46) then                            (: '/' :)
      let $state := p:shiftT(46, $input, $state)            (: '/' :)
      let $state := p:lookahead1W(252, $input, $state)      (: EOF | Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '!=' | '$' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '.' | '..' | ';' | '<' | '<!--' |
                                                               '<<' | '<=' | '<?' | '=' | '>' | '>=' | '>>' | '@' |
                                                               ']' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' |
                                                               '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:l1] = 1                               (: EOF :)
         or $state[$p:l1] = 27                              (: '!=' :)
         or $state[$p:l1] = 37                              (: ')' :)
         or $state[$p:l1] = 38                              (: '*' :)
         or $state[$p:l1] = 40                              (: '+' :)
         or $state[$p:l1] = 41                              (: ',' :)
         or $state[$p:l1] = 42                              (: '-' :)
         or $state[$p:l1] = 52                              (: ';' :)
         or $state[$p:l1] = 57                              (: '<<' :)
         or $state[$p:l1] = 58                              (: '<=' :)
         or $state[$p:l1] = 60                              (: '=' :)
         or $state[$p:l1] = 61                              (: '>' :)
         or $state[$p:l1] = 62                              (: '>=' :)
         or $state[$p:l1] = 63                              (: '>>' :)
         or $state[$p:l1] = 69                              (: ']' :)
         or $state[$p:l1] = 259                             (: '|' :)
         or $state[$p:l1] = 260                             (: '||' :)
         or $state[$p:l1] = 261) then                       (: '}' :)
          $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:try-RelativePathExpr($input, $state)
          return $state
      return $state
    else if ($state[$p:l1] = 47) then                       (: '//' :)
      let $state := p:shiftT(47, $input, $state)            (: '//' :)
      let $state := p:lookahead1W(240, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | ('(' ':') | '.' | '..' |
                                                               '<' | '<!--' | '<?' | '@' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-RelativePathExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-RelativePathExpr($input, $state)
      return $state
  return $state
};

(:~
 : Parse ValidationMode.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValidationMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 159) then                           (: 'lax' :)
      let $state := p:shift(159, $input, $state)            (: 'lax' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(224, $input, $state)            (: 'strict' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ValidationMode", $count, $begin, $end)
};

(:~
 : Try parsing ValidationMode.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ValidationMode($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 159) then                           (: 'lax' :)
      let $state := p:shiftT(159, $input, $state)           (: 'lax' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(224, $input, $state)           (: 'strict' :)
      return $state
  return $state
};

(:~
 : Parse ValidateExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValidateExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(242, $input, $state)                (: 'validate' :)
  let $state := p:lookahead1W(165, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'full' | 'lax' | 'strict' |
                                                               'type' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 137                           (: 'full' :)
         and $state[$p:l1] != 257) then                     (: '{' :)
      let $state :=
        if ($state[$p:l1] = 159                             (: 'lax' :)
         or $state[$p:l1] = 224) then                       (: 'strict' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-ValidationMode($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state :=
            if ($state[$p:l1] = 78) then                    (: 'as' :)
              let $state := p:shift(78, $input, $state)     (: 'as' :)
              return $state
            else if ($state[$p:error]) then
              $state
            else
              let $state := p:shift(236, $input, $state)    (: 'type' :)
              return $state
          let $state := p:lookahead1W(229, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-TypeName($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(112, $input, $state)          (: S^WS | ('(' ':') | 'full' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 137) then                      (: 'full' :)
      let $state := p:shift(137, $input, $state)            (: 'full' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(257, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(261, $input, $state)                (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ValidateExpr", $count, $begin, $end)
};

(:~
 : Try parsing ValidateExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ValidateExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(242, $input, $state)               (: 'validate' :)
  let $state := p:lookahead1W(165, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'full' | 'lax' | 'strict' |
                                                               'type' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 137                           (: 'full' :)
         and $state[$p:l1] != 257) then                     (: '{' :)
      let $state :=
        if ($state[$p:l1] = 159                             (: 'lax' :)
         or $state[$p:l1] = 224) then                       (: 'strict' :)
          let $state := p:try-ValidationMode($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state :=
            if ($state[$p:l1] = 78) then                    (: 'as' :)
              let $state := p:shiftT(78, $input, $state)    (: 'as' :)
              return $state
            else if ($state[$p:error]) then
              $state
            else
              let $state := p:shiftT(236, $input, $state)   (: 'type' :)
              return $state
          let $state := p:lookahead1W(229, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
          let $state := p:try-TypeName($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(112, $input, $state)          (: S^WS | ('(' ':') | 'full' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 137) then                      (: 'full' :)
      let $state := p:shiftT(137, $input, $state)           (: 'full' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shiftT(257, $input, $state)               (: '{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-Expr($input, $state)
  let $state := p:shiftT(261, $input, $state)               (: '}' :)
  return $state
};

(:~
 : Parse ValueExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValueExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 242) then                           (: 'validate' :)
      let $state := p:lookahead2W(225, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'full' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'lax' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'strict' | 'times' | 'to' |
                                                               'treat' | 'type' | 'union' | 'where' | 'with' | 'words' |
                                                               '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:lk] = 40178) then                     (: 'validate' 'as' :)
          let $state := p:lookahead3W(241, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 1875186                        (: 'validate' 'as' URIQualifiedName :)
          or $state[$p:lk] = 5807346                        (: 'validate' 'as' QName^Token :)
          or $state[$p:lk] = 18652402                       (: 'validate' 'as' 'after' :)
          or $state[$p:lk] = 19438834                       (: 'validate' 'as' 'ancestor' :)
          or $state[$p:lk] = 19700978                       (: 'validate' 'as' 'ancestor-or-self' :)
          or $state[$p:lk] = 19963122                       (: 'validate' 'as' 'and' :)
          or $state[$p:lk] = 20487410                       (: 'validate' 'as' 'as' :)
          or $state[$p:lk] = 20749554                       (: 'validate' 'as' 'ascending' :)
          or $state[$p:lk] = 21273842                       (: 'validate' 'as' 'attribute' :)
          or $state[$p:lk] = 21798130                       (: 'validate' 'as' 'before' :)
          or $state[$p:lk] = 22060274                       (: 'validate' 'as' 'binary' :)
          or $state[$p:lk] = 22846706                       (: 'validate' 'as' 'case' :)
          or $state[$p:lk] = 23108850                       (: 'validate' 'as' 'cast' :)
          or $state[$p:lk] = 23370994                       (: 'validate' 'as' 'castable' :)
          or $state[$p:lk] = 23633138                       (: 'validate' 'as' 'catch' :)
          or $state[$p:lk] = 23895282                       (: 'validate' 'as' 'child' :)
          or $state[$p:lk] = 24157426                       (: 'validate' 'as' 'collation' :)
          or $state[$p:lk] = 24419570                       (: 'validate' 'as' 'comment' :)
          or $state[$p:lk] = 24943858                       (: 'validate' 'as' 'contains' :)
          or $state[$p:lk] = 25730290                       (: 'validate' 'as' 'copy' :)
          or $state[$p:lk] = 26254578                       (: 'validate' 'as' 'count' :)
          or $state[$p:lk] = 27041010                       (: 'validate' 'as' 'declare' :)
          or $state[$p:lk] = 27303154                       (: 'validate' 'as' 'default' :)
          or $state[$p:lk] = 27565298                       (: 'validate' 'as' 'delete' :)
          or $state[$p:lk] = 27827442                       (: 'validate' 'as' 'descendant' :)
          or $state[$p:lk] = 28089586                       (: 'validate' 'as' 'descendant-or-self' :)
          or $state[$p:lk] = 28351730                       (: 'validate' 'as' 'descending' :)
          or $state[$p:lk] = 29662450                       (: 'validate' 'as' 'div' :)
          or $state[$p:lk] = 29924594                       (: 'validate' 'as' 'document' :)
          or $state[$p:lk] = 30186738                       (: 'validate' 'as' 'document-node' :)
          or $state[$p:lk] = 30448882                       (: 'validate' 'as' 'element' :)
          or $state[$p:lk] = 30711026                       (: 'validate' 'as' 'else' :)
          or $state[$p:lk] = 30973170                       (: 'validate' 'as' 'empty' :)
          or $state[$p:lk] = 31235314                       (: 'validate' 'as' 'empty-sequence' :)
          or $state[$p:lk] = 31759602                       (: 'validate' 'as' 'end' :)
          or $state[$p:lk] = 32283890                       (: 'validate' 'as' 'eq' :)
          or $state[$p:lk] = 32546034                       (: 'validate' 'as' 'every' :)
          or $state[$p:lk] = 33070322                       (: 'validate' 'as' 'except' :)
          or $state[$p:lk] = 33594610                       (: 'validate' 'as' 'first' :)
          or $state[$p:lk] = 33856754                       (: 'validate' 'as' 'following' :)
          or $state[$p:lk] = 34118898                       (: 'validate' 'as' 'following-sibling' :)
          or $state[$p:lk] = 34381042                       (: 'validate' 'as' 'for' :)
          or $state[$p:lk] = 36216050                       (: 'validate' 'as' 'function' :)
          or $state[$p:lk] = 36478194                       (: 'validate' 'as' 'ge' :)
          or $state[$p:lk] = 37002482                       (: 'validate' 'as' 'group' :)
          or $state[$p:lk] = 37526770                       (: 'validate' 'as' 'gt' :)
          or $state[$p:lk] = 37788914                       (: 'validate' 'as' 'idiv' :)
          or $state[$p:lk] = 38051058                       (: 'validate' 'as' 'if' :)
          or $state[$p:lk] = 38313202                       (: 'validate' 'as' 'import' :)
          or $state[$p:lk] = 39623922                       (: 'validate' 'as' 'insert' :)
          or $state[$p:lk] = 39886066                       (: 'validate' 'as' 'instance' :)
          or $state[$p:lk] = 40148210                       (: 'validate' 'as' 'intersect' :)
          or $state[$p:lk] = 40410354                       (: 'validate' 'as' 'into' :)
          or $state[$p:lk] = 40672498                       (: 'validate' 'as' 'is' :)
          or $state[$p:lk] = 40934642                       (: 'validate' 'as' 'item' :)
          or $state[$p:lk] = 41458930                       (: 'validate' 'as' 'last' :)
          or $state[$p:lk] = 41983218                       (: 'validate' 'as' 'le' :)
          or $state[$p:lk] = 42507506                       (: 'validate' 'as' 'let' :)
          or $state[$p:lk] = 43293938                       (: 'validate' 'as' 'lt' :)
          or $state[$p:lk] = 43818226                       (: 'validate' 'as' 'mod' :)
          or $state[$p:lk] = 44080370                       (: 'validate' 'as' 'modify' :)
          or $state[$p:lk] = 44342514                       (: 'validate' 'as' 'module' :)
          or $state[$p:lk] = 44866802                       (: 'validate' 'as' 'namespace' :)
          or $state[$p:lk] = 45128946                       (: 'validate' 'as' 'namespace-node' :)
          or $state[$p:lk] = 45391090                       (: 'validate' 'as' 'ne' :)
          or $state[$p:lk] = 46701810                       (: 'validate' 'as' 'node' :)
          or $state[$p:lk] = 48012530                       (: 'validate' 'as' 'only' :)
          or $state[$p:lk] = 48536818                       (: 'validate' 'as' 'or' :)
          or $state[$p:lk] = 48798962                       (: 'validate' 'as' 'order' :)
          or $state[$p:lk] = 49061106                       (: 'validate' 'as' 'ordered' :)
          or $state[$p:lk] = 49847538                       (: 'validate' 'as' 'paragraphs' :)
          or $state[$p:lk] = 50109682                       (: 'validate' 'as' 'parent' :)
          or $state[$p:lk] = 51420402                       (: 'validate' 'as' 'preceding' :)
          or $state[$p:lk] = 51682546                       (: 'validate' 'as' 'preceding-sibling' :)
          or $state[$p:lk] = 52468978                       (: 'validate' 'as' 'private' :)
          or $state[$p:lk] = 52731122                       (: 'validate' 'as' 'processing-instruction' :)
          or $state[$p:lk] = 52993266                       (: 'validate' 'as' 'property' :)
          or $state[$p:lk] = 53517554                       (: 'validate' 'as' 'rename' :)
          or $state[$p:lk] = 53779698                       (: 'validate' 'as' 'replace' :)
          or $state[$p:lk] = 54041842                       (: 'validate' 'as' 'return' :)
          or $state[$p:lk] = 54828274                       (: 'validate' 'as' 'satisfies' :)
          or $state[$p:lk] = 55352562                       (: 'validate' 'as' 'schema-attribute' :)
          or $state[$p:lk] = 55614706                       (: 'validate' 'as' 'schema-element' :)
          or $state[$p:lk] = 55876850                       (: 'validate' 'as' 'self' :)
          or $state[$p:lk] = 56663282                       (: 'validate' 'as' 'sentences' :)
          or $state[$p:lk] = 57449714                       (: 'validate' 'as' 'some' :)
          or $state[$p:lk] = 57711858                       (: 'validate' 'as' 'stable' :)
          or $state[$p:lk] = 57974002                       (: 'validate' 'as' 'start' :)
          or $state[$p:lk] = 59546866                       (: 'validate' 'as' 'switch' :)
          or $state[$p:lk] = 59809010                       (: 'validate' 'as' 'text' :)
          or $state[$p:lk] = 60595442                       (: 'validate' 'as' 'times' :)
          or $state[$p:lk] = 60857586                       (: 'validate' 'as' 'to' :)
          or $state[$p:lk] = 61119730                       (: 'validate' 'as' 'treat' :)
          or $state[$p:lk] = 61381874                       (: 'validate' 'as' 'try' :)
          or $state[$p:lk] = 62168306                       (: 'validate' 'as' 'typeswitch' :)
          or $state[$p:lk] = 62430450                       (: 'validate' 'as' 'union' :)
          or $state[$p:lk] = 62692594                       (: 'validate' 'as' 'unordered' :)
          or $state[$p:lk] = 63479026                       (: 'validate' 'as' 'validate' :)
          or $state[$p:lk] = 65051890                       (: 'validate' 'as' 'where' :)
          or $state[$p:lk] = 65838322                       (: 'validate' 'as' 'with' :)
          or $state[$p:lk] = 66624754                       (: 'validate' 'as' 'words' :)
          or $state[$p:lk] = 66886898) then                 (: 'validate' 'as' 'xquery' :)
      let $state := p:memoized($state, 0)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:try-ValidateExpr($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 0)
            else
              p:memoize($backtrack, $state, -2, 0)
    else
      $state
  let $state :=
    if ($state[$p:lk] = -1
     or $state[$p:lk] = 70386                               (: 'validate' 'full' :)
     or $state[$p:lk] = 81650                               (: 'validate' 'lax' :)
     or $state[$p:lk] = 114930                              (: 'validate' 'strict' :)
     or $state[$p:lk] = 121074                              (: 'validate' 'type' :)
     or $state[$p:lk] = 131826) then                        (: 'validate' '{' :)
      let $state := p:parse-ValidateExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 35) then                       (: '(#' :)
      let $state := p:parse-ExtensionExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-PathExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ValueExpr", $count, $begin, $end)
};

(:~
 : Try parsing ValueExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ValueExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 242) then                           (: 'validate' :)
      let $state := p:lookahead2W(225, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'full' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'lax' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'strict' | 'times' | 'to' |
                                                               'treat' | 'type' | 'union' | 'where' | 'with' | 'words' |
                                                               '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:lk] = 40178) then                     (: 'validate' 'as' :)
          let $state := p:lookahead3W(241, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 1875186                        (: 'validate' 'as' URIQualifiedName :)
          or $state[$p:lk] = 5807346                        (: 'validate' 'as' QName^Token :)
          or $state[$p:lk] = 18652402                       (: 'validate' 'as' 'after' :)
          or $state[$p:lk] = 19438834                       (: 'validate' 'as' 'ancestor' :)
          or $state[$p:lk] = 19700978                       (: 'validate' 'as' 'ancestor-or-self' :)
          or $state[$p:lk] = 19963122                       (: 'validate' 'as' 'and' :)
          or $state[$p:lk] = 20487410                       (: 'validate' 'as' 'as' :)
          or $state[$p:lk] = 20749554                       (: 'validate' 'as' 'ascending' :)
          or $state[$p:lk] = 21273842                       (: 'validate' 'as' 'attribute' :)
          or $state[$p:lk] = 21798130                       (: 'validate' 'as' 'before' :)
          or $state[$p:lk] = 22060274                       (: 'validate' 'as' 'binary' :)
          or $state[$p:lk] = 22846706                       (: 'validate' 'as' 'case' :)
          or $state[$p:lk] = 23108850                       (: 'validate' 'as' 'cast' :)
          or $state[$p:lk] = 23370994                       (: 'validate' 'as' 'castable' :)
          or $state[$p:lk] = 23633138                       (: 'validate' 'as' 'catch' :)
          or $state[$p:lk] = 23895282                       (: 'validate' 'as' 'child' :)
          or $state[$p:lk] = 24157426                       (: 'validate' 'as' 'collation' :)
          or $state[$p:lk] = 24419570                       (: 'validate' 'as' 'comment' :)
          or $state[$p:lk] = 24943858                       (: 'validate' 'as' 'contains' :)
          or $state[$p:lk] = 25730290                       (: 'validate' 'as' 'copy' :)
          or $state[$p:lk] = 26254578                       (: 'validate' 'as' 'count' :)
          or $state[$p:lk] = 27041010                       (: 'validate' 'as' 'declare' :)
          or $state[$p:lk] = 27303154                       (: 'validate' 'as' 'default' :)
          or $state[$p:lk] = 27565298                       (: 'validate' 'as' 'delete' :)
          or $state[$p:lk] = 27827442                       (: 'validate' 'as' 'descendant' :)
          or $state[$p:lk] = 28089586                       (: 'validate' 'as' 'descendant-or-self' :)
          or $state[$p:lk] = 28351730                       (: 'validate' 'as' 'descending' :)
          or $state[$p:lk] = 29662450                       (: 'validate' 'as' 'div' :)
          or $state[$p:lk] = 29924594                       (: 'validate' 'as' 'document' :)
          or $state[$p:lk] = 30186738                       (: 'validate' 'as' 'document-node' :)
          or $state[$p:lk] = 30448882                       (: 'validate' 'as' 'element' :)
          or $state[$p:lk] = 30711026                       (: 'validate' 'as' 'else' :)
          or $state[$p:lk] = 30973170                       (: 'validate' 'as' 'empty' :)
          or $state[$p:lk] = 31235314                       (: 'validate' 'as' 'empty-sequence' :)
          or $state[$p:lk] = 31759602                       (: 'validate' 'as' 'end' :)
          or $state[$p:lk] = 32283890                       (: 'validate' 'as' 'eq' :)
          or $state[$p:lk] = 32546034                       (: 'validate' 'as' 'every' :)
          or $state[$p:lk] = 33070322                       (: 'validate' 'as' 'except' :)
          or $state[$p:lk] = 33594610                       (: 'validate' 'as' 'first' :)
          or $state[$p:lk] = 33856754                       (: 'validate' 'as' 'following' :)
          or $state[$p:lk] = 34118898                       (: 'validate' 'as' 'following-sibling' :)
          or $state[$p:lk] = 34381042                       (: 'validate' 'as' 'for' :)
          or $state[$p:lk] = 36216050                       (: 'validate' 'as' 'function' :)
          or $state[$p:lk] = 36478194                       (: 'validate' 'as' 'ge' :)
          or $state[$p:lk] = 37002482                       (: 'validate' 'as' 'group' :)
          or $state[$p:lk] = 37526770                       (: 'validate' 'as' 'gt' :)
          or $state[$p:lk] = 37788914                       (: 'validate' 'as' 'idiv' :)
          or $state[$p:lk] = 38051058                       (: 'validate' 'as' 'if' :)
          or $state[$p:lk] = 38313202                       (: 'validate' 'as' 'import' :)
          or $state[$p:lk] = 39623922                       (: 'validate' 'as' 'insert' :)
          or $state[$p:lk] = 39886066                       (: 'validate' 'as' 'instance' :)
          or $state[$p:lk] = 40148210                       (: 'validate' 'as' 'intersect' :)
          or $state[$p:lk] = 40410354                       (: 'validate' 'as' 'into' :)
          or $state[$p:lk] = 40672498                       (: 'validate' 'as' 'is' :)
          or $state[$p:lk] = 40934642                       (: 'validate' 'as' 'item' :)
          or $state[$p:lk] = 41458930                       (: 'validate' 'as' 'last' :)
          or $state[$p:lk] = 41983218                       (: 'validate' 'as' 'le' :)
          or $state[$p:lk] = 42507506                       (: 'validate' 'as' 'let' :)
          or $state[$p:lk] = 43293938                       (: 'validate' 'as' 'lt' :)
          or $state[$p:lk] = 43818226                       (: 'validate' 'as' 'mod' :)
          or $state[$p:lk] = 44080370                       (: 'validate' 'as' 'modify' :)
          or $state[$p:lk] = 44342514                       (: 'validate' 'as' 'module' :)
          or $state[$p:lk] = 44866802                       (: 'validate' 'as' 'namespace' :)
          or $state[$p:lk] = 45128946                       (: 'validate' 'as' 'namespace-node' :)
          or $state[$p:lk] = 45391090                       (: 'validate' 'as' 'ne' :)
          or $state[$p:lk] = 46701810                       (: 'validate' 'as' 'node' :)
          or $state[$p:lk] = 48012530                       (: 'validate' 'as' 'only' :)
          or $state[$p:lk] = 48536818                       (: 'validate' 'as' 'or' :)
          or $state[$p:lk] = 48798962                       (: 'validate' 'as' 'order' :)
          or $state[$p:lk] = 49061106                       (: 'validate' 'as' 'ordered' :)
          or $state[$p:lk] = 49847538                       (: 'validate' 'as' 'paragraphs' :)
          or $state[$p:lk] = 50109682                       (: 'validate' 'as' 'parent' :)
          or $state[$p:lk] = 51420402                       (: 'validate' 'as' 'preceding' :)
          or $state[$p:lk] = 51682546                       (: 'validate' 'as' 'preceding-sibling' :)
          or $state[$p:lk] = 52468978                       (: 'validate' 'as' 'private' :)
          or $state[$p:lk] = 52731122                       (: 'validate' 'as' 'processing-instruction' :)
          or $state[$p:lk] = 52993266                       (: 'validate' 'as' 'property' :)
          or $state[$p:lk] = 53517554                       (: 'validate' 'as' 'rename' :)
          or $state[$p:lk] = 53779698                       (: 'validate' 'as' 'replace' :)
          or $state[$p:lk] = 54041842                       (: 'validate' 'as' 'return' :)
          or $state[$p:lk] = 54828274                       (: 'validate' 'as' 'satisfies' :)
          or $state[$p:lk] = 55352562                       (: 'validate' 'as' 'schema-attribute' :)
          or $state[$p:lk] = 55614706                       (: 'validate' 'as' 'schema-element' :)
          or $state[$p:lk] = 55876850                       (: 'validate' 'as' 'self' :)
          or $state[$p:lk] = 56663282                       (: 'validate' 'as' 'sentences' :)
          or $state[$p:lk] = 57449714                       (: 'validate' 'as' 'some' :)
          or $state[$p:lk] = 57711858                       (: 'validate' 'as' 'stable' :)
          or $state[$p:lk] = 57974002                       (: 'validate' 'as' 'start' :)
          or $state[$p:lk] = 59546866                       (: 'validate' 'as' 'switch' :)
          or $state[$p:lk] = 59809010                       (: 'validate' 'as' 'text' :)
          or $state[$p:lk] = 60595442                       (: 'validate' 'as' 'times' :)
          or $state[$p:lk] = 60857586                       (: 'validate' 'as' 'to' :)
          or $state[$p:lk] = 61119730                       (: 'validate' 'as' 'treat' :)
          or $state[$p:lk] = 61381874                       (: 'validate' 'as' 'try' :)
          or $state[$p:lk] = 62168306                       (: 'validate' 'as' 'typeswitch' :)
          or $state[$p:lk] = 62430450                       (: 'validate' 'as' 'union' :)
          or $state[$p:lk] = 62692594                       (: 'validate' 'as' 'unordered' :)
          or $state[$p:lk] = 63479026                       (: 'validate' 'as' 'validate' :)
          or $state[$p:lk] = 65051890                       (: 'validate' 'as' 'where' :)
          or $state[$p:lk] = 65838322                       (: 'validate' 'as' 'with' :)
          or $state[$p:lk] = 66624754                       (: 'validate' 'as' 'words' :)
          or $state[$p:lk] = 66886898) then                 (: 'validate' 'as' 'xquery' :)
      let $state := p:memoized($state, 0)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:try-ValidateExpr($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 0)
            else
              p:memoize($backtrack, $state, -2, 0)
    else
      $state
  let $state :=
    if ($state[$p:lk] = -1
     or $state[$p:lk] = 70386                               (: 'validate' 'full' :)
     or $state[$p:lk] = 81650                               (: 'validate' 'lax' :)
     or $state[$p:lk] = 114930                              (: 'validate' 'strict' :)
     or $state[$p:lk] = 121074                              (: 'validate' 'type' :)
     or $state[$p:lk] = 131826) then                        (: 'validate' '{' :)
      let $state := p:try-ValidateExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 35) then                       (: '(#' :)
      let $state := p:try-ExtensionExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-PathExpr($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production UnaryExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnaryExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(241, $input, $state)        (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
    return
      if ($state[$p:l1] != 40                               (: '+' :)
      and $state[$p:l1] != 42) then                         (: '-' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 42) then                      (: '-' :)
            let $state := p:shift(42, $input, $state)       (: '-' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(40, $input, $state)       (: '+' :)
            return $state
        return p:parse-UnaryExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production UnaryExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-UnaryExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(241, $input, $state)        (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
    return
      if ($state[$p:l1] != 40                               (: '+' :)
      and $state[$p:l1] != 42) then                         (: '-' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 42) then                      (: '-' :)
            let $state := p:shiftT(42, $input, $state)      (: '-' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shiftT(40, $input, $state)      (: '+' :)
            return $state
        return p:try-UnaryExpr-1($input, $state)
};

(:~
 : Parse UnaryExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-UnaryExpr-1($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ValueExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "UnaryExpr", $count, $begin, $end)
};

(:~
 : Try parsing UnaryExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-UnaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-UnaryExpr-1($input, $state)
  let $state := p:try-ValueExpr($input, $state)
  return $state
};

(:~
 : Parse CastExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CastExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-UnaryExpr($input, $state)
  let $state := p:lookahead1W(203, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'treat' | 'union' | 'where' |
                                                               'with' | 'words' | '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 88) then                       (: 'cast' :)
      let $state := p:shift(88, $input, $state)             (: 'cast' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(78, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SingleType($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "CastExpr", $count, $begin, $end)
};

(:~
 : Try parsing CastExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CastExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-UnaryExpr($input, $state)
  let $state := p:lookahead1W(203, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'treat' | 'union' | 'where' |
                                                               'with' | 'words' | '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 88) then                       (: 'cast' :)
      let $state := p:shiftT(88, $input, $state)            (: 'cast' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shiftT(78, $input, $state)            (: 'as' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-SingleType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse CastableExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CastableExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-CastExpr($input, $state)
  let $state := p:lookahead1W(202, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'treat' | 'union' | 'where' |
                                                               'with' | 'words' | '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 89) then                       (: 'castable' :)
      let $state := p:shift(89, $input, $state)             (: 'castable' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(78, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SingleType($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "CastableExpr", $count, $begin, $end)
};

(:~
 : Try parsing CastableExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CastableExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-CastExpr($input, $state)
  let $state := p:lookahead1W(202, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'treat' | 'union' | 'where' |
                                                               'with' | 'words' | '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 89) then                       (: 'castable' :)
      let $state := p:shiftT(89, $input, $state)            (: 'castable' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shiftT(78, $input, $state)            (: 'as' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-SingleType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse TreatExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TreatExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-CastableExpr($input, $state)
  let $state := p:lookahead1W(201, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 233) then                      (: 'treat' :)
      let $state := p:shift(233, $input, $state)            (: 'treat' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(78, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(235, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "TreatExpr", $count, $begin, $end)
};

(:~
 : Try parsing TreatExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-TreatExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-CastableExpr($input, $state)
  let $state := p:lookahead1W(201, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 233) then                      (: 'treat' :)
      let $state := p:shiftT(233, $input, $state)           (: 'treat' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shiftT(78, $input, $state)            (: 'as' :)
      let $state := p:lookahead1W(235, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-SequenceType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse InstanceofExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InstanceofExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-TreatExpr($input, $state)
  let $state := p:lookahead1W(200, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'union' | 'where' | 'with' | 'words' | '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 152) then                      (: 'instance' :)
      let $state := p:shift(152, $input, $state)            (: 'instance' :)
      let $state := p:lookahead1W(60, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      let $state := p:shift(182, $input, $state)            (: 'of' :)
      let $state := p:lookahead1W(235, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "InstanceofExpr", $count, $begin, $end)
};

(:~
 : Try parsing InstanceofExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-InstanceofExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-TreatExpr($input, $state)
  let $state := p:lookahead1W(200, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'union' | 'where' | 'with' | 'words' | '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 152) then                      (: 'instance' :)
      let $state := p:shiftT(152, $input, $state)           (: 'instance' :)
      let $state := p:lookahead1W(60, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      let $state := p:shiftT(182, $input, $state)           (: 'of' :)
      let $state := p:lookahead1W(235, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-SequenceType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production IntersectExceptExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntersectExceptExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(198, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'union' | 'where' |
                                                               'with' | 'words' | '|' | '||' | '}' :)
    return
      if ($state[$p:l1] != 126                              (: 'except' :)
      and $state[$p:l1] != 153) then                        (: 'intersect' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 153) then                     (: 'intersect' :)
            let $state := p:shift(153, $input, $state)      (: 'intersect' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(126, $input, $state)      (: 'except' :)
            return $state
        let $state := p:lookahead1W(241, $input, $state)    (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-InstanceofExpr($input, $state)
        return p:parse-IntersectExceptExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production IntersectExceptExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-IntersectExceptExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(198, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'union' | 'where' |
                                                               'with' | 'words' | '|' | '||' | '}' :)
    return
      if ($state[$p:l1] != 126                              (: 'except' :)
      and $state[$p:l1] != 153) then                        (: 'intersect' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 153) then                     (: 'intersect' :)
            let $state := p:shiftT(153, $input, $state)     (: 'intersect' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shiftT(126, $input, $state)     (: 'except' :)
            return $state
        let $state := p:lookahead1W(241, $input, $state)    (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
        let $state := p:try-InstanceofExpr($input, $state)
        return p:try-IntersectExceptExpr-1($input, $state)
};

(:~
 : Parse IntersectExceptExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntersectExceptExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-InstanceofExpr($input, $state)
  let $state := p:parse-IntersectExceptExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "IntersectExceptExpr", $count, $begin, $end)
};

(:~
 : Try parsing IntersectExceptExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-IntersectExceptExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-InstanceofExpr($input, $state)
  let $state := p:try-IntersectExceptExpr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production UnionExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnionExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 238                                (: 'union' :)
    and $state[$p:l1] != 259) then                          (: '|' :)
      $state
    else
      let $state :=
        if ($state[$p:l1] = 238) then                       (: 'union' :)
          let $state := p:shift(238, $input, $state)        (: 'union' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(259, $input, $state)        (: '|' :)
          return $state
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-IntersectExceptExpr($input, $state)
      return p:parse-UnionExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production UnionExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-UnionExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 238                                (: 'union' :)
    and $state[$p:l1] != 259) then                          (: '|' :)
      $state
    else
      let $state :=
        if ($state[$p:l1] = 238) then                       (: 'union' :)
          let $state := p:shiftT(238, $input, $state)       (: 'union' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shiftT(259, $input, $state)       (: '|' :)
          return $state
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-IntersectExceptExpr($input, $state)
      return p:try-UnionExpr-1($input, $state)
};

(:~
 : Parse UnionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-IntersectExceptExpr($input, $state)
  let $state := p:parse-UnionExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "UnionExpr", $count, $begin, $end)
};

(:~
 : Try parsing UnionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-UnionExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-IntersectExceptExpr($input, $state)
  let $state := p:try-UnionExpr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production MultiplicativeExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MultiplicativeExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 38                                 (: '*' :)
    and $state[$p:l1] != 113                                (: 'div' :)
    and $state[$p:l1] != 144                                (: 'idiv' :)
    and $state[$p:l1] != 167) then                          (: 'mod' :)
      $state
    else
      let $state :=
        if ($state[$p:l1] = 38) then                        (: '*' :)
          let $state := p:shift(38, $input, $state)         (: '*' :)
          return $state
        else if ($state[$p:l1] = 113) then                  (: 'div' :)
          let $state := p:shift(113, $input, $state)        (: 'div' :)
          return $state
        else if ($state[$p:l1] = 144) then                  (: 'idiv' :)
          let $state := p:shift(144, $input, $state)        (: 'idiv' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(167, $input, $state)        (: 'mod' :)
          return $state
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-UnionExpr($input, $state)
      return p:parse-MultiplicativeExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production MultiplicativeExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-MultiplicativeExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 38                                 (: '*' :)
    and $state[$p:l1] != 113                                (: 'div' :)
    and $state[$p:l1] != 144                                (: 'idiv' :)
    and $state[$p:l1] != 167) then                          (: 'mod' :)
      $state
    else
      let $state :=
        if ($state[$p:l1] = 38) then                        (: '*' :)
          let $state := p:shiftT(38, $input, $state)        (: '*' :)
          return $state
        else if ($state[$p:l1] = 113) then                  (: 'div' :)
          let $state := p:shiftT(113, $input, $state)       (: 'div' :)
          return $state
        else if ($state[$p:l1] = 144) then                  (: 'idiv' :)
          let $state := p:shiftT(144, $input, $state)       (: 'idiv' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shiftT(167, $input, $state)       (: 'mod' :)
          return $state
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-UnionExpr($input, $state)
      return p:try-MultiplicativeExpr-1($input, $state)
};

(:~
 : Parse MultiplicativeExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MultiplicativeExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-UnionExpr($input, $state)
  let $state := p:parse-MultiplicativeExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "MultiplicativeExpr", $count, $begin, $end)
};

(:~
 : Try parsing MultiplicativeExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-MultiplicativeExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-UnionExpr($input, $state)
  let $state := p:try-MultiplicativeExpr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production AdditiveExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AdditiveExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 40                                 (: '+' :)
    and $state[$p:l1] != 42) then                           (: '-' :)
      $state
    else
      let $state :=
        if ($state[$p:l1] = 40) then                        (: '+' :)
          let $state := p:shift(40, $input, $state)         (: '+' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(42, $input, $state)         (: '-' :)
          return $state
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-MultiplicativeExpr($input, $state)
      return p:parse-AdditiveExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production AdditiveExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AdditiveExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 40                                 (: '+' :)
    and $state[$p:l1] != 42) then                           (: '-' :)
      $state
    else
      let $state :=
        if ($state[$p:l1] = 40) then                        (: '+' :)
          let $state := p:shiftT(40, $input, $state)        (: '+' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shiftT(42, $input, $state)        (: '-' :)
          return $state
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-MultiplicativeExpr($input, $state)
      return p:try-AdditiveExpr-1($input, $state)
};

(:~
 : Parse AdditiveExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AdditiveExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-MultiplicativeExpr($input, $state)
  let $state := p:parse-AdditiveExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AdditiveExpr", $count, $begin, $end)
};

(:~
 : Try parsing AdditiveExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AdditiveExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-MultiplicativeExpr($input, $state)
  let $state := p:try-AdditiveExpr-1($input, $state)
  return $state
};

(:~
 : Parse RangeExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RangeExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-AdditiveExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 232) then                      (: 'to' :)
      let $state := p:shift(232, $input, $state)            (: 'to' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AdditiveExpr($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "RangeExpr", $count, $begin, $end)
};

(:~
 : Try parsing RangeExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-RangeExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-AdditiveExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 232) then                      (: 'to' :)
      let $state := p:shiftT(232, $input, $state)           (: 'to' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-AdditiveExpr($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production StringConcatExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StringConcatExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 260) then                          (: '||' :)
      $state
    else
      let $state := p:shift(260, $input, $state)            (: '||' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-RangeExpr($input, $state)
      return p:parse-StringConcatExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production StringConcatExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-StringConcatExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 260) then                          (: '||' :)
      $state
    else
      let $state := p:shiftT(260, $input, $state)           (: '||' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-RangeExpr($input, $state)
      return p:try-StringConcatExpr-1($input, $state)
};

(:~
 : Parse StringConcatExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StringConcatExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-RangeExpr($input, $state)
  let $state := p:parse-StringConcatExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "StringConcatExpr", $count, $begin, $end)
};

(:~
 : Try parsing StringConcatExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-StringConcatExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-RangeExpr($input, $state)
  let $state := p:try-StringConcatExpr-1($input, $state)
  return $state
};

(:~
 : Parse FTContainsExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTContainsExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-StringConcatExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 95) then                       (: 'contains' :)
      let $state := p:shift(95, $input, $state)             (: 'contains' :)
      let $state := p:lookahead1W(72, $input, $state)       (: S^WS | ('(' ':') | 'text' :)
      let $state := p:shift(228, $input, $state)            (: 'text' :)
      let $state := p:lookahead1W(156, $input, $state)      (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FTSelection($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 252) then                  (: 'without' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-FTIgnoreOption($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTContainsExpr", $count, $begin, $end)
};

(:~
 : Try parsing FTContainsExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTContainsExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-StringConcatExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 95) then                       (: 'contains' :)
      let $state := p:shiftT(95, $input, $state)            (: 'contains' :)
      let $state := p:lookahead1W(72, $input, $state)       (: S^WS | ('(' ':') | 'text' :)
      let $state := p:shiftT(228, $input, $state)           (: 'text' :)
      let $state := p:lookahead1W(156, $input, $state)      (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state := p:try-FTSelection($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 252) then                  (: 'without' :)
          let $state := p:try-FTIgnoreOption($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  return $state
};

(:~
 : Parse ComparisonExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ComparisonExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FTContainsExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 27                             (: '!=' :)
          or $state[$p:l1] = 53                             (: '<' :)
          or $state[$p:l1] = 57                             (: '<<' :)
          or $state[$p:l1] = 58                             (: '<=' :)
          or $state[$p:l1] = 60                             (: '=' :)
          or $state[$p:l1] = 61                             (: '>' :)
          or $state[$p:l1] = 62                             (: '>=' :)
          or $state[$p:l1] = 63                             (: '>>' :)
          or $state[$p:l1] = 123                            (: 'eq' :)
          or $state[$p:l1] = 139                            (: 'ge' :)
          or $state[$p:l1] = 143                            (: 'gt' :)
          or $state[$p:l1] = 155                            (: 'is' :)
          or $state[$p:l1] = 160                            (: 'le' :)
          or $state[$p:l1] = 165                            (: 'lt' :)
          or $state[$p:l1] = 173) then                      (: 'ne' :)
      let $state :=
        if ($state[$p:l1] = 123                             (: 'eq' :)
         or $state[$p:l1] = 139                             (: 'ge' :)
         or $state[$p:l1] = 143                             (: 'gt' :)
         or $state[$p:l1] = 160                             (: 'le' :)
         or $state[$p:l1] = 165                             (: 'lt' :)
         or $state[$p:l1] = 173) then                       (: 'ne' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-ValueComp($input, $state)
          return $state
        else if ($state[$p:l1] = 57                         (: '<<' :)
              or $state[$p:l1] = 63                         (: '>>' :)
              or $state[$p:l1] = 155) then                  (: 'is' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-NodeComp($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:whitespace($input, $state)
          let $state := p:parse-GeneralComp($input, $state)
          return $state
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FTContainsExpr($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ComparisonExpr", $count, $begin, $end)
};

(:~
 : Try parsing ComparisonExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ComparisonExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-FTContainsExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 27                             (: '!=' :)
          or $state[$p:l1] = 53                             (: '<' :)
          or $state[$p:l1] = 57                             (: '<<' :)
          or $state[$p:l1] = 58                             (: '<=' :)
          or $state[$p:l1] = 60                             (: '=' :)
          or $state[$p:l1] = 61                             (: '>' :)
          or $state[$p:l1] = 62                             (: '>=' :)
          or $state[$p:l1] = 63                             (: '>>' :)
          or $state[$p:l1] = 123                            (: 'eq' :)
          or $state[$p:l1] = 139                            (: 'ge' :)
          or $state[$p:l1] = 143                            (: 'gt' :)
          or $state[$p:l1] = 155                            (: 'is' :)
          or $state[$p:l1] = 160                            (: 'le' :)
          or $state[$p:l1] = 165                            (: 'lt' :)
          or $state[$p:l1] = 173) then                      (: 'ne' :)
      let $state :=
        if ($state[$p:l1] = 123                             (: 'eq' :)
         or $state[$p:l1] = 139                             (: 'ge' :)
         or $state[$p:l1] = 143                             (: 'gt' :)
         or $state[$p:l1] = 160                             (: 'le' :)
         or $state[$p:l1] = 165                             (: 'lt' :)
         or $state[$p:l1] = 173) then                       (: 'ne' :)
          let $state := p:try-ValueComp($input, $state)
          return $state
        else if ($state[$p:l1] = 57                         (: '<<' :)
              or $state[$p:l1] = 63                         (: '>>' :)
              or $state[$p:l1] = 155) then                  (: 'is' :)
          let $state := p:try-NodeComp($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:try-GeneralComp($input, $state)
          return $state
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-FTContainsExpr($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production AndExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AndExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 76) then                           (: 'and' :)
      $state
    else
      let $state := p:shift(76, $input, $state)             (: 'and' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ComparisonExpr($input, $state)
      return p:parse-AndExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production AndExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AndExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 76) then                           (: 'and' :)
      $state
    else
      let $state := p:shiftT(76, $input, $state)            (: 'and' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-ComparisonExpr($input, $state)
      return p:try-AndExpr-1($input, $state)
};

(:~
 : Parse AndExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AndExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ComparisonExpr($input, $state)
  let $state := p:parse-AndExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AndExpr", $count, $begin, $end)
};

(:~
 : Try parsing AndExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AndExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-ComparisonExpr($input, $state)
  let $state := p:try-AndExpr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production OrExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 185) then                          (: 'or' :)
      $state
    else
      let $state := p:shift(185, $input, $state)            (: 'or' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AndExpr($input, $state)
      return p:parse-OrExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production OrExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-OrExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 185) then                          (: 'or' :)
      $state
    else
      let $state := p:shiftT(185, $input, $state)           (: 'or' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-AndExpr($input, $state)
      return p:try-OrExpr-1($input, $state)
};

(:~
 : Parse OrExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-AndExpr($input, $state)
  let $state := p:parse-OrExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrExpr", $count, $begin, $end)
};

(:~
 : Try parsing OrExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-OrExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-AndExpr($input, $state)
  let $state := p:try-OrExpr-1($input, $state)
  return $state
};

(:~
 : Parse IfExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IfExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(145, $input, $state)                (: 'if' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(73, $input, $state)           (: S^WS | ('(' ':') | 'then' :)
  let $state := p:shift(229, $input, $state)                (: 'then' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:shift(117, $input, $state)                (: 'else' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "IfExpr", $count, $begin, $end)
};

(:~
 : Try parsing IfExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-IfExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(145, $input, $state)               (: 'if' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-Expr($input, $state)
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  let $state := p:lookahead1W(73, $input, $state)           (: S^WS | ('(' ':') | 'then' :)
  let $state := p:shiftT(229, $input, $state)               (: 'then' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  let $state := p:shiftT(117, $input, $state)               (: 'else' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production SequenceTypeUnion (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SequenceTypeUnion-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(126, $input, $state)        (: S^WS | ('(' ':') | 'return' | '|' :)
    return
      if ($state[$p:l1] != 259) then                        (: '|' :)
        $state
      else
        let $state := p:shift(259, $input, $state)          (: '|' :)
        let $state := p:lookahead1W(235, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-SequenceType($input, $state)
        return p:parse-SequenceTypeUnion-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production SequenceTypeUnion (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-SequenceTypeUnion-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(126, $input, $state)        (: S^WS | ('(' ':') | 'return' | '|' :)
    return
      if ($state[$p:l1] != 259) then                        (: '|' :)
        $state
      else
        let $state := p:shiftT(259, $input, $state)         (: '|' :)
        let $state := p:lookahead1W(235, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
        let $state := p:try-SequenceType($input, $state)
        return p:try-SequenceTypeUnion-1($input, $state)
};

(:~
 : Parse SequenceTypeUnion.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SequenceTypeUnion($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-SequenceType($input, $state)
  let $state := p:parse-SequenceTypeUnion-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SequenceTypeUnion", $count, $begin, $end)
};

(:~
 : Try parsing SequenceTypeUnion.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-SequenceTypeUnion($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-SequenceType($input, $state)
  let $state := p:try-SequenceTypeUnion-1($input, $state)
  return $state
};

(:~
 : Parse CaseClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CaseClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(87, $input, $state)                 (: 'case' :)
  let $state := p:lookahead1W(237, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '$' | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VarName($input, $state)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(78, $input, $state)             (: 'as' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(235, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-SequenceTypeUnion($input, $state)
  let $state := p:shift(206, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CaseClause", $count, $begin, $end)
};

(:~
 : Try parsing CaseClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CaseClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(87, $input, $state)                (: 'case' :)
  let $state := p:lookahead1W(237, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '$' | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:shiftT(31, $input, $state)            (: '$' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-VarName($input, $state)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shiftT(78, $input, $state)            (: 'as' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(235, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-SequenceTypeUnion($input, $state)
  let $state := p:shiftT(206, $input, $state)               (: 'return' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production TypeswitchExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeswitchExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(37, $input, $state)         (: S^WS | ('(' ':') | 'case' :)
    let $state := p:whitespace($input, $state)
    let $state := p:parse-CaseClause($input, $state)
    return
      if ($state[$p:l1] != 87) then                         (: 'case' :)
        $state
      else
        p:parse-TypeswitchExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production TypeswitchExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-TypeswitchExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(37, $input, $state)         (: S^WS | ('(' ':') | 'case' :)
    let $state := p:try-CaseClause($input, $state)
    return
      if ($state[$p:l1] != 87) then                         (: 'case' :)
        $state
      else
        p:try-TypeswitchExpr-1($input, $state)
};

(:~
 : Parse TypeswitchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeswitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(237, $input, $state)                (: 'typeswitch' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $state := p:parse-TypeswitchExpr-1($input, $state)
  let $state := p:shift(104, $input, $state)                (: 'default' :)
  let $state := p:lookahead1W(88, $input, $state)           (: S^WS | '$' | ('(' ':') | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VarName($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(64, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:shift(206, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypeswitchExpr", $count, $begin, $end)
};

(:~
 : Try parsing TypeswitchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-TypeswitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(237, $input, $state)               (: 'typeswitch' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-Expr($input, $state)
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  let $state := p:try-TypeswitchExpr-1($input, $state)
  let $state := p:shiftT(104, $input, $state)               (: 'default' :)
  let $state := p:lookahead1W(88, $input, $state)           (: S^WS | '$' | ('(' ':') | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:shiftT(31, $input, $state)            (: '$' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-VarName($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(64, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:shiftT(206, $input, $state)               (: 'return' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse SwitchCaseOperand.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchCaseOperand($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SwitchCaseOperand", $count, $begin, $end)
};

(:~
 : Try parsing SwitchCaseOperand.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-SwitchCaseOperand($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production SwitchCaseClause (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchCaseClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:shift(87, $input, $state)               (: 'case' :)
    let $state := p:lookahead1W(241, $input, $state)        (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
    let $state := p:whitespace($input, $state)
    let $state := p:parse-SwitchCaseOperand($input, $state)
    return
      if ($state[$p:l1] != 87) then                         (: 'case' :)
        $state
      else
        p:parse-SwitchCaseClause-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production SwitchCaseClause (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-SwitchCaseClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:shiftT(87, $input, $state)              (: 'case' :)
    let $state := p:lookahead1W(241, $input, $state)        (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
    let $state := p:try-SwitchCaseOperand($input, $state)
    return
      if ($state[$p:l1] != 87) then                         (: 'case' :)
        $state
      else
        p:try-SwitchCaseClause-1($input, $state)
};

(:~
 : Parse SwitchCaseClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchCaseClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-SwitchCaseClause-1($input, $state)
  let $state := p:shift(206, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SwitchCaseClause", $count, $begin, $end)
};

(:~
 : Try parsing SwitchCaseClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-SwitchCaseClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-SwitchCaseClause-1($input, $state)
  let $state := p:shiftT(206, $input, $state)               (: 'return' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production Expr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Expr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 41) then                           (: ',' :)
      $state
    else
      let $state := p:shift(41, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ExprSingle($input, $state)
      return p:parse-Expr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production Expr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Expr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 41) then                           (: ',' :)
      $state
    else
      let $state := p:shiftT(41, $input, $state)            (: ',' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-ExprSingle($input, $state)
      return p:try-Expr-1($input, $state)
};

(:~
 : Parse Expr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Expr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-Expr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "Expr", $count, $begin, $end)
};

(:~
 : Try parsing Expr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Expr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-ExprSingle($input, $state)
  let $state := p:try-Expr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production SwitchExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(37, $input, $state)         (: S^WS | ('(' ':') | 'case' :)
    let $state := p:whitespace($input, $state)
    let $state := p:parse-SwitchCaseClause($input, $state)
    return
      if ($state[$p:l1] != 87) then                         (: 'case' :)
        $state
      else
        p:parse-SwitchExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production SwitchExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-SwitchExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(37, $input, $state)         (: S^WS | ('(' ':') | 'case' :)
    let $state := p:try-SwitchCaseClause($input, $state)
    return
      if ($state[$p:l1] != 87) then                         (: 'case' :)
        $state
      else
        p:try-SwitchExpr-1($input, $state)
};

(:~
 : Parse SwitchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(227, $input, $state)                (: 'switch' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $state := p:parse-SwitchExpr-1($input, $state)
  let $state := p:shift(104, $input, $state)                (: 'default' :)
  let $state := p:lookahead1W(64, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:shift(206, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SwitchExpr", $count, $begin, $end)
};

(:~
 : Try parsing SwitchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-SwitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(227, $input, $state)               (: 'switch' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-Expr($input, $state)
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  let $state := p:try-SwitchExpr-1($input, $state)
  let $state := p:shiftT(104, $input, $state)               (: 'default' :)
  let $state := p:lookahead1W(64, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:shiftT(206, $input, $state)               (: 'return' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production QuantifiedExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuantifiedExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 41) then                           (: ',' :)
      $state
    else
      let $state := p:shift(41, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VarName($input, $state)
      let $state := p:lookahead1W(100, $input, $state)      (: S^WS | ('(' ':') | 'as' | 'in' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 78) then                   (: 'as' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-TypeDeclaration($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(50, $input, $state)       (: S^WS | ('(' ':') | 'in' :)
      let $state := p:shift(147, $input, $state)            (: 'in' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ExprSingle($input, $state)
      return p:parse-QuantifiedExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production QuantifiedExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-QuantifiedExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 41) then                           (: ',' :)
      $state
    else
      let $state := p:shiftT(41, $input, $state)            (: ',' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:shiftT(31, $input, $state)            (: '$' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-VarName($input, $state)
      let $state := p:lookahead1W(100, $input, $state)      (: S^WS | ('(' ':') | 'as' | 'in' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 78) then                   (: 'as' :)
          let $state := p:try-TypeDeclaration($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(50, $input, $state)       (: S^WS | ('(' ':') | 'in' :)
      let $state := p:shiftT(147, $input, $state)           (: 'in' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-ExprSingle($input, $state)
      return p:try-QuantifiedExpr-1($input, $state)
};

(:~
 : Parse QuantifiedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuantifiedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 219) then                           (: 'some' :)
      let $state := p:shift(219, $input, $state)            (: 'some' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(124, $input, $state)            (: 'every' :)
      return $state
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(100, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shift(147, $input, $state)                (: 'in' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-QuantifiedExpr-1($input, $state)
  let $state := p:shift(209, $input, $state)                (: 'satisfies' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "QuantifiedExpr", $count, $begin, $end)
};

(:~
 : Try parsing QuantifiedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-QuantifiedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 219) then                           (: 'some' :)
      let $state := p:shiftT(219, $input, $state)           (: 'some' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(124, $input, $state)           (: 'every' :)
      return $state
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shiftT(31, $input, $state)                (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-VarName($input, $state)
  let $state := p:lookahead1W(100, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:try-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shiftT(147, $input, $state)               (: 'in' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  let $state := p:try-QuantifiedExpr-1($input, $state)
  let $state := p:shiftT(209, $input, $state)               (: 'satisfies' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse ReturnClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReturnClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(206, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ReturnClause", $count, $begin, $end)
};

(:~
 : Try parsing ReturnClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ReturnClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(206, $input, $state)               (: 'return' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse CountClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CountClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(100, $input, $state)                (: 'count' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CountClause", $count, $begin, $end)
};

(:~
 : Try parsing CountClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CountClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(100, $input, $state)               (: 'count' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shiftT(31, $input, $state)                (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-VarName($input, $state)
  return $state
};

(:~
 : Parse OrderModifier.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderModifier($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 79                             (: 'ascending' :)
          or $state[$p:l1] = 108) then                      (: 'descending' :)
      let $state :=
        if ($state[$p:l1] = 79) then                        (: 'ascending' :)
          let $state := p:shift(79, $input, $state)         (: 'ascending' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(108, $input, $state)        (: 'descending' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(172, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 118) then                      (: 'empty' :)
      let $state := p:shift(118, $input, $state)            (: 'empty' :)
      let $state := p:lookahead1W(113, $input, $state)      (: S^WS | ('(' ':') | 'greatest' | 'least' :)
      let $state :=
        if ($state[$p:l1] = 140) then                       (: 'greatest' :)
          let $state := p:shift(140, $input, $state)        (: 'greatest' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(161, $input, $state)        (: 'least' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(170, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' | 'for' |
                                                               'group' | 'let' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 92) then                       (: 'collation' :)
      let $state := p:shift(92, $input, $state)             (: 'collation' :)
      let $state := p:lookahead1W(17, $input, $state)       (: URILiteral | S^WS | ('(' ':') :)
      let $state := p:shift(8, $input, $state)              (: URILiteral :)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderModifier", $count, $begin, $end)
};

(:~
 : Try parsing OrderModifier.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-OrderModifier($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 79                             (: 'ascending' :)
          or $state[$p:l1] = 108) then                      (: 'descending' :)
      let $state :=
        if ($state[$p:l1] = 79) then                        (: 'ascending' :)
          let $state := p:shiftT(79, $input, $state)        (: 'ascending' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shiftT(108, $input, $state)       (: 'descending' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(172, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 118) then                      (: 'empty' :)
      let $state := p:shiftT(118, $input, $state)           (: 'empty' :)
      let $state := p:lookahead1W(113, $input, $state)      (: S^WS | ('(' ':') | 'greatest' | 'least' :)
      let $state :=
        if ($state[$p:l1] = 140) then                       (: 'greatest' :)
          let $state := p:shiftT(140, $input, $state)       (: 'greatest' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shiftT(161, $input, $state)       (: 'least' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(170, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' | 'for' |
                                                               'group' | 'let' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 92) then                       (: 'collation' :)
      let $state := p:shiftT(92, $input, $state)            (: 'collation' :)
      let $state := p:lookahead1W(17, $input, $state)       (: URILiteral | S^WS | ('(' ':') :)
      let $state := p:shiftT(8, $input, $state)             (: URILiteral :)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse OrderSpec.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpec($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-OrderModifier($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderSpec", $count, $begin, $end)
};

(:~
 : Try parsing OrderSpec.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-OrderSpec($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-ExprSingle($input, $state)
  let $state := p:try-OrderModifier($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production OrderSpecList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpecList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(169, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(241, $input, $state)    (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-OrderSpec($input, $state)
        return p:parse-OrderSpecList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production OrderSpecList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-OrderSpecList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(169, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shiftT(41, $input, $state)          (: ',' :)
        let $state := p:lookahead1W(241, $input, $state)    (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
        let $state := p:try-OrderSpec($input, $state)
        return p:try-OrderSpecList-1($input, $state)
};

(:~
 : Parse OrderSpecList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpecList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-OrderSpec($input, $state)
  let $state := p:parse-OrderSpecList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderSpecList", $count, $begin, $end)
};

(:~
 : Try parsing OrderSpecList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-OrderSpecList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-OrderSpec($input, $state)
  let $state := p:try-OrderSpecList-1($input, $state)
  return $state
};

(:~
 : Parse OrderByClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderByClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 186) then                           (: 'order' :)
      let $state := p:shift(186, $input, $state)            (: 'order' :)
      let $state := p:lookahead1W(36, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:shift(86, $input, $state)             (: 'by' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(220, $input, $state)            (: 'stable' :)
      let $state := p:lookahead1W(62, $input, $state)       (: S^WS | ('(' ':') | 'order' :)
      let $state := p:shift(186, $input, $state)            (: 'order' :)
      let $state := p:lookahead1W(36, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:shift(86, $input, $state)             (: 'by' :)
      return $state
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-OrderSpecList($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderByClause", $count, $begin, $end)
};

(:~
 : Try parsing OrderByClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-OrderByClause($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 186) then                           (: 'order' :)
      let $state := p:shiftT(186, $input, $state)           (: 'order' :)
      let $state := p:lookahead1W(36, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:shiftT(86, $input, $state)            (: 'by' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(220, $input, $state)           (: 'stable' :)
      let $state := p:lookahead1W(62, $input, $state)       (: S^WS | ('(' ':') | 'order' :)
      let $state := p:shiftT(186, $input, $state)           (: 'order' :)
      let $state := p:lookahead1W(36, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:shiftT(86, $input, $state)            (: 'by' :)
      return $state
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-OrderSpecList($input, $state)
  return $state
};

(:~
 : Parse GroupingSpec.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GroupingSpec($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(170, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' | 'for' |
                                                               'group' | 'let' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 92) then                       (: 'collation' :)
      let $state := p:shift(92, $input, $state)             (: 'collation' :)
      let $state := p:lookahead1W(17, $input, $state)       (: URILiteral | S^WS | ('(' ':') :)
      let $state := p:shift(8, $input, $state)              (: URILiteral :)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "GroupingSpec", $count, $begin, $end)
};

(:~
 : Try parsing GroupingSpec.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-GroupingSpec($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(31, $input, $state)                (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-VarName($input, $state)
  let $state := p:lookahead1W(170, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' | 'for' |
                                                               'group' | 'let' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 92) then                       (: 'collation' :)
      let $state := p:shiftT(92, $input, $state)            (: 'collation' :)
      let $state := p:lookahead1W(17, $input, $state)       (: URILiteral | S^WS | ('(' ':') :)
      let $state := p:shiftT(8, $input, $state)             (: URILiteral :)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production GroupingSpecList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GroupingSpecList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(169, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(23, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-GroupingSpec($input, $state)
        return p:parse-GroupingSpecList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production GroupingSpecList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-GroupingSpecList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(169, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shiftT(41, $input, $state)          (: ',' :)
        let $state := p:lookahead1W(23, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state := p:try-GroupingSpec($input, $state)
        return p:try-GroupingSpecList-1($input, $state)
};

(:~
 : Parse GroupingSpecList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GroupingSpecList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-GroupingSpec($input, $state)
  let $state := p:parse-GroupingSpecList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "GroupingSpecList", $count, $begin, $end)
};

(:~
 : Try parsing GroupingSpecList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-GroupingSpecList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-GroupingSpec($input, $state)
  let $state := p:try-GroupingSpecList-1($input, $state)
  return $state
};

(:~
 : Parse GroupByClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GroupByClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(141, $input, $state)                (: 'group' :)
  let $state := p:lookahead1W(36, $input, $state)           (: S^WS | ('(' ':') | 'by' :)
  let $state := p:shift(86, $input, $state)                 (: 'by' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-GroupingSpecList($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "GroupByClause", $count, $begin, $end)
};

(:~
 : Try parsing GroupByClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-GroupByClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(141, $input, $state)               (: 'group' :)
  let $state := p:lookahead1W(36, $input, $state)           (: S^WS | ('(' ':') | 'by' :)
  let $state := p:shiftT(86, $input, $state)                (: 'by' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:try-GroupingSpecList($input, $state)
  return $state
};

(:~
 : Parse WhereClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WhereClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(248, $input, $state)                (: 'where' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "WhereClause", $count, $begin, $end)
};

(:~
 : Try parsing WhereClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-WhereClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(248, $input, $state)               (: 'where' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse IntermediateClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntermediateClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 131                                 (: 'for' :)
     or $state[$p:l1] = 162) then                           (: 'let' :)
      let $state := p:parse-InitialClause($input, $state)
      return $state
    else if ($state[$p:l1] = 248) then                      (: 'where' :)
      let $state := p:parse-WhereClause($input, $state)
      return $state
    else if ($state[$p:l1] = 141) then                      (: 'group' :)
      let $state := p:parse-GroupByClause($input, $state)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'count' :)
      let $state := p:parse-CountClause($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-OrderByClause($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "IntermediateClause", $count, $begin, $end)
};

(:~
 : Try parsing IntermediateClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-IntermediateClause($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 131                                 (: 'for' :)
     or $state[$p:l1] = 162) then                           (: 'let' :)
      let $state := p:try-InitialClause($input, $state)
      return $state
    else if ($state[$p:l1] = 248) then                      (: 'where' :)
      let $state := p:try-WhereClause($input, $state)
      return $state
    else if ($state[$p:l1] = 141) then                      (: 'group' :)
      let $state := p:try-GroupByClause($input, $state)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'count' :)
      let $state := p:try-CountClause($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-OrderByClause($input, $state)
      return $state
  return $state
};

(:~
 : Parse SlidingWindowClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SlidingWindowClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(218, $input, $state)                (: 'sliding' :)
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | 'window' :)
  let $state := p:shift(250, $input, $state)                (: 'window' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(100, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shift(147, $input, $state)                (: 'in' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-WindowStartCondition($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-WindowEndCondition($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SlidingWindowClause", $count, $begin, $end)
};

(:~
 : Try parsing SlidingWindowClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-SlidingWindowClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(218, $input, $state)               (: 'sliding' :)
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | 'window' :)
  let $state := p:shiftT(250, $input, $state)               (: 'window' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shiftT(31, $input, $state)                (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-VarName($input, $state)
  let $state := p:lookahead1W(100, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:try-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shiftT(147, $input, $state)               (: 'in' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  let $state := p:try-WindowStartCondition($input, $state)
  let $state := p:try-WindowEndCondition($input, $state)
  return $state
};

(:~
 : Parse WindowEndCondition.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WindowEndCondition($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 183) then                      (: 'only' :)
      let $state := p:shift(183, $input, $state)            (: 'only' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(48, $input, $state)           (: S^WS | ('(' ':') | 'end' :)
  let $state := p:shift(121, $input, $state)                (: 'end' :)
  let $state := p:lookahead1W(157, $input, $state)          (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-WindowVars($input, $state)
  let $state := p:lookahead1W(77, $input, $state)           (: S^WS | ('(' ':') | 'when' :)
  let $state := p:shift(247, $input, $state)                (: 'when' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "WindowEndCondition", $count, $begin, $end)
};

(:~
 : Try parsing WindowEndCondition.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-WindowEndCondition($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 183) then                      (: 'only' :)
      let $state := p:shiftT(183, $input, $state)           (: 'only' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(48, $input, $state)           (: S^WS | ('(' ':') | 'end' :)
  let $state := p:shiftT(121, $input, $state)               (: 'end' :)
  let $state := p:lookahead1W(157, $input, $state)          (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' :)
  let $state := p:try-WindowVars($input, $state)
  let $state := p:lookahead1W(77, $input, $state)           (: S^WS | ('(' ':') | 'when' :)
  let $state := p:shiftT(247, $input, $state)               (: 'when' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse NextItem.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NextItem($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "NextItem", $count, $begin, $end)
};

(:~
 : Try parsing NextItem.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-NextItem($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-EQName($input, $state)
  return $state
};

(:~
 : Parse PreviousItem.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PreviousItem($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PreviousItem", $count, $begin, $end)
};

(:~
 : Try parsing PreviousItem.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-PreviousItem($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-EQName($input, $state)
  return $state
};

(:~
 : Parse CurrentItem.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CurrentItem($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CurrentItem", $count, $begin, $end)
};

(:~
 : Try parsing CurrentItem.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CurrentItem($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-EQName($input, $state)
  return $state
};

(:~
 : Parse WindowVars.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WindowVars($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-CurrentItem($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(153, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'next' | 'previous' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 80) then                       (: 'at' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(147, $input, $state)          (: S^WS | ('(' ':') | 'next' | 'previous' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 199) then                      (: 'previous' :)
      let $state := p:shift(199, $input, $state)            (: 'previous' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-PreviousItem($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(117, $input, $state)          (: S^WS | ('(' ':') | 'next' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 174) then                      (: 'next' :)
      let $state := p:shift(174, $input, $state)            (: 'next' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-NextItem($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "WindowVars", $count, $begin, $end)
};

(:~
 : Try parsing WindowVars.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-WindowVars($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:shiftT(31, $input, $state)            (: '$' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-CurrentItem($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(153, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'next' | 'previous' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 80) then                       (: 'at' :)
      let $state := p:try-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(147, $input, $state)          (: S^WS | ('(' ':') | 'next' | 'previous' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 199) then                      (: 'previous' :)
      let $state := p:shiftT(199, $input, $state)           (: 'previous' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:shiftT(31, $input, $state)            (: '$' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-PreviousItem($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(117, $input, $state)          (: S^WS | ('(' ':') | 'next' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 174) then                      (: 'next' :)
      let $state := p:shiftT(174, $input, $state)           (: 'next' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:shiftT(31, $input, $state)            (: '$' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-NextItem($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse WindowStartCondition.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WindowStartCondition($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(221, $input, $state)                (: 'start' :)
  let $state := p:lookahead1W(157, $input, $state)          (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-WindowVars($input, $state)
  let $state := p:lookahead1W(77, $input, $state)           (: S^WS | ('(' ':') | 'when' :)
  let $state := p:shift(247, $input, $state)                (: 'when' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "WindowStartCondition", $count, $begin, $end)
};

(:~
 : Try parsing WindowStartCondition.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-WindowStartCondition($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(221, $input, $state)               (: 'start' :)
  let $state := p:lookahead1W(157, $input, $state)          (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' :)
  let $state := p:try-WindowVars($input, $state)
  let $state := p:lookahead1W(77, $input, $state)           (: S^WS | ('(' ':') | 'when' :)
  let $state := p:shiftT(247, $input, $state)               (: 'when' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse TumblingWindowClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TumblingWindowClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(235, $input, $state)                (: 'tumbling' :)
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | 'window' :)
  let $state := p:shift(250, $input, $state)                (: 'window' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(100, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shift(147, $input, $state)                (: 'in' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-WindowStartCondition($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 121                            (: 'end' :)
          or $state[$p:l1] = 183) then                      (: 'only' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-WindowEndCondition($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "TumblingWindowClause", $count, $begin, $end)
};

(:~
 : Try parsing TumblingWindowClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-TumblingWindowClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(235, $input, $state)               (: 'tumbling' :)
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | 'window' :)
  let $state := p:shiftT(250, $input, $state)               (: 'window' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shiftT(31, $input, $state)                (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-VarName($input, $state)
  let $state := p:lookahead1W(100, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:try-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shiftT(147, $input, $state)               (: 'in' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  let $state := p:try-WindowStartCondition($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 121                            (: 'end' :)
          or $state[$p:l1] = 183) then                      (: 'only' :)
      let $state := p:try-WindowEndCondition($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse WindowClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WindowClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(131, $input, $state)                (: 'for' :)
  let $state := p:lookahead1W(127, $input, $state)          (: S^WS | ('(' ':') | 'sliding' | 'tumbling' :)
  let $state :=
    if ($state[$p:l1] = 235) then                           (: 'tumbling' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TumblingWindowClause($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SlidingWindowClause($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "WindowClause", $count, $begin, $end)
};

(:~
 : Try parsing WindowClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-WindowClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(131, $input, $state)               (: 'for' :)
  let $state := p:lookahead1W(127, $input, $state)          (: S^WS | ('(' ':') | 'sliding' | 'tumbling' :)
  let $state :=
    if ($state[$p:l1] = 235) then                           (: 'tumbling' :)
      let $state := p:try-TumblingWindowClause($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-SlidingWindowClause($input, $state)
      return $state
  return $state
};

(:~
 : Parse LetBinding.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetBinding($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(96, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:shift(51, $input, $state)                 (: ':=' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "LetBinding", $count, $begin, $end)
};

(:~
 : Try parsing LetBinding.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-LetBinding($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(31, $input, $state)                (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-VarName($input, $state)
  let $state := p:lookahead1W(96, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:try-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:shiftT(51, $input, $state)                (: ':=' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production LetClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 41) then                           (: ',' :)
      $state
    else
      let $state := p:shift(41, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-LetBinding($input, $state)
      return p:parse-LetClause-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production LetClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-LetClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 41) then                           (: ',' :)
      $state
    else
      let $state := p:shiftT(41, $input, $state)            (: ',' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:try-LetBinding($input, $state)
      return p:try-LetClause-1($input, $state)
};

(:~
 : Parse LetClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(162, $input, $state)                (: 'let' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-LetBinding($input, $state)
  let $state := p:parse-LetClause-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "LetClause", $count, $begin, $end)
};

(:~
 : Try parsing LetClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-LetClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(162, $input, $state)               (: 'let' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:try-LetBinding($input, $state)
  let $state := p:try-LetClause-1($input, $state)
  return $state
};

(:~
 : Parse PositionalVar.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PositionalVar($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(80, $input, $state)                 (: 'at' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PositionalVar", $count, $begin, $end)
};

(:~
 : Try parsing PositionalVar.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-PositionalVar($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(80, $input, $state)                (: 'at' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shiftT(31, $input, $state)                (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-VarName($input, $state)
  return $state
};

(:~
 : Parse AllowingEmpty.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AllowingEmpty($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(73, $input, $state)                 (: 'allowing' :)
  let $state := p:lookahead1W(47, $input, $state)           (: S^WS | ('(' ':') | 'empty' :)
  let $state := p:shift(118, $input, $state)                (: 'empty' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AllowingEmpty", $count, $begin, $end)
};

(:~
 : Try parsing AllowingEmpty.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AllowingEmpty($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(73, $input, $state)                (: 'allowing' :)
  let $state := p:lookahead1W(47, $input, $state)           (: S^WS | ('(' ':') | 'empty' :)
  let $state := p:shiftT(118, $input, $state)               (: 'empty' :)
  return $state
};

(:~
 : Parse TypeDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(78, $input, $state)                 (: 'as' :)
  let $state := p:lookahead1W(235, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-SequenceType($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypeDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing TypeDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-TypeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(78, $input, $state)                (: 'as' :)
  let $state := p:lookahead1W(235, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-SequenceType($input, $state)
  return $state
};

(:~
 : Parse VarName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VarName", $count, $begin, $end)
};

(:~
 : Try parsing VarName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-VarName($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-EQName($input, $state)
  return $state
};

(:~
 : Parse ForBinding.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForBinding($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(152, $input, $state)          (: S^WS | ('(' ':') | 'allowing' | 'as' | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(140, $input, $state)          (: S^WS | ('(' ':') | 'allowing' | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 73) then                       (: 'allowing' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AllowingEmpty($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(103, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 80) then                       (: 'at' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shift(147, $input, $state)                (: 'in' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ForBinding", $count, $begin, $end)
};

(:~
 : Try parsing ForBinding.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ForBinding($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(31, $input, $state)                (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-VarName($input, $state)
  let $state := p:lookahead1W(152, $input, $state)          (: S^WS | ('(' ':') | 'allowing' | 'as' | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:try-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(140, $input, $state)          (: S^WS | ('(' ':') | 'allowing' | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 73) then                       (: 'allowing' :)
      let $state := p:try-AllowingEmpty($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(103, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 80) then                       (: 'at' :)
      let $state := p:try-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shiftT(147, $input, $state)               (: 'in' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production ForClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 41) then                           (: ',' :)
      $state
    else
      let $state := p:shift(41, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ForBinding($input, $state)
      return p:parse-ForClause-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ForClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ForClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 41) then                           (: ',' :)
      $state
    else
      let $state := p:shiftT(41, $input, $state)            (: ',' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:try-ForBinding($input, $state)
      return p:try-ForClause-1($input, $state)
};

(:~
 : Parse ForClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(131, $input, $state)                (: 'for' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ForBinding($input, $state)
  let $state := p:parse-ForClause-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ForClause", $count, $begin, $end)
};

(:~
 : Try parsing ForClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ForClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(131, $input, $state)               (: 'for' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:try-ForBinding($input, $state)
  let $state := p:try-ForClause-1($input, $state)
  return $state
};

(:~
 : Parse InitialClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InitialClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 131) then                           (: 'for' :)
      let $state := p:lookahead2W(134, $input, $state)      (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 16003) then                         (: 'for' '$' :)
      let $state := p:parse-ForClause($input, $state)
      return $state
    else if ($state[$p:lk] = 162) then                      (: 'let' :)
      let $state := p:parse-LetClause($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-WindowClause($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "InitialClause", $count, $begin, $end)
};

(:~
 : Try parsing InitialClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-InitialClause($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 131) then                           (: 'for' :)
      let $state := p:lookahead2W(134, $input, $state)      (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 16003) then                         (: 'for' '$' :)
      let $state := p:try-ForClause($input, $state)
      return $state
    else if ($state[$p:lk] = 162) then                      (: 'let' :)
      let $state := p:try-LetClause($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-WindowClause($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production FLWORExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FLWORExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(167, $input, $state)        (: S^WS | ('(' ':') | 'count' | 'for' | 'group' | 'let' |
                                                               'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] = 206) then                         (: 'return' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-IntermediateClause($input, $state)
        return p:parse-FLWORExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FLWORExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FLWORExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(167, $input, $state)        (: S^WS | ('(' ':') | 'count' | 'for' | 'group' | 'let' |
                                                               'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] = 206) then                         (: 'return' :)
        $state
      else
        let $state := p:try-IntermediateClause($input, $state)
        return p:try-FLWORExpr-1($input, $state)
};

(:~
 : Parse FLWORExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FLWORExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-InitialClause($input, $state)
  let $state := p:parse-FLWORExpr-1($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ReturnClause($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FLWORExpr", $count, $begin, $end)
};

(:~
 : Try parsing FLWORExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FLWORExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-InitialClause($input, $state)
  let $state := p:try-FLWORExpr-1($input, $state)
  let $state := p:try-ReturnClause($input, $state)
  return $state
};

(:~
 : Parse ExprSingle.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExprSingle($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 131) then                           (: 'for' :)
      let $state := p:lookahead2W(212, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '$' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'sliding' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'tumbling' | 'union' | 'where' | 'with' | '|' | '||' |
                                                               '}' :)
      return $state
    else if ($state[$p:l1] = 204) then                      (: 'rename' :)
      let $state := p:lookahead2W(207, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'node' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               'with' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 205) then                      (: 'replace' :)
      let $state := p:lookahead2W(210, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'node' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'value' |
                                                               'where' | 'with' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 234) then                      (: 'try' :)
      let $state := p:lookahead2W(208, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'start' | 'to' | 'treat' | 'union' | 'where' | 'with' |
                                                               '{' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 105                            (: 'insert' :)
          or $state[$p:l1] = 151) then                      (: 'insert' :)
      let $state := p:lookahead2W(209, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'node' |
                                                               'nodes' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' | 'with' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 145                            (: 'switch' :)
          or $state[$p:l1] = 227                            (: 'typeswitch' :)
          or $state[$p:l1] = 237) then                      (: 'typeswitch' :)
      let $state := p:lookahead2W(205, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'start' | 'to' | 'treat' | 'union' | 'where' | 'with' |
                                                               '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 98                             (: 'every' :)
          or $state[$p:l1] = 124                            (: 'let' :)
          or $state[$p:l1] = 162                            (: 'some' :)
          or $state[$p:l1] = 219) then                      (: 'some' :)
      let $state := p:lookahead2W(206, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '$' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               'with' | '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 16003                               (: 'for' '$' :)
     or $state[$p:lk] = 16034                               (: 'let' '$' :)
     or $state[$p:lk] = 111747                              (: 'for' 'sliding' :)
     or $state[$p:lk] = 120451) then                        (: 'for' 'tumbling' :)
      let $state := p:parse-FLWORExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 15996                          (: 'every' '$' :)
          or $state[$p:lk] = 16091) then                    (: 'some' '$' :)
      let $state := p:parse-QuantifiedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 17635) then                    (: 'switch' '(' :)
      let $state := p:parse-SwitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 17645) then                    (: 'typeswitch' '(' :)
      let $state := p:parse-TypeswitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 17553) then                    (: 'if' '(' :)
      let $state := p:parse-IfExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 131818) then                   (: 'try' '{' :)
      let $state := p:parse-TryCatchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 91287                          (: 'insert' 'node' :)
          or $state[$p:lk] = 91799) then                    (: 'insert' 'nodes' :)
      let $state := p:parse-InsertExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 91241                          (: 'delete' 'node' :)
          or $state[$p:lk] = 91753) then                    (: 'delete' 'nodes' :)
      let $state := p:parse-DeleteExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 91340) then                    (: 'rename' 'node' :)
      let $state := p:parse-RenameExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 91341                          (: 'replace' 'node' :)
          or $state[$p:lk] = 124621) then                   (: 'replace' 'value' :)
      let $state := p:parse-ReplaceExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 15970) then                    (: 'copy' '$' :)
      let $state := p:parse-TransformExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-OrExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ExprSingle", $count, $begin, $end)
};

(:~
 : Try parsing ExprSingle.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ExprSingle($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 131) then                           (: 'for' :)
      let $state := p:lookahead2W(212, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '$' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'sliding' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'tumbling' | 'union' | 'where' | 'with' | '|' | '||' |
                                                               '}' :)
      return $state
    else if ($state[$p:l1] = 204) then                      (: 'rename' :)
      let $state := p:lookahead2W(207, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'node' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               'with' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 205) then                      (: 'replace' :)
      let $state := p:lookahead2W(210, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'node' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'value' |
                                                               'where' | 'with' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 234) then                      (: 'try' :)
      let $state := p:lookahead2W(208, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'start' | 'to' | 'treat' | 'union' | 'where' | 'with' |
                                                               '{' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 105                            (: 'insert' :)
          or $state[$p:l1] = 151) then                      (: 'insert' :)
      let $state := p:lookahead2W(209, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'node' |
                                                               'nodes' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' | 'with' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 145                            (: 'switch' :)
          or $state[$p:l1] = 227                            (: 'typeswitch' :)
          or $state[$p:l1] = 237) then                      (: 'typeswitch' :)
      let $state := p:lookahead2W(205, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'start' | 'to' | 'treat' | 'union' | 'where' | 'with' |
                                                               '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 98                             (: 'every' :)
          or $state[$p:l1] = 124                            (: 'let' :)
          or $state[$p:l1] = 162                            (: 'some' :)
          or $state[$p:l1] = 219) then                      (: 'some' :)
      let $state := p:lookahead2W(206, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '$' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               'with' | '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 16003                               (: 'for' '$' :)
     or $state[$p:lk] = 16034                               (: 'let' '$' :)
     or $state[$p:lk] = 111747                              (: 'for' 'sliding' :)
     or $state[$p:lk] = 120451) then                        (: 'for' 'tumbling' :)
      let $state := p:try-FLWORExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 15996                          (: 'every' '$' :)
          or $state[$p:lk] = 16091) then                    (: 'some' '$' :)
      let $state := p:try-QuantifiedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 17635) then                    (: 'switch' '(' :)
      let $state := p:try-SwitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 17645) then                    (: 'typeswitch' '(' :)
      let $state := p:try-TypeswitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 17553) then                    (: 'if' '(' :)
      let $state := p:try-IfExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 131818) then                   (: 'try' '{' :)
      let $state := p:try-TryCatchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 91287                          (: 'insert' 'node' :)
          or $state[$p:lk] = 91799) then                    (: 'insert' 'nodes' :)
      let $state := p:try-InsertExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 91241                          (: 'delete' 'node' :)
          or $state[$p:lk] = 91753) then                    (: 'delete' 'nodes' :)
      let $state := p:try-DeleteExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 91340) then                    (: 'rename' 'node' :)
      let $state := p:try-RenameExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 91341                          (: 'replace' 'node' :)
          or $state[$p:lk] = 124621) then                   (: 'replace' 'value' :)
      let $state := p:try-ReplaceExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 15970) then                    (: 'copy' '$' :)
      let $state := p:try-TransformExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-OrExpr($input, $state)
      return $state
  return $state
};

(:~
 : Parse VarValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VarValue", $count, $begin, $end)
};

(:~
 : Parse ParenthesizedItemType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParenthesizedItemType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(235, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ItemType($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ParenthesizedItemType", $count, $begin, $end)
};

(:~
 : Try parsing ParenthesizedItemType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ParenthesizedItemType($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(235, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ItemType($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  return $state
};

(:~
 : Parse AtomicOrUnionType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AtomicOrUnionType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AtomicOrUnionType", $count, $begin, $end)
};

(:~
 : Try parsing AtomicOrUnionType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AtomicOrUnionType($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-EQName($input, $state)
  return $state
};

(:~
 : Parse OccurrenceIndicator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OccurrenceIndicator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 64) then                            (: '?' :)
      let $state := p:shift(64, $input, $state)             (: '?' :)
      return $state
    else if ($state[$p:l1] = 39) then                       (: '*' :)
      let $state := p:shift(39, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(40, $input, $state)             (: '+' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "OccurrenceIndicator", $count, $begin, $end)
};

(:~
 : Try parsing OccurrenceIndicator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-OccurrenceIndicator($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 64) then                            (: '?' :)
      let $state := p:shiftT(64, $input, $state)            (: '?' :)
      return $state
    else if ($state[$p:l1] = 39) then                       (: '*' :)
      let $state := p:shiftT(39, $input, $state)            (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(40, $input, $state)            (: '+' :)
      return $state
  return $state
};

(:~
 : Parse SequenceType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SequenceType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 119) then                           (: 'empty-sequence' :)
      let $state := p:lookahead2W(219, $input, $state)      (: EOF | S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '*' |
                                                               '+' | ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'after' | 'allowing' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'external' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'in' | 'instance' | 'intersect' | 'into' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' |
                                                               'only' | 'or' | 'order' | 'paragraphs' | 'return' |
                                                               'satisfies' | 'sentences' | 'stable' | 'start' |
                                                               'times' | 'to' | 'union' | 'where' | 'with' | 'words' |
                                                               '{' | '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 17527) then                         (: 'empty-sequence' '(' :)
      let $state := p:shift(119, $input, $state)            (: 'empty-sequence' :)
      let $state := p:lookahead1W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:shift(34, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:shift(37, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ItemType($input, $state)
      let $state := p:lookahead1W(216, $input, $state)      (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '*' | '+' |
                                                               ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '?' | ']' | 'after' | 'allowing' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'external' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'in' | 'instance' | 'intersect' | 'into' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' |
                                                               'only' | 'or' | 'order' | 'paragraphs' | 'return' |
                                                               'satisfies' | 'sentences' | 'stable' | 'start' |
                                                               'times' | 'to' | 'union' | 'where' | 'with' | 'words' |
                                                               '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:l1] = 39                              (: '*' :)
         or $state[$p:l1] = 40                              (: '+' :)
         or $state[$p:l1] = 64) then                        (: '?' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-OccurrenceIndicator($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SequenceType", $count, $begin, $end)
};

(:~
 : Try parsing SequenceType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-SequenceType($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 119) then                           (: 'empty-sequence' :)
      let $state := p:lookahead2W(219, $input, $state)      (: EOF | S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '*' |
                                                               '+' | ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'after' | 'allowing' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'external' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'in' | 'instance' | 'intersect' | 'into' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' |
                                                               'only' | 'or' | 'order' | 'paragraphs' | 'return' |
                                                               'satisfies' | 'sentences' | 'stable' | 'start' |
                                                               'times' | 'to' | 'union' | 'where' | 'with' | 'words' |
                                                               '{' | '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 17527) then                         (: 'empty-sequence' '(' :)
      let $state := p:shiftT(119, $input, $state)           (: 'empty-sequence' :)
      let $state := p:lookahead1W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:shiftT(34, $input, $state)            (: '(' :)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:shiftT(37, $input, $state)            (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-ItemType($input, $state)
      let $state := p:lookahead1W(216, $input, $state)      (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '*' | '+' |
                                                               ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '?' | ']' | 'after' | 'allowing' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'external' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'in' | 'instance' | 'intersect' | 'into' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' |
                                                               'only' | 'or' | 'order' | 'paragraphs' | 'return' |
                                                               'satisfies' | 'sentences' | 'stable' | 'start' |
                                                               'times' | 'to' | 'union' | 'where' | 'with' | 'words' |
                                                               '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:l1] = 39                              (: '*' :)
         or $state[$p:l1] = 40                              (: '+' :)
         or $state[$p:l1] = 64) then                        (: '?' :)
          let $state := p:try-OccurrenceIndicator($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          $state
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production TypedFunctionTest (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypedFunctionTest-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(92, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(235, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-SequenceType($input, $state)
        return p:parse-TypedFunctionTest-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production TypedFunctionTest (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-TypedFunctionTest-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(92, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shiftT(41, $input, $state)          (: ',' :)
        let $state := p:lookahead1W(235, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
        let $state := p:try-SequenceType($input, $state)
        return p:try-TypedFunctionTest-1($input, $state)
};

(:~
 : Parse TypedFunctionTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypedFunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(138, $input, $state)                (: 'function' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(238, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | ')' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SequenceType($input, $state)
      let $state := p:parse-TypedFunctionTest-1($input, $state)
      return $state
    else
      $state
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(32, $input, $state)           (: S^WS | ('(' ':') | 'as' :)
  let $state := p:shift(78, $input, $state)                 (: 'as' :)
  let $state := p:lookahead1W(235, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-SequenceType($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypedFunctionTest", $count, $begin, $end)
};

(:~
 : Try parsing TypedFunctionTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-TypedFunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(138, $input, $state)               (: 'function' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(238, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | ')' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:try-SequenceType($input, $state)
      let $state := p:try-TypedFunctionTest-1($input, $state)
      return $state
    else
      $state
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  let $state := p:lookahead1W(32, $input, $state)           (: S^WS | ('(' ':') | 'as' :)
  let $state := p:shiftT(78, $input, $state)                (: 'as' :)
  let $state := p:lookahead1W(235, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-SequenceType($input, $state)
  return $state
};

(:~
 : Parse AnyFunctionTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnyFunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(138, $input, $state)                (: 'function' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(26, $input, $state)           (: S^WS | ('(' ':') | '*' :)
  let $state := p:shift(38, $input, $state)                 (: '*' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AnyFunctionTest", $count, $begin, $end)
};

(:~
 : Try parsing AnyFunctionTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AnyFunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(138, $input, $state)               (: 'function' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(26, $input, $state)           (: S^WS | ('(' ':') | '*' :)
  let $state := p:shiftT(38, $input, $state)                (: '*' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  return $state
};

(:~
 : Parse NumericLiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NumericLiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 9) then                             (: IntegerLiteral :)
      let $state := p:shift(9, $input, $state)              (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 10) then                       (: DecimalLiteral :)
      let $state := p:shift(10, $input, $state)             (: DecimalLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(11, $input, $state)             (: DoubleLiteral :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NumericLiteral", $count, $begin, $end)
};

(:~
 : Try parsing NumericLiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-NumericLiteral($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 9) then                             (: IntegerLiteral :)
      let $state := p:shiftT(9, $input, $state)             (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 10) then                       (: DecimalLiteral :)
      let $state := p:shiftT(10, $input, $state)            (: DecimalLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(11, $input, $state)            (: DoubleLiteral :)
      return $state
  return $state
};

(:~
 : Parse Literal.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Literal($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 12) then                            (: StringLiteral :)
      let $state := p:shift(12, $input, $state)             (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NumericLiteral($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Literal", $count, $begin, $end)
};

(:~
 : Try parsing Literal.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Literal($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 12) then                            (: StringLiteral :)
      let $state := p:shiftT(12, $input, $state)            (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-NumericLiteral($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production Annotation (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Annotation-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(92, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(148, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | ('(' ':') :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Literal($input, $state)
        return p:parse-Annotation-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production Annotation (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Annotation-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(92, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shiftT(41, $input, $state)          (: ',' :)
        let $state := p:lookahead1W(148, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | ('(' ':') :)
        let $state := p:try-Literal($input, $state)
        return p:try-Annotation-1($input, $state)
};

(:~
 : Parse Annotation.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Annotation($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 32) then                            (: '%' :)
      let $state := p:shift(32, $input, $state)             (: '%' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-EQName($input, $state)
      let $state := p:lookahead1W(158, $input, $state)      (: S^WS | '%' | '(' | ('(' ':') | 'function' | 'private' |
                                                               'variable' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 34) then                   (: '(' :)
          let $state := p:shift(34, $input, $state)         (: '(' :)
          let $state := p:lookahead1W(148, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | ('(' ':') :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-Literal($input, $state)
          let $state := p:parse-Annotation-1($input, $state)
          let $state := p:shift(37, $input, $state)         (: ')' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(200, $input, $state)            (: 'private' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Annotation", $count, $begin, $end)
};

(:~
 : Try parsing Annotation.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Annotation($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 32) then                            (: '%' :)
      let $state := p:shiftT(32, $input, $state)            (: '%' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-EQName($input, $state)
      let $state := p:lookahead1W(158, $input, $state)      (: S^WS | '%' | '(' | ('(' ':') | 'function' | 'private' |
                                                               'variable' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 34) then                   (: '(' :)
          let $state := p:shiftT(34, $input, $state)        (: '(' :)
          let $state := p:lookahead1W(148, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | ('(' ':') :)
          let $state := p:try-Literal($input, $state)
          let $state := p:try-Annotation-1($input, $state)
          let $state := p:shiftT(37, $input, $state)        (: ')' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(200, $input, $state)           (: 'private' :)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production FunctionTest (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionTest-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(135, $input, $state)        (: S^WS | '%' | ('(' ':') | 'function' | 'private' :)
    return
      if ($state[$p:l1] = 138) then                         (: 'function' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Annotation($input, $state)
        return p:parse-FunctionTest-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FunctionTest (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FunctionTest-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(135, $input, $state)        (: S^WS | '%' | ('(' ':') | 'function' | 'private' :)
    return
      if ($state[$p:l1] = 138) then                         (: 'function' :)
        $state
      else
        let $state := p:try-Annotation($input, $state)
        return p:try-FunctionTest-1($input, $state)
};

(:~
 : Parse FunctionTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FunctionTest-1($input, $state)
  let $state :=
    if ($state[$p:l1] = 138) then                           (: 'function' :)
      let $state := p:lookahead2W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state :=
        if ($state[$p:lk] = 17546) then                     (: 'function' '(' :)
          let $state := p:lookahead3W(239, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | ')' | '*' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 9979018) then                       (: 'function' '(' '*' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AnyFunctionTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TypedFunctionTest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionTest", $count, $begin, $end)
};

(:~
 : Try parsing FunctionTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-FunctionTest-1($input, $state)
  let $state :=
    if ($state[$p:l1] = 138) then                           (: 'function' :)
      let $state := p:lookahead2W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state :=
        if ($state[$p:lk] = 17546) then                     (: 'function' '(' :)
          let $state := p:lookahead3W(239, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | ')' | '*' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 9979018) then                       (: 'function' '(' '*' :)
      let $state := p:try-AnyFunctionTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-TypedFunctionTest($input, $state)
      return $state
  return $state
};

(:~
 : Parse BinaryTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BinaryTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(84, $input, $state)                 (: 'binary' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "BinaryTest", $count, $begin, $end)
};

(:~
 : Try parsing BinaryTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-BinaryTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(84, $input, $state)                (: 'binary' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  return $state
};

(:~
 : Parse AnyKindTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnyKindTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(178, $input, $state)                (: 'node' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AnyKindTest", $count, $begin, $end)
};

(:~
 : Try parsing AnyKindTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AnyKindTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(178, $input, $state)               (: 'node' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  return $state
};

(:~
 : Parse NamespaceNodeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NamespaceNodeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(172, $input, $state)                (: 'namespace-node' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "NamespaceNodeTest", $count, $begin, $end)
};

(:~
 : Try parsing NamespaceNodeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-NamespaceNodeTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(172, $input, $state)               (: 'namespace-node' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  return $state
};

(:~
 : Parse TextTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TextTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(228, $input, $state)                (: 'text' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "TextTest", $count, $begin, $end)
};

(:~
 : Try parsing TextTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-TextTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(228, $input, $state)               (: 'text' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  return $state
};

(:~
 : Parse CommentTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CommentTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(93, $input, $state)                 (: 'comment' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CommentTest", $count, $begin, $end)
};

(:~
 : Try parsing CommentTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CommentTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(93, $input, $state)                (: 'comment' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  return $state
};

(:~
 : Parse PITest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PITest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(201, $input, $state)                (: 'processing-instruction' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(183, $input, $state)          (: StringLiteral | NCName^Token | S^WS | ('(' ':') | ')' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'treat' | 'try' | 'union' |
                                                               'where' | 'with' | 'words' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:l1] = 12) then                        (: StringLiteral :)
          let $state := p:shift(12, $input, $state)         (: StringLiteral :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:whitespace($input, $state)
          let $state := p:parse-NCName($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "PITest", $count, $begin, $end)
};

(:~
 : Try parsing PITest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-PITest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(201, $input, $state)               (: 'processing-instruction' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(183, $input, $state)          (: StringLiteral | NCName^Token | S^WS | ('(' ':') | ')' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'treat' | 'try' | 'union' |
                                                               'where' | 'with' | 'words' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:l1] = 12) then                        (: StringLiteral :)
          let $state := p:shiftT(12, $input, $state)        (: StringLiteral :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:try-NCName($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  return $state
};

(:~
 : Parse AttributeDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-AttributeName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AttributeDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing AttributeDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AttributeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-AttributeName($input, $state)
  return $state
};

(:~
 : Parse SchemaAttributeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaAttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(211, $input, $state)                (: 'schema-attribute' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-AttributeDeclaration($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "SchemaAttributeTest", $count, $begin, $end)
};

(:~
 : Try parsing SchemaAttributeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-SchemaAttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(211, $input, $state)               (: 'schema-attribute' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-AttributeDeclaration($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  return $state
};

(:~
 : Parse AttributeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AttributeName", $count, $begin, $end)
};

(:~
 : Try parsing AttributeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AttributeName($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-EQName($input, $state)
  return $state
};

(:~
 : Parse AttribNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttribNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 38) then                            (: '*' :)
      let $state := p:shift(38, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AttributeName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "AttribNameOrWildcard", $count, $begin, $end)
};

(:~
 : Try parsing AttribNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AttribNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 38) then                            (: '*' :)
      let $state := p:shiftT(38, $input, $state)            (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-AttributeName($input, $state)
      return $state
  return $state
};

(:~
 : Parse AttributeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(81, $input, $state)                 (: 'attribute' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(236, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' |
                                                               '*' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AttribNameOrWildcard($input, $state)
      let $state := p:lookahead1W(92, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 41) then                   (: ',' :)
          let $state := p:shift(41, $input, $state)         (: ',' :)
          let $state := p:lookahead1W(229, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-TypeName($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AttributeTest", $count, $begin, $end)
};

(:~
 : Try parsing AttributeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(81, $input, $state)                (: 'attribute' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(236, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' |
                                                               '*' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:try-AttribNameOrWildcard($input, $state)
      let $state := p:lookahead1W(92, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 41) then                   (: ',' :)
          let $state := p:shiftT(41, $input, $state)        (: ',' :)
          let $state := p:lookahead1W(229, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
          let $state := p:try-TypeName($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  return $state
};

(:~
 : Parse ElementDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ElementName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ElementDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing ElementDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ElementDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-ElementName($input, $state)
  return $state
};

(:~
 : Parse SchemaElementTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaElementTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(212, $input, $state)                (: 'schema-element' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ElementDeclaration($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "SchemaElementTest", $count, $begin, $end)
};

(:~
 : Try parsing SchemaElementTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-SchemaElementTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(212, $input, $state)               (: 'schema-element' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ElementDeclaration($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  return $state
};

(:~
 : Parse TypeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypeName", $count, $begin, $end)
};

(:~
 : Try parsing TypeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-TypeName($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-EQName($input, $state)
  return $state
};

(:~
 : Parse ElementName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ElementName", $count, $begin, $end)
};

(:~
 : Try parsing ElementName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ElementName($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-EQName($input, $state)
  return $state
};

(:~
 : Parse ElementNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 38) then                            (: '*' :)
      let $state := p:shift(38, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ElementName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ElementNameOrWildcard", $count, $begin, $end)
};

(:~
 : Try parsing ElementNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ElementNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 38) then                            (: '*' :)
      let $state := p:shiftT(38, $input, $state)            (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-ElementName($input, $state)
      return $state
  return $state
};

(:~
 : Parse ElementTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(116, $input, $state)                (: 'element' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(236, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' |
                                                               '*' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ElementNameOrWildcard($input, $state)
      let $state := p:lookahead1W(92, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 41) then                   (: ',' :)
          let $state := p:shift(41, $input, $state)         (: ',' :)
          let $state := p:lookahead1W(229, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-TypeName($input, $state)
          let $state := p:lookahead1W(93, $input, $state)   (: S^WS | ('(' ':') | ')' | '?' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 64) then               (: '?' :)
              let $state := p:shift(64, $input, $state)     (: '?' :)
              return $state
            else
              $state
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ElementTest", $count, $begin, $end)
};

(:~
 : Try parsing ElementTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ElementTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(116, $input, $state)               (: 'element' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(236, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' |
                                                               '*' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:try-ElementNameOrWildcard($input, $state)
      let $state := p:lookahead1W(92, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 41) then                   (: ',' :)
          let $state := p:shiftT(41, $input, $state)        (: ',' :)
          let $state := p:lookahead1W(229, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
          let $state := p:try-TypeName($input, $state)
          let $state := p:lookahead1W(93, $input, $state)   (: S^WS | ('(' ':') | ')' | '?' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 64) then               (: '?' :)
              let $state := p:shiftT(64, $input, $state)    (: '?' :)
              return $state
            else
              $state
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  return $state
};

(:~
 : Parse DocumentTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DocumentTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(115, $input, $state)                (: 'document-node' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(138, $input, $state)          (: S^WS | ('(' ':') | ')' | 'element' | 'schema-element' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:l1] = 116) then                       (: 'element' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-ElementTest($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:whitespace($input, $state)
          let $state := p:parse-SchemaElementTest($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "DocumentTest", $count, $begin, $end)
};

(:~
 : Try parsing DocumentTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-DocumentTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(115, $input, $state)               (: 'document-node' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(138, $input, $state)          (: S^WS | ('(' ':') | ')' | 'element' | 'schema-element' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:l1] = 116) then                       (: 'element' :)
          let $state := p:try-ElementTest($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:try-SchemaElementTest($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  return $state
};

(:~
 : Parse KindTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-KindTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 115) then                           (: 'document-node' :)
      let $state := p:parse-DocumentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'element' :)
      let $state := p:parse-ElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'attribute' :)
      let $state := p:parse-AttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 212) then                      (: 'schema-element' :)
      let $state := p:parse-SchemaElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 211) then                      (: 'schema-attribute' :)
      let $state := p:parse-SchemaAttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 201) then                      (: 'processing-instruction' :)
      let $state := p:parse-PITest($input, $state)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'comment' :)
      let $state := p:parse-CommentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 228) then                      (: 'text' :)
      let $state := p:parse-TextTest($input, $state)
      return $state
    else if ($state[$p:l1] = 172) then                      (: 'namespace-node' :)
      let $state := p:parse-NamespaceNodeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 178) then                      (: 'node' :)
      let $state := p:parse-AnyKindTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-BinaryTest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "KindTest", $count, $begin, $end)
};

(:~
 : Try parsing KindTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-KindTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 115) then                           (: 'document-node' :)
      let $state := p:try-DocumentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'element' :)
      let $state := p:try-ElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'attribute' :)
      let $state := p:try-AttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 212) then                      (: 'schema-element' :)
      let $state := p:try-SchemaElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 211) then                      (: 'schema-attribute' :)
      let $state := p:try-SchemaAttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 201) then                      (: 'processing-instruction' :)
      let $state := p:try-PITest($input, $state)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'comment' :)
      let $state := p:try-CommentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 228) then                      (: 'text' :)
      let $state := p:try-TextTest($input, $state)
      return $state
    else if ($state[$p:l1] = 172) then                      (: 'namespace-node' :)
      let $state := p:try-NamespaceNodeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 178) then                      (: 'node' :)
      let $state := p:try-AnyKindTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-BinaryTest($input, $state)
      return $state
  return $state
};

(:~
 : Parse ItemType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ItemType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 200) then                           (: 'private' :)
      let $state := p:lookahead2W(222, $input, $state)      (: EOF | S^WS | '!=' | '%' | ('(' ':') | ')' | '*' | '*' |
                                                               '+' | ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'after' | 'allowing' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'external' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'private' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'union' | 'where' | 'with' | 'words' | '{' | '|' | '||' |
                                                               '}' :)
      return $state
    else if ($state[$p:l1] = 81                             (: 'binary' :)
          or $state[$p:l1] = 84                             (: 'comment' :)
          or $state[$p:l1] = 93                             (: 'document-node' :)
          or $state[$p:l1] = 115                            (: 'element' :)
          or $state[$p:l1] = 116                            (: 'function' :)
          or $state[$p:l1] = 138                            (: 'item' :)
          or $state[$p:l1] = 156                            (: 'namespace-node' :)
          or $state[$p:l1] = 172                            (: 'node' :)
          or $state[$p:l1] = 178                            (: 'processing-instruction' :)
          or $state[$p:l1] = 201                            (: 'schema-attribute' :)
          or $state[$p:l1] = 211                            (: 'schema-element' :)
          or $state[$p:l1] = 212                            (: 'text' :)
          or $state[$p:l1] = 228) then                      (: 'text' :)
      let $state := p:lookahead2W(219, $input, $state)      (: EOF | S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '*' |
                                                               '+' | ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'after' | 'allowing' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'external' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'in' | 'instance' | 'intersect' | 'into' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' |
                                                               'only' | 'or' | 'order' | 'paragraphs' | 'return' |
                                                               'satisfies' | 'sentences' | 'stable' | 'start' |
                                                               'times' | 'to' | 'union' | 'where' | 'with' | 'words' |
                                                               '{' | '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 17489                               (: 'attribute' '(' :)
     or $state[$p:lk] = 17492                               (: 'binary' '(' :)
     or $state[$p:lk] = 17501                               (: 'comment' '(' :)
     or $state[$p:lk] = 17523                               (: 'document-node' '(' :)
     or $state[$p:lk] = 17524                               (: 'element' '(' :)
     or $state[$p:lk] = 17580                               (: 'namespace-node' '(' :)
     or $state[$p:lk] = 17586                               (: 'node' '(' :)
     or $state[$p:lk] = 17609                               (: 'processing-instruction' '(' :)
     or $state[$p:lk] = 17619                               (: 'schema-attribute' '(' :)
     or $state[$p:lk] = 17620                               (: 'schema-element' '(' :)
     or $state[$p:lk] = 17636) then                         (: 'text' '(' :)
      let $state := p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:lk] = 17564) then                    (: 'item' '(' :)
      let $state := p:shift(156, $input, $state)            (: 'item' :)
      let $state := p:lookahead1W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:shift(34, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:shift(37, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:lk] = 32                             (: '%' :)
          or $state[$p:lk] = 16584                          (: 'private' '%' :)
          or $state[$p:lk] = 17546                          (: 'function' '(' :)
          or $state[$p:lk] = 70856                          (: 'private' 'function' :)
          or $state[$p:lk] = 102600) then                   (: 'private' 'private' :)
      let $state := p:parse-FunctionTest($input, $state)
      return $state
    else if ($state[$p:lk] = 34) then                       (: '(' :)
      let $state := p:parse-ParenthesizedItemType($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AtomicOrUnionType($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ItemType", $count, $begin, $end)
};

(:~
 : Try parsing ItemType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ItemType($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 200) then                           (: 'private' :)
      let $state := p:lookahead2W(222, $input, $state)      (: EOF | S^WS | '!=' | '%' | ('(' ':') | ')' | '*' | '*' |
                                                               '+' | ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'after' | 'allowing' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'external' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'private' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'union' | 'where' | 'with' | 'words' | '{' | '|' | '||' |
                                                               '}' :)
      return $state
    else if ($state[$p:l1] = 81                             (: 'binary' :)
          or $state[$p:l1] = 84                             (: 'comment' :)
          or $state[$p:l1] = 93                             (: 'document-node' :)
          or $state[$p:l1] = 115                            (: 'element' :)
          or $state[$p:l1] = 116                            (: 'function' :)
          or $state[$p:l1] = 138                            (: 'item' :)
          or $state[$p:l1] = 156                            (: 'namespace-node' :)
          or $state[$p:l1] = 172                            (: 'node' :)
          or $state[$p:l1] = 178                            (: 'processing-instruction' :)
          or $state[$p:l1] = 201                            (: 'schema-attribute' :)
          or $state[$p:l1] = 211                            (: 'schema-element' :)
          or $state[$p:l1] = 212                            (: 'text' :)
          or $state[$p:l1] = 228) then                      (: 'text' :)
      let $state := p:lookahead2W(219, $input, $state)      (: EOF | S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '*' |
                                                               '+' | ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'after' | 'allowing' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'external' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'in' | 'instance' | 'intersect' | 'into' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' |
                                                               'only' | 'or' | 'order' | 'paragraphs' | 'return' |
                                                               'satisfies' | 'sentences' | 'stable' | 'start' |
                                                               'times' | 'to' | 'union' | 'where' | 'with' | 'words' |
                                                               '{' | '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 17489                               (: 'attribute' '(' :)
     or $state[$p:lk] = 17492                               (: 'binary' '(' :)
     or $state[$p:lk] = 17501                               (: 'comment' '(' :)
     or $state[$p:lk] = 17523                               (: 'document-node' '(' :)
     or $state[$p:lk] = 17524                               (: 'element' '(' :)
     or $state[$p:lk] = 17580                               (: 'namespace-node' '(' :)
     or $state[$p:lk] = 17586                               (: 'node' '(' :)
     or $state[$p:lk] = 17609                               (: 'processing-instruction' '(' :)
     or $state[$p:lk] = 17619                               (: 'schema-attribute' '(' :)
     or $state[$p:lk] = 17620                               (: 'schema-element' '(' :)
     or $state[$p:lk] = 17636) then                         (: 'text' '(' :)
      let $state := p:try-KindTest($input, $state)
      return $state
    else if ($state[$p:lk] = 17564) then                    (: 'item' '(' :)
      let $state := p:shiftT(156, $input, $state)           (: 'item' :)
      let $state := p:lookahead1W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:shiftT(34, $input, $state)            (: '(' :)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:shiftT(37, $input, $state)            (: ')' :)
      return $state
    else if ($state[$p:lk] = 32                             (: '%' :)
          or $state[$p:lk] = 16584                          (: 'private' '%' :)
          or $state[$p:lk] = 17546                          (: 'function' '(' :)
          or $state[$p:lk] = 70856                          (: 'private' 'function' :)
          or $state[$p:lk] = 102600) then                   (: 'private' 'private' :)
      let $state := p:try-FunctionTest($input, $state)
      return $state
    else if ($state[$p:lk] = 34) then                       (: '(' :)
      let $state := p:try-ParenthesizedItemType($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-AtomicOrUnionType($input, $state)
      return $state
  return $state
};

(:~
 : Parse ContextItemDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContextItemDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(103, $input, $state)                (: 'declare' :)
  let $state := p:lookahead1W(42, $input, $state)           (: S^WS | ('(' ':') | 'context' :)
  let $state := p:shift(97, $input, $state)                 (: 'context' :)
  let $state := p:lookahead1W(53, $input, $state)           (: S^WS | ('(' ':') | 'item' :)
  let $state := p:shift(156, $input, $state)                (: 'item' :)
  let $state := p:lookahead1W(139, $input, $state)          (: S^WS | ('(' ':') | ':=' | 'as' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:shift(78, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(235, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ItemType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(97, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'external' :)
  let $state :=
    if ($state[$p:l1] = 51) then                            (: ':=' :)
      let $state := p:shift(51, $input, $state)             (: ':=' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VarValue($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(127, $input, $state)            (: 'external' :)
      let $state := p:lookahead1W(95, $input, $state)       (: S^WS | ('(' ':') | ':=' | ';' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 51) then                   (: ':=' :)
          let $state := p:shift(51, $input, $state)         (: ':=' :)
          let $state := p:lookahead1W(241, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-VarDefaultValue($input, $state)
          return $state
        else
          $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ContextItemDecl", $count, $begin, $end)
};

(:~
 : Parse FTExtensionOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTExtensionOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(184, $input, $state)                (: 'option' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:shift(12, $input, $state)                 (: StringLiteral :)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTExtensionOption", $count, $begin, $end)
};

(:~
 : Try parsing FTExtensionOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTExtensionOption($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(184, $input, $state)               (: 'option' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-EQName($input, $state)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:shiftT(12, $input, $state)                (: StringLiteral :)
  return $state
};

(:~
 : Parse FTStopWordsInclExcl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTStopWordsInclExcl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 238) then                           (: 'union' :)
      let $state := p:shift(238, $input, $state)            (: 'union' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(126, $input, $state)            (: 'except' :)
      return $state
  let $state := p:lookahead1W(90, $input, $state)           (: S^WS | '(' | ('(' ':') | 'at' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-FTStopWords($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTStopWordsInclExcl", $count, $begin, $end)
};

(:~
 : Try parsing FTStopWordsInclExcl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTStopWordsInclExcl($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 238) then                           (: 'union' :)
      let $state := p:shiftT(238, $input, $state)           (: 'union' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(126, $input, $state)           (: 'except' :)
      return $state
  let $state := p:lookahead1W(90, $input, $state)           (: S^WS | '(' | ('(' ':') | 'at' :)
  let $state := p:try-FTStopWords($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production FTStopWords (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTStopWords-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(92, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(19, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state := p:shift(12, $input, $state)           (: StringLiteral :)
        return p:parse-FTStopWords-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTStopWords (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTStopWords-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(92, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shiftT(41, $input, $state)          (: ',' :)
        let $state := p:lookahead1W(19, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state := p:shiftT(12, $input, $state)          (: StringLiteral :)
        return p:try-FTStopWords-1($input, $state)
};

(:~
 : Parse FTStopWords.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTStopWords($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 80) then                            (: 'at' :)
      let $state := p:shift(80, $input, $state)             (: 'at' :)
      let $state := p:lookahead1W(17, $input, $state)       (: URILiteral | S^WS | ('(' ':') :)
      let $state := p:shift(8, $input, $state)              (: URILiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(34, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:shift(12, $input, $state)             (: StringLiteral :)
      let $state := p:parse-FTStopWords-1($input, $state)
      let $state := p:shift(37, $input, $state)             (: ')' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTStopWords", $count, $begin, $end)
};

(:~
 : Try parsing FTStopWords.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTStopWords($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 80) then                            (: 'at' :)
      let $state := p:shiftT(80, $input, $state)            (: 'at' :)
      let $state := p:lookahead1W(17, $input, $state)       (: URILiteral | S^WS | ('(' ':') :)
      let $state := p:shiftT(8, $input, $state)             (: URILiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(34, $input, $state)            (: '(' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:shiftT(12, $input, $state)            (: StringLiteral :)
      let $state := p:try-FTStopWords-1($input, $state)
      let $state := p:shiftT(37, $input, $state)            (: ')' :)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production FTStopWordOption (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTStopWordOption-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(194, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'except' | 'for' | 'ftand' | 'ftor' |
                                                               'ge' | 'group' | 'gt' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'modify' | 'ne' | 'not' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'return' | 'same' | 'satisfies' |
                                                               'stable' | 'start' | 'union' | 'using' | 'weight' |
                                                               'where' | 'window' | 'with' | 'without' | '}' :)
    return
      if ($state[$p:l1] != 126                              (: 'except' :)
      and $state[$p:l1] != 238) then                        (: 'union' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-FTStopWordsInclExcl($input, $state)
        return p:parse-FTStopWordOption-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTStopWordOption (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTStopWordOption-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(194, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'except' | 'for' | 'ftand' | 'ftor' |
                                                               'ge' | 'group' | 'gt' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'modify' | 'ne' | 'not' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'return' | 'same' | 'satisfies' |
                                                               'stable' | 'start' | 'union' | 'using' | 'weight' |
                                                               'where' | 'window' | 'with' | 'without' | '}' :)
    return
      if ($state[$p:l1] != 126                              (: 'except' :)
      and $state[$p:l1] != 238) then                        (: 'union' :)
        $state
      else
        let $state := p:try-FTStopWordsInclExcl($input, $state)
        return p:try-FTStopWordOption-1($input, $state)
};

(:~
 : Parse the 2nd loop of production FTStopWordOption (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTStopWordOption-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(194, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'except' | 'for' | 'ftand' | 'ftor' |
                                                               'ge' | 'group' | 'gt' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'modify' | 'ne' | 'not' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'return' | 'same' | 'satisfies' |
                                                               'stable' | 'start' | 'union' | 'using' | 'weight' |
                                                               'where' | 'window' | 'with' | 'without' | '}' :)
    return
      if ($state[$p:l1] != 126                              (: 'except' :)
      and $state[$p:l1] != 238) then                        (: 'union' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-FTStopWordsInclExcl($input, $state)
        return p:parse-FTStopWordOption-2($input, $state)
};

(:~
 : Try parsing the 2nd loop of production FTStopWordOption (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTStopWordOption-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(194, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'except' | 'for' | 'ftand' | 'ftor' |
                                                               'ge' | 'group' | 'gt' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'modify' | 'ne' | 'not' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'return' | 'same' | 'satisfies' |
                                                               'stable' | 'start' | 'union' | 'using' | 'weight' |
                                                               'where' | 'window' | 'with' | 'without' | '}' :)
    return
      if ($state[$p:l1] != 126                              (: 'except' :)
      and $state[$p:l1] != 238) then                        (: 'union' :)
        $state
      else
        let $state := p:try-FTStopWordsInclExcl($input, $state)
        return p:try-FTStopWordOption-2($input, $state)
};

(:~
 : Parse FTStopWordOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTStopWordOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 223) then                           (: 'stop' :)
      let $state := p:lookahead2W(80, $input, $state)       (: S^WS | ('(' ':') | 'words' :)
      let $state :=
        if ($state[$p:lk] = 130271) then                    (: 'stop' 'words' :)
          let $state := p:lookahead3W(136, $input, $state)  (: S^WS | '(' | ('(' ':') | 'at' | 'default' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 27393247) then                      (: 'stop' 'words' 'default' :)
      let $state := p:shift(223, $input, $state)            (: 'stop' :)
      let $state := p:lookahead1W(80, $input, $state)       (: S^WS | ('(' ':') | 'words' :)
      let $state := p:shift(254, $input, $state)            (: 'words' :)
      let $state := p:lookahead1W(45, $input, $state)       (: S^WS | ('(' ':') | 'default' :)
      let $state := p:shift(104, $input, $state)            (: 'default' :)
      let $state := p:parse-FTStopWordOption-2($input, $state)
      return $state
    else if ($state[$p:lk] = 175) then                      (: 'no' :)
      let $state := p:shift(175, $input, $state)            (: 'no' :)
      let $state := p:lookahead1W(70, $input, $state)       (: S^WS | ('(' ':') | 'stop' :)
      let $state := p:shift(223, $input, $state)            (: 'stop' :)
      let $state := p:lookahead1W(80, $input, $state)       (: S^WS | ('(' ':') | 'words' :)
      let $state := p:shift(254, $input, $state)            (: 'words' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(223, $input, $state)            (: 'stop' :)
      let $state := p:lookahead1W(80, $input, $state)       (: S^WS | ('(' ':') | 'words' :)
      let $state := p:shift(254, $input, $state)            (: 'words' :)
      let $state := p:lookahead1W(90, $input, $state)       (: S^WS | '(' | ('(' ':') | 'at' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FTStopWords($input, $state)
      let $state := p:parse-FTStopWordOption-1($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTStopWordOption", $count, $begin, $end)
};

(:~
 : Try parsing FTStopWordOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTStopWordOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 223) then                           (: 'stop' :)
      let $state := p:lookahead2W(80, $input, $state)       (: S^WS | ('(' ':') | 'words' :)
      let $state :=
        if ($state[$p:lk] = 130271) then                    (: 'stop' 'words' :)
          let $state := p:lookahead3W(136, $input, $state)  (: S^WS | '(' | ('(' ':') | 'at' | 'default' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 27393247) then                      (: 'stop' 'words' 'default' :)
      let $state := p:shiftT(223, $input, $state)           (: 'stop' :)
      let $state := p:lookahead1W(80, $input, $state)       (: S^WS | ('(' ':') | 'words' :)
      let $state := p:shiftT(254, $input, $state)           (: 'words' :)
      let $state := p:lookahead1W(45, $input, $state)       (: S^WS | ('(' ':') | 'default' :)
      let $state := p:shiftT(104, $input, $state)           (: 'default' :)
      let $state := p:try-FTStopWordOption-2($input, $state)
      return $state
    else if ($state[$p:lk] = 175) then                      (: 'no' :)
      let $state := p:shiftT(175, $input, $state)           (: 'no' :)
      let $state := p:lookahead1W(70, $input, $state)       (: S^WS | ('(' ':') | 'stop' :)
      let $state := p:shiftT(223, $input, $state)           (: 'stop' :)
      let $state := p:lookahead1W(80, $input, $state)       (: S^WS | ('(' ':') | 'words' :)
      let $state := p:shiftT(254, $input, $state)           (: 'words' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(223, $input, $state)           (: 'stop' :)
      let $state := p:lookahead1W(80, $input, $state)       (: S^WS | ('(' ':') | 'words' :)
      let $state := p:shiftT(254, $input, $state)           (: 'words' :)
      let $state := p:lookahead1W(90, $input, $state)       (: S^WS | '(' | ('(' ':') | 'at' :)
      let $state := p:try-FTStopWords($input, $state)
      let $state := p:try-FTStopWordOption-1($input, $state)
      return $state
  return $state
};

(:~
 : Parse FTDiacriticsOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTDiacriticsOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 109) then                           (: 'diacritics' :)
      let $state := p:lookahead2W(115, $input, $state)      (: S^WS | ('(' ':') | 'insensitive' | 'sensitive' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 76909) then                         (: 'diacritics' 'insensitive' :)
      let $state := p:shift(109, $input, $state)            (: 'diacritics' :)
      let $state := p:lookahead1W(51, $input, $state)       (: S^WS | ('(' ':') | 'insensitive' :)
      let $state := p:shift(150, $input, $state)            (: 'insensitive' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(109, $input, $state)            (: 'diacritics' :)
      let $state := p:lookahead1W(67, $input, $state)       (: S^WS | ('(' ':') | 'sensitive' :)
      let $state := p:shift(214, $input, $state)            (: 'sensitive' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTDiacriticsOption", $count, $begin, $end)
};

(:~
 : Try parsing FTDiacriticsOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTDiacriticsOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 109) then                           (: 'diacritics' :)
      let $state := p:lookahead2W(115, $input, $state)      (: S^WS | ('(' ':') | 'insensitive' | 'sensitive' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 76909) then                         (: 'diacritics' 'insensitive' :)
      let $state := p:shiftT(109, $input, $state)           (: 'diacritics' :)
      let $state := p:lookahead1W(51, $input, $state)       (: S^WS | ('(' ':') | 'insensitive' :)
      let $state := p:shiftT(150, $input, $state)           (: 'insensitive' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(109, $input, $state)           (: 'diacritics' :)
      let $state := p:lookahead1W(67, $input, $state)       (: S^WS | ('(' ':') | 'sensitive' :)
      let $state := p:shiftT(214, $input, $state)           (: 'sensitive' :)
      return $state
  return $state
};

(:~
 : Parse FTCaseOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTCaseOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 87) then                            (: 'case' :)
      let $state := p:lookahead2W(115, $input, $state)      (: S^WS | ('(' ':') | 'insensitive' | 'sensitive' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 76887) then                         (: 'case' 'insensitive' :)
      let $state := p:shift(87, $input, $state)             (: 'case' :)
      let $state := p:lookahead1W(51, $input, $state)       (: S^WS | ('(' ':') | 'insensitive' :)
      let $state := p:shift(150, $input, $state)            (: 'insensitive' :)
      return $state
    else if ($state[$p:lk] = 109655) then                   (: 'case' 'sensitive' :)
      let $state := p:shift(87, $input, $state)             (: 'case' :)
      let $state := p:lookahead1W(67, $input, $state)       (: S^WS | ('(' ':') | 'sensitive' :)
      let $state := p:shift(214, $input, $state)            (: 'sensitive' :)
      return $state
    else if ($state[$p:lk] = 164) then                      (: 'lowercase' :)
      let $state := p:shift(164, $input, $state)            (: 'lowercase' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(240, $input, $state)            (: 'uppercase' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTCaseOption", $count, $begin, $end)
};

(:~
 : Try parsing FTCaseOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTCaseOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 87) then                            (: 'case' :)
      let $state := p:lookahead2W(115, $input, $state)      (: S^WS | ('(' ':') | 'insensitive' | 'sensitive' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 76887) then                         (: 'case' 'insensitive' :)
      let $state := p:shiftT(87, $input, $state)            (: 'case' :)
      let $state := p:lookahead1W(51, $input, $state)       (: S^WS | ('(' ':') | 'insensitive' :)
      let $state := p:shiftT(150, $input, $state)           (: 'insensitive' :)
      return $state
    else if ($state[$p:lk] = 109655) then                   (: 'case' 'sensitive' :)
      let $state := p:shiftT(87, $input, $state)            (: 'case' :)
      let $state := p:lookahead1W(67, $input, $state)       (: S^WS | ('(' ':') | 'sensitive' :)
      let $state := p:shiftT(214, $input, $state)           (: 'sensitive' :)
      return $state
    else if ($state[$p:lk] = 164) then                      (: 'lowercase' :)
      let $state := p:shiftT(164, $input, $state)           (: 'lowercase' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(240, $input, $state)           (: 'uppercase' :)
      return $state
  return $state
};

(:~
 : Parse FTStemOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTStemOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 222) then                           (: 'stemming' :)
      let $state := p:shift(222, $input, $state)            (: 'stemming' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(175, $input, $state)            (: 'no' :)
      let $state := p:lookahead1W(69, $input, $state)       (: S^WS | ('(' ':') | 'stemming' :)
      let $state := p:shift(222, $input, $state)            (: 'stemming' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTStemOption", $count, $begin, $end)
};

(:~
 : Try parsing FTStemOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTStemOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 222) then                           (: 'stemming' :)
      let $state := p:shiftT(222, $input, $state)           (: 'stemming' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(175, $input, $state)           (: 'no' :)
      let $state := p:lookahead1W(69, $input, $state)       (: S^WS | ('(' ':') | 'stemming' :)
      let $state := p:shiftT(222, $input, $state)           (: 'stemming' :)
      return $state
  return $state
};

(:~
 : Parse FTLiteralRange.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTLiteralRange($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 80) then                            (: 'at' :)
      let $state := p:lookahead2W(116, $input, $state)      (: S^WS | ('(' ':') | 'least' | 'most' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 125) then                           (: 'exactly' :)
      let $state := p:shift(125, $input, $state)            (: 'exactly' :)
      let $state := p:lookahead1W(18, $input, $state)       (: IntegerLiteral | S^WS | ('(' ':') :)
      let $state := p:shift(9, $input, $state)              (: IntegerLiteral :)
      return $state
    else if ($state[$p:lk] = 82512) then                    (: 'at' 'least' :)
      let $state := p:shift(80, $input, $state)             (: 'at' :)
      let $state := p:lookahead1W(54, $input, $state)       (: S^WS | ('(' ':') | 'least' :)
      let $state := p:shift(161, $input, $state)            (: 'least' :)
      let $state := p:lookahead1W(18, $input, $state)       (: IntegerLiteral | S^WS | ('(' ':') :)
      let $state := p:shift(9, $input, $state)              (: IntegerLiteral :)
      return $state
    else if ($state[$p:lk] = 87120) then                    (: 'at' 'most' :)
      let $state := p:shift(80, $input, $state)             (: 'at' :)
      let $state := p:lookahead1W(57, $input, $state)       (: S^WS | ('(' ':') | 'most' :)
      let $state := p:shift(170, $input, $state)            (: 'most' :)
      let $state := p:lookahead1W(18, $input, $state)       (: IntegerLiteral | S^WS | ('(' ':') :)
      let $state := p:shift(9, $input, $state)              (: IntegerLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(132, $input, $state)            (: 'from' :)
      let $state := p:lookahead1W(18, $input, $state)       (: IntegerLiteral | S^WS | ('(' ':') :)
      let $state := p:shift(9, $input, $state)              (: IntegerLiteral :)
      let $state := p:lookahead1W(75, $input, $state)       (: S^WS | ('(' ':') | 'to' :)
      let $state := p:shift(232, $input, $state)            (: 'to' :)
      let $state := p:lookahead1W(18, $input, $state)       (: IntegerLiteral | S^WS | ('(' ':') :)
      let $state := p:shift(9, $input, $state)              (: IntegerLiteral :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTLiteralRange", $count, $begin, $end)
};

(:~
 : Try parsing FTLiteralRange.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTLiteralRange($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 80) then                            (: 'at' :)
      let $state := p:lookahead2W(116, $input, $state)      (: S^WS | ('(' ':') | 'least' | 'most' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 125) then                           (: 'exactly' :)
      let $state := p:shiftT(125, $input, $state)           (: 'exactly' :)
      let $state := p:lookahead1W(18, $input, $state)       (: IntegerLiteral | S^WS | ('(' ':') :)
      let $state := p:shiftT(9, $input, $state)             (: IntegerLiteral :)
      return $state
    else if ($state[$p:lk] = 82512) then                    (: 'at' 'least' :)
      let $state := p:shiftT(80, $input, $state)            (: 'at' :)
      let $state := p:lookahead1W(54, $input, $state)       (: S^WS | ('(' ':') | 'least' :)
      let $state := p:shiftT(161, $input, $state)           (: 'least' :)
      let $state := p:lookahead1W(18, $input, $state)       (: IntegerLiteral | S^WS | ('(' ':') :)
      let $state := p:shiftT(9, $input, $state)             (: IntegerLiteral :)
      return $state
    else if ($state[$p:lk] = 87120) then                    (: 'at' 'most' :)
      let $state := p:shiftT(80, $input, $state)            (: 'at' :)
      let $state := p:lookahead1W(57, $input, $state)       (: S^WS | ('(' ':') | 'most' :)
      let $state := p:shiftT(170, $input, $state)           (: 'most' :)
      let $state := p:lookahead1W(18, $input, $state)       (: IntegerLiteral | S^WS | ('(' ':') :)
      let $state := p:shiftT(9, $input, $state)             (: IntegerLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(132, $input, $state)           (: 'from' :)
      let $state := p:lookahead1W(18, $input, $state)       (: IntegerLiteral | S^WS | ('(' ':') :)
      let $state := p:shiftT(9, $input, $state)             (: IntegerLiteral :)
      let $state := p:lookahead1W(75, $input, $state)       (: S^WS | ('(' ':') | 'to' :)
      let $state := p:shiftT(232, $input, $state)           (: 'to' :)
      let $state := p:lookahead1W(18, $input, $state)       (: IntegerLiteral | S^WS | ('(' ':') :)
      let $state := p:shiftT(9, $input, $state)             (: IntegerLiteral :)
      return $state
  return $state
};

(:~
 : Parse FTThesaurusID.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTThesaurusID($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(80, $input, $state)                 (: 'at' :)
  let $state := p:lookahead1W(17, $input, $state)           (: URILiteral | S^WS | ('(' ':') :)
  let $state := p:shift(8, $input, $state)                  (: URILiteral :)
  let $state := p:lookahead1W(197, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'exactly' | 'for' | 'from' | 'ftand' |
                                                               'ftor' | 'ge' | 'group' | 'gt' | 'into' | 'is' | 'le' |
                                                               'let' | 'lt' | 'modify' | 'ne' | 'not' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'relationship' | 'return' |
                                                               'same' | 'satisfies' | 'stable' | 'start' | 'using' |
                                                               'weight' | 'where' | 'window' | 'with' | 'without' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 203) then                      (: 'relationship' :)
      let $state := p:shift(203, $input, $state)            (: 'relationship' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:shift(12, $input, $state)             (: StringLiteral :)
      return $state
    else
      $state
  let $state := p:lookahead1W(193, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'exactly' | 'for' | 'from' | 'ftand' |
                                                               'ftor' | 'ge' | 'group' | 'gt' | 'into' | 'is' | 'le' |
                                                               'let' | 'lt' | 'modify' | 'ne' | 'not' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'return' | 'same' | 'satisfies' |
                                                               'stable' | 'start' | 'using' | 'weight' | 'where' |
                                                               'window' | 'with' | 'without' | '}' :)
  let $state :=
    if ($state[$p:l1] = 80) then                            (: 'at' :)
      let $state := p:lookahead2W(154, $input, $state)      (: S^WS | ('(' ':') | 'end' | 'least' | 'most' | 'start' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 125                            (: 'exactly' :)
          or $state[$p:lk] = 132                            (: 'from' :)
          or $state[$p:lk] = 82512                          (: 'at' 'least' :)
          or $state[$p:lk] = 87120) then                    (: 'at' 'most' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FTLiteralRange($input, $state)
      let $state := p:lookahead1W(55, $input, $state)       (: S^WS | ('(' ':') | 'levels' :)
      let $state := p:shift(163, $input, $state)            (: 'levels' :)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTThesaurusID", $count, $begin, $end)
};

(:~
 : Try parsing FTThesaurusID.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTThesaurusID($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(80, $input, $state)                (: 'at' :)
  let $state := p:lookahead1W(17, $input, $state)           (: URILiteral | S^WS | ('(' ':') :)
  let $state := p:shiftT(8, $input, $state)                 (: URILiteral :)
  let $state := p:lookahead1W(197, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'exactly' | 'for' | 'from' | 'ftand' |
                                                               'ftor' | 'ge' | 'group' | 'gt' | 'into' | 'is' | 'le' |
                                                               'let' | 'lt' | 'modify' | 'ne' | 'not' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'relationship' | 'return' |
                                                               'same' | 'satisfies' | 'stable' | 'start' | 'using' |
                                                               'weight' | 'where' | 'window' | 'with' | 'without' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 203) then                      (: 'relationship' :)
      let $state := p:shiftT(203, $input, $state)           (: 'relationship' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:shiftT(12, $input, $state)            (: StringLiteral :)
      return $state
    else
      $state
  let $state := p:lookahead1W(193, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'exactly' | 'for' | 'from' | 'ftand' |
                                                               'ftor' | 'ge' | 'group' | 'gt' | 'into' | 'is' | 'le' |
                                                               'let' | 'lt' | 'modify' | 'ne' | 'not' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'return' | 'same' | 'satisfies' |
                                                               'stable' | 'start' | 'using' | 'weight' | 'where' |
                                                               'window' | 'with' | 'without' | '}' :)
  let $state :=
    if ($state[$p:l1] = 80) then                            (: 'at' :)
      let $state := p:lookahead2W(154, $input, $state)      (: S^WS | ('(' ':') | 'end' | 'least' | 'most' | 'start' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 125                            (: 'exactly' :)
          or $state[$p:lk] = 132                            (: 'from' :)
          or $state[$p:lk] = 82512                          (: 'at' 'least' :)
          or $state[$p:lk] = 87120) then                    (: 'at' 'most' :)
      let $state := p:try-FTLiteralRange($input, $state)
      let $state := p:lookahead1W(55, $input, $state)       (: S^WS | ('(' ':') | 'levels' :)
      let $state := p:shiftT(163, $input, $state)           (: 'levels' :)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production FTThesaurusOption (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTThesaurusOption-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(92, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(33, $input, $state)     (: S^WS | ('(' ':') | 'at' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-FTThesaurusID($input, $state)
        return p:parse-FTThesaurusOption-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTThesaurusOption (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTThesaurusOption-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(92, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shiftT(41, $input, $state)          (: ',' :)
        let $state := p:lookahead1W(33, $input, $state)     (: S^WS | ('(' ':') | 'at' :)
        let $state := p:try-FTThesaurusID($input, $state)
        return p:try-FTThesaurusOption-1($input, $state)
};

(:~
 : Parse FTThesaurusOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTThesaurusOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 230) then                           (: 'thesaurus' :)
      let $state := p:lookahead2W(136, $input, $state)      (: S^WS | '(' | ('(' ':') | 'at' | 'default' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 17638) then                         (: 'thesaurus' '(' :)
      let $state := p:shift(230, $input, $state)            (: 'thesaurus' :)
      let $state := p:lookahead1W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:shift(34, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(102, $input, $state)      (: S^WS | ('(' ':') | 'at' | 'default' :)
      let $state :=
        if ($state[$p:l1] = 80) then                        (: 'at' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-FTThesaurusID($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(104, $input, $state)        (: 'default' :)
          return $state
      let $state := p:parse-FTThesaurusOption-1($input, $state)
      let $state := p:shift(37, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:lk] = 175) then                      (: 'no' :)
      let $state := p:shift(175, $input, $state)            (: 'no' :)
      let $state := p:lookahead1W(74, $input, $state)       (: S^WS | ('(' ':') | 'thesaurus' :)
      let $state := p:shift(230, $input, $state)            (: 'thesaurus' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(230, $input, $state)            (: 'thesaurus' :)
      let $state := p:lookahead1W(102, $input, $state)      (: S^WS | ('(' ':') | 'at' | 'default' :)
      let $state :=
        if ($state[$p:l1] = 80) then                        (: 'at' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-FTThesaurusID($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(104, $input, $state)        (: 'default' :)
          return $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTThesaurusOption", $count, $begin, $end)
};

(:~
 : Try parsing FTThesaurusOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTThesaurusOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 230) then                           (: 'thesaurus' :)
      let $state := p:lookahead2W(136, $input, $state)      (: S^WS | '(' | ('(' ':') | 'at' | 'default' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 17638) then                         (: 'thesaurus' '(' :)
      let $state := p:shiftT(230, $input, $state)           (: 'thesaurus' :)
      let $state := p:lookahead1W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:shiftT(34, $input, $state)            (: '(' :)
      let $state := p:lookahead1W(102, $input, $state)      (: S^WS | ('(' ':') | 'at' | 'default' :)
      let $state :=
        if ($state[$p:l1] = 80) then                        (: 'at' :)
          let $state := p:try-FTThesaurusID($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shiftT(104, $input, $state)       (: 'default' :)
          return $state
      let $state := p:try-FTThesaurusOption-1($input, $state)
      let $state := p:shiftT(37, $input, $state)            (: ')' :)
      return $state
    else if ($state[$p:lk] = 175) then                      (: 'no' :)
      let $state := p:shiftT(175, $input, $state)           (: 'no' :)
      let $state := p:lookahead1W(74, $input, $state)       (: S^WS | ('(' ':') | 'thesaurus' :)
      let $state := p:shiftT(230, $input, $state)           (: 'thesaurus' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(230, $input, $state)           (: 'thesaurus' :)
      let $state := p:lookahead1W(102, $input, $state)      (: S^WS | ('(' ':') | 'at' | 'default' :)
      let $state :=
        if ($state[$p:l1] = 80) then                        (: 'at' :)
          let $state := p:try-FTThesaurusID($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shiftT(104, $input, $state)       (: 'default' :)
          return $state
      return $state
  return $state
};

(:~
 : Parse FTWildCardOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTWildCardOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 249) then                           (: 'wildcards' :)
      let $state := p:shift(249, $input, $state)            (: 'wildcards' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(175, $input, $state)            (: 'no' :)
      let $state := p:lookahead1W(78, $input, $state)       (: S^WS | ('(' ':') | 'wildcards' :)
      let $state := p:shift(249, $input, $state)            (: 'wildcards' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTWildCardOption", $count, $begin, $end)
};

(:~
 : Try parsing FTWildCardOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTWildCardOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 249) then                           (: 'wildcards' :)
      let $state := p:shiftT(249, $input, $state)           (: 'wildcards' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(175, $input, $state)           (: 'no' :)
      let $state := p:lookahead1W(78, $input, $state)       (: S^WS | ('(' ':') | 'wildcards' :)
      let $state := p:shiftT(249, $input, $state)           (: 'wildcards' :)
      return $state
  return $state
};

(:~
 : Parse FTLanguageOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTLanguageOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(157, $input, $state)                (: 'language' :)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:shift(12, $input, $state)                 (: StringLiteral :)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTLanguageOption", $count, $begin, $end)
};

(:~
 : Try parsing FTLanguageOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTLanguageOption($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(157, $input, $state)               (: 'language' :)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:shiftT(12, $input, $state)                (: StringLiteral :)
  return $state
};

(:~
 : Parse FTMatchOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTMatchOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 175) then                           (: 'no' :)
      let $state := p:lookahead2W(155, $input, $state)      (: S^WS | ('(' ':') | 'stemming' | 'stop' | 'thesaurus' |
                                                               'wildcards' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 157) then                           (: 'language' :)
      let $state := p:parse-FTLanguageOption($input, $state)
      return $state
    else if ($state[$p:lk] = 249                            (: 'wildcards' :)
          or $state[$p:lk] = 127663) then                   (: 'no' 'wildcards' :)
      let $state := p:parse-FTWildCardOption($input, $state)
      return $state
    else if ($state[$p:lk] = 230                            (: 'thesaurus' :)
          or $state[$p:lk] = 117935) then                   (: 'no' 'thesaurus' :)
      let $state := p:parse-FTThesaurusOption($input, $state)
      return $state
    else if ($state[$p:lk] = 222                            (: 'stemming' :)
          or $state[$p:lk] = 113839) then                   (: 'no' 'stemming' :)
      let $state := p:parse-FTStemOption($input, $state)
      return $state
    else if ($state[$p:lk] = 109) then                      (: 'diacritics' :)
      let $state := p:parse-FTDiacriticsOption($input, $state)
      return $state
    else if ($state[$p:lk] = 223                            (: 'stop' :)
          or $state[$p:lk] = 114351) then                   (: 'no' 'stop' :)
      let $state := p:parse-FTStopWordOption($input, $state)
      return $state
    else if ($state[$p:lk] = 184) then                      (: 'option' :)
      let $state := p:parse-FTExtensionOption($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FTCaseOption($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTMatchOption", $count, $begin, $end)
};

(:~
 : Try parsing FTMatchOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTMatchOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 175) then                           (: 'no' :)
      let $state := p:lookahead2W(155, $input, $state)      (: S^WS | ('(' ':') | 'stemming' | 'stop' | 'thesaurus' |
                                                               'wildcards' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 157) then                           (: 'language' :)
      let $state := p:try-FTLanguageOption($input, $state)
      return $state
    else if ($state[$p:lk] = 249                            (: 'wildcards' :)
          or $state[$p:lk] = 127663) then                   (: 'no' 'wildcards' :)
      let $state := p:try-FTWildCardOption($input, $state)
      return $state
    else if ($state[$p:lk] = 230                            (: 'thesaurus' :)
          or $state[$p:lk] = 117935) then                   (: 'no' 'thesaurus' :)
      let $state := p:try-FTThesaurusOption($input, $state)
      return $state
    else if ($state[$p:lk] = 222                            (: 'stemming' :)
          or $state[$p:lk] = 113839) then                   (: 'no' 'stemming' :)
      let $state := p:try-FTStemOption($input, $state)
      return $state
    else if ($state[$p:lk] = 109) then                      (: 'diacritics' :)
      let $state := p:try-FTDiacriticsOption($input, $state)
      return $state
    else if ($state[$p:lk] = 223                            (: 'stop' :)
          or $state[$p:lk] = 114351) then                   (: 'no' 'stop' :)
      let $state := p:try-FTStopWordOption($input, $state)
      return $state
    else if ($state[$p:lk] = 184) then                      (: 'option' :)
      let $state := p:try-FTExtensionOption($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-FTCaseOption($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production FTMatchOptions (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTMatchOptions-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:shift(241, $input, $state)              (: 'using' :)
    let $state := p:lookahead1W(174, $input, $state)        (: S^WS | ('(' ':') | 'case' | 'diacritics' | 'language' |
                                                               'lowercase' | 'no' | 'option' | 'stemming' | 'stop' |
                                                               'thesaurus' | 'uppercase' | 'wildcards' :)
    let $state := p:whitespace($input, $state)
    let $state := p:parse-FTMatchOption($input, $state)
    let $state := p:lookahead1W(190, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'return' | 'same' | 'satisfies' | 'stable' |
                                                               'start' | 'using' | 'weight' | 'where' | 'window' |
                                                               'with' | 'without' | '}' :)
    return
      if ($state[$p:l1] != 241) then                        (: 'using' :)
        $state
      else
        p:parse-FTMatchOptions-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTMatchOptions (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTMatchOptions-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:shiftT(241, $input, $state)             (: 'using' :)
    let $state := p:lookahead1W(174, $input, $state)        (: S^WS | ('(' ':') | 'case' | 'diacritics' | 'language' |
                                                               'lowercase' | 'no' | 'option' | 'stemming' | 'stop' |
                                                               'thesaurus' | 'uppercase' | 'wildcards' :)
    let $state := p:try-FTMatchOption($input, $state)
    let $state := p:lookahead1W(190, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'return' | 'same' | 'satisfies' | 'stable' |
                                                               'start' | 'using' | 'weight' | 'where' | 'window' |
                                                               'with' | 'without' | '}' :)
    return
      if ($state[$p:l1] != 241) then                        (: 'using' :)
        $state
      else
        p:try-FTMatchOptions-1($input, $state)
};

(:~
 : Parse FTMatchOptions.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTMatchOptions($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FTMatchOptions-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTMatchOptions", $count, $begin, $end)
};

(:~
 : Try parsing FTMatchOptions.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTMatchOptions($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-FTMatchOptions-1($input, $state)
  return $state
};

(:~
 : Parse FTOptionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTOptionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(103, $input, $state)                (: 'declare' :)
  let $state := p:lookahead1W(49, $input, $state)           (: S^WS | ('(' ':') | 'ft-option' :)
  let $state := p:shift(133, $input, $state)                (: 'ft-option' :)
  let $state := p:lookahead1W(76, $input, $state)           (: S^WS | ('(' ':') | 'using' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-FTMatchOptions($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTOptionDecl", $count, $begin, $end)
};

(:~
 : Parse ImportStylesheetDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ImportStylesheetDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(146, $input, $state)                (: 'import' :)
  let $state := p:lookahead1W(71, $input, $state)           (: S^WS | ('(' ':') | 'stylesheet' :)
  let $state := p:shift(226, $input, $state)                (: 'stylesheet' :)
  let $state := p:lookahead1W(33, $input, $state)           (: S^WS | ('(' ':') | 'at' :)
  let $state := p:shift(80, $input, $state)                 (: 'at' :)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:shift(12, $input, $state)                 (: StringLiteral :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ImportStylesheetDecl", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production ModuleImport (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ModuleImport-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(94, $input, $state)         (: S^WS | ('(' ':') | ',' | ';' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(17, $input, $state)     (: URILiteral | S^WS | ('(' ':') :)
        let $state := p:shift(8, $input, $state)            (: URILiteral :)
        return p:parse-ModuleImport-1($input, $state)
};

(:~
 : Parse ModuleImport.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ModuleImport($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(146, $input, $state)                (: 'import' :)
  let $state := p:lookahead1W(56, $input, $state)           (: S^WS | ('(' ':') | 'module' :)
  let $state := p:shift(169, $input, $state)                (: 'module' :)
  let $state := p:lookahead1W(83, $input, $state)           (: URILiteral | S^WS | ('(' ':') | 'namespace' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 171) then                      (: 'namespace' :)
      let $state := p:shift(171, $input, $state)            (: 'namespace' :)
      let $state := p:lookahead1W(181, $input, $state)      (: NCName^Token | S^WS | ('(' ':') | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' | 'with' | 'words' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-NCName($input, $state)
      let $state := p:lookahead1W(31, $input, $state)       (: S^WS | ('(' ':') | '=' :)
      let $state := p:shift(60, $input, $state)             (: '=' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(17, $input, $state)           (: URILiteral | S^WS | ('(' ':') :)
  let $state := p:shift(8, $input, $state)                  (: URILiteral :)
  let $state := p:lookahead1W(98, $input, $state)           (: S^WS | ('(' ':') | ';' | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 80) then                       (: 'at' :)
      let $state := p:shift(80, $input, $state)             (: 'at' :)
      let $state := p:lookahead1W(17, $input, $state)       (: URILiteral | S^WS | ('(' ':') :)
      let $state := p:shift(8, $input, $state)              (: URILiteral :)
      let $state := p:parse-ModuleImport-1($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ModuleImport", $count, $begin, $end)
};

(:~
 : Parse SchemaPrefix.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaPrefix($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 171) then                           (: 'namespace' :)
      let $state := p:shift(171, $input, $state)            (: 'namespace' :)
      let $state := p:lookahead1W(181, $input, $state)      (: NCName^Token | S^WS | ('(' ':') | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' | 'with' | 'words' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-NCName($input, $state)
      let $state := p:lookahead1W(31, $input, $state)       (: S^WS | ('(' ':') | '=' :)
      let $state := p:shift(60, $input, $state)             (: '=' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(104, $input, $state)            (: 'default' :)
      let $state := p:lookahead1W(46, $input, $state)       (: S^WS | ('(' ':') | 'element' :)
      let $state := p:shift(116, $input, $state)            (: 'element' :)
      let $state := p:lookahead1W(58, $input, $state)       (: S^WS | ('(' ':') | 'namespace' :)
      let $state := p:shift(171, $input, $state)            (: 'namespace' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SchemaPrefix", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production SchemaImport (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaImport-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(94, $input, $state)         (: S^WS | ('(' ':') | ',' | ';' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(17, $input, $state)     (: URILiteral | S^WS | ('(' ':') :)
        let $state := p:shift(8, $input, $state)            (: URILiteral :)
        return p:parse-SchemaImport-1($input, $state)
};

(:~
 : Parse SchemaImport.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaImport($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(146, $input, $state)                (: 'import' :)
  let $state := p:lookahead1W(66, $input, $state)           (: S^WS | ('(' ':') | 'schema' :)
  let $state := p:shift(210, $input, $state)                (: 'schema' :)
  let $state := p:lookahead1W(131, $input, $state)          (: URILiteral | S^WS | ('(' ':') | 'default' | 'namespace' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 8) then                       (: URILiteral :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SchemaPrefix($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(17, $input, $state)           (: URILiteral | S^WS | ('(' ':') :)
  let $state := p:shift(8, $input, $state)                  (: URILiteral :)
  let $state := p:lookahead1W(98, $input, $state)           (: S^WS | ('(' ':') | ';' | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 80) then                       (: 'at' :)
      let $state := p:shift(80, $input, $state)             (: 'at' :)
      let $state := p:lookahead1W(17, $input, $state)       (: URILiteral | S^WS | ('(' ':') :)
      let $state := p:shift(8, $input, $state)              (: URILiteral :)
      let $state := p:parse-SchemaImport-1($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SchemaImport", $count, $begin, $end)
};

(:~
 : Parse Import.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Import($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 146) then                           (: 'import' :)
      let $state := p:lookahead2W(146, $input, $state)      (: S^WS | ('(' ':') | 'module' | 'schema' | 'stylesheet' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 107666) then                        (: 'import' 'schema' :)
      let $state := p:parse-SchemaImport($input, $state)
      return $state
    else if ($state[$p:lk] = 86674) then                    (: 'import' 'module' :)
      let $state := p:parse-ModuleImport($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ImportStylesheetDecl($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Import", $count, $begin, $end)
};

(:~
 : Parse NamespaceDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(103, $input, $state)                (: 'declare' :)
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:shift(171, $input, $state)                (: 'namespace' :)
  let $state := p:lookahead1W(181, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' | 'with' | 'words' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-NCName($input, $state)
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | ('(' ':') | '=' :)
  let $state := p:shift(60, $input, $state)                 (: '=' :)
  let $state := p:lookahead1W(17, $input, $state)           (: URILiteral | S^WS | ('(' ':') :)
  let $state := p:shift(8, $input, $state)                  (: URILiteral :)
  let $end := $state[$p:e0]
  return p:reduce($state, "NamespaceDecl", $count, $begin, $end)
};

(:~
 : Parse DFPropertyName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DFPropertyName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 102) then                           (: 'decimal-separator' :)
      let $state := p:shift(102, $input, $state)            (: 'decimal-separator' :)
      return $state
    else if ($state[$p:l1] = 142) then                      (: 'grouping-separator' :)
      let $state := p:shift(142, $input, $state)            (: 'grouping-separator' :)
      return $state
    else if ($state[$p:l1] = 148) then                      (: 'infinity' :)
      let $state := p:shift(148, $input, $state)            (: 'infinity' :)
      return $state
    else if ($state[$p:l1] = 166) then                      (: 'minus-sign' :)
      let $state := p:shift(166, $input, $state)            (: 'minus-sign' :)
      return $state
    else if ($state[$p:l1] = 67) then                       (: 'NaN' :)
      let $state := p:shift(67, $input, $state)             (: 'NaN' :)
      return $state
    else if ($state[$p:l1] = 194) then                      (: 'percent' :)
      let $state := p:shift(194, $input, $state)            (: 'percent' :)
      return $state
    else if ($state[$p:l1] = 193) then                      (: 'per-mille' :)
      let $state := p:shift(193, $input, $state)            (: 'per-mille' :)
      return $state
    else if ($state[$p:l1] = 256) then                      (: 'zero-digit' :)
      let $state := p:shift(256, $input, $state)            (: 'zero-digit' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'digit' :)
      let $state := p:shift(111, $input, $state)            (: 'digit' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(192, $input, $state)            (: 'pattern-separator' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "DFPropertyName", $count, $begin, $end)
};

(:~
 : Parse FunctionQName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionQName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 22) then                            (: QName^Token :)
      let $state := p:shift(22, $input, $state)             (: QName^Token :)
      return $state
    else if ($state[$p:l1] = 95) then                       (: 'contains' :)
      let $state := p:shift(95, $input, $state)             (: 'contains' :)
      return $state
    else if ($state[$p:l1] = 190) then                      (: 'paragraphs' :)
      let $state := p:shift(190, $input, $state)            (: 'paragraphs' :)
      return $state
    else if ($state[$p:l1] = 216) then                      (: 'sentences' :)
      let $state := p:shift(216, $input, $state)            (: 'sentences' :)
      return $state
    else if ($state[$p:l1] = 231) then                      (: 'times' :)
      let $state := p:shift(231, $input, $state)            (: 'times' :)
      return $state
    else if ($state[$p:l1] = 254) then                      (: 'words' :)
      let $state := p:shift(254, $input, $state)            (: 'words' :)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'after' :)
      let $state := p:shift(71, $input, $state)             (: 'after' :)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:shift(78, $input, $state)             (: 'as' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'before' :)
      let $state := p:shift(83, $input, $state)             (: 'before' :)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'copy' :)
      let $state := p:shift(98, $input, $state)             (: 'copy' :)
      return $state
    else if ($state[$p:l1] = 105) then                      (: 'delete' :)
      let $state := p:shift(105, $input, $state)            (: 'delete' :)
      return $state
    else if ($state[$p:l1] = 128) then                      (: 'first' :)
      let $state := p:shift(128, $input, $state)            (: 'first' :)
      return $state
    else if ($state[$p:l1] = 151) then                      (: 'insert' :)
      let $state := p:shift(151, $input, $state)            (: 'insert' :)
      return $state
    else if ($state[$p:l1] = 154) then                      (: 'into' :)
      let $state := p:shift(154, $input, $state)            (: 'into' :)
      return $state
    else if ($state[$p:l1] = 158) then                      (: 'last' :)
      let $state := p:shift(158, $input, $state)            (: 'last' :)
      return $state
    else if ($state[$p:l1] = 168) then                      (: 'modify' :)
      let $state := p:shift(168, $input, $state)            (: 'modify' :)
      return $state
    else if ($state[$p:l1] = 204) then                      (: 'rename' :)
      let $state := p:shift(204, $input, $state)            (: 'rename' :)
      return $state
    else if ($state[$p:l1] = 205) then                      (: 'replace' :)
      let $state := p:shift(205, $input, $state)            (: 'replace' :)
      return $state
    else if ($state[$p:l1] = 251) then                      (: 'with' :)
      let $state := p:shift(251, $input, $state)            (: 'with' :)
      return $state
    else if ($state[$p:l1] = 200) then                      (: 'private' :)
      let $state := p:shift(200, $input, $state)            (: 'private' :)
      return $state
    else if ($state[$p:l1] = 74) then                       (: 'ancestor' :)
      let $state := p:shift(74, $input, $state)             (: 'ancestor' :)
      return $state
    else if ($state[$p:l1] = 75) then                       (: 'ancestor-or-self' :)
      let $state := p:shift(75, $input, $state)             (: 'ancestor-or-self' :)
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'and' :)
      let $state := p:shift(76, $input, $state)             (: 'and' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'ascending' :)
      let $state := p:shift(79, $input, $state)             (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 87) then                       (: 'case' :)
      let $state := p:shift(87, $input, $state)             (: 'case' :)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'cast' :)
      let $state := p:shift(88, $input, $state)             (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'castable' :)
      let $state := p:shift(89, $input, $state)             (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 90) then                       (: 'catch' :)
      let $state := p:shift(90, $input, $state)             (: 'catch' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'child' :)
      let $state := p:shift(91, $input, $state)             (: 'child' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'collation' :)
      let $state := p:shift(92, $input, $state)             (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'count' :)
      let $state := p:shift(100, $input, $state)            (: 'count' :)
      return $state
    else if ($state[$p:l1] = 103) then                      (: 'declare' :)
      let $state := p:shift(103, $input, $state)            (: 'declare' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'default' :)
      let $state := p:shift(104, $input, $state)            (: 'default' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'descendant' :)
      let $state := p:shift(106, $input, $state)            (: 'descendant' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'descendant-or-self' :)
      let $state := p:shift(107, $input, $state)            (: 'descendant-or-self' :)
      return $state
    else if ($state[$p:l1] = 108) then                      (: 'descending' :)
      let $state := p:shift(108, $input, $state)            (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 113) then                      (: 'div' :)
      let $state := p:shift(113, $input, $state)            (: 'div' :)
      return $state
    else if ($state[$p:l1] = 114) then                      (: 'document' :)
      let $state := p:shift(114, $input, $state)            (: 'document' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'else' :)
      let $state := p:shift(117, $input, $state)            (: 'else' :)
      return $state
    else if ($state[$p:l1] = 118) then                      (: 'empty' :)
      let $state := p:shift(118, $input, $state)            (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 121) then                      (: 'end' :)
      let $state := p:shift(121, $input, $state)            (: 'end' :)
      return $state
    else if ($state[$p:l1] = 123) then                      (: 'eq' :)
      let $state := p:shift(123, $input, $state)            (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'every' :)
      let $state := p:shift(124, $input, $state)            (: 'every' :)
      return $state
    else if ($state[$p:l1] = 126) then                      (: 'except' :)
      let $state := p:shift(126, $input, $state)            (: 'except' :)
      return $state
    else if ($state[$p:l1] = 129) then                      (: 'following' :)
      let $state := p:shift(129, $input, $state)            (: 'following' :)
      return $state
    else if ($state[$p:l1] = 130) then                      (: 'following-sibling' :)
      let $state := p:shift(130, $input, $state)            (: 'following-sibling' :)
      return $state
    else if ($state[$p:l1] = 131) then                      (: 'for' :)
      let $state := p:shift(131, $input, $state)            (: 'for' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'ge' :)
      let $state := p:shift(139, $input, $state)            (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 141) then                      (: 'group' :)
      let $state := p:shift(141, $input, $state)            (: 'group' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'gt' :)
      let $state := p:shift(143, $input, $state)            (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 144) then                      (: 'idiv' :)
      let $state := p:shift(144, $input, $state)            (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 146) then                      (: 'import' :)
      let $state := p:shift(146, $input, $state)            (: 'import' :)
      return $state
    else if ($state[$p:l1] = 152) then                      (: 'instance' :)
      let $state := p:shift(152, $input, $state)            (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 153) then                      (: 'intersect' :)
      let $state := p:shift(153, $input, $state)            (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 155) then                      (: 'is' :)
      let $state := p:shift(155, $input, $state)            (: 'is' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'le' :)
      let $state := p:shift(160, $input, $state)            (: 'le' :)
      return $state
    else if ($state[$p:l1] = 162) then                      (: 'let' :)
      let $state := p:shift(162, $input, $state)            (: 'let' :)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'lt' :)
      let $state := p:shift(165, $input, $state)            (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'mod' :)
      let $state := p:shift(167, $input, $state)            (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 169) then                      (: 'module' :)
      let $state := p:shift(169, $input, $state)            (: 'module' :)
      return $state
    else if ($state[$p:l1] = 171) then                      (: 'namespace' :)
      let $state := p:shift(171, $input, $state)            (: 'namespace' :)
      return $state
    else if ($state[$p:l1] = 173) then                      (: 'ne' :)
      let $state := p:shift(173, $input, $state)            (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 183) then                      (: 'only' :)
      let $state := p:shift(183, $input, $state)            (: 'only' :)
      return $state
    else if ($state[$p:l1] = 185) then                      (: 'or' :)
      let $state := p:shift(185, $input, $state)            (: 'or' :)
      return $state
    else if ($state[$p:l1] = 186) then                      (: 'order' :)
      let $state := p:shift(186, $input, $state)            (: 'order' :)
      return $state
    else if ($state[$p:l1] = 187) then                      (: 'ordered' :)
      let $state := p:shift(187, $input, $state)            (: 'ordered' :)
      return $state
    else if ($state[$p:l1] = 191) then                      (: 'parent' :)
      let $state := p:shift(191, $input, $state)            (: 'parent' :)
      return $state
    else if ($state[$p:l1] = 196) then                      (: 'preceding' :)
      let $state := p:shift(196, $input, $state)            (: 'preceding' :)
      return $state
    else if ($state[$p:l1] = 197) then                      (: 'preceding-sibling' :)
      let $state := p:shift(197, $input, $state)            (: 'preceding-sibling' :)
      return $state
    else if ($state[$p:l1] = 202) then                      (: 'property' :)
      let $state := p:shift(202, $input, $state)            (: 'property' :)
      return $state
    else if ($state[$p:l1] = 206) then                      (: 'return' :)
      let $state := p:shift(206, $input, $state)            (: 'return' :)
      return $state
    else if ($state[$p:l1] = 209) then                      (: 'satisfies' :)
      let $state := p:shift(209, $input, $state)            (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 213) then                      (: 'self' :)
      let $state := p:shift(213, $input, $state)            (: 'self' :)
      return $state
    else if ($state[$p:l1] = 219) then                      (: 'some' :)
      let $state := p:shift(219, $input, $state)            (: 'some' :)
      return $state
    else if ($state[$p:l1] = 220) then                      (: 'stable' :)
      let $state := p:shift(220, $input, $state)            (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 221) then                      (: 'start' :)
      let $state := p:shift(221, $input, $state)            (: 'start' :)
      return $state
    else if ($state[$p:l1] = 232) then                      (: 'to' :)
      let $state := p:shift(232, $input, $state)            (: 'to' :)
      return $state
    else if ($state[$p:l1] = 233) then                      (: 'treat' :)
      let $state := p:shift(233, $input, $state)            (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 234) then                      (: 'try' :)
      let $state := p:shift(234, $input, $state)            (: 'try' :)
      return $state
    else if ($state[$p:l1] = 238) then                      (: 'union' :)
      let $state := p:shift(238, $input, $state)            (: 'union' :)
      return $state
    else if ($state[$p:l1] = 239) then                      (: 'unordered' :)
      let $state := p:shift(239, $input, $state)            (: 'unordered' :)
      return $state
    else if ($state[$p:l1] = 242) then                      (: 'validate' :)
      let $state := p:shift(242, $input, $state)            (: 'validate' :)
      return $state
    else if ($state[$p:l1] = 248) then                      (: 'where' :)
      let $state := p:shift(248, $input, $state)            (: 'where' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(255, $input, $state)            (: 'xquery' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionQName", $count, $begin, $end)
};

(:~
 : Try parsing FunctionQName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FunctionQName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 22) then                            (: QName^Token :)
      let $state := p:shiftT(22, $input, $state)            (: QName^Token :)
      return $state
    else if ($state[$p:l1] = 95) then                       (: 'contains' :)
      let $state := p:shiftT(95, $input, $state)            (: 'contains' :)
      return $state
    else if ($state[$p:l1] = 190) then                      (: 'paragraphs' :)
      let $state := p:shiftT(190, $input, $state)           (: 'paragraphs' :)
      return $state
    else if ($state[$p:l1] = 216) then                      (: 'sentences' :)
      let $state := p:shiftT(216, $input, $state)           (: 'sentences' :)
      return $state
    else if ($state[$p:l1] = 231) then                      (: 'times' :)
      let $state := p:shiftT(231, $input, $state)           (: 'times' :)
      return $state
    else if ($state[$p:l1] = 254) then                      (: 'words' :)
      let $state := p:shiftT(254, $input, $state)           (: 'words' :)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'after' :)
      let $state := p:shiftT(71, $input, $state)            (: 'after' :)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:shiftT(78, $input, $state)            (: 'as' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'before' :)
      let $state := p:shiftT(83, $input, $state)            (: 'before' :)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'copy' :)
      let $state := p:shiftT(98, $input, $state)            (: 'copy' :)
      return $state
    else if ($state[$p:l1] = 105) then                      (: 'delete' :)
      let $state := p:shiftT(105, $input, $state)           (: 'delete' :)
      return $state
    else if ($state[$p:l1] = 128) then                      (: 'first' :)
      let $state := p:shiftT(128, $input, $state)           (: 'first' :)
      return $state
    else if ($state[$p:l1] = 151) then                      (: 'insert' :)
      let $state := p:shiftT(151, $input, $state)           (: 'insert' :)
      return $state
    else if ($state[$p:l1] = 154) then                      (: 'into' :)
      let $state := p:shiftT(154, $input, $state)           (: 'into' :)
      return $state
    else if ($state[$p:l1] = 158) then                      (: 'last' :)
      let $state := p:shiftT(158, $input, $state)           (: 'last' :)
      return $state
    else if ($state[$p:l1] = 168) then                      (: 'modify' :)
      let $state := p:shiftT(168, $input, $state)           (: 'modify' :)
      return $state
    else if ($state[$p:l1] = 204) then                      (: 'rename' :)
      let $state := p:shiftT(204, $input, $state)           (: 'rename' :)
      return $state
    else if ($state[$p:l1] = 205) then                      (: 'replace' :)
      let $state := p:shiftT(205, $input, $state)           (: 'replace' :)
      return $state
    else if ($state[$p:l1] = 251) then                      (: 'with' :)
      let $state := p:shiftT(251, $input, $state)           (: 'with' :)
      return $state
    else if ($state[$p:l1] = 200) then                      (: 'private' :)
      let $state := p:shiftT(200, $input, $state)           (: 'private' :)
      return $state
    else if ($state[$p:l1] = 74) then                       (: 'ancestor' :)
      let $state := p:shiftT(74, $input, $state)            (: 'ancestor' :)
      return $state
    else if ($state[$p:l1] = 75) then                       (: 'ancestor-or-self' :)
      let $state := p:shiftT(75, $input, $state)            (: 'ancestor-or-self' :)
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'and' :)
      let $state := p:shiftT(76, $input, $state)            (: 'and' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'ascending' :)
      let $state := p:shiftT(79, $input, $state)            (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 87) then                       (: 'case' :)
      let $state := p:shiftT(87, $input, $state)            (: 'case' :)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'cast' :)
      let $state := p:shiftT(88, $input, $state)            (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'castable' :)
      let $state := p:shiftT(89, $input, $state)            (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 90) then                       (: 'catch' :)
      let $state := p:shiftT(90, $input, $state)            (: 'catch' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'child' :)
      let $state := p:shiftT(91, $input, $state)            (: 'child' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'collation' :)
      let $state := p:shiftT(92, $input, $state)            (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'count' :)
      let $state := p:shiftT(100, $input, $state)           (: 'count' :)
      return $state
    else if ($state[$p:l1] = 103) then                      (: 'declare' :)
      let $state := p:shiftT(103, $input, $state)           (: 'declare' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'default' :)
      let $state := p:shiftT(104, $input, $state)           (: 'default' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'descendant' :)
      let $state := p:shiftT(106, $input, $state)           (: 'descendant' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'descendant-or-self' :)
      let $state := p:shiftT(107, $input, $state)           (: 'descendant-or-self' :)
      return $state
    else if ($state[$p:l1] = 108) then                      (: 'descending' :)
      let $state := p:shiftT(108, $input, $state)           (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 113) then                      (: 'div' :)
      let $state := p:shiftT(113, $input, $state)           (: 'div' :)
      return $state
    else if ($state[$p:l1] = 114) then                      (: 'document' :)
      let $state := p:shiftT(114, $input, $state)           (: 'document' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'else' :)
      let $state := p:shiftT(117, $input, $state)           (: 'else' :)
      return $state
    else if ($state[$p:l1] = 118) then                      (: 'empty' :)
      let $state := p:shiftT(118, $input, $state)           (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 121) then                      (: 'end' :)
      let $state := p:shiftT(121, $input, $state)           (: 'end' :)
      return $state
    else if ($state[$p:l1] = 123) then                      (: 'eq' :)
      let $state := p:shiftT(123, $input, $state)           (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'every' :)
      let $state := p:shiftT(124, $input, $state)           (: 'every' :)
      return $state
    else if ($state[$p:l1] = 126) then                      (: 'except' :)
      let $state := p:shiftT(126, $input, $state)           (: 'except' :)
      return $state
    else if ($state[$p:l1] = 129) then                      (: 'following' :)
      let $state := p:shiftT(129, $input, $state)           (: 'following' :)
      return $state
    else if ($state[$p:l1] = 130) then                      (: 'following-sibling' :)
      let $state := p:shiftT(130, $input, $state)           (: 'following-sibling' :)
      return $state
    else if ($state[$p:l1] = 131) then                      (: 'for' :)
      let $state := p:shiftT(131, $input, $state)           (: 'for' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'ge' :)
      let $state := p:shiftT(139, $input, $state)           (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 141) then                      (: 'group' :)
      let $state := p:shiftT(141, $input, $state)           (: 'group' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'gt' :)
      let $state := p:shiftT(143, $input, $state)           (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 144) then                      (: 'idiv' :)
      let $state := p:shiftT(144, $input, $state)           (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 146) then                      (: 'import' :)
      let $state := p:shiftT(146, $input, $state)           (: 'import' :)
      return $state
    else if ($state[$p:l1] = 152) then                      (: 'instance' :)
      let $state := p:shiftT(152, $input, $state)           (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 153) then                      (: 'intersect' :)
      let $state := p:shiftT(153, $input, $state)           (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 155) then                      (: 'is' :)
      let $state := p:shiftT(155, $input, $state)           (: 'is' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'le' :)
      let $state := p:shiftT(160, $input, $state)           (: 'le' :)
      return $state
    else if ($state[$p:l1] = 162) then                      (: 'let' :)
      let $state := p:shiftT(162, $input, $state)           (: 'let' :)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'lt' :)
      let $state := p:shiftT(165, $input, $state)           (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'mod' :)
      let $state := p:shiftT(167, $input, $state)           (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 169) then                      (: 'module' :)
      let $state := p:shiftT(169, $input, $state)           (: 'module' :)
      return $state
    else if ($state[$p:l1] = 171) then                      (: 'namespace' :)
      let $state := p:shiftT(171, $input, $state)           (: 'namespace' :)
      return $state
    else if ($state[$p:l1] = 173) then                      (: 'ne' :)
      let $state := p:shiftT(173, $input, $state)           (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 183) then                      (: 'only' :)
      let $state := p:shiftT(183, $input, $state)           (: 'only' :)
      return $state
    else if ($state[$p:l1] = 185) then                      (: 'or' :)
      let $state := p:shiftT(185, $input, $state)           (: 'or' :)
      return $state
    else if ($state[$p:l1] = 186) then                      (: 'order' :)
      let $state := p:shiftT(186, $input, $state)           (: 'order' :)
      return $state
    else if ($state[$p:l1] = 187) then                      (: 'ordered' :)
      let $state := p:shiftT(187, $input, $state)           (: 'ordered' :)
      return $state
    else if ($state[$p:l1] = 191) then                      (: 'parent' :)
      let $state := p:shiftT(191, $input, $state)           (: 'parent' :)
      return $state
    else if ($state[$p:l1] = 196) then                      (: 'preceding' :)
      let $state := p:shiftT(196, $input, $state)           (: 'preceding' :)
      return $state
    else if ($state[$p:l1] = 197) then                      (: 'preceding-sibling' :)
      let $state := p:shiftT(197, $input, $state)           (: 'preceding-sibling' :)
      return $state
    else if ($state[$p:l1] = 202) then                      (: 'property' :)
      let $state := p:shiftT(202, $input, $state)           (: 'property' :)
      return $state
    else if ($state[$p:l1] = 206) then                      (: 'return' :)
      let $state := p:shiftT(206, $input, $state)           (: 'return' :)
      return $state
    else if ($state[$p:l1] = 209) then                      (: 'satisfies' :)
      let $state := p:shiftT(209, $input, $state)           (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 213) then                      (: 'self' :)
      let $state := p:shiftT(213, $input, $state)           (: 'self' :)
      return $state
    else if ($state[$p:l1] = 219) then                      (: 'some' :)
      let $state := p:shiftT(219, $input, $state)           (: 'some' :)
      return $state
    else if ($state[$p:l1] = 220) then                      (: 'stable' :)
      let $state := p:shiftT(220, $input, $state)           (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 221) then                      (: 'start' :)
      let $state := p:shiftT(221, $input, $state)           (: 'start' :)
      return $state
    else if ($state[$p:l1] = 232) then                      (: 'to' :)
      let $state := p:shiftT(232, $input, $state)           (: 'to' :)
      return $state
    else if ($state[$p:l1] = 233) then                      (: 'treat' :)
      let $state := p:shiftT(233, $input, $state)           (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 234) then                      (: 'try' :)
      let $state := p:shiftT(234, $input, $state)           (: 'try' :)
      return $state
    else if ($state[$p:l1] = 238) then                      (: 'union' :)
      let $state := p:shiftT(238, $input, $state)           (: 'union' :)
      return $state
    else if ($state[$p:l1] = 239) then                      (: 'unordered' :)
      let $state := p:shiftT(239, $input, $state)           (: 'unordered' :)
      return $state
    else if ($state[$p:l1] = 242) then                      (: 'validate' :)
      let $state := p:shiftT(242, $input, $state)           (: 'validate' :)
      return $state
    else if ($state[$p:l1] = 248) then                      (: 'where' :)
      let $state := p:shiftT(248, $input, $state)           (: 'where' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(255, $input, $state)           (: 'xquery' :)
      return $state
  return $state
};

(:~
 : Parse QName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1(226, $input, $state)           (: QName^Token | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 81) then                            (: 'attribute' :)
      let $state := p:shift(81, $input, $state)             (: 'attribute' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'binary' :)
      let $state := p:shift(84, $input, $state)             (: 'binary' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'comment' :)
      let $state := p:shift(93, $input, $state)             (: 'comment' :)
      return $state
    else if ($state[$p:l1] = 115) then                      (: 'document-node' :)
      let $state := p:shift(115, $input, $state)            (: 'document-node' :)
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'element' :)
      let $state := p:shift(116, $input, $state)            (: 'element' :)
      return $state
    else if ($state[$p:l1] = 119) then                      (: 'empty-sequence' :)
      let $state := p:shift(119, $input, $state)            (: 'empty-sequence' :)
      return $state
    else if ($state[$p:l1] = 138) then                      (: 'function' :)
      let $state := p:shift(138, $input, $state)            (: 'function' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'if' :)
      let $state := p:shift(145, $input, $state)            (: 'if' :)
      return $state
    else if ($state[$p:l1] = 156) then                      (: 'item' :)
      let $state := p:shift(156, $input, $state)            (: 'item' :)
      return $state
    else if ($state[$p:l1] = 172) then                      (: 'namespace-node' :)
      let $state := p:shift(172, $input, $state)            (: 'namespace-node' :)
      return $state
    else if ($state[$p:l1] = 178) then                      (: 'node' :)
      let $state := p:shift(178, $input, $state)            (: 'node' :)
      return $state
    else if ($state[$p:l1] = 201) then                      (: 'processing-instruction' :)
      let $state := p:shift(201, $input, $state)            (: 'processing-instruction' :)
      return $state
    else if ($state[$p:l1] = 211) then                      (: 'schema-attribute' :)
      let $state := p:shift(211, $input, $state)            (: 'schema-attribute' :)
      return $state
    else if ($state[$p:l1] = 212) then                      (: 'schema-element' :)
      let $state := p:shift(212, $input, $state)            (: 'schema-element' :)
      return $state
    else if ($state[$p:l1] = 227) then                      (: 'switch' :)
      let $state := p:shift(227, $input, $state)            (: 'switch' :)
      return $state
    else if ($state[$p:l1] = 228) then                      (: 'text' :)
      let $state := p:shift(228, $input, $state)            (: 'text' :)
      return $state
    else if ($state[$p:l1] = 237) then                      (: 'typeswitch' :)
      let $state := p:shift(237, $input, $state)            (: 'typeswitch' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FunctionQName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "QName", $count, $begin, $end)
};

(:~
 : Try parsing QName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-QName($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1(226, $input, $state)           (: QName^Token | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 81) then                            (: 'attribute' :)
      let $state := p:shiftT(81, $input, $state)            (: 'attribute' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'binary' :)
      let $state := p:shiftT(84, $input, $state)            (: 'binary' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'comment' :)
      let $state := p:shiftT(93, $input, $state)            (: 'comment' :)
      return $state
    else if ($state[$p:l1] = 115) then                      (: 'document-node' :)
      let $state := p:shiftT(115, $input, $state)           (: 'document-node' :)
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'element' :)
      let $state := p:shiftT(116, $input, $state)           (: 'element' :)
      return $state
    else if ($state[$p:l1] = 119) then                      (: 'empty-sequence' :)
      let $state := p:shiftT(119, $input, $state)           (: 'empty-sequence' :)
      return $state
    else if ($state[$p:l1] = 138) then                      (: 'function' :)
      let $state := p:shiftT(138, $input, $state)           (: 'function' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'if' :)
      let $state := p:shiftT(145, $input, $state)           (: 'if' :)
      return $state
    else if ($state[$p:l1] = 156) then                      (: 'item' :)
      let $state := p:shiftT(156, $input, $state)           (: 'item' :)
      return $state
    else if ($state[$p:l1] = 172) then                      (: 'namespace-node' :)
      let $state := p:shiftT(172, $input, $state)           (: 'namespace-node' :)
      return $state
    else if ($state[$p:l1] = 178) then                      (: 'node' :)
      let $state := p:shiftT(178, $input, $state)           (: 'node' :)
      return $state
    else if ($state[$p:l1] = 201) then                      (: 'processing-instruction' :)
      let $state := p:shiftT(201, $input, $state)           (: 'processing-instruction' :)
      return $state
    else if ($state[$p:l1] = 211) then                      (: 'schema-attribute' :)
      let $state := p:shiftT(211, $input, $state)           (: 'schema-attribute' :)
      return $state
    else if ($state[$p:l1] = 212) then                      (: 'schema-element' :)
      let $state := p:shiftT(212, $input, $state)           (: 'schema-element' :)
      return $state
    else if ($state[$p:l1] = 227) then                      (: 'switch' :)
      let $state := p:shiftT(227, $input, $state)           (: 'switch' :)
      return $state
    else if ($state[$p:l1] = 228) then                      (: 'text' :)
      let $state := p:shiftT(228, $input, $state)           (: 'text' :)
      return $state
    else if ($state[$p:l1] = 237) then                      (: 'typeswitch' :)
      let $state := p:shiftT(237, $input, $state)           (: 'typeswitch' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-FunctionQName($input, $state)
      return $state
  return $state
};

(:~
 : Parse EQName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EQName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1(227, $input, $state)           (: URIQualifiedName | QName^Token | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 7) then                             (: URIQualifiedName :)
      let $state := p:shift(7, $input, $state)              (: URIQualifiedName :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-QName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "EQName", $count, $begin, $end)
};

(:~
 : Try parsing EQName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-EQName($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1(227, $input, $state)           (: URIQualifiedName | QName^Token | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 7) then                             (: URIQualifiedName :)
      let $state := p:shiftT(7, $input, $state)             (: URIQualifiedName :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-QName($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production DecimalFormatDecl (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DecimalFormatDecl-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(173, $input, $state)        (: S^WS | ('(' ':') | ';' | 'NaN' | 'decimal-separator' |
                                                               'digit' | 'grouping-separator' | 'infinity' |
                                                               'minus-sign' | 'pattern-separator' | 'per-mille' |
                                                               'percent' | 'zero-digit' :)
    return
      if ($state[$p:l1] = 52) then                          (: ';' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-DFPropertyName($input, $state)
        let $state := p:lookahead1W(31, $input, $state)     (: S^WS | ('(' ':') | '=' :)
        let $state := p:shift(60, $input, $state)           (: '=' :)
        let $state := p:lookahead1W(19, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state := p:shift(12, $input, $state)           (: StringLiteral :)
        return p:parse-DecimalFormatDecl-1($input, $state)
};

(:~
 : Parse DecimalFormatDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DecimalFormatDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(103, $input, $state)                (: 'declare' :)
  let $state := p:lookahead1W(105, $input, $state)          (: S^WS | ('(' ':') | 'decimal-format' | 'default' :)
  let $state :=
    if ($state[$p:l1] = 101) then                           (: 'decimal-format' :)
      let $state := p:shift(101, $input, $state)            (: 'decimal-format' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-EQName($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(104, $input, $state)            (: 'default' :)
      let $state := p:lookahead1W(44, $input, $state)       (: S^WS | ('(' ':') | 'decimal-format' :)
      let $state := p:shift(101, $input, $state)            (: 'decimal-format' :)
      return $state
  let $state := p:parse-DecimalFormatDecl-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "DecimalFormatDecl", $count, $begin, $end)
};

(:~
 : Parse InheritMode.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InheritMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 149) then                           (: 'inherit' :)
      let $state := p:shift(149, $input, $state)            (: 'inherit' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(176, $input, $state)            (: 'no-inherit' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "InheritMode", $count, $begin, $end)
};

(:~
 : Parse PreserveMode.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PreserveMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 198) then                           (: 'preserve' :)
      let $state := p:shift(198, $input, $state)            (: 'preserve' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(177, $input, $state)            (: 'no-preserve' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PreserveMode", $count, $begin, $end)
};

(:~
 : Parse CopyNamespacesDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CopyNamespacesDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(103, $input, $state)                (: 'declare' :)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | 'copy-namespaces' :)
  let $state := p:shift(99, $input, $state)                 (: 'copy-namespaces' :)
  let $state := p:lookahead1W(118, $input, $state)          (: S^WS | ('(' ':') | 'no-preserve' | 'preserve' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-PreserveMode($input, $state)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | ('(' ':') | ',' :)
  let $state := p:shift(41, $input, $state)                 (: ',' :)
  let $state := p:lookahead1W(114, $input, $state)          (: S^WS | ('(' ':') | 'inherit' | 'no-inherit' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-InheritMode($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CopyNamespacesDecl", $count, $begin, $end)
};

(:~
 : Parse RevalidationDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RevalidationDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(103, $input, $state)                (: 'declare' :)
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | ('(' ':') | 'revalidation' :)
  let $state := p:shift(207, $input, $state)                (: 'revalidation' :)
  let $state := p:lookahead1W(145, $input, $state)          (: S^WS | ('(' ':') | 'lax' | 'skip' | 'strict' :)
  let $state :=
    if ($state[$p:l1] = 224) then                           (: 'strict' :)
      let $state := p:shift(224, $input, $state)            (: 'strict' :)
      return $state
    else if ($state[$p:l1] = 159) then                      (: 'lax' :)
      let $state := p:shift(159, $input, $state)            (: 'lax' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(217, $input, $state)            (: 'skip' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "RevalidationDecl", $count, $begin, $end)
};

(:~
 : Parse EmptyOrderDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EmptyOrderDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(103, $input, $state)                (: 'declare' :)
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:shift(104, $input, $state)                (: 'default' :)
  let $state := p:lookahead1W(62, $input, $state)           (: S^WS | ('(' ':') | 'order' :)
  let $state := p:shift(186, $input, $state)                (: 'order' :)
  let $state := p:lookahead1W(47, $input, $state)           (: S^WS | ('(' ':') | 'empty' :)
  let $state := p:shift(118, $input, $state)                (: 'empty' :)
  let $state := p:lookahead1W(113, $input, $state)          (: S^WS | ('(' ':') | 'greatest' | 'least' :)
  let $state :=
    if ($state[$p:l1] = 140) then                           (: 'greatest' :)
      let $state := p:shift(140, $input, $state)            (: 'greatest' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(161, $input, $state)            (: 'least' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "EmptyOrderDecl", $count, $begin, $end)
};

(:~
 : Parse OrderingModeDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderingModeDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(103, $input, $state)                (: 'declare' :)
  let $state := p:lookahead1W(63, $input, $state)           (: S^WS | ('(' ':') | 'ordering' :)
  let $state := p:shift(188, $input, $state)                (: 'ordering' :)
  let $state := p:lookahead1W(123, $input, $state)          (: S^WS | ('(' ':') | 'ordered' | 'unordered' :)
  let $state :=
    if ($state[$p:l1] = 187) then                           (: 'ordered' :)
      let $state := p:shift(187, $input, $state)            (: 'ordered' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(239, $input, $state)            (: 'unordered' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderingModeDecl", $count, $begin, $end)
};

(:~
 : Parse ConstructionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ConstructionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(103, $input, $state)                (: 'declare' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | ('(' ':') | 'construction' :)
  let $state := p:shift(94, $input, $state)                 (: 'construction' :)
  let $state := p:lookahead1W(125, $input, $state)          (: S^WS | ('(' ':') | 'preserve' | 'strip' :)
  let $state :=
    if ($state[$p:l1] = 225) then                           (: 'strip' :)
      let $state := p:shift(225, $input, $state)            (: 'strip' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(198, $input, $state)            (: 'preserve' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ConstructionDecl", $count, $begin, $end)
};

(:~
 : Parse BaseURIDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BaseURIDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(103, $input, $state)                (: 'declare' :)
  let $state := p:lookahead1W(34, $input, $state)           (: S^WS | ('(' ':') | 'base-uri' :)
  let $state := p:shift(82, $input, $state)                 (: 'base-uri' :)
  let $state := p:lookahead1W(17, $input, $state)           (: URILiteral | S^WS | ('(' ':') :)
  let $state := p:shift(8, $input, $state)                  (: URILiteral :)
  let $end := $state[$p:e0]
  return p:reduce($state, "BaseURIDecl", $count, $begin, $end)
};

(:~
 : Parse DefaultCollationDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DefaultCollationDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(103, $input, $state)                (: 'declare' :)
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:shift(104, $input, $state)                (: 'default' :)
  let $state := p:lookahead1W(39, $input, $state)           (: S^WS | ('(' ':') | 'collation' :)
  let $state := p:shift(92, $input, $state)                 (: 'collation' :)
  let $state := p:lookahead1W(17, $input, $state)           (: URILiteral | S^WS | ('(' ':') :)
  let $state := p:shift(8, $input, $state)                  (: URILiteral :)
  let $end := $state[$p:e0]
  return p:reduce($state, "DefaultCollationDecl", $count, $begin, $end)
};

(:~
 : Parse BoundarySpaceDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BoundarySpaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(103, $input, $state)                (: 'declare' :)
  let $state := p:lookahead1W(35, $input, $state)           (: S^WS | ('(' ':') | 'boundary-space' :)
  let $state := p:shift(85, $input, $state)                 (: 'boundary-space' :)
  let $state := p:lookahead1W(125, $input, $state)          (: S^WS | ('(' ':') | 'preserve' | 'strip' :)
  let $state :=
    if ($state[$p:l1] = 198) then                           (: 'preserve' :)
      let $state := p:shift(198, $input, $state)            (: 'preserve' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(225, $input, $state)            (: 'strip' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "BoundarySpaceDecl", $count, $begin, $end)
};

(:~
 : Parse Setter.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Setter($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 103) then                           (: 'declare' :)
      let $state := p:lookahead2W(166, $input, $state)      (: S^WS | ('(' ':') | 'base-uri' | 'boundary-space' |
                                                               'construction' | 'copy-namespaces' | 'decimal-format' |
                                                               'default' | 'ordering' | 'revalidation' :)
      let $state :=
        if ($state[$p:lk] = 53351) then                     (: 'declare' 'default' :)
          let $state := p:lookahead3W(143, $input, $state)  (: S^WS | ('(' ':') | 'collation' | 'decimal-format' |
                                                               'order' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 43623) then                         (: 'declare' 'boundary-space' :)
      let $state := p:parse-BoundarySpaceDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 24170599) then                 (: 'declare' 'default' 'collation' :)
      let $state := p:parse-DefaultCollationDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 42087) then                    (: 'declare' 'base-uri' :)
      let $state := p:parse-BaseURIDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 48231) then                    (: 'declare' 'construction' :)
      let $state := p:parse-ConstructionDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 96359) then                    (: 'declare' 'ordering' :)
      let $state := p:parse-OrderingModeDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 48812135) then                 (: 'declare' 'default' 'order' :)
      let $state := p:parse-EmptyOrderDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 106087) then                   (: 'declare' 'revalidation' :)
      let $state := p:parse-RevalidationDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 50791) then                    (: 'declare' 'copy-namespaces' :)
      let $state := p:parse-CopyNamespacesDecl($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-DecimalFormatDecl($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Setter", $count, $begin, $end)
};

(:~
 : Parse DefaultNamespaceDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DefaultNamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(103, $input, $state)                (: 'declare' :)
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:shift(104, $input, $state)                (: 'default' :)
  let $state := p:lookahead1W(106, $input, $state)          (: S^WS | ('(' ':') | 'element' | 'function' :)
  let $state :=
    if ($state[$p:l1] = 116) then                           (: 'element' :)
      let $state := p:shift(116, $input, $state)            (: 'element' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(138, $input, $state)            (: 'function' :)
      return $state
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:shift(171, $input, $state)                (: 'namespace' :)
  let $state := p:lookahead1W(17, $input, $state)           (: URILiteral | S^WS | ('(' ':') :)
  let $state := p:shift(8, $input, $state)                  (: URILiteral :)
  let $end := $state[$p:e0]
  return p:reduce($state, "DefaultNamespaceDecl", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production Prolog (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Prolog-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(242, $input, $state)        (: EOF | Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
    let $state :=
      if ($state[$p:l1] = 103) then                         (: 'declare' :)
        let $state := p:lookahead2W(188, $input, $state)    (: EOF | S^WS | '!' | '!=' | '#' | '%' | '(' | ('(' ':') |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | 'and' |
                                                               'base-uri' | 'boundary-space' | 'cast' | 'castable' |
                                                               'construction' | 'contains' | 'context' |
                                                               'copy-namespaces' | 'decimal-format' | 'default' |
                                                               'div' | 'eq' | 'except' | 'ft-option' | 'function' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'lt' | 'mod' | 'namespace' | 'ne' | 'option' |
                                                               'or' | 'ordering' | 'private' | 'revalidation' | 'to' |
                                                               'treat' | 'union' | 'variable' | '|' | '||' :)
        return $state
      else if ($state[$p:l1] = 146) then                    (: 'import' :)
        let $state := p:lookahead2W(179, $input, $state)    (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                               'castable' | 'contains' | 'div' | 'eq' | 'except' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'lt' | 'mod' | 'module' | 'ne' | 'or' | 'schema' |
                                                               'stylesheet' | 'to' | 'treat' | 'union' | '|' | '||' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 42087                            (: 'declare' 'base-uri' :)
      and $state[$p:lk] != 43623                            (: 'declare' 'boundary-space' :)
      and $state[$p:lk] != 48231                            (: 'declare' 'construction' :)
      and $state[$p:lk] != 50791                            (: 'declare' 'copy-namespaces' :)
      and $state[$p:lk] != 51815                            (: 'declare' 'decimal-format' :)
      and $state[$p:lk] != 53351                            (: 'declare' 'default' :)
      and $state[$p:lk] != 68199                            (: 'declare' 'ft-option' :)
      and $state[$p:lk] != 86674                            (: 'import' 'module' :)
      and $state[$p:lk] != 87655                            (: 'declare' 'namespace' :)
      and $state[$p:lk] != 96359                            (: 'declare' 'ordering' :)
      and $state[$p:lk] != 106087                           (: 'declare' 'revalidation' :)
      and $state[$p:lk] != 107666                           (: 'import' 'schema' :)
      and $state[$p:lk] != 115858) then                     (: 'import' 'stylesheet' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 103) then                     (: 'declare' :)
            let $state := p:lookahead2W(171, $input, $state) (: S^WS | ('(' ':') | 'base-uri' | 'boundary-space' |
                                                                'construction' | 'copy-namespaces' | 'decimal-format' |
                                                                'default' | 'ft-option' | 'namespace' | 'ordering' |
                                                                'revalidation' :)
            let $state :=
              if ($state[$p:lk] = 53351) then               (: 'declare' 'default' :)
                let $state := p:lookahead3W(159, $input, $state) (: S^WS | ('(' ':') | 'collation' | 'decimal-format' |
                                                                    'element' | 'function' | 'order' :)
                return $state
              else
                $state
            return $state
          else
            ($state[$p:l1], subsequence($state, $p:lk + 1))
        let $state :=
          if ($state[$p:lk] = 30462055                      (: 'declare' 'default' 'element' :)
           or $state[$p:lk] = 36229223) then                (: 'declare' 'default' 'function' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-DefaultNamespaceDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 87655) then              (: 'declare' 'namespace' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-NamespaceDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 146) then                (: 'import' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-Import($input, $state)
            return $state
          else if ($state[$p:lk] = 68199) then              (: 'declare' 'ft-option' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-FTOptionDecl($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:whitespace($input, $state)
            let $state := p:parse-Setter($input, $state)
            return $state
        let $state := p:lookahead1W(30, $input, $state)     (: S^WS | ('(' ':') | ';' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Separator($input, $state)
        return p:parse-Prolog-1($input, $state)
};

(:~
 : Parse the 2nd loop of production Prolog (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Prolog-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(242, $input, $state)        (: EOF | Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
    let $state :=
      if ($state[$p:l1] = 103) then                         (: 'declare' :)
        let $state := p:lookahead2W(180, $input, $state)    (: EOF | S^WS | '!' | '!=' | '#' | '%' | '(' | ('(' ':') |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                               'castable' | 'contains' | 'context' | 'div' | 'eq' |
                                                               'except' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' |
                                                               'ne' | 'option' | 'or' | 'private' | 'to' | 'treat' |
                                                               'union' | 'variable' | '|' | '||' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 16487                            (: 'declare' '%' :)
      and $state[$p:lk] != 49767                            (: 'declare' 'context' :)
      and $state[$p:lk] != 70759                            (: 'declare' 'function' :)
      and $state[$p:lk] != 94311                            (: 'declare' 'option' :)
      and $state[$p:lk] != 102503                           (: 'declare' 'private' :)
      and $state[$p:lk] != 125031) then                     (: 'declare' 'variable' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 103) then                     (: 'declare' :)
            let $state := p:lookahead2W(164, $input, $state) (: S^WS | '%' | ('(' ':') | 'context' | 'function' |
                                                                'option' | 'private' | 'variable' :)
            return $state
          else
            ($state[$p:l1], subsequence($state, $p:lk + 1))
        let $state :=
          if ($state[$p:lk] = 49767) then                   (: 'declare' 'context' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-ContextItemDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 94311) then              (: 'declare' 'option' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-OptionDecl($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:whitespace($input, $state)
            let $state := p:parse-AnnotatedDecl($input, $state)
            return $state
        let $state := p:lookahead1W(30, $input, $state)     (: S^WS | ('(' ':') | ';' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Separator($input, $state)
        return p:parse-Prolog-2($input, $state)
};

(:~
 : Parse Prolog.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Prolog($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Prolog-1($input, $state)
  let $state := p:parse-Prolog-2($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "Prolog", $count, $begin, $end)
};

(:~
 : Parse NCName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NCName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 21) then                            (: NCName^Token :)
      let $state := p:shift(21, $input, $state)             (: NCName^Token :)
      return $state
    else if ($state[$p:l1] = 95) then                       (: 'contains' :)
      let $state := p:shift(95, $input, $state)             (: 'contains' :)
      return $state
    else if ($state[$p:l1] = 190) then                      (: 'paragraphs' :)
      let $state := p:shift(190, $input, $state)            (: 'paragraphs' :)
      return $state
    else if ($state[$p:l1] = 216) then                      (: 'sentences' :)
      let $state := p:shift(216, $input, $state)            (: 'sentences' :)
      return $state
    else if ($state[$p:l1] = 231) then                      (: 'times' :)
      let $state := p:shift(231, $input, $state)            (: 'times' :)
      return $state
    else if ($state[$p:l1] = 254) then                      (: 'words' :)
      let $state := p:shift(254, $input, $state)            (: 'words' :)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'after' :)
      let $state := p:shift(71, $input, $state)             (: 'after' :)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:shift(78, $input, $state)             (: 'as' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'before' :)
      let $state := p:shift(83, $input, $state)             (: 'before' :)
      return $state
    else if ($state[$p:l1] = 154) then                      (: 'into' :)
      let $state := p:shift(154, $input, $state)            (: 'into' :)
      return $state
    else if ($state[$p:l1] = 168) then                      (: 'modify' :)
      let $state := p:shift(168, $input, $state)            (: 'modify' :)
      return $state
    else if ($state[$p:l1] = 251) then                      (: 'with' :)
      let $state := p:shift(251, $input, $state)            (: 'with' :)
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'and' :)
      let $state := p:shift(76, $input, $state)             (: 'and' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'ascending' :)
      let $state := p:shift(79, $input, $state)             (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 87) then                       (: 'case' :)
      let $state := p:shift(87, $input, $state)             (: 'case' :)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'cast' :)
      let $state := p:shift(88, $input, $state)             (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'castable' :)
      let $state := p:shift(89, $input, $state)             (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'collation' :)
      let $state := p:shift(92, $input, $state)             (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'count' :)
      let $state := p:shift(100, $input, $state)            (: 'count' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'default' :)
      let $state := p:shift(104, $input, $state)            (: 'default' :)
      return $state
    else if ($state[$p:l1] = 108) then                      (: 'descending' :)
      let $state := p:shift(108, $input, $state)            (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 113) then                      (: 'div' :)
      let $state := p:shift(113, $input, $state)            (: 'div' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'else' :)
      let $state := p:shift(117, $input, $state)            (: 'else' :)
      return $state
    else if ($state[$p:l1] = 118) then                      (: 'empty' :)
      let $state := p:shift(118, $input, $state)            (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 121) then                      (: 'end' :)
      let $state := p:shift(121, $input, $state)            (: 'end' :)
      return $state
    else if ($state[$p:l1] = 123) then                      (: 'eq' :)
      let $state := p:shift(123, $input, $state)            (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 126) then                      (: 'except' :)
      let $state := p:shift(126, $input, $state)            (: 'except' :)
      return $state
    else if ($state[$p:l1] = 131) then                      (: 'for' :)
      let $state := p:shift(131, $input, $state)            (: 'for' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'ge' :)
      let $state := p:shift(139, $input, $state)            (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 141) then                      (: 'group' :)
      let $state := p:shift(141, $input, $state)            (: 'group' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'gt' :)
      let $state := p:shift(143, $input, $state)            (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 144) then                      (: 'idiv' :)
      let $state := p:shift(144, $input, $state)            (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 152) then                      (: 'instance' :)
      let $state := p:shift(152, $input, $state)            (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 153) then                      (: 'intersect' :)
      let $state := p:shift(153, $input, $state)            (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 155) then                      (: 'is' :)
      let $state := p:shift(155, $input, $state)            (: 'is' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'le' :)
      let $state := p:shift(160, $input, $state)            (: 'le' :)
      return $state
    else if ($state[$p:l1] = 162) then                      (: 'let' :)
      let $state := p:shift(162, $input, $state)            (: 'let' :)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'lt' :)
      let $state := p:shift(165, $input, $state)            (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'mod' :)
      let $state := p:shift(167, $input, $state)            (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 173) then                      (: 'ne' :)
      let $state := p:shift(173, $input, $state)            (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 183) then                      (: 'only' :)
      let $state := p:shift(183, $input, $state)            (: 'only' :)
      return $state
    else if ($state[$p:l1] = 185) then                      (: 'or' :)
      let $state := p:shift(185, $input, $state)            (: 'or' :)
      return $state
    else if ($state[$p:l1] = 186) then                      (: 'order' :)
      let $state := p:shift(186, $input, $state)            (: 'order' :)
      return $state
    else if ($state[$p:l1] = 206) then                      (: 'return' :)
      let $state := p:shift(206, $input, $state)            (: 'return' :)
      return $state
    else if ($state[$p:l1] = 209) then                      (: 'satisfies' :)
      let $state := p:shift(209, $input, $state)            (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 220) then                      (: 'stable' :)
      let $state := p:shift(220, $input, $state)            (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 221) then                      (: 'start' :)
      let $state := p:shift(221, $input, $state)            (: 'start' :)
      return $state
    else if ($state[$p:l1] = 232) then                      (: 'to' :)
      let $state := p:shift(232, $input, $state)            (: 'to' :)
      return $state
    else if ($state[$p:l1] = 233) then                      (: 'treat' :)
      let $state := p:shift(233, $input, $state)            (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 234) then                      (: 'try' :)
      let $state := p:shift(234, $input, $state)            (: 'try' :)
      return $state
    else if ($state[$p:l1] = 238) then                      (: 'union' :)
      let $state := p:shift(238, $input, $state)            (: 'union' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(248, $input, $state)            (: 'where' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NCName", $count, $begin, $end)
};

(:~
 : Try parsing NCName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-NCName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 21) then                            (: NCName^Token :)
      let $state := p:shiftT(21, $input, $state)            (: NCName^Token :)
      return $state
    else if ($state[$p:l1] = 95) then                       (: 'contains' :)
      let $state := p:shiftT(95, $input, $state)            (: 'contains' :)
      return $state
    else if ($state[$p:l1] = 190) then                      (: 'paragraphs' :)
      let $state := p:shiftT(190, $input, $state)           (: 'paragraphs' :)
      return $state
    else if ($state[$p:l1] = 216) then                      (: 'sentences' :)
      let $state := p:shiftT(216, $input, $state)           (: 'sentences' :)
      return $state
    else if ($state[$p:l1] = 231) then                      (: 'times' :)
      let $state := p:shiftT(231, $input, $state)           (: 'times' :)
      return $state
    else if ($state[$p:l1] = 254) then                      (: 'words' :)
      let $state := p:shiftT(254, $input, $state)           (: 'words' :)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'after' :)
      let $state := p:shiftT(71, $input, $state)            (: 'after' :)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:shiftT(78, $input, $state)            (: 'as' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'before' :)
      let $state := p:shiftT(83, $input, $state)            (: 'before' :)
      return $state
    else if ($state[$p:l1] = 154) then                      (: 'into' :)
      let $state := p:shiftT(154, $input, $state)           (: 'into' :)
      return $state
    else if ($state[$p:l1] = 168) then                      (: 'modify' :)
      let $state := p:shiftT(168, $input, $state)           (: 'modify' :)
      return $state
    else if ($state[$p:l1] = 251) then                      (: 'with' :)
      let $state := p:shiftT(251, $input, $state)           (: 'with' :)
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'and' :)
      let $state := p:shiftT(76, $input, $state)            (: 'and' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'ascending' :)
      let $state := p:shiftT(79, $input, $state)            (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 87) then                       (: 'case' :)
      let $state := p:shiftT(87, $input, $state)            (: 'case' :)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'cast' :)
      let $state := p:shiftT(88, $input, $state)            (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'castable' :)
      let $state := p:shiftT(89, $input, $state)            (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'collation' :)
      let $state := p:shiftT(92, $input, $state)            (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'count' :)
      let $state := p:shiftT(100, $input, $state)           (: 'count' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'default' :)
      let $state := p:shiftT(104, $input, $state)           (: 'default' :)
      return $state
    else if ($state[$p:l1] = 108) then                      (: 'descending' :)
      let $state := p:shiftT(108, $input, $state)           (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 113) then                      (: 'div' :)
      let $state := p:shiftT(113, $input, $state)           (: 'div' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'else' :)
      let $state := p:shiftT(117, $input, $state)           (: 'else' :)
      return $state
    else if ($state[$p:l1] = 118) then                      (: 'empty' :)
      let $state := p:shiftT(118, $input, $state)           (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 121) then                      (: 'end' :)
      let $state := p:shiftT(121, $input, $state)           (: 'end' :)
      return $state
    else if ($state[$p:l1] = 123) then                      (: 'eq' :)
      let $state := p:shiftT(123, $input, $state)           (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 126) then                      (: 'except' :)
      let $state := p:shiftT(126, $input, $state)           (: 'except' :)
      return $state
    else if ($state[$p:l1] = 131) then                      (: 'for' :)
      let $state := p:shiftT(131, $input, $state)           (: 'for' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'ge' :)
      let $state := p:shiftT(139, $input, $state)           (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 141) then                      (: 'group' :)
      let $state := p:shiftT(141, $input, $state)           (: 'group' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'gt' :)
      let $state := p:shiftT(143, $input, $state)           (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 144) then                      (: 'idiv' :)
      let $state := p:shiftT(144, $input, $state)           (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 152) then                      (: 'instance' :)
      let $state := p:shiftT(152, $input, $state)           (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 153) then                      (: 'intersect' :)
      let $state := p:shiftT(153, $input, $state)           (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 155) then                      (: 'is' :)
      let $state := p:shiftT(155, $input, $state)           (: 'is' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'le' :)
      let $state := p:shiftT(160, $input, $state)           (: 'le' :)
      return $state
    else if ($state[$p:l1] = 162) then                      (: 'let' :)
      let $state := p:shiftT(162, $input, $state)           (: 'let' :)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'lt' :)
      let $state := p:shiftT(165, $input, $state)           (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'mod' :)
      let $state := p:shiftT(167, $input, $state)           (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 173) then                      (: 'ne' :)
      let $state := p:shiftT(173, $input, $state)           (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 183) then                      (: 'only' :)
      let $state := p:shiftT(183, $input, $state)           (: 'only' :)
      return $state
    else if ($state[$p:l1] = 185) then                      (: 'or' :)
      let $state := p:shiftT(185, $input, $state)           (: 'or' :)
      return $state
    else if ($state[$p:l1] = 186) then                      (: 'order' :)
      let $state := p:shiftT(186, $input, $state)           (: 'order' :)
      return $state
    else if ($state[$p:l1] = 206) then                      (: 'return' :)
      let $state := p:shiftT(206, $input, $state)           (: 'return' :)
      return $state
    else if ($state[$p:l1] = 209) then                      (: 'satisfies' :)
      let $state := p:shiftT(209, $input, $state)           (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 220) then                      (: 'stable' :)
      let $state := p:shiftT(220, $input, $state)           (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 221) then                      (: 'start' :)
      let $state := p:shiftT(221, $input, $state)           (: 'start' :)
      return $state
    else if ($state[$p:l1] = 232) then                      (: 'to' :)
      let $state := p:shiftT(232, $input, $state)           (: 'to' :)
      return $state
    else if ($state[$p:l1] = 233) then                      (: 'treat' :)
      let $state := p:shiftT(233, $input, $state)           (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 234) then                      (: 'try' :)
      let $state := p:shiftT(234, $input, $state)           (: 'try' :)
      return $state
    else if ($state[$p:l1] = 238) then                      (: 'union' :)
      let $state := p:shiftT(238, $input, $state)           (: 'union' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(248, $input, $state)           (: 'where' :)
      return $state
  return $state
};

(:~
 : Parse ModuleDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ModuleDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(169, $input, $state)                (: 'module' :)
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:shift(171, $input, $state)                (: 'namespace' :)
  let $state := p:lookahead1W(181, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' | 'with' | 'words' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-NCName($input, $state)
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | ('(' ':') | '=' :)
  let $state := p:shift(60, $input, $state)                 (: '=' :)
  let $state := p:lookahead1W(17, $input, $state)           (: URILiteral | S^WS | ('(' ':') :)
  let $state := p:shift(8, $input, $state)                  (: URILiteral :)
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | ('(' ':') | ';' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Separator($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ModuleDecl", $count, $begin, $end)
};

(:~
 : Parse LibraryModule.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LibraryModule($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ModuleDecl($input, $state)
  let $state := p:lookahead1W(130, $input, $state)          (: EOF | S^WS | ('(' ':') | 'declare' | 'import' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Prolog($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "LibraryModule", $count, $begin, $end)
};

(:~
 : Parse Separator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Separator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(52, $input, $state)                 (: ';' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Separator", $count, $begin, $end)
};

(:~
 : Parse VersionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VersionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(255, $input, $state)                (: 'xquery' :)
  let $state := p:lookahead1W(107, $input, $state)          (: S^WS | ('(' ':') | 'encoding' | 'version' :)
  let $state :=
    if ($state[$p:l1] = 120) then                           (: 'encoding' :)
      let $state := p:shift(120, $input, $state)            (: 'encoding' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:shift(12, $input, $state)             (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(245, $input, $state)            (: 'version' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:shift(12, $input, $state)             (: StringLiteral :)
      let $state := p:lookahead1W(99, $input, $state)       (: S^WS | ('(' ':') | ';' | 'encoding' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 120) then                  (: 'encoding' :)
          let $state := p:shift(120, $input, $state)        (: 'encoding' :)
          let $state := p:lookahead1W(19, $input, $state)   (: StringLiteral | S^WS | ('(' ':') :)
          let $state := p:shift(12, $input, $state)         (: StringLiteral :)
          return $state
        else
          $state
      return $state
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | ('(' ':') | ';' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Separator($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VersionDecl", $count, $begin, $end)
};

(:~
 : Parse Module.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Module($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 255) then                           (: 'xquery' :)
      let $state := p:lookahead2W(178, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                               'castable' | 'contains' | 'div' | 'encoding' | 'eq' |
                                                               'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' |
                                                               'to' | 'treat' | 'union' | 'version' | '|' | '||' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 61695                          (: 'xquery' 'encoding' :)
          or $state[$p:lk] = 125695) then                   (: 'xquery' 'version' :)
      let $state := p:parse-VersionDecl($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 169) then                           (: 'module' :)
      let $state := p:lookahead2W(177, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                               'castable' | 'contains' | 'div' | 'eq' | 'except' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'lt' | 'mod' | 'namespace' | 'ne' | 'or' | 'to' |
                                                               'treat' | 'union' | '|' | '||' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 87721) then                         (: 'module' 'namespace' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-LibraryModule($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-MainModuleSequence($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Module", $count, $begin, $end)
};

(:~
 : Parse XQuery.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-XQuery($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Module($input, $state)
  let $state := p:lookahead1W(16, $input, $state)           (: EOF | S^WS | ('(' ':') :)
  let $state := p:shift(1, $input, $state)                  (: EOF :)
  let $end := $state[$p:e0]
  return p:reduce($state, "XQuery", $count, $begin, $end)
};

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    if ($error/@o) then
      concat
      (
        "syntax error, found ", $p:TOKEN[$error/@o + 1], "&#10;",
        "while expecting ", $p:TOKEN[$error/@x + 1], "&#10;",
        if ($error/@e = $begin) then
          ""
        else
          concat("after successfully scanning ", string($error/@e - $begin), " characters "),
        "at line ", string($line), ", column ", string($column), "&#10;",
        "...", substring($input, $begin, 32), "..."
      )
    else
      let $expected := p:expected-token-set($error/@s)
      return
        concat
        (
          "lexical analysis failed&#10;",
          "while expecting ",
          "["[exists($expected[2])],
          string-join($expected, ", "),
          "]"[exists($expected[2])],
          "&#10;",
          if ($error/@e = $begin) then
            ""
          else
            concat("after successfully scanning ", string($error/@e - $begin), " characters "),
          "at line ", string($line), ", column ", string($column), "&#10;",
          "...", substring($input, $begin, 32), "..."
        )
};

(:~
 : Shift one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : parser state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:shift($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] = $code) then
  (
    subsequence($state, $p:l1, $p:e3 - $p:l1 + 1),
    0,
    $state[$p:e3],
    subsequence($state, $p:e3),
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    where $begin ne $end
    return
      text
      {
        substring($input, $begin, $end - $begin)
      },
    let $token := $p:TOKEN[1 + $state[$p:l1]]
    let $name := if (starts-with($token, "'")) then "TOKEN" else $token
    let $begin := $state[$p:b1]
    let $end := $state[$p:e1]
    return
      element {$name}
      {
        substring($input, $begin, $end - $begin)
      }
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      if ($state[$p:e1] < $state[$p:memo]/@e) then
        $state[$p:memo]/@*
      else
      (
        attribute b {$state[$p:b1]},
        attribute e {$state[$p:e1]},
        if ($state[$p:l1] < 0) then
          attribute s {- $state[$p:l1]}
        else
          (attribute o {$state[$p:l1]}, attribute x {$code})
      )
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Shift one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : parser state. In contrast to p:shift, do not create any output.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:shiftT($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] = $code) then
  (
    subsequence($state, $p:l1, $p:e3 - $p:l1 + 1),
    0,
    $state[$p:e3],
    subsequence($state, $p:e3)
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      if ($state[$p:e1] < $state[$p:memo]/@e) then
        $state[$p:memo]/@*
      else
      (
        attribute b {$state[$p:b1]},
        attribute e {$state[$p:e1]},
        if ($state[$p:l1] < 0) then
          attribute s {- $state[$p:l1]}
        else
          (attribute o {$state[$p:l1]}, attribute x {$code})
      )
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Consume whitespace.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:whitespace($input as xs:string,
                              $state as item()+) as item()+
{
  if ($state[$p:e0] = $state[$p:b1]) then
    $state
  else
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    return
    (
      0,
      $begin,
      $end,
      subsequence($state, $p:e0 + 1),
      text
      {
        substring($input, $begin, $end - $begin)
      }
    )
};

(:~
 : Use p:match to fetch the next token, but skip any leading
 : whitespace.
 :
 : @param $input the input string.
 : @param $begin the index where to start.
 : @param $token-set the valid token set id.
 : @return a sequence of three values: the token code of the result
 : token, with input string positions of token begin and end.
 :)
declare function p:matchW($input as xs:string,
                          $begin as xs:integer,
                          $token-set as xs:integer) as xs:integer+
{
  let $match := p:match($input, $begin, $token-set)
  return
    if ($match[1] = 24) then                                (: S^WS :)
      p:matchW($input, $match[3], $token-set)
    else if ($match[1] = 36) then                           (: ('(' ':') :)
      let $state := p:try-Whitespace($input, (0, 0, 0, $match, 0, $match[3], 0, 0, 0, 0, false(), <memo/>))
      return p:matchW($input, $state[$p:e0], $token-set)
    else
      $match
};

(:~
 : Lookahead one token on level 1 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:matchW($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      subsequence($state, $p:lk + 1, $p:l1 - $p:lk - 1),
      $match,
      0, $match[3], 0,
      subsequence($state, $p:e2 + 1)
    )
};

(:~
 : Lookahead one token on level 2 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead2W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l2] != 0) then
      subsequence($state, $p:l2, $p:e2 - $p:l2 + 1)
    else
      p:matchW($input, $state[$p:b2], $set)
  return
  (
    $match[1] * 512 + $state[$p:l1],
    subsequence($state, $p:lk + 1, $p:l2 - $p:lk - 1),
    $match,
    0, $match[3], 0,
    subsequence($state, $p:e3 + 1)
  )
};

(:~
 : Lookahead one token on level 3 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead3W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l3] != 0) then
      subsequence($state, $p:l3, $p:e3 - $p:l3 + 1)
    else
      p:matchW($input, $state[$p:b3], $set)
  return
  (
    $match[1] * 262144 + $state[$p:lk],
    subsequence($state, $p:lk + 1, $p:l3 - $p:lk - 1),
    $match,
    subsequence($state, $p:e3 + 1)
  )
};

(:~
 : Lookahead one token on level 1.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:match($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      subsequence($state, $p:lk + 1, $p:l1 - $p:lk - 1),
      $match,
      0, $match[3], 0,
      subsequence($state, $p:e2 + 1)
    )
};

(:~
 : Reduce the result stack, creating a nonterminal element. Pop
 : $count elements off the stack, wrap them in a new element
 : named $name, and push the new element.
 :
 : @param $state the parser state.
 : @param $name the name of the result node.
 : @param $count the number of child nodes.
 : @param $begin the input index where the nonterminal begins.
 : @param $end the input index where the nonterminal ends.
 : @return the updated parser state.
 :)
declare function p:reduce($state as item()+, $name as xs:string, $count as xs:integer, $begin as xs:integer, $end as xs:integer) as item()+
{
  subsequence($state, 1, $count),
  element {$name}
  {
    subsequence($state, $count + 1)
  }
};

(:~
 : Strip result from parser state, in order to avoid carrying it while
 : backtracking.
 :
 : @param $state the parser state after an alternative failed.
 : @return the updated parser state.
 :)
declare function p:strip-result($state as item()+) as item()+
{
  subsequence($state, 1, $p:memo)
};

(:~
 : Restore parser state after unsuccessfully trying an alternative,
 : merging any memoization that was collected on the way.
 :
 : @param $backtrack the parser state before backtracking started.
 : @param $state the parser state after an alternative failed.
 : @return the updated parser state.
 :)
declare function p:restore($backtrack as item()+,
                           $state as item()+) as item()+
{
  subsequence($backtrack, 1, $p:memo - 1),
  element memo{$state[$p:error]/@*, $state[$p:memo]/value}
};

(:~
 : Memoize the backtracking result that was computed at decision point
 : $i for input position $state[$p:e0].
 :
 : @param $backtrack the parser state before backtracking started.
 : @param $state the parser state after successfully trying an alternative.
 : @param $v the id of the successful alternative.
 : @param $i the decision point id.
 : @return the updated parser state.
 :)
declare function p:memoize($backtrack as item()+,
                           $state as item()+,
                           $v as xs:integer,
                           $i as xs:integer) as item()+
{
  $v,
  subsequence($backtrack, $p:lk + 1, $p:memo - $p:lk - 1),
  element memo
  {
    $state[$p:memo]/value,
    element value {attribute key {$backtrack[$p:e0] * 1 + $i}, $v}
  },
  subsequence($backtrack, $p:memo + 1)
};

(:~
 : Retrieve memoized backtracking result for decision point $i
 : and input position $state[$p:e0] into $state[$p:lk].
 :
 : @param $state the parser state.
 : @param $i the decision point id.
 : @return the updated parser state.
 :)
declare function p:memoized($state as item()+, $i as xs:integer) as item()+
{
  let $value := data($state[$p:memo]/value[@key = $state[$p:e0] * 1 + $i])
  return
  (
    if ($value) then $value else 0,
    subsequence($state, $p:lk + 1)
  )
};

(:~
 : Parse start symbol XQuery from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-XQuery($s as xs:string) as item()*
{
  let $state := p:parse-XQuery($s, (0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, false(), <memo/>))
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      subsequence($state, $p:result)
};

(: End :)
