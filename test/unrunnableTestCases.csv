cbcl-subsequence-010,Performance: crashes browser when trying to create array of 3000000000 elements
cbcl-subsequence-012,Performance: crashes browser when trying to create array of 3000000000 elements
cbcl-subsequence-013,Performance: crashes browser when trying to create array of 3000000000 elements
cbcl-subsequence-014,Performance: crashes browser when trying to create array of 3000000000 elements
map-keys-014,Tries to make a map of length 500K
map-keys-016,Tries to make a map of huge length
map-remove-012,Tries to make a map of length 500K
map-for-each-014,Tries to make a map of length 500K
map-remove-012,Tries to make a map of length 500K
map-contains-016,Tries to make a map of huge length
map-get-016,Tries to make a map of huge length
RexParser,Loads missing files...
fn-absintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-absintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-absintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-abslng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-abslng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-abslng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-absnint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-absnint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-abspint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-abspint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-absulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-absulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-absnpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-absnpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-absnni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-absnni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-abs-1,Error: XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
fn-avgintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avglng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avglng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avglng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgpint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgpint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgintg2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgintg2args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgintg2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgintg2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgintg2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgflt2args-2,AssertionError: Expected XPath fn:avg((xs:float("0"),xs:float("-3.4028235E38"))) to resolve to xs:float('-1.7014117E38'): expected false to be true
fn-avgflt2args-4,AssertionError: Expected XPath fn:avg((xs:float("-3.4028235E38"),xs:float("0"))) to resolve to xs:float('-1.7014117E38'): expected false to be true
fn-avglng2args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avglng2args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avglng2args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avglng2args-4,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avglng2args-5,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnint2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnint2args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnint2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnint2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnint2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgpint2args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgpint2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgpint2args-4,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgpint2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgulng2args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgulng2args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgulng2args-4,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgulng2args-5,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnpi2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnpi2args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnpi2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnpi2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnpi2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnni2args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnni2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnni2args-4,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnni2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avg-mix-args-002,Error: FORG0006: items passed to fn:avg are not all numeric.
fn-avg-mix-args-012,AssertionError: Expected XPath fn:avg(( (xs:float("-3.4028235E38"), xs:decimal("-999999999999999999") ))) to resolve to xs:float("-1.7014117E38"): expected false to be true
fn-avg-mix-args-014,AssertionError: Expected XPath fn:avg(( (xs:float("3.4028235E38"), xs:decimal("-999999999999999999") ))) to resolve to xs:float("1.7014117E38"): expected false to be true
fn-avg-mix-args-020,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avg-mix-args-021,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avg-mix-args-022,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avg-mix-args-023,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avg-mix-args-024,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avg-mix-args-025,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avg-mix-args-036,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.'
fn-avg-mix-args-037,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.'
fn-avg-mix-args-038,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.'
fn-avg-mix-args-051,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.'
fn-avg-mix-args-052,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.'
fn-avg-mix-args-053,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.'
fn-avg-mix-args-054,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.'
fn-avg-mix-args-055,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.'
fn-avg-mix-args-056,AssertionError: Expected executing the XPath "fn:avg(( (xs:double("NaN"), xs:integer("-999999999999999999") , "a", (), "3") ))" to resolve to one of the expected results, but got Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers., AssertionError: expected [Function] to throw error including 'FORG0006' but got 'FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.'.
K-SeqAVGFunc-39,Error: FORG0006: items passed to fn:avg are not all numeric.
fn-avg-3,Error: FORG0006: items passed to fn:avg are not all numeric.
fn-avg-4,Error: FORG0006: items passed to fn:avg are not all numeric.
fn-avg-5,Error: FORG0006: items passed to fn:avg are not all numeric.
fn-avg-6,Error: FORG0006: items passed to fn:avg are not all numeric.
fn-avg-10,Error: FORG0006: items passed to fn:avg are not all numeric.
cbcl-avg-001,AssertionError: Expected executing the XPath "fn:avg((xs:decimal("79000000000000000000000000000"),                     xs:decimal("79000000000000000000000000000")))             eq 79000000000000000000000000000       " to resolve to one of the expected results, but got AssertionError: Expected XPath fn:avg((xs:decimal("79000000000000000000000000000"),                     xs:decimal("79000000000000000000000000000")))             eq 79000000000000000000000000000        to resolve to true: expected false to be true, AssertionError: expected [Function] to throw an error.
cbcl-avg-004,Error: FORG0006: items passed to fn:avg are not all numeric.
cbcl-avg-006,Error: FORG0006: items passed to fn:avg are not all numeric.
cbcl-avg-008,Error: XPST0003: Unable to parse XPath: "typeswitch (fn:avg((xs:float(1), xs:double(2), xs:float(3)))) case $x as xs:double return $x default return "FAIL"". Expected "!", "!=", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "(" found. typeswitch [Error is around here](fn:avg((xs:float(1), xs:double(2), xs:float(3)))) case $x as xs:double return $x default return "FAIL"
fn-booleanintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-booleanintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-booleanintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-booleanlng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-booleanlng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-booleanlng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-booleannint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-booleannint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-booleanpint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-booleanpint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-booleanulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-booleanulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-booleannpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-booleannpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-booleannni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-booleannni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-boolean-mixed-args-032,Error: FOCA0003: can not cast -99999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-boolean-mixed-args-035,Error: FOCA0003: can not cast -99999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-boolean-mixed-args-037,Error: FOCA0003: can not cast 99999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-boolean-mixed-args-039,Error: FOCA0003: can not cast 9223372036854775807 to xs:integer, it is out of bounds for JavaScript numbers.
fn-boolean-mixed-args-040,Error: FOCA0003: can not cast -9223372036854775808 to xs:integer, it is out of bounds for JavaScript numbers.
K-SeqBooleanFunc-16,Error: XPST0003: Unable to parse XPath: "true() eq boolean(remove((xs:hexBinary("FF"), 1), 1) treat as xs:integer)". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found. true() eq boolean(remove((xs:hexBinary("FF"), 1), 1) [Error is around here]treat as xs:integer)
cbcl-boolean-005,Error: XPST0003: Unable to parse XPath: "       declare function local:repeat($count as xs:integer, $arg as xs:string) { for $x in 1 to $count return $arg };        fn:boolean( text { local:repeat(0, "string") } )       ". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.        declare function local:repeat($count as xs:integer, $arg as xs:string) { for $x in 1 to $count return $arg };        fn:boolean( text [Error is around here]{ local:repeat(0, "string") } )
cbcl-boolean-006,Error: XPST0003: Unable to parse XPath: "       declare function local:repeat($count as xs:integer, $arg as xs:string) as item()* {        	if ($count lt 0) then '$count must not be negative'        	else text { for $x in 1 to $count return $arg }       };        fn:boolean( local:repeat(0, "string") )". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.        declare function local:repeat($count as xs:integer, $arg as xs:string) as item()* {        	if ($count lt 0) then '$count must not be negative'        	else text [Error is around here]{ for $x in 1 to $count return $arg }       };        fn:boolean( local:repeat(0, "string") )
fn-ceilingintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-ceilingintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-ceilingintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-ceilinglng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-ceilinglng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-ceilinglng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-ceilingnint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-ceilingnint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-ceilingpint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-ceilingpint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-ceilingulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-ceilingulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-ceilingnpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-ceilingnpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-ceilingnni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-ceilingnni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-ceiling-1,Error: XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
fn-concatintg2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatintg2args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatintg2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatintg2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatintg2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatdec2args-1,AssertionError: fn:concat(xs:decimal("-999999999999999999"),xs:decimal("-999999999999999999")): expected '-1000000000000000000-1000000000000000000' to equal '-999999999999999999-999999999999999999'
fn-concatdec2args-2,AssertionError: fn:concat(xs:decimal("617375191608514839"),xs:decimal("-999999999999999999")): expected '617375191608514800-1000000000000000000' to equal '617375191608514839-999999999999999999'
fn-concatdec2args-3,AssertionError: fn:concat(xs:decimal("999999999999999999"),xs:decimal("-999999999999999999")): expected '1000000000000000000-1000000000000000000' to equal '999999999999999999-999999999999999999'
fn-concatdec2args-4,AssertionError: fn:concat(xs:decimal("-999999999999999999"),xs:decimal("617375191608514839")): expected '-1000000000000000000617375191608514800' to equal '-999999999999999999617375191608514839'
fn-concatdec2args-5,AssertionError: fn:concat(xs:decimal("-999999999999999999"),xs:decimal("999999999999999999")): expected '-10000000000000000001000000000000000000' to equal '-999999999999999999999999999999999999'
fn-concatlng2args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatlng2args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatlng2args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatlng2args-4,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatlng2args-5,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatnint2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatnint2args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatnint2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatnint2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatnint2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatpint2args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatpint2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatpint2args-4,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatpint2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatulng2args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatulng2args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatulng2args-4,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatulng2args-5,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatnpi2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatnpi2args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatnpi2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatnpi2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatnpi2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatnni2args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatnni2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatnni2args-4,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatnni2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-contains-17,Error: FOCH0002: No collations are supported
fn-contains-18,Error: FOCH0002: No collations are supported
fn-contains-19,Error: FOCH0002: No collations are supported
fn-contains-20,Error: FOCH0002: No collations are supported
fn-contains-21,Error: FOCH0002: No collations are supported
fn-contains-22,Error: FOCH0002: No collations are supported
fn-contains-23,Error: FOCH0002: No collations are supported
fn-contains-24,Error: FOCH0002: No collations are supported
fn-contains-25,Error: FOCH0002: No collations are supported
fn-contains-26,Error: FOCH0002: No collations are supported
fn-contains-27,Error: FOCH0002: No collations are supported
fn-contains-28,Error: FOCH0002: No collations are supported
fn-contains-29,Error: FOCH0002: No collations are supported
fn-contains-30,Error: FOCH0002: No collations are supported
fn-contains-31,Error: FOCH0002: No collations are supported
fn-contains-35,Error: FOCH0002: No collations are supported
fn-contains-37,Error: FOCH0002: No collations are supported
K-ContainsFunc-5,Error: FOCH0002: No collations are supported
K2-ContainsFunc-1,Error: XPST0003: Unable to parse XPath: "let $vA := ("B STRING", current-time(), string("content"))[1] treat as xs:string,                 $vB  := ("b string", current-time(), string("content"))[1] treat as xs:string          return contains(lower-case($vA), lower-case($vB))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found. let $vA := ("B STRING", current-time(), string("content"))[1] [Error is around here]treat as xs:string,                 $vB  := ("b string", current-time(), string("content"))[1] treat as xs:string          return contains(lower-case($vA), lower-case($vB))
K2-ContainsFunc-2,Error: XPST0003: Unable to parse XPath: "let $vA := ("B STRING", current-time(), string("content"))[1] treat as xs:string,                 $vB := ("b string", current-time(), string("content"))[1] treat as xs:string          return contains(upper-case($vA), upper-case($vB))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found. let $vA := ("B STRING", current-time(), string("content"))[1] [Error is around here]treat as xs:string,                 $vB := ("b string", current-time(), string("content"))[1] treat as xs:string          return contains(upper-case($vA), upper-case($vB))
K2-ContainsFunc-3,Error: XPST0003: Unable to parse XPath: "let $vA  := ("B STRING", current-time(), string("content"))[1] treat as xs:string,                 $vB := ("no match", current-time(), string("content"))[1] treat as xs:string          return contains(lower-case($vA), lower-case($vB))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found. let $vA  := ("B STRING", current-time(), string("content"))[1] [Error is around here]treat as xs:string,                 $vB := ("no match", current-time(), string("content"))[1] treat as xs:string          return contains(lower-case($vA), lower-case($vB))
K2-ContainsFunc-4,Error: XPST0003: Unable to parse XPath: "let $vA := ("B STRING", current-time(), string("content"))[1] treat as xs:string,                 $vB  := ("no match", current-time(), string("content"))[1] treat as xs:string         return contains(upper-case($vA), upper-case($vB))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found. let $vA := ("B STRING", current-time(), string("content"))[1] [Error is around here]treat as xs:string,                 $vB  := ("no match", current-time(), string("content"))[1] treat as xs:string         return contains(upper-case($vA), upper-case($vB))
K2-ContainsFunc-5,Error: XPST0003: Unable to parse XPath: "let $vA := ("B STRING", current-time(), string("content"))[1] treat as xs:string,                 $vB := ("b string", current-time(), string("content"))[1] treat as xs:string          return contains(upper-case($vA), lower-case($vB))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found. let $vA := ("B STRING", current-time(), string("content"))[1] [Error is around here]treat as xs:string,                 $vB := ("b string", current-time(), string("content"))[1] treat as xs:string          return contains(upper-case($vA), lower-case($vB))
K2-ContainsFunc-6,Error: XPST0003: Unable to parse XPath: "let $vA := ("B STRING", current-time(), string("content"))[1] treat as xs:string,                 $vB := ("b string", current-time(), string("content"))[1] treat as xs:string          return contains(lower-case($vA), upper-case($vB))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found. let $vA := ("B STRING", current-time(), string("content"))[1] [Error is around here]treat as xs:string,                 $vB := ("b string", current-time(), string("content"))[1] treat as xs:string          return contains(lower-case($vA), upper-case($vB))
cbcl-contains-001,Error: FOCH0002: No collations are supported
cbcl-contains-002,Error: FOCH0002: No collations are supported
cbcl-contains-003,Error: XPST0017: Function fn:index-of with arity of 2 not registered. No similar functions found.
liam-contains-001,Error: FOCH0002: No collations are supported
liam-contains-002,Error: FOCH0002: No collations are supported
liam-contains-003,Error: FOCH0002: No collations are supported
liam-contains-004,Error: FOCH0002: No collations are supported
fn-countintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-countintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-countintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-countlng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-countlng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-countlng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-countnint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-countnint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-countpint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-countpint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-countulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-countulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-countnpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-countnpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-countnni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-countnni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
Count015,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
fn-current-date-6,Error: Not implemented: adding durations to xs:date
fn-current-date-7,Error: Not implemented: subtracting durations from xs:date
fn-current-date-21,Error: Not implemented: subtracting durations from xs:date
fn-current-dateTime-6,Error: Not implemented: adding durations to xs:dateTime
fn-current-datetime-7,Error: Not implemented: subtracting durations from xs:dateTime
fn-current-dateTime-21,Error: Not implemented: subtracting durations from xs:dateTime
fn-current-time-6,Error: Not implemented: adding durations to xs:time
fn-current-time-7,Error: Not implemented: subtracting durations from xs:time
fn-dateTime-22,Error: XPST0017: Function fn:adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
fn-dateTime-24,Error: Not implemented: adding durations to xs:dateTime
fn-dateTime-25,Error: Not implemented: adding durations to xs:dateTime
fn-dateTime-26,Error: Not implemented: subtracting durations from xs:dateTime
fn-dateTime-27,Error: Not implemented: subtracting durations from xs:dateTime
cbcl-dateTime-001,Error: XPST0017: Function fn:index-of with arity of 2 not registered. No similar functions found.
cbcl-dateTime-002,AssertionError: expected [Function] to throw error including 'FORG0008' but got 'XPST0017: Function fn:index-of with arity of 2 not registered. No similar functions found.'
fn-day-from-dateTime-3,Error: XPST0017: Function fn:adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
fn-deep-equalintg2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalintg2args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalintg2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalintg2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalintg2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equallng2args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equallng2args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equallng2args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equallng2args-4,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equallng2args-5,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalnint2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalnint2args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalnint2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalnint2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalnint2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalpint2args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalpint2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalpint2args-4,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalpint2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalulng2args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalulng2args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalulng2args-4,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalulng2args-5,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalnpi2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalnpi2args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalnpi2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalnpi2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalnpi2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalnni2args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalnni2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalnni2args-4,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalnni2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equal-mix-args-019,AssertionError: Expected XPath fn:deep-equal( xs:float(1.01) , xs:double(1.01)) to resolve to false: expected true to be false
fn-deep-equal-maps-13,Error: FOCH0002: No collations are supported
fn-deep-equal-maps-14,Error: FOCH0002: No collations are supported
fn-deep-equal-maps-16,Error: XPST0017: Function adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
fn-deep-equal-maps-17,Error: XPST0017: Function adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
K-SeqDeepEqualFunc-6,Error: FOCH0002: No collations are supported
K-SeqDeepEqualFunc-32,Error: XPST0017: Function index-of with arity of 2 not registered. No similar functions found.
K-SeqDeepEqualFunc-33,Error: XPST0017: Function index-of with arity of 2 not registered. No similar functions found.
K-SeqDeepEqualFunc-34,Error: XPST0017: Function index-of with arity of 2 not registered. No similar functions found.
K-SeqDeepEqualFunc-35,Error: XPST0017: Function index-of with arity of 2 not registered. No similar functions found.
K-SeqDeepEqualFunc-56,Error: FOCH0002: No collations are supported
K-SeqDeepEqualFunc-57,Error: FOCH0002: No collations are supported
K-SeqDeepEqualFunc-58,Error: FOCH0002: No collations are supported
K-SeqDeepEqualFunc-59,Error: FOCH0002: No collations are supported
K-SeqDeepEqualFunc-60,Error: FOCH0002: No collations are supported
K-SeqDeepEqualFunc-61,Error: FOCH0002: No collations are supported
K-SeqDeepEqualFunc-62,Error: FOCH0002: No collations are supported
K-SeqDeepEqualFunc-63,Error: FOCH0002: No collations are supported
K-SeqDeepEqualFunc-64,Error: FOCH0002: No collations are supported
K-SeqDeepEqualFunc-65,Error: FOCH0002: No collations are supported
K-SeqDeepEqualFunc-66,Error: FOCH0002: No collations are supported
K-SeqDeepEqualFunc-67,Error: FOCH0002: No collations are supported
K-SeqDeepEqualFunc-68,Error: FOCH0002: No collations are supported
K-SeqDeepEqualFunc-69,Error: FOCH0002: No collations are supported
K-SeqDeepEqualFunc-70,Error: FOCH0002: No collations are supported
K-SeqDeepEqualFunc-71,Error: FOCH0002: No collations are supported
K2-SeqDeepEqualFunc-14,Error: XPST0003: Unable to parse XPath: "declare variable $d1 := document { <?target data?>, text{"some text"}}; declare variable $d2 := document {text{"some text"}}; deep-equal($d1, $d2)". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", ";", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. declare variable $d1 := document [Error is around here]{ <?target data?>, text{"some text"}}; declare variable $d2 := document {text{"some text"}}; deep-equal($d1, $d2)
K2-SeqDeepEqualFunc-15,Error: XPST0003: Unable to parse XPath: "declare variable $d1 := document {()}; declare variable $d2 := document {<?target data?>}; deep-equal($d1, $d2)". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", ";", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. declare variable $d1 := document [Error is around here]{()}; declare variable $d2 := document {<?target data?>}; deep-equal($d1, $d2)
K2-SeqDeepEqualFunc-16,Error: XPST0003: Unable to parse XPath: "declare variable $d1 := document { <?target data?>, text{"some text"}}; declare variable $d2 := document {text{"some text"}}; deep-equal($d1, $d2)". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", ";", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. declare variable $d1 := document [Error is around here]{ <?target data?>, text{"some text"}}; declare variable $d2 := document {text{"some text"}}; deep-equal($d1, $d2)
K2-SeqDeepEqualFunc-17,Error: XPST0003: Unable to parse XPath: "declare variable $d1 := document {()}; declare variable $d2 := document {<?target data?>}; deep-equal($d1, $d2)". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", ";", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. declare variable $d1 := document [Error is around here]{()}; declare variable $d2 := document {<?target data?>}; deep-equal($d1, $d2)
K2-SeqDeepEqualFunc-20,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-SeqDeepEqualFunc-21,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-SeqDeepEqualFunc-22,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-SeqDeepEqualFunc-23,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-SeqDeepEqualFunc-24,Error: XPST0003: Unable to parse XPath: "deep-equal(attribute name {"content"}, attribute name {"content"})". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. deep-equal(attribute [Error is around here]name {"content"}, attribute name {"content"})
K2-SeqDeepEqualFunc-25,Error: XPST0003: Unable to parse XPath: "deep-equal((attribute name2 {"content"}, attribute name {"content"}), (attribute name {"content"}, attribute name2 {"content"}))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. deep-equal((attribute [Error is around here]name2 {"content"}, attribute name {"content"}), (attribute name {"content"}, attribute name2 {"content"}))
K2-SeqDeepEqualFunc-26,Error: XPST0003: Unable to parse XPath: "deep-equal((attribute name {"content"}, attribute name {"content"}), (attribute name {"content"}))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. deep-equal((attribute [Error is around here]name {"content"}, attribute name {"content"}), (attribute name {"content"}))
K2-SeqDeepEqualFunc-27,Error: XPST0003: Unable to parse XPath: "deep-equal((attribute name {"content"}, attribute name {"content"}), attribute name {"content"})". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. deep-equal((attribute [Error is around here]name {"content"}, attribute name {"content"}), attribute name {"content"})
K2-SeqDeepEqualFunc-28,Error: XPST0003: Unable to parse XPath: "deep-equal(attribute name {}, attribute name {})". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. deep-equal(attribute [Error is around here]name {}, attribute name {})
K2-SeqDeepEqualFunc-29,Error: XPST0003: Unable to parse XPath: "deep-equal(attribute name {"content"}, attribute name {"content"})". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. deep-equal(attribute [Error is around here]name {"content"}, attribute name {"content"})
K2-SeqDeepEqualFunc-30,Error: XPST0003: Unable to parse XPath: "deep-equal(attribute name {"content"}, attribute name {})". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. deep-equal(attribute [Error is around here]name {"content"}, attribute name {})
K2-SeqDeepEqualFunc-31,Error: XPST0003: Unable to parse XPath: "deep-equal(attribute name {}, attribute name2 {})". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. deep-equal(attribute [Error is around here]name {}, attribute name2 {})
K2-SeqDeepEqualFunc-32,Error: XPST0003: Unable to parse XPath: "deep-equal(attribute name {"content "}, attribute name2 {"content "})". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. deep-equal(attribute [Error is around here]name {"content "}, attribute name2 {"content "})
K2-SeqDeepEqualFunc-40,Error: Not implemented: subtracting durations from xs:dateTime
cbcl-deep-equal-001,Error: XPST0003: Unable to parse XPath: "let $doc1 := <doc><?processing-instruction content ?></doc> let $doc2 := <doc><!--comment--></doc> return deep-equal($doc1, $doc2)". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. let $doc1 := <doc><?processing-instruction content ?></doc> [Error is around here]let $doc2 := <doc><!--comment--></doc> return deep-equal($doc1, $doc2)
cbcl-deep-equal-002,Error: XPST0003: Unable to parse XPath: "let $doc1 := <?cheese brie?> let $doc2 := <?cheese stilton?> return deep-equal($doc1, $doc2)". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. let $doc1 := <?cheese brie?> [Error is around here]let $doc2 := <?cheese stilton?> return deep-equal($doc1, $doc2)
cbcl-deep-equal-003,Error: XPST0003: Unable to parse XPath: "let $doc1 := <?foo test?> let $doc2 := <?bar test?> return deep-equal($doc1, $doc2)". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. let $doc1 := <?foo test?> [Error is around here]let $doc2 := <?bar test?> return deep-equal($doc1, $doc2)
cbcl-deep-equal-004,Error: XPST0003: Unable to parse XPath: "let $doc1 := <?foo bar?> let $doc2 := <?foo bar?> return deep-equal($doc1, $doc2)". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. let $doc1 := <?foo bar?> [Error is around here]let $doc2 := <?foo bar?> return deep-equal($doc1, $doc2)
cbcl-deep-equal-005,Error: XPST0003: Unable to parse XPath: "declare function local:f($x as xs:integer)as xs:integer* { 1 to $x }; deep-equal((local:f(3), 2, local:f(1)), (local:f(3), 2))". Expected " ", "(:", "\n", "\r", or "\t" but "a" found. declare function local:f($x as xs:integer)[Error is around here]as xs:integer* { 1 to $x }; deep-equal((local:f(3), 2, local:f(1)), (local:f(3), 2))
fn-emptyintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-emptyintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-emptyintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-emptylng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-emptylng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-emptylng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-emptynint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-emptynint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-emptypint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-emptypint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-emptyulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-emptyulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-emptynpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-emptynpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-emptynni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-emptynni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
cbcl-empty-func-004,Error: XPST0003: Unable to parse XPath: "empty(text {(1 to 10)[. mod 2 = 0]})". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. empty(text [Error is around here]{(1 to 10)[. mod 2 = 0]})
fn-ends-with-17,Error: FOCH0002: No collations are supported
fn-ends-with-18,Error: FOCH0002: No collations are supported
fn-ends-with-19,Error: FOCH0002: No collations are supported
fn-ends-with-20,Error: FOCH0002: No collations are supported
fn-ends-with-21,Error: FOCH0002: No collations are supported
fn-ends-with-22,Error: FOCH0002: No collations are supported
fn-ends-with-23,Error: FOCH0002: No collations are supported
fn-ends-with-24,Error: FOCH0002: No collations are supported
fn-ends-with-25,Error: FOCH0002: No collations are supported
fn-ends-with-26,Error: FOCH0002: No collations are supported
fn-ends-with-27,Error: FOCH0002: No collations are supported
fn-ends-with-28,Error: FOCH0002: No collations are supported
fn-ends-with-29,Error: FOCH0002: No collations are supported
fn-ends-with-30,Error: FOCH0002: No collations are supported
fn-ends-with-31,Error: FOCH0002: No collations are supported
fn-ends-with-33,AssertionError: Expected executing the XPath "fn:ends-with("Chapter-100", "Chapter-10", "http://www.w3.org/2013/collation/UCA?lang=en;numeric=yes")" to resolve to one of the expected results, but got Error: FOCH0002: No collations are supported, AssertionError: expected [Function] to throw error including 'FOCH0004' but got 'FOCH0002: No collations are supported'.
K-EndsWithFunc-5,Error: FOCH0002: No collations are supported
K2-EndsWithFunc-1,Error: XPST0003: Unable to parse XPath: "let $vA := ("B STRING", current-time(), string("content"))[1] treat as xs:string,          $vB := ("b string", current-time(), string("content"))[1] treat as xs:string         return ends-with(lower-case($vA), lower-case($vB))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found. let $vA := ("B STRING", current-time(), string("content"))[1] [Error is around here]treat as xs:string,          $vB := ("b string", current-time(), string("content"))[1] treat as xs:string         return ends-with(lower-case($vA), lower-case($vB))
K2-EndsWithFunc-2,Error: XPST0003: Unable to parse XPath: "          let $vA  := ("B STRING", current-time(), string("content"))[1] treat as xs:string,          $vB  := ("b string", current-time(), string("content"))[1] treat as xs:string          return ends-with(upper-case($vA), upper-case($vB))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found.           let $vA  := ("B STRING", current-time(), string("content"))[1] [Error is around here]treat as xs:string,          $vB  := ("b string", current-time(), string("content"))[1] treat as xs:string          return ends-with(upper-case($vA), upper-case($vB))
K2-EndsWithFunc-3,Error: XPST0003: Unable to parse XPath: "          let $vA  := ("B STRING", current-time(), string("content"))[1] treat as xs:string,          $vB  := ("no match", current-time(), string("content"))[1] treat as xs:string          return ends-with(lower-case($vA), lower-case($vB))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found.           let $vA  := ("B STRING", current-time(), string("content"))[1] [Error is around here]treat as xs:string,          $vB  := ("no match", current-time(), string("content"))[1] treat as xs:string          return ends-with(lower-case($vA), lower-case($vB))
K2-EndsWithFunc-4,Error: XPST0003: Unable to parse XPath: "          let $vA  := ("B STRING", current-time(), string("content"))[1] treat as xs:string,          $vB  := ("no match", current-time(), string("content"))[1] treat as xs:string          return ends-with(upper-case($vA), upper-case($vB))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found.           let $vA  := ("B STRING", current-time(), string("content"))[1] [Error is around here]treat as xs:string,          $vB  := ("no match", current-time(), string("content"))[1] treat as xs:string          return ends-with(upper-case($vA), upper-case($vB))
K2-EndsWithFunc-5,Error: XPST0003: Unable to parse XPath: "          let $vA := ("B STRING", current-time(), string("content"))[1] treat as xs:string,          $vB := ("b string", current-time(), string("content"))[1] treat as xs:string         return ends-with(upper-case($vA), lower-case($vB))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found.           let $vA := ("B STRING", current-time(), string("content"))[1] [Error is around here]treat as xs:string,          $vB := ("b string", current-time(), string("content"))[1] treat as xs:string         return ends-with(upper-case($vA), lower-case($vB))
K2-EndsWithFunc-6,Error: XPST0003: Unable to parse XPath: "          let $vA := ("B STRING", current-time(), string("content"))[1] treat as xs:string,          $vB := ("b string", current-time(), string("content"))[1] treat as xs:string         return ends-with(lower-case($vA), upper-case($vB))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found.           let $vA := ("B STRING", current-time(), string("content"))[1] [Error is around here]treat as xs:string,          $vB := ("b string", current-time(), string("content"))[1] treat as xs:string         return ends-with(lower-case($vA), upper-case($vB))
cbcl-ends-with-001,Error: FOCH0002: No collations are supported
fn-exactly-oneintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-exactly-oneintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-exactly-oneintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-exactly-onedec1args-1,AssertionError: fn:exactly-one(xs:decimal("-999999999999999999")): expected '-1000000000000000000' to equal '-999999999999999999'
fn-exactly-onedec1args-2,AssertionError: fn:exactly-one(xs:decimal("617375191608514839")): expected '617375191608514800' to equal '617375191608514839'
fn-exactly-onedec1args-3,AssertionError: fn:exactly-one(xs:decimal("999999999999999999")): expected '1000000000000000000' to equal '999999999999999999'
fn-exactly-onelng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-exactly-onelng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-exactly-onelng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-exactly-onenint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-exactly-onenint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-exactly-onepint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-exactly-onepint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-exactly-oneulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-exactly-oneulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-exactly-onenpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-exactly-onenpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-exactly-onenni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-exactly-onenni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-SeqExactlyOneFunc-6,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
K-SeqExactlyOneFunc-7,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
K-SeqExactlyOneFunc-8,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
fn-existsintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-existsintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-existsintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-existslng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-existslng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-existslng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-existsnint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-existsnint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-existspint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-existspint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-existsulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-existsulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-existsnpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-existsnpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-existsnni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-existsnni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
cbcl-exists-003,Error: XPST0003: Unable to parse XPath: "exists(text {(1 to 10)[. mod 2 = 0]})". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. exists(text [Error is around here]{(1 to 10)[. mod 2 = 0]})
filter-003,Error: XPST0081: The type element(emp) could not be found.
filter-006,Error: XPTY0004: signature of function passed to fn:filter is incompatible.
fn-filter-006,AssertionError: expected [Function] to throw an error
fn-filter-007,AssertionError: expected [Function] to throw an error
fn-filter-013,Error: No selector counterpart for: anyFunctionTest.
fn-filter-016,AssertionError: expected [Function] to throw an error
fn-filter-019,AssertionError: expected [Function] to throw an error
fn-filter-022,AssertionError: expected [Function] to throw an error
fn-floorintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-floorintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-floorintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-floordec1args-1,AssertionError: fn:floor(xs:decimal("-999999999999999999")): expected '-1000000000000000000' to equal '-999999999999999999'
fn-floordec1args-2,AssertionError: fn:floor(xs:decimal("617375191608514839")): expected '617375191608514800' to equal '617375191608514839'
fn-floordec1args-3,AssertionError: fn:floor(xs:decimal("999999999999999999")): expected '1000000000000000000' to equal '999999999999999999'
fn-floorlng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-floorlng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-floorlng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-floornint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-floornint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-floorpint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-floorpint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-floorulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-floorulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-floornpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-floornpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-floornni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-floornni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-floor-1,Error: XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
generate-id-000,Error: XPST0017: Function generate-id with arity of 1 not registered. No similar functions found.
generate-id-001,Error: XPST0017: Function generate-id with arity of 1 not registered. No similar functions found.
generate-id-002,Error: XPST0017: Function generate-id with arity of 1 not registered. No similar functions found.
generate-id-003,Error: XPST0017: Function generate-id with arity of 1 not registered. No similar functions found.
generate-id-004,Error: XPST0017: Function generate-id with arity of 1 not registered. No similar functions found.
generate-id-005,Error: XPST0017: Function generate-id with arity of 1 not registered. No similar functions found.
generate-id-006,Error: XPST0017: Function generate-id with arity of 1 not registered. No similar functions found.
generate-id-008,Error: XPST0017: Function generate-id with arity of 0 not registered. No similar functions found.
generate-id-009,Error: XPST0017: Function generate-id with arity of 0 not registered. No similar functions found.
generate-id-010,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
generate-id-012,Error: XPST0017: Function collection with arity of 0 not registered. No similar functions found.
generate-id-013,Error: XPST0017: Function collection with arity of 0 not registered. No similar functions found.
generate-id-014,SyntaxError: Expected "!", "!=", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "(" found.
generate-id-015,SyntaxError: Expected "!", "!=", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "(" found.
generate-id-016,SyntaxError: Expected "!", "!=", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "(" found.
generate-id-017,SyntaxError: Expected "!", "!=", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "(" found.
generate-id-018,Error: XPST0017: Function generate-id with arity of 1 not registered. No similar functions found.
generate-id-019,Error: XPST0017: Function generate-id with arity of 0 not registered. No similar functions found.
generate-id-020,Error: XPST0003: Unable to parse XPath: "          let $nodes := (<a lang='de' xml:lang='de'>Insel</a>, <a lang='en' xml:lang='en'>Island</a>)          let $ids := for $n in $nodes return generate-id($n)          return count($nodes) = count(distinct-values($ids))        ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.           let $nodes := (<a lang='de' xml:lang='de'>Insel</a>, <a lang='en' xml:lang='en'>Island</a>)          [Error is around here]let $ids := for $n in $nodes return generate-id($n)          return count($nodes) = count(distinct-values($ids))
generate-id-021,Error: XPST0003: Unable to parse XPath: "          let $nodes := (<a lang='de' xml:lang='de'>Insel</a>, <a lang='en' xml:lang='en'>Island</a>)          let $ids := for $n in $nodes return generate-id($n)          return every $id in $ids satisfies matches($id, '^[A-Za-z][A-Za-z0-9]*$')        ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.           let $nodes := (<a lang='de' xml:lang='de'>Insel</a>, <a lang='en' xml:lang='en'>Island</a>)          [Error is around here]let $ids := for $n in $nodes return generate-id($n)          return every $id in $ids satisfies matches($id, '^[A-Za-z][A-Za-z0-9]*$')
generate-id-022,Error: XPST0003: Unable to parse XPath: "          let $nodes := (text{''}, text{''}, text{''}, text{''})          let $ids := for $n in $nodes return generate-id($n)          return count($nodes) = count(distinct-values($ids))        ". Expected "!", "!=", "#", "(", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found.           let $nodes := (text[Error is around here]{''}, text{''}, text{''}, text{''})          let $ids := for $n in $nodes return generate-id($n)          return count($nodes) = count(distinct-values($ids))
generate-id-023,Error: XPST0003: Unable to parse XPath: "          let $nodes := (text{''}, text{''}, text{''}, text{''})          let $ids := for $n in $nodes return generate-id($n)          return every $id in $ids satisfies matches($id, '^[A-Za-z][A-Za-z0-9]*$')        ". Expected "!", "!=", "#", "(", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found.           let $nodes := (text[Error is around here]{''}, text{''}, text{''}, text{''})          let $ids := for $n in $nodes return generate-id($n)          return every $id in $ids satisfies matches($id, '^[A-Za-z][A-Za-z0-9]*$')
generate-id-901,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0017: Function generate-id with arity of 0 not registered. No similar functions found.'
generate-id-902,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function generate-id with arity of 1 not registered. No similar functions found.'
generate-id-903,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function generate-id with arity of 1 not registered. No similar functions found.'
generate-id-904,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function generate-id with arity of 1 not registered. No similar functions found.'
generate-id-905,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function generate-id with arity of 1 not registered. No similar functions found.'
fn-hours-from-dateTime-3,Error: XPST0017: Function fn:adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
fn-hours-from-time-4,Error: XPST0017: Function fn:adjust-time-to-timezone with arity of 2 not registered. No similar functions found.
fn-id-2,AssertionError: expected [Function] to throw an error
fn-id-4,SyntaxError: Expected "!", "!=", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "(" found.
K2-SeqIDFunc-3,AssertionError: expected [Function] to throw an error
K2-SeqIDFunc-4,SyntaxError: Expected "!", "!=", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "(" found.
K2-SeqIDFunc-5,SyntaxError: Expected "!", "!=", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "(" found.
K2-SeqIDFunc-6,SyntaxError: Expected "!", "!=", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "(" found.
K2-SeqIDFunc-7,SyntaxError: Expected "!", "!=", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "(" found.
K2-SeqIDFunc-8,AssertionError: expected [Function] to throw an error
K2-SeqIDFunc-9,Error: XPST0003: Unable to parse XPath: "let $i := document {<e> <e/> <e/> <e/> <e/> <e/> <e/> <e/> <b xml:id="foo"/> <e/> </e>} return id("foo", $i)/name()". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found. let $i := document [Error is around here]{<e> <e/> <e/> <e/> <e/> <e/> <e/> <e/> <b xml:id="foo"/> <e/> </e>} return id("foo", $i)/name()
K2-SeqIDFunc-10,AssertionError: for $i in id(("short", "positiveInteger")) return $i/@name/string(): expected '' to equal 'positiveInteger short'
K2-SeqIDFunc-11,AssertionError: id(("short"), //xs:element/@name[. = "positiveInteger"])/@name: expected '' to equal 'short'
K2-SeqIDFunc-12,AssertionError: id((".", "short", "123"), //xs:element/@name[. = "positiveInteger"])/@name: expected '' to equal 'short'
K2-SeqIDFunc-13,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
K2-SeqIDFunc-14,AssertionError: for $i in id(("short positiveInteger")) return $i/@name/string(): expected '' to equal 'positiveInteger short'
K2-SeqIDFunc-15,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
cbcl-id-001,Error: XPST0003: Unable to parse XPath: "       	declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then () else 'id1', 'id2' };        	let $doc := document { <root /> } return fn:empty( fn:id( local:generate(0), $doc) )       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found.        	declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then () else 'id1', 'id2' };        	let $doc := document [Error is around here]{ <root /> } return fn:empty( fn:id( local:generate(0), $doc) )
cbcl-id-002,AssertionError: Expected executing the XPath "       	let $doc := document { <root /> } return fn:empty( fn:id( (), $doc) )       " to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "       	let $doc := document { <root /> } return fn:empty( fn:id( (), $doc) )       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found.        	let $doc := document [Error is around here]{ <root /> } return fn:empty( fn:id( (), $doc) )       , AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "\n      \tlet $doc := document { <root /> } return fn:empty( fn:id( (), $doc) )\n      ".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found.\n\n      \tlet $doc := document [Error is around here]{ <root /> } return fn:empty( fn:id( (), $doc) )\n      '.
cbcl-id-003,Error: XPST0003: Unable to parse XPath: "       	declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then () else 'id1', 'id2' };        	let $doc := document { <root /> } return fn:empty( $doc/fn:id( local:generate(0)) )       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found.        	declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then () else 'id1', 'id2' };        	let $doc := document [Error is around here]{ <root /> } return fn:empty( $doc/fn:id( local:generate(0)) )
fn-idref-2,AssertionError: expected [Function] to throw an error
fn-idref-4,SyntaxError: Expected "!", "!=", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "(" found.
K2-SeqIDREFFunc-3,AssertionError: expected [Function] to throw an error
cbcl-idref-001,Error: XPST0003: Unable to parse XPath: "       	declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then () else 'id1', 'id2' };        	let $doc := document { <root /> } return fn:empty( fn:idref( local:generate(0), $doc) )       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found.        	declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then () else 'id1', 'id2' };        	let $doc := document [Error is around here]{ <root /> } return fn:empty( fn:idref( local:generate(0), $doc) )
cbcl-idref-002,AssertionError: Expected executing the XPath "       	let $doc := document { <root /> } return fn:empty( fn:idref( (), $doc) )       " to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "       	let $doc := document { <root /> } return fn:empty( fn:idref( (), $doc) )       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found.        	let $doc := document [Error is around here]{ <root /> } return fn:empty( fn:idref( (), $doc) )       , AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "\n      \tlet $doc := document { <root /> } return fn:empty( fn:idref( (), $doc) )\n      ".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found.\n\n      \tlet $doc := document [Error is around here]{ <root /> } return fn:empty( fn:idref( (), $doc) )\n      '.
cbcl-idref-003,Error: XPST0003: Unable to parse XPath: "       	declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then () else 'id1', 'id2' };        	let $doc := document { <root /> } return fn:empty( $doc/fn:idref( local:generate(0)) )       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found.        	declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then () else 'id1', 'id2' };        	let $doc := document [Error is around here]{ <root /> } return fn:empty( $doc/fn:idref( local:generate(0)) )
fn-implicit-timezone-15,Error: Not implemented: adding durations to xs:time
fn-implicit-timezone-16,Error: Not implemented: subtracting durations from xs:time
fn-implicit-timezone-17,Error: Not implemented: subtracting durations from xs:date
fn-implicit-timezone-18,Error: Not implemented: adding durations to xs:date
fn-implicit-timezone-19,Error: Not implemented: subtracting durations from xs:dateTime
fn-implicit-timezone-20,Error: Not implemented: adding durations to xs:dateTime
fn-implicit-timezone-21,Error: XPST0017: Function fn:adjust-date-to-timezone with arity of 2 not registered. No similar functions found.
fn-implicit-timezone-22,Error: XPST0017: Function fn:adjust-time-to-timezone with arity of 2 not registered. No similar functions found.
fn-implicit-timezone-23,Error: XPST0017: Function fn:adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
fn-innermost-008,AssertionError: expected [Function] to throw an error
fn-innermost-010,AssertionError: expected [Function] to throw an error
fn-innermost-055,Error: XPST0003: Unable to parse XPath: "let $in := for $x in //* order by local-name($x) return $x             return deep-equal(fn:innermost($in)/local-name(), fn:innermost(//*)/local-name())". Expected " ", "!", "!=", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. let $in := for $x in //* [Error is around here]order by local-name($x) return $x             return deep-equal(fn:innermost($in)/local-name(), fn:innermost(//*)/local-name())
fn-innermost-056,Error: XPST0003: Unable to parse XPath: "let $in := for $x in //* order by local-name($x) return $x             return deep-equal(fn:innermost(($in, $in))/local-name(), fn:innermost(//*)/local-name())". Expected " ", "!", "!=", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. let $in := for $x in //* [Error is around here]order by local-name($x) return $x             return deep-equal(fn:innermost(($in, $in))/local-name(), fn:innermost(//*)/local-name())
K-SeqInsertBeforeFunc-16,AssertionError: Expected executing the XPath "count(insert-before((error(), 1), 1, (1, "two", 3))) > 1" to resolve to one of the expected results, but got Error: XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?, AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'.
K-SeqInsertBeforeFunc-17,Error: XPST0003: Unable to parse XPath: "(insert-before((1, current-time(), 3), 1, (4, 5, 6))[last()] treat as xs:integer) eq 3". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found. (insert-before((1, current-time(), 3), 1, (4, 5, 6))[last()] [Error is around here]treat as xs:integer) eq 3
K-SeqInsertBeforeFunc-18,Error: XPST0003: Unable to parse XPath: "(insert-before((1, current-time(), 3), 10, (4, 5, 6))[last()] treat as xs:integer) eq 6". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found. (insert-before((1, current-time(), 3), 10, (4, 5, 6))[last()] [Error is around here]treat as xs:integer) eq 6
K-SeqInsertBeforeFunc-19,Error: XPST0003: Unable to parse XPath: "(insert-before((1, current-time(), 3), 10, (4, 5, 6))[last() - 3] treat as xs:integer) eq 3". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found. (insert-before((1, current-time(), 3), 10, (4, 5, 6))[last() - 3] [Error is around here]treat as xs:integer) eq 3
K-SeqInsertBeforeFunc-20,Error: XPST0003: Unable to parse XPath: "(insert-before((1, current-time(), 3), 10, ())[last()] treat as xs:integer) eq 3". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found. (insert-before((1, current-time(), 3), 10, ())[last()] [Error is around here]treat as xs:integer) eq 3
K-ContextLastFunc-5,Error: XPST0003: Unable to parse XPath: "(1, 2, 3, current-time())[last() - 1] treat as xs:integer eq 3". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "t" found. (1, 2, 3, current-time())[last() - 1] [Error is around here]treat as xs:integer eq 3
K-ContextLastFunc-24,Error: XPST0003: Unable to parse XPath: "(1, 2, 3, 4, current-time(), 4, 5, 6)[last() - 2] treat as xs:integer eq 4". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "t" found. (1, 2, 3, 4, current-time(), 4, 5, 6)[last() - 2] [Error is around here]treat as xs:integer eq 4
K-ContextLastFunc-25,Error: XPST0003: Unable to parse XPath: "(1, 2, 3, 4, current-time(), 4, 5, 6)[last() - 1] treat as xs:integer eq 5". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "t" found. (1, 2, 3, 4, current-time(), 4, 5, 6)[last() - 1] [Error is around here]treat as xs:integer eq 5
K-ContextLastFunc-26,Error: XPST0003: Unable to parse XPath: "(1, 2, 3, 4, current-time(), 4, 5, 6)[last()] treat as xs:integer eq 6". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "t" found. (1, 2, 3, 4, current-time(), 4, 5, 6)[last()] [Error is around here]treat as xs:integer eq 6
K-ContextLastFunc-27,Error: XPST0003: Unable to parse XPath: "(1, 2, 3, 4, current-time(), 4, 5, 6)[last() - 0] treat as xs:integer eq 6". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "t" found. (1, 2, 3, 4, current-time(), 4, 5, 6)[last() - 0] [Error is around here]treat as xs:integer eq 6
cbcl-last-in-sequence-004,Error: XPST0003: Unable to parse XPath: "       	declare function local:generate($arg as xs:integer?) as xs:integer* { if ($arg = 0) then ( 1, 2, 3 ) else ( $arg ) };        	( local:generate(()), for $x at $p in local:generate(0) return $p + $x)[last()]       ". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.        	declare function local:generate($arg as xs:integer?) as xs:integer* { if ($arg = 0) then ( 1, 2, 3 ) else ( $arg ) };        	( local:generate(()), for $x [Error is around here]at $p in local:generate(0) return $p + $x)[last()]
cbcl-last-in-sequence-005,Error: XPST0003: Unable to parse XPath: "       	declare function local:generate($arg as xs:integer?) as xs:integer? { if ($arg = 0) then 1 else $arg };        	( local:generate(()), for $x at $p in local:generate(0) return $p + $x)[last()]       ". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.        	declare function local:generate($arg as xs:integer?) as xs:integer? { if ($arg = 0) then 1 else $arg };        	( local:generate(()), for $x [Error is around here]at $p in local:generate(0) return $p + $x)[last()]
LocalNameFromQNameFunc015,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
LocalNameFromQNameFunc015a,AssertionError: expected [Function] to throw error including 'XPTY0117' but got 'Casting to xs:QName is not implemented.'
LocalNameFromQNameFunc018,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
fn-lower-case-18,Error: XPST0017: Function fn:string-to-codepoints with arity of 1 not registered. No similar functions found.
fn-lower-case-19,Error: XPST0017: Function fn:string-to-codepoints with arity of 1 not registered. No similar functions found.
fn-lower-case-20,Error: XPST0017: Function fn:string-to-codepoints with arity of 1 not registered. No similar functions found.
fn-maxintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxlng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxlng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxlng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxpint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxpint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxintg2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxintg2args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxintg2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxintg2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxintg2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxlng2args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxlng2args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxlng2args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxlng2args-4,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxlng2args-5,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnint2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnint2args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnint2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnint2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnint2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxpint2args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxpint2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxpint2args-4,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxpint2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxulng2args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxulng2args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxulng2args-4,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxulng2args-5,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnpi2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnpi2args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnpi2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnpi2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnpi2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnni2args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnni2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnni2args-4,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnni2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-SeqMAXFunc-21,AssertionError: expected [Function] to throw an error
K-SeqMAXFunc-22,AssertionError: expected [Function] to throw an error
K-SeqMAXFunc-30,AssertionError: Expected XPath max((3, xs:float("NaN"))) instance of xs:float to resolve to true: expected false to be true
K-SeqMAXFunc-38,AssertionError: expected [Function] to throw an error
fn-max-5,AssertionError: max(for $x in 1 to 10 return xs:dayTimeDuration(concat("PT",$x,"H"))): expected 'PT9H' to equal 'PT10H'
fn-max-7,AssertionError: max(for $x in 1 to 10 return xs:yearMonthDuration(concat("P",$x,"M"))): expected 'P9M' to equal 'P10M'
fn-max-8,AssertionError: Expected executing the XPath "max((xs:yearMonthDuration("P1Y"), xs:dayTimeDuration("P1D")))" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw an error, AssertionError: expected [Function] to throw an error.
fn-max-9,AssertionError: Expected executing the XPath "max(xs:duration("P1Y1M1D"))" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw an error, AssertionError: expected [Function] to throw an error.
fn-max-10,Error: XPST0003: Unable to parse XPath: "for $p in 1 to 4 let $x := (xs:integer(1), xs:decimal(2), xs:float(3), xs:double(4))[position() le $p] return typeswitch (max($x)) case xs:integer return "integer" case xs:decimal return "decimal" case xs:float return "float" case xs:double return "double" default return error()". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "union", "|", or "||" but "l" found. for $p in 1 to 4 [Error is around here]let $x := (xs:integer(1), xs:decimal(2), xs:float(3), xs:double(4))[position() le $p] return typeswitch (max($x)) case xs:integer return "integer" case xs:decimal return "decimal" case xs:float return "float" case xs:double return "double" default return error()
fn-max-18,AssertionError: Expected XPath max((xs:token("zither"), xs:anyURI("http://b.com"))) to resolve to something of type xs:token: expected false to be true
fn-max-19,Error: Atomizing array(*) is not implemented.
cbcl-max-007,AssertionError:        	declare function local:f($x as xs:integer) {        		if ($x = 2) then xs:dayTimeDuration("P1D") else xs:dayTimeDuration("PT3S")        	};        	max(for $x in (1,2,3) return local:f($x))       : expected 'PT3S' to equal 'P1D'
cbcl-max-008,AssertionError: expected [Function] to throw an error
cbcl-max-016,AssertionError: expected [Function] to throw an error
cbcl-max-017,AssertionError: expected [Function] to throw an error
fn-minintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minlng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minlng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minlng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minpint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minpint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minintg2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minintg2args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minintg2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minintg2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minintg2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minlng2args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minlng2args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minlng2args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minlng2args-4,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minlng2args-5,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnint2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnint2args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnint2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnint2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnint2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minpint2args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minpint2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minpint2args-4,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minpint2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minulng2args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minulng2args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minulng2args-4,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minulng2args-5,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnpi2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnpi2args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnpi2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnpi2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnpi2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnni2args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnni2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnni2args-4,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnni2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-SeqMINFunc-21,AssertionError: expected [Function] to throw an error
K-SeqMINFunc-22,AssertionError: expected [Function] to throw an error
K-SeqMINFunc-30,AssertionError: Expected XPath min((3, xs:float("NaN"))) instance of xs:float to resolve to true: expected false to be true
K-SeqMINFunc-38,AssertionError: expected [Function] to throw an error
fn-min-5,AssertionError: min(for $x in 1 to 10 return xs:dayTimeDuration(concat("PT",$x,"H"))): expected 'PT10H' to equal 'PT1H'
fn-min-7,AssertionError: min(for $x in 1 to 10 return xs:yearMonthDuration(concat("P",$x,"M"))): expected 'P10M' to equal 'P1M'
fn-min-8,AssertionError: Expected executing the XPath "min((xs:yearMonthDuration("P1Y"), xs:dayTimeDuration("P1D")))" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw an error, AssertionError: expected [Function] to throw an error.
fn-min-9,AssertionError: Expected executing the XPath "min(xs:duration("P1Y1M1D"))" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw an error, AssertionError: expected [Function] to throw an error.
fn-min-10,Error: XPST0003: Unable to parse XPath: "for $p in 1 to 4 let $x := (xs:integer(4), xs:decimal(3), xs:float(2), xs:double(1))[position() le $p] return typeswitch (min($x)) case xs:integer return "integer" case xs:decimal return "decimal" case xs:float return "float" case xs:double return "double" default return error()". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "union", "|", or "||" but "l" found. for $p in 1 to 4 [Error is around here]let $x := (xs:integer(4), xs:decimal(3), xs:float(2), xs:double(1))[position() le $p] return typeswitch (min($x)) case xs:integer return "integer" case xs:decimal return "decimal" case xs:float return "float" case xs:double return "double" default return error()
fn-min-18,AssertionError: Expected XPath min((xs:token("http"), xs:anyURI("http://b.com"))) to resolve to something of type xs:token: expected false to be true
fn-min-19,Error: Atomizing array(*) is not implemented.
cbcl-min-007,AssertionError:        	declare function local:f($x as xs:integer) { if ($x = 2) then xs:dayTimeDuration("P1D") else xs:dayTimeDuration("PT3S") };        	min(for $x in (1,2,3) return local:f($x))       : expected 'P1DT' to equal 'PT3S'
cbcl-min-008,AssertionError: expected [Function] to throw an error
cbcl-min-016,AssertionError: expected [Function] to throw an error
cbcl-min-017,AssertionError: expected [Function] to throw an error
fn-month-from-dateTime-3,Error: XPST0017: Function fn:adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
fn-name-16,AssertionError: Expected executing the XPath "for $h in (./works/employee[2]) return fn:count(fn:name($h/self::div))" to resolve to one of the expected results, but got AssertionError: for $h in (./works/employee[2]) return fn:count(fn:name($h/self::div)): expected '0' to equal '1', AssertionError: expected [Function] to throw an error.
K-NameFunc-3,AssertionError: Expected XPath name(()) eq "" to resolve to true: expected false to be true
NamespaceURIFromQNameFunc015,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
NamespaceURIFromQNameFunc015a,AssertionError: expected [Function] to throw error including 'XPTY0117' but got 'Casting to xs:QName is not implemented.'
NamespaceURIFromQNameFunc018,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
K2-NamespaceURIFromQNameFunc-1,Error: Casting to xs:QName is not implemented.
K2-NamespaceURIFromQNameFunc-2,Error: XPST0003: Unable to parse XPath: "         <e xmlns="http://example.com/"> {namespace-uri-from-QName(node-name(element anElement{"text"}))} </e>/string()       ". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "a" found.          <e xmlns="http://example.com/"> {namespace-uri-from-QName(node-name(element [Error is around here]anElement{"text"}))} </e>/string()
K2-NamespaceURIFromQNameFunc-3,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-NamespaceURIFromQNameFunc-4,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
fn-node-name-8,Error: XPST0003: Unable to parse XPath: "fn:local-name-from-QName(fn:node-name(element elementName {}))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found. fn:local-name-from-QName(fn:node-name(element [Error is around here]elementName {}))
fn-node-name-9,Error: XPST0003: Unable to parse XPath: "fn:count(fn:namespace-uri-from-QName(fn:node-name(element elementName {})))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found. fn:count(fn:namespace-uri-from-QName(fn:node-name(element [Error is around here]elementName {})))
fn-node-name-10,Error: XPST0003: Unable to parse XPath: "fn:local-name-from-QName(fn:node-name(element elementName { element achild {"some text"}}))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found. fn:local-name-from-QName(fn:node-name(element [Error is around here]elementName { element achild {"some text"}}))
fn-node-name-11,Error: XPST0003: Unable to parse XPath: "fn:local-name-from-QName(fn:node-name(attribute attributeName {""}))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "a" found. fn:local-name-from-QName(fn:node-name(attribute [Error is around here]attributeName {""}))
fn-node-name-12,Error: XPST0003: Unable to parse XPath: "fn:local-name-from-QName(fn:node-name(attribute attributeName {"an attribute value"}))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "a" found. fn:local-name-from-QName(fn:node-name(attribute [Error is around here]attributeName {"an attribute value"}))
fn-node-name-13,Error: XPST0003: Unable to parse XPath: "fn:count(fn:namespace-uri-from-QName(fn:node-name(attribute attributeName {"an attribute value"})))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "a" found. fn:count(fn:namespace-uri-from-QName(fn:node-name(attribute [Error is around here]attributeName {"an attribute value"})))
fn-node-name-14,Error: XPST0003: Unable to parse XPath: "fn:count(fn:local-name-from-QName(fn:node-name(document {""})))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. fn:count(fn:local-name-from-QName(fn:node-name(document [Error is around here]{""})))
fn-node-name-15,Error: XPST0003: Unable to parse XPath: "fn:count(fn:namespace-uri-from-QName(fn:node-name(document {""})))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. fn:count(fn:namespace-uri-from-QName(fn:node-name(document [Error is around here]{""})))
fn-node-name-16,Error: XPST0003: Unable to parse XPath: "fn:count(fn:local-name-from-QName(fn:node-name(document {"<element1> text </element1>"})))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. fn:count(fn:local-name-from-QName(fn:node-name(document [Error is around here]{"<element1> text </element1>"})))
fn-node-name-17,Error: XPST0003: Unable to parse XPath: "fn:count(fn:namespace-uri-from-QName(fn:node-name(document {"<element1> text </element1>"})))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. fn:count(fn:namespace-uri-from-QName(fn:node-name(document [Error is around here]{"<element1> text </element1>"})))
fn-node-name-18,Error: XPST0003: Unable to parse XPath: "fn:count(fn:local-name-from-QName(fn:node-name(text {""})))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. fn:count(fn:local-name-from-QName(fn:node-name(text [Error is around here]{""})))
fn-node-name-19,Error: XPST0003: Unable to parse XPath: "fn:count(fn:namespace-uri-from-QName(fn:node-name(text {""})))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. fn:count(fn:namespace-uri-from-QName(fn:node-name(text [Error is around here]{""})))
fn-node-name-20,Error: XPST0003: Unable to parse XPath: "fn:count(fn:local-name-from-QName(fn:node-name(text {"a text value"})))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. fn:count(fn:local-name-from-QName(fn:node-name(text [Error is around here]{"a text value"})))
fn-node-name-21,Error: XPST0003: Unable to parse XPath: "fn:count(fn:namespace-uri-from-QName(fn:node-name(text {"a text value"})))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. fn:count(fn:namespace-uri-from-QName(fn:node-name(text [Error is around here]{"a text value"})))
fn-node-name-22,Error: XPST0003: Unable to parse XPath: "fn:local-name-from-QName(fn:node-name(processing-instruction piName {"Processing Instruction content"}))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "p" found. fn:local-name-from-QName(fn:node-name(processing-instruction [Error is around here]piName {"Processing Instruction content"}))
fn-node-name-23,Error: XPST0003: Unable to parse XPath: "fn:count(fn:namespace-uri-from-QName(fn:node-name(processing-instruction piName {"Processing Instruction content"})))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "p" found. fn:count(fn:namespace-uri-from-QName(fn:node-name(processing-instruction [Error is around here]piName {"Processing Instruction content"})))
fn-node-name-24,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'XPST0003: Unable to parse XPath: "fn:node-name(processing-instruction piName {"Processing Instruction content"},"A Second Argument")".\nExpected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "p" found.\nfn:node-name(processing-instruction [Error is around here]piName {"Processing Instruction content"},"A Second Argument")'
fn-node-name-28,Error: XPST0003: Unable to parse XPath: "namespace{"foo"}{"http://example.com/foo"}/node-name() = QName("", "foo")". Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "{" found. namespace[Error is around here]{"foo"}{"http://example.com/foo"}/node-name() = QName("", "foo")
fn-node-name-30,AssertionError: expected [Function] to throw an error
fn-node-name-31,AssertionError: expected [Function] to throw an error
K-NodeNameFunc-1,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'XPDY0002: The function which was called depends on dynamic context, which is absent.'
cbcl-node-name-001,Error: XPST0003: Unable to parse XPath: "empty(node-name( comment { "comments have no name " } ) )". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. empty(node-name( comment [Error is around here]{ "comments have no name " } ) )
fn-notintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-notintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-notintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-notlng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-notlng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-notlng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-notnint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-notnint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-notpint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-notpint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-notulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-notulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-notnpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-notnpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-notnni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-notnni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-NotFunc-10,Error: XPST0003: Unable to parse XPath: "not(fn:boolean((1, 2, 3, current-time())[1] treat as xs:integer)) eq false()". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found. not(fn:boolean((1, 2, 3, current-time())[1] [Error is around here]treat as xs:integer)) eq false()
fn-numberint1args-1,AssertionError: fn:number(xs:int("-2147483648")): expected '-2147483648' to equal '-2.147483648E9'
fn-numberint1args-2,AssertionError: fn:number(xs:int("-1873914410")): expected '-1873914410' to equal '-1.87391441E9'
fn-numberint1args-3,AssertionError: fn:number(xs:int("2147483647")): expected '2147483647' to equal '2.147483647E9'
fn-numberintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-numberintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-numberintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-numberdec1args-1,AssertionError: fn:number(xs:decimal("-999999999999999999")): expected '-1000000000000000000' to equal '-1.0E18'
fn-numberdec1args-3,AssertionError: fn:number(xs:decimal("999999999999999999")): expected '1000000000000000000' to equal '1.0E18'
fn-numberflt1args-1,AssertionError: Expected XPath fn:number(xs:float("-3.4028235E38")) eq -3.4028234663852885E38 to resolve to true: expected false to be true
fn-numberflt1args-3,AssertionError: Expected executing the XPath "fn:number(xs:float("3.4028235E38"))" to resolve to one of the expected results, but got AssertionError: fn:number(xs:float("3.4028235E38")): expected '3.4028235E38' to equal '3.4028234663852885E38', AssertionError: fn:number(xs:float("3.4028235E38")): expected '3.4028235E38' to equal '3.402823466385289E38', AssertionError: fn:number(xs:float("3.4028235E38")): expected '3.4028235E38' to equal '3.4028234663852886E38'.
fn-numberlng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-numberlng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-numberlng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-numbernint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-numbernint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-numberpint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-numberpint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-numberulng1args-2,AssertionError: Expected executing the XPath "fn:number(xs:unsignedLong("130747108607674654"))" to resolve to one of the expected results, but got Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers..
fn-numberulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-numbernpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-numbernpi1args-2,AssertionError: Expected executing the XPath "fn:number(xs:nonPositiveInteger("-475688437271870490"))" to resolve to one of the expected results, but got Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers..
fn-numbernni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-numbernni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-one-or-moreintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-one-or-moreintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-one-or-moreintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-one-or-moredec1args-1,AssertionError: fn:one-or-more(xs:decimal("-999999999999999999")): expected '-1000000000000000000' to equal '-999999999999999999'
fn-one-or-moredec1args-2,AssertionError: fn:one-or-more(xs:decimal("617375191608514839")): expected '617375191608514800' to equal '617375191608514839'
fn-one-or-moredec1args-3,AssertionError: fn:one-or-more(xs:decimal("999999999999999999")): expected '1000000000000000000' to equal '999999999999999999'
fn-one-or-morelng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-one-or-morelng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-one-or-morelng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-one-or-morenint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-one-or-morenint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-one-or-morepint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-one-or-morepint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-one-or-moreulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-one-or-moreulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-one-or-morenpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-one-or-morenpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-one-or-morenni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-one-or-morenni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-SeqOneOrMoreFunc-7,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
K2-SeqOneOrMoreFunc-1,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
fn-outermost-008,AssertionError: expected [Function] to throw an error
fn-outermost-010,AssertionError: expected [Function] to throw an error
fn-outermost-055,Error: XPST0003: Unable to parse XPath: "let $in := for $x in //* order by local-name($x) return $x             return deep-equal(fn:outermost($in)/local-name(), fn:outermost(//*)/local-name())". Expected " ", "!", "!=", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. let $in := for $x in //* [Error is around here]order by local-name($x) return $x             return deep-equal(fn:outermost($in)/local-name(), fn:outermost(//*)/local-name())
fn-outermost-056,Error: XPST0003: Unable to parse XPath: "let $in := for $x in //* order by local-name($x) return $x             return deep-equal(fn:outermost(($in, $in))/local-name(), fn:outermost(//*)/local-name())". Expected " ", "!", "!=", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. let $in := for $x in //* [Error is around here]order by local-name($x) return $x             return deep-equal(fn:outermost(($in, $in))/local-name(), fn:outermost(//*)/local-name())
fn-parse-json-002,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?
fn-parse-json-011,Error: No selector counterpart for: anyArrayTest.
fn-parse-json-012,Error: No selector counterpart for: anyArrayTest.
fn-parse-json-013,Error: No selector counterpart for: anyArrayTest.
fn-parse-json-014,Error: No selector counterpart for: anyArrayTest.
fn-parse-json-015,Error: No selector counterpart for: anyArrayTest.
fn-parse-json-016,Error: No selector counterpart for: anyArrayTest.
fn-parse-json-017,Error: No selector counterpart for: anyArrayTest.
fn-parse-json-018,Error: No selector counterpart for: anyArrayTest.
fn-parse-json-019,Error: No selector counterpart for: typedArrayTest.
fn-parse-json-020,Error: No selector counterpart for: anyArrayTest.
fn-parse-json-021,Error: XPST0003: Unable to parse XPath: "let $result := (parse-json('[{"x":12,"y":5}, {"x":13,"y":6}]')) return $result?2?y = 6". Expected "$", "(", "*", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "2" found. let $result := (parse-json('[{"x":12,"y":5}, {"x":13,"y":6}]')) return $result?[Error is around here]2?y = 6
fn-parse-json-022,Error: XPST0003: Unable to parse XPath: "let $result := (parse-json('{"x":[12,3], "y":[14,9]}')) return $result?y?2 = 9". Expected "$", "(", "*", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "2" found. let $result := (parse-json('{"x":[12,3], "y":[14,9]}')) return $result?y?[Error is around here]2 = 9
fn-parse-json-023,Error: XPST0003: Unable to parse XPath: "let $result := (parse-json('[0.123]')) return $result?1 = 0.123e0". Expected "$", "(", "*", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "1" found. let $result := (parse-json('[0.123]')) return $result?[Error is around here]1 = 0.123e0
fn-parse-json-024,Error: XPST0003: Unable to parse XPath: "let $result := (parse-json('[-0.123]')) return $result?1 = -0.123e0". Expected "$", "(", "*", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "1" found. let $result := (parse-json('[-0.123]')) return $result?[Error is around here]1 = -0.123e0
fn-parse-json-025,Error: XPST0003: Unable to parse XPath: "let $result := (parse-json('[-0.123e2]')) return $result?1 = -0.123e2". Expected "$", "(", "*", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "1" found. let $result := (parse-json('[-0.123e2]')) return $result?[Error is around here]1 = -0.123e2
fn-parse-json-026,Error: XPST0003: Unable to parse XPath: "let $result := (parse-json('[-0.123e+2]')) return $result?1 = -0.123e+2". Expected "$", "(", "*", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "1" found. let $result := (parse-json('[-0.123e+2]')) return $result?[Error is around here]1 = -0.123e+2
fn-parse-json-027,Error: XPST0003: Unable to parse XPath: "let $result := (parse-json('[-0.123e-2]')) return $result?1 = -0.123e-2". Expected "$", "(", "*", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "1" found. let $result := (parse-json('[-0.123e-2]')) return $result?[Error is around here]1 = -0.123e-2
fn-parse-json-028,Error: XPST0003: Unable to parse XPath: "let $result := (parse-json('["\\"]')) return $result?1 = "\"". Expected "$", "(", "*", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "1" found. let $result := (parse-json('["\\"]')) return $result?[Error is around here]1 = "\"
fn-parse-json-029,Error: XPST0003: Unable to parse XPath: "let $result := (parse-json('["\""]')) return $result?1 = '"'". Expected "$", "(", "*", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "1" found. let $result := (parse-json('["\""]')) return $result?[Error is around here]1 = '"'
fn-parse-json-030,Error: XPST0003: Unable to parse XPath: "let $result := (parse-json('["\r"]')) return $result?1 = codepoints-to-string(13)". Expected "$", "(", "*", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "1" found. let $result := (parse-json('["\r"]')) return $result?[Error is around here]1 = codepoints-to-string(13)
fn-parse-json-031,Error: XPST0003: Unable to parse XPath: "let $result := (parse-json('["\n"]')) return $result?1 = codepoints-to-string(10)". Expected "$", "(", "*", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "1" found. let $result := (parse-json('["\n"]')) return $result?[Error is around here]1 = codepoints-to-string(10)
fn-parse-json-032,Error: XPST0003: Unable to parse XPath: "let $result := (parse-json('["\/"]')) return $result?1 = '/'". Expected "$", "(", "*", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "1" found. let $result := (parse-json('["\/"]')) return $result?[Error is around here]1 = '/'
fn-parse-json-033,Error: XPST0003: Unable to parse XPath: "let $result := (parse-json('["aa\u0030aa"]')) return $result?1 = 'aa0aa'". Expected "$", "(", "*", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "1" found. let $result := (parse-json('["aa\u0030aa"]')) return $result?[Error is around here]1 = 'aa0aa'
fn-parse-json-034,Error: XPST0003: Unable to parse XPath: "let $result := (parse-json('["\uD834\udD1E"]')) return $result?1 = codepoints-to-string(119070)". Expected "$", "(", "*", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "1" found. let $result := (parse-json('["\uD834\udD1E"]')) return $result?[Error is around here]1 = codepoints-to-string(119070)
fn-parse-json-035,Error: XPST0003: Unable to parse XPath: "let $result := (parse-json('["\r"]', map{'escape':true()})) return $result?1 = '\r'". Expected "$", "(", "*", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "1" found. let $result := (parse-json('["\r"]', map{'escape':true()})) return $result?[Error is around here]1 = '\r'
fn-parse-json-036,Error: XPST0003: Unable to parse XPath: "let $result := (parse-json('["\r"]', map{'escape':false()})) return $result?1 = codepoints-to-string(13)". Expected "$", "(", "*", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "1" found. let $result := (parse-json('["\r"]', map{'escape':false()})) return $result?[Error is around here]1 = codepoints-to-string(13)
fn-parse-json-037,Error: XPST0003: Unable to parse XPath: "let $result := (parse-json('["\u0000"]', map{'escape':true()})) return $result?1 = '\u0000'". Expected "$", "(", "*", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "1" found. let $result := (parse-json('["\u0000"]', map{'escape':true()})) return $result?[Error is around here]1 = '\u0000'
fn-parse-json-042,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?
fn-parse-json-050,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?
fn-parse-json-051,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?
fn-parse-json-052,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?
fn-parse-json-053,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
fn-parse-json-054,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
fn-parse-json-055,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
fn-parse-json-056,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
fn-parse-json-057,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
fn-parse-json-058,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
fn-parse-json-059,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?
fn-parse-json-060,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?
fn-parse-json-061,AssertionError: Expected executing the XPath "parse-json('"\b"', map{'fallback':lower-case#1})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?, Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?.
fn-parse-json-062,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?
fn-parse-json-063,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?
fn-parse-json-064,AssertionError: Expected executing the XPath "parse-json('{"\b":""}', map{'fallback':lower-case#1}) => map:keys()" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?, Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?.
fn-parse-json-065,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?
fn-parse-json-066,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?
fn-parse-json-101,Error: XPST0017: Function unparsed-text with arity of 1 not registered. No similar functions found.
fn-parse-json-102,Error: XPST0017: Function unparsed-text with arity of 1 not registered. No similar functions found.
fn-parse-json-103,Error: XPST0017: Function unparsed-text with arity of 1 not registered. No similar functions found.
fn-parse-json-104,Error: XPST0017: Function unparsed-text with arity of 1 not registered. No similar functions found.
fn-parse-json-105,Error: XPST0017: Function unparsed-text with arity of 1 not registered. No similar functions found.
fn-parse-json-106,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?
fn-parse-json-107,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?
fn-parse-json-108,AssertionError: expected [Function] to throw error including 'FOJS0003' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'
fn-parse-json-109,AssertionError: expected [Function] to throw error including 'FOJS0003' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'
fn-parse-json-110,AssertionError: expected [Function] to throw error including 'FOJS0003' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'
fn-parse-json-111,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?
fn-parse-json-801,AssertionError: Expected executing the XPath "parse-json('[-0.123e-2,]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'.
fn-parse-json-802,AssertionError: Expected executing the XPath "parse-json('[FALSE]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'.
fn-parse-json-804,AssertionError: Expected executing the XPath "parse-json('[(5)]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'.
fn-parse-json-806,AssertionError: Expected executing the XPath "parse-json('[{x:23}]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'.
fn-parse-json-809,AssertionError: Expected executing the XPath "parse-json('[1,2,3,]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'.
fn-parse-json-810,AssertionError: Expected executing the XPath "parse-json('{"a":=13}', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'.
fn-parse-json-811,AssertionError: Expected executing the XPath "parse-json('{"a":13,,"b":15}', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'.
fn-parse-json-814,AssertionError: Expected executing the XPath "parse-json('{"a":{"b":12}}}', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'.
fn-parse-json-815,AssertionError: Expected executing the XPath "parse-json('["\"]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'.
fn-parse-json-816,AssertionError: Expected executing the XPath "parse-json('["\1"]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'.
fn-parse-json-817,AssertionError: Expected executing the XPath "parse-json('["\u2"]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'.
fn-parse-json-819,AssertionError: Expected executing the XPath "parse-json('["\b"]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'.
fn-parse-json-820,AssertionError: Expected executing the XPath "parse-json('["\x20"]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'.
fn-parse-json-821,AssertionError: Expected executing the XPath "parse-json('["\s"]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'.
fn-parse-json-822,AssertionError: Expected executing the XPath "parse-json('["\uD834"]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'.
fn-parse-json-823,AssertionError: Expected executing the XPath "parse-json('["\udD1E"]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'.
fn-parse-json-824,AssertionError: Expected executing the XPath "parse-json('["\u0000"]', map{'escape':false(), 'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'.
fn-parse-json-830,AssertionError: Expected executing the XPath "parse-json('[.3]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'.
fn-parse-json-831,AssertionError: Expected executing the XPath "parse-json('[01]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'.
fn-parse-json-832,AssertionError: Expected executing the XPath "parse-json('[00.00]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'.
fn-parse-json-833,AssertionError: Expected executing the XPath "parse-json('[+23]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'.
fn-parse-json-834,AssertionError: Expected executing the XPath "parse-json('[1.234f0]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'.
fn-parse-json-835,AssertionError: Expected executing the XPath "parse-json("['wrong']", map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'.
fn-parse-json-839,AssertionError: Expected executing the XPath "parse-json('', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'.
fn-parse-json-840,AssertionError: Expected executing the XPath "parse-json('{"'||codepoints-to-string((10, 37))||'":"x", "yyy":"y"}', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'.
fn-parse-json-919,AssertionError: Expected executing the XPath "parse-json('["\b"]')" to resolve to one of the expected results, but got AssertionError: Expected XPath parse-json('["\b"]') to (deep equally) resolve to ['�']: expected false to be true, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'Atomizing array(*) is not implemented.'.
fn-parse-json-922,AssertionError: Expected XPath parse-json('["\uD834"]') to (deep equally) resolve to ['�']: expected false to be true
fn-parse-json-923,AssertionError: Expected XPath parse-json('["\udD1E"]') to (deep equally) resolve to ['�']: expected false to be true
fn-parse-json-924,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?
fn-parse-json-925,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?
fn-parse-json-926,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?
fn-parse-json-927,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?
fn-parse-json-928,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?
fn-parse-json-929,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?
fn-parse-json-936,AssertionError: expected [Function] to throw error including 'FOJS0003' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'
fn-parse-json-937,AssertionError: expected [Function] to throw error including 'FOJS0005' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'
fn-parse-json-938,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'
fn-parse-json-940,AssertionError: expected [Function] to throw error including 'FOJS0005' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'
fn-parse-json-941,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'
fn-parse-json-942,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'
fn-parse-json-943,AssertionError: expected [Function] to throw error including 'Q{}USER9999' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'
fn-parse-json-944,AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'
fn-parse-json-945,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?'
fn-parse-json-946,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?
fn-parse-json-953,AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.'
K-ContextPositionFunc-20,Error: XPST0003: Unable to parse XPath: "1 eq (0, 1, current-time(), 4)[position() = 2] treat as xs:integer". Expected " ", "!", "(", "(:", "*", "+", ",", "-", "/", "//", "=>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "except", "idiv", "instance", "intersect", "mod", "or", "to", "union", "|", "||", or end of input but "t" found. 1 eq (0, 1, current-time(), 4)[position() = 2] [Error is around here]treat as xs:integer
K-ContextPositionFunc-21,Error: XPST0003: Unable to parse XPath: "1 eq (0, 1, current-time(), 4)[position() eq 2] treat as xs:integer". Expected " ", "!", "(", "(:", "*", "+", ",", "-", "/", "//", "=>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "except", "idiv", "instance", "intersect", "mod", "or", "to", "union", "|", "||", or end of input but "t" found. 1 eq (0, 1, current-time(), 4)[position() eq 2] [Error is around here]treat as xs:integer
K-ContextPositionFunc-22,Error: XPST0003: Unable to parse XPath: "1 eq (0, 1, current-time(), 4)[2 eq position()] treat as xs:integer". Expected " ", "!", "(", "(:", "*", "+", ",", "-", "/", "//", "=>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "except", "idiv", "instance", "intersect", "mod", "or", "to", "union", "|", "||", or end of input but "t" found. 1 eq (0, 1, current-time(), 4)[2 eq position()] [Error is around here]treat as xs:integer
K-ContextPositionFunc-23,Error: XPST0003: Unable to parse XPath: "1 eq (0, 1, current-time(), 4)[2 = position()] treat as xs:integer". Expected " ", "!", "(", "(:", "*", "+", ",", "-", "/", "//", "=>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "except", "idiv", "instance", "intersect", "mod", "or", "to", "union", "|", "||", or end of input but "t" found. 1 eq (0, 1, current-time(), 4)[2 = position()] [Error is around here]treat as xs:integer
fn-prefix-from-qname-20,Error: FONS0004: The value foo:bar can not be cast to a QName. Did you mean to use fn:QName?
ExpandedQNameConstructFunc001,Error: XPST0003: Unable to parse XPath: "element {fn:QName("http://www.example.com/example", "person")}{ "test" }". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. element [Error is around here]{fn:QName("http://www.example.com/example", "person")}{ "test" }
ExpandedQNameConstructFunc002,Error: XPST0003: Unable to parse XPath: "element {fn:QName("http://www.example.com/example", "ht:person")}{ "test" }". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. element [Error is around here]{fn:QName("http://www.example.com/example", "ht:person")}{ "test" }
ExpandedQNameConstructFunc003,Error: XPST0003: Unable to parse XPath: "element {fn:QName("", "person")}{ "test" }". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. element [Error is around here]{fn:QName("", "person")}{ "test" }
ExpandedQNameConstructFunc004,Error: XPST0003: Unable to parse XPath: "element {fn:QName((), "person")}{ "test" }". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. element [Error is around here]{fn:QName((), "person")}{ "test" }
ExpandedQNameConstructFunc017,Error: XPST0003: Unable to parse XPath: "element {fn:QName( "http://www.example.com/example", string((//FolderName)[2]) )}{ "test" }". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. element [Error is around here]{fn:QName( "http://www.example.com/example", string((//FolderName)[2]) )}{ "test" }
ExpandedQNameConstructFunc018,Error: XPST0003: Unable to parse XPath: "element {fn:QName( concat('http://www.example.com/', string((//FolderName)[2])), "people" )}{ "test" }". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. element [Error is around here]{fn:QName( concat('http://www.example.com/', string((//FolderName)[2])), "people" )}{ "test" }
ExpandedQNameConstructFunc019,AssertionError: expected [Function] to throw error including 'FOCA0002' but got 'XPST0003: Unable to parse XPath: "element {fn:QName( "http://www.example.com/example", "" )}{ "test" }".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nelement [Error is around here]{fn:QName( "http://www.example.com/example", "" )}{ "test" }'
ExpandedQNameConstructFunc020,Error: XPST0003: Unable to parse XPath: "declare namespace ht="http://www.example.com/example"; element {fn:QName( "http://www.example.com/another-example", "ht:person" )}{ "test" }". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. declare namespace ht="http://www.example.com/example"; element [Error is around here]{fn:QName( "http://www.example.com/another-example", "ht:person" )}{ "test" }
ExpandedQNameConstructFunc021,Error: XPST0003: Unable to parse XPath: "declare namespace ht="http://www.example.com/example"; element {fn:QName( "http://www.example.com/example", "ht2:person" )}{ "test" }". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. declare namespace ht="http://www.example.com/example"; element [Error is around here]{fn:QName( "http://www.example.com/example", "ht2:person" )}{ "test" }
K-SeqRemoveFunc-13,AssertionError: Expected executing the XPath "remove(error(), 1)" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?', AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'.
K-SeqRemoveFunc-17,AssertionError: expected [Function] to throw an error
K-SeqRemoveFunc-18,AssertionError: expected [Function] to throw an error
fn-reverseintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-reverseintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-reverseintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-reverselng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-reverselng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-reverselng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-reversenint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-reversenint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-reversepint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-reversepint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-reverseulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-reverseulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-reversenpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-reversenpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-reversenni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-reversenni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-SeqReverseFunc-15,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
K2-SeqReverseFunc-2,Error: XPST0003: Unable to parse XPath: "declare variable $myVar := unordered{ordered{unordered{fn:reverse((<a/>, <b/>))}}}; deep-equal($myVar, (<a/>, <b/>)) or deep-equal($myVar, (<b/>, <a/>))". Expected " ", "!", "!=", "#", "(", "(:", "*", "+", "-", "/", "//", ":", ":*", ";", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. declare variable $myVar := unordered[Error is around here]{ordered{unordered{fn:reverse((<a/>, <b/>))}}}; deep-equal($myVar, (<a/>, <b/>)) or deep-equal($myVar, (<b/>, <a/>))
K2-SeqReverseFunc-3,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-SeqReverseFunc-6,Error: XPST0003: Unable to parse XPath: "deep-equal((declare ordering unordered; reverse((1, 2))), (2, 1))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "to", "union", "|", or "||" but "o" found. deep-equal((declare [Error is around here]ordering unordered; reverse((1, 2))), (2, 1))
fn-root-1,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0017: Function fn:root with arity of 0 not registered. No similar functions found.'
fn-root-2,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function fn:root with arity of 0 not registered. No similar functions found.'
fn-root-3,AssertionError: Expected executing the XPath "fn:count(fn:root(()))" to resolve to one of the expected results, but got Error: XPST0017: Function fn:root with arity of 1 not registered. No similar functions found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0017: Function fn:root with arity of 1 not registered. No similar functions found.'.
fn-root-4,Error: XPST0017: Function fn:root with arity of 1 not registered. No similar functions found.
fn-root-5,Error: XPST0017: Function fn:root with arity of 1 not registered. No similar functions found.
fn-root-6,Error: XPST0017: Function fn:root with arity of 1 not registered. No similar functions found.
fn-root-7,Error: XPST0017: Function fn:root with arity of 1 not registered. No similar functions found.
fn-root-8,Error: XPST0017: Function fn:root with arity of 1 not registered. No similar functions found.
fn-root-9,Error: XPST0017: Function fn:root with arity of 1 not registered. No similar functions found.
fn-root-10,Error: XPST0003: Unable to parse XPath: "let $var := element anElement {attribute anAttribute {"Attribute Value"}} return fn:root($var)". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "a" found. let $var := element [Error is around here]anElement {attribute anAttribute {"Attribute Value"}} return fn:root($var)
fn-root-11,Error: XPST0003: Unable to parse XPath: "fn:root(element anElement {attribute anAttribute {"Attribute Value"}})". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "a" found. fn:root(element [Error is around here]anElement {attribute anAttribute {"Attribute Value"}})
fn-root-12,Error: XPST0003: Unable to parse XPath: "let $var := document {<anElement><anInternalElement>element content</anInternalElement></anElement>} return fn:root($var)". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found. let $var := document [Error is around here]{<anElement><anInternalElement>element content</anInternalElement></anElement>} return fn:root($var)
fn-root-13,Error: XPST0003: Unable to parse XPath: "fn:root(document {<anElement><anInternalElement>element content</anInternalElement></anElement>})". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. fn:root(document [Error is around here]{<anElement><anInternalElement>element content</anInternalElement></anElement>})
fn-root-14,Error: XPST0017: Function fn:root with arity of 1 not registered. No similar functions found.
fn-root-15,Error: XPST0017: Function fn:root with arity of 1 not registered. No similar functions found.
fn-root-16,Error: XPST0003: Unable to parse XPath: "fn:root(text {"A text Node"})". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. fn:root(text [Error is around here]{"A text Node"})
fn-root-17,Error: XPST0003: Unable to parse XPath: "let $var := text {"a text Node"} return fn:root($var)". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found. let $var := text [Error is around here]{"a text Node"} return fn:root($var)
fn-root-18,Error: XPST0003: Unable to parse XPath: "let $var := element anElement {"Element Content"} return fn:root($var) is fn:root($var)". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "a" found. let $var := element [Error is around here]anElement {"Element Content"} return fn:root($var) is fn:root($var)
fn-root-19,Error: XPST0003: Unable to parse XPath: "let $var := element anElement {"Element Content"} return fn:root($var) is fn:root($var)". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "a" found. let $var := element [Error is around here]anElement {"Element Content"} return fn:root($var) is fn:root($var)
fn-root-20,Error: XPST0003: Unable to parse XPath: "let $var := element anElement {"Element Content"} return fn:count(fn:namespace-uri(fn:root($var))) = 1". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "a" found. let $var := element [Error is around here]anElement {"Element Content"} return fn:count(fn:namespace-uri(fn:root($var))) = 1
fn-root-21,Error: XPST0017: Function fn:root with arity of 1 not registered. No similar functions found.
fn-root-22,Error: XPST0017: Function fn:root with arity of 1 not registered. No similar functions found.
fn-root-23,Error: XPST0003: Unable to parse XPath: "let $var := text {"A text node"} return fn:count(fn:namespace-uri(fn:root($var))) = 1". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found. let $var := text [Error is around here]{"A text node"} return fn:count(fn:namespace-uri(fn:root($var))) = 1
fn-root-24,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0017: Function fn:root with arity of 1 not registered. No similar functions found.'
K-NodeRootFunc-2,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function root with arity of 0 not registered. No similar functions found.'
K-NodeRootFunc-3,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function root with arity of 1 not registered. No similar functions found.'
K-NodeRootFunc-4,AssertionError: Expected executing the XPath "empty(root(()))" to resolve to one of the expected results, but got Error: XPST0017: Function root with arity of 1 not registered. No similar functions found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0017: Function root with arity of 1 not registered. No similar functions found.'.
K2-NodeRootFunc-1,Error: XPST0017: Function fn:root with arity of 1 not registered. No similar functions found.
K2-NodeRootFunc-2,Error: XPST0017: Function fn:root with arity of 1 not registered. No similar functions found.
K2-NodeRootFunc-3,Error: XPST0017: Function fn:root with arity of 1 not registered. No similar functions found.
K2-NodeRootFunc-4,Error: XPST0003: Unable to parse XPath: "<e>{fn:root(attribute name {"value"})}</e>". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. <e>{fn:root(attribute [Error is around here]name {"value"})}</e>
K2-NodeRootFunc-5,Error: XPST0017: Function fn:root with arity of 1 not registered. No similar functions found.
K2-NodeRootFunc-6,Error: XPST0003: Unable to parse XPath: "fn:root(text{"text node"})". Expected "!", "!=", "#", "(", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. fn:root(text[Error is around here]{"text node"})
K2-NodeRootFunc-7,Error: XPST0003: Unable to parse XPath: "fn:root(text{"text node"})". Expected "!", "!=", "#", "(", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. fn:root(text[Error is around here]{"text node"})
K2-NodeRootFunc-8,Error: XPST0003: Unable to parse XPath: "root(document {()}) instance of document-node()". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. root(document [Error is around here]{()}) instance of document-node()
fn-roundintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-roundintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-roundintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-roundlng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-roundlng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-roundlng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-roundnint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-roundnint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-roundpint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-roundpint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-roundulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-roundulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-roundnpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-roundnpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-roundnni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-roundnni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-RoundFunc-2,AssertionError: expected [Function] to throw an error
fn-round-1,Error: XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
fn-round2args-4,AssertionError: Expected XPath fn:round(35.425, 2) to resolve to 35.43: expected false to be true
fn-round-half-to-evenintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-round-half-to-evenintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-round-half-to-evenintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-round-half-to-evenlng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-round-half-to-evenlng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-round-half-to-evenlng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-round-half-to-evennint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-round-half-to-evennint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-round-half-to-evenpint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-round-half-to-evenpint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-round-half-to-evenulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-round-half-to-evenulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-round-half-to-evennpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-round-half-to-evennpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-round-half-to-evennni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-round-half-to-evennni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-round-half-to-even-1,Error: XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
fn-round-half-to-even-2,Error: XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
fn-round-half-to-even-14,AssertionError: Expected XPath round-half-to-even(xs:float('0.05'), 1) to resolve to 0.1: expected false to be true
fn-round-half-to-even-15,AssertionError: Expected XPath round-half-to-even(xs:float('-0.05'), 1) to resolve to -0.1: expected false to be true
K-SecondsFromDurationFunc-5,AssertionError: Expected XPath seconds-from-duration(xs:dayTimeDuration("P3DT8H2M1.03S")) eq 1.03 to resolve to true: expected false to be true
K-SecondsFromDurationFunc-6,AssertionError: Expected XPath seconds-from-duration(xs:dayTimeDuration("-P3DT8H2M1.03S")) eq -1.03 to resolve to true: expected false to be true
K-SecondsFromDurationFunc-7,AssertionError: Expected XPath seconds-from-duration(xs:duration("-P3Y4M8DT1H23M2.34S")) eq -2.34 to resolve to true: expected false to be true
fn-starts-with-17,Error: FOCH0002: No collations are supported
fn-starts-with-18,Error: FOCH0002: No collations are supported
fn-starts-with-19,Error: FOCH0002: No collations are supported
fn-starts-with-20,Error: FOCH0002: No collations are supported
fn-starts-with-21,Error: FOCH0002: No collations are supported
fn-starts-with-22,Error: FOCH0002: No collations are supported
fn-starts-with-23,Error: FOCH0002: No collations are supported
fn-starts-with-24,Error: FOCH0002: No collations are supported
fn-starts-with-25,Error: FOCH0002: No collations are supported
fn-starts-with-26,Error: FOCH0002: No collations are supported
fn-starts-with-27,Error: FOCH0002: No collations are supported
fn-starts-with-28,Error: FOCH0002: No collations are supported
fn-starts-with-29,Error: FOCH0002: No collations are supported
fn-starts-with-30,Error: FOCH0002: No collations are supported
fn-starts-with-31,Error: FOCH0002: No collations are supported
K-StartsWithFunc-5,Error: FOCH0002: No collations are supported
K2-StartsWithFunc-1,Error: XPST0003: Unable to parse XPath: "let $vA := ("B STRING", current-time(), string("content"))[1] treat as xs:string,          $vB := ("b string", current-time(), string("content"))[1] treat as xs:string         return starts-with(lower-case($vA), lower-case($vB))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found. let $vA := ("B STRING", current-time(), string("content"))[1] [Error is around here]treat as xs:string,          $vB := ("b string", current-time(), string("content"))[1] treat as xs:string         return starts-with(lower-case($vA), lower-case($vB))
K2-StartsWithFunc-2,Error: XPST0003: Unable to parse XPath: "let $vA := ("B STRING", current-time(), string("content"))[1] treat as xs:string,          $vB := ("b string", current-time(), string("content"))[1] treat as xs:string          return starts-with(upper-case($vA), upper-case($vB))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found. let $vA := ("B STRING", current-time(), string("content"))[1] [Error is around here]treat as xs:string,          $vB := ("b string", current-time(), string("content"))[1] treat as xs:string          return starts-with(upper-case($vA), upper-case($vB))
K2-StartsWithFunc-3,Error: XPST0003: Unable to parse XPath: "let $vA := ("B STRING", current-time(), string("content"))[1] treat as xs:string,          $vB := ("no match", current-time(), string("content"))[1] treat as xs:string         return starts-with(lower-case($vA), lower-case($vB))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found. let $vA := ("B STRING", current-time(), string("content"))[1] [Error is around here]treat as xs:string,          $vB := ("no match", current-time(), string("content"))[1] treat as xs:string         return starts-with(lower-case($vA), lower-case($vB))
K2-StartsWithFunc-4,Error: XPST0003: Unable to parse XPath: "let $vA := ("B STRING", current-time(), string("content"))[1] treat as xs:string,          $vB := ("no match", current-time(), string("content"))[1] treat as xs:string          return starts-with(upper-case($vA), upper-case($vB))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found. let $vA := ("B STRING", current-time(), string("content"))[1] [Error is around here]treat as xs:string,          $vB := ("no match", current-time(), string("content"))[1] treat as xs:string          return starts-with(upper-case($vA), upper-case($vB))
K2-StartsWithFunc-5,Error: XPST0003: Unable to parse XPath: "let $vA := ("B STRING", current-time(), string("content"))[1] treat as xs:string,          $vB := ("b string", current-time(), string("content"))[1] treat as xs:string          return starts-with(upper-case($vA), lower-case($vB))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found. let $vA := ("B STRING", current-time(), string("content"))[1] [Error is around here]treat as xs:string,          $vB := ("b string", current-time(), string("content"))[1] treat as xs:string          return starts-with(upper-case($vA), lower-case($vB))
K2-StartsWithFunc-6,Error: XPST0003: Unable to parse XPath: "let $vA := ("B STRING", current-time(), string("content"))[1] treat as xs:string,          $vB := ("b string", current-time(), string("content"))[1] treat as xs:string          return starts-with(lower-case($vA), upper-case($vB))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found. let $vA := ("B STRING", current-time(), string("content"))[1] [Error is around here]treat as xs:string,          $vB := ("b string", current-time(), string("content"))[1] treat as xs:string          return starts-with(lower-case($vA), upper-case($vB))
cbcl-starts-with-001,Error: FOCH0002: No collations are supported
fn-stringintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-stringintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-stringintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-stringdec1args-1,AssertionError: fn:string(xs:decimal("-999999999999999999")): expected '-1000000000000000000' to equal '-999999999999999999'
fn-stringdec1args-2,AssertionError: fn:string(xs:decimal("617375191608514839")): expected '617375191608514800' to equal '617375191608514839'
fn-stringdec1args-3,AssertionError: fn:string(xs:decimal("999999999999999999")): expected '1000000000000000000' to equal '999999999999999999'
fn-stringlng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-stringlng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-stringlng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-stringnint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-stringnint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-stringpint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-stringpint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-stringulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-stringulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-stringnpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-stringnpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-stringnni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-stringnni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-string-23,AssertionError: expected [Function] to throw an error
fn-string-32,AssertionError: expected [Function] to throw an error
fn-string-33,AssertionError: expected [Function] to throw an error
fn-string-34,AssertionError: expected [Function] to throw an error
fn-string-35,AssertionError: expected [Function] to throw an error
fn-string-36,AssertionError: expected [Function] to throw an error
fn-string-37,AssertionError: expected [Function] to throw an error
fn-string-38,AssertionError: expected [Function] to throw an error
fn-string-join-27,AssertionError: expected [Function] to throw an error
fn-string-join-29,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
fn-string-join-31,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
K-StringJoinFunc-1,AssertionError: expected [Function] to throw an error
fn-string-length-21,AssertionError: expected [Function] to throw error including 'FOTY0013' but got 'XPTY0004 Unable to convert to type'
K-SeqSubsequenceFunc-30,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
K2-SeqSubsequenceFunc-1,Error: XPST0003: Unable to parse XPath: "let $start := (current-time(), 2)[2] treat as xs:integer,                 $len := (current-time(), 1)[2] treat as xs:integer                 return subsequence((1, 2, 3), $start, $len) = 2". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found. let $start := (current-time(), 2)[2] [Error is around here]treat as xs:integer,                 $len := (current-time(), 1)[2] treat as xs:integer                 return subsequence((1, 2, 3), $start, $len) = 2
fn-substring-after-22,Error: XPST0017: Function substring-after with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)"?
fn-substring-after-23,Error: XPST0017: Function substring-after with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)"?
fn-substring-after-24,Error: XPST0017: Function substring-after with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)"?
fn-substring-after-26,Error: XPST0017: Function substring-after with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)"?
fn-substring-after-27,Error: XPST0017: Function fn:substring-after with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)"?
fn-substring-after-28,Error: XPST0017: Function fn:substring-after with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)"?
fn-substring-after-29,Error: XPST0017: Function fn:substring-after with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)"?
fn-substring-after-30,Error: XPST0017: Function fn:substring-after with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)"?
fn-substring-after-31,Error: XPST0017: Function fn:substring-after with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)"?
fn-substring-after-32,Error: XPST0017: Function fn:substring-after with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)"?
fn-substring-after-33,Error: XPST0017: Function fn:substring-after with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)"?
fn-substring-after-34,Error: XPST0017: Function fn:substring-after with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)"?
fn-substring-after-35,Error: XPST0017: Function fn:substring-after with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)"?
fn-substring-after-36,Error: XPST0017: Function fn:substring-after with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)"?
fn-substring-after-37,Error: XPST0017: Function fn:substring-after with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)"?
fn-substring-after-38,Error: XPST0017: Function fn:substring-after with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)"?
fn-substring-after-39,Error: XPST0017: Function fn:substring-after with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)"?
fn-substring-after-40,Error: XPST0017: Function fn:substring-after with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)"?
fn-substring-after-41,Error: XPST0017: Function fn:substring-after with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)"?
K-SubstringAfterFunc-4,AssertionError: expected [Function] to throw error including 'FOCH0002' but got 'XPST0017: Function substring-after with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)"?'
K-SubstringAfterFunc-5,Error: XPST0017: Function substring-after with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)"?
cbcl-substring-after-001,Error: XPST0017: Function fn:substring-after with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)"?
fn-substring-before-22,Error: XPST0017: Function substring-before with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}insert-before (item()*, xs:integer, item()*)"?
fn-substring-before-23,Error: XPST0017: Function substring-before with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}insert-before (item()*, xs:integer, item()*)"?
fn-substring-before-24,Error: XPST0017: Function substring-before with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}insert-before (item()*, xs:integer, item()*)"?
fn-substring-before-26,Error: XPST0017: Function substring-before with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}insert-before (item()*, xs:integer, item()*)"?
fn-substring-before-27,Error: XPST0017: Function fn:substring-before with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}insert-before (item()*, xs:integer, item()*)"?
fn-substring-before-28,Error: XPST0017: Function fn:substring-before with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}insert-before (item()*, xs:integer, item()*)"?
fn-substring-before-29,Error: XPST0017: Function fn:substring-before with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}insert-before (item()*, xs:integer, item()*)"?
fn-substring-before-30,Error: XPST0017: Function fn:substring-before with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}insert-before (item()*, xs:integer, item()*)"?
fn-substring-before-31,Error: XPST0017: Function fn:substring-before with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}insert-before (item()*, xs:integer, item()*)"?
fn-substring-before-32,Error: XPST0017: Function fn:substring-before with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}insert-before (item()*, xs:integer, item()*)"?
fn-substring-before-33,Error: XPST0017: Function fn:substring-before with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}insert-before (item()*, xs:integer, item()*)"?
fn-substring-before-34,Error: XPST0017: Function fn:substring-before with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}insert-before (item()*, xs:integer, item()*)"?
fn-substring-before-35,Error: XPST0017: Function fn:substring-before with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}insert-before (item()*, xs:integer, item()*)"?
fn-substring-before-36,Error: XPST0017: Function fn:substring-before with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}insert-before (item()*, xs:integer, item()*)"?
fn-substring-before-37,Error: XPST0017: Function fn:substring-before with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}insert-before (item()*, xs:integer, item()*)"?
fn-substring-before-38,Error: XPST0017: Function fn:substring-before with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}insert-before (item()*, xs:integer, item()*)"?
fn-substring-before-39,Error: XPST0017: Function fn:substring-before with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}insert-before (item()*, xs:integer, item()*)"?
fn-substring-before-40,Error: XPST0017: Function fn:substring-before with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}insert-before (item()*, xs:integer, item()*)"?
fn-substring-before-41,Error: XPST0017: Function fn:substring-before with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}insert-before (item()*, xs:integer, item()*)"?
fn-substring-before-43,AssertionError: Expected executing the XPath "fn:substring-before("Chapter-100", "Chapter-10", "http://www.w3.org/2013/collation/UCA?lang=en;numeric=yes")" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FOCH0004' but got 'XPST0017: Function fn:substring-before with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}insert-before (item()*, xs:integer, item()*)"?', Error: XPST0017: Function fn:substring-before with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}insert-before (item()*, xs:integer, item()*)"?.
K-SubstringBeforeFunc-4,AssertionError: expected [Function] to throw error including 'FOCH0002' but got 'XPST0017: Function substring-before with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}insert-before (item()*, xs:integer, item()*)"?'
K-SubstringBeforeFunc-5,Error: XPST0017: Function substring-before with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}insert-before (item()*, xs:integer, item()*)"?
cbcl-substring-before-001,Error: XPST0017: Function fn:substring-before with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}insert-before (item()*, xs:integer, item()*)"?
fn-sumintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumlng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumlng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumlng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumpint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumpint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumintg2args-1,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumintg2args-2,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumintg2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumintg2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumlng2args-1,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumlng2args-2,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumlng2args-3,Error: FOCA0003: can not cast -45058158165499290 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumlng2args-4,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnint2args-1,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnint2args-2,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnint2args-3,Error: FOCA0003: can not cast -702985924000903206 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnint2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumpint2args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumpint2args-3,Error: FOCA0003: can not cast 999999999999999998 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumpint2args-4,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumpint2args-5,Error: FOCA0003: can not cast 999999999999999998 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumulng2args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumulng2args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumulng2args-4,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumulng2args-5,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnpi2args-1,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnpi2args-2,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnpi2args-3,Error: FOCA0003: can not cast -524311562728129509 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnpi2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnni2args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnni2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnni2args-4,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnni2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumintg3args-1,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumintg3args-2,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumintg3args-3,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumintg3args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumflt3args-1,AssertionError: Expected executing the XPath "fn:sum((xs:float("0"),xs:float("-3.4028235E38"),xs:float("-3.4028235E38")))" to resolve to one of the expected results, but got AssertionError: fn:sum((xs:float("0"),xs:float("-3.4028235E38"),xs:float("-3.4028235E38"))): expected '-6.805647E38' to equal '-INF', AssertionError: expected [Function] to throw an error.
fn-sumlng3args-1,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumlng3args-2,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumlng3args-3,Error: FOCA0003: can not cast -45058158165499290 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumlng3args-4,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumlng3args-5,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumlng3args-6,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnint3args-1,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnint3args-2,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumpint3args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumpint3args-3,Error: FOCA0003: can not cast 999999999999999998 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumpint3args-4,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumpint3args-5,Error: FOCA0003: can not cast 999999999999999998 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumpint3args-6,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumpint3args-7,Error: FOCA0003: can not cast 999999999999999998 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumulng3args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumulng3args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumulng3args-4,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumulng3args-5,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumulng3args-6,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumulng3args-7,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnpi3args-1,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnpi3args-2,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnpi3args-3,Error: FOCA0003: can not cast -524311562728129509 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnpi3args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnpi3args-5,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnni3args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnni3args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnni3args-4,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnni3args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnni3args-6,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnni3args-7,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-SeqSUMFunc-30,Error: FORG0006: items passed to fn:sum are not all numeric.
K2-SeqSUMFunc-4,AssertionError: Expected XPath sum(xs:unsignedShort("1")) instance of xs:unsignedShort to resolve to true: expected false to be true
fn-sum-1,Error: FORG0006: items passed to fn:sum are not all numeric.
fn-sum-3,Error: FORG0006: items passed to fn:sum are not all numeric.
fn-sum-4,Error: FORG0006: items passed to fn:sum are not all numeric.
fn-sum-6,Error: FORG0006: items passed to fn:sum are not all numeric.
fn-sum-11,Error: FORG0006: items passed to fn:sum are not all numeric.
tail-006,Error: XPST0003: Unable to parse XPath: "(declare function local:sum($n) { if (empty($n)) then 0 else head($n) + local:sum(tail($n)) };              local:sum(1 to 5)) instance of xs:integer". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found. (declare [Error is around here]function local:sum($n) { if (empty($n)) then 0 else head($n) + local:sum(tail($n)) };              local:sum(1 to 5)) instance of xs:integer
cbcl-timezone-from-date-001,Error: XPST0017: Function adjust-date-to-timezone with arity of 1 not registered. No similar functions found.
cbcl-timezone-from-date-002,AssertionError: expected [Function] to throw error including 'FODT0003' but got 'XPST0017: Function adjust-date-to-timezone with arity of 2 not registered. No similar functions found.'
cbcl-timezone-from-date-003,Error: XPST0017: Function adjust-date-to-timezone with arity of 2 not registered. No similar functions found.
cbcl-timezone-from-date-004,Error: XPST0017: Function adjust-date-to-timezone with arity of 2 not registered. No similar functions found.
cbcl-timezone-from-date-005,Error: XPST0017: Function adjust-date-to-timezone with arity of 2 not registered. No similar functions found.
cbcl-timezone-from-date-006,Error: XPST0017: Function adjust-date-to-timezone with arity of 2 not registered. No similar functions found.
cbcl-timezone-from-date-007,Error: XPST0017: Function adjust-date-to-timezone with arity of 2 not registered. No similar functions found.
fn-unordered-mix-args-001,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-002,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-003,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-004,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-005,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-006,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-007,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-008,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-009,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-010,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-011,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-012,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-013,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-014,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-015,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-016,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-017,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-018,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-019,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-020,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-021,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-022,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-023,AssertionError: Skipped test, it was a assert-permutation
K-SeqUnorderedFunc-8,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
fn-unordered-108,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-109,AssertionError: Skipped test, it was a assert-permutation
fn-upper-case-18,Error: XPST0017: Function fn:string-to-codepoints with arity of 1 not registered. No similar functions found.
fn-upper-case-19,Error: XPST0017: Function fn:string-to-codepoints with arity of 1 not registered. No similar functions found.
fn-upper-case-20,Error: XPST0017: Function fn:string-to-codepoints with arity of 1 not registered. No similar functions found.
fn-upper-case-21,Error: XPST0017: Function fn:string-to-codepoints with arity of 1 not registered. No similar functions found.
fn-upper-case-22,Error: XPST0017: Function fn:string-to-codepoints with arity of 1 not registered. No similar functions found.
fn-zero-or-oneintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-zero-or-oneintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-zero-or-oneintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-zero-or-onedec1args-1,AssertionError: fn:zero-or-one(xs:decimal("-999999999999999999")): expected '-1000000000000000000' to equal '-999999999999999999'
fn-zero-or-onedec1args-2,AssertionError: fn:zero-or-one(xs:decimal("617375191608514839")): expected '617375191608514800' to equal '617375191608514839'
fn-zero-or-onedec1args-3,AssertionError: fn:zero-or-one(xs:decimal("999999999999999999")): expected '1000000000000000000' to equal '999999999999999999'
fn-zero-or-onelng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-zero-or-onelng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-zero-or-onelng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-zero-or-onenint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-zero-or-onenint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-zero-or-onepint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-zero-or-onepint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-zero-or-oneulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-zero-or-oneulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-zero-or-onenpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-zero-or-onenpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-zero-or-onenni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-zero-or-onenni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-SeqZeroOrOneFunc-7,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
math-exp-004,AssertionError: Expected XPath math:exp(2) to resolve to 7.38905609893065e0: expected false to be true
math-exp-006,AssertionError: Expected XPath math:exp(math:pi()) to resolve to 23.140692632779267e0: expected false to be true
math-pi-005,Error: XPST0017: Function function-lookup with arity of 2 not registered. No similar functions found.
map-merge-002,Error: No selector counterpart for: typedMapTest.
map-merge-003-hof,Error: No selector counterpart for: typedMapTest.
map-merge-003,Error: No selector counterpart for: typedMapTest.
map-merge-004,Error: No selector counterpart for: typedMapTest.
map-merge-005,Error: No selector counterpart for: typedMapTest.
map-merge-006,Error: No selector counterpart for: typedMapTest.
map-merge-006b,Error: No selector counterpart for: typedMapTest.
map-merge-006c,Error: No selector counterpart for: typedMapTest.
map-merge-007,Error: No selector counterpart for: typedMapTest.
map-merge-008,Error: No selector counterpart for: typedMapTest.
map-merge-009,Error: No selector counterpart for: typedMapTest.
map-merge-010,Error: No selector counterpart for: typedMapTest.
map-merge-011,Error: No selector counterpart for: typedMapTest.
map-merge-012,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
map-merge-013,Error: No selector counterpart for: typedMapTest.
map-merge-024-hof,Error: No selector counterpart for: typedMapTest.
map-merge-024,Error: No selector counterpart for: typedMapTest.
map-contains-017,AssertionError: Expected XPath map:contains(map{1:"Sunday",2:"Monday",3:"Tuesday",xs:duration('P1Y'):"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, xs:yearMonthDuration('P12M')) to resolve to true: expected false to be true
map-contains-018,Error: XPST0017: Function function-name with arity of 1 not registered. No similar functions found.
map-get-017,AssertionError: map:get(map{1:"Sunday",2:"Monday",3:"Tuesday",xs:duration('P1Y'):"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, xs:yearMonthDuration('P12M')): expected '' to equal 'Wednesday'
map-get-018,Error: XPST0017: Function function-name with arity of 1 not registered. No similar functions found.
map-get-023,Error: XPST0017: Function adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
map-get-024,Error: XPST0017: Function adjust-date-to-timezone with arity of 2 not registered. No similar functions found.
map-get-100,Error: XPST0017: Function fn:for-each with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}for-each (array(*), function(*))" or "Q{http://www.w3.org/2005/xpath-functions/map}for-each (map(*), function(*))"?
map-entry-001-hof,Error: No selector counterpart for: typedMapTest.
map-entry-001,Error: No selector counterpart for: typedMapTest.
map-entry-002,Error: No selector counterpart for: typedMapTest.
map-entry-003,Error: No selector counterpart for: typedMapTest.
map-entry-004,Error: No selector counterpart for: typedMapTest.
map-entry-005,Error: No selector counterpart for: lookup.
map-entry-006,Error: No selector counterpart for: lookup.
map-entry-007-hof,Error: No selector counterpart for: typedMapTest.
map-entry-007,Error: No selector counterpart for: typedMapTest.
map-size-007,AssertionError: expected [Function] to throw an error
map-size-014,Error: XPST0017: Function adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
map-keys-007,AssertionError: expected [Function] to throw an error
map-put-002-hof,Error: No selector counterpart for: typedMapTest.
map-put-002,Error: No selector counterpart for: typedMapTest.
map-put-003-hof,Error: No selector counterpart for: typedMapTest.
map-put-003,Error: No selector counterpart for: typedMapTest.
map-put-004,Error: No selector counterpart for: typedMapTest.
map-put-006,Error: No selector counterpart for: typedMapTest.
map-put-007,Error: No selector counterpart for: typedMapTest.
map-put-008,Error: No selector counterpart for: typedMapTest.
map-put-010,Error: No selector counterpart for: typedMapTest.
map-put-011,Error: No selector counterpart for: typedMapTest.
map-put-012,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
map-put-013,Error: No selector counterpart for: typedMapTest.
map-put-023,AssertionError: Expected XPath              map{xs:float('1.0'):0, xs:double('1.00000000001'):1}              => map:put(xs:decimal('1.0000000000100000000001'), 2)              => map:size()          to resolve to 3: expected false to be true
map-remove-008,Error: No selector counterpart for: typedMapTest.
map-remove-009,Error: No selector counterpart for: typedMapTest.
map-remove-010,Error: No selector counterpart for: typedMapTest.
map-remove-011,Error: No selector counterpart for: typedMapTest.
map-remove-014,Error: XPST0017: Function adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
map-remove-016,AssertionError: Expected XPath              map{xs:float('1.0'):0, xs:double('1.00000000001'):1}              => map:remove(xs:decimal('1.0000000000100000000001'))              => map:size()          to resolve to 2: expected false to be true
map-for-each-007,AssertionError: expected [Function] to throw an error
map-for-each-017,Error: XPST0003: Unable to parse XPath: "<e>{map:for-each(map{"a":1, "b":2}, function($k,$v){attribute{$k}{$v}})}</e>". Expected "!", "!=", "#", "(", "*", "+", ",", "-", "/", "//", ":", ":*", "::", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", "}", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. <e>{map:for-each(map{"a":1, "b":2}, function($k,$v){attribute[Error is around here]{$k}{$v}})}</e>
array-append-101,Error: No selector counterpart for: anyArrayTest.
array-append-102,Error: No selector counterpart for: anyArrayTest.
array-append-103,Error: No selector counterpart for: anyArrayTest.
array-append-104,Error: No selector counterpart for: anyArrayTest.
array-append-105,Error: No selector counterpart for: anyArrayTest.
array-append-106,Error: No selector counterpart for: anyArrayTest.
array-append-107,Error: No selector counterpart for: anyArrayTest.
array-append-108,Error: No selector counterpart for: anyArrayTest.
array-filter-001,Error: No selector counterpart for: anyArrayTest.
array-filter-002,Error: No selector counterpart for: anyArrayTest.
array-filter-003,Error: No selector counterpart for: anyArrayTest.
array-filter-004,Error: No selector counterpart for: anyArrayTest.
array-filter-005,Error: No selector counterpart for: anyArrayTest.
array-filter-006,Error: No selector counterpart for: anyArrayTest.
array-filter-007,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Atomizing array(*) is not implemented.'
array-filter-008,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Cannot read property \'u\' of undefined'
array-filter-009,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'f.indexOf is not a function'
array-flatten-010,Error: Atomizing array(*) is not implemented.
array-fold-right-002,Error: XPTY0004 Unable to convert to type
array-fold-right-003,AssertionError: Expected XPath array:fold-right(["the cat", "sat", "on the mat"], "", function($a,$z){concat($a, " ", $z)}) to (deep equally) resolve to "the cat sat on the mat ": expected false to be true
array-fold-right-004,AssertionError: Expected XPath array:fold-right(["+2", "*3"], "10", function($a,$z){concat("(", $z, $a, ")")}) to (deep equally) resolve to "((10*3)+2)": expected false to be true
array-fold-right-005,Error: XPTY0004: expected base expression to evaluate to a function item
array-fold-right-006,AssertionError: Expected XPath array:fold-right([" opened the door", " went up stairs"], "Bob", function($a,$z){concat($z, $a)}) to (deep equally) resolve to "Bob went up stairs opened the door": expected false to be true
array-fold-right-009,AssertionError: Expected XPath array:fold-right([1,2,3], [], function($x, $y){[$x, $y]}) to (deep equally) resolve to [1, [2, [3, []]]]: expected false to be true
array-for-each-001,Error: No selector counterpart for: anyArrayTest.
array-for-each-002,Error: No selector counterpart for: anyArrayTest.
array-for-each-003,Error: No selector counterpart for: anyArrayTest.
array-for-each-004,Error: No selector counterpart for: anyArrayTest.
array-for-each-005,Error: No selector counterpart for: anyArrayTest.
array-for-each-006,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Cannot read property \'first\' of undefined'
array-for-each-007,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'a.value.toUpperCase is not a function'
array-for-each-pair-301,Error: No selector counterpart for: anyArrayTest.
array-for-each-pair-302,Error: No selector counterpart for: anyArrayTest.
array-for-each-pair-303,Error: No selector counterpart for: anyArrayTest.
array-for-each-pair-304,Error: No selector counterpart for: anyArrayTest.
array-for-each-pair-305,Error: No selector counterpart for: anyArrayTest.
array-for-each-pair-306,Error: No selector counterpart for: anyArrayTest.
array-for-each-pair-307,Error: No selector counterpart for: anyArrayTest.
array-for-each-pair-308,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Atomizing array(*) is not implemented.'
array-for-each-pair-309,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Atomizing array(*) is not implemented.'
array-get-002,Error: No selector counterpart for: anyArrayTest.
array-head-602,Error: No selector counterpart for: anyArrayTest.
array-head-606,Error: No selector counterpart for: anyArrayTest.
array-head-607,Error: XPST0003: Unable to parse XPath: "let $result := (            array:head([(1, [<e><f>g</f></e>, "b"], 2)])         ) return $result[2]?2 eq "b"". Expected "$", "(", "*", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "2" found. let $result := (            array:head([(1, [<e><f>g</f></e>, "b"], 2)])         ) return $result[2]?[Error is around here]2 eq "b"
array-insert-before-501,Error: No selector counterpart for: anyArrayTest.
array-insert-before-502,Error: No selector counterpart for: anyArrayTest.
array-insert-before-503,Error: No selector counterpart for: anyArrayTest.
array-insert-before-504,Error: No selector counterpart for: anyArrayTest.
array-insert-before-505,Error: No selector counterpart for: anyArrayTest.
array-insert-before-508,Error: XPST0003: Unable to parse XPath: "(                  let $x := <x/>         	  let $array := [<e/>, <f/>, <g/>]            	  for $i in 1 to array:size($array) + 1               return         	     array:insert-before($array, $i, $x)          ) instance of array(*)+". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. (                  let $x := <x/>         	  [Error is around here]let $array := [<e/>, <f/>, <g/>]            	  for $i in 1 to array:size($array) + 1               return         	     array:insert-before($array, $i, $x)          ) instance of array(*)+
array-insert-before-509,Error: XPST0003: Unable to parse XPath: "(                  let $x := 1               let $array := [0,0,0]               for $i in 1 to array:size($array) + 1               return                  array:insert-before($array, $i, $x)          ) instance of array(*)+". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. (                  let $x := 1               [Error is around here]let $array := [0,0,0]               for $i in 1 to array:size($array) + 1               return                  array:insert-before($array, $i, $x)          ) instance of array(*)+
array-insert-before-510,Error: XPST0003: Unable to parse XPath: "deep-equal((                  let $x := <c/>               let $array := [<a/>, <b/>]               let $insert1 := array:insert-before($array, 1, $x)               let $insert2 := array:insert-before($array, 2, $x)               for $element in (array:flatten($insert1) union array:flatten($insert2))               let $name := $element/name()               order by $name               return $name         ), (("a", "b", "c")))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. deep-equal((                  let $x := <c/>               [Error is around here]let $array := [<a/>, <b/>]               let $insert1 := array:insert-before($array, 1, $x)               let $insert2 := array:insert-before($array, 2, $x)               for $element in (array:flatten($insert1) union array:flatten($insert2))               let $name := $element/name()               order by $name               return $name         ), (("a", "b", "c")))
array-join-201,Error: No selector counterpart for: anyArrayTest.
array-join-202,Error: No selector counterpart for: anyArrayTest.
array-join-203,Error: No selector counterpart for: anyArrayTest.
array-join-204,Error: No selector counterpart for: anyArrayTest.
array-join-205,Error: No selector counterpart for: anyArrayTest.
array-join-206,Error: No selector counterpart for: anyArrayTest.
array-join-207,Error: No selector counterpart for: anyArrayTest.
array-join-208,Error: No selector counterpart for: anyArrayTest.
array-join-209,Error: No selector counterpart for: anyArrayTest.
array-join-210,Error: No selector counterpart for: anyArrayTest.
array-join-211,Error: No selector counterpart for: anyArrayTest.
array-put-001,Error: No selector counterpart for: anyArrayTest.
array-put-002,Error: No selector counterpart for: anyArrayTest.
array-put-003,Error: No selector counterpart for: anyArrayTest.
array-put-004,Error: No selector counterpart for: anyArrayTest.
array-put-005,Error: No selector counterpart for: anyArrayTest.
array-put-008,Error: XPST0003: Unable to parse XPath: "(                  let $x := <x/>         	  let $array := [<e/>, <f/>, <g/>]            	  for $i in 1 to array:size($array)               return         	     array:put($array, $i, $x)          ) instance of array(*)+". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. (                  let $x := <x/>         	  [Error is around here]let $array := [<e/>, <f/>, <g/>]            	  for $i in 1 to array:size($array)               return         	     array:put($array, $i, $x)          ) instance of array(*)+
array-put-009,Error: XPST0003: Unable to parse XPath: "(                  let $x := 1               let $array := [0,0,0]               for $i in 1 to array:size($array)               return                  array:put($array, $i, $x)          ) instance of array(*)+". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. (                  let $x := 1               [Error is around here]let $array := [0,0,0]               for $i in 1 to array:size($array)               return                  array:put($array, $i, $x)          ) instance of array(*)+
array-put-010,Error: XPST0003: Unable to parse XPath: "deep-equal((                  let $x := <c/>               let $array := [<a/>, <b/>]               let $insert1 := array:put($array, 1, $x)               let $insert2 := array:put($array, 2, $x)               for $element in (array:flatten($insert1) union array:flatten($insert2))               let $name := $element/name()               order by $name               return $name         ), (("a", "b", "c")))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. deep-equal((                  let $x := <c/>               [Error is around here]let $array := [<a/>, <b/>]               let $insert1 := array:put($array, 1, $x)               let $insert2 := array:put($array, 2, $x)               for $element in (array:flatten($insert1) union array:flatten($insert2))               let $name := $element/name()               order by $name               return $name         ), (("a", "b", "c")))
array-remove-401,Error: No selector counterpart for: anyArrayTest.
array-remove-402,Error: No selector counterpart for: anyArrayTest.
array-remove-403,Error: No selector counterpart for: anyArrayTest.
array-remove-404,Error: No selector counterpart for: anyArrayTest.
array-remove-409,Error: No selector counterpart for: anyArrayTest.
array-remove-410,Error: No selector counterpart for: anyArrayTest.
array-remove-413,Error: No selector counterpart for: anyArrayTest.
array-remove-414,Error: No selector counterpart for: anyArrayTest.
array-remove-416,Error: No selector counterpart for: anyArrayTest.
array-reverse-801,Error: No selector counterpart for: anyArrayTest.
array-reverse-802,Error: No selector counterpart for: anyArrayTest.
array-reverse-803,Error: No selector counterpart for: anyArrayTest.
array-reverse-804,Error: No selector counterpart for: anyArrayTest.
array-subarray-301,Error: No selector counterpart for: anyArrayTest.
array-subarray-302,Error: No selector counterpart for: anyArrayTest.
array-subarray-303,Error: No selector counterpart for: anyArrayTest.
array-subarray-304,Error: No selector counterpart for: anyArrayTest.
array-subarray-305,Error: No selector counterpart for: anyArrayTest.
array-subarray-306,Error: No selector counterpart for: anyArrayTest.
array-subarray-307,Error: No selector counterpart for: anyArrayTest.
array-subarray-308,Error: No selector counterpart for: anyArrayTest.
array-subarray-309,Error: No selector counterpart for: anyArrayTest.
array-subarray-313,Error: No selector counterpart for: anyArrayTest.
array-subarray-314,Error: No selector counterpart for: anyArrayTest.
array-tail-701,Error: No selector counterpart for: anyArrayTest.
array-tail-702,Error: No selector counterpart for: anyArrayTest.
array-tail-703,Error: No selector counterpart for: anyArrayTest.
array-tail-705,Error: No selector counterpart for: anyArrayTest.
array-tail-706,Error: No selector counterpart for: anyArrayTest.
base64-102,AssertionError: xs:hexBinary(xs:base64Binary("AA==")): expected '0' to equal '00'
base64-103,AssertionError: xs:hexBinary(xs:base64Binary("AQ==")): expected '1' to equal '01'
base64-105,AssertionError: xs:hexBinary(xs:base64Binary("AAA=")): expected '00' to equal '0000'
base64-106,AssertionError: xs:hexBinary(xs:base64Binary("AP8=")): expected '0FF' to equal '00FF'
base64-109,AssertionError: xs:hexBinary(xs:base64Binary("AQID")): expected '123' to equal '010203'
base64-110,AssertionError: xs:hexBinary(xs:base64Binary("AQIDBA==")): expected '1234' to equal '01020304'
base64-111,AssertionError: xs:hexBinary(xs:base64Binary("AQIDBAU=")): expected '12345' to equal '0102030405'
base64-112,AssertionError: xs:hexBinary(xs:base64Binary("AQIDBAUG")): expected '123456' to equal '010203040506'
base64-113,AssertionError: xs:hexBinary(xs:base64Binary("AQIDBAUGBw==")): expected '1234567' to equal '01020304050607'
base64-114,AssertionError: xs:hexBinary(xs:base64Binary("AQIDBAUGBwgJCgsMDQ4PEBESExMUFRYXGBkaGxwdHyAhIiMkJSYnKCkqKywtLi8=")): expected '123456789ABCDEF10111213131415161718191A1B1C1D1F202122232425262728292A2B2C2D2E2F' to equal '0102030405060708090A0B0C0D0E0F10111213131415161718191A1B1C1D1F202122232425262728292A2B2C2D2E2F'
base64-115,AssertionError: xs:hexBinary(xs:base64Binary(" AQIDBAUG BwgJCgsM DQ4PEBES ExMUFRYX   GBkaGxwdH yAhIiMkJ SYnKCkqK y w t L i 8 = ")): expected '123456789ABCDEF10111213131415161718191A1B1C1D1F202122232425262728292A2B2C2D2E2F' to equal '0102030405060708090A0B0C0D0E0F10111213131415161718191A1B1C1D1F202122232425262728292A2B2C2D2E2F'
base64-908,AssertionError: expected [Function] to throw error including 'FORG0001' but got 'XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.'
base64-909,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
xs-double-004,AssertionError: expected [Function] to throw an error
xs-error-006,Error: No selector counterpart for: functionTest.
xs-error-007,Error: No selector counterpart for: functionTest.
xs-error-015,Error: No selector counterpart for: functionTest.
xs-error-016,Error: No selector counterpart for: functionTest.
xs-error-017,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function fn:error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
xs-error-019,AssertionError: Expected executing the XPath "declare function local:constant($arg as xs:error)             {               fn:true()             };        local:constant(fn:error())       " to resolve to one of the expected results, but got Error: XPST0017: Function fn:error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function fn:error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?', AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function fn:error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'.
xs-error-020,Error: XPST0003: Unable to parse XPath: "(declare function local:identity($arg as xs:error?)             {               $arg             };        local:identity(())       ) => empty()". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found. (declare [Error is around here]function local:identity($arg as xs:error?)             {               $arg             };        local:identity(())       ) => empty()
xs-error-021,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function fn:error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
xs-error-022,AssertionError: expected [Function] to throw an error
xs-error-023,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0003: Unable to parse XPath: "let $x as xs:error := fn:error() return $x".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\nlet $x [Error is around here]as xs:error := fn:error() return $x'
xs-error-024,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function fn:error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
xs-error-025,AssertionError: Expected executing the XPath "let $x as xs:error := fn:error() return fn:true()" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "let $x as xs:error := fn:error() return fn:true()". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $x [Error is around here]as xs:error := fn:error() return fn:true(), AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0003: Unable to parse XPath: "let $x as xs:error := fn:error() return fn:true()".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\nlet $x [Error is around here]as xs:error := fn:error() return fn:true()'.
xs-error-026,AssertionError: Expected executing the XPath "let $x := fn:error() return true()" to resolve to one of the expected results, but got Error: XPST0017: Function fn:error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?, AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function fn:error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'.
xs-error-027,AssertionError: Expected executing the XPath "let $x as xs:error := 1 return fn:true()" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "let $x as xs:error := 1 return fn:true()". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $x [Error is around here]as xs:error := 1 return fn:true(), AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "let $x as xs:error := 1 return fn:true()".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\nlet $x [Error is around here]as xs:error := 1 return fn:true()'.
xs-error-028,Error: XPST0003: Unable to parse XPath: "(for $x as xs:error in () return fn:true()) => empty()". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. (for $x [Error is around here]as xs:error in () return fn:true()) => empty()
xs-error-029,AssertionError: Expected executing the XPath "for $x as xs:error in fn:error() return fn:true()" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "for $x as xs:error in fn:error() return fn:true()". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. for $x [Error is around here]as xs:error in fn:error() return fn:true(), AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0003: Unable to parse XPath: "for $x as xs:error in fn:error() return fn:true()".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\nfor $x [Error is around here]as xs:error in fn:error() return fn:true()'.
xs-error-030,AssertionError: Expected executing the XPath "for $x in fn:error() return fn:true()" to resolve to one of the expected results, but got Error: XPST0017: Function fn:error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?, AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function fn:error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'.
xs-error-031,AssertionError: Expected executing the XPath "for $x as xs:error in (1, 2, 3) return $x" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "for $x as xs:error in (1, 2, 3) return $x".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\nfor $x [Error is around here]as xs:error in (1, 2, 3) return $x'.
xs-error-036,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function fn:error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
xs-error-044,AssertionError: Expected executing the XPath "fn:error() instance of xs:error" to resolve to one of the expected results, but got Error: XPST0017: Function fn:error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?, AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function fn:error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'.
xs-error-045,AssertionError: Expected executing the XPath "typeswitch (xs:error(1))              case xs:error return fn:true()             default return false()" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "typeswitch (xs:error(1))              case xs:error return fn:true()             default return false()". Expected "!", "!=", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "(" found. typeswitch [Error is around here](xs:error(1))              case xs:error return fn:true()             default return false(), AssertionError: expected [Function] to throw error including 'FORG0001' but got 'XPST0003: Unable to parse XPath: "typeswitch (xs:error(1)) \n            case xs:error return fn:true()\n            default return false()".\nExpected "!", "!=", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "(" found.\ntypeswitch [Error is around here](xs:error(1)) \n            case xs:error return fn:true()\n            default return false()'.
xs-error-046,AssertionError: Expected executing the XPath "typeswitch (fn:error())              case xs:error return fn:true()             default return false()" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "typeswitch (fn:error())              case xs:error return fn:true()             default return false()". Expected "!", "!=", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "(" found. typeswitch [Error is around here](fn:error())              case xs:error return fn:true()             default return false(), AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0003: Unable to parse XPath: "typeswitch (fn:error()) \n            case xs:error return fn:true()\n            default return false()".\nExpected "!", "!=", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "(" found.\ntypeswitch [Error is around here](fn:error()) \n            case xs:error return fn:true()\n            default return false()'.
xs-error-047,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0003: Unable to parse XPath: "fn:error() treat as xs:error".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "t" found.\nfn:error() [Error is around here]treat as xs:error'
xs-error-048,AssertionError: expected [Function] to throw error including 'XPDY0050' but got 'XPST0003: Unable to parse XPath: "1 treat as xs:error".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "t" found.\n1 [Error is around here]treat as xs:error'
xs-error-049,Error: XPST0003: Unable to parse XPath: "(() treat as xs:error?) => empty()". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found. (() [Error is around here]treat as xs:error?) => empty()
xs-float-004,AssertionError: expected [Function] to throw an error
K-DayTimeDurationAdd-3,AssertionError: Expected XPath xs:dayTimeDuration("P3DT4H3M3.100S") + xs:dayTimeDuration("P3DT12H31M56.303S") eq xs:dayTimeDuration("P6DT16H34M59.403S") to resolve to true: expected false to be true
cbcl-plus-001,Error: Not implemented: adding durations to xs:date
cbcl-plus-003,Error: Not implemented: adding durations to xs:date
cbcl-plus-005,Error: Not implemented: adding durations to xs:dateTime
cbcl-plus-007,Error: Not implemented: adding durations to xs:dateTime
cbcl-plus-009,Error: Not implemented: adding durations to xs:time
cbcl-plus-015,Error: XPTY0004: + not available for types xs:dayTimeDuration and xs:date
cbcl-plus-017,Error: XPTY0004: + not available for types xs:yearMonthDuration and xs:date
cbcl-plus-019,Error: XPTY0004: + not available for types xs:dayTimeDuration and xs:dateTime
cbcl-plus-021,Error: XPTY0004: + not available for types xs:yearMonthDuration and xs:dateTime
cbcl-plus-023,Error: XPTY0004: + not available for types xs:dayTimeDuration and xs:time
cbcl-plus-031,AssertionError:          declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") };         local:f(false()) + local:f(false()): expected 'P2DT' to equal 'P2D'
K2-BooleanEqual-1,AssertionError: expected [Function] to throw an error
K2-BooleanEqual-2,AssertionError: expected [Function] to throw an error
K2-BooleanEqual-3,AssertionError: expected [Function] to throw an error
op-concatintg2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatintg2args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatintg2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatintg2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatintg2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatdec2args-1,AssertionError: (xs:decimal("-999999999999999999")||xs:decimal("-999999999999999999")): expected '-1000000000000000000-1000000000000000000' to equal '-999999999999999999-999999999999999999'
op-concatdec2args-2,AssertionError: (xs:decimal("617375191608514839")||xs:decimal("-999999999999999999")): expected '617375191608514800-1000000000000000000' to equal '617375191608514839-999999999999999999'
op-concatdec2args-3,AssertionError: (xs:decimal("999999999999999999")||xs:decimal("-999999999999999999")): expected '1000000000000000000-1000000000000000000' to equal '999999999999999999-999999999999999999'
op-concatdec2args-4,AssertionError: (xs:decimal("-999999999999999999")||xs:decimal("617375191608514839")): expected '-1000000000000000000617375191608514800' to equal '-999999999999999999617375191608514839'
op-concatdec2args-5,AssertionError: (xs:decimal("-999999999999999999")||xs:decimal("999999999999999999")): expected '-10000000000000000001000000000000000000' to equal '-999999999999999999999999999999999999'
op-concatlng2args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatlng2args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatlng2args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatlng2args-4,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatlng2args-5,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatnint2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatnint2args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatnint2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatnint2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatnint2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatpint2args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatpint2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatpint2args-4,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatpint2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatulng2args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatulng2args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatulng2args-4,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatulng2args-5,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatnpi2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatnpi2args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatnpi2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatnpi2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatnpi2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatnni2args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatnni2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatnni2args-4,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatnni2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
cbcl-date-equal-015,Error: XPST0017: Function adjust-date-to-timezone with arity of 1 not registered. No similar functions found.
cbcl-date-equal-016,Error: XPST0017: Function adjust-date-to-timezone with arity of 1 not registered. No similar functions found.
cbcl-date-greater-than-015,Error: XPST0017: Function adjust-date-to-timezone with arity of 1 not registered. No similar functions found.
cbcl-date-greater-than-016,Error: XPST0017: Function adjust-date-to-timezone with arity of 1 not registered. No similar functions found.
cbcl-date-less-than-015,Error: XPST0017: Function adjust-date-to-timezone with arity of 1 not registered. No similar functions found.
cbcl-date-less-than-016,Error: XPST0017: Function adjust-date-to-timezone with arity of 1 not registered. No similar functions found.
cbcl-dateTime-equal-015,Error: XPST0017: Function adjust-dateTime-to-timezone with arity of 1 not registered. No similar functions found.
cbcl-dateTime-equal-016,Error: XPST0017: Function adjust-dateTime-to-timezone with arity of 1 not registered. No similar functions found.
cbcl-dateTime-greater-than-015,Error: XPST0017: Function adjust-dateTime-to-timezone with arity of 1 not registered. No similar functions found.
cbcl-dateTime-greater-than-016,Error: XPST0017: Function adjust-dateTime-to-timezone with arity of 1 not registered. No similar functions found.
cbcl-dateTime-less-than-015,Error: XPST0017: Function adjust-dateTime-to-timezone with arity of 1 not registered. No similar functions found.
cbcl-dateTime-less-than-016,Error: XPST0017: Function adjust-dateTime-to-timezone with arity of 1 not registered. No similar functions found.
op-divide-dayTimeDuration2args-2,AssertionError: xs:dayTimeDuration("P15DT11H59M59S") div xs:double("-1.7976931348623157E308"): expected '-PT7.449541715597465e-303S' to equal 'PT0S'
op-divide-dayTimeDuration2args-3,AssertionError: xs:dayTimeDuration("P31DT23H59M59S") div xs:double("-1.7976931348623157E308"): expected '-PT1.5379704947317132e-302S' to equal 'PT0S'
cbcl-divide-dayTimeDuration-002,AssertionError: declare function local:dayTimeDuration($days as xs:integer) as xs:dayTimeDuration { xs:dayTimeDuration(concat("P", $days, "D")) }; local:dayTimeDuration(2) div 1: expected 'P2DT' to equal 'P2D'
op-divide-dayTimeDuration-by-dTD-1,AssertionError: Expected executing the XPath "fn:round-half-to-even((xs:dayTimeDuration("P2DT53M11S") div xs:dayTimeDuration("P1DT10H")),15)" to resolve to one of the expected results, but got AssertionError: Expected XPath fn:round-half-to-even((xs:dayTimeDuration("P2DT53M11S") div xs:dayTimeDuration("P1DT10H")),15) to resolve to 1.437834967320261: expected false to be true, AssertionError: Expected XPath fn:round-half-to-even((xs:dayTimeDuration("P2DT53M11S") div xs:dayTimeDuration("P1DT10H")),15) to resolve to 1.4378349673: expected false to be true.
cbcl-divide-yearMonthDuration-by-yearMonthDuration-001,AssertionError: expected [Function] to throw an error
distinct-duration-equal-1,AssertionError: Expected executing the XPath "fn:distinct-values((xs:yearMonthDuration('P0Y'), xs:dayTimeDuration('P0D')))" to resolve to one of the expected results, but got Error: XPST0017: Function fn:distinct-values with arity of 1 not registered. No similar functions found., Error: XPST0017: Function fn:distinct-values with arity of 1 not registered. No similar functions found..
distinct-duration-equal-2,AssertionError: Expected executing the XPath "fn:distinct-values((xs:yearMonthDuration('P1Y'), xs:dayTimeDuration('P365D')))" to resolve to one of the expected results, but got Error: XPST0017: Function fn:distinct-values with arity of 1 not registered. No similar functions found., Error: XPST0017: Function fn:distinct-values with arity of 1 not registered. No similar functions found..
fn-except-node-args-003,Error: XPST0017: Function root with arity of 1 not registered. No similar functions found.
K2-SeqExcept-18,Error: XPST0003: Unable to parse XPath: "count(<e/>/(a except attribute {"name"} {()}))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. count(<e/>/(a except attribute [Error is around here]{"name"} {()}))
K2-SeqExcept-19,Error: XPST0003: Unable to parse XPath: "count(<e/>/(a except attribute name {()}))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. count(<e/>/(a except attribute [Error is around here]name {()}))
K2-SeqExcept-20,AssertionError: Expected executing the XPath "count(<e/>/(a except element {"name"} {()}))" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "count(<e/>/(a except element {"name"} {()}))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. count(<e/>/(a except element [Error is around here]{"name"} {()})), AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "count(<e/>/(a except element {"name"} {()}))".\nExpected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.\ncount(<e/>/(a except element [Error is around here]{"name"} {()}))'.
K2-SeqExcept-21,AssertionError: Expected executing the XPath "count(<e/>/(a except element name {()}))" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "count(<e/>/(a except element name {()}))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. count(<e/>/(a except element [Error is around here]name {()})), AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "count(<e/>/(a except element name {()}))".\nExpected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.\ncount(<e/>/(a except element [Error is around here]name {()}))'.
K2-SeqExcept-22,Error: XPST0003: Unable to parse XPath: "count(<e/>/(a except processing-instruction {"name"} {()}))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. count(<e/>/(a except processing-instruction [Error is around here]{"name"} {()}))
K2-SeqExcept-23,Error: XPST0003: Unable to parse XPath: "count(<e/>/(a except processing-instruction name {}))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. count(<e/>/(a except processing-instruction [Error is around here]name {}))
K2-SeqExcept-24,Error: XPST0003: Unable to parse XPath: "count(<e/>/(a except comment {()}))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. count(<e/>/(a except comment [Error is around here]{()}))
K2-SeqExcept-25,Error: XPST0003: Unable to parse XPath: "count(<e/>/(a except text {()}))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. count(<e/>/(a except text [Error is around here]{()}))
combiningnodeseqexcepthc4,Error: XPST0003: Unable to parse XPath: "for $h in ( count((//hours) except (//hours))) order by number($h) return $h = 0". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. for $h in ( count((//hours) except (//hours))) [Error is around here]order by number($h) return $h = 0
combiningnodeseqexcepthc5,Error: XPST0003: Unable to parse XPath: "for $h in ( count(($works//hours) except ($staff//grade,$works//hours))) order by number($h) return $h = 0". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. for $h in ( count(($works//hours) except ($staff//grade,$works//hours))) [Error is around here]order by number($h) return $h = 0
combiningnodeseqexcepthc6,Error: XPST0003: Unable to parse XPath: "for $h in ( ($works//hours) except ($staff//grade)) order by number($h) return $h". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. for $h in ( ($works//hours) except ($staff//grade)) [Error is around here]order by number($h) return $h
K-HexBinaryEQ-1,AssertionError: Expected XPath xs:hexBinary("FF") eq xs:hexBinary("ff") to resolve to true: expected false to be true
K-HexBinaryEQ-4,AssertionError: Expected XPath xs:hexBinary(xs:base64Binary(xs:hexBinary("03"))) eq xs:hexBinary("03") to resolve to true: expected false to be true
fn-intersect-node-args-003,Error: XPST0017: Function root with arity of 1 not registered. No similar functions found.
K2-SeqIntersect-18,Error: XPST0003: Unable to parse XPath: "empty(<e/>/(a intersect attribute {"name"} {()}))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. empty(<e/>/(a intersect attribute [Error is around here]{"name"} {()}))
K2-SeqIntersect-19,Error: XPST0003: Unable to parse XPath: "empty(<e/>/(a intersect attribute name {()}))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. empty(<e/>/(a intersect attribute [Error is around here]name {()}))
K2-SeqIntersect-20,AssertionError: Expected executing the XPath "empty(<e/>/(a intersect element {"name"} {()}))" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "empty(<e/>/(a intersect element {"name"} {()}))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. empty(<e/>/(a intersect element [Error is around here]{"name"} {()})), AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "empty(<e/>/(a intersect element {"name"} {()}))".\nExpected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.\nempty(<e/>/(a intersect element [Error is around here]{"name"} {()}))'.
K2-SeqIntersect-21,AssertionError: Expected executing the XPath "empty(<e/>/(a intersect element name {()}))" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "empty(<e/>/(a intersect element name {()}))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. empty(<e/>/(a intersect element [Error is around here]name {()})), AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "empty(<e/>/(a intersect element name {()}))".\nExpected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.\nempty(<e/>/(a intersect element [Error is around here]name {()}))'.
K2-SeqIntersect-22,Error: XPST0003: Unable to parse XPath: "empty(<e/>/(a intersect processing-instruction {"name"} {()}))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. empty(<e/>/(a intersect processing-instruction [Error is around here]{"name"} {()}))
K2-SeqIntersect-23,Error: XPST0003: Unable to parse XPath: "empty(<e/>/(a intersect processing-instruction name {}))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. empty(<e/>/(a intersect processing-instruction [Error is around here]name {}))
K2-SeqIntersect-24,Error: XPST0003: Unable to parse XPath: "empty(<e/>/(a intersect comment {()}))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. empty(<e/>/(a intersect comment [Error is around here]{()}))
K2-SeqIntersect-25,Error: XPST0003: Unable to parse XPath: "empty(<e/>/(a intersect text {()}))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. empty(<e/>/(a intersect text [Error is around here]{()}))
K2-SeqIntersect-42,Error: XPST0003: Unable to parse XPath: "          declare function local:function ($c as node()) { $c intersect $c };           empty(local:function(document{()}))       ". Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found.           declare function local:function ($c as node()) { $c intersect $c };           empty(local:function(document[Error is around here]{()}))
combiningnodeseqintersecthc3,Error: XPST0003: Unable to parse XPath: "for $h in ( (//hours) intersect (//hours[xs:integer(.) gt 12])) order by number($h) return $h". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. for $h in ( (//hours) intersect (//hours[xs:integer(.) gt 12])) [Error is around here]order by number($h) return $h
combiningnodeseqintersecthc4,Error: XPST0003: Unable to parse XPath: "for $h in ( ($works//hours) intersect ($works//hours, $staff//grade)) order by number($h) return $h". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. for $h in ( ($works//hours) intersect ($works//hours, $staff//grade)) [Error is around here]order by number($h) return $h
K2-NodeSame-1,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-NodeSame-2,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-NodeSame-3,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-NodeSame-4,Error: XPST0003: Unable to parse XPath: "declare variable $e := attribute name {()}; $e is $e, <is/> is <is/>". Expected "!", "!=", "(", "*", "+", "-", "/", "//", ";", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. declare variable $e := attribute [Error is around here]name {()}; $e is $e, <is/> is <is/>
K-DayTimeDurationMultiply-1,AssertionError: Expected XPath xs:dayTimeDuration("P3DT4H3M3.100S") * 3 eq xs:dayTimeDuration("P9DT12H9M9.3S") to resolve to true: expected false to be true
K-DayTimeDurationMultiply-2,AssertionError: Expected XPath 3 * xs:dayTimeDuration("P3DT4H3M3.100S") eq xs:dayTimeDuration("P9DT12H9M9.3S") to resolve to true: expected false to be true
cbcl-multiply-dayTimeDuration-002,AssertionError: declare function local:dayTimeDuration($days as xs:integer) as xs:dayTimeDuration { xs:dayTimeDuration(concat("P", $days, "D")) }; local:dayTimeDuration(2) * 1: expected 'P2DT' to equal 'P2D'
cbcl-multiply-dayTimeDuration-005,AssertionError: declare function local:dayTimeDuration($days as xs:integer) as xs:dayTimeDuration { xs:dayTimeDuration(concat("P", $days, "D")) }; 1 * local:dayTimeDuration(2): expected 'P2DT' to equal 'P2D'
cbcl-times-003,AssertionError:          declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("P1D") };         local:f(false()) * 2: expected 'P2DT' to equal 'P2D'
cbcl-times-007,AssertionError:          declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("P1D") };         2 * local:f(false()): expected 'P2DT' to equal 'P2D'
K-NodeBefore-12,Error: XPST0003: Unable to parse XPath: "    let $doc :=     <catalog>        <product dept="WMN">         <number>557</number>         <name language="en">Fleece Pullover</name>         <colorChoices>navy black</colorChoices>        </product>        <product dept="ACC">         <number>563</number>         <name language="en">Floppy Sun Hat</name>        </product>        <product dept="ACC">         <number>443</number>         <name language="en">Deluxe Travel Bag</name>        </product>        <product dept="MEN">         <number>784</number>         <name language="en">Cotton Dress Shirt</name>         <colorChoices>white gray</colorChoices>         <desc>Our <i>favorite</i> shirt!</desc>        </product>    </catalog>    let $prods := $doc//product    for $prod in $prods    where $prod << $prods[@dept = $prod/@dept][last()]    return $prod". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.     let $doc :=     <catalog>        <product dept="WMN">         <number>557</number>         <name language="en">Fleece Pullover</name>         <colorChoices>navy black</colorChoices>        </product>        <product dept="ACC">         <number>563</number>         <name language="en">Floppy Sun Hat</name>        </product>        <product dept="ACC">         <number>443</number>         <name language="en">Deluxe Travel Bag</name>        </product>        <product dept="MEN">         <number>784</number>         <name language="en">Cotton Dress Shirt</name>         <colorChoices>white gray</colorChoices>         <desc>Our <i>favorite</i> shirt!</desc>        </product>    </catalog>    [Error is around here]let $prods := $doc//product    for $prod in $prods    where $prod << $prods[@dept = $prod/@dept][last()]    return $prod
op-numeric-addintg2args-1,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addintg2args-2,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addintg2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addintg2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addlng2args-1,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addlng2args-2,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addlng2args-3,Error: FOCA0003: can not cast -45058158165499290 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addlng2args-4,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addnint2args-1,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addnint2args-2,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addnint2args-3,Error: FOCA0003: can not cast -702985924000903206 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addnint2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addpint2args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addpint2args-3,Error: FOCA0003: can not cast 999999999999999998 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addpint2args-4,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addpint2args-5,Error: FOCA0003: can not cast 999999999999999998 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addulng2args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addulng2args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addulng2args-4,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addulng2args-5,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addnpi2args-1,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addnpi2args-2,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addnpi2args-3,Error: FOCA0003: can not cast -524311562728129509 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addnpi2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addnni2args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addnni2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addnni2args-4,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addnni2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-NumericAdd-4,AssertionError: Expected XPath 1.1 + 2.2 eq 3.3 to resolve to true: expected false to be true
K-NumericAdd-17,AssertionError: Expected XPath (xs:decimal(6) + xs:float(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericAdd-18,AssertionError: Expected XPath (xs:float(6) + xs:decimal(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericAdd-19,AssertionError: Expected XPath (xs:float(6) + xs:integer(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericAdd-20,AssertionError: Expected XPath (xs:integer(6) + xs:float(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericAdd-22,AssertionError: Expected XPath (xs:decimal(6) + xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericAdd-23,AssertionError: Expected XPath (xs:double(6) + xs:decimal(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericAdd-24,AssertionError: Expected XPath (xs:double(6) + xs:float(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericAdd-25,AssertionError: Expected XPath (xs:float(6) + xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericAdd-26,AssertionError: Expected XPath (xs:double(6) + xs:integer(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericAdd-27,AssertionError: Expected XPath (xs:integer(6) + xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericAdd-31,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
K-NumericAdd-32,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
K-NumericAdd-33,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
K-NumericAdd-34,AssertionError: Expected executing the XPath "(4, error()) + 3" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?', AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'.
K-NumericAdd-35,AssertionError: Expected executing the XPath "3 + (4, error())" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?', AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'.
K-NumericAdd-36,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
K-NumericAdd-41,AssertionError: Expected executing the XPath "error() + 3" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?', AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'.
K-NumericAdd-42,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
K-NumericAdd-60,AssertionError: Expected XPath (xs:untypedAtomic("3") + 3) instance of xs:double to resolve to true: expected false to be true
op-numeric-add-1,Error: XPST0003: Unable to parse XPath: "let $result := (          for $x in (1, xs:decimal(2), xs:float(3), xs:double(4), xs:untypedAtomic(5))           for $y in (1, xs:decimal(2), xs:float(3), xs:double(4), xs:untypedAtomic(5))          return ($x + $y)       ) return $result[1] instance of xs:integer". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found. let $result := (          for $x in (1, xs:decimal(2), xs:float(3), xs:double(4), xs:untypedAtomic(5))           [Error is around here]for $y in (1, xs:decimal(2), xs:float(3), xs:double(4), xs:untypedAtomic(5))          return ($x + $y)       ) return $result[1] instance of xs:integer
op-numeric-equalintg2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalintg2args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalintg2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalintg2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalintg2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalintg2args-6,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalintg2args-7,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalintg2args-8,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalintg2args-9,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalintg2args-10,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equallng2args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equallng2args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equallng2args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equallng2args-4,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equallng2args-5,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equallng2args-6,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equallng2args-7,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equallng2args-8,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equallng2args-9,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equallng2args-10,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnint2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnint2args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnint2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnint2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnint2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnint2args-6,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnint2args-7,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnint2args-8,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnint2args-9,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnint2args-10,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalpint2args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalpint2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalpint2args-4,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalpint2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalpint2args-7,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalpint2args-8,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalpint2args-9,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalpint2args-10,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalulng2args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalulng2args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalulng2args-4,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalulng2args-5,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalulng2args-7,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalulng2args-8,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalulng2args-9,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalulng2args-10,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnpi2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnpi2args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnpi2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnpi2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnpi2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnpi2args-6,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnpi2args-7,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnpi2args-8,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnpi2args-9,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnpi2args-10,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnni2args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnni2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnni2args-4,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnni2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnni2args-7,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnni2args-8,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnni2args-9,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnni2args-10,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K2-NumericEqual-5,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "1 eq text {"1"}".\nExpected "!", "(", "*", "+", ",", "-", "/", "//", "=>", "and", "cast", "castable", "div", "except", "idiv", "instance", "intersect", "mod", "or", "to", "union", "|", "||", or end of input but "{" found.\n1 eq text [Error is around here]{"1"}'
K2-NumericEqual-6,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "text {"1"} eq 1".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\ntext [Error is around here]{"1"} eq 1'
op-numeric-divideintg2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-divideintg2args-2,AssertionError: Expected executing the XPath "fn:round-half-to-even((xs:integer("830993497117024304") div xs:integer("-999999999999999999")),18)" to resolve to one of the expected results, but got Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers..
op-numeric-divideintg2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-divideintg2args-4,AssertionError: Expected executing the XPath "fn:round-half-to-even((xs:integer("-999999999999999999") div xs:integer("830993497117024304")),18)" to resolve to one of the expected results, but got Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers..
op-numeric-divideintg2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-divideintg2args-6,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-dividelng2args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-dividelng2args-2,AssertionError: Expected executing the XPath "fn:round-half-to-even((xs:long("-47175562203048468") div xs:long("-92233720368547758")),17)" to resolve to one of the expected results, but got Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers..
op-numeric-dividelng2args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-dividelng2args-4,AssertionError: Expected executing the XPath "fn:round-half-to-even((xs:long("-92233720368547758") div xs:long("-47175562203048468")),17)" to resolve to one of the expected results, but got Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers..
op-numeric-dividelng2args-5,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-dividenint2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-dividenint2args-2,AssertionError: Expected executing the XPath "fn:round-half-to-even((xs:negativeInteger("-297014075999096793") div xs:negativeInteger("-999999999999999999")),18)" to resolve to one of the expected results, but got Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers..
op-numeric-dividenint2args-3,AssertionError: Expected executing the XPath "xs:negativeInteger("-1") div xs:negativeInteger("-999999999999999999")" to resolve to one of the expected results, but got Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers..
op-numeric-dividenint2args-4,AssertionError: Expected executing the XPath "fn:round-half-to-even((xs:negativeInteger("-999999999999999999") div xs:negativeInteger("-297014075999096793")),18)" to resolve to one of the expected results, but got Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers..
op-numeric-dividenint2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-dividepint2args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-dividepint2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-dividepint2args-4,AssertionError: Expected executing the XPath "fn:round-half-to-even((xs:positiveInteger("1") div xs:positiveInteger("52704602390610033")),17)" to resolve to one of the expected results, but got Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers..
op-numeric-dividepint2args-5,AssertionError: Expected executing the XPath "xs:positiveInteger("1") div xs:positiveInteger("999999999999999999")" to resolve to one of the expected results, but got Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers..
op-numeric-divideulng2args-1,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-divideulng2args-2,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-dividenpi2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-dividenpi2args-2,AssertionError: Expected executing the XPath "fn:round-half-to-even((xs:nonPositiveInteger("-475688437271870490") div xs:nonPositiveInteger("-999999999999999999")),18)" to resolve to one of the expected results, but got Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers..
op-numeric-dividenpi2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-dividenpi2args-4,AssertionError: Expected executing the XPath "fn:round-half-to-even((xs:nonPositiveInteger("-999999999999999999") div xs:nonPositiveInteger("-475688437271870490")),18)" to resolve to one of the expected results, but got Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers..
op-numeric-dividenni2args-1,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-dividenni2args-2,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-NumericDivide-20,AssertionError: Expected XPath (xs:float(6) div xs:decimal(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericDivide-21,AssertionError: Expected XPath (xs:decimal(6) div xs:float(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericDivide-22,AssertionError: Expected XPath (xs:float(6) div xs:integer(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericDivide-23,AssertionError: Expected XPath (xs:integer(6) div xs:float(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericDivide-24,AssertionError: Expected XPath (xs:float(6) div xs:float(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericDivide-25,AssertionError: Expected XPath (xs:decimal(6) div xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericDivide-26,AssertionError: Expected XPath (xs:double(6) div xs:decimal(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericDivide-27,AssertionError: Expected XPath (xs:double(6) div xs:float(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericDivide-28,AssertionError: Expected XPath (xs:float(6) div xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericDivide-29,AssertionError: Expected XPath (xs:double(6) div xs:integer(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericDivide-30,AssertionError: Expected XPath (xs:integer(6) div xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericDivide-31,AssertionError: Expected XPath (xs:double(6) div xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K2-NumericDivide-1,AssertionError: expected [Function] to throw an error
K2-NumericDivide-2,AssertionError: expected [Function] to throw an error
K2-NumericDivide-3,AssertionError: expected [Function] to throw an error
K2-NumericDivide-4,AssertionError: expected [Function] to throw an error
K2-NumericDivide-5,AssertionError: 1 div 0e0: expected 'Infinity' to equal 'INF'
K2-NumericDivide-6,AssertionError: -1 div 0e0: expected '-Infinity' to equal '-INF'
K2-NumericDivide-7,AssertionError: 1 div xs:float(0): expected 'Infinity' to equal 'INF'
K2-NumericDivide-8,AssertionError: -1 div xs:float(0): expected '-Infinity' to equal '-INF'
K2-NumericDivide-13,AssertionError: +3 div +0e0: expected 'Infinity' to equal 'INF'
K2-NumericDivide-14,AssertionError: -3 div +0e0: expected '-Infinity' to equal '-INF'
K2-NumericDivide-15,AssertionError: +3 div -0e0: expected '-Infinity' to equal '-INF'
K2-NumericDivide-16,AssertionError: -3 div -0e0: expected 'Infinity' to equal 'INF'
op-numeric-divide-1,Error: XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
cbcl-numeric-divide-009,AssertionError: expected [Function] to throw an error
cbcl-numeric-divide-012,AssertionError: expected [Function] to throw an error
op-numeric-divide-big-01,AssertionError: Expected executing the XPath "(10000000000000000000000000000.0 div 0.1) cast as xs:string" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw an error, AssertionError: (10000000000000000000000000000.0 div 0.1) cast as xs:string: expected '1E+29' to equal '100000000000000000000000000000'.
op-numeric-greater-thanintg2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thanintg2args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thanintg2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thanintg2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thanintg2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thanlng2args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thanlng2args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thanlng2args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thanlng2args-4,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thanlng2args-5,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thannint2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thannint2args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thannint2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thannint2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thannint2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thanpint2args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thanpint2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thanpint2args-4,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thanpint2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thanulng2args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thanulng2args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thanulng2args-4,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thanulng2args-5,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thannpi2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thannpi2args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thannpi2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thannpi2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thannpi2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thannni2args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thannni2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thannni2args-4,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thannni2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K2-NumericGT-1,Error: FOCA0003: can not cast 18446744073709551615 to xs:integer, it is out of bounds for JavaScript numbers.
K2-NumericGT-2,Error: FOCA0003: can not cast 18446744073709551615 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-divideintg2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-divideintg2args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-divideintg2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-divideintg2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-divideintg2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividelng2args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividelng2args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividelng2args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividelng2args-4,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividelng2args-5,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividenint2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividenint2args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividenint2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividenint2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividenint2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividepint2args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividepint2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividepint2args-4,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividepint2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-divideulng2args-1,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-divideulng2args-2,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividenpi2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividenpi2args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividenpi2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividenpi2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividenni2args-1,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividenni2args-2,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
cbcl-numeric-idivide-002,AssertionError: Expected executing the XPath "       	declare function local:square($arg as xs:double) as xs:double { $arg * $arg };        	local:square(1e100) idiv 5e-100" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw an error, Error: XPST0003: Unable to parse XPath: "(       	declare function local:square($arg as xs:double) as xs:double { $arg * $arg };        	local:square(1e100) idiv 5e-100) instance of xs:integer". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found. (       	declare [Error is around here]function local:square($arg as xs:double) as xs:double { $arg * $arg };        	local:square(1e100) idiv 5e-100) instance of xs:integer.
cbcl-numeric-idivide-003,AssertionError: expected [Function] to throw an error
cbcl-numeric-idivide-008,AssertionError: Expected executing the XPath "xs:float('1e38') idiv xs:float('1e-37')" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw an error, AssertionError: expected [Function] to throw an error, Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found..
op-numeric-less-thanintg2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanintg2args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanintg2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanintg2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanintg2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanintg2args-6,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanintg2args-7,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanintg2args-8,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanintg2args-9,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanintg2args-10,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanlng2args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanlng2args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanlng2args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanlng2args-4,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanlng2args-5,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanlng2args-6,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanlng2args-7,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanlng2args-8,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanlng2args-9,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanlng2args-10,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannint2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannint2args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannint2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannint2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannint2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannint2args-6,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannint2args-7,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannint2args-8,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannint2args-9,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannint2args-10,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanpint2args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanpint2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanpint2args-4,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanpint2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanpint2args-7,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanpint2args-8,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanpint2args-9,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanpint2args-10,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanulng2args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanulng2args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanulng2args-4,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanulng2args-5,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanulng2args-7,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanulng2args-8,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanulng2args-9,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanulng2args-10,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannpi2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannpi2args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannpi2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannpi2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannpi2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannpi2args-6,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannpi2args-7,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannpi2args-8,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannpi2args-9,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannpi2args-10,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannni2args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannni2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannni2args-4,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannni2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannni2args-7,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannni2args-8,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannni2args-9,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannni2args-10,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K2-NumericLT-1,Error: FOCA0003: can not cast 18446744073709551615 to xs:integer, it is out of bounds for JavaScript numbers.
K2-NumericLT-2,Error: FOCA0003: can not cast 18446744073709551615 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-modintg2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-modintg2args-2,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-modlng2args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-modpint2args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-modpint2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-modpint2args-4,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-modpint2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-modulng2args-1,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-modulng2args-2,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-modnni2args-1,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-modnni2args-2,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-NumericMod-3,AssertionError: Expected XPath (xs:integer(6) mod xs:integer(2)) instance of xs:integer to resolve to true: expected false to be true
K-NumericMod-5,AssertionError: Expected XPath (xs:decimal(6) mod xs:float(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericMod-6,AssertionError: Expected XPath (xs:float(6) mod xs:decimal(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericMod-7,AssertionError: Expected XPath (xs:float(6) mod xs:integer(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericMod-8,AssertionError: Expected XPath (xs:integer(6) mod xs:float(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericMod-9,AssertionError: Expected XPath (xs:float(6) mod xs:float(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericMod-10,AssertionError: Expected XPath (xs:decimal(6) mod xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericMod-11,AssertionError: Expected XPath (xs:double(6) mod xs:decimal(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericMod-12,AssertionError: Expected XPath (xs:double(6) mod xs:float(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericMod-13,AssertionError: Expected XPath (xs:float(6) mod xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericMod-14,AssertionError: Expected XPath (xs:double(6) mod xs:integer(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericMod-15,AssertionError: Expected XPath (xs:integer(6) mod xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericMod-16,AssertionError: Expected XPath (xs:double(6) mod xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericMod-19,AssertionError: Expected XPath 4.5 mod 1.2 eq 0.9 to resolve to true: expected false to be true
K2-NumericMod-59,AssertionError: expected [Function] to throw an error
K2-NumericMod-60,AssertionError: expected [Function] to throw an error
K2-NumericMod-61,AssertionError: expected [Function] to throw an error
op-numeric-mod-1,Error: XPST0003: Unable to parse XPath: "let $result := (          for $x in (1, xs:decimal(2), xs:float(3), xs:double(4), xs:untypedAtomic(5))           for $y in (1, xs:decimal(2), xs:float(3), xs:double(4), xs:untypedAtomic(5))          return ($x mod $y)       ) return $result[1] instance of xs:integer". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found. let $result := (          for $x in (1, xs:decimal(2), xs:float(3), xs:double(4), xs:untypedAtomic(5))           [Error is around here]for $y in (1, xs:decimal(2), xs:float(3), xs:double(4), xs:untypedAtomic(5))          return ($x mod $y)       ) return $result[1] instance of xs:integer
cbcl-numeric-mod-001,AssertionError: Expected XPath        	declare function local:integer($x as xs:decimal) { if ($x mod 1 eq 0) then xs:integer($x) else $x };        	(local:integer(3) mod local:integer(2)) instance of xs:integer to resolve to true: expected false to be true
op-numeric-multiplypint2args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-multiplypint2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-multiplypint2args-4,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-multiplypint2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-multiplyulng2args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-multiplyulng2args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-multiplyulng2args-4,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-multiplyulng2args-5,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-multiplynpi2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-multiplynpi2args-2,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-multiplynni2args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-multiplynni2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-multiplynni2args-4,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-multiplynni2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-NumericMultiply-9,AssertionError: Expected XPath (xs:decimal(6) * xs:float(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericMultiply-10,AssertionError: Expected XPath (xs:float(6) * xs:decimal(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericMultiply-11,AssertionError: Expected XPath (xs:float(6) * xs:integer(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericMultiply-12,AssertionError: Expected XPath (xs:integer(6) * xs:float(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericMultiply-14,AssertionError: Expected XPath (xs:decimal(6) * xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericMultiply-15,AssertionError: Expected XPath (xs:double(6) * xs:decimal(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericMultiply-16,AssertionError: Expected XPath (xs:double(6) * xs:float(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericMultiply-17,AssertionError: Expected XPath (xs:float(6) * xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericMultiply-18,AssertionError: Expected XPath (xs:double(6) * xs:integer(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericMultiply-19,AssertionError: Expected XPath (xs:integer(6) * xs:double(2)) instance of xs:double to resolve to true: expected false to be true
op-numeric-multiply-1,Error: XPST0003: Unable to parse XPath: "let $result := (          for $x in (1, xs:decimal(2), xs:float(3), xs:double(4), xs:untypedAtomic(5))           for $y in (1, xs:decimal(2), xs:float(3), xs:double(4), xs:untypedAtomic(5))          return ($x * $y)       ) return $result[1] instance of xs:integer". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found. let $result := (          for $x in (1, xs:decimal(2), xs:float(3), xs:double(4), xs:untypedAtomic(5))           [Error is around here]for $y in (1, xs:decimal(2), xs:float(3), xs:double(4), xs:untypedAtomic(5))          return ($x * $y)       ) return $result[1] instance of xs:integer
op-numeric-subtractintg2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractintg2args-2,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractintg2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractintg2args-4,Error: FOCA0003: can not cast -169006502882975695 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractintg2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractlng2args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractlng2args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractlng2args-3,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractlng2args-4,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractlng2args-5,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractnint2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractnint2args-2,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractpint2args-1,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractpint2args-2,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractpint2args-3,Error: FOCA0003: can not cast 52704602390610034 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractulng2args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractulng2args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractulng2args-4,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractulng2args-5,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractnpi2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractnpi2args-2,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractnpi2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractnpi2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractnpi2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractnni2args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractnni2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractnni2args-4,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractnni2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-NumericSubtract-9,AssertionError: Expected XPath (xs:decimal(6) - xs:float(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericSubtract-10,AssertionError: Expected XPath (xs:float(6) - xs:decimal(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericSubtract-11,AssertionError: Expected XPath (xs:float(6) - xs:integer(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericSubtract-12,AssertionError: Expected XPath (xs:integer(6) - xs:float(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericSubtract-14,AssertionError: Expected XPath (xs:decimal(6) - xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericSubtract-15,AssertionError: Expected XPath (xs:double(6) - xs:decimal(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericSubtract-16,AssertionError: Expected XPath (xs:double(6) - xs:float(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericSubtract-17,AssertionError: Expected XPath (xs:float(6) - xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericSubtract-18,AssertionError: Expected XPath (xs:double(6) - xs:integer(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericSubtract-19,AssertionError: Expected XPath (xs:integer(6) - xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericSubtract-34,AssertionError: Expected XPath (xs:untypedAtomic("3") - 1.1) instance of xs:double to resolve to true: expected false to be true
K-NumericSubtract-35,AssertionError: Expected XPath (1.1 - xs:untypedAtomic("3")) instance of xs:double to resolve to true: expected false to be true
op-numeric-subtract-1,Error: XPST0003: Unable to parse XPath: "let $result := (          for $x in (1, xs:decimal(2), xs:float(3), xs:double(4), xs:untypedAtomic(5))           for $y in (1, xs:decimal(2), xs:float(3), xs:double(4), xs:untypedAtomic(5))          return ($x - $y)       ) return $result[1] instance of xs:integer". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found. let $result := (          for $x in (1, xs:decimal(2), xs:float(3), xs:double(4), xs:untypedAtomic(5))           [Error is around here]for $y in (1, xs:decimal(2), xs:float(3), xs:double(4), xs:untypedAtomic(5))          return ($x - $y)       ) return $result[1] instance of xs:integer
op-numeric-subtract-big-01,AssertionError: Expected executing the XPath "(-79228162514264337593543950335.0 - 1.0) cast as xs:string" to resolve to one of the expected results, but got AssertionError: (-79228162514264337593543950335.0 - 1.0) cast as xs:string: expected '-7.922816251426434E+28' to equal '-79228162514264337593543950336', AssertionError: expected [Function] to throw an error.
op-numeric-unary-minusintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-minusintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-minusintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-minuslng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-minuslng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-minuslng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-minusnint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-minusnint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-minuspint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-minuspint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-minusulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-minusulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-minusnpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-minusnpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-minusnni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-minusnni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-NumericUnaryMinus-1,AssertionError: expected [Function] to throw an error
K2-NumericUnaryMinus-8,Error: XPST0003: Unable to parse XPath: "empty(document{()}/(-element()))". Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. empty(document[Error is around here]{()}/(-element()))
op-numeric-unary-plusintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-plusintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-plusintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-pluslng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-pluslng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-pluslng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-plusnint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-plusnint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-pluspint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-pluspint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-plusulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-plusulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-plusnpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-plusnpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-plusnni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-plusnni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-NumericUnaryPlus-1,AssertionError: expected [Function] to throw an error
K2-NumericUnaryPlus-1,Error: XPST0003: Unable to parse XPath: "empty(document{()}/(+element()))". Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. empty(document[Error is around here]{()}/(+element()))
K2-StringEqual-1,Error: XPST0003: Unable to parse XPath: "declare variable $vA as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string; declare variable $vB as xs:string := ("b string", current-time(), string(<e>content</e>))[1] treat as xs:string; (lower-case($vA) eq lower-case($vB))". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $vA [Error is around here]as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string; declare variable $vB as xs:string := ("b string", current-time(), string(<e>content</e>))[1] treat as xs:string; (lower-case($vA) eq lower-case($vB))
K2-StringEqual-2,Error: XPST0003: Unable to parse XPath: "declare variable $vA as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string; declare variable $vB as xs:string := ("b string", current-time(), string(<e>content</e>))[1] treat as xs:string; (upper-case($vA) eq upper-case($vB))". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $vA [Error is around here]as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string; declare variable $vB as xs:string := ("b string", current-time(), string(<e>content</e>))[1] treat as xs:string; (upper-case($vA) eq upper-case($vB))
K2-StringEqual-3,Error: XPST0003: Unable to parse XPath: "declare variable $vA as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string; declare variable $vB as xs:string := ("no match", current-time(), string(<e>content</e>))[1] treat as xs:string; (lower-case($vA) eq lower-case($vB))". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $vA [Error is around here]as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string; declare variable $vB as xs:string := ("no match", current-time(), string(<e>content</e>))[1] treat as xs:string; (lower-case($vA) eq lower-case($vB))
K2-StringEqual-4,Error: XPST0003: Unable to parse XPath: "declare variable $vA as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string; declare variable $vB as xs:string := ("no match", current-time(), string(<e>content</e>))[1] treat as xs:string; (upper-case($vA) eq upper-case($vB))". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $vA [Error is around here]as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string; declare variable $vB as xs:string := ("no match", current-time(), string(<e>content</e>))[1] treat as xs:string; (upper-case($vA) eq upper-case($vB))
K2-StringEqual-5,Error: XPST0003: Unable to parse XPath: "declare variable $vA as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string; declare variable $vB as xs:string := ("b string", current-time(), string(<e>content</e>))[1] treat as xs:string; (upper-case($vA) eq lower-case($vB))". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $vA [Error is around here]as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string; declare variable $vB as xs:string := ("b string", current-time(), string(<e>content</e>))[1] treat as xs:string; (upper-case($vA) eq lower-case($vB))
K2-StringEqual-6,Error: XPST0003: Unable to parse XPath: "         declare variable $vA as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string;          declare variable $vB as xs:string := ("b string", current-time(), string(<e>content</e>))[1] treat as xs:string;          (lower-case($vA) eq upper-case($vB))       ". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.          declare variable $vA [Error is around here]as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string;          declare variable $vB as xs:string := ("b string", current-time(), string(<e>content</e>))[1] treat as xs:string;          (lower-case($vA) eq upper-case($vB))
K2-StringLT-1,AssertionError: Expected XPath "" lt "𑅰" to resolve to true: expected false to be true
K2-DayTimeDurationSubtract-1,Error: Not implemented: subtracting durations from xs:time
K2-DayTimeDurationSubtract-2,Error: Not implemented: subtracting durations from xs:dateTime
cbcl-minus-001,Error: Not implemented: subtracting durations from xs:date
cbcl-minus-003,Error: Not implemented: subtracting durations from xs:date
cbcl-minus-005,Error: Not implemented: subtracting durations from xs:dateTime
cbcl-minus-007,Error: Not implemented: subtracting durations from xs:dateTime
cbcl-minus-009,Error: Not implemented: subtracting durations from xs:time
rangeExpr-28,AssertionError: Expected executing the XPath "18446744073709551616 to 18446744073709551620" to resolve to one of the expected results, but got AssertionError: 18446744073709551616 to 18446744073709551620: expected '18446744073709552000' to equal '18446744073709551616 18446744073709551617 18446744073709551618 18446744073709551619 18446744073709551620', AssertionError: expected [Function] to throw an error.
rangeExpr-29,AssertionError: Expected executing the XPath "count(18446744073709551616 to 18446744073709551620)" to resolve to one of the expected results, but got AssertionError: Expected XPath count(18446744073709551616 to 18446744073709551620) to resolve to 5: expected false to be true, AssertionError: expected [Function] to throw an error.
rangeExpr-30,AssertionError: Expected executing the XPath "(28446744073709551616 to 28446744073709551620)!position()" to resolve to one of the expected results, but got AssertionError: (28446744073709551616 to 28446744073709551620)!position(): expected '1' to equal '1 2 3 4 5', AssertionError: expected [Function] to throw an error.
rangeExpr-31,AssertionError: Expected executing the XPath "((28446744073709551616 to 28446744073709551620)!last())[1]" to resolve to one of the expected results, but got AssertionError: Expected XPath ((28446744073709551616 to 28446744073709551620)!last())[1] to resolve to 5: expected false to be true, AssertionError: expected [Function] to throw an error.
rangeExpr-32,AssertionError: Expected executing the XPath "reverse(28446744073709551616 to 28446744073709551620)" to resolve to one of the expected results, but got AssertionError: reverse(28446744073709551616 to 28446744073709551620): expected '28446744073709550000' to equal '28446744073709551620 28446744073709551619 28446744073709551618 28446744073709551617 28446744073709551616', AssertionError: expected [Function] to throw an error.
K-RangeExpr-31,Error: XPST0003: Unable to parse XPath: "(remove((2.e0, 4), 1) treat as xs:integer to 4)". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found. (remove((2.e0, 4), 1) [Error is around here]treat as xs:integer to 4)
K-RangeExpr-32,Error: XPST0003: Unable to parse XPath: "(4 to remove((2e0, 4), 1) treat as xs:integer)". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "union", "|", or "||" but "t" found. (4 to remove((2e0, 4), 1) [Error is around here]treat as xs:integer)
fn-union-node-args-003,Error: XPST0017: Function root with arity of 1 not registered. No similar functions found.
K2-SeqUnion-22,Error: XPST0003: Unable to parse XPath: "empty(<e/>/(a union attribute {"name"} {()}))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. empty(<e/>/(a union attribute [Error is around here]{"name"} {()}))
K2-SeqUnion-23,Error: XPST0003: Unable to parse XPath: "empty(<e/>/(a union attribute name {()}))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. empty(<e/>/(a union attribute [Error is around here]name {()}))
K2-SeqUnion-24,AssertionError: Expected executing the XPath "empty(<e/>/(a union element {"name"} {()}))" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "empty(<e/>/(a union element {"name"} {()}))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. empty(<e/>/(a union element [Error is around here]{"name"} {()})), AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "empty(<e/>/(a union element {"name"} {()}))".\nExpected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.\nempty(<e/>/(a union element [Error is around here]{"name"} {()}))'.
K2-SeqUnion-25,AssertionError: Expected executing the XPath "empty(<e/>/(a union element name {()}))" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "empty(<e/>/(a union element name {()}))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. empty(<e/>/(a union element [Error is around here]name {()})), AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "empty(<e/>/(a union element name {()}))".\nExpected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.\nempty(<e/>/(a union element [Error is around here]name {()}))'.
K2-SeqUnion-26,Error: XPST0003: Unable to parse XPath: "empty(<e/>/(a union processing-instruction {"name"} {()}))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. empty(<e/>/(a union processing-instruction [Error is around here]{"name"} {()}))
K2-SeqUnion-27,Error: XPST0003: Unable to parse XPath: "empty(<e/>/(a union processing-instruction name {}))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. empty(<e/>/(a union processing-instruction [Error is around here]name {}))
K2-SeqUnion-28,Error: XPST0003: Unable to parse XPath: "empty(<e/>/(a union comment {()}))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. empty(<e/>/(a union comment [Error is around here]{()}))
K2-SeqUnion-29,Error: XPST0003: Unable to parse XPath: "empty(<e/>/(a union text {()}))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. empty(<e/>/(a union text [Error is around here]{()}))
combiningnodeseqhc1,Error: XPST0003: Unable to parse XPath: "for $h in ( (<hours>0</hours>,<hours>1</hours>) | //hours) order by number($h) return $h". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. for $h in ( (<hours>0</hours>,<hours>1</hours>) | //hours) [Error is around here]order by number($h) return $h
combiningnodeseqhc2,Error: XPST0003: Unable to parse XPath: "for $h in ( (<hours>0</hours>,<hours>1</hours>) union (//hours)) order by number($h) return $h". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. for $h in ( (<hours>0</hours>,<hours>1</hours>) union (//hours)) [Error is around here]order by number($h) return $h
combiningnodeseqhc3,Error: XPST0003: Unable to parse XPath: "for $h in ( (<hours>0</hours>,<hours>40</hours>) | (//hours)) order by number($h) return $h". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. for $h in ( (<hours>0</hours>,<hours>40</hours>) | (//hours)) [Error is around here]order by number($h) return $h
combiningnodeseqhc4,Error: XPST0003: Unable to parse XPath: "for $h in ( (<hours>0</hours>,<hours>40</hours>) union (//hours)) order by number($h) return $h". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. for $h in ( (<hours>0</hours>,<hours>40</hours>) union (//hours)) [Error is around here]order by number($h) return $h
combiningnodeseqhc5,Error: XPST0003: Unable to parse XPath: "for $h in ( () | (//hours)) order by number($h) return $h". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. for $h in ( () | (//hours)) [Error is around here]order by number($h) return $h
combiningnodeseqhc6,Error: XPST0003: Unable to parse XPath: "for $h in ( () union (//hours)) order by number($h) return $h". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. for $h in ( () union (//hours)) [Error is around here]order by number($h) return $h
combiningnodeseqhc7,Error: XPST0003: Unable to parse XPath: "for $h in ( (//hours[xs:integer(.) le 20]) | (//hours[xs:integer(.) gt 20])) order by number($h) return $h". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. for $h in ( (//hours[xs:integer(.) le 20]) | (//hours[xs:integer(.) gt 20])) [Error is around here]order by number($h) return $h
combiningnodeseqhc8,Error: XPST0003: Unable to parse XPath: "for $h in ( (//hours[xs:integer(.) le 20]) union (//hours[xs:integer(.) gt 20])) order by number($h) return $h". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. for $h in ( (//hours[xs:integer(.) le 20]) union (//hours[xs:integer(.) gt 20])) [Error is around here]order by number($h) return $h
combiningnodeseqhc9,Error: XPST0003: Unable to parse XPath: "for $h in ( ($works//hours) | ($staff//grade[xs:integer(.) gt 12])) order by number($h) return $h". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. for $h in ( ($works//hours) | ($staff//grade[xs:integer(.) gt 12])) [Error is around here]order by number($h) return $h
combiningnodeseqhc10,Error: XPST0003: Unable to parse XPath: "for $h in ( ($works//hours) union ($staff//grade[xs:integer(.) gt 12])) order by number($h) return $h". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. for $h in ( ($works//hours) union ($staff//grade[xs:integer(.) gt 12])) [Error is around here]order by number($h) return $h
cbcl-fn-union-001,AssertionError: Expected executing the XPath "         declare variable $x := <b/>;         declare variable $y := <a/>;         ($x union $y) union $x, ($x intersect $y) union $x, ($x except $y) union $x, ($y except $x) union $x, $x union ($x union $y), $x union ($x intersect $y), $x union ($x except $y), $x union ($y except $x)" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, Error: Not implemented: only module imports and function declarations are implemented in XQuery modules.
cbcl-fn-union-002,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
outer-001,Error: XPST0003: Unable to parse XPath: "         declare variable $n as xs:integer external := 10;          <out>{ for $x allowing empty in 1 to $n return <a>{$x}</a> }</out>       ". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.          declare variable $n [Error is around here]as xs:integer external := 10;          <out>{ for $x allowing empty in 1 to $n return <a>{$x}</a> }</out>
outer-002,Error: XPST0003: Unable to parse XPath: "         declare variable $n as xs:integer external := 0;          <out>{ for $x allowing empty in 1 to $n return <a>{$x}</a> }</out>       ". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.          declare variable $n [Error is around here]as xs:integer external := 0;          <out>{ for $x allowing empty in 1 to $n return <a>{$x}</a> }</out>
outer-003,Error: XPST0003: Unable to parse XPath: "         declare variable $n as xs:integer external := 10;          <out>{ for $x allowing empty at $p in 1 to $n return <a position="{$p}">{$x}</a> }</out>       ". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.          declare variable $n [Error is around here]as xs:integer external := 10;          <out>{ for $x allowing empty at $p in 1 to $n return <a position="{$p}">{$x}</a> }</out>
outer-004,Error: XPST0003: Unable to parse XPath: "         declare variable $n as xs:integer external := 0;          <out>{ for $x allowing empty at $p in 1 to $n return <a position="{$p}">{$x}</a> }</out>       ". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.          declare variable $n [Error is around here]as xs:integer external := 0;          <out>{ for $x allowing empty at $p in 1 to $n return <a position="{$p}">{$x}</a> }</out>
outer-005,Error: XPST0003: Unable to parse XPath: "         declare variable $n as xs:integer external := 10;         <out>{ string-join(for $x allowing empty in 1 to $n return concat('[',$x,']'), '|') }</out>". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.          declare variable $n [Error is around here]as xs:integer external := 10;         <out>{ string-join(for $x allowing empty in 1 to $n return concat('[',$x,']'), '|') }</out>
outer-006,Error: XPST0003: Unable to parse XPath: "         declare variable $n as xs:integer external := 0;          <out>{ string-join(for $x allowing empty in 1 to $n return concat('[',$x,']'), '|') }</out>       ". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.          declare variable $n [Error is around here]as xs:integer external := 0;          <out>{ string-join(for $x allowing empty in 1 to $n return concat('[',$x,']'), '|') }</out>
outer-007,Error: XPST0003: Unable to parse XPath: "         declare variable $m as xs:integer external := 5;          declare variable $n as xs:integer external := 5;          <out>{ for $x allowing empty at $p in 1 to $m, $y at $q in 1 to $n return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>       ". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.          declare variable $m [Error is around here]as xs:integer external := 5;          declare variable $n as xs:integer external := 5;          <out>{ for $x allowing empty at $p in 1 to $m, $y at $q in 1 to $n return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>
outer-008,Error: XPST0003: Unable to parse XPath: "         declare variable $m as xs:integer external := 5;          declare variable $n as xs:integer external := 0;          <out>{ for $x allowing empty at $p in 1 to $m, $y allowing empty at $q in 1 to $n return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>       ". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.          declare variable $m [Error is around here]as xs:integer external := 5;          declare variable $n as xs:integer external := 0;          <out>{ for $x allowing empty at $p in 1 to $m, $y allowing empty at $q in 1 to $n return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>
outer-009,Error: XPST0003: Unable to parse XPath: "         declare variable $m as xs:integer external := 0;          declare variable $n as xs:integer external := 5;          <out>{ for $x allowing empty at $p in 1 to $m, $y at $q in 1 to $n return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.          declare variable $m [Error is around here]as xs:integer external := 0;          declare variable $n as xs:integer external := 5;          <out>{ for $x allowing empty at $p in 1 to $m, $y at $q in 1 to $n return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>
outer-010,Error: XPST0003: Unable to parse XPath: "         declare variable $m as xs:integer external := 0;          declare variable $n as xs:integer external := 0;          <out>{ for $x allowing empty at $p in 1 to $m,                     $y allowing empty at $q in 1 to $n return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>       ". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.          declare variable $m [Error is around here]as xs:integer external := 0;          declare variable $n as xs:integer external := 0;          <out>{ for $x allowing empty at $p in 1 to $m,                     $y allowing empty at $q in 1 to $n return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>
outer-011,Error: XPST0003: Unable to parse XPath: "         declare variable $n as xs:integer external := 5;          <out>{ for $x allowing empty at $p in 1 to $n, $y allowing empty at $q in ($x+1) to $n return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>       ". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.          declare variable $n [Error is around here]as xs:integer external := 5;          <out>{ for $x allowing empty at $p in 1 to $n, $y allowing empty at $q in ($x+1) to $n return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>
outer-012,Error: XPST0003: Unable to parse XPath: "         declare variable $n as xs:integer external := 5;          <out>{              for $x as xs:integer allowing empty at $p in 1 to $n,                  $y as xs:integer? allowing empty at $q in ($x+1) to $n              return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>       ". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.          declare variable $n [Error is around here]as xs:integer external := 5;          <out>{              for $x as xs:integer allowing empty at $p in 1 to $n,                  $y as xs:integer? allowing empty at $q in ($x+1) to $n              return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>
outer-013,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "\n        declare variable $n as xs:integer external := 5; \n        <out>{ for $x as xs:integer allowing empty at $p in 1 to $n, \n                   $y as xs:integer allowing empty at $q in ($x+1) to $n \n               return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>\n      ".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\n\n        declare variable $n [Error is around here]as xs:integer external := 5; \n        <out>{ for $x as xs:integer allowing empty at $p in 1 to $n, \n                   $y as xs:integer allowing empty at $q in ($x+1) to $n \n               return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>\n      '
outer-014,Error: XPST0003: Unable to parse XPath: "         declare variable $n as xs:integer external := 5;          <out>{ for $x as xs:integer at $p in 1 to $n                 for $y as xs:integer? allowing empty at $q in ($x+1) to $n                 return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>       ". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.          declare variable $n [Error is around here]as xs:integer external := 5;          <out>{ for $x as xs:integer at $p in 1 to $n                 for $y as xs:integer? allowing empty at $q in ($x+1) to $n                 return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>
outer-015,Error: XPST0003: Unable to parse XPath: "         declare variable $n as xs:integer external := 5;          <out>{ for $x as xs:integer? allowing empty at $p in 1 to $n                 for $y as xs:integer at $q in (if (empty($x)) then 0 else (1 to $x))                 return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>       ". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.          declare variable $n [Error is around here]as xs:integer external := 5;          <out>{ for $x as xs:integer? allowing empty at $p in 1 to $n                 for $y as xs:integer at $q in (if (empty($x)) then 0 else (1 to $x))                 return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>
outer-016,Error: XPST0003: Unable to parse XPath: "         declare variable $n as xs:integer external := 0;          <out>{ for $x as xs:integer? allowing empty at $p in 1 to $n                 for $y as xs:integer at $q in (if (empty($x)) then 0 else (1 to $x))                 return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>       ". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.          declare variable $n [Error is around here]as xs:integer external := 0;          <out>{ for $x as xs:integer? allowing empty at $p in 1 to $n                 for $y as xs:integer at $q in (if (empty($x)) then 0 else (1 to $x))                 return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>
outer-017,Error: XPST0003: Unable to parse XPath: "         declare variable $n as xs:integer external := 5;          <out>{ for $x as xs:integer? allowing empty at $p in 1 to $n                 for $y as xs:integer? allowing empty at $q in (if (empty($x)) then () else (1 to $x))                 where deep-equal($x,$y)                 return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>       ". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.          declare variable $n [Error is around here]as xs:integer external := 5;          <out>{ for $x as xs:integer? allowing empty at $p in 1 to $n                 for $y as xs:integer? allowing empty at $q in (if (empty($x)) then () else (1 to $x))                 where deep-equal($x,$y)                 return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>
outer-018,Error: XPST0003: Unable to parse XPath: "         declare variable $n as xs:integer external := 0;          <out>{ for $x as xs:integer? allowing empty at $p in 1 to $n                 for $y as xs:integer? allowing empty at $q in (if (empty($x)) then () else (1 to $x))                 where deep-equal($x,$y) return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>       ". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.          declare variable $n [Error is around here]as xs:integer external := 0;          <out>{ for $x as xs:integer? allowing empty at $p in 1 to $n                 for $y as xs:integer? allowing empty at $q in (if (empty($x)) then () else (1 to $x))                 where deep-equal($x,$y) return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>
outer-019,AssertionError: expected [Function] to throw error including 'FORG0005' but got 'XPST0003: Unable to parse XPath: "for $c allowing empty in () return exactly-one($c)".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\nfor $c [Error is around here]allowing empty in () return exactly-one($c)'
annotation-2,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
annotation-3,Error: XPST0003: Unable to parse XPath: "          declare namespace eg = "http://example.com";          %eg:sequential function () { "bar" } ()        = "bar"". Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "declare", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "import", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "%" found.           declare namespace eg = "http://example.com";          [Error is around here]%eg:sequential function () { "bar" } ()        = "bar"
annotation-4,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
annotation-5,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
annotation-6,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
annotation-7,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
annotation-9,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
annotation-10,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
annotation-11,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
annotation-12,Error: XPST0003: Unable to parse XPath: "          declare namespace eg = "http://example.com";           declare %eg:one%eg:two%eg:three(1)%eg:four variable $foo := 0;           declare %eg:one%eg:two%eg:three(1)%eg:four function local:foo($arg) { $arg };            local:foo($foo)       ". Expected " ", "(", "(:", "\n", "\r", "\t", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "%" found.           declare namespace eg = "http://example.com";           declare %eg:one[Error is around here]%eg:two%eg:three(1)%eg:four variable $foo := 0;           declare %eg:one%eg:two%eg:three(1)%eg:four function local:foo($arg) { $arg };            local:foo($foo)
annotation-13,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
annotation-14,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
annotation-15,AssertionError: expected [Function] to throw an error
annotation-16,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
annotation-17,AssertionError: expected [Function] to throw an error
annotation-18,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
annotation-19,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0008: The prefix xsi is not declared'
annotation-20,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
annotation-21,AssertionError: expected [Function] to throw an error
annotation-22,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
annotation-23,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
annotation-24,AssertionError: expected [Function] to throw an error
annotation-25,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
annotation-26,AssertionError: expected [Function] to throw an error
annotation-27,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
annotation-28,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
annotation-29,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
annotation-30,Error: XPST0003: Unable to parse XPath: "          declare namespace eg = "http://example.com";          %eg:sequential("abc", 3) function () { "bar" } ()        = "bar"". Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "declare", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "import", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "%" found.           declare namespace eg = "http://example.com";          [Error is around here]%eg:sequential("abc", 3) function () { "bar" } ()        = "bar"
annotation-31,Error: XPST0003: Unable to parse XPath: "          declare namespace eg = "http://example.com";          % Q{http://example.com}sequential("abc", 3) function () { "bar" } ()        = "bar"". Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "declare", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "import", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "%" found.           declare namespace eg = "http://example.com";          [Error is around here]% Q{http://example.com}sequential("abc", 3) function () { "bar" } ()        = "bar"
annotation-32,Error: XPST0003: Unable to parse XPath: "          declare namespace eg = "http://example.com";          %eg:sequential("abc", 3) %eg:memo-function function () { "bar" } ()        = "bar"". Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "declare", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "import", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "%" found.           declare namespace eg = "http://example.com";          [Error is around here]%eg:sequential("abc", 3) %eg:memo-function function () { "bar" } ()        = "bar"
annotation-34,Error: XPST0003: Unable to parse XPath: "(          declare default function namespace "http://example.com";          declare %private function lt() as item()*{          ()          };          ()       ) => empty()". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found. (          declare [Error is around here]default function namespace "http://example.com";          declare %private function lt() as item()*{          ()          };          ()       ) => empty()
annotation-35,AssertionError: expected [Function] to throw an error
annotation-36,AssertionError: expected [Function] to throw an error
annotation-38,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
annotation-assertion-1,Error: XPST0003: Unable to parse XPath: "          declare namespace eg = "http://example.com";          () instance of %eg:x function(*)       ". Expected " ", "(", "(:", "Q", "\n", "\r", "\t", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "empty-sequence()", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "%" found.           declare namespace eg = "http://example.com";          () instance of [Error is around here]%eg:x function(*)
annotation-assertion-2,Error: XPST0003: Unable to parse XPath: "          declare namespace eg = "http://example.com";          () instance of %eg:x("foo") function(*)       ". Expected " ", "(", "(:", "Q", "\n", "\r", "\t", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "empty-sequence()", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "%" found.           declare namespace eg = "http://example.com";          () instance of [Error is around here]%eg:x("foo") function(*)
annotation-assertion-3,Error: XPST0003: Unable to parse XPath: "          declare namespace eg = "http://example.com";          () instance of %eg:x(1234) function(*)       ". Expected " ", "(", "(:", "Q", "\n", "\r", "\t", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "empty-sequence()", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "%" found.           declare namespace eg = "http://example.com";          () instance of [Error is around here]%eg:x(1234) function(*)
annotation-assertion-4,Error: XPST0003: Unable to parse XPath: "          declare namespace eg = "http://example.com";          () instance of %eg:x(12.34) function(*)       ". Expected " ", "(", "(:", "Q", "\n", "\r", "\t", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "empty-sequence()", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "%" found.           declare namespace eg = "http://example.com";          () instance of [Error is around here]%eg:x(12.34) function(*)
annotation-assertion-5,Error: XPST0003: Unable to parse XPath: "          declare namespace eg = "http://example.com";          () instance of %eg:x(12e34) function(*)       ". Expected " ", "(", "(:", "Q", "\n", "\r", "\t", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "empty-sequence()", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "%" found.           declare namespace eg = "http://example.com";          () instance of [Error is around here]%eg:x(12e34) function(*)
annotation-assertion-6,Error: XPST0003: Unable to parse XPath: "          declare namespace eg = "http://example.com";          () instance of %eg:x("abc", 12e34, 567) function(*)       ". Expected " ", "(", "(:", "Q", "\n", "\r", "\t", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "empty-sequence()", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "%" found.           declare namespace eg = "http://example.com";          () instance of [Error is around here]%eg:x("abc", 12e34, 567) function(*)
annotation-assertion-7,Error: XPST0003: Unable to parse XPath: "          () instance of %Q{http://example.com}x function(*)       ". Expected " ", "(", "(:", "Q", "\n", "\r", "\t", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "empty-sequence()", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "%" found.           () instance of [Error is around here]%Q{http://example.com}x function(*)
annotation-assertion-8,Error: XPST0003: Unable to parse XPath: "          () instance of %Q{http://example.com}x function(*)       ". Expected " ", "(", "(:", "Q", "\n", "\r", "\t", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "empty-sequence()", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "%" found.           () instance of [Error is around here]%Q{http://example.com}x function(*)
annotation-assertion-9,Error: XPST0003: Unable to parse XPath: "          declare namespace eg = "http://example.com";          () instance of %eg:x %eg:y%eg:z %eg:w(1) function(*)       ". Expected " ", "(", "(:", "Q", "\n", "\r", "\t", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "empty-sequence()", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "%" found.           declare namespace eg = "http://example.com";          () instance of [Error is around here]%eg:x %eg:y%eg:z %eg:w(1) function(*)
annotation-assertion-10,Error: XPST0003: Unable to parse XPath: "          declare namespace eg = "http://example.com";          () instance of %eg:x function(xs:integer) as xs:string       ". Expected " ", "(", "(:", "Q", "\n", "\r", "\t", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "empty-sequence()", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "%" found.           declare namespace eg = "http://example.com";          () instance of [Error is around here]%eg:x function(xs:integer) as xs:string
annotation-assertion-11,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: "\n         () instance of %xml:x function(*) \n      ".\nExpected " ", "(", "(:", "Q", "\\n", "\\r", "\\t", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "empty-sequence()", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "%" found.\n\n         () instance of [Error is around here]%xml:x function(*) \n      '
annotation-assertion-12,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: "\n         () instance of %Q{http://www.w3.org/XML/1998/namespace}x function(*) \n      ".\nExpected " ", "(", "(:", "Q", "\\n", "\\r", "\\t", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "empty-sequence()", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "%" found.\n\n         () instance of [Error is around here]%Q{http://www.w3.org/XML/1998/namespace}x function(*) \n      '
annotation-assertion-13,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: "\n         () instance of %xs:x function(*) \n      ".\nExpected " ", "(", "(:", "Q", "\\n", "\\r", "\\t", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "empty-sequence()", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "%" found.\n\n         () instance of [Error is around here]%xs:x function(*) \n      '
annotation-assertion-14,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: "\n         () instance of %Q{http://www.w3.org/2001/XMLSchema}x function(*) \n      ".\nExpected " ", "(", "(:", "Q", "\\n", "\\r", "\\t", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "empty-sequence()", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "%" found.\n\n         () instance of [Error is around here]%Q{http://www.w3.org/2001/XMLSchema}x function(*) \n      '
annotation-assertion-15,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: "\n         () instance of %xsi:x function(*) \n      ".\nExpected " ", "(", "(:", "Q", "\\n", "\\r", "\\t", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "empty-sequence()", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "%" found.\n\n         () instance of [Error is around here]%xsi:x function(*) \n      '
annotation-assertion-16,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: "\n         () instance of %fn:x function(*) \n      ".\nExpected " ", "(", "(:", "Q", "\\n", "\\r", "\\t", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "empty-sequence()", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "%" found.\n\n         () instance of [Error is around here]%fn:x function(*) \n      '
annotation-assertion-17,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: "\n         declare namespace math = "http://www.w3.org/2005/xpath-functions/math";\n         () instance of %math:x function(*) \n      ".\nExpected " ", "(", "(:", "Q", "\\n", "\\r", "\\t", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "empty-sequence()", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "%" found.\n\n         declare namespace math = "http://www.w3.org/2005/xpath-functions/math";\n         () instance of [Error is around here]%math:x function(*) \n      '
annotation-assertion-18,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: "\n         declare namespace opts = "http://www.w3.org/2012/xquery";\n         () instance of %opts:x function(*) \n      ".\nExpected " ", "(", "(:", "Q", "\\n", "\\r", "\\t", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "empty-sequence()", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "%" found.\n\n         declare namespace opts = "http://www.w3.org/2012/xquery";\n         () instance of [Error is around here]%opts:x function(*) \n      '
annotation-assertion-19,Error: XPST0003: Unable to parse XPath: "          declare namespace eg = "http://example.com";          () instance of %eg:x(1) %eg:x(2) function(xs:integer) as xs:string       ". Expected " ", "(", "(:", "Q", "\n", "\r", "\t", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "empty-sequence()", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "%" found.           declare namespace eg = "http://example.com";          () instance of [Error is around here]%eg:x(1) %eg:x(2) function(xs:integer) as xs:string
annotation-assertion-20,AssertionError: Expected executing the XPath "          declare namespace eg = "http://example.com";          declare %public function local:three() as xs:integer {3};          local:three#0 instance of %public %private function(xs:integer) as xs:integer       " to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "          declare namespace eg = "http://example.com";          declare %public function local:three() as xs:integer {3};          local:three#0 instance of %public %private function(xs:integer) as xs:integer       ". Expected " ", "(", "(:", "Q", "\n", "\r", "\t", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "empty-sequence()", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "%" found.           declare namespace eg = "http://example.com";          declare %public function local:three() as xs:integer {3};          local:three#0 instance of [Error is around here]%public %private function(xs:integer) as xs:integer       , Error: XPST0003: Unable to parse XPath: "          declare namespace eg = "http://example.com";          declare %public function local:three() as xs:integer {3};          local:three#0 instance of %public %private function(xs:integer) as xs:integer       ". Expected " ", "(", "(:", "Q", "\n", "\r", "\t", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "empty-sequence()", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "%" found.           declare namespace eg = "http://example.com";          declare %public function local:three() as xs:integer {3};          local:three#0 instance of [Error is around here]%public %private function(xs:integer) as xs:integer       .
ArrowPostfix-015,Error: XPST0017: Function normalize-unicode with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}normalize-space (xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}normalize-space ()" or "Q{http://www.w3.org/2001/XMLSchema}normalizedString (xs:anyAtomicType?)"?
ArrowPostfix-027,AssertionError: Skipped test, it was a assert-permutation
ArrowPostfix-028,AssertionError: Skipped test, it was a assert-permutation
ArrowPostfix-029,AssertionError: Skipped test, it was a assert-permutation
ArrowPostfix-030,AssertionError: Skipped test, it was a assert-permutation
Axes089,Error: XPST0003: Unable to parse XPath: " xquery version "1.0"; declare namespace saxon="http://saxon.sf.net/"; declare namespace tour="http://wrox.com/tour";  (:     XQuery program to perform a knight's tour of the chessboard.     Author: Michael H. Kay     Date: 26 June 2003          This version modified to use XQuery 1.0, with sequences and functions.      This query does not use a source document.     There is an optional parameter, start, which can be set to any square on the     chessboard, e.g. a3 or h5. XQuery does not allow parameters to be given a     default value, so the parameter is mandatory.          There is a second optional parameter, end, which indicates that the processing should stop     after a given number of steps. This can be used to animate the display of the tour. This     works especially well when the query is compiled into a Java servlet.      The output is an HTML display of the completed tour.      Internally, the following data representations are used:     * A square on the chessboard: represented as a number in the range 0 to 63     * A state of the chessboard: a sequence of 64 integers, each containing a move number.        A square that has not been visited yet is represented by a zero.     * A set of possible moves: represented as a sequence of integers,     * each integer representing the number of the destination square        :)  declare variable $start as xs:string := "a1";  declare variable $end as xs:string := "64"; declare variable $endd as xs:integer := xs:integer($end);   (: start-column is an integer in the range 0-7 :)  declare variable $start-column as xs:integer :=     xs:integer(translate(substring($start, 1, 1),             'abcdefgh', '01234567'));  (: start-row is an integer in the range 0-7, with zero at the top :)  declare variable $start-row as xs:integer :=     8 - xs:integer(substring($start, 2, 1));      declare function tour:main () as element() {      (: This function controls the processing. It does not access the source document. :)      (: Validate the input parameter :)      if (not(string-length($start)=2) or         not(translate(substring($start,1,1), 'abcdefgh', 'aaaaaaaa')='a') or         not(translate(substring($start,2,1), '12345678', '11111111')='1'))     then         error((), "Invalid start parameter: try say 'a1' or 'g6'")     else          if (not($endd = 1 to 64))      then         error((), "Invalid end parameter: must be in range 1 to 64")     else      (: Set up the empty board :)      let $empty-board as xs:integer* :=          for $i in (1 to 64) return 0          (: Place the knight on the board at the chosen starting position :)          let $initial-board as xs:integer* :=         tour:place-knight(1, $empty-board, $start-row * 8 + $start-column)          (: Evaluate the knight's tour :)      let $final-board as xs:integer* :=        tour:make-moves(2, $initial-board, $start-row * 8 + $start-column)      (: produce the HTML output :)          return tour:print-board($final-board) };  declare function tour:place-knight (                     $move as xs:integer,                     $board as xs:integer*,                     $square as xs:integer (: range 0 to 63 :)                   ) as xs:integer* {      (: This function places a knight on the board at a given square. The returned value is          the supplied board, modified to indicate that the knight reached a given square at a given          move :)      for $i in 1 to 64 return         if ($i = $square + 1) then $move else $board[$i]  };  declare function tour:make-moves (                     $move as xs:integer,                     $board as xs:integer*,                     $square as xs:integer (: range 0 to 63 :)                 ) as xs:integer* {      (: This function takes the board in a given state, decides on the next move to make,          and then calls itself recursively to make further moves, until the knight has completed          his tour of the board. It returns the board in its final state. :)      (: determine the possible moves that the knight can make :)      let $possible-move-list as xs:integer* :=          tour:list-possible-moves($board, $square)      (: try these moves in turn until one is found that works :)      return tour:try-possible-moves($move, $board, $square, $possible-move-list) };  declare function tour:try-possible-moves (                     $move as xs:integer,                     $board as xs:integer*,                     $square as xs:integer, (: range 0 to 63 :)                     $possible-moves as xs:integer* )                 as xs:integer* {      (:   This function tries a set of possible moves that the knight can make          from a given position. It determines the best move as the one to the square with          fewest exits. If this is unsuccessful then it can backtrack and          try another move; however this turns out rarely to be necessary.                     The function makes the selected move, and then calls make-moves() to make          subsequent moves, returning the final state of the board. :)           if (count($possible-moves)!=0)                 then tour:make-best-move($move, $board, $square, $possible-moves)                 else ()           (: if there is no possible move, we return the special value () as the final state              of the board, to indicate to the caller that we got stuck :) };  declare function tour:make-best-move (                     $move as xs:integer,                     $board as xs:integer*,                     $square as xs:integer, (: range 0 to 63 :)                     $possible-moves as xs:integer* )                 as xs:integer* {                      (: this function, given the state of the board and a set of possible moves,        determines which of the moves is the best one. It then makes this move,        and proceeds recursively to make further moves, eventually returning the        final state of the board. :)                          (:  if at least one move is possible, find the best one :)      let $best-move as xs:integer :=         tour:find-best-move($board, $possible-moves, 9, 999)      (: find the list of possible moves excluding the best one :)      let $other-possible-moves as xs:integer* :=         $possible-moves[. != $best-move]      (: update the board to make the move chosen as the best one :)      let $next-board as xs:integer* :=         tour:place-knight($move, $board, $best-move)          (: now make further moves using a recursive call, until the board is complete :)      let $final-board as xs:integer* :=         if ($move < $endd) (:count($next-board[.=0])!=0:)                      then tour:make-moves($move+1, $next-board, $best-move)                     else $next-board      (:   if the final board has the special value '()', we got stuck, and have to choose          the next best of the possible moves. This is done by a recursive call. I thought          that the knight never did get stuck, but it does: if the starting square is f1,          the wrong choice is made at move 58, and needs to be reversed. :)      return         if (empty($final-board))         then tour:try-possible-moves($move, $board, $square, $other-possible-moves)         else $final-board          };  declare function tour:find-best-move (                     $board as xs:integer*,                     $possible-moves as xs:integer*,                     $fewest-exits as xs:integer,                     $best-so-far as xs:integer )                 as xs:integer {      (:  This function finds from among the possible moves, the one with fewest exits.          It calls itself recursively. :)               (:  split the list of possible moves into the first move and the rest of the moves :)      let $trial-move as xs:integer :=          $possible-moves[1]          let $other-possible-moves as xs:integer* :=         $possible-moves[position() > 1]      (: try making the first move :)      let $trial-board as xs:integer* :=         tour:place-knight(99, $board, $trial-move)      (: see how many moves would be possible the next time :)      let $trial-move-exit-list as xs:integer* :=         tour:list-possible-moves($trial-board, $trial-move)      let $number-of-exits as xs:integer :=         count($trial-move-exit-list)      (:  determine whether this trial move has fewer exits than those considered up till now :)      let $minimum-exits as xs:integer :=         min(($number-of-exits, $fewest-exits))      (:  determine which is the best move (the one with fewest exits) so far :)      let $new-best-so-far as xs:integer :=         if ($number-of-exits < $fewest-exits)             then $trial-move             else $best-so-far        (:  if there are other possible moves, consider them too, using a recursive call.         Otherwise return the best move found. :)      return         if (count($other-possible-moves)!=0)             then tour:find-best-move($board, $other-possible-moves,                                              $minimum-exits, $new-best-so-far)             else $new-best-so-far  };  declare function tour:list-possible-moves (                 $board as xs:integer*,                 $square as xs:integer )             as xs:integer* {      (:   This function, given the knight's position on the board, returns the set of squares          he can move to. The squares will be ones that have not been visited before :)                  let $row as xs:integer := $square idiv 8     let $column as xs:integer := $square mod 8      return         (if ($row > 1 and $column > 0 and $board[($square - 17) + 1]=0)             then $square - 17 else (),          if ($row > 1 and $column < 7 and $board[($square - 15) + 1]=0)             then $square - 15 else (),          if ($row > 0 and $column > 1 and $board[($square - 10) + 1]=0)             then $square - 10 else (),          if ($row > 0 and $column < 6 and $board[($square - 6) + 1]=0)             then $square - 6 else (),          if ($row < 6 and $column > 0 and $board[($square + 15) + 1]=0)             then $square + 15 else (),          if ($row < 6 and $column < 7 and $board[($square + 17) + 1]=0)             then $square + 17 else (),          if ($row < 7 and $column > 1 and $board[($square + 6) + 1]=0)             then $square + 6 else (),          if ($row < 7 and $column < 6 and $board[($square + 10) + 1]=0)             then $square + 10 else () )  };  declare function tour:print-board (                 $board as xs:integer* )             as element() {     (: Output the board in HTML format :)      <html>     <head>         <title>Knight's tour</title>     </head>     <body>     <div align="center">     <h1>Knight's tour starting at {$start}</h1>     <table border="1" cellpadding="4">         {for $row in 0 to 7 return            <tr>               {for $column in 0 to 7                 let $color :=                           if ((($row + $column) mod 2)=1)                           then 'xffff44'                            else 'white' return                 <td align="center" bgcolor="{$color}" width="22">{                   let $n := $board[$row * 8 + $column + 1]                   return                        if ($endd != 64 and $n = $endd)                       then <b>{$n}</b>                       else if ($n = 0)                       then "&#xa0;"                       else $n                 }</td>               }            </tr>         }     </table>     <p>{         if ($endd != 64)          then           <a href="Tour?start={$start}&amp;end={$endd+1}">Step</a>         else ()     }</p>         </div>     </body>     </html> };  tour:main()  ". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.  xquery version "1.0"; declare namespace saxon="http://saxon.sf.net/"; declare namespace tour="http://wrox.com/tour";  (:     XQuery program to perform a knight's tour of the chessboard.     Author: Michael H. Kay     Date: 26 June 2003          This version modified to use XQuery 1.0, with sequences and functions.      This query does not use a source document.     There is an optional parameter, start, which can be set to any square on the     chessboard, e.g. a3 or h5. XQuery does not allow parameters to be given a     default value, so the parameter is mandatory.          There is a second optional parameter, end, which indicates that the processing should stop     after a given number of steps. This can be used to animate the display of the tour. This     works especially well when the query is compiled into a Java servlet.      The output is an HTML display of the completed tour.      Internally, the following data representations are used:     * A square on the chessboard: represented as a number in the range 0 to 63     * A state of the chessboard: a sequence of 64 integers, each containing a move number.        A square that has not been visited yet is represented by a zero.     * A set of possible moves: represented as a sequence of integers,     * each integer representing the number of the destination square        :)  declare variable $start [Error is around here]as xs:string := "a1";  declare variable $end as xs:string := "64"; declare variable $endd as xs:integer := xs:integer($end);   (: start-column is an integer in the range 0-7 :)  declare variable $start-column as xs:integer :=     xs:integer(translate(substring($start, 1, 1),             'abcdefgh', '01234567'));  (: start-row is an integer in the range 0-7, with zero at the top :)  declare variable $start-row as xs:integer :=     8 - xs:integer(substring($start, 2, 1));      declare function tour:main () as element() {      (: This function controls the processing. It does not access the source document. :)      (: Validate the input parameter :)      if (not(string-length($start)=2) or         not(translate(substring($start,1,1), 'abcdefgh', 'aaaaaaaa')='a') or         not(translate(substring($start,2,1), '12345678', '11111111')='1'))     then         error((), "Invalid start parameter: try say 'a1' or 'g6'")     else          if (not($endd = 1 to 64))      then         error((), "Invalid end parameter: must be in range 1 to 64")     else      (: Set up the empty board :)      let $empty-board as xs:integer* :=          for $i in (1 to 64) return 0          (: Place the knight on the board at the chosen starting position :)          let $initial-board as xs:integer* :=         tour:place-knight(1, $empty-board, $start-row * 8 + $start-column)          (: Evaluate the knight's tour :)      let $final-board as xs:integer* :=        tour:make-moves(2, $initial-board, $start-row * 8 + $start-column)      (: produce the HTML output :)          return tour:print-board($final-board) };  declare function tour:place-knight (                     $move as xs:integer,                     $board as xs:integer*,                     $square as xs:integer (: range 0 to 63 :)                   ) as xs:integer* {      (: This function places a knight on the board at a given square. The returned value is          the supplied board, modified to indicate that the knight reached a given square at a given          move :)      for $i in 1 to 64 return         if ($i = $square + 1) then $move else $board[$i]  };  declare function tour:make-moves (                     $move as xs:integer,                     $board as xs:integer*,                     $square as xs:integer (: range 0 to 63 :)                 ) as xs:integer* {      (: This function takes the board in a given state, decides on the next move to make,          and then calls itself recursively to make further moves, until the knight has completed          his tour of the board. It returns the board in its final state. :)      (: determine the possible moves that the knight can make :)      let $possible-move-list as xs:integer* :=          tour:list-possible-moves($board, $square)      (: try these moves in turn until one is found that works :)      return tour:try-possible-moves($move, $board, $square, $possible-move-list) };  declare function tour:try-possible-moves (                     $move as xs:integer,                     $board as xs:integer*,                     $square as xs:integer, (: range 0 to 63 :)                     $possible-moves as xs:integer* )                 as xs:integer* {      (:   This function tries a set of possible moves that the knight can make          from a given position. It determines the best move as the one to the square with          fewest exits. If this is unsuccessful then it can backtrack and          try another move; however this turns out rarely to be necessary.                     The function makes the selected move, and then calls make-moves() to make          subsequent moves, returning the final state of the board. :)           if (count($possible-moves)!=0)                 then tour:make-best-move($move, $board, $square, $possible-moves)                 else ()           (: if there is no possible move, we return the special value () as the final state              of the board, to indicate to the caller that we got stuck :) };  declare function tour:make-best-move (                     $move as xs:integer,                     $board as xs:integer*,                     $square as xs:integer, (: range 0 to 63 :)                     $possible-moves as xs:integer* )                 as xs:integer* {                      (: this function, given the state of the board and a set of possible moves,        determines which of the moves is the best one. It then makes this move,        and proceeds recursively to make further moves, eventually returning the        final state of the board. :)                          (:  if at least one move is possible, find the best one :)      let $best-move as xs:integer :=         tour:find-best-move($board, $possible-moves, 9, 999)      (: find the list of possible moves excluding the best one :)      let $other-possible-moves as xs:integer* :=         $possible-moves[. != $best-move]      (: update the board to make the move chosen as the best one :)      let $next-board as xs:integer* :=         tour:place-knight($move, $board, $best-move)          (: now make further moves using a recursive call, until the board is complete :)      let $final-board as xs:integer* :=         if ($move < $endd) (:count($next-board[.=0])!=0:)                      then tour:make-moves($move+1, $next-board, $best-move)                     else $next-board      (:   if the final board has the special value '()', we got stuck, and have to choose          the next best of the possible moves. This is done by a recursive call. I thought          that the knight never did get stuck, but it does: if the starting square is f1,          the wrong choice is made at move 58, and needs to be reversed. :)      return         if (empty($final-board))         then tour:try-possible-moves($move, $board, $square, $other-possible-moves)         else $final-board          };  declare function tour:find-best-move (                     $board as xs:integer*,                     $possible-moves as xs:integer*,                     $fewest-exits as xs:integer,                     $best-so-far as xs:integer )                 as xs:integer {      (:  This function finds from among the possible moves, the one with fewest exits.          It calls itself recursively. :)               (:  split the list of possible moves into the first move and the rest of the moves :)      let $trial-move as xs:integer :=          $possible-moves[1]          let $other-possible-moves as xs:integer* :=         $possible-moves[position() > 1]      (: try making the first move :)      let $trial-board as xs:integer* :=         tour:place-knight(99, $board, $trial-move)      (: see how many moves would be possible the next time :)      let $trial-move-exit-list as xs:integer* :=         tour:list-possible-moves($trial-board, $trial-move)      let $number-of-exits as xs:integer :=         count($trial-move-exit-list)      (:  determine whether this trial move has fewer exits than those considered up till now :)      let $minimum-exits as xs:integer :=         min(($number-of-exits, $fewest-exits))      (:  determine which is the best move (the one with fewest exits) so far :)      let $new-best-so-far as xs:integer :=         if ($number-of-exits < $fewest-exits)             then $trial-move             else $best-so-far        (:  if there are other possible moves, consider them too, using a recursive call.         Otherwise return the best move found. :)      return         if (count($other-possible-moves)!=0)             then tour:find-best-move($board, $other-possible-moves,                                              $minimum-exits, $new-best-so-far)             else $new-best-so-far  };  declare function tour:list-possible-moves (                 $board as xs:integer*,                 $square as xs:integer )             as xs:integer* {      (:   This function, given the knight's position on the board, returns the set of squares          he can move to. The squares will be ones that have not been visited before :)                  let $row as xs:integer := $square idiv 8     let $column as xs:integer := $square mod 8      return         (if ($row > 1 and $column > 0 and $board[($square - 17) + 1]=0)             then $square - 17 else (),          if ($row > 1 and $column < 7 and $board[($square - 15) + 1]=0)             then $square - 15 else (),          if ($row > 0 and $column > 1 and $board[($square - 10) + 1]=0)             then $square - 10 else (),          if ($row > 0 and $column < 6 and $board[($square - 6) + 1]=0)             then $square - 6 else (),          if ($row < 6 and $column > 0 and $board[($square + 15) + 1]=0)             then $square + 15 else (),          if ($row < 6 and $column < 7 and $board[($square + 17) + 1]=0)             then $square + 17 else (),          if ($row < 7 and $column > 1 and $board[($square + 6) + 1]=0)             then $square + 6 else (),          if ($row < 7 and $column < 6 and $board[($square + 10) + 1]=0)             then $square + 10 else () )  };  declare function tour:print-board (                 $board as xs:integer* )             as element() {     (: Output the board in HTML format :)      <html>     <head>         <title>Knight's tour</title>     </head>     <body>     <div align="center">     <h1>Knight's tour starting at {$start}</h1>     <table border="1" cellpadding="4">         {for $row in 0 to 7 return            <tr>               {for $column in 0 to 7                 let $color :=                           if ((($row + $column) mod 2)=1)                           then 'xffff44'                            else 'white' return                 <td align="center" bgcolor="{$color}" width="22">{                   let $n := $board[$row * 8 + $column + 1]                   return                        if ($endd != 64 and $n = $endd)                       then <b>{$n}</b>                       else if ($n = 0)                       then "&#xa0;"                       else $n                 }</td>               }            </tr>         }     </table>     <p>{         if ($endd != 64)          then           <a href="Tour?start={$start}&amp;end={$endd+1}">Step</a>         else ()     }</p>         </div>     </body>     </html> };  tour:main()
Axes090,AssertionError: Expected executing the XPath "let $element as element(foo) := <foo/> return count($element/self::bar)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "let $element as element(foo) := <foo/> return count($element/self::bar) = 0". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $element [Error is around here]as element(foo) := <foo/> return count($element/self::bar) = 0, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "let $element as element(foo) := <foo/> return count($element/self::bar)".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\nlet $element [Error is around here]as element(foo) := <foo/> return count($element/self::bar)'.
Axes091,AssertionError: Expected executing the XPath "let $element as element(foo) := <foo/> return count($element/self::*:bar)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "let $element as element(foo) := <foo/> return count($element/self::*:bar) = 0". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $element [Error is around here]as element(foo) := <foo/> return count($element/self::*:bar) = 0, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "let $element as element(foo) := <foo/> return count($element/self::*:bar)".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\nlet $element [Error is around here]as element(foo) := <foo/> return count($element/self::*:bar)'.
Axes092,AssertionError: Expected executing the XPath "declare namespace ns1 = "http://www.example.org/ns1"; declare namespace ns2 = "http://www.example.org/ns2"; let $element as element(ns1:foo) := <ns1:foo/> return count($element/self::ns2:*)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "declare namespace ns1 = "http://www.example.org/ns1"; declare namespace ns2 = "http://www.example.org/ns2"; let $element as element(ns1:foo) := <ns1:foo/> return count($element/self::ns2:*) = 0". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. declare namespace ns1 = "http://www.example.org/ns1"; declare namespace ns2 = "http://www.example.org/ns2"; let $element [Error is around here]as element(ns1:foo) := <ns1:foo/> return count($element/self::ns2:*) = 0, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "declare namespace ns1 = "http://www.example.org/ns1"; declare namespace ns2 = "http://www.example.org/ns2"; let $element as element(ns1:foo) := <ns1:foo/> return count($element/self::ns2:*)".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\ndeclare namespace ns1 = "http://www.example.org/ns1"; declare namespace ns2 = "http://www.example.org/ns2"; let $element [Error is around here]as element(ns1:foo) := <ns1:foo/> return count($element/self::ns2:*)'.
Axes093,AssertionError: Expected executing the XPath "let $attribute as attribute(foo) := attribute foo { } return count($attribute/self::bar)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "let $attribute as attribute(foo) := attribute foo { } return count($attribute/self::bar) = 0". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $attribute [Error is around here]as attribute(foo) := attribute foo { } return count($attribute/self::bar) = 0, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "let $attribute as attribute(foo) := attribute foo { } return count($attribute/self::bar)".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\nlet $attribute [Error is around here]as attribute(foo) := attribute foo { } return count($attribute/self::bar)'.
Axes094,AssertionError: Expected executing the XPath "let $attribute as attribute(foo) := attribute foo { }              return count($attribute/self::*:bar)       " to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "let $attribute as attribute(foo) := attribute foo { }              return count($attribute/self::*:bar)        = 0". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $attribute [Error is around here]as attribute(foo) := attribute foo { }              return count($attribute/self::*:bar)        = 0, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "let $attribute as attribute(foo) := attribute foo { } \n            return count($attribute/self::*:bar)\n      ".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\nlet $attribute [Error is around here]as attribute(foo) := attribute foo { } \n            return count($attribute/self::*:bar)\n      '.
Axes095,AssertionError: Expected executing the XPath "         declare namespace ns1 = "http://www.example.org/ns1";          declare namespace ns2 = "http://www.example.org/ns2";          let $attribute as attribute(ns1:foo) := attribute ns1:foo { }          return count($attribute/self::ns2:*)       " to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "         declare namespace ns1 = "http://www.example.org/ns1";          declare namespace ns2 = "http://www.example.org/ns2";          let $attribute as attribute(ns1:foo) := attribute ns1:foo { }          return count($attribute/self::ns2:*)        = 0". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.          declare namespace ns1 = "http://www.example.org/ns1";          declare namespace ns2 = "http://www.example.org/ns2";          let $attribute [Error is around here]as attribute(ns1:foo) := attribute ns1:foo { }          return count($attribute/self::ns2:*)        = 0, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "\n        declare namespace ns1 = "http://www.example.org/ns1"; \n        declare namespace ns2 = "http://www.example.org/ns2"; \n        let $attribute as attribute(ns1:foo) := attribute ns1:foo { } \n        return count($attribute/self::ns2:*)\n      ".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\n\n        declare namespace ns1 = "http://www.example.org/ns1"; \n        declare namespace ns2 = "http://www.example.org/ns2"; \n        let $attribute [Error is around here]as attribute(ns1:foo) := attribute ns1:foo { } \n        return count($attribute/self::ns2:*)\n      '.
Axes096,AssertionError: Expected executing the XPath "let $element as element(*) := <foo/> return count($element/self::bar)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "let $element as element(*) := <foo/> return count($element/self::bar) = 0". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $element [Error is around here]as element(*) := <foo/> return count($element/self::bar) = 0, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "let $element as element(*) := <foo/> return count($element/self::bar)".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\nlet $element [Error is around here]as element(*) := <foo/> return count($element/self::bar)'.
Axes097,AssertionError: Expected executing the XPath "let $element as element(*) := <foo/> return count($element/self::*:bar)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "let $element as element(*) := <foo/> return count($element/self::*:bar) = 0". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $element [Error is around here]as element(*) := <foo/> return count($element/self::*:bar) = 0, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "let $element as element(*) := <foo/> return count($element/self::*:bar)".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\nlet $element [Error is around here]as element(*) := <foo/> return count($element/self::*:bar)'.
Axes098,AssertionError: Expected executing the XPath "         declare namespace ns1 = "http://www.example.org/ns1";          declare namespace ns2 = "http://www.example.org/ns2";          let $element as element(*) := <ns1:foo/>          return count($element/self::ns2:*)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "         declare namespace ns1 = "http://www.example.org/ns1";          declare namespace ns2 = "http://www.example.org/ns2";          let $element as element(*) := <ns1:foo/>          return count($element/self::ns2:*) = 0". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.          declare namespace ns1 = "http://www.example.org/ns1";          declare namespace ns2 = "http://www.example.org/ns2";          let $element [Error is around here]as element(*) := <ns1:foo/>          return count($element/self::ns2:*) = 0, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "\n        declare namespace ns1 = "http://www.example.org/ns1"; \n        declare namespace ns2 = "http://www.example.org/ns2"; \n        let $element as element(*) := <ns1:foo/> \n        return count($element/self::ns2:*)".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\n\n        declare namespace ns1 = "http://www.example.org/ns1"; \n        declare namespace ns2 = "http://www.example.org/ns2"; \n        let $element [Error is around here]as element(*) := <ns1:foo/> \n        return count($element/self::ns2:*)'.
Axes099,AssertionError: Expected executing the XPath "let $attribute as attribute(*) := attribute foo { } return count($attribute/self::bar)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "let $attribute as attribute(*) := attribute foo { } return count($attribute/self::bar) = 0". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $attribute [Error is around here]as attribute(*) := attribute foo { } return count($attribute/self::bar) = 0, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "let $attribute as attribute(*) := attribute foo { } return count($attribute/self::bar)".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\nlet $attribute [Error is around here]as attribute(*) := attribute foo { } return count($attribute/self::bar)'.
Axes100,AssertionError: Expected executing the XPath "let $attribute as attribute(*) := attribute foo { } return count($attribute/self::*:bar)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "let $attribute as attribute(*) := attribute foo { } return count($attribute/self::*:bar) = 0". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $attribute [Error is around here]as attribute(*) := attribute foo { } return count($attribute/self::*:bar) = 0, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "let $attribute as attribute(*) := attribute foo { } return count($attribute/self::*:bar)".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\nlet $attribute [Error is around here]as attribute(*) := attribute foo { } return count($attribute/self::*:bar)'.
Axes101,AssertionError: Expected executing the XPath "         declare namespace ns1 = "http://www.example.org/ns1";          declare namespace ns2 = "http://www.example.org/ns2";          let $attribute as attribute(*) := attribute ns1:foo { }          return count($attribute/self::ns2:*)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "         declare namespace ns1 = "http://www.example.org/ns1";          declare namespace ns2 = "http://www.example.org/ns2";          let $attribute as attribute(*) := attribute ns1:foo { }          return count($attribute/self::ns2:*) = 0". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.          declare namespace ns1 = "http://www.example.org/ns1";          declare namespace ns2 = "http://www.example.org/ns2";          let $attribute [Error is around here]as attribute(*) := attribute ns1:foo { }          return count($attribute/self::ns2:*) = 0, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "\n        declare namespace ns1 = "http://www.example.org/ns1"; \n        declare namespace ns2 = "http://www.example.org/ns2"; \n        let $attribute as attribute(*) := attribute ns1:foo { } \n        return count($attribute/self::ns2:*)".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\n\n        declare namespace ns1 = "http://www.example.org/ns1"; \n        declare namespace ns2 = "http://www.example.org/ns2"; \n        let $attribute [Error is around here]as attribute(*) := attribute ns1:foo { } \n        return count($attribute/self::ns2:*)'.
Axes102,Error: XPST0003: Unable to parse XPath: "         declare namespace ns1 = "http://www.example.org/ns1";          declare namespace ns2 = "http://www.example.org/ns2";          declare construction strip;          let $element as element(*, xs:untyped) := <e>test</e>          let $element as element(*, xs:untyped) := $element/self::*          return count($element)        = 1". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.          declare namespace ns1 = "http://www.example.org/ns1";          declare namespace ns2 = "http://www.example.org/ns2";          declare construction strip;          let $element [Error is around here]as element(*, xs:untyped) := <e>test</e>          let $element as element(*, xs:untyped) := $element/self::*          return count($element)        = 1
Axes103,AssertionError: Expected executing the XPath "let $comment as comment() := <!--comment--> return count($comment/self::*)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "let $comment as comment() := <!--comment--> return count($comment/self::*) = 0". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $comment [Error is around here]as comment() := <!--comment--> return count($comment/self::*) = 0, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "let $comment as comment() := <!--comment--> return count($comment/self::*)".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\nlet $comment [Error is around here]as comment() := <!--comment--> return count($comment/self::*)'.
Axes104,AssertionError: Expected executing the XPath "let $comment as comment() := <!--comment--> return count($comment/self::foo)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "let $comment as comment() := <!--comment--> return count($comment/self::foo) = 0". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $comment [Error is around here]as comment() := <!--comment--> return count($comment/self::foo) = 0, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "let $comment as comment() := <!--comment--> return count($comment/self::foo)".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\nlet $comment [Error is around here]as comment() := <!--comment--> return count($comment/self::foo)'.
Axes105,AssertionError: Expected executing the XPath "let $comment as comment() := <!--comment--> return count($comment/self::*:foo)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "let $comment as comment() := <!--comment--> return count($comment/self::*:foo) = 0". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $comment [Error is around here]as comment() := <!--comment--> return count($comment/self::*:foo) = 0, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "let $comment as comment() := <!--comment--> return count($comment/self::*:foo)".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\nlet $comment [Error is around here]as comment() := <!--comment--> return count($comment/self::*:foo)'.
Axes106,AssertionError: Expected executing the XPath "         declare namespace ns1 = "http://www.example.org/ns1";          let $comment as comment() := <!--comment-->          return count($comment/self::ns1:*)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "         declare namespace ns1 = "http://www.example.org/ns1";          let $comment as comment() := <!--comment-->          return count($comment/self::ns1:*) = 0". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.          declare namespace ns1 = "http://www.example.org/ns1";          let $comment [Error is around here]as comment() := <!--comment-->          return count($comment/self::ns1:*) = 0, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "\n        declare namespace ns1 = "http://www.example.org/ns1"; \n        let $comment as comment() := <!--comment--> \n        return count($comment/self::ns1:*)".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\n\n        declare namespace ns1 = "http://www.example.org/ns1"; \n        let $comment [Error is around here]as comment() := <!--comment--> \n        return count($comment/self::ns1:*)'.
Axes107,AssertionError: Expected executing the XPath "         let $processing-instruction as processing-instruction() := <?processing instruction?>          return count($processing-instruction/self::*)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "         let $processing-instruction as processing-instruction() := <?processing instruction?>          return count($processing-instruction/self::*) = 0". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.          let $processing-instruction [Error is around here]as processing-instruction() := <?processing instruction?>          return count($processing-instruction/self::*) = 0, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "\n        let $processing-instruction as processing-instruction() := <?processing instruction?> \n        return count($processing-instruction/self::*)".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\n\n        let $processing-instruction [Error is around here]as processing-instruction() := <?processing instruction?> \n        return count($processing-instruction/self::*)'.
Axes108,AssertionError: Expected executing the XPath "         let $processing-instruction as processing-instruction() := <?processing instruction?>          return count($processing-instruction/self::processing)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "         let $processing-instruction as processing-instruction() := <?processing instruction?>          return count($processing-instruction/self::processing) = 0". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.          let $processing-instruction [Error is around here]as processing-instruction() := <?processing instruction?>          return count($processing-instruction/self::processing) = 0, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "\n        let $processing-instruction as processing-instruction() := <?processing instruction?> \n        return count($processing-instruction/self::processing)".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\n\n        let $processing-instruction [Error is around here]as processing-instruction() := <?processing instruction?> \n        return count($processing-instruction/self::processing)'.
Axes109,AssertionError: Expected executing the XPath "         let $processing-instruction as processing-instruction() := <?processing instruction?>          return count($processing-instruction/self::*:processing)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "         let $processing-instruction as processing-instruction() := <?processing instruction?>          return count($processing-instruction/self::*:processing) = 0". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.          let $processing-instruction [Error is around here]as processing-instruction() := <?processing instruction?>          return count($processing-instruction/self::*:processing) = 0, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "\n        let $processing-instruction as processing-instruction() := <?processing instruction?> \n        return count($processing-instruction/self::*:processing)".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\n\n        let $processing-instruction [Error is around here]as processing-instruction() := <?processing instruction?> \n        return count($processing-instruction/self::*:processing)'.
Axes110,AssertionError: Expected executing the XPath "         declare namespace ns1 = "http://www.example.org/ns1";          let $processing-instruction as processing-instruction() := <?processing instruction?>          return count($processing-instruction/self::ns1:*)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "         declare namespace ns1 = "http://www.example.org/ns1";          let $processing-instruction as processing-instruction() := <?processing instruction?>          return count($processing-instruction/self::ns1:*) = 0". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.          declare namespace ns1 = "http://www.example.org/ns1";          let $processing-instruction [Error is around here]as processing-instruction() := <?processing instruction?>          return count($processing-instruction/self::ns1:*) = 0, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "\n        declare namespace ns1 = "http://www.example.org/ns1"; \n        let $processing-instruction as processing-instruction() := <?processing instruction?> \n        return count($processing-instruction/self::ns1:*)".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\n\n        declare namespace ns1 = "http://www.example.org/ns1"; \n        let $processing-instruction [Error is around here]as processing-instruction() := <?processing instruction?> \n        return count($processing-instruction/self::ns1:*)'.
Axes111,Error: XPST0003: Unable to parse XPath: "         declare namespace ns1 = "http://www.example.org/ns1";          declare namespace ns2 = "http://www.example.org/ns2"; declare construction strip;          let $element as element(*, xs:untyped) := <e a="value" />          let $attribute as attribute(*, xs:untypedAtomic)* := $element/attribute::*          return count($attribute) = 1". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.          declare namespace ns1 = "http://www.example.org/ns1";          declare namespace ns2 = "http://www.example.org/ns2"; declare construction strip;          let $element [Error is around here]as element(*, xs:untyped) := <e a="value" />          let $attribute as attribute(*, xs:untypedAtomic)* := $element/attribute::*          return count($attribute) = 1
Axes112,AssertionError: expected [Function] to throw error including 'XQST0134' but got 'No selector counterpart for: u.'
Axes115,AssertionError: Expected executing the XPath "/*/attribute::namespace-node()" to resolve to one of the expected results, but got Error: No selector counterpart for: u., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'No selector counterpart for: u.'.
Axes117,Error: XPST0003: Unable to parse XPath: "(namespace {"xsl"}{"http://www.w3.org/1999/XSL/Transform"} / self::namespace-node()) => count()". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. (namespace [Error is around here]{"xsl"}{"http://www.w3.org/1999/XSL/Transform"} / self::namespace-node()) => count()
Axes127,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'No selector counterpart for: u.'
axis-err-1,AssertionError: expected [Function] to throw an error
K2-Axes-1,Error: XPST0003: Unable to parse XPath: "declare variable $var := document{<e><f>f's value</f></e>}; $var/(/)/(/)//f". Expected " ", "!", "!=", "#", "(", "(:", "*", "+", "-", "/", "//", ":", ":*", ";", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. declare variable $var := document[Error is around here]{<e><f>f's value</f></e>}; $var/(/)/(/)//f
K2-Axes-2,AssertionError: expected [Function] to throw error including 'XPDY0050' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-Axes-3,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-Axes-4,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-Axes-18,Error: XPST0003: Unable to parse XPath: "empty(text {"some text"}/..)". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. empty(text [Error is around here]{"some text"}/..)
K2-Axes-19,Error: XPST0003: Unable to parse XPath: "empty(processing-instruction theName {"some text"}/..)". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found. empty(processing-instruction [Error is around here]theName {"some text"}/..)
K2-Axes-20,Error: XPST0003: Unable to parse XPath: "empty(attribute theName {"some text"}/..)". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found. empty(attribute [Error is around here]theName {"some text"}/..)
K2-Axes-21,Error: XPST0003: Unable to parse XPath: "empty(element theName {"some text"}/..)". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found. empty(element [Error is around here]theName {"some text"}/..)
K2-Axes-22,Error: XPST0003: Unable to parse XPath: "empty(comment {"some text"}/..)". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. empty(comment [Error is around here]{"some text"}/..)
K2-Axes-30,AssertionError: Expected executing the XPath "empty(fn:root(<e/>)/..)" to resolve to one of the expected results, but got Error: XPST0017: Function fn:root with arity of 1 not registered. No similar functions found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0017: Function fn:root with arity of 1 not registered. No similar functions found.'.
K2-Axes-32,AssertionError: Expected executing the XPath "declare variable $myVar := <e/>; empty(fn:root($myVar/(/)/..))" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules', AssertionError: expected [Function] to throw error including 'XPDY0050' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
K2-Axes-33,AssertionError: Expected executing the XPath "declare variable $myVar := document { <e/>}; empty($myVar/(/)/..)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "declare variable $myVar := document { <e/>}; empty($myVar/(/)/..)". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", ";", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. declare variable $myVar := document [Error is around here]{ <e/>}; empty($myVar/(/)/..), AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "declare variable $myVar := document { <e/>}; empty($myVar/(/)/..)".\nExpected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", ";", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.\ndeclare variable $myVar := document [Error is around here]{ <e/>}; empty($myVar/(/)/..)'.
K2-Axes-38,AssertionError: expected [Function] to throw an error
K2-Axes-39,AssertionError: expected [Function] to throw an error
K2-Axes-40,AssertionError: expected [Function] to throw an error
K2-Axes-41,AssertionError: expected [Function] to throw an error
K2-Axes-47,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-Axes-48,Error: XPST0003: Unable to parse XPath: "declare variable $myVar := <e/>; $myVar/(<a/>, <b/>, <?d ?>, <!-- e-->, attribute name {}, document {()})/3". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. declare variable $myVar := <e/>; $myVar/(<a/>, <b/>, <?d ?>, <!-- e-->, attribute [Error is around here]name {}, document {()})/3
K2-Axes-49,Error: XPST0003: Unable to parse XPath: "declare variable $myVar := <e/>; $myVar/(<a/>, <b/>, <?d ?>, <!-- e-->, attribute name {}, document {()})/number()". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. declare variable $myVar := <e/>; $myVar/(<a/>, <b/>, <?d ?>, <!-- e-->, attribute [Error is around here]name {}, document {()})/number()
K2-Axes-52,AssertionError: Expected executing the XPath "         declare variable $myVar := <e/>;          empty($myVar/preceding-sibling::comment()/a/b/c/1/@*)" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules', AssertionError: expected [Function] to throw error including 'XPTY0019' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules', AssertionError: expected [Function] to throw error including 'XPTY0020' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
K2-Axes-57,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-Axes-58,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-Axes-59,AssertionError: Expected executing the XPath "declare variable $i := <root> <child/> <child/> <child> <child2> <child3> <leaf/> </child3> </child2> </child> </root>; 1, root($i)//leaf/child::node(), 1" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
K2-Axes-84,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'No selector counterpart for: u.'
K2-Axes-86,AssertionError: Expected executing the XPath "         declare variable $root as document-node() := . treat as document-node();         <out>         <empty> { (: attribute axis, and all other axes that inference can assert might produce attributes.               These are placed first, so we don't raise XQTY0024. :)               $root/foo/child::attribute(foo),               $root//element()/self::attribute(),               $root//text()/self::attribute(),               $root/self::attribute(),               $root/foo/descendant::attribute(foo),               $root//processing-instruction()/self::attribute(),               $root/attribute(foo), $root/attribute(),               $root/attribute::attribute(),               $root//parent::attribute(),               $root//document-node()/self::attribute(),               $root/@*, $root/*/@*[self::*],               $root//comment()/descendant-or-self::attribute(),               $root//processing-instruction()/descendant-or-self::attribute(),               $root//text()/descendant-or-self::attribute(),               $root//document-node()/descendant-or-self::attribute(),               $root//parent::attribute(),               $root//ancestor::attribute(),               $root//ancestor-or-self::attribute(),               $root/self::attribute(),               $root//attribute()/child::node(),               $root//attribute::text(),               $root//attribute::comment(),               $root//attribute::processing-instruction(),               $root//attribute::document-node(),               $root//attribute::document-node(element(foo)),              $root//attribute()/self::text(),              $root//attribute()/self::processing-instruction(),               $root//attribute()/self::element(),               $root//attribute()/self::document-node(),               $root//attribute()/self::comment(),               $root//*/attribute()//node(),               $root//*/attribute()/descendant::node(),               $root//attribute::element(),               $root//comment()/child::node(),               $root//processing-instruction()/child::node(),               $root//text()/child::node(),              $root//attribute()/descendant::node(),               $root//comment()/descendant::node(),               $root//text()/descendant::node(),               $root//processing-instruction()/descendant::node(),               $root//comment()/descendant-or-self::text(),               $root//comment()/descendant-or-self::processing-instruction(),               $root//comment()/descendant-or-self::element(),               $root//comment()/descendant-or-self::document-node(),               $root//processing-instruction()/descendant-or-self::text(),               $root//processing-instruction()/descendant-or-self::comment(),               $root//processing-instruction()/descendant-or-self::element(),               $root//processing-instruction()/descendant-or-self::document-node(),               $root//text()/descendant-or-self::processing-instruction(),               $root//text()/descendant-or-self::comment(),               $root//text()/descendant-or-self::element(),               $root//text()/descendant-or-self::document-node(),               $root//attribute()/descendant-or-self::processing-instruction(),               $root//attribute()/descendant-or-self::text(),               $root//attribute()/descendant-or-self::comment(),               $root//attribute()/descendant-or-self::element(),               $root//attribute()/descendant-or-self::document-node(),               $root/.., $root//parent::comment(),               $root//parent::processing-instruction(),               $root//parent::text(),               $root//ancestor::comment(),               $root//ancestor::processing-instruction(),               $root//ancestor::text(),               $root/self::comment(),               $root/self::processing-instruction(),               $root/self::text(),               $root/self::element(),               $root//element()/self::text(),               $root//element()/self::processing-instruction(),               $root//element()/self::document-node(),               $root//element()/self::comment(),               $root//processing-instruction()/self::text(),               $root//processing-instruction()/self::element(),               $root//processing-instruction()/self::document-node(),               $root//processing-instruction()/self::comment(),               $root//text()/self::processing-instruction(),               $root//text()/self::element(),               $root//text()/self::document-node(),               $root//text()/self::comment(),               $root//document-node()/self::processing-instruction(),               $root//document-node()/self::element(),               $root//document-node()/self::text(),               $root//document-node()/self::comment() } </empty><ex>{exists($root//*/attribute()/descendant-or-self::node())}</ex></out>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "         declare variable $root as document-node() := . treat as document-node();         <out>         <empty> { (: attribute axis, and all other axes that inference can assert might produce attributes.               These are placed first, so we don't raise XQTY0024. :)               $root/foo/child::attribute(foo),               $root//element()/self::attribute(),               $root//text()/self::attribute(),               $root/self::attribute(),               $root/foo/descendant::attribute(foo),               $root//processing-instruction()/self::attribute(),               $root/attribute(foo), $root/attribute(),               $root/attribute::attribute(),               $root//parent::attribute(),               $root//document-node()/self::attribute(),               $root/@*, $root/*/@*[self::*],               $root//comment()/descendant-or-self::attribute(),               $root//processing-instruction()/descendant-or-self::attribute(),               $root//text()/descendant-or-self::attribute(),               $root//document-node()/descendant-or-self::attribute(),               $root//parent::attribute(),               $root//ancestor::attribute(),               $root//ancestor-or-self::attribute(),               $root/self::attribute(),               $root//attribute()/child::node(),               $root//attribute::text(),               $root//attribute::comment(),               $root//attribute::processing-instruction(),               $root//attribute::document-node(),               $root//attribute::document-node(element(foo)),              $root//attribute()/self::text(),              $root//attribute()/self::processing-instruction(),               $root//attribute()/self::element(),               $root//attribute()/self::document-node(),               $root//attribute()/self::comment(),               $root//*/attribute()//node(),               $root//*/attribute()/descendant::node(),               $root//attribute::element(),               $root//comment()/child::node(),               $root//processing-instruction()/child::node(),               $root//text()/child::node(),              $root//attribute()/descendant::node(),               $root//comment()/descendant::node(),               $root//text()/descendant::node(),               $root//processing-instruction()/descendant::node(),               $root//comment()/descendant-or-self::text(),               $root//comment()/descendant-or-self::processing-instruction(),               $root//comment()/descendant-or-self::element(),               $root//comment()/descendant-or-self::document-node(),               $root//processing-instruction()/descendant-or-self::text(),               $root//processing-instruction()/descendant-or-self::comment(),               $root//processing-instruction()/descendant-or-self::element(),               $root//processing-instruction()/descendant-or-self::document-node(),               $root//text()/descendant-or-self::processing-instruction(),               $root//text()/descendant-or-self::comment(),               $root//text()/descendant-or-self::element(),               $root//text()/descendant-or-self::document-node(),               $root//attribute()/descendant-or-self::processing-instruction(),               $root//attribute()/descendant-or-self::text(),               $root//attribute()/descendant-or-self::comment(),               $root//attribute()/descendant-or-self::element(),               $root//attribute()/descendant-or-self::document-node(),               $root/.., $root//parent::comment(),               $root//parent::processing-instruction(),               $root//parent::text(),               $root//ancestor::comment(),               $root//ancestor::processing-instruction(),               $root//ancestor::text(),               $root/self::comment(),               $root/self::processing-instruction(),               $root/self::text(),               $root/self::element(),               $root//element()/self::text(),               $root//element()/self::processing-instruction(),               $root//element()/self::document-node(),               $root//element()/self::comment(),               $root//processing-instruction()/self::text(),               $root//processing-instruction()/self::element(),               $root//processing-instruction()/self::document-node(),               $root//processing-instruction()/self::comment(),               $root//text()/self::processing-instruction(),               $root//text()/self::element(),               $root//text()/self::document-node(),               $root//text()/self::comment(),               $root//document-node()/self::processing-instruction(),               $root//document-node()/self::element(),               $root//document-node()/self::text(),               $root//document-node()/self::comment() } </empty><ex>{exists($root//*/attribute()/descendant-or-self::node())}</ex></out>". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.          declare variable $root [Error is around here]as document-node() := . treat as document-node();         <out>         <empty> { (: attribute axis, and all other axes that inference can assert might produce attributes.               These are placed first, so we don't raise XQTY0024. :)               $root/foo/child::attribute(foo),               $root//element()/self::attribute(),               $root//text()/self::attribute(),               $root/self::attribute(),               $root/foo/descendant::attribute(foo),               $root//processing-instruction()/self::attribute(),               $root/attribute(foo), $root/attribute(),               $root/attribute::attribute(),               $root//parent::attribute(),               $root//document-node()/self::attribute(),               $root/@*, $root/*/@*[self::*],               $root//comment()/descendant-or-self::attribute(),               $root//processing-instruction()/descendant-or-self::attribute(),               $root//text()/descendant-or-self::attribute(),               $root//document-node()/descendant-or-self::attribute(),               $root//parent::attribute(),               $root//ancestor::attribute(),               $root//ancestor-or-self::attribute(),               $root/self::attribute(),               $root//attribute()/child::node(),               $root//attribute::text(),               $root//attribute::comment(),               $root//attribute::processing-instruction(),               $root//attribute::document-node(),               $root//attribute::document-node(element(foo)),              $root//attribute()/self::text(),              $root//attribute()/self::processing-instruction(),               $root//attribute()/self::element(),               $root//attribute()/self::document-node(),               $root//attribute()/self::comment(),               $root//*/attribute()//node(),               $root//*/attribute()/descendant::node(),               $root//attribute::element(),               $root//comment()/child::node(),               $root//processing-instruction()/child::node(),               $root//text()/child::node(),              $root//attribute()/descendant::node(),               $root//comment()/descendant::node(),               $root//text()/descendant::node(),               $root//processing-instruction()/descendant::node(),               $root//comment()/descendant-or-self::text(),               $root//comment()/descendant-or-self::processing-instruction(),               $root//comment()/descendant-or-self::element(),               $root//comment()/descendant-or-self::document-node(),               $root//processing-instruction()/descendant-or-self::text(),               $root//processing-instruction()/descendant-or-self::comment(),               $root//processing-instruction()/descendant-or-self::element(),               $root//processing-instruction()/descendant-or-self::document-node(),               $root//text()/descendant-or-self::processing-instruction(),               $root//text()/descendant-or-self::comment(),               $root//text()/descendant-or-self::element(),               $root//text()/descendant-or-self::document-node(),               $root//attribute()/descendant-or-self::processing-instruction(),               $root//attribute()/descendant-or-self::text(),               $root//attribute()/descendant-or-self::comment(),               $root//attribute()/descendant-or-self::element(),               $root//attribute()/descendant-or-self::document-node(),               $root/.., $root//parent::comment(),               $root//parent::processing-instruction(),               $root//parent::text(),               $root//ancestor::comment(),               $root//ancestor::processing-instruction(),               $root//ancestor::text(),               $root/self::comment(),               $root/self::processing-instruction(),               $root/self::text(),               $root/self::element(),               $root//element()/self::text(),               $root//element()/self::processing-instruction(),               $root//element()/self::document-node(),               $root//element()/self::comment(),               $root//processing-instruction()/self::text(),               $root//processing-instruction()/self::element(),               $root//processing-instruction()/self::document-node(),               $root//processing-instruction()/self::comment(),               $root//text()/self::processing-instruction(),               $root//text()/self::element(),               $root//text()/self::document-node(),               $root//text()/self::comment(),               $root//document-node()/self::processing-instruction(),               $root//document-node()/self::element(),               $root//document-node()/self::text(),               $root//document-node()/self::comment() } </empty><ex>{exists($root//*/attribute()/descendant-or-self::node())}</ex></out>, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "\n        declare variable $root as document-node() := . treat as document-node();\n        <out>\n        <empty> { (: attribute axis, and all other axes that inference can assert might produce attributes. \n             These are placed first, so we don\'t raise XQTY0024. :) \n             $root/foo/child::attribute(foo), \n             $root//element()/self::attribute(), \n             $root//text()/self::attribute(), \n             $root/self::attribute(), \n             $root/foo/descendant::attribute(foo), \n             $root//processing-instruction()/self::attribute(), \n             $root/attribute(foo), $root/attribute(), \n             $root/attribute::attribute(), \n             $root//parent::attribute(), \n             $root//document-node()/self::attribute(), \n             $root/@*, $root/*/@*[self::*], \n             $root//comment()/descendant-or-self::attribute(), \n             $root//processing-instruction()/descendant-or-self::attribute(), \n             $root//text()/descendant-or-self::attribute(), \n             $root//document-node()/descendant-or-self::attribute(), \n             $root//parent::attribute(), \n             $root//ancestor::attribute(), \n             $root//ancestor-or-self::attribute(), \n             $root/self::attribute(), \n             $root//attribute()/child::node(), \n             $root//attribute::text(), \n             $root//attribute::comment(), \n             $root//attribute::processing-instruction(), \n             $root//attribute::document-node(), \n             $root//attribute::document-node(element(foo)),\n             $root//attribute()/self::text(),\n             $root//attribute()/self::processing-instruction(), \n             $root//attribute()/self::element(), \n             $root//attribute()/self::document-node(), \n             $root//attribute()/self::comment(), \n             $root//*/attribute()//node(), \n             $root//*/attribute()/descendant::node(), \n             $root//attribute::element(), \n             $root//comment()/child::node(), \n             $root//processing-instruction()/child::node(), \n             $root//text()/child::node(),\n             $root//attribute()/descendant::node(), \n             $root//comment()/descendant::node(), \n             $root//text()/descendant::node(), \n             $root//processing-instruction()/descendant::node(), \n             $root//comment()/descendant-or-self::text(), \n             $root//comment()/descendant-or-self::processing-instruction(), \n             $root//comment()/descendant-or-self::element(), \n             $root//comment()/descendant-or-self::document-node(), \n             $root//processing-instruction()/descendant-or-self::text(), \n             $root//processing-instruction()/descendant-or-self::comment(), \n             $root//processing-instruction()/descendant-or-self::element(), \n             $root//processing-instruction()/descendant-or-self::document-node(), \n             $root//text()/descendant-or-self::processing-instruction(), \n             $root//text()/descendant-or-self::comment(), \n             $root//text()/descendant-or-self::element(), \n             $root//text()/descendant-or-self::document-node(), \n             $root//attribute()/descendant-or-self::processing-instruction(), \n             $root//attribute()/descendant-or-self::text(), \n             $root//attribute()/descendant-or-self::comment(), \n             $root//attribute()/descendant-or-self::element(), \n             $root//attribute()/descendant-or-self::document-node(), \n             $root/.., $root//parent::comment(), \n             $root//parent::processing-instruction(), \n             $root//parent::text(), \n             $root//ancestor::comment(), \n             $root//ancestor::processing-instruction(), \n             $root//ancestor::text(), \n             $root/self::comment(), \n             $root/self::processing-instruction(), \n             $root/self::text(), \n             $root/self::element(), \n             $root//element()/self::text(), \n             $root//element()/self::processing-instruction(), \n             $root//element()/self::document-node(), \n             $root//element()/self::comment(), \n             $root//processing-instruction()/self::text(), \n             $root//processing-instruction()/self::element(), \n             $root//processing-instruction()/self::document-node(), \n             $root//processing-instruction()/self::comment(), \n             $root//text()/self::processing-instruction(), \n             $root//text()/self::element(), \n             $root//text()/self::document-node(), \n             $root//text()/self::comment(), \n             $root//document-node()/self::processing-instruction(), \n             $root//document-node()/self::element(), \n             $root//document-node()/self::text(), \n             $root//document-node()/self::comment() } </empty><ex>{exists($root//*/attribute()/descendant-or-self::node())}</ex></out>".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\n\n        declare variable $root [Error is around here]as document-node() := . treat as document-node();\n        <out>\n        <empty> { (: attribute axis, and all other axes that inference can assert might produce attributes. \n             These are placed first, so we don\'t raise XQTY0024. :) \n             $root/foo/child::attribute(foo), \n             $root//element()/self::attribute(), \n             $root//text()/self::attribute(), \n             $root/self::attribute(), \n             $root/foo/descendant::attribute(foo), \n             $root//processing-instruction()/self::attribute(), \n             $root/attribute(foo), $root/attribute(), \n             $root/attribute::attribute(), \n             $root//parent::attribute(), \n             $root//document-node()/self::attribute(), \n             $root/@*, $root/*/@*[self::*], \n             $root//comment()/descendant-or-self::attribute(), \n             $root//processing-instruction()/descendant-or-self::attribute(), \n             $root//text()/descendant-or-self::attribute(), \n             $root//document-node()/descendant-or-self::attribute(), \n             $root//parent::attribute(), \n             $root//ancestor::attribute(), \n             $root//ancestor-or-self::attribute(), \n             $root/self::attribute(), \n             $root//attribute()/child::node(), \n             $root//attribute::text(), \n             $root//attribute::comment(), \n             $root//attribute::processing-instruction(), \n             $root//attribute::document-node(), \n             $root//attribute::document-node(element(foo)),\n             $root//attribute()/self::text(),\n             $root//attribute()/self::processing-instruction(), \n             $root//attribute()/self::element(), \n             $root//attribute()/self::document-node(), \n             $root//attribute()/self::comment(), \n             $root//*/attribute()//node(), \n             $root//*/attribute()/descendant::node(), \n             $root//attribute::element(), \n             $root//comment()/child::node(), \n             $root//processing-instruction()/child::node(), \n             $root//text()/child::node(),\n             $root//attribute()/descendant::node(), \n             $root//comment()/descendant::node(), \n             $root//text()/descendant::node(), \n             $root//processing-instruction()/descendant::node(), \n             $root//comment()/descendant-or-self::text(), \n             $root//comment()/descendant-or-self::processing-instruction(), \n             $root//comment()/descendant-or-self::element(), \n             $root//comment()/descendant-or-self::document-node(), \n             $root//processing-instruction()/descendant-or-self::text(), \n             $root//processing-instruction()/descendant-or-self::comment(), \n             $root//processing-instruction()/descendant-or-self::element(), \n             $root//processing-instruction()/descendant-or-self::document-node(), \n             $root//text()/descendant-or-self::processing-instruction(), \n             $root//text()/descendant-or-self::comment(), \n             $root//text()/descendant-or-self::element(), \n             $root//text()/descendant-or-self::document-node(), \n             $root//attribute()/descendant-or-self::processing-instruction(), \n             $root//attribute()/descendant-or-self::text(), \n             $root//attribute()/descendant-or-self::comment(), \n             $root//attribute()/descendant-or-self::element(), \n             $root//attribute()/descendant-or-self::document-node(), \n             $root/.., $root//parent::comment(), \n             $root//parent::processing-instruction(), \n             $root//parent::text(), \n             $root//ancestor::comment(), \n             $root//ancestor::processing-instruction(), \n             $root//ancestor::text(), \n             $root/self::comment(), \n             $root/self::processing-instruction(), \n             $root/self::text(), \n             $root/self::element(), \n             $root//element()/self::text(), \n             $root//element()/self::processing-instruction(), \n             $root//element()/self::document-node(), \n             $root//element()/self::comment(), \n             $root//processing-instruction()/self::text(), \n             $root//processing-instruction()/self::element(), \n             $root//processing-instruction()/self::document-node(), \n             $root//processing-instruction()/self::comment(), \n             $root//text()/self::processing-instruction(), \n             $root//text()/self::element(), \n             $root//text()/self::document-node(), \n             $root//text()/self::comment(), \n             $root//document-node()/self::processing-instruction(), \n             $root//document-node()/self::element(), \n             $root//document-node()/self::text(), \n             $root//document-node()/self::comment() } </empty><ex>{exists($root//*/attribute()/descendant-or-self::node())}</ex></out>'.
K2-Axes-88,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-Axes-89,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-Axes-99,AssertionError: Expected executing the XPath "declare function foo() external; 1" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XQST0060: Functions declared in a module must reside in a namespace.', AssertionError: expected [Function] to throw error including 'XPST0017' but got 'XQST0060: Functions declared in a module must reside in a namespace.'.
K2-Axes-102,Error: XPST0003: Unable to parse XPath: "         for $a in (/) return          for $b in $a/child::site return          for $c in $b/child::people return          for $d in $c/child::person return              if ((some $id in $d/attribute::id satisfies                      typeswitch ($id)                      case $n as node() return $id = "person0"                      default $d return ()))              then $d/child::name              else (),          for $b in /site/people/person where $b/@id="person0" return $b/name,          /site/people/person[@id eq "person0"]/name". Expected "!", "!=", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "(" found.          for $a in (/) return          for $b in $a/child::site return          for $c in $b/child::people return          for $d in $c/child::person return              if ((some $id in $d/attribute::id satisfies                      typeswitch [Error is around here]($id)                      case $n as node() return $id = "person0"                      default $d return ()))              then $d/child::name              else (),          for $b in /site/people/person where $b/@id="person0" return $b/name,          /site/people/person[@id eq "person0"]/name
abbreviatedSyntax-2,AssertionError: for $h in (/works/employee[2]) return $h/text(): expected '\n    \n    \n    \n    Text data from Employee[2]\n  ' to equal 'Text data from Employee[2]'
abbreviatedSyntax-26,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
K2-ancestorAxis-4,AssertionError: Expected executing the XPath "empty(attribute name {"content"}/ancestor::node())" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "empty(attribute name {"content"}/ancestor::node())". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. empty(attribute [Error is around here]name {"content"}/ancestor::node()), AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "empty(attribute name {"content"}/ancestor::node())".\nExpected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.\nempty(attribute [Error is around here]name {"content"}/ancestor::node())'.
K2-ancestorAxis-5,AssertionError: Expected executing the XPath "empty(document {()}/ancestor::node())" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "empty(document {()}/ancestor::node())". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. empty(document [Error is around here]{()}/ancestor::node()), AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "empty(document {()}/ancestor::node())".\nExpected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.\nempty(document [Error is around here]{()}/ancestor::node())'.
K2-ancestorAxis-6,AssertionError: Expected executing the XPath "empty(document {<e><f/><f/>text</e>}/ancestor::node())" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "empty(document {<e><f/><f/>text</e>}/ancestor::node())". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. empty(document [Error is around here]{<e><f/><f/>text</e>}/ancestor::node()), AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "empty(document {<e><f/><f/>text</e>}/ancestor::node())".\nExpected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.\nempty(document [Error is around here]{<e><f/><f/>text</e>}/ancestor::node())'.
K2-ancestorAxis-9,AssertionError: Expected XPath <a> <b c=""> <c/> </b> <d/> </a>/b/c/(ancestor::*)[1] to resolve to the given XML. Expected <b c=""><c/></b> to equal <a><b c=""><c/></b><d/></a>
K2-ancestorAxis-12,AssertionError: Expected XPath <a> <b c=""> <c/> </b> <d/> </a>/b/c/(ancestor::*)[last()] to resolve to the given XML. Expected <a><b c=""><c/></b><d/></a> to equal <b c=""><c/></b>
K2-ancestorAxis-15,Error: XPST0003: Unable to parse XPath: "1, attribute name {"content"}/ancestor::node(), 1". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found. 1, attribute [Error is around here]name {"content"}/ancestor::node(), 1
K2-ancestorAxis-17,AssertionError: Expected executing the XPath "document {()}/ancestor::node(), count(document {()}/ancestor::node()), 1" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "document {()}/ancestor::node(), count(document {()}/ancestor::node()), 1". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. document [Error is around here]{()}/ancestor::node(), count(document {()}/ancestor::node()), 1, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "document {()}/ancestor::node(), count(document {()}/ancestor::node()), 1".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\ndocument [Error is around here]{()}/ancestor::node(), count(document {()}/ancestor::node()), 1'.
K2-ancestorAxis-18,Error: XPST0003: Unable to parse XPath: "1, text {""}/ancestor::node(), 1". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. 1, text [Error is around here]{""}/ancestor::node(), 1
K2-ancestor-or-selfAxis-3,Error: XPST0003: Unable to parse XPath: "deep-equal((1, (attribute name {"content"}/ancestor-or-self::node() instance of attribute(name)), 1), (1, true(), 1))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. deep-equal((1, (attribute [Error is around here]name {"content"}/ancestor-or-self::node() instance of attribute(name)), 1), (1, true(), 1))
K2-ancestor-or-selfAxis-5,Error: XPST0003: Unable to parse XPath: "let $result := (1, document {()}/ancestor-or-self::node(), 1) return $result[1] eq 1". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. let $result := (1, document [Error is around here]{()}/ancestor-or-self::node(), 1) return $result[1] eq 1
K2-ancestor-or-selfAxis-6,Error: XPST0003: Unable to parse XPath: "let $result := (1, text {""}/ancestor-or-self::node(), 1) return $result[1] eq 1". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. let $result := (1, text [Error is around here]{""}/ancestor-or-self::node(), 1) return $result[1] eq 1
K2-followingAxis-2,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-followingAxis-3,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-followingAxis-4,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-following-siblingAxis-4,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-following-siblingAxis-5,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-following-siblingAxis-6,AssertionError: expected [Function] to throw error including 'XPTY0018' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-precedingAxis-1,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-precedingAxis-2,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-precedingAxis-3,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-precedingAxis-4,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-precedingAxis-5,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-precedingAxis-6,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-precedingAxis-7,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-precedingAxis-8,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-preceding-siblingAxis-1,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-preceding-siblingAxis-2,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-preceding-siblingAxis-3,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-preceding-siblingAxis-4,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-preceding-siblingAxis-5,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
unabbreviatedSyntax-3,AssertionError: for $h in (/works[1]/employee[2]) return $h/child::text(): expected '\n    \n    \n    \n    Text data from Employee[2]\n  ' to equal 'Text data from Employee[2]'
CastableAs647,Error: Casting to xs:QName is not implemented.
CastableAs648,Error: Casting to xs:QName is not implemented.
CastableAs648a,Error: Casting to xs:QName is not implemented.
K-SeqExprCastable-5,AssertionError: expected [Function] to throw error including 'XPST0051' but got 'XPST0080: Casting to xs:anyAtomicType, xs:anySimpleType or xs:NOTATION is not permitted.'
K-SeqExprCastable-6,AssertionError: expected [Function] to throw an error
K-SeqExprCastable-6a,AssertionError: expected [Function] to throw an error
K-SeqExprCastable-19,Error: Casting to xs:QName is not implemented.
K-SeqExprCastable-22,AssertionError: Expected executing the XPath "not(xs:untypedAtomic("ncname") castable as xs:QName)" to resolve to one of the expected results, but got Error: Casting to xs:QName is not implemented., Error: Casting to xs:QName is not implemented..
K2-SeqExprCastable-4,AssertionError: expected [Function] to throw an error
K2-SeqExprCastable-6,AssertionError: Expected XPath "%" castable as xs:anyURI to resolve to false: expected true to be false
K2-SeqExprCastable-7,AssertionError: Expected XPath xs:untypedAtomic("%") castable as xs:anyURI to resolve to false: expected true to be false
cbcl-castable-date-001,Error: FODT0001: Datetime year is out of bounds
cbcl-castable-date-002,Error: FODT0001: Datetime year is out of bounds
cbcl-castable-dateTime-001,Error: FODT0001: Datetime year is out of bounds
cbcl-castable-dateTime-002,Error: FODT0001: Datetime year is out of bounds
cbcl-castable-dayTimeDuration-001,Error: FODT0002: Number of seconds given to construct DayTimeDuration overflows MAX_SAFE_INTEGER or MIN_SAFE_INTEGER
cbcl-castable-dayTimeDuration-002,Error: FODT0002: Number of seconds given to construct DayTimeDuration overflows MAX_SAFE_INTEGER or MIN_SAFE_INTEGER
cbcl-castable-duration-001,Error: FODT0002: Value overflow while constructing xs:yearMonthDuration
cbcl-castable-duration-002,Error: FODT0002: Value overflow while constructing xs:yearMonthDuration
cbcl-castable-yearMonthDuration-001,Error: FODT0002: Value overflow while constructing xs:yearMonthDuration
cbcl-castable-yearMonthDuration-002,Error: FODT0002: Value overflow while constructing xs:yearMonthDuration
cbcl-castable-gYear-001,Error: FODT0001: Datetime year is out of bounds
cbcl-castable-gYearMonth-001,Error: FODT0001: Datetime year is out of bounds
casthc12,AssertionError: xs:double(1267.43233E12) cast as xs:double: expected '1267432330000000' to equal '1.26743233E15'
casthc13,AssertionError: xs:double(1267.43233E12) cast as xs:string: expected '1267432330000000' to equal '1.26743233E15'
casthc17,AssertionError: xs:decimal(12678967.543233) cast as xs:float: expected '12678967.543233' to equal '1.2678968E7'
casthc18,AssertionError: xs:decimal(12678967.543233) cast as xs:double: expected '12678967.543233' to equal '1.2678967543233E7'
casthc24,AssertionError: xs:integer(12678967543233) cast as xs:double: expected '12678967543233' to equal '1.2678967543233E13'
CastAs010,AssertionError: xs:untypedAtomic("-10000000") cast as xs:float: expected '-10000000' to equal '-1.0E7'
CastAs015,AssertionError: xs:untypedAtomic("-10000000") cast as xs:double: expected '-10000000' to equal '-1.0E7'
CastAs028,AssertionError: xs:untypedAtomic("-P1Y1M1DT1H1M1.123S") cast as xs:duration: expected '-P1Y1M1DT1H1M1.1230000000068685S' to equal '-P1Y1M1DT1H1M1.123S'
CastAs092,AssertionError: xs:string("-10000000") cast as xs:float: expected '-10000000' to equal '-1.0E7'
CastAs097,AssertionError: xs:string("-10000000") cast as xs:double: expected '-10000000' to equal '-1.0E7'
CastAs110,AssertionError: xs:string("-P1Y1M1DT1H1M1.123S") cast as xs:duration: expected '-P1Y1M1DT1H1M1.1230000000068685S' to equal '-P1Y1M1DT1H1M1.123S'
CastAs169,AssertionError: Expected executing the XPath "xs:float("5.4321E-100") cast as xs:float" to resolve to one of the expected results, but got AssertionError: Expected XPath xs:float("5.4321E-100") cast as xs:float to resolve to 0: expected false to be true, AssertionError: expected [Function] to throw an error.
CastAs175,AssertionError: Expected XPath xs:float("5.4321E-100") cast as xs:decimal to resolve to 0: expected false to be true
CastAs201,AssertionError: xs:double("1e8") cast as xs:string: expected '100000000' to equal '1.0E8'
CastAs334,AssertionError: xs:dayTimeDuration("PT24H") cast as xs:duration: expected 'P1DT' to equal 'P1D'
CastAs338,AssertionError: xs:dayTimeDuration("P14D") cast as xs:dayTimeDuration: expected 'P14DT' to equal 'P14D'
CastAs600,AssertionError: xs:base64Binary("aA+zZ/09") cast as xs:hexBinary: expected '68FB367FD3D' to equal '680FB367FD3D'
CastAs647,AssertionError: Expected executing the XPath "xs:string(2.123456789123456789) cast as xs:decimal" to resolve to one of the expected results, but got AssertionError: xs:string(2.123456789123456789) cast as xs:decimal: expected '2.123456789123457' to equal '2.123456789123456789', AssertionError: expected [Function] to throw an error.
CastAs670,AssertionError: Expected executing the XPath "let $d1 := '2006-07-12' cast as xs:date let $oneky := xs:yearMonthDuration('P1000Y') let $d2 := $d1 + $oneky let $d3 := $d2 + $oneky let $d4 := $d3 + $oneky let $d5 := $d4 + $oneky let $d6 := $d5 + $oneky let $d7 := $d6 + $oneky let $d8 := $d7 + $oneky let $d9 := $d8 + $oneky let $d10 := $d9 + $oneky return $d10" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "let $d1 := '2006-07-12' cast as xs:date let $oneky := xs:yearMonthDuration('P1000Y') let $d2 := $d1 + $oneky let $d3 := $d2 + $oneky let $d4 := $d3 + $oneky let $d5 := $d4 + $oneky let $d6 := $d5 + $oneky let $d7 := $d6 + $oneky let $d8 := $d7 + $oneky let $d9 := $d8 + $oneky let $d10 := $d9 + $oneky return $d10". Expected " ", "!=", "(:", "*", "+", ",", "-", "<", "<<", "<=", "=", ">", ">=", ">>", "\n", "\r", "\t", "and", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. let $d1 := '2006-07-12' cast as xs:date [Error is around here]let $oneky := xs:yearMonthDuration('P1000Y') let $d2 := $d1 + $oneky let $d3 := $d2 + $oneky let $d4 := $d3 + $oneky let $d5 := $d4 + $oneky let $d6 := $d5 + $oneky let $d7 := $d6 + $oneky let $d8 := $d7 + $oneky let $d9 := $d8 + $oneky let $d10 := $d9 + $oneky return $d10, AssertionError: expected [Function] to throw error including 'FODT0001' but got 'XPST0003: Unable to parse XPath: "let $d1 := \'2006-07-12\' cast as xs:date let $oneky := xs:yearMonthDuration(\'P1000Y\') let $d2 := $d1 + $oneky let $d3 := $d2 + $oneky let $d4 := $d3 + $oneky let $d5 := $d4 + $oneky let $d6 := $d5 + $oneky let $d7 := $d6 + $oneky let $d8 := $d7 + $oneky let $d9 := $d8 + $oneky let $d10 := $d9 + $oneky return $d10".\nExpected " ", "!=", "(:", "*", "+", ",", "-", "<", "<<", "<=", "=", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.\nlet $d1 := \'2006-07-12\' cast as xs:date [Error is around here]let $oneky := xs:yearMonthDuration(\'P1000Y\') let $d2 := $d1 + $oneky let $d3 := $d2 + $oneky let $d4 := $d3 + $oneky let $d5 := $d4 + $oneky let $d6 := $d5 + $oneky let $d7 := $d6 + $oneky let $d8 := $d7 + $oneky let $d9 := $d8 + $oneky let $d10 := $d9 + $oneky return $d10'.
CastAs673a,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
CastAs673b,Error: Casting to xs:QName is not implemented.
CastAs674,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
CastAs674a,Error: Casting to xs:QName is not implemented.
CastAs675,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
CastAs675a,AssertionError: expected [Function] to throw error including 'XPTY0117' but got 'Casting to xs:QName is not implemented.'
CastAs677,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
CastAs678,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
CastAsNamespaceSensitiveType-1,AssertionError: expected [Function] to throw error including 'XPTY0117' but got 'Casting to xs:QName is not implemented.'
CastAsNamespaceSensitiveType-2,AssertionError: expected [Function] to throw error including 'XPTY0117' but got 'Casting to xs:QName is not implemented.'
CastAsNamespaceSensitiveType-4,AssertionError: expected [Function] to throw error including 'XPTY0117' but got 'XPST0080: Casting to xs:NOTATION is not permitted.'
CastAsNamespaceSensitiveType-5,AssertionError: expected [Function] to throw error including 'XPTY0117' but got 'XPST0080: Casting to xs:NOTATION is not permitted.'
CastFOCA0003-1,AssertionError: Expected executing the XPath "xs:integer(99e100)" to resolve to one of the expected results, but got Error: FOAR0002: can not cast 9.9e+101 to xs:integer, it is out of bounds for JavaScript numbers., AssertionError: expected [Function] to throw error including 'FOCA0003' but got 'FOAR0002: can not cast 9.9e+101 to xs:integer, it is out of bounds for JavaScript numbers.'.
K-SeqExprCast-4,AssertionError: expected [Function] to throw error including 'XPST0051' but got 'XPST0080: Casting to xs:anyAtomicType, xs:anySimpleType or xs:NOTATION is not permitted.'
K-SeqExprCast-5,AssertionError: expected [Function] to throw error including 'XPST0051' but got 'XPST0081: Can not cast: type xs:untyped is unknown.'
K-SeqExprCast-5a,AssertionError: expected [Function] to throw error including 'XQST0052' but got 'XPST0081: Can not cast: type xs:untyped is unknown.'
K-SeqExprCast-7,AssertionError: expected [Function] to throw error including 'XPST0051' but got 'XPST0081: Can not cast: type xs:anyType is unknown.'
K-SeqExprCast-7a,AssertionError: expected [Function] to throw error including 'XQST0052' but got 'XPST0081: Can not cast: type xs:anyType is unknown.'
K-SeqExprCast-9,AssertionError: expected [Function] to throw error including 'XPST0051' but got 'XPST0081: Can not cast: type xs:doesNotExist is unknown.'
K-SeqExprCast-9a,AssertionError: expected [Function] to throw error including 'XQST0052' but got 'XPST0081: Can not cast: type xs:doesNotExist is unknown.'
K-SeqExprCast-68,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-71a,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-71b,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-127,AssertionError: Expected XPath xs:string(xs:base64Binary("aaa a")) eq "aaaa" to resolve to true: expected false to be true
K-SeqExprCast-143,Error: XPST0003: Unable to parse XPath: "xs:hexBinary(remove(("3B", 1.1), 2) treat as xs:string)". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found. xs:hexBinary(remove(("3B", 1.1), 2) [Error is around here]treat as xs:string)
K-SeqExprCast-150,AssertionError: expected [Function] to throw an error
K-SeqExprCast-151,AssertionError: expected [Function] to throw an error
K-SeqExprCast-152,AssertionError: expected [Function] to throw an error
K-SeqExprCast-158,AssertionError: Expected XPath xs:string(xs:duration("-P2000Y11M5DT0H0M0.000S")) eq "-P2000Y11M5D" to resolve to true: expected false to be true
K-SeqExprCast-159,AssertionError: Expected XPath xs:string(xs:duration("P365D")) eq "P365D" to resolve to true: expected false to be true
K-SeqExprCast-161,AssertionError: Expected XPath xs:string(xs:duration("P31D")) eq "P31D" to resolve to true: expected false to be true
K-SeqExprCast-163,AssertionError: Expected XPath xs:string(xs:duration("P31DT3H2M10.001S")) eq "P31DT3H2M10.001S" to resolve to true: expected false to be true
K-SeqExprCast-165,AssertionError: Expected XPath xs:string(xs:duration(xs:dayTimeDuration("P31DT3H2M10.001S"))) eq "P31DT3H2M10.001S" to resolve to true: expected false to be true
K-SeqExprCast-167,AssertionError: Expected XPath xs:string(xs:duration(xs:dayTimeDuration("-P31DT3H2M10.001S"))) eq "-P31DT3H2M10.001S" to resolve to true: expected false to be true
K-SeqExprCast-172,AssertionError: expected [Function] to throw an error
K-SeqExprCast-173,AssertionError: expected [Function] to throw an error
K-SeqExprCast-174,AssertionError: expected [Function] to throw an error
K-SeqExprCast-182,AssertionError: Expected XPath xs:string(xs:dayTimeDuration("-P5DT0H0M0.000S")) eq "-P5D" to resolve to true: expected false to be true
K-SeqExprCast-186,AssertionError: Expected XPath xs:string(xs:dayTimeDuration("PT1M1231.432S")) eq "PT21M31.432S" to resolve to true: expected false to be true
K-SeqExprCast-187,AssertionError: Expected XPath xs:string(xs:dayTimeDuration("P31DT3H2M10.001S")) eq "P31DT3H2M10.001S" to resolve to true: expected false to be true
K-SeqExprCast-189,AssertionError: Expected XPath xs:string(xs:dayTimeDuration(xs:duration("P3Y0M31DT3H2M10.001S"))) eq "P31DT3H2M10.001S" to resolve to true: expected false to be true
K-SeqExprCast-191,AssertionError: Expected XPath xs:string(xs:dayTimeDuration(xs:duration("-P3Y0M31DT3H2M10.001S"))) eq "-P31DT3H2M10.001S" to resolve to true: expected false to be true
K-SeqExprCast-193,AssertionError: Expected XPath xs:string(xs:dayTimeDuration("P3D")) eq "P3D" to resolve to true: expected false to be true
K-SeqExprCast-295,AssertionError: expected [Function] to throw an error
K-SeqExprCast-297,AssertionError: expected [Function] to throw an error
K-SeqExprCast-298,AssertionError: expected [Function] to throw an error
K-SeqExprCast-299,AssertionError: expected [Function] to throw an error
K-SeqExprCast-312,AssertionError: expected [Function] to throw an error
K-SeqExprCast-350,AssertionError: Expected XPath string(xs:dateTime("2004-03-31T24:00:00")) eq "2004-04-01T00:00:00" to resolve to true: expected false to be true
K-SeqExprCast-379,AssertionError: expected [Function] to throw an error
K-SeqExprCast-422,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-422a,AssertionError: expected [Function] to throw error including 'FORG0001' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-423,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-482,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-483,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-530,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-531,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-582,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-583,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-634,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-635,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-686,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-687,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-738,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-739,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-790,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-791,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-842,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-843,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-894,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-895,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-946,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-947,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-998,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-999,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-1050,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-1051,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-1102,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-1103,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-1154,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-1155,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-1206,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-1207,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-1258,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-1259,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-1310,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-1311,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-1362,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-1363,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-1414,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-1415,Error: Casting to xs:QName is not implemented.
K2-SeqExprCast-1,Error: Casting to xs:QName is not implemented.
K2-SeqExprCast-5,Error: FOCA0003: can not cast 9223372036854775807 to xs:integer, it is out of bounds for JavaScript numbers.
K2-SeqExprCast-15,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K2-SeqExprCast-16,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K2-SeqExprCast-17,AssertionError: Expected executing the XPath "xs:long("-9223372036854775808")" to resolve to one of the expected results, but got Error: FOCA0003: can not cast -9223372036854775808 to xs:integer, it is out of bounds for JavaScript numbers., AssertionError: expected [Function] to throw error including 'FOAR0002' but got 'FOCA0003: can not cast -9223372036854775808 to xs:integer, it is out of bounds for JavaScript numbers.'.
K2-SeqExprCast-21,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K2-SeqExprCast-22,AssertionError: Expected executing the XPath "xs:unsignedLong("18446744073709551615")" to resolve to one of the expected results, but got Error: FOCA0003: can not cast 18446744073709551615 to xs:integer, it is out of bounds for JavaScript numbers., AssertionError: expected [Function] to throw error including 'FOAR0002' but got 'FOCA0003: can not cast 18446744073709551615 to xs:integer, it is out of bounds for JavaScript numbers.'.
K2-SeqExprCast-26,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K2-SeqExprCast-78,AssertionError: Expected executing the XPath "xs:long("-9223372036854775809")" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FORG0001' but got 'FOCA0003: can not cast -9223372036854775809 to xs:integer, it is out of bounds for JavaScript numbers.', AssertionError: expected [Function] to throw error including 'FOAR0002' but got 'FOCA0003: can not cast -9223372036854775809 to xs:integer, it is out of bounds for JavaScript numbers.'.
K2-SeqExprCast-90,AssertionError: Expected executing the XPath "xs:long("9223372036854775808")" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FORG0001' but got 'FOCA0003: can not cast 9223372036854775808 to xs:integer, it is out of bounds for JavaScript numbers.', AssertionError: expected [Function] to throw error including 'FOAR0002' but got 'FOCA0003: can not cast 9223372036854775808 to xs:integer, it is out of bounds for JavaScript numbers.'.
K2-SeqExprCast-210,AssertionError: expected [Function] to throw an error
K2-SeqExprCast-214,AssertionError: xs:double(xs:int("-1873914410")): expected '-1873914410' to equal '-1.87391441E9'
K2-SeqExprCast-231,AssertionError: expected [Function] to throw an error
K2-SeqExprCast-232,AssertionError: expected [Function] to throw an error
K2-SeqExprCast-422,AssertionError: expected [Function] to throw an error
K2-SeqExprCast-423,AssertionError: expected [Function] to throw an error
K2-SeqExprCast-424,AssertionError: expected [Function] to throw an error
K2-SeqExprCast-480,AssertionError: xs:untypedAtomic("xs:untypedAtomic"), xs:dateTime("2002-10-10T23:02:12Z"), xs:date("2002-10-10Z"), xs:time("23:02:12Z"),                 xs:duration("P12M"), xs:dayTimeDuration("PT1S"), xs:yearMonthDuration("P1M"), xs:float("3e3"), xs:double("4e4"),                 xs:decimal("2.0"), xs:integer("16"), xs:nonPositiveInteger("0"), xs:negativeInteger("-4"), xs:long("5"),                 xs:int("6"), xs:short("7"), xs:byte("8"), xs:nonNegativeInteger("9"), xs:unsignedLong("10"),                 xs:unsignedInt("11"), xs:unsignedShort("12"), xs:unsignedByte("13"), xs:positiveInteger("14"),                 xs:gYearMonth("1976-02Z"), xs:gYear("2005-12:00"), xs:gMonthDay("--12-25-14:00"),                 xs:gDay("---25-14:00"), xs:gMonth("--12-14:00"), xs:boolean("true"), xs:base64Binary("aaaa"),                 xs:hexBinary("FFFF"), xs:anyURI("http://example.com/"), xs:QName("localName"),                 xs:string("An xs:string"), xs:normalizedString("normalizedString"), xs:token("token"),                 xs:language("language"), xs:NMTOKEN("NMTOKEN"), xs:Name("Name"), xs:NCName("NCName"),                 xs:ID("ID"), xs:IDREF("IDREF"), xs:ENTITY("ENTITY"): expected 'xs:untypedAtomic 2002-10-10T23:02:12Z 2002-10-10Z 23:02:12Z P1Y PT1S P1M 3000 40000 2 16 0 -4 5 6 7 8 9 10 11 12 13 14 1976-02Z 2005-12:00 --12-25-14:00 ---25-14:00 --12-14:00 true aaaa FFFF http://example.com/ localName An xs:string normalizedString token language NMTOKEN Name NCName ID IDREF ENTITY' to equal '\n             xs:untypedAtomic 2002-10-10T23:02:12Z 2002-10-10Z 23:02:12Z P1Y PT1S P1M 3000 40000 2 16 0\n             -4 5 6 7 8 9 10 11 12 13 14 1976-02Z 2005-12:00 --12-25-14:00 ---25-14:00 --12-14:00 true\n             aaaa FFFF http://example.com/ localName An xs:string normalizedString token language\n             NMTOKEN Name NCName ID IDREF ENTITY'
K2-SeqExprCast-504,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
K2-SeqExprCast-505,AssertionError: expected [Function] to throw an error
cbcl-cast-decimal-001,AssertionError: Expected executing the XPath "1.7976931348623157E+308 cast as xs:decimal" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw an error, AssertionError: 1.7976931348623157E+308 cast as xs:decimal: expected false to be true.
cbcl-cast-decimal-002,AssertionError: Expected executing the XPath "-1.7976931348623157E+308 cast as xs:decimal" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw an error, AssertionError: -1.7976931348623157E+308 cast as xs:decimal: expected false to be true.
cbcl-cast-decimal-003,AssertionError: Expected executing the XPath "xs:float('3.402823e38') cast as xs:decimal" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw an error, AssertionError: xs:float('3.402823e38') cast as xs:decimal: expected false to be true.
cbcl-cast-decimal-004,AssertionError: Expected executing the XPath "xs:float('-3.402823e38') cast as xs:decimal" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw an error, AssertionError: xs:float('-3.402823e38') cast as xs:decimal: expected false to be true.
cbcl-cast-integer-001,AssertionError: Expected executing the XPath "1.7976931348623157E+308 cast as xs:integer" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FOCA0003' but got 'FOAR0002: can not cast 1.7976931348623157e+308 to xs:integer, it is out of bounds for JavaScript numbers.', Error: FOAR0002: can not cast 1.7976931348623157e+308 to xs:integer, it is out of bounds for JavaScript numbers..
cbcl-cast-integer-002,AssertionError: Expected executing the XPath "-1.7976931348623157E+308 cast as xs:integer" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FOCA0003' but got 'FOAR0002: can not cast -1.7976931348623157e+308 to xs:integer, it is out of bounds for JavaScript numbers.', Error: FOAR0002: can not cast -1.7976931348623157e+308 to xs:integer, it is out of bounds for JavaScript numbers..
cbcl-cast-integer-003,AssertionError: Expected executing the XPath "xs:float('3.402823e38') cast as xs:integer" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FOCA0003' but got 'FOAR0002: can not cast 3.402823e+38 to xs:integer, it is out of bounds for JavaScript numbers.', Error: FOAR0002: can not cast 3.402823e+38 to xs:integer, it is out of bounds for JavaScript numbers..
cbcl-cast-integer-004,AssertionError: Expected executing the XPath "xs:float('-3.402823e38') cast as xs:integer" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FOCA0003' but got 'FOAR0002: can not cast -3.402823e+38 to xs:integer, it is out of bounds for JavaScript numbers.', Error: FOAR0002: can not cast -3.402823e+38 to xs:integer, it is out of bounds for JavaScript numbers..
cbcl-cast-long-003,AssertionError: expected [Function] to throw error including 'FORG0001' but got 'FOCA0003: can not cast 9223372036854775808 to xs:integer, it is out of bounds for JavaScript numbers.'
cbcl-cast-long-004,AssertionError: expected [Function] to throw error including 'FORG0001' but got 'FOCA0003: can not cast -9223372036854775809 to xs:integer, it is out of bounds for JavaScript numbers.'
cbcl-cast-unsignedLong-003,AssertionError: expected [Function] to throw error including 'FORG0001' but got 'FOCA0003: can not cast 18446744073709551616 to xs:integer, it is out of bounds for JavaScript numbers.'
cbcl-cast-gYear-002,AssertionError: expected [Function] to throw an error
cbcl-cast-gYear-003,AssertionError: expected [Function] to throw an error
cbcl-cast-gYearMonth-003,AssertionError: expected [Function] to throw an error
XQueryComment014,Error: XPST0003: Unable to parse XPath: "(: Name: XQueryComment014 :) (: Description: Comments inside a cast expression :)   "10" cast as (: type comment :) xs:integer ?   = 10". Expected " ", "!=", "(:", "*", "+", ",", "-", "<", "<<", "<=", "=", ">", ">=", ">>", "\n", "\r", "\t", "and", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "?" found. (: Name: XQueryComment014 :) (: Description: Comments inside a cast expression :)   "10" cast as (: type comment :) xs:integer [Error is around here]?   = 10
K2-XQueryComment-3,Error: XPST0003: Unable to parse XPath: "(:*******************************************************:) (: Test: K2-XQueryComment-3                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:21+01:00                       :) (: Purpose: Have a computed comment constructor as a last step. :) (:*******************************************************:) let $i := <e>                                             <b/>                                             <b/>                                             <b/>                                         </e>                                         return $i/b/comment(: some : content (:some content:):){"content"}  ". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. (:*******************************************************:) (: Test: K2-XQueryComment-3                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:21+01:00                       :) (: Purpose: Have a computed comment constructor as a last step. :) (:*******************************************************:) let $i := <e>                                             <b/>                                             <b/>                                             <b/>                                         </e>                                         return $i/b/comment(: some : content (:some content:):)[Error is around here]{"content"}
Constr-compattr-name-1,Error: XPST0003: Unable to parse XPath: "element elem {attribute attr {'text'}}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. element [Error is around here]elem {attribute attr {'text'}}
Constr-compattr-name-2,Error: XPST0003: Unable to parse XPath: "declare namespace foo="http://www.example.com/foo"; element elem {attribute foo:attr {'text'}}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. declare namespace foo="http://www.example.com/foo"; element [Error is around here]elem {attribute foo:attr {'text'}}
Constr-compattr-name-3,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPST0003: Unable to parse XPath: "element elem {attribute foo:attr {\'text\'}}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.\nelement [Error is around here]elem {attribute foo:attr {\'text\'}}'
Constr-compattr-name-4,Error: XPST0003: Unable to parse XPath: "let $result := (element x { attribute Q{http://example.com/x}y { } }) return $result[self::x/@*[local-name()='y' and namespace-uri()='http://example.com/x']]". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "x" found. let $result := (element [Error is around here]x { attribute Q{http://example.com/x}y { } }) return $result[self::x/@*[local-name()='y' and namespace-uri()='http://example.com/x']]
Constr-compattr-compname-1,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "element elem {attribute {()} {\'text\'}}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.\nelement [Error is around here]elem {attribute {()} {\'text\'}}'
Constr-compattr-compname-2,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "element elem {attribute {\'one\', \'two\'} {\'text\'}}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.\nelement [Error is around here]elem {attribute {\'one\', \'two\'} {\'text\'}}'
Constr-compattr-compname-3,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "element elem {attribute {xs:untypedAtomic(\'one\'), xs:untypedAtomic(\'two\')} {\'text\'}}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.\nelement [Error is around here]elem {attribute {xs:untypedAtomic(\'one\'), xs:untypedAtomic(\'two\')} {\'text\'}}'
Constr-compattr-compname-4,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "element elem {attribute {//a} {\'text\'}}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.\nelement [Error is around here]elem {attribute {//a} {\'text\'}}'
Constr-compattr-compname-5,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "element elem {attribute {1,2} {\'text\'}}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.\nelement [Error is around here]elem {attribute {1,2} {\'text\'}}'
Constr-compattr-compname-6,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "element elem {attribute {123} {\'text\'}}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.\nelement [Error is around here]elem {attribute {123} {\'text\'}}'
Constr-compattr-compname-7,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "element elem {attribute {xs:dateTime("1999-05-31T13:20:00")} {\'text\'}}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.\nelement [Error is around here]elem {attribute {xs:dateTime("1999-05-31T13:20:00")} {\'text\'}}'
Constr-compattr-compname-8,Error: XPST0003: Unable to parse XPath: "element elem {attribute {//*:NCName[1]} {'text'}}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. element [Error is around here]elem {attribute {//*:NCName[1]} {'text'}}
Constr-compattr-compname-9,Error: XPST0003: Unable to parse XPath: "element elem {attribute {xs:QName('aQname')} {'text'}}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. element [Error is around here]elem {attribute {xs:QName('aQname')} {'text'}}
Constr-compattr-compname-10,Error: XPST0003: Unable to parse XPath: "element elem {attribute {'attr'} {'text'}}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. element [Error is around here]elem {attribute {'attr'} {'text'}}
Constr-compattr-compname-11,Error: XPST0003: Unable to parse XPath: "element elem {attribute {'attr', ()} {'text'}}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. element [Error is around here]elem {attribute {'attr', ()} {'text'}}
Constr-compattr-compname-12,Error: XPST0003: Unable to parse XPath: "element elem {attribute {(), 'attr'} {'text'}}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. element [Error is around here]elem {attribute {(), 'attr'} {'text'}}
Constr-compattr-compname-13,Error: XPST0003: Unable to parse XPath: "<elem xmlns:foo="http://www.example.com/foo">{element elem {attribute {'foo:attr'} {}}}</elem>". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "e" found. <elem xmlns:foo="http://www.example.com/foo">{element [Error is around here]elem {attribute {'foo:attr'} {}}}</elem>
Constr-compattr-compname-14,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: "element elem {attribute {\'foo:attr\'} {}}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.\nelement [Error is around here]elem {attribute {\'foo:attr\'} {}}'
Constr-compattr-compname-15,Error: XPST0003: Unable to parse XPath: "element elem {attribute {xs:untypedAtomic('attr')} {'text'}}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. element [Error is around here]elem {attribute {xs:untypedAtomic('attr')} {'text'}}
Constr-compattr-compname-16,Error: XPST0003: Unable to parse XPath: "<elem xmlns:foo="http://www.example.com/foo">{attribute {xs:untypedAtomic('foo:attr')} {'text'}}</elem>". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. <elem xmlns:foo="http://www.example.com/foo">{attribute [Error is around here]{xs:untypedAtomic('foo:attr')} {'text'}}</elem>
Constr-compattr-compname-17,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: "element elem {attribute {xs:untypedAtomic(\'foo:elem\')} {\'text\'}}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.\nelement [Error is around here]elem {attribute {xs:untypedAtomic(\'foo:elem\')} {\'text\'}}'
Constr-compattr-compname-18,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: "element elem {attribute {\'el em\'} {\'text\'}}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.\nelement [Error is around here]elem {attribute {\'el em\'} {\'text\'}}'
Constr-compattr-compname-19,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: "element elem {attribute {xs:untypedAtomic(\'el em\')} {\'text\'}}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.\nelement [Error is around here]elem {attribute {xs:untypedAtomic(\'el em\')} {\'text\'}}'
Constr-compattr-doc-1,Error: XPST0003: Unable to parse XPath: "element elem {attribute attr {., .}}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. element [Error is around here]elem {attribute attr {., .}}
Constr-compattr-parent-1,Error: XPST0003: Unable to parse XPath: "count((attribute attr {})/..) = 0". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "a" found. count((attribute [Error is around here]attr {})/..) = 0
Constr-compattr-string-1,Error: XPST0003: Unable to parse XPath: "fn:string(attribute attr {'a', element a {}, 'b'})". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "a" found. fn:string(attribute [Error is around here]attr {'a', element a {}, 'b'})
Constr-compattr-data-1,Error: XPST0003: Unable to parse XPath: "fn:data(attribute attr {'a', element a {}, 'b'})". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "a" found. fn:data(attribute [Error is around here]attr {'a', element a {}, 'b'})
Constr-compattr-enclexpr-1,Error: XPST0003: Unable to parse XPath: "element elem {attribute attr {1,'string',3.14,xs:float('1.2345e-2'),xs:dateTime('2002-04-02T12:00:00-01:00')}}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. element [Error is around here]elem {attribute attr {1,'string',3.14,xs:float('1.2345e-2'),xs:dateTime('2002-04-02T12:00:00-01:00')}}
Constr-compattr-enclexpr-2,Error: XPST0003: Unable to parse XPath: "element elem {attribute attr {<elem>123</elem>, (<elem attr='456'/>)/@attr, (<elem>789</elem>)/text()}}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. element [Error is around here]elem {attribute attr {<elem>123</elem>, (<elem attr='456'/>)/@attr, (<elem>789</elem>)/text()}}
Constr-compattr-enclexpr-3,Error: XPST0003: Unable to parse XPath: "element elem {attribute attr {1,'',2}}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. element [Error is around here]elem {attribute attr {1,'',2}}
Constr-compattr-enclexpr-4,Error: XPST0003: Unable to parse XPath: "element elem {attribute attr {1,<a/>,2}}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. element [Error is around here]elem {attribute attr {1,<a/>,2}}
Constr-compattr-id-1,Error: XPST0003: Unable to parse XPath: "element elem {attribute xml:id {"ncname"}}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. element [Error is around here]elem {attribute xml:id {"ncname"}}
Constr-compattr-id-2,AssertionError: Expected executing the XPath "element elem {attribute xml:id {" ab c d "}}" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "element elem {attribute xml:id {" ab c d "}}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. element [Error is around here]elem {attribute xml:id {" ab c d "}}, AssertionError: expected [Function] to throw error including 'XQDY0091' but got 'XPST0003: Unable to parse XPath: "element elem {attribute xml:id {" ab c d "}}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.\nelement [Error is around here]elem {attribute xml:id {" ab c d "}}'.
constattrerr-1,AssertionError: expected [Function] to throw error including 'XQDY0044' but got 'XPST0003: Unable to parse XPath: "attribute xmlns {}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "x" found.\nattribute [Error is around here]xmlns {}'
K2-ComputeConAttr-2,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: "<elem> <?target content ?> {attribute name {"content"}} </elem>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.\n<elem> <?target content ?> {attribute [Error is around here]name {"content"}} </elem>'
K2-ComputeConAttr-3,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: "<elem> {"a string", attribute name {"content"}} </elem>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.\n<elem> {"a string", attribute [Error is around here]name {"content"}} </elem>'
K2-ComputeConAttr-4,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: "<elem> {"a string", attribute name {"content"}} </elem>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.\n<elem> {"a string", attribute [Error is around here]name {"content"}} </elem>'
K2-ComputeConAttr-5,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: "<elem> <![CDATA[]]> {attribute name {"content"}} </elem>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.\n<elem> <![CDATA[]]> {attribute [Error is around here]name {"content"}} </elem>'
K2-ComputeConAttr-6,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: "<elem> <![CDATA[content]]> {attribute name {"content"}} </elem>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.\n<elem> <![CDATA[content]]> {attribute [Error is around here]name {"content"}} </elem>'
K2-ComputeConAttr-7,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: "<elem> <!-- content --> {attribute name {"content"}} </elem>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.\n<elem> <!-- content --> {attribute [Error is around here]name {"content"}} </elem>'
K2-ComputeConAttr-8,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: "<elem> <!-- comment --> { "a string", 999, attribute name {"content"}, xs:hexBinary("FF") } </elem>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.\n<elem> <!-- comment --> { "a string", 999, attribute [Error is around here]name {"content"}, xs:hexBinary("FF") } </elem>'
K2-ComputeConAttr-9,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: "<elem> <!-- comment --> { "a string", 999, ("another string", attribute name {"content"}, 383), xs:hexBinary("FF") } </elem>".\nExpected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.\n<elem> <!-- comment --> { "a string", 999, ("another string", attribute [Error is around here]name {"content"}, 383), xs:hexBinary("FF") } </elem>'
K2-ComputeConAttr-10,Error: XPST0003: Unable to parse XPath: "<a> <?target content?> {<b>{attribute name{"content"}}</b>} </a>". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found. <a> <?target content?> {<b>{attribute [Error is around here]name{"content"}}</b>} </a>
K2-ComputeConAttr-11,Error: XPST0003: Unable to parse XPath: "<a>{(<?target content?>, attribute name{"content"})[2]} </a>". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. <a>{(<?target content?>, attribute [Error is around here]name{"content"})[2]} </a>
K2-ComputeConAttr-12,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: "<a> <!-- content --> {attribute name{"content"}} </a>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.\n<a> <!-- content --> {attribute [Error is around here]name{"content"}} </a>'
K2-ComputeConAttr-13,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: "<foo > <doo/> {attribute name {"content"}} </foo>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.\n<foo > <doo/> {attribute [Error is around here]name {"content"}} </foo>'
K2-ComputeConAttr-14,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: "declare function local:myFunc() { <a/> }; <b> {local:myFunc()} {attribute name {"content"}} </b>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.\ndeclare function local:myFunc() { <a/> }; <b> {local:myFunc()} {attribute [Error is around here]name {"content"}} </b>'
K2-ComputeConAttr-15,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: "declare function local:myFunc() { comment {"content"} }; <b> {local:myFunc()} {attribute name {"content"}} </b>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.\ndeclare function local:myFunc() { comment [Error is around here]{"content"} }; <b> {local:myFunc()} {attribute name {"content"}} </b>'
K2-ComputeConAttr-16,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: "declare function local:myFunc() as element()+ { <a/> }; <b> {local:myFunc()} {attribute name {"content"}} </b>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.\ndeclare function local:myFunc() as element()+ { <a/> }; <b> {local:myFunc()} {attribute [Error is around here]name {"content"}} </b>'
K2-ComputeConAttr-17,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: "declare function local:myFunc() as item() { <a/> }; <b> {local:myFunc()} {attribute name {"content"}} </b>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.\ndeclare function local:myFunc() as item() { <a/> }; <b> {local:myFunc()} {attribute [Error is around here]name {"content"}} </b>'
K2-ComputeConAttr-18,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: "declare function local:myFunc() as item() { <a/> }; <b> {local:myFunc()} {attribute name {"content"}} </b>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.\ndeclare function local:myFunc() as item() { <a/> }; <b> {local:myFunc()} {attribute [Error is around here]name {"content"}} </b>'
K2-ComputeConAttr-19,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: "declare function local:myFunc($recurse as xs:integer) { <nested> { if ($recurse = 0) then () else local:myFunc($recurse - 1) } </nested> }; <b> {local:myFunc(3)} {attribute name {"content"}} </b>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.\ndeclare function local:myFunc($recurse as xs:integer) { <nested> { if ($recurse = 0) then () else local:myFunc($recurse - 1) } </nested> }; <b> {local:myFunc(3)} {attribute [Error is around here]name {"content"}} </b>'
K2-ComputeConAttr-20,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: "declare function local:myFunc($recurse as xs:integer) as item() { <nested> { if ($recurse = 0) then () else local:myFunc($recurse - 1) } </nested> }; <b> {local:myFunc(3)} {attribute name {"content"}} </b>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.\ndeclare function local:myFunc($recurse as xs:integer) as item() { <nested> { if ($recurse = 0) then () else local:myFunc($recurse - 1) } </nested> }; <b> {local:myFunc(3)} {attribute [Error is around here]name {"content"}} </b>'
K2-ComputeConAttr-21,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: "declare function local:myFunc() { <elem/>, attribute name {"content"} }; <b> {local:myFunc()} </b>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.\ndeclare function local:myFunc() { <elem/>, attribute [Error is around here]name {"content"} }; <b> {local:myFunc()} </b>'
K2-ComputeConAttr-22,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: "declare variable $myVar := (<elem/>, attribute name {"content"}); <b> {$myVar} </b>".\nExpected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.\ndeclare variable $myVar := (<elem/>, attribute [Error is around here]name {"content"}); <b> {$myVar} </b>'
K2-ComputeConAttr-23,Error: XPST0003: Unable to parse XPath: "declare variable $myVar := (<elem/>, attribute name {"content"}); <b> {$myVar[2]} </b>". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. declare variable $myVar := (<elem/>, attribute [Error is around here]name {"content"}); <b> {$myVar[2]} </b>
K2-ComputeConAttr-24,Error: XPST0003: Unable to parse XPath: "declare variable $myVar := (attribute name {"content"}, <elem/>); <b> {$myVar[2]} </b>". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. declare variable $myVar := (attribute [Error is around here]name {"content"}, <elem/>); <b> {$myVar[2]} </b>
K2-ComputeConAttr-25,Error: XPST0003: Unable to parse XPath: "declare function local:myFunc($recurse as xs:integer) { attribute {concat("name", $recurse)} {"content"} , if ($recurse = 0) then () else local:myFunc($recurse - 1) }; <b> {local:myFunc(2)} {attribute name {"content"}} </b>". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare function local:myFunc($recurse as xs:integer) { attribute [Error is around here]{concat("name", $recurse)} {"content"} , if ($recurse = 0) then () else local:myFunc($recurse - 1) }; <b> {local:myFunc(2)} {attribute name {"content"}} </b>
K2-ComputeConAttr-26,Error: XPST0003: Unable to parse XPath: "declare function local:myFunc() { attribute name {"content"}, <elem/> }; <b> {local:myFunc()} </b>". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found. declare function local:myFunc() { attribute [Error is around here]name {"content"}, <elem/> }; <b> {local:myFunc()} </b>
K2-ComputeConAttr-27,Error: XPST0003: Unable to parse XPath: "declare function local:myFunc() { <elem/>, attribute name {"content"} }; <b> {local:myFunc()[2]} </b>". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found. declare function local:myFunc() { <elem/>, attribute [Error is around here]name {"content"} }; <b> {local:myFunc()[2]} </b>
K2-ComputeConAttr-28,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: "declare variable $local:myVar := <a/>; <b> {$local:myVar} {attribute name {"content"}} </b>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.\ndeclare variable $local:myVar := <a/>; <b> {$local:myVar} {attribute [Error is around here]name {"content"}} </b>'
K2-ComputeConAttr-29,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: "declare variable $local:myVar as item() := <a/>; <b> {$local:myVar} {attribute name {"content"}} </b>".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\ndeclare variable $local:myVar [Error is around here]as item() := <a/>; <b> {$local:myVar} {attribute name {"content"}} </b>'
K2-ComputeConAttr-30,Error: XPST0003: Unable to parse XPath: "declare variable $local:myVar := attribute n2 {"content"}; <b> {$local:myVar} {attribute name {"content"}} </b>". Expected "!", "!=", "(", "*", "+", "-", "/", "//", ";", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. declare variable $local:myVar := attribute [Error is around here]n2 {"content"}; <b> {$local:myVar} {attribute name {"content"}} </b>
K2-ComputeConAttr-31,Error: XPST0003: Unable to parse XPath: "declare function local:myFunc() { attribute n2 {"content"} }; <b> {local:myFunc()} {attribute name {"content"}} </b>". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found. declare function local:myFunc() { attribute [Error is around here]n2 {"content"} }; <b> {local:myFunc()} {attribute name {"content"}} </b>
K2-ComputeConAttr-32,Error: XPST0003: Unable to parse XPath: "<e> { attribute name {<anElement/>}, attribute name2 {"content"} } </e>". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found. <e> { attribute [Error is around here]name {<anElement/>}, attribute name2 {"content"} } </e>
K2-ComputeConAttr-33,Error: XPST0003: Unable to parse XPath: "<e> { attribute name {"content"}, attribute name2 {"content"} } </e>". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found. <e> { attribute [Error is around here]name {"content"}, attribute name2 {"content"} } </e>
K2-ComputeConAttr-34,Error: XPST0003: Unable to parse XPath: "<e> { attribute name {xs:hexBinary("ff")}, attribute name2 {"content"} } </e>". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found. <e> { attribute [Error is around here]name {xs:hexBinary("ff")}, attribute name2 {"content"} } </e>
K2-ComputeConAttr-35,Error: XPST0003: Unable to parse XPath: "<elem><![CDATA[]]>{attribute name {"content"}}<alem/> </elem>". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found. <elem><![CDATA[]]>{attribute [Error is around here]name {"content"}}<alem/> </elem>
K2-ComputeConAttr-37,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPST0003: Unable to parse XPath: "attribute xmlns:localName {"content"}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "x" found.\nattribute [Error is around here]xmlns:localName {"content"}'
K2-ComputeConAttr-38,AssertionError: Expected executing the XPath "attribute {"xmlns:localName"} {"content"}" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQDY0044' but got 'XPST0003: Unable to parse XPath: "attribute {"xmlns:localName"} {"content"}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nattribute [Error is around here]{"xmlns:localName"} {"content"}', AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: "attribute {"xmlns:localName"} {"content"}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nattribute [Error is around here]{"xmlns:localName"} {"content"}'.
K2-ComputeConAttr-39,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPST0003: Unable to parse XPath: "attribute aPrefix:localName {"content"}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "a" found.\nattribute [Error is around here]aPrefix:localName {"content"}'
K2-ComputeConAttr-40,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: "attribute {"aPrefix:localName"} {"content"}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nattribute [Error is around here]{"aPrefix:localName"} {"content"}'
K2-ComputeConAttr-41,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: "attribute {xs:untypedAtomic("aPrefix::localName")} {"content"}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nattribute [Error is around here]{xs:untypedAtomic("aPrefix::localName")} {"content"}'
K2-ComputeConAttr-42,AssertionError: expected [Function] to throw error including 'XQST0070' but got 'XPST0003: Unable to parse XPath: "\n        declare namespace prefix = "http://www.w3.org/2000/xmlns/"; \n        <e>{attribute prefix:localName {"content"}}</e>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "p" found.\n\n        declare namespace prefix = "http://www.w3.org/2000/xmlns/"; \n        <e>{attribute [Error is around here]prefix:localName {"content"}}</e>'
K2-ComputeConAttr-43,AssertionError: expected [Function] to throw error including 'XQST0070' but got 'XPST0003: Unable to parse XPath: "declare namespace prefix = "http://www.w3.org/2000/xmlns/"; <e>{attribute {"prefix:localName"} {"content"}}</e>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.\ndeclare namespace prefix = "http://www.w3.org/2000/xmlns/"; <e>{attribute [Error is around here]{"prefix:localName"} {"content"}}</e>'
K2-ComputeConAttr-44,AssertionError: expected [Function] to throw error including 'XQDY0044' but got 'XPST0003: Unable to parse XPath: "attribute {"xmlns"} {"content"}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nattribute [Error is around here]{"xmlns"} {"content"}'
K2-ComputeConAttr-45,AssertionError: expected [Function] to throw error including 'XQDY0044' but got 'XPST0003: Unable to parse XPath: "attribute xmlns {"content"}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "x" found.\nattribute [Error is around here]xmlns {"content"}'
K2-ComputeConAttr-46,AssertionError: expected [Function] to throw error including 'XQDY0044' but got 'XPST0003: Unable to parse XPath: "declare default element namespace "http://www.example.com/"; <e>{attribute xmlns {"content"}}</e>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "x" found.\ndeclare default element namespace "http://www.example.com/"; <e>{attribute [Error is around here]xmlns {"content"}}</e>'
K2-ComputeConAttr-47,Error: XPST0003: Unable to parse XPath: "data(attribute foo {"content"}) instance of xs:untypedAtomic". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found. data(attribute [Error is around here]foo {"content"}) instance of xs:untypedAtomic
K2-ComputeConAttr-48,AssertionError: Expected executing the XPath "string(attribute xml:id {" ab c d "})" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "string(attribute xml:id {" ab c d "})". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "x" found. string(attribute [Error is around here]xml:id {" ab c d "}), AssertionError: expected [Function] to throw error including 'XQDY0091' but got 'XPST0003: Unable to parse XPath: "string(attribute xml:id {" ab c d "})".\nExpected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "x" found.\nstring(attribute [Error is around here]xml:id {" ab c d "})'.
K2-ComputeConAttr-49,AssertionError: expected [Function] to throw error including 'XQDY0025' but got 'XPST0003: Unable to parse XPath: "declare namespace a = "http://example.com/A"; declare namespace b = "http://example.com/A"; <e> { attribute a:localName {()}, attribute b:localName {()} } </e>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "a" found.\ndeclare namespace a = "http://example.com/A"; declare namespace b = "http://example.com/A"; <e> { attribute [Error is around here]a:localName {()}, attribute b:localName {()} } </e>'
K2-ComputeConAttr-50,AssertionError: expected [Function] to throw error including 'XQDY0025' but got 'XPST0003: Unable to parse XPath: "<e> { attribute {QName("http://example.com/", "attr")} {()}, attribute {QName("http://example.com/", "attr")} {()} } </e>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.\n<e> { attribute [Error is around here]{QName("http://example.com/", "attr")} {()}, attribute {QName("http://example.com/", "attr")} {()} } </e>'
K2-ComputeConAttr-51,Error: XPST0003: Unable to parse XPath: "(<e> { attribute {QName("http://example.com/", "attr")} {()} } </e>) instance of element(e)". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. (<e> { attribute [Error is around here]{QName("http://example.com/", "attr")} {()} } </e>) instance of element(e)
K2-ComputeConAttr-52,AssertionError: expected [Function] to throw error including 'XQDY0025' but got 'XPST0003: Unable to parse XPath: "<e xmlns:p="http://example.com/" p:attr=""> { attribute {QName("http://example.com/", "p:attr")} {()} } </e>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.\n<e xmlns:p="http://example.com/" p:attr=""> { attribute [Error is around here]{QName("http://example.com/", "p:attr")} {()} } </e>'
K2-ComputeConAttr-53,Error: XPST0003: Unable to parse XPath: "(<e> { attribute {QName("http://example.com/", "attr")} {()} } </e>) instance of element(e)". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. (<e> { attribute [Error is around here]{QName("http://example.com/", "attr")} {()} } </e>) instance of element(e)
K2-ComputeConAttr-54,Error: XPST0003: Unable to parse XPath: "string-length(xs:NCName(prefix-from-QName(node-name(attribute {QName("http://example.com/", "attr")} {()})))) > 0". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. string-length(xs:NCName(prefix-from-QName(node-name(attribute [Error is around here]{QName("http://example.com/", "attr")} {()})))) > 0
K2-ComputeConAttr-55,Error: XPST0003: Unable to parse XPath: "prefix-from-QName(node-name(attribute {QName("http://www.w3.org/XML/1998/namespace", "attr")} {()}))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. prefix-from-QName(node-name(attribute [Error is around here]{QName("http://www.w3.org/XML/1998/namespace", "attr")} {()}))
K2-ComputeConAttr-56,Error: XPST0003: Unable to parse XPath: "<e> { attribute {QName("http://www.w3.org/XML/1998/namespace", "space")} {"default"} } </e>". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. <e> { attribute [Error is around here]{QName("http://www.w3.org/XML/1998/namespace", "space")} {"default"} } </e>
K2-ComputeConAttr-57,AssertionError: expected [Function] to throw error including 'XQDY0044' but got 'XPST0003: Unable to parse XPath: "<e> { attribute {QName("http://www.w3.org/2000/xmlns/", "space")} {"default"} } </e>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.\n<e> { attribute [Error is around here]{QName("http://www.w3.org/2000/xmlns/", "space")} {"default"} } </e>'
K2-ComputeConAttr-58,Error: XPST0003: Unable to parse XPath: "<e xmlns:p="http://example.com/" p:attr1="value"> { attribute {QName("http://example.com/", "attr2")} {()} } </e>". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. <e xmlns:p="http://example.com/" p:attr1="value"> { attribute [Error is around here]{QName("http://example.com/", "attr2")} {()} } </e>
K2-ComputeConAttr-59,AssertionError: Expected executing the XPath "<a> { attribute xml:id {"1"} } </a>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "<a> { attribute xml:id {"1"} } </a>". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "x" found. <a> { attribute [Error is around here]xml:id {"1"} } </a>, AssertionError: expected [Function] to throw error including 'XQDY0091' but got 'XPST0003: Unable to parse XPath: "<a> { attribute xml:id {"1"} } </a>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "x" found.\n<a> { attribute [Error is around here]xml:id {"1"} } </a>'.
K2-ComputeConAttr-60,AssertionError: Expected executing the XPath "<a> { attribute xml:space {"DEFAULT"} } </a>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "<a> { attribute xml:space {"DEFAULT"} } </a>". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "x" found. <a> { attribute [Error is around here]xml:space {"DEFAULT"} } </a>, AssertionError: expected [Function] to throw error including 'XQDY0092' but got 'XPST0003: Unable to parse XPath: "<a> { attribute xml:space {"DEFAULT"} } </a>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "x" found.\n<a> { attribute [Error is around here]xml:space {"DEFAULT"} } </a>'.
K2-ComputeConAttr-61,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: "let $x := ( attribute a { "a" }, element b { "b" }, attribute c { "c" } ) return <foo> { $x } </foo>".\nExpected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "a" found.\nlet $x := ( attribute [Error is around here]a { "a" }, element b { "b" }, attribute c { "c" } ) return <foo> { $x } </foo>'
cbcl-constr-compattr-001,AssertionError: expected [Function] to throw error including 'XQDY0044' but got 'XPST0003: Unable to parse XPath: "for $a in attribute { fn:QName("http://www.w3.org/2000/xmlns/", "namespace:foo") } { "bar" } return name($a)".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found.\nfor $a in attribute [Error is around here]{ fn:QName("http://www.w3.org/2000/xmlns/", "namespace:foo") } { "bar" } return name($a)'
cbcl-constr-compattr-002,AssertionError: expected [Function] to throw error including 'XQDY0044' but got 'XPST0003: Unable to parse XPath: "for $a in attribute { fn:QName("http://www.example.com/", "xmlns:foo") } { "bar" } return name($a)".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found.\nfor $a in attribute [Error is around here]{ fn:QName("http://www.example.com/", "xmlns:foo") } { "bar" } return name($a)'
cbcl-constr-compattr-003,AssertionError: expected [Function] to throw error including 'XQDY0044' but got 'XPST0003: Unable to parse XPath: "for $a in attribute { "xmlns" } { "bar" } return name($a)".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found.\nfor $a in attribute [Error is around here]{ "xmlns" } { "bar" } return name($a)'
cbcl-constr-compattr-005,AssertionError: expected [Function] to throw error including 'XQDY0044' but got 'XPST0003: Unable to parse XPath: "\n      \tfor $a in attribute { fn:QName("http://www.example.com/", "xml:foo") } { "bar" } \n      \treturn name($a)\n      ".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found.\n\n      \tfor $a in attribute [Error is around here]{ fn:QName("http://www.example.com/", "xml:foo") } { "bar" } \n      \treturn name($a)\n      '
cbcl-constr-compattr-006,AssertionError: expected [Function] to throw error including 'XQDY0044' but got 'XPST0003: Unable to parse XPath: "\n      \tfor $a in attribute { fn:QName("http://www.w3.org/XML/1998/namespace", "sgml:foo") } { "bar" } \n      \treturn name($a)\n      ".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found.\n\n      \tfor $a in attribute [Error is around here]{ fn:QName("http://www.w3.org/XML/1998/namespace", "sgml:foo") } { "bar" } \n      \treturn name($a)\n      '
cbcl-constr-compattr-007,Error: XPST0003: Unable to parse XPath: "       	<element xmlns:sgml="http://www.example.com/other"> {        		for $a in attribute { fn:QName("http://www.example.com/", "sgml:foo") } { }        		return concat(name($a), "=", namespace-uri($a)) }        	</element>       ". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found.        	<element xmlns:sgml="http://www.example.com/other"> {        		for $a in attribute [Error is around here]{ fn:QName("http://www.example.com/", "sgml:foo") } { }        		return concat(name($a), "=", namespace-uri($a)) }        	</element>
cbcl-constr-compattr-008,Error: XPST0003: Unable to parse XPath: "       	declare function local:factorial($arg as xs:integer) as xs:integer {        		if ($arg le 1) then 1 else $arg * local:factorial($arg - 1)        	};        	<element> { attribute { fn:QName("http://www.example.com/", "sgml:foo") } { local:factorial(5) } } </element>       ". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.        	declare function local:factorial($arg as xs:integer) as xs:integer {        		if ($arg le 1) then 1 else $arg * local:factorial($arg - 1)        	};        	<element> { attribute [Error is around here]{ fn:QName("http://www.example.com/", "sgml:foo") } { local:factorial(5) } } </element>
cbcl-constr-compattr-009,Error: XPST0003: Unable to parse XPath: "       	declare function local:even-range($arg as xs:integer) as xs:integer* { (1 to $arg)[. mod 2 = 9] };        	<element> { attribute { 'attr' } { local:even-range(0) } } </element>       ". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.        	declare function local:even-range($arg as xs:integer) as xs:integer* { (1 to $arg)[. mod 2 = 9] };        	<element> { attribute [Error is around here]{ 'attr' } { local:even-range(0) } } </element>
Constr-docnode-adjtext-1,Error: XPST0003: Unable to parse XPath: "count((document {1, 'string', 1,2e3})/text()) = 1". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. count((document [Error is around here]{1, 'string', 1,2e3})/text()) = 1
Constr-docnode-adjtext-2,Error: XPST0003: Unable to parse XPath: "count((document {1, //text(), 'string'})/text()) = 1". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. count((document [Error is around here]{1, //text(), 'string'})/text()) = 1
Constr-docnode-adjtext-3,Error: XPST0003: Unable to parse XPath: "count((document {1, 2, <a/>, 3, 4, <b/>, 5, 6})/text()) = 3". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. count((document [Error is around here]{1, 2, <a/>, 3, 4, <b/>, 5, 6})/text()) = 3
Constr-docnode-nested-1,Error: XPST0003: Unable to parse XPath: "document {1, document {2, document {document {()}, document {3}}, 4}}". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. document [Error is around here]{1, document {2, document {document {()}, document {3}}, 4}}
Constr-docnode-nested-2,Error: XPST0003: Unable to parse XPath: "document {/root}". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. document [Error is around here]{/root}
Constr-docnode-nested-3,Error: XPST0003: Unable to parse XPath: "count(document {1, document{2}, document { document {()}, document {3}}, 4}/text()) = 1". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. count(document [Error is around here]{1, document{2}, document { document {()}, document {3}}, 4}/text()) = 1
Constr-docnode-nested-4,Error: XPST0003: Unable to parse XPath: "count(document {"", document{""}, document { document {()}, document {""}}, ""}/text()) = 0". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. count(document [Error is around here]{"", document{""}, document { document {()}, document {""}}, ""}/text()) = 0
Constr-docnode-enclexpr-1,Error: XPST0003: Unable to parse XPath: "document {()}". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. document [Error is around here]{()}
Constr-docnode-enclexpr-2,Error: XPST0003: Unable to parse XPath: "document {1,'a',3.5,4e2}". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. document [Error is around here]{1,'a',3.5,4e2}
Constr-docnode-enclexpr-3,Error: XPST0003: Unable to parse XPath: "document {1,//a,2,3,//comment(),4,5,//processing-instruction(),6,7,//text(),8}". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. document [Error is around here]{1,//a,2,3,//comment(),4,5,//processing-instruction(),6,7,//text(),8}
Constr-docnode-enclexpr-4,Error: XPST0003: Unable to parse XPath: "document {1, '', 2}". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. document [Error is around here]{1, '', 2}
Constr-docnode-nodeid-1,Error: XPST0003: Unable to parse XPath: "for $x in <a/>, $y in document {$x} return exactly-one($y/a) is $x". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found. for $x in <a/>, $y in document [Error is around here]{$x} return exactly-one($y/a) is $x
Constr-docnode-nodeid-3,Error: XPST0003: Unable to parse XPath: "for $x in <!--comment-->, $y in document {$x} return exactly-one($y/comment()) is $x". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found. for $x in <!--comment-->, $y in document [Error is around here]{$x} return exactly-one($y/comment()) is $x
Constr-docnode-nodeid-4,Error: XPST0003: Unable to parse XPath: "for $x in <?pi content?>, $y in document {$x} return exactly-one($y/processing-instruction()) is $x". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found. for $x in <?pi content?>, $y in document [Error is around here]{$x} return exactly-one($y/processing-instruction()) is $x
Constr-docnode-nodeid-5,Error: XPST0003: Unable to parse XPath: "for $x in <a>text</a>, $y in document {$x/text()} return exactly-one($y/text()) is exactly-one($x/text())". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found. for $x in <a>text</a>, $y in document [Error is around here]{$x/text()} return exactly-one($y/text()) is exactly-one($x/text())
Constr-docnode-constrmod-1,Error: XPST0003: Unable to parse XPath: "declare construction strip; fn:count(fn:data((document {//*:idrefs})/*)) = 1". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. declare construction strip; fn:count(fn:data((document [Error is around here]{//*:idrefs})/*)) = 1
Constr-docnode-constrmod-2,AssertionError: Expected executing the XPath "declare construction preserve; fn:count(fn:data((document {//*:idrefs})/*))" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "declare construction preserve; fn:count(fn:data((document {//*:idrefs})/*)) = 2". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. declare construction preserve; fn:count(fn:data((document [Error is around here]{//*:idrefs})/*)) = 2, Error: XPST0003: Unable to parse XPath: "declare construction preserve; fn:count(fn:data((document {//*:idrefs})/*)) = 1". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. declare construction preserve; fn:count(fn:data((document [Error is around here]{//*:idrefs})/*)) = 1.
Constr-docnode-constrmod-3,AssertionError: expected [Function] to throw error including 'FORG0001' but got 'XPST0003: Unable to parse XPath: "declare construction strip; (document {//*:decimal})/* cast as xs:integer".\nExpected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.\ndeclare construction strip; (document [Error is around here]{//*:decimal})/* cast as xs:integer'
Constr-docnode-constrmod-4,AssertionError: Expected executing the XPath "declare construction preserve; (document {//*:decimal})/* cast as xs:integer" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "declare construction preserve; (document {//*:decimal})/* cast as xs:integer = 12678967". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. declare construction preserve; (document [Error is around here]{//*:decimal})/* cast as xs:integer = 12678967, AssertionError: expected [Function] to throw error including 'FORG0001' but got 'XPST0003: Unable to parse XPath: "declare construction preserve; (document {//*:decimal})/* cast as xs:integer".\nExpected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.\ndeclare construction preserve; (document [Error is around here]{//*:decimal})/* cast as xs:integer'.
Constr-docnode-doc-1,AssertionError: Expected executing the XPath "document {., .}" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "document {., .}". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. document [Error is around here]{., .}, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "document {., .}".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\ndocument [Error is around here]{., .}'.
Constr-docnode-parent-1,AssertionError: Expected executing the XPath "count((document {()})/..)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "count((document {()})/..) = 0". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. count((document [Error is around here]{()})/..) = 0, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "count((document {()})/..)".\nExpected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.\ncount((document [Error is around here]{()})/..)'.
Constr-docnode-string-1,Error: XPST0003: Unable to parse XPath: "fn:string(document {'a', element a {}, 'b'})". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. fn:string(document [Error is around here]{'a', element a {}, 'b'})
Constr-docnode-data-1,Error: XPST0003: Unable to parse XPath: "fn:data(document {'a', element a {}, 'b'})". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. fn:data(document [Error is around here]{'a', element a {}, 'b'})
Constr-docnode-attr-1,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "document {//@mark}".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\ndocument [Error is around here]{//@mark}'
Constr-docnode-attr-2,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "document {<a/>, //@mark}".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\ndocument [Error is around here]{<a/>, //@mark}'
Constr-docnode-attr-3,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "document {<a/>, //@mark, <b/>}".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\ndocument [Error is around here]{<a/>, //@mark, <b/>}'
K2-ConDocNode-3,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "document{"some text", <e/>, attribute name {"content"}}".\nExpected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "{" found.\ndocument[Error is around here]{"some text", <e/>, attribute name {"content"}}'
K2-ConDocNode-4,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "document{<e/>, attribute name {"content"}, "some text"}".\nExpected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "{" found.\ndocument[Error is around here]{<e/>, attribute name {"content"}, "some text"}'
K2-ConDocNode-5,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "document{attribute name {"content"}, <e/>, "some text"}".\nExpected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "{" found.\ndocument[Error is around here]{attribute name {"content"}, <e/>, "some text"}'
K2-ConDocNode-6,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "string(document{"some text", <e/>, attribute name {"content"}})".\nExpected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found.\nstring(document[Error is around here]{"some text", <e/>, attribute name {"content"}})'
K2-ConDocNode-7,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "string(document{<e/>, attribute name {"content"}, "some text"})".\nExpected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found.\nstring(document[Error is around here]{<e/>, attribute name {"content"}, "some text"})'
K2-ConDocNode-8,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "string(document{attribute name {"content"}, <e/>, "some text"})".\nExpected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found.\nstring(document[Error is around here]{attribute name {"content"}, <e/>, "some text"})'
K2-ConDocNode-9,Error: XPST0003: Unable to parse XPath: "document{<a/>, <b/>, <c/>}". Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "{" found. document[Error is around here]{<a/>, <b/>, <c/>}
K2-ConDocNode-10,Error: XPST0003: Unable to parse XPath: "document{<a/>, <b/>, <c/>}". Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "{" found. document[Error is around here]{<a/>, <b/>, <c/>}
K2-ConDocNode-11,Error: XPST0003: Unable to parse XPath: "<a>{data(document{<a/>, <b/>, <c/>})}</a>". Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. <a>{data(document[Error is around here]{<a/>, <b/>, <c/>})}</a>
K2-ConDocNode-12,Error: XPST0003: Unable to parse XPath: "<a>{string(document{<a/>, <b/>, <c/>})}</a>". Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. <a>{string(document[Error is around here]{<a/>, <b/>, <c/>})}</a>
K2-ConDocNode-13,Error: XPST0003: Unable to parse XPath: "<a>{string(document{<a/>, <b/>, <c/>})}</a>". Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. <a>{string(document[Error is around here]{<a/>, <b/>, <c/>})}</a>
K2-ConDocNode-14,Error: XPST0003: Unable to parse XPath: "string(document{"abc"})". Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. string(document[Error is around here]{"abc"})
K2-ConDocNode-15,Error: XPST0003: Unable to parse XPath: "data(document {"content"}) instance of xs:untypedAtomic". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. data(document [Error is around here]{"content"}) instance of xs:untypedAtomic
K2-ConDocNode-16,Error: XPST0003: Unable to parse XPath: "document {"content"} is document{"content"}". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. document [Error is around here]{"content"} is document{"content"}
K2-ConDocNode-17,Error: XPST0003: Unable to parse XPath: "string(document{"string", <e>more<a>even more</a><b attr="thisIsIgnored"/><![CDATA[ButNotThis]]><?target butThisIs?> content</e>})". Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. string(document[Error is around here]{"string", <e>more<a>even more</a><b attr="thisIsIgnored"/><![CDATA[ButNotThis]]><?target butThisIs?> content</e>})
K2-ConDocNode-18,Error: XPST0003: Unable to parse XPath: "string(document{ text {"data"}, processing-instruction name {"data"}, processing-instruction name {"data"}, text {"data"}, processing-instruction name {"data"}, processing-instruction name1 {"data"}, comment {"content"}, comment {"content"}, text {"data"}, processing-instruction name2 {"data"}, comment {"content"}, text {"data"} })". Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. string(document[Error is around here]{ text {"data"}, processing-instruction name {"data"}, processing-instruction name {"data"}, text {"data"}, processing-instruction name {"data"}, processing-instruction name1 {"data"}, comment {"content"}, comment {"content"}, text {"data"}, processing-instruction name2 {"data"}, comment {"content"}, text {"data"} })
K2-ConDocNode-19,Error: XPST0003: Unable to parse XPath: "count(document{document{document{document{()}}}}/child::node()) = 0". Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. count(document[Error is around here]{document{document{document{()}}}}/child::node()) = 0
K2-ConDocNode-20,Error: XPST0003: Unable to parse XPath: "1, document{document{document{document{()}}}}/child::node(), 1". Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "{" found. 1, document[Error is around here]{document{document{document{()}}}}/child::node(), 1
K2-ConDocNode-21,Error: XPST0003: Unable to parse XPath: "document{document{document{document{<e/>}}}}/child::node()". Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "{" found. document[Error is around here]{document{document{document{<e/>}}}}/child::node()
K2-ConDocNode-22,Error: XPST0003: Unable to parse XPath: "document{document{document{document{<e/>, document{()}, <e>{document{()}}</e>}}}}//child::node()". Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "{" found. document[Error is around here]{document{document{document{<e/>, document{()}, <e>{document{()}}</e>}}}}//child::node()
K2-ConDocNode-23,Error: XPST0003: Unable to parse XPath: "string(document{ text {"data"}, text {"data"}, text {"data"}, text {"data"} })". Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. string(document[Error is around here]{ text {"data"}, text {"data"}, text {"data"}, text {"data"} })
K2-ConDocNode-24,Error: XPST0003: Unable to parse XPath: "count(document{ text {"data"}, text {"data"}, <e/>, text {"data"}, text {"data"} }/child::node()) = 3". Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. count(document[Error is around here]{ text {"data"}, text {"data"}, <e/>, text {"data"}, text {"data"} }/child::node()) = 3
K2-ConDocNode-25,Error: XPST0003: Unable to parse XPath: "count(document{ text {"data"}, text {"data"}, text {"data"}, text {"data"} }/child::node()) = 1". Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. count(document[Error is around here]{ text {"data"}, text {"data"}, text {"data"}, text {"data"} }/child::node()) = 1
K2-ConDocNode-26,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "<doo> { document { attribute name {"content"} } } </doo>".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.\n<doo> { document [Error is around here]{ attribute name {"content"} } } </doo>'
K2-ConDocNode-27,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "<doo> { document { <e/>, attribute name {"content"} } } </doo>".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.\n<doo> { document [Error is around here]{ <e/>, attribute name {"content"} } } </doo>'
K2-ConDocNode-28,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "<doo> { document { <e> <b/> <b/> <b/> <c> <d/> </c> </e>, attribute name {"content"} } } </doo>".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.\n<doo> { document [Error is around here]{ <e> <b/> <b/> <b/> <c> <d/> </c> </e>, attribute name {"content"} } } </doo>'
K2-ConDocNode-29,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: "<doo> { document { <e> { <?target data?>, attribute name {"content"} } </e> } } </doo>".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.\n<doo> { document [Error is around here]{ <e> { <?target data?>, attribute name {"content"} } </e> } } </doo>'
K2-ConDocNode-30,Error: XPST0003: Unable to parse XPath: "count(<a>{document {text{'a'}}}b</a>/node()) = 1". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. count(<a>{document [Error is around here]{text{'a'}}}b</a>/node()) = 1
K2-ConDocNode-31,Error: XPST0003: Unable to parse XPath: "string(document {1, document {2, document {document {()}, 3, document {4}}, 5}, 6})". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. string(document [Error is around here]{1, document {2, document {document {()}, 3, document {4}}, 5}, 6})
K2-ConDocNode-32,Error: XPST0003: Unable to parse XPath: "document {1, document {2, document {document {()}, 3, document {4}}, 5}, 6}". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. document [Error is around here]{1, document {2, document {document {()}, 3, document {4}}, 5}, 6}
Constr-compcomment-enclexpr-1,Error: XPST0003: Unable to parse XPath: "comment {1,'string',3.14,xs:float('1.2345e-2'),xs:dateTime('2002-04-02T12:00:00-01:00')}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. comment [Error is around here]{1,'string',3.14,xs:float('1.2345e-2'),xs:dateTime('2002-04-02T12:00:00-01:00')}
Constr-compcomment-enclexpr-2,Error: XPST0003: Unable to parse XPath: "comment {<elem>123</elem>, (<elem attr='456'/>)/@attr, (<elem>789</elem>)/text()}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. comment [Error is around here]{<elem>123</elem>, (<elem attr='456'/>)/@attr, (<elem>789</elem>)/text()}
Constr-compcomment-enclexpr-3,Error: XPST0003: Unable to parse XPath: "comment {1,'',2}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. comment [Error is around here]{1,'',2}
Constr-compcomment-enclexpr-4,Error: XPST0003: Unable to parse XPath: "comment {1,<a/>,2}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. comment [Error is around here]{1,<a/>,2}
Constr-compcomment-enclexpr-5,Error: XPST0003: Unable to parse XPath: "comment {/root}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. comment [Error is around here]{/root}
Constr-compcomment-doc-1,Error: XPST0003: Unable to parse XPath: "comment {., .}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. comment [Error is around here]{., .}
Constr-compcomment-parent-1,Error: XPST0003: Unable to parse XPath: "count((comment {'comment'})/..) = 0". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. count((comment [Error is around here]{'comment'})/..) = 0
Constr-compcomment-string-1,Error: XPST0003: Unable to parse XPath: "fn:string(comment {'a', element a {}, 'b'})". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. fn:string(comment [Error is around here]{'a', element a {}, 'b'})
Constr-compcomment-data-1,Error: XPST0003: Unable to parse XPath: "fn:data(comment {'a', element a {}, 'b'})". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. fn:data(comment [Error is around here]{'a', element a {}, 'b'})
Constr-compcomment-nested-1,Error: XPST0003: Unable to parse XPath: "comment {comment {'one', comment {'two'}}, 'three', comment {'four'}}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. comment [Error is around here]{comment {'one', comment {'two'}}, 'three', comment {'four'}}
Constr-compcomment-nested-2,Error: XPST0003: Unable to parse XPath: "<elem>{comment {'one'}}<a>{comment {'two'}}</a>{comment {'three'}}</elem>". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. <elem>{comment [Error is around here]{'one'}}<a>{comment {'two'}}</a>{comment {'three'}}</elem>
Constr-compcomment-nested-3,Error: XPST0003: Unable to parse XPath: "document {comment {'one'}, <a/>, comment {'two'}, <b/>, comment {'three'}}". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. document [Error is around here]{comment {'one'}, <a/>, comment {'two'}, <b/>, comment {'three'}}
Constr-compcomment-dash-1,AssertionError: expected [Function] to throw error including 'XQDY0072' but got 'XPST0003: Unable to parse XPath: "comment {\'-\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\ncomment [Error is around here]{\'-\'}'
Constr-compcomment-dash-2,AssertionError: expected [Function] to throw error including 'XQDY0072' but got 'XPST0003: Unable to parse XPath: "comment {\'comment-\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\ncomment [Error is around here]{\'comment-\'}'
Constr-compcomment-dash-3,AssertionError: expected [Function] to throw error including 'XQDY0072' but got 'XPST0003: Unable to parse XPath: "comment {\'comment&#x2D;\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\ncomment [Error is around here]{\'comment&#x2D;\'}'
Constr-compcomment-dash-4,AssertionError: expected [Function] to throw error including 'XQDY0072' but got 'XPST0003: Unable to parse XPath: "comment {//*:test-case[@name="Constr-compcomment-dash-4"]/*:description}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\ncomment [Error is around here]{//*:test-case[@name="Constr-compcomment-dash-4"]/*:description}'
Constr-compcomment-doubledash-1,AssertionError: expected [Function] to throw error including 'XQDY0072' but got 'XPST0003: Unable to parse XPath: "comment {\'--\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\ncomment [Error is around here]{\'--\'}'
Constr-compcomment-doubledash-2,AssertionError: expected [Function] to throw error including 'XQDY0072' but got 'XPST0003: Unable to parse XPath: "comment {\'com--ment\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\ncomment [Error is around here]{\'com--ment\'}'
Constr-compcomment-doubledash-3,AssertionError: expected [Function] to throw error including 'XQDY0072' but got 'XPST0003: Unable to parse XPath: "comment {\'com&#x2D;&#x2D;ment\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\ncomment [Error is around here]{\'com&#x2D;&#x2D;ment\'}'
Constr-compcomment-doubledash-4,AssertionError: expected [Function] to throw error including 'XQDY0072' but got 'XPST0003: Unable to parse XPath: "comment {//*:test-case[@name="Constr-compcomment-doubledash-4"]/*:description}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\ncomment [Error is around here]{//*:test-case[@name="Constr-compcomment-doubledash-4"]/*:description}'
Constr-compcomment-doubledash-5,Error: XPST0003: Unable to parse XPath: "comment {'com','-','-','ment'}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. comment [Error is around here]{'com','-','-','ment'}
K2-ComputeConComment-3,Error: XPST0003: Unable to parse XPath: "comment {()}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. comment [Error is around here]{()}
K2-ComputeConComment-4a,Error: XPST0003: Unable to parse XPath: "let $result := (comment{}) return count($result) = 1". Expected "!", "!=", "#", "(", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. let $result := (comment[Error is around here]{}) return count($result) = 1
K2-ComputeConComment-5,Error: XPST0003: Unable to parse XPath: "data(comment {"content"}) instance of xs:string". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. data(comment [Error is around here]{"content"}) instance of xs:string
cbcl-constr-compcomment-001,AssertionError: expected [Function] to throw error including 'XQDY0072' but got 'XPST0003: Unable to parse XPath: "<element> { comment { \'-\', \'-\' } } </element>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.\n<element> { comment [Error is around here]{ \'-\', \'-\' } } </element>'
cbcl-constr-compcomment-002,AssertionError: expected [Function] to throw error including 'XQDY0072' but got 'XPST0003: Unable to parse XPath: "\n      \tdeclare function local:tag($arg) as element() { element { \'tag\' } { $arg } }; \n      \t<element> { comment { \'comment\', local:tag(\'--\') } } </element>\n      ".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.\n\n      \tdeclare function local:tag($arg) as element() { element [Error is around here]{ \'tag\' } { $arg } }; \n      \t<element> { comment { \'comment\', local:tag(\'--\') } } </element>\n      '
Constr-compelem-name-1,Error: XPST0003: Unable to parse XPath: "element elem {'text'}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. element [Error is around here]elem {'text'}
Constr-compelem-name-2,Error: XPST0003: Unable to parse XPath: "declare namespace foo="http://www.example.com/foo"; element foo:elem {'text'}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found. declare namespace foo="http://www.example.com/foo"; element [Error is around here]foo:elem {'text'}
Constr-compelem-name-3,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPST0003: Unable to parse XPath: "element foo:elem {\'text\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.\nelement [Error is around here]foo:elem {\'text\'}'
Constr-compelem-compname-1,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "element {()} {\'text\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nelement [Error is around here]{()} {\'text\'}'
Constr-compelem-compname-2,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "element {\'one\', \'two\'} {\'text\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nelement [Error is around here]{\'one\', \'two\'} {\'text\'}'
Constr-compelem-compname-3,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "element {xs:untypedAtomic(\'one\'), xs:untypedAtomic(\'two\')} {\'text\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nelement [Error is around here]{xs:untypedAtomic(\'one\'), xs:untypedAtomic(\'two\')} {\'text\'}'
Constr-compelem-compname-4,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "element {//a} {\'text\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nelement [Error is around here]{//a} {\'text\'}'
Constr-compelem-compname-5,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "element {1,2} {\'text\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nelement [Error is around here]{1,2} {\'text\'}'
Constr-compelem-compname-6,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "element {123} {\'text\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nelement [Error is around here]{123} {\'text\'}'
Constr-compelem-compname-7,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "element {xs:dateTime("1999-05-31T13:20:00")} {\'text\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nelement [Error is around here]{xs:dateTime("1999-05-31T13:20:00")} {\'text\'}'
Constr-compelem-compname-8,Error: XPST0003: Unable to parse XPath: "element {//*:NCName[1]} {'text'}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. element [Error is around here]{//*:NCName[1]} {'text'}
Constr-compelem-compname-9,Error: XPST0003: Unable to parse XPath: "element {xs:QName('aQname')} {'text'}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. element [Error is around here]{xs:QName('aQname')} {'text'}
Constr-compelem-compname-10,Error: XPST0003: Unable to parse XPath: "element {'elem'} {'text'}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. element [Error is around here]{'elem'} {'text'}
Constr-compelem-compname-11,Error: XPST0003: Unable to parse XPath: "element {'elem', ()} {'text'}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. element [Error is around here]{'elem', ()} {'text'}
Constr-compelem-compname-12,Error: XPST0003: Unable to parse XPath: "element {(), 'elem'} {'text'}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. element [Error is around here]{(), 'elem'} {'text'}
Constr-compelem-compname-13,Error: XPST0003: Unable to parse XPath: "<elem xmlns:foo="http://www.example.com/foo">{element {'foo:elem'} {'text'}}</elem>". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. <elem xmlns:foo="http://www.example.com/foo">{element [Error is around here]{'foo:elem'} {'text'}}</elem>
Constr-compelem-compname-14,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: "element {\'foo:elem\'} {}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nelement [Error is around here]{\'foo:elem\'} {}'
Constr-compelem-compname-15,Error: XPST0003: Unable to parse XPath: "element {xs:untypedAtomic('elem')} {'text'}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. element [Error is around here]{xs:untypedAtomic('elem')} {'text'}
Constr-compelem-compname-16,Error: XPST0003: Unable to parse XPath: "<elem xmlns:foo="http://www.example.com/foo">{element {xs:untypedAtomic('foo:elem')} {'text'}}</elem>". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. <elem xmlns:foo="http://www.example.com/foo">{element [Error is around here]{xs:untypedAtomic('foo:elem')} {'text'}}</elem>
Constr-compelem-compname-17,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: "element {xs:untypedAtomic(\'foo:elem\')} {\'text\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nelement [Error is around here]{xs:untypedAtomic(\'foo:elem\')} {\'text\'}'
Constr-compelem-compname-18,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: "element {\'el em\'} {\'text\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nelement [Error is around here]{\'el em\'} {\'text\'}'
Constr-compelem-compname-19,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: "element {xs:untypedAtomic(\'el em\')} {\'text\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nelement [Error is around here]{xs:untypedAtomic(\'el em\')} {\'text\'}'
Constr-compelem-adjtext-1,Error: XPST0003: Unable to parse XPath: "count((element elem {1, 'string', 1,2e3})/text()) = 1". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found. count((element [Error is around here]elem {1, 'string', 1,2e3})/text()) = 1
Constr-compelem-adjtext-2,Error: XPST0003: Unable to parse XPath: "count((element elem {1, //text(), 'string'})/text()) = 1". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found. count((element [Error is around here]elem {1, //text(), 'string'})/text()) = 1
Constr-compelem-adjtext-3,Error: XPST0003: Unable to parse XPath: "count((element elem {1, 2, <a/>, 3, 4, <b/>, 5, 6})/text()) = 3". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found. count((element [Error is around here]elem {1, 2, <a/>, 3, 4, <b/>, 5, 6})/text()) = 3
Constr-compelem-nested-1,Error: XPST0003: Unable to parse XPath: "element elem {1, element a {2, element b {element c {}, element d {3}}, 4}}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. element [Error is around here]elem {1, element a {2, element b {element c {}, element d {3}}, 4}}
Constr-compelem-nested-2,Error: XPST0003: Unable to parse XPath: "element elem {}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. element [Error is around here]elem {}
Constr-compelem-enclexpr-1,Error: XPST0003: Unable to parse XPath: "element elem {}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. element [Error is around here]elem {}
Constr-compelem-enclexpr-2,Error: XPST0003: Unable to parse XPath: "element elem {1,'a',3.5,4e2}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. element [Error is around here]elem {1,'a',3.5,4e2}
Constr-compelem-enclexpr-3,Error: XPST0003: Unable to parse XPath: "element elem {1,//a,2,3,//comment(),4,5,//processing-instruction(),6,7,//text(),8}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. element [Error is around here]elem {1,//a,2,3,//comment(),4,5,//processing-instruction(),6,7,//text(),8}
Constr-compelem-enclexpr-4,Error: XPST0003: Unable to parse XPath: "element elem {1, '', 2}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. element [Error is around here]elem {1, '', 2}
Constr-compelem-nodeid-1,Error: XPST0003: Unable to parse XPath: "for $x in <a/>, $y in element elem {$x} return exactly-one($y/a) is $x". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "e" found. for $x in <a/>, $y in element [Error is around here]elem {$x} return exactly-one($y/a) is $x
Constr-compelem-nodeid-2,Error: XPST0003: Unable to parse XPath: "for $x in <a b="b"/>, $y in element elem {$x/@b} return $y/@b is $x/@b". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "e" found. for $x in <a b="b"/>, $y in element [Error is around here]elem {$x/@b} return $y/@b is $x/@b
Constr-compelem-nodeid-3,Error: XPST0003: Unable to parse XPath: "for $x in <!--comment-->, $y in element elem {$x} return exactly-one($y/comment()) is $x". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "e" found. for $x in <!--comment-->, $y in element [Error is around here]elem {$x} return exactly-one($y/comment()) is $x
Constr-compelem-nodeid-4,Error: XPST0003: Unable to parse XPath: "for $x in <?pi content?>, $y in element elem {$x} return exactly-one($y/processing-instruction()) is $x". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "e" found. for $x in <?pi content?>, $y in element [Error is around here]elem {$x} return exactly-one($y/processing-instruction()) is $x
Constr-compelem-nodeid-5,Error: XPST0003: Unable to parse XPath: "for $x in <a>text</a>, $y in element elem {$x/text()} return exactly-one($y/text()) is exactly-one($x/text())". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "e" found. for $x in <a>text</a>, $y in element [Error is around here]elem {$x/text()} return exactly-one($y/text()) is exactly-one($x/text())
Constr-compelem-constrmod-3,AssertionError: expected [Function] to throw error including 'FORG0001' but got 'XPST0003: Unable to parse XPath: "declare construction strip; (element elem {xs:decimal((//decimal[1]))}) cast as xs:integer".\nExpected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found.\ndeclare construction strip; (element [Error is around here]elem {xs:decimal((//decimal[1]))}) cast as xs:integer'
Constr-compelem-constrmod-4,AssertionError: Expected executing the XPath "declare construction preserve; (element elem {xs:decimal((//decimal[1]))}) cast as xs:integer" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "declare construction preserve; (element elem {xs:decimal((//decimal[1]))}) cast as xs:integer = 12678967". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found. declare construction preserve; (element [Error is around here]elem {xs:decimal((//decimal[1]))}) cast as xs:integer = 12678967, AssertionError: expected [Function] to throw error including 'FORG0001' but got 'XPST0003: Unable to parse XPath: "declare construction preserve; (element elem {xs:decimal((//decimal[1]))}) cast as xs:integer".\nExpected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found.\ndeclare construction preserve; (element [Error is around here]elem {xs:decimal((//decimal[1]))}) cast as xs:integer'.
Constr-compelem-constrmod-7,AssertionError: expected [Function] to throw error including 'FORG0001' but got 'XPST0003: Unable to parse XPath: "declare construction strip; (element elem {//*:decimal/@*:attr})/@*:attr cast as xs:integer".\nExpected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found.\ndeclare construction strip; (element [Error is around here]elem {//*:decimal/@*:attr})/@*:attr cast as xs:integer'
Constr-compelem-constrmod-8,AssertionError: Expected executing the XPath "declare construction preserve; (element elem {xs:decimal(//*:decimal[1]/@*:attr)}) cast as xs:integer" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "declare construction preserve; (element elem {xs:decimal(//*:decimal[1]/@*:attr)}) cast as xs:integer = 12678967". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found. declare construction preserve; (element [Error is around here]elem {xs:decimal(//*:decimal[1]/@*:attr)}) cast as xs:integer = 12678967, AssertionError: expected [Function] to throw error including 'FORG0001' but got 'XPST0003: Unable to parse XPath: "declare construction preserve; (element elem {xs:decimal(//*:decimal[1]/@*:attr)}) cast as xs:integer".\nExpected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found.\ndeclare construction preserve; (element [Error is around here]elem {xs:decimal(//*:decimal[1]/@*:attr)}) cast as xs:integer', AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "declare construction preserve; (element elem {xs:decimal(//*:decimal[1]/@*:attr)}) cast as xs:integer".\nExpected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found.\ndeclare construction preserve; (element [Error is around here]elem {xs:decimal(//*:decimal[1]/@*:attr)}) cast as xs:integer'.
Constr-compelem-baseuri-1,Error: XPST0003: Unable to parse XPath: "fn:base-uri(element elem {attribute xml:base {"http://www.example.com"}})". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found. fn:base-uri(element [Error is around here]elem {attribute xml:base {"http://www.example.com"}})
Constr-compelem-baseuri-2,Error: XPST0003: Unable to parse XPath: "fn:base-uri(exactly-one((<elem xml:base="http://www.example.com">{element a {}}</elem>)/a))". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "a" found. fn:base-uri(exactly-one((<elem xml:base="http://www.example.com">{element [Error is around here]a {}}</elem>)/a))
Constr-compelem-baseuri-3,Error: XPST0003: Unable to parse XPath: "declare base-uri "http://www.example.com"; fn:base-uri(element elem {})". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found. declare base-uri "http://www.example.com"; fn:base-uri(element [Error is around here]elem {})
Constr-compelem-doc-1,Error: XPST0003: Unable to parse XPath: "element elem {., .}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. element [Error is around here]elem {., .}
Constr-compelem-parent-1,Error: XPST0003: Unable to parse XPath: "count((element elem {})/..) = 0". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found. count((element [Error is around here]elem {})/..) = 0
Constr-compelem-string-1,Error: XPST0003: Unable to parse XPath: "fn:string(element elem {'a', element a {}, 'b'})". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found. fn:string(element [Error is around here]elem {'a', element a {}, 'b'})
Constr-compelem-data-1,Error: XPST0003: Unable to parse XPath: "fn:data(element elem {'a', element a {}, 'b'})". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found. fn:data(element [Error is around here]elem {'a', element a {}, 'b'})
Constr-compelem-attr-1,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: "element elem {1, //west/@mark}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.\nelement [Error is around here]elem {1, //west/@mark}'
Constr-compelem-attr-2,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: "element elem {element a {}, //west/@mark}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.\nelement [Error is around here]elem {element a {}, //west/@mark}'
Constr-compelem-attr-3,Error: XPST0003: Unable to parse XPath: "element elem {//west/@mark, //west/@west-attr-1}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. element [Error is around here]elem {//west/@mark, //west/@west-attr-1}
Constr-compelem-attr-4,AssertionError: expected [Function] to throw error including 'XQDY0025' but got 'XPST0003: Unable to parse XPath: "element elem {//west/@mark, //center/@mark}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.\nelement [Error is around here]elem {//west/@mark, //center/@mark}'
K2-ComputeConElem-4,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: "element {"aPrefix:localName"} {"content"}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nelement [Error is around here]{"aPrefix:localName"} {"content"}'
K2-ComputeConElem-5,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: "element {xs:untypedAtomic("aPrefix::localName")} {"content"}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nelement [Error is around here]{xs:untypedAtomic("aPrefix::localName")} {"content"}'
K2-ComputeConElem-6,Error: XPST0003: Unable to parse XPath: "data(element foo {"dsa"}) instance of xs:untypedAtomic". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found. data(element [Error is around here]foo {"dsa"}) instance of xs:untypedAtomic
K2-ComputeConElem-7,Error: XPST0003: Unable to parse XPath: "data(element foo {"dsa"})". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found. data(element [Error is around here]foo {"dsa"})
K2-ComputeConElem-8,Error: XPST0003: Unable to parse XPath: "element e {"content"} instance of element(*, xs:anyType)". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. element [Error is around here]e {"content"} instance of element(*, xs:anyType)
K2-ComputeConElem-9,AssertionError: Expected executing the XPath "element e {"content"} instance of element(*, xs:untyped)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "element e {"content"} instance of element(*, xs:untyped)". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. element [Error is around here]e {"content"} instance of element(*, xs:untyped), Error: XPST0003: Unable to parse XPath: "element e {"content"} instance of element(*, xs:untyped)". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. element [Error is around here]e {"content"} instance of element(*, xs:untyped).
K2-ComputeConElem-10,Error: XPST0003: Unable to parse XPath: "declare construction strip; element e {"content"} instance of element(*, xs:untyped)". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. declare construction strip; element [Error is around here]e {"content"} instance of element(*, xs:untyped)
K2-ComputeConElem-11,Error: XPST0003: Unable to parse XPath: "element e {"content"} instance of element(a, xs:anyType)". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. element [Error is around here]e {"content"} instance of element(a, xs:anyType)
K2-ComputeConElem-12,Error: XPST0003: Unable to parse XPath: "declare construction strip; element e {"content"} instance of element(b, xs:untyped)". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. declare construction strip; element [Error is around here]e {"content"} instance of element(b, xs:untyped)
K2-ComputeConElem-13,Error: XPST0003: Unable to parse XPath: "element e {element b{()}}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. element [Error is around here]e {element b{()}}
K2-ComputeConElem-14,Error: XPST0003: Unable to parse XPath: "         declare function local:addNamespace($argElement as element(), $argPrefix as xs:string, $namespaceURI as xs:string) as element() {              element { QName($namespaceURI, concat($argPrefix, ":x")) }{$argElement}/*          };          local:addNamespace(<a><b/></a>, "prefix", "http://example.com/")       ". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.          declare function local:addNamespace($argElement as element(), $argPrefix as xs:string, $namespaceURI as xs:string) as element() {              element [Error is around here]{ QName($namespaceURI, concat($argPrefix, ":x")) }{$argElement}/*          };          local:addNamespace(<a><b/></a>, "prefix", "http://example.com/")
K2-ComputeConElem-15,Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://example.com/NS";          element {exactly-one((//*)[3])} {}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.          declare default element namespace "http://example.com/NS";          element [Error is around here]{exactly-one((//*)[3])} {}
comp-elem-bad-name-1,AssertionError: Expected executing the XPath "element {"xmlns:error"} {}" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQDY0096' but got 'XPST0003: Unable to parse XPath: "element {"xmlns:error"} {}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nelement [Error is around here]{"xmlns:error"} {}', AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: "element {"xmlns:error"} {}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nelement [Error is around here]{"xmlns:error"} {}'.
nscons-001,Error: XPST0003: Unable to parse XPath: "         declare variable $s := "http://saxon.sf.net/";          declare variable $xsl := "http://www.w3.org/1999/XSL/Transform";          <e>{ namespace saxon {$s}, attribute a {23}, namespace xsl {$xsl} }</e>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "s" found.          declare variable $s := "http://saxon.sf.net/";          declare variable $xsl := "http://www.w3.org/1999/XSL/Transform";          <e>{ namespace [Error is around here]saxon {$s}, attribute a {23}, namespace xsl {$xsl} }</e>
nscons-002,Error: XPST0003: Unable to parse XPath: "         declare variable $s := "saxon";          declare variable $xsl := "xsl";          <e>{ namespace {$s} {"http://saxon.sf.net/"},               attribute a {23},               namespace {$xsl} {"http://www.w3.org/1999/XSL/Transform"} }</e>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.          declare variable $s := "saxon";          declare variable $xsl := "xsl";          <e>{ namespace [Error is around here]{$s} {"http://saxon.sf.net/"},               attribute a {23},               namespace {$xsl} {"http://www.w3.org/1999/XSL/Transform"} }</e>
nscons-003,Error: XPST0003: Unable to parse XPath: "         declare variable $s := "saxon";          declare variable $xsl := "xsl";          <out> <t:e xmlns:t="http://www.example.com/">{              namespace {""} {"http://saxon.sf.net/"},              attribute a {23},              namespace {$xsl} {"http://www.w3.org/1999/XSL/Transform"}, <f/> }</t:e> </out>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.          declare variable $s := "saxon";          declare variable $xsl := "xsl";          <out> <t:e xmlns:t="http://www.example.com/">{              namespace [Error is around here]{""} {"http://saxon.sf.net/"},              attribute a {23},              namespace {$xsl} {"http://www.w3.org/1999/XSL/Transform"}, <f/> }</t:e> </out>
nscons-004,Error: XPST0003: Unable to parse XPath: "         declare variable $s := "saxon";          declare variable $xml := "http://www.w3.org/XML/1998/namespace";          <out> <t:e xmlns:t="http://www.example.com/" xml:space="preserve">{              namespace xml {"http://www.w3.org/XML/1998/namespace"},              attribute a {23}, <f/> }</t:e> </out>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "x" found.          declare variable $s := "saxon";          declare variable $xml := "http://www.w3.org/XML/1998/namespace";          <out> <t:e xmlns:t="http://www.example.com/" xml:space="preserve">{              namespace [Error is around here]xml {"http://www.w3.org/XML/1998/namespace"},              attribute a {23}, <f/> }</t:e> </out>
nscons-005,Error: XPST0003: Unable to parse XPath: "         declare variable $s := "http://saxon.sf.net/";          declare variable $xsl := "http://www.w3.org/1999/XSL/Transform";          element {QName("http://saxon.sf.net/", "saxon:extension")} { namespace saxon {$s}, attribute a {23}, namespace xsl {$xsl}, element f {42} }       ". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.          declare variable $s := "http://saxon.sf.net/";          declare variable $xsl := "http://www.w3.org/1999/XSL/Transform";          element [Error is around here]{QName("http://saxon.sf.net/", "saxon:extension")} { namespace saxon {$s}, attribute a {23}, namespace xsl {$xsl}, element f {42} }
nscons-006,Error: XPST0003: Unable to parse XPath: "         declare variable $s := "http://saxon.sf.net/";          declare variable $xsl := "http://www.w3.org/1999/XSL/Transform";          element {QName("http://saxon.sf.net/", "saxon:extension")}                  { namespace saxon {$s}, attribute a {23}, namespace xsl {$xsl}, namespace saxon {$s}, element f {42} }       ". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.          declare variable $s := "http://saxon.sf.net/";          declare variable $xsl := "http://www.w3.org/1999/XSL/Transform";          element [Error is around here]{QName("http://saxon.sf.net/", "saxon:extension")}                  { namespace saxon {$s}, attribute a {23}, namespace xsl {$xsl}, namespace saxon {$s}, element f {42} }
nscons-007,AssertionError: expected [Function] to throw error including 'XQDY0101' but got 'XPST0003: Unable to parse XPath: "\n        declare variable $s := "http://saxon.sf.net/"; \n        declare variable $xsl := "http://www.w3.org/1999/XSL/Transform"; \n        declare variable $xmlns := "xmlns"; \n        <e> { namespace saxon {$s}, attribute a {23}, namespace xsl {$xsl}, namespace xmlns {$s}, element f {42} }</e>\n      ".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "s" found.\n\n        declare variable $s := "http://saxon.sf.net/"; \n        declare variable $xsl := "http://www.w3.org/1999/XSL/Transform"; \n        declare variable $xmlns := "xmlns"; \n        <e> { namespace [Error is around here]saxon {$s}, attribute a {23}, namespace xsl {$xsl}, namespace xmlns {$s}, element f {42} }</e>\n      '
nscons-008,AssertionError: expected [Function] to throw error including 'XQDY0101' but got 'XPST0003: Unable to parse XPath: "\n        declare variable $s := "http://saxon.sf.net/"; \n        declare variable $xsl := "http://www.w3.org/1999/XSL/Transform"; \n        declare variable $xmlns := "xml"; \n        <e> { namespace saxon {$s}, attribute a {23}, namespace xsl {$xsl}, namespace {$xmlns} {$s}, element f {42} }</e>\n      ".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "s" found.\n\n        declare variable $s := "http://saxon.sf.net/"; \n        declare variable $xsl := "http://www.w3.org/1999/XSL/Transform"; \n        declare variable $xmlns := "xml"; \n        <e> { namespace [Error is around here]saxon {$s}, attribute a {23}, namespace xsl {$xsl}, namespace {$xmlns} {$s}, element f {42} }</e>\n      '
nscons-009,AssertionError: expected [Function] to throw error including 'XQDY0102' but got 'XPST0003: Unable to parse XPath: "\n        declare variable $p1 := "http://example.com/one"; \n        declare variable $p2 := "http://example.com/two"; \n        <e> { namespace p {$p1}, namespace p {$p2}, element f {42} }</e>\n      ".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "p" found.\n\n        declare variable $p1 := "http://example.com/one"; \n        declare variable $p2 := "http://example.com/two"; \n        <e> { namespace [Error is around here]p {$p1}, namespace p {$p2}, element f {42} }</e>\n      '
nscons-010,Error: XPST0003: Unable to parse XPath: "         declare variable $p1 := "http://example.com/one";          declare variable $p2 := "http://example.com/two";          declare variable $r := <e> { namespace p {$p1}, attribute {QName($p2, "p:att")} {93.7}, element f {42} }</e>;          <out> { exists($r/@*:att[prefix-from-QName(node-name(.))!='p']), exists(in-scope-prefixes($r)[.='p']) }</out>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "p" found.          declare variable $p1 := "http://example.com/one";          declare variable $p2 := "http://example.com/two";          declare variable $r := <e> { namespace [Error is around here]p {$p1}, attribute {QName($p2, "p:att")} {93.7}, element f {42} }</e>;          <out> { exists($r/@*:att[prefix-from-QName(node-name(.))!='p']), exists(in-scope-prefixes($r)[.='p']) }</out>
nscons-011,Error: XPST0003: Unable to parse XPath: "         declare variable $p1 := "http://example.com/one";          declare variable $p2 := "http://example.com/two";          declare variable $r := element {QName($p2, 'p:e')} { namespace p {$p1}, element f {42} };          <out> { exists($r[prefix-from-QName(node-name(.))!='p']), exists(in-scope-prefixes($r)[.='p']) }</out>       ". Expected "!", "!=", "(", "*", "+", "-", "/", "//", ";", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.          declare variable $p1 := "http://example.com/one";          declare variable $p2 := "http://example.com/two";          declare variable $r := element [Error is around here]{QName($p2, 'p:e')} { namespace p {$p1}, element f {42} };          <out> { exists($r[prefix-from-QName(node-name(.))!='p']), exists(in-scope-prefixes($r)[.='p']) }</out>
nscons-012,Error: XPST0003: Unable to parse XPath: "         declare variable $p1 := "http://example.com/one";          declare variable $p2 := "http://example.com/two";          declare function local:f($ns as namespace-node()) as element() {              <namespace name="{name($ns)}" local-name="{local-name($ns)}"                  namespace-uri="{namespace-uri($ns)}" string-value="{string($ns)}" typed-value="{data($ns)}"                  is-untyped="{data($ns) instance of xs:untypedAtomic}" parent-exists="{exists($ns/..)}"                  is-namespace="{$ns instance of namespace-node()}"                  is-node="{$ns instance of node()}" is-item="{$ns instance of item()}"                  same-as-self="{$ns is $ns}"/>          };          <out>{              local:f(namespace p {"http://example.com/one"}),              local:f(namespace {""} {"http://example.com/two"}) }</out>       ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "p" found.          declare variable $p1 := "http://example.com/one";          declare variable $p2 := "http://example.com/two";          declare function local:f($ns as namespace-node()) as element() {              <namespace name="{name($ns)}" local-name="{local-name($ns)}"                  namespace-uri="{namespace-uri($ns)}" string-value="{string($ns)}" typed-value="{data($ns)}"                  is-untyped="{data($ns) instance of xs:untypedAtomic}" parent-exists="{exists($ns/..)}"                  is-namespace="{$ns instance of namespace-node()}"                  is-node="{$ns instance of node()}" is-item="{$ns instance of item()}"                  same-as-self="{$ns is $ns}"/>          };          <out>{              local:f(namespace [Error is around here]p {"http://example.com/one"}),              local:f(namespace {""} {"http://example.com/two"}) }</out>
nscons-013,Error: XPST0003: Unable to parse XPath: "         let $pre := <prefix>z</prefix>,             $uri := "http://www.zorba-xquery.com/"         return           <e>{ namespace { $pre } { $uri } }</e>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.          let $pre := <prefix>z</prefix>,             $uri := "http://www.zorba-xquery.com/"         return           <e>{ namespace [Error is around here]{ $pre } { $uri } }</e>
nscons-014,Error: XPST0003: Unable to parse XPath: "         let $pre := "z",             $uri := "http://www.zorba-xquery.com/"         return           <e>{ namespace { $pre } { $uri } }</e>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.          let $pre := "z",             $uri := "http://www.zorba-xquery.com/"         return           <e>{ namespace [Error is around here]{ $pre } { $uri } }</e>
nscons-015,Error: XPST0003: Unable to parse XPath: "         declare namespace z="http://www.zorba-xquery.com/";         <z:e>{ namespace { <a/>/* } { "http://www.w3.org/" } }</z:e>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.          declare namespace z="http://www.zorba-xquery.com/";         <z:e>{ namespace [Error is around here]{ <a/>/* } { "http://www.w3.org/" } }</z:e>
nscons-016,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: "\n        let $pre := <prefix>z:z</prefix>,\n            $uri := "http://www.zorba-xquery.com/"\n        return\n          <e>{ namespace { $pre } { $uri } }</e>\n      ".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.\n\n        let $pre := <prefix>z:z</prefix>,\n            $uri := "http://www.zorba-xquery.com/"\n        return\n          <e>{ namespace [Error is around here]{ $pre } { $uri } }</e>\n      '
nscons-017,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: "\n        let $pre := "z z",\n            $uri := "http://www.zorba-xquery.com/"\n        return\n          <e>{ namespace { $pre } { $uri } }</e>\n      ".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.\n\n        let $pre := "z z",\n            $uri := "http://www.zorba-xquery.com/"\n        return\n          <e>{ namespace [Error is around here]{ $pre } { $uri } }</e>\n      '
nscons-018,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "\n        let $pre := 1,\n            $uri := "http://www.zorba-xquery.com/"\n        return\n          <e>{ namespace { $pre } { $uri } }</e>\n      ".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.\n\n        let $pre := 1,\n            $uri := "http://www.zorba-xquery.com/"\n        return\n          <e>{ namespace [Error is around here]{ $pre } { $uri } }</e>\n      '
nscons-019,AssertionError: expected [Function] to throw error including 'XQDY0101' but got 'XPST0003: Unable to parse XPath: "\n        let $uri := "http://www.w3.org/XML/1998/namespace"\n        return\n          <e>{ namespace x { $uri } }</e>\n      ".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "x" found.\n\n        let $uri := "http://www.w3.org/XML/1998/namespace"\n        return\n          <e>{ namespace [Error is around here]x { $uri } }</e>\n      '
nscons-020,AssertionError: expected [Function] to throw error including 'XQDY0101' but got 'XPST0003: Unable to parse XPath: "\n        let $uri := "http://www.w3.org/2000/xmlns/"\n        return\n          <e>{ namespace x { $uri } }</e>\n      ".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "x" found.\n\n        let $uri := "http://www.w3.org/2000/xmlns/"\n        return\n          <e>{ namespace [Error is around here]x { $uri } }</e>\n      '
nscons-021,AssertionError: expected [Function] to throw error including 'XQDY0101' but got 'XPST0003: Unable to parse XPath: "\n        <e>{ namespace x { "" } }</e>\n      ".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "x" found.\n\n        <e>{ namespace [Error is around here]x { "" } }</e>\n      '
nscons-022,Error: XPST0003: Unable to parse XPath: "         let $elem := <e>{ namespace z { "http://www.zorba-xquery.com/" } }</e>         return           element { resolve-QName("z:f", $elem) } {}       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "z" found.          let $elem := <e>{ namespace [Error is around here]z { "http://www.zorba-xquery.com/" } }</e>         return           element { resolve-QName("z:f", $elem) } {}
nscons-023,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPST0003: Unable to parse XPath: "\n        <z:e>{ namespace z { "http://www.zorba-xquery.com/" } }</z:e>\n      ".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "z" found.\n\n        <z:e>{ namespace [Error is around here]z { "http://www.zorba-xquery.com/" } }</z:e>\n      '
nscons-024,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPST0003: Unable to parse XPath: "\n        <e>{ namespace z { "http://www.zorba-xquery.com/" }, element z:e {} }</e>\n      ".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "z" found.\n\n        <e>{ namespace [Error is around here]z { "http://www.zorba-xquery.com/" }, element z:e {} }</e>\n      '
nscons-025,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPST0003: Unable to parse XPath: "\n        element e { attribute z:a {},  namespace z { "http://www.zorba-xquery.com/" } }\n      ".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.\n\n        element [Error is around here]e { attribute z:a {},  namespace z { "http://www.zorba-xquery.com/" } }\n      '
nscons-026,AssertionError: expected [Function] to throw error including 'FONS0004' but got 'XPST0003: Unable to parse XPath: "\n        <e>{ namespace z { "http://www.zorba-xquery.com/" }, element { xs:QName("z:e") } { } }</e>\n      ".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "z" found.\n\n        <e>{ namespace [Error is around here]z { "http://www.zorba-xquery.com/" }, element { xs:QName("z:e") } { } }</e>\n      '
nscons-027,SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "z" found.
nscons-028,SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "z" found.
nscons-029,AssertionError: expected [Function] to throw error including 'SENR0001' but got 'XPST0003: Unable to parse XPath: "\n        serialize( namespace z { "http://www.zorba-xquery.com/" } )\n      ".\nExpected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "z" found.\n\n        serialize( namespace [Error is around here]z { "http://www.zorba-xquery.com/" } )\n      '
nscons-030,Error: XPST0003: Unable to parse XPath: "let $result := (         serialize( element e { namespace z { "http://www.zorba-xquery.com/" } } )       ) return contains($result,'xmlns:z')". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found. let $result := (         serialize( element [Error is around here]e { namespace z { "http://www.zorba-xquery.com/" } } )       ) return contains($result,'xmlns:z')
nscons-031,Error: XPST0003: Unable to parse XPath: "         declare copy-namespaces preserve, inherit;         let $nested :=              element outer {                namespace out { "http://out.zorba-xquery.com/" },               element inner {                 namespace in { "http://in.zorba-xquery.com/" }               }              },             $elem := element e { namespace new { "http://new.zorba-xquery.com/" }, $nested }         return           $elem/outer/inner       ". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "o" found.          declare copy-namespaces preserve, inherit;         let $nested :=              element [Error is around here]outer {                namespace out { "http://out.zorba-xquery.com/" },               element inner {                 namespace in { "http://in.zorba-xquery.com/" }               }              },             $elem := element e { namespace new { "http://new.zorba-xquery.com/" }, $nested }         return           $elem/outer/inner
nscons-032,Error: XPST0003: Unable to parse XPath: "         declare copy-namespaces preserve, no-inherit;         let $nested :=              element outer {                namespace out { "http://out.zorba-xquery.com/" },               element inner { namespace in { "http://in.zorba-xquery.com/" } }              },             $elem := element e { namespace new { "http://new.zorba-xquery.com/" }, $nested }         return           $elem/outer/inner       ". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "o" found.          declare copy-namespaces preserve, no-inherit;         let $nested :=              element [Error is around here]outer {                namespace out { "http://out.zorba-xquery.com/" },               element inner { namespace in { "http://in.zorba-xquery.com/" } }              },             $elem := element e { namespace new { "http://new.zorba-xquery.com/" }, $nested }         return           $elem/outer/inner
nscons-033,Error: XPST0003: Unable to parse XPath: "         declare copy-namespaces no-preserve, inherit;         let $nested :=              element outer {                namespace out { "http://out.zorba-xquery.com/" },               element inner { namespace in { "http://in.zorba-xquery.com/" } }              },             $elem := element e { namespace new { "http://new.zorba-xquery.com/" }, $nested }         return           $elem/outer/inner       ". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "o" found.          declare copy-namespaces no-preserve, inherit;         let $nested :=              element [Error is around here]outer {                namespace out { "http://out.zorba-xquery.com/" },               element inner { namespace in { "http://in.zorba-xquery.com/" } }              },             $elem := element e { namespace new { "http://new.zorba-xquery.com/" }, $nested }         return           $elem/outer/inner
nscons-034,Error: XPST0003: Unable to parse XPath: "         declare copy-namespaces no-preserve, no-inherit;         let $nested :=              element outer {                namespace out { "http://out.zorba-xquery.com/" },               element inner { namespace in { "http://in.zorba-xquery.com/" } }              },             $elem := element e { namespace new { "http://new.zorba-xquery.com/" }, $nested }         return           $elem/outer/inner       ". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "o" found.          declare copy-namespaces no-preserve, no-inherit;         let $nested :=              element [Error is around here]outer {                namespace out { "http://out.zorba-xquery.com/" },               element inner { namespace in { "http://in.zorba-xquery.com/" } }              },             $elem := element e { namespace new { "http://new.zorba-xquery.com/" }, $nested }         return           $elem/outer/inner
nscons-035,SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "z" found.
nscons-036,SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "z" found.
nscons-037,SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "z" found.
nscons-038,SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "z" found.
nscons-039,Error: XPST0003: Unable to parse XPath: "         declare copy-namespaces preserve, inherit;                  declare function local:rec-add($level as xs:integer) as element() {           if ($level > 0) then             element { concat("e", $level) } {                namespace { concat("pre", $level) } { concat("uri", $level) },               local:rec-add($level - 1)             }           else             element e0 {}                };          local:rec-add(2)/e1/e0       ". Expected "!", "!=", "(", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "else", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.          declare copy-namespaces preserve, inherit;                  declare function local:rec-add($level as xs:integer) as element() {           if ($level > 0) then             element [Error is around here]{ concat("e", $level) } {                namespace { concat("pre", $level) } { concat("uri", $level) },               local:rec-add($level - 1)             }           else             element e0 {}                };          local:rec-add(2)/e1/e0
nscons-042,AssertionError: expected [Function] to throw error including 'XQDY0102' but got 'XPST0003: Unable to parse XPath: "\n        element e { namespace {\'\'} {\'http://example.com/uri\'} }\n      ".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.\n\n        element [Error is around here]e { namespace {\'\'} {\'http://example.com/uri\'} }\n      '
nscons-043,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "\n        let $pre := xs:anyURI(\'ns\'),\n            $uri := "http://www.zorba-xquery.com/"\n        return\n          <e>{ namespace { $pre } { $uri } }</e>\n      ".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.\n\n        let $pre := xs:anyURI(\'ns\'),\n            $uri := "http://www.zorba-xquery.com/"\n        return\n          <e>{ namespace [Error is around here]{ $pre } { $uri } }</e>\n      '
nscons-044,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "\n        let $pre := xs:duration(\'P1D\'),\n            $uri := "http://www.zorba-xquery.com/"\n        return\n          <e>{ namespace { $pre } { $uri } }</e>\n      ".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.\n\n        let $pre := xs:duration(\'P1D\'),\n            $uri := "http://www.zorba-xquery.com/"\n        return\n          <e>{ namespace [Error is around here]{ $pre } { $uri } }</e>\n      '
Constr-comppi-name-1,Error: XPST0003: Unable to parse XPath: "processing-instruction pi {'text'}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "p" found. processing-instruction [Error is around here]pi {'text'}
Constr-comppi-compname-1,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "processing-instruction {()} {\'text\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nprocessing-instruction [Error is around here]{()} {\'text\'}'
Constr-comppi-compname-2,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "processing-instruction {\'one\', \'two\'} {\'text\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nprocessing-instruction [Error is around here]{\'one\', \'two\'} {\'text\'}'
Constr-comppi-compname-3,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "processing-instruction {xs:untypedAtomic(\'one\'), xs:untypedAtomic(\'two\')} {\'text\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nprocessing-instruction [Error is around here]{xs:untypedAtomic(\'one\'), xs:untypedAtomic(\'two\')} {\'text\'}'
Constr-comppi-compname-4,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "processing-instruction {//a} {\'text\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nprocessing-instruction [Error is around here]{//a} {\'text\'}'
Constr-comppi-compname-5,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "processing-instruction {1,2} {\'text\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nprocessing-instruction [Error is around here]{1,2} {\'text\'}'
Constr-comppi-compname-6,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "processing-instruction {123} {\'text\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nprocessing-instruction [Error is around here]{123} {\'text\'}'
Constr-comppi-compname-7,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "processing-instruction {xs:dateTime("1999-05-31T13:20:00")} {\'text\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nprocessing-instruction [Error is around here]{xs:dateTime("1999-05-31T13:20:00")} {\'text\'}'
Constr-comppi-compname-8,Error: XPST0003: Unable to parse XPath: "processing-instruction {//*:NCName[1]} {'text'}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. processing-instruction [Error is around here]{//*:NCName[1]} {'text'}
Constr-comppi-compname-9,AssertionError: Expected executing the XPath "processing-instruction {//*:QName} {'text'}" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQDY0041' but got 'XPST0003: Unable to parse XPath: "processing-instruction {//*:QName} {\'text\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nprocessing-instruction [Error is around here]{//*:QName} {\'text\'}', AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "processing-instruction {//*:QName} {\'text\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nprocessing-instruction [Error is around here]{//*:QName} {\'text\'}'.
Constr-comppi-compname-10,Error: XPST0003: Unable to parse XPath: "processing-instruction {'pi'} {'text'}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. processing-instruction [Error is around here]{'pi'} {'text'}
Constr-comppi-compname-11,Error: XPST0003: Unable to parse XPath: "processing-instruction {'pi', ()} {'text'}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. processing-instruction [Error is around here]{'pi', ()} {'text'}
Constr-comppi-compname-12,Error: XPST0003: Unable to parse XPath: "processing-instruction {(), 'pi'} {'text'}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. processing-instruction [Error is around here]{(), 'pi'} {'text'}
Constr-comppi-compname-13,AssertionError: expected [Function] to throw error including 'XQDY0041' but got 'XPST0003: Unable to parse XPath: "<elem xmlns:foo="http://www.example.com/foo">{processing-instruction {\'foo:attr\'} {}}</elem>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.\n<elem xmlns:foo="http://www.example.com/foo">{processing-instruction [Error is around here]{\'foo:attr\'} {}}</elem>'
Constr-comppi-compname-15,Error: XPST0003: Unable to parse XPath: "processing-instruction {xs:untypedAtomic('pi')} {'text'}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. processing-instruction [Error is around here]{xs:untypedAtomic('pi')} {'text'}
Constr-comppi-compname-16,AssertionError: expected [Function] to throw error including 'XQDY0041' but got 'XPST0003: Unable to parse XPath: "<elem xmlns:foo="http://www.example.com/foo">{processing-instruction {xs:untypedAtomic(\'foo:pi\')} {\'text\'}}</elem>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.\n<elem xmlns:foo="http://www.example.com/foo">{processing-instruction [Error is around here]{xs:untypedAtomic(\'foo:pi\')} {\'text\'}}</elem>'
Constr-comppi-compname-18,AssertionError: expected [Function] to throw error including 'XQDY0041' but got 'XPST0003: Unable to parse XPath: "processing-instruction {\'p i\'} {\'text\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nprocessing-instruction [Error is around here]{\'p i\'} {\'text\'}'
Constr-comppi-compname-19,AssertionError: expected [Function] to throw error including 'XQDY0041' but got 'XPST0003: Unable to parse XPath: "processing-instruction {xs:untypedAtomic(\'p i\')} {\'text\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nprocessing-instruction [Error is around here]{xs:untypedAtomic(\'p i\')} {\'text\'}'
Constr-comppi-compname-20,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "processing-instruction {(\'pi\'[current-date() lt xs:date(\'1900-01-01\')], xs:anyURI(\'pi\'))} {\'text\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nprocessing-instruction [Error is around here]{(\'pi\'[current-date() lt xs:date(\'1900-01-01\')], xs:anyURI(\'pi\'))} {\'text\'}'
Constr-comppi-compname-21,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "processing-instruction {(\'pi\'[current-date() lt xs:date(\'1900-01-01\')], xs:duration(\'P1D\'))} {\'text\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nprocessing-instruction [Error is around here]{(\'pi\'[current-date() lt xs:date(\'1900-01-01\')], xs:duration(\'P1D\'))} {\'text\'}'
Constr-comppi-compname-22,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "processing-instruction {\'pi\'[current-date() lt xs:date(\'1900-01-01\')]} {\'text\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nprocessing-instruction [Error is around here]{\'pi\'[current-date() lt xs:date(\'1900-01-01\')]} {\'text\'}'
Constr-comppi-doc-1,Error: XPST0003: Unable to parse XPath: "processing-instruction pi {., .}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "p" found. processing-instruction [Error is around here]pi {., .}
Constr-comppi-parent-1,Error: XPST0003: Unable to parse XPath: "count((processing-instruction pi {()})/..) = 0". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "p" found. count((processing-instruction [Error is around here]pi {()})/..) = 0
Constr-comppi-string-1,Error: XPST0003: Unable to parse XPath: "fn:string(processing-instruction pi {'a', element a {}, 'b'})". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "p" found. fn:string(processing-instruction [Error is around here]pi {'a', element a {}, 'b'})
Constr-comppi-data-1,Error: XPST0003: Unable to parse XPath: "fn:data(processing-instruction pi {'a', element a {}, 'b'})". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "p" found. fn:data(processing-instruction [Error is around here]pi {'a', element a {}, 'b'})
Constr-comppi-enclexpr-1,Error: XPST0003: Unable to parse XPath: "processing-instruction pi {1,'string',3.14,xs:float('1.2345e-2'),xs:dateTime('2002-04-02T12:00:00-01:00')}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "p" found. processing-instruction [Error is around here]pi {1,'string',3.14,xs:float('1.2345e-2'),xs:dateTime('2002-04-02T12:00:00-01:00')}
Constr-comppi-enclexpr-2,Error: XPST0003: Unable to parse XPath: "processing-instruction pi {<elem>123</elem>, (<elem attr='456'/>)/@attr, (<elem>789</elem>)/text()}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "p" found. processing-instruction [Error is around here]pi {<elem>123</elem>, (<elem attr='456'/>)/@attr, (<elem>789</elem>)/text()}
Constr-comppi-enclexpr-3,Error: XPST0003: Unable to parse XPath: "processing-instruction pi {1,'',2}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "p" found. processing-instruction [Error is around here]pi {1,'',2}
Constr-comppi-enclexpr-4,Error: XPST0003: Unable to parse XPath: "processing-instruction pi {1,<a/>,2}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "p" found. processing-instruction [Error is around here]pi {1,<a/>,2}
Constr-comppi-enclexpr-5,Error: XPST0003: Unable to parse XPath: "processing-instruction pi {/root}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "p" found. processing-instruction [Error is around here]pi {/root}
Constr-comppi-namexml-1,AssertionError: expected [Function] to throw error including 'XQDY0064' but got 'XPST0003: Unable to parse XPath: "processing-instruction xml {\'pi\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "x" found.\nprocessing-instruction [Error is around here]xml {\'pi\'}'
Constr-comppi-namexml-2,AssertionError: expected [Function] to throw error including 'XQDY0064' but got 'XPST0003: Unable to parse XPath: "processing-instruction XmL {\'pi\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "X" found.\nprocessing-instruction [Error is around here]XmL {\'pi\'}'
Constr-comppi-namexml-3,AssertionError: expected [Function] to throw error including 'XQDY0064' but got 'XPST0003: Unable to parse XPath: "processing-instruction {\'xml\'} {\'pi\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nprocessing-instruction [Error is around here]{\'xml\'} {\'pi\'}'
Constr-comppi-namexml-4,AssertionError: expected [Function] to throw error including 'XQDY0064' but got 'XPST0003: Unable to parse XPath: "processing-instruction {\'XmL\'} {\'pi\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nprocessing-instruction [Error is around here]{\'XmL\'} {\'pi\'}'
Constr-comppi-invalid-1,AssertionError: expected [Function] to throw error including 'XQDY0026' but got 'XPST0003: Unable to parse XPath: "processing-instruction pi {\'?>\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "p" found.\nprocessing-instruction [Error is around here]pi {\'?>\'}'
Constr-comppi-invalid-2,AssertionError: expected [Function] to throw error including 'XQDY0026' but got 'XPST0003: Unable to parse XPath: "processing-instruction pi {\'?>text\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "p" found.\nprocessing-instruction [Error is around here]pi {\'?>text\'}'
Constr-comppi-invalid-3,AssertionError: expected [Function] to throw error including 'XQDY0026' but got 'XPST0003: Unable to parse XPath: "processing-instruction pi {\'text?>text\'}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "p" found.\nprocessing-instruction [Error is around here]pi {\'text?>text\'}'
Constr-comppi-space-1,Error: XPST0003: Unable to parse XPath: "processing-instruction pi {' text'}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "p" found. processing-instruction [Error is around here]pi {' text'}
Constr-comppi-space-2,Error: XPST0003: Unable to parse XPath: "processing-instruction pi {'&#x20;&#x0A;&#x0D;&#x09;text'}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "p" found. processing-instruction [Error is around here]pi {'&#x20;&#x0A;&#x0D;&#x09;text'}
Constr-comppi-space-3,Error: XPST0003: Unable to parse XPath: "string-to-codepoints(processing-instruction pi {' text'})". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "p" found. string-to-codepoints(processing-instruction [Error is around here]pi {' text'})
Constr-comppi-space-4,Error: XPST0003: Unable to parse XPath: "string-to-codepoints(processing-instruction pi {'&#x20;&#x0A;&#x0D;&#x09;text'})". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "p" found. string-to-codepoints(processing-instruction [Error is around here]pi {'&#x20;&#x0A;&#x0D;&#x09;text'})
Constr-comppi-empty-1,Error: XPST0003: Unable to parse XPath: "processing-instruction pi {()}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "p" found. processing-instruction [Error is around here]pi {()}
Constr-comppi-empty-2,Error: XPST0003: Unable to parse XPath: "processing-instruction pi {''}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "p" found. processing-instruction [Error is around here]pi {''}
K2-ComputeConPI-2,AssertionError: expected [Function] to throw error including 'XQDY0064' but got 'XPST0003: Unable to parse XPath: "processing-instruction {"xml"} {"content"}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nprocessing-instruction [Error is around here]{"xml"} {"content"}'
K2-ComputeConPI-3,AssertionError: expected [Function] to throw error including 'XQDY0064' but got 'XPST0003: Unable to parse XPath: "processing-instruction {" xmL "} {"content"}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nprocessing-instruction [Error is around here]{" xmL "} {"content"}'
K2-ComputeConPI-4,Error: XPST0003: Unable to parse XPath: "local-name(processing-instruction {" name "} {"content"})". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. local-name(processing-instruction [Error is around here]{" name "} {"content"})
K2-ComputeConPI-5,Error: XPST0003: Unable to parse XPath: "local-name(processing-instruction {" XmLnaMe "} {"content"})". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. local-name(processing-instruction [Error is around here]{" XmLnaMe "} {"content"})
K2-ComputeConPI-6,AssertionError: expected [Function] to throw error including 'XQDY0041' but got 'XPST0003: Unable to parse XPath: "processing-instruction {"1.das "} {"content"}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nprocessing-instruction [Error is around here]{"1.das "} {"content"}'
K2-ComputeConPI-7,AssertionError: expected [Function] to throw error including 'XQDY0026' but got 'XPST0003: Unable to parse XPath: "processing-instruction {"thename"} {"asdas?>"}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nprocessing-instruction [Error is around here]{"thename"} {"asdas?>"}'
K2-ComputeConPI-8,Error: XPST0003: Unable to parse XPath: "string(processing-instruction {"thename"} {"asdas? >"})". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. string(processing-instruction [Error is around here]{"thename"} {"asdas? >"})
K2-ComputeConPI-9,Error: XPST0003: Unable to parse XPath: "string(processing-instruction {"thename"} {"content {1+ } {"})". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. string(processing-instruction [Error is around here]{"thename"} {"content {1+ } {"})
K2-ComputeConPI-10,Error: XPST0003: Unable to parse XPath: "processing-instruction name {" "} eq """. Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found. processing-instruction [Error is around here]name {" "} eq ""
K2-ComputeConPI-11,Error: XPST0003: Unable to parse XPath: "data(processing-instruction name {"content"}) instance of xs:string". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. data(processing-instruction [Error is around here]name {"content"}) instance of xs:string
cbcl-constr-comppi-001,AssertionError: expected [Function] to throw error including 'XQDY0026' but got 'XPST0003: Unable to parse XPath: "\n      \t<element> { processing-instruction { \'pi\' } { <element>?&gt;</element> } } </element>\n      ".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.\n\n      \t<element> { processing-instruction [Error is around here]{ \'pi\' } { <element>?&gt;</element> } } </element>\n      '
cbcl-constr-comppi-002,AssertionError: expected [Function] to throw error including 'XQDY0026' but got 'XPST0003: Unable to parse XPath: "\n      \tdeclare function local:tag($arg) as element() { element { \'tag\' } { $arg } }; \n      \t<element> { processing-instruction { \'pi\' } { "content", local:tag(\'?&gt;\') } } </element>\n      ".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.\n\n      \tdeclare function local:tag($arg) as element() { element [Error is around here]{ \'tag\' } { $arg } }; \n      \t<element> { processing-instruction { \'pi\' } { "content", local:tag(\'?&gt;\') } } </element>\n      '
Constr-text-enclexpr-1,Error: XPST0003: Unable to parse XPath: "text {1,'string',3.14,xs:float('1.2345e-2'),xs:dateTime('2002-04-02T12:00:00-01:00')}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. text [Error is around here]{1,'string',3.14,xs:float('1.2345e-2'),xs:dateTime('2002-04-02T12:00:00-01:00')}
Constr-text-enclexpr-2,Error: XPST0003: Unable to parse XPath: "text {<elem>123</elem>, (<elem attr='456'/>)/@attr, (<elem>789</elem>)/text()}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. text [Error is around here]{<elem>123</elem>, (<elem attr='456'/>)/@attr, (<elem>789</elem>)/text()}
Constr-text-enclexpr-3,Error: XPST0003: Unable to parse XPath: "text {1,'',2}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. text [Error is around here]{1,'',2}
Constr-text-enclexpr-4,Error: XPST0003: Unable to parse XPath: "text {1,<a/>,2}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. text [Error is around here]{1,<a/>,2}
Constr-text-enclexpr-5,Error: XPST0003: Unable to parse XPath: "text {/root}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. text [Error is around here]{/root}
Constr-text-doc-1,Error: XPST0003: Unable to parse XPath: "text {., .}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. text [Error is around here]{., .}
Constr-text-parent-1,Error: XPST0003: Unable to parse XPath: "count((text {'text'})/..) = 0". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. count((text [Error is around here]{'text'})/..) = 0
Constr-text-string-1,Error: XPST0003: Unable to parse XPath: "fn:string(text {'a', element a {}, 'b'})". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. fn:string(text [Error is around here]{'a', element a {}, 'b'})
Constr-text-data-1,Error: XPST0003: Unable to parse XPath: "fn:data(text {'a', element a {}, 'b'})". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. fn:data(text [Error is around here]{'a', element a {}, 'b'})
Constr-text-count-1,Error: XPST0003: Unable to parse XPath: "count(text {''}) = 1". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. count(text [Error is around here]{''}) = 1
Constr-text-count-2,Error: XPST0003: Unable to parse XPath: "count(text {()}) = 0". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. count(text [Error is around here]{()}) = 0
Constr-text-count-3,Error: XPST0003: Unable to parse XPath: "count(element elem {text {''}}/text()) = 0". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found. count(element [Error is around here]elem {text {''}}/text()) = 0
Constr-text-count-4,AssertionError: Expected executing the XPath "count(document {text {''}}/text())" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "count(document {text {''}}/text()) = 0". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. count(document [Error is around here]{text {''}}/text()) = 0, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "count(document {text {\'\'}}/text())".\nExpected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.\ncount(document [Error is around here]{text {\'\'}}/text())'.
Constr-text-count-5,Error: XPST0003: Unable to parse XPath: "count(<a>{text {''}}<b/>{text {''}}<b/>{text {''}}</a>/text()) = 0". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. count(<a>{text [Error is around here]{''}}<b/>{text {''}}<b/>{text {''}}</a>/text()) = 0
Constr-text-count-6,AssertionError: Expected executing the XPath "count(document {text {''},<b/>,text {''},<b/>,text {''}}/text())" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "count(document {text {''},<b/>,text {''},<b/>,text {''}}/text()) = 0". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. count(document [Error is around here]{text {''},<b/>,text {''},<b/>,text {''}}/text()) = 0, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "count(document {text {\'\'},<b/>,text {\'\'},<b/>,text {\'\'}}/text())".\nExpected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.\ncount(document [Error is around here]{text {\'\'},<b/>,text {\'\'},<b/>,text {\'\'}}/text())'.
Constr-text-adjtext-1,Error: XPST0003: Unable to parse XPath: "count(<elem>{text {'te'}, text {'xt'}}</elem>/text()) = 1". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. count(<elem>{text [Error is around here]{'te'}, text {'xt'}}</elem>/text()) = 1
Constr-text-adjtext-2,Error: XPST0003: Unable to parse XPath: "count(document {text {'te'}, text {'xt'}}/text()) = 1". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. count(document [Error is around here]{text {'te'}, text {'xt'}}/text()) = 1
Constr-text-nested-1,Error: XPST0003: Unable to parse XPath: "text {text {'one', text {'two'}}, 'three', text {'four'}}". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. text [Error is around here]{text {'one', text {'two'}}, 'three', text {'four'}}
Constr-text-nested-2,Error: XPST0003: Unable to parse XPath: "<elem>{text {'one'}}<a>{text {'two'}}</a>{text {'three'}}</elem>". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. <elem>{text [Error is around here]{'one'}}<a>{text {'two'}}</a>{text {'three'}}</elem>
Constr-text-nested-3,Error: XPST0003: Unable to parse XPath: "document {text {'one'}, <a/>, text {'two'}, <b/>, text {'three'}}". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. document [Error is around here]{text {'one'}, <a/>, text {'two'}, <b/>, text {'three'}}
K2-ConText-3,Error: XPST0003: Unable to parse XPath: "string(text {""}) eq """. Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. string(text [Error is around here]{""}) eq ""
K2-ConText-4,Error: XPST0003: Unable to parse XPath: "<a>{text{()}}</a>". Expected "!", "!=", "#", "(", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", "}", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. <a>{text[Error is around here]{()}}</a>
K2-ConText-5a,Error: XPST0003: Unable to parse XPath: "(text{}) => empty()". Expected "!", "!=", "#", "(", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. (text[Error is around here]{}) => empty()
K2-ConText-6,Error: XPST0003: Unable to parse XPath: "data(text {"content"}) instance of xs:untypedAtomic". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. data(text [Error is around here]{"content"}) instance of xs:untypedAtomic
K2-ConText-14,Error: XPST0003: Unable to parse XPath: "<elem>{1}{text{""}}{2}</elem>". Expected "!", "!=", "#", "(", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", "}", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. <elem>{1}{text[Error is around here]{""}}{2}</elem>
K2-ConText-15,Error: XPST0003: Unable to parse XPath: "string(<elem>{1}{text{""}}{2}</elem>)". Expected "!", "!=", "#", "(", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", "}", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. string(<elem>{1}{text[Error is around here]{""}}{2}</elem>)
constprolog-1,AssertionError: expected [Function] to throw error including 'XQST0067' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
constprolog-2,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
constprolog-3,Error: XPST0003: Unable to parse XPath: "         declare construction strip;          let $anElement := element anElement {"someContent"}          return $anElement instance of element(*,xs:untyped)       ". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "a" found.          declare construction strip;          let $anElement := element [Error is around here]anElement {"someContent"}          return $anElement instance of element(*,xs:untyped)
constprolog-4,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
constprolog-5,Error: XPST0003: Unable to parse XPath: "         declare construction strip;          let $anElement := element anElement {"someContent"}          return $anElement instance of element(*,xs:anyType)". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "a" found.          declare construction strip;          let $anElement := element [Error is around here]anElement {"someContent"}          return $anElement instance of element(*,xs:anyType)
constprolog-6,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
constprolog-7,Error: XPST0003: Unable to parse XPath: "         declare construction strip;          let $anElement := element anElement {"someContent"}          return $anElement instance of element(*,xs:anyType)       ". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "a" found.          declare construction strip;          let $anElement := element [Error is around here]anElement {"someContent"}          return $anElement instance of element(*,xs:anyType)
constprolog-8,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
constprolog-9,Error: XPST0003: Unable to parse XPath: "         declare construction strip;          let $anElement := element someElement{"some content"}          return fn:not($anElement instance of element(*,xs:untyped))". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found.          declare construction strip;          let $anElement := element [Error is around here]someElement{"some content"}          return fn:not($anElement instance of element(*,xs:untyped))
constprolog-10,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
constprolog-11,Error: XPST0003: Unable to parse XPath: "         declare construction preserve;          let $anElement := element someElement{"some content"}          return fn:not($anElement instance of element(*,xs:anyType))       ". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found.          declare construction preserve;          let $anElement := element [Error is around here]someElement{"some content"}          return fn:not($anElement instance of element(*,xs:anyType))
constprolog-12,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
constprolog-13,Error: XPST0003: Unable to parse XPath: "         declare construction preserve;          fn:not(element someElement{"some content"} instance of element(*,xs:anyType))       ". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "s" found.          declare construction preserve;          fn:not(element [Error is around here]someElement{"some content"} instance of element(*,xs:anyType))
constprolog-14,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
constprolog-15,Error: XPST0003: Unable to parse XPath: "         declare construction strip;          let $anElement := element someElement{"some content"}          return ($anElement instance of element(*,xs:untyped)) and fn:true()       ". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found.          declare construction strip;          let $anElement := element [Error is around here]someElement{"some content"}          return ($anElement instance of element(*,xs:untyped)) and fn:true()
constprolog-16,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
constprolog-17,Error: XPST0003: Unable to parse XPath: "         declare construction preserve;          let $anElement := element someElement{"some content"}          return ($anElement instance of element(*,xs:anyType)) and fn:true()       ". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found.          declare construction preserve;          let $anElement := element [Error is around here]someElement{"some content"}          return ($anElement instance of element(*,xs:anyType)) and fn:true()
constprolog-18,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
constprolog-19,Error: XPST0003: Unable to parse XPath: "         declare construction strip;          let $anElement := element someElement{"some content"}          return ($anElement instance of element(*,xs:untyped)) or fn:false()       ". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found.          declare construction strip;          let $anElement := element [Error is around here]someElement{"some content"}          return ($anElement instance of element(*,xs:untyped)) or fn:false()
constprolog-20,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
constprolog-21,Error: XPST0003: Unable to parse XPath: "         declare construction preserve;          let $anElement := element someElement{"some content"}          return ($anElement instance of element(*,xs:anyType)) or fn:false()       ". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found.          declare construction preserve;          let $anElement := element [Error is around here]someElement{"some content"}          return ($anElement instance of element(*,xs:anyType)) or fn:false()
K-ConstructionProlog-1,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K-ConstructionProlog-3,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K-ConstructionProlog-4,AssertionError: expected [Function] to throw error including 'XQST0067' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
contextDecl-014,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
contextDecl-015,AssertionError: Expected executing the XPath "         declare variable $y := /works/employee;         declare context item := $y[9];         declare variable $x external := if (./*) then fn:position() else 0;         ($x, $y)       " to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules', AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
contextDecl-016,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
contextDecl-017,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
contextDecl-018,AssertionError: Expected executing the XPath " declare context item := last() + 1; ." to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules', AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
contextDecl-019,AssertionError: Expected executing the XPath " declare context item := position() + 1; ." to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules', AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
contextDecl-020,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: " declare context item as xs:integer external; . ".\nExpected "(", "Q", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but " " found.\n declare context item as[Error is around here] xs:integer external; . '
contextDecl-021,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: " declare context item as xs:integer := \'London\'; . ".\nExpected "(", "Q", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but " " found.\n declare context item as[Error is around here] xs:integer := \'London\'; . '
contextDecl-022,AssertionError: Expected executing the XPath " declare context item as xs:string := 2; . " to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: " declare context item as xs:string := 2; . ".\nExpected "(", "Q", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but " " found.\n declare context item as[Error is around here] xs:string := 2; . '.
contextDecl-028,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
contextDecl-029,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
contextDecl-030,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
contextDecl-031,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
contextDecl-032,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
contextDecl-033,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
contextDecl-034,Error: XPST0003: Unable to parse XPath: "declare context item as xs:integer := (1 to 17)[position() = 5]; . = 5". Expected "(", "Q", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but " " found. declare context item as[Error is around here] xs:integer := (1 to 17)[position() = 5]; . = 5
contextDecl-035,Error: XPST0003: Unable to parse XPath: "         declare context item as xs:integer := (1 to 17)[position() = 5];         .        = 5". Expected "(", "Q", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but " " found.          declare context item as[Error is around here] xs:integer := (1 to 17)[position() = 5];         .        = 5
contextDecl-036,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "\n        declare context item as xs:integer := current-date();\n        .\n      ".\nExpected "(", "Q", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but " " found.\n\n        declare context item as[Error is around here] xs:integer := current-date();\n        .\n      '
contextDecl-037,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "\n        declare context item as xs:integer := <a>23</a>;\n        .\n      ".\nExpected "(", "Q", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but " " found.\n\n        declare context item as[Error is around here] xs:integer := <a>23</a>;\n        .\n      '
contextDecl-038,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "\n        declare context item as xs:anyURI := "http://www.w3.org/";\n        .\n      ".\nExpected "(", "Q", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but " " found.\n\n        declare context item as[Error is around here] xs:anyURI := "http://www.w3.org/";\n        .\n      '
contextDecl-039,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "\n        declare context item as xs:double := 1.234;\n        .\n      ".\nExpected "(", "Q", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but " " found.\n\n        declare context item as[Error is around here] xs:double := 1.234;\n        .\n      '
contextDecl-040,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
contextDecl-041,Error: XPST0003: Unable to parse XPath: "         declare context item as document-node() external;         name(/*)        = "works"". Expected "(", "Q", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but " " found.          declare context item as[Error is around here] document-node() external;         name(/*)        = "works"
contextDecl-042,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
contextDecl-043,Error: XPST0003: Unable to parse XPath: "         declare context item as xs:integer external := 17;         . = 17       ". Expected "(", "Q", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but " " found.          declare context item as[Error is around here] xs:integer external := 17;         . = 17
contextDecl-044,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: " declare context item as xs:double external := 17; . = 17".\nExpected "(", "Q", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but " " found.\n declare context item as[Error is around here] xs:double external := 17; . = 17'
contextDecl-045,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: " declare context item as xs:double external; . = 17".\nExpected "(", "Q", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but " " found.\n declare context item as[Error is around here] xs:double external; . = 17'
contextDecl-046,AssertionError: expected [Function] to throw error including 'XQST0099' but got 'XPST0003: Unable to parse XPath: "\n        declare context item as xs:double external;\n        declare context item as xs:integer := 15;\n        . = 17\n      ".\nExpected "(", "Q", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but " " found.\n\n        declare context item as[Error is around here] xs:double external;\n        declare context item as xs:integer := 15;\n        . = 17\n      '
contextDecl-047,SyntaxError: Expected "(", "Q", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but " " found.
contextDecl-048,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
contextDecl-049,SyntaxError: Expected "(", "Q", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but " " found.
contextDecl-050,SyntaxError: Expected "(", "Q", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but " " found.
contextDecl-051,SyntaxError: Expected "(", "Q", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but " " found.
contextDecl-052,SyntaxError: Expected "(", "Q", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but " " found.
contextDecl-053,AssertionError: Expected executing the XPath "         declare variable $p := "base-uri";         declare variable $f := function-lookup(xs:QName("fn:"||$p), 0);         declare context item := $f();         .       " to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules', AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
contextDecl-054,SyntaxError: Expected "(", "Q", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but " " found.
contextDecl-055,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
contextDecl-056,SyntaxError: Expected "(", "Q", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but " " found.
contextDecl-057,SyntaxError: Expected "(", "Q", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but " " found.
contextDecl-058,SyntaxError: Expected "(", "Q", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but " " found.
CurlyArray-002,Error: No selector counterpart for: anyArrayTest.
CurlyArray-006,Error: XPST0003: Unable to parse XPath: "(declare function local:fun() {1 to 5}; array:size(array{local:fun()})) instance of xs:integer". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found. (declare [Error is around here]function local:fun() {1 to 5}; array:size(array{local:fun()})) instance of xs:integer
CurlyArray-008,Error: XPST0003: Unable to parse XPath: "(declare function local:fun() {1 to 5}; array{local:fun()}(1)) instance of xs:integer". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found. (declare [Error is around here]function local:fun() {1 to 5}; array{local:fun()}(1)) instance of xs:integer
CurlyArray-010,Error: XPST0003: Unable to parse XPath: "declare function local:fun() {1 to 5}; array{local:fun()}?1 = 1". Expected "$", "(", "*", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "1" found. declare function local:fun() {1 to 5}; array{local:fun()}?[Error is around here]1 = 1
decimal-format-01,Error: XPST0003: Unable to parse XPath: "         declare default decimal-format zero-digit="0" grouping-separator="," decimal-separator=".";       	format-number(2392.14*36.58,'000,000.000000')". Expected " ", "(:", ";", "\n", "\r", or "\t" but "z" found.          declare default decimal-format [Error is around here]zero-digit="0" grouping-separator="," decimal-separator=".";       	format-number(2392.14*36.58,'000,000.000000')
decimal-format-02,Error: XPST0003: Unable to parse XPath: "         declare default decimal-format digit="#" grouping-separator="," decimal-separator=".";       	format-number(12792.14*96.58,'##,###,000.000###')". Expected " ", "(:", ";", "\n", "\r", or "\t" but "d" found.          declare default decimal-format [Error is around here]digit="#" grouping-separator="," decimal-separator=".";       	format-number(12792.14*96.58,'##,###,000.000###')
decimal-format-03,Error: XPST0003: Unable to parse XPath: "         declare default decimal-format minus-sign="-" grouping-separator="," decimal-separator=".";       	format-number(2792.14*(-36.58),'000,000.000###')". Expected " ", "(:", ";", "\n", "\r", or "\t" but "m" found.          declare default decimal-format [Error is around here]minus-sign="-" grouping-separator="," decimal-separator=".";       	format-number(2792.14*(-36.58),'000,000.000###')
decimal-format-04,Error: XPST0003: Unable to parse XPath: "         declare default decimal-format minus-sign="-" pattern-separator=";" grouping-separator="," decimal-separator=".";       	format-number(2392.14*(-36.58),'000,000.000###;###,###.000###')". Expected " ", "(:", ";", "\n", "\r", or "\t" but "m" found.          declare default decimal-format [Error is around here]minus-sign="-" pattern-separator=";" grouping-separator="," decimal-separator=".";       	format-number(2392.14*(-36.58),'000,000.000###;###,###.000###')
decimal-format-05,Error: XPST0003: Unable to parse XPath: "         declare decimal-format local:df minus-sign="-" percent="%" decimal-separator=".";       	format-number(0.4857,'###.###%', 'local:df')". Expected " ", "(:", ";", "\n", "\r", or "\t" but "m" found.          declare decimal-format local:df [Error is around here]minus-sign="-" percent="%" decimal-separator=".";       	format-number(0.4857,'###.###%', 'local:df')
decimal-format-06,Error: XPST0003: Unable to parse XPath: "         declare decimal-format local:df minus-sign="-" per-mille="‰" decimal-separator=".";       	format-number(0.4857,'###.###‰')". Expected " ", "(:", ";", "\n", "\r", or "\t" but "m" found.          declare decimal-format local:df [Error is around here]minus-sign="-" per-mille="‰" decimal-separator=".";       	format-number(0.4857,'###.###‰')
decimal-format-09,Error: XPST0003: Unable to parse XPath: "          declare default decimal-format decimal-separator="|" grouping-separator=".";           format-number(931.4857,'000.000|###')". Expected " ", "(:", ";", "\n", "\r", or "\t" but "d" found.           declare default decimal-format [Error is around here]decimal-separator="|" grouping-separator=".";           format-number(931.4857,'000.000|###')
decimal-format-11,Error: XPST0003: Unable to parse XPath: "         declare default decimal-format digit="!" pattern-separator="\";         format-number(26931.4,'+!!!,!!!.!!!\-!!,!!!.!!!')". Expected " ", "(:", ";", "\n", "\r", or "\t" but "d" found.          declare default decimal-format [Error is around here]digit="!" pattern-separator="\";         format-number(26931.4,'+!!!,!!!.!!!\-!!,!!!.!!!')
decimal-format-12,Error: XPST0003: Unable to parse XPath: "         declare default decimal-format digit="!" pattern-separator="\";         format-number(-26931.4,'+!!,!!!.!!!\-!!!,!!!.!!!')". Expected " ", "(:", ";", "\n", "\r", or "\t" but "d" found.          declare default decimal-format [Error is around here]digit="!" pattern-separator="\";         format-number(-26931.4,'+!!,!!!.!!!\-!!!,!!!.!!!')
decimal-format-13,Error: XPST0003: Unable to parse XPath: "         declare default decimal-format digit="!" pattern-separator="\";         format-number(-26931.4,'!!!,!!!.!!!')". Expected " ", "(:", ";", "\n", "\r", or "\t" but "d" found.          declare default decimal-format [Error is around here]digit="!" pattern-separator="\";         format-number(-26931.4,'!!!,!!!.!!!')
decimal-format-14,Error: XPST0003: Unable to parse XPath: "         declare decimal-format local:df2 infinity="off-the-scale";         format-number(1 div 0e0,'###############################', 'local:df2')". Expected " ", "(:", ";", "\n", "\r", or "\t" but "i" found.          declare decimal-format local:df2 [Error is around here]infinity="off-the-scale";         format-number(1 div 0e0,'###############################', 'local:df2')
decimal-format-15,Error: XPST0003: Unable to parse XPath: "         declare decimal-format local:df2 NaN="non-numeric";         format-number(number('none'), '#############', 'local:df2')". Expected " ", "(:", ";", "\n", "\r", or "\t" but "N" found.          declare decimal-format local:df2 [Error is around here]NaN="non-numeric";         format-number(number('none'), '#############', 'local:df2')
decimal-format-16,Error: XPST0003: Unable to parse XPath: "         declare default decimal-format  per-mille="m";         format-number(0.4857,'###.###m')". Expected " ", "(:", ";", "\n", "\r", or "\t" but "p" found.          declare default decimal-format  [Error is around here]per-mille="m";         format-number(0.4857,'###.###m')
decimal-format-17,Error: XPST0003: Unable to parse XPath: "         declare default decimal-format  minus-sign="_";         format-number(-26931.4,'+###,###.###;-###,###.###')". Expected " ", "(:", ";", "\n", "\r", or "\t" but "m" found.          declare default decimal-format  [Error is around here]minus-sign="_";         format-number(-26931.4,'+###,###.###;-###,###.###')
decimal-format-18,Error: XPST0003: Unable to parse XPath: "         declare default decimal-format minus-sign="_";         format-number(-26931.4,'###,###.###')". Expected " ", "(:", ";", "\n", "\r", or "\t" but "m" found.          declare default decimal-format [Error is around here]minus-sign="_";         format-number(-26931.4,'###,###.###')
decimal-format-19,Error: XPST0003: Unable to parse XPath: "         declare decimal-format myminus minus-sign="_";          concat(format-number(-26931.4,'###,###.###','myminus'), '/',         format-number(-42857.1,'###,###.###'))". Expected " ", "(:", ";", "\n", "\r", or "\t" but "m" found.          declare decimal-format myminus [Error is around here]minus-sign="_";          concat(format-number(-26931.4,'###,###.###','myminus'), '/',         format-number(-42857.1,'###,###.###'))
decimal-format-20,Error: XPST0003: Unable to parse XPath: "         declare namespace foo="http://foo.ns";         declare decimal-format foo:decimal1  decimal-separator="!" grouping-separator="*";         declare decimal-format decimal1  decimal-separator="*" grouping-separator="!";         format-number(1234.567,'#*###*###!###','foo:decimal1')". Expected " ", "(:", ";", "\n", "\r", or "\t" but "d" found.          declare namespace foo="http://foo.ns";         declare decimal-format foo:decimal1  [Error is around here]decimal-separator="!" grouping-separator="*";         declare decimal-format decimal1  decimal-separator="*" grouping-separator="!";         format-number(1234.567,'#*###*###!###','foo:decimal1')
decimal-format-21,SyntaxError: Expected " ", "(:", ";", "\n", "\r", or "\t" but "g" found.
decimal-format-31,AssertionError: expected [Function] to throw error including 'XQST0111' but got 'XPST0003: Unable to parse XPath: "\n        declare default decimal-format decimal-separator = "^";\n        declare default decimal-format decimal-separator = "^";\n      \ttrue()\n      ".\nExpected " ", "(:", ";", "\\n", "\\r", or "\\t" but "d" found.\n\n        declare default decimal-format [Error is around here]decimal-separator = "^";\n        declare default decimal-format decimal-separator = "^";\n      \ttrue()\n      '
decimal-format-32,AssertionError: expected [Function] to throw error including 'XQST0111' but got 'XPST0003: Unable to parse XPath: "\n        declare decimal-format fmt1 decimal-separator = "^";\n        declare decimal-format fmt1 decimal-separator = "^";\n      \ttrue()\n      ".\nExpected " ", "(:", ";", "\\n", "\\r", or "\\t" but "d" found.\n\n        declare decimal-format fmt1 [Error is around here]decimal-separator = "^";\n        declare decimal-format fmt1 decimal-separator = "^";\n      \ttrue()\n      '
decimal-format-33,Error: XPST0003: Unable to parse XPath: "         declare decimal-format fmt1 decimal-separator = "^";         declare decimal-format fmt2 decimal-separator = "~";       	concat (format-number(123.45, '9999^999', 'fmt1'), " and ",                 format-number(123.45, '9999~999', 'fmt2'))       ". Expected " ", "(:", ";", "\n", "\r", or "\t" but "d" found.          declare decimal-format fmt1 [Error is around here]decimal-separator = "^";         declare decimal-format fmt2 decimal-separator = "~";       	concat (format-number(123.45, '9999^999', 'fmt1'), " and ",                 format-number(123.45, '9999~999', 'fmt2'))
decimal-format-34,AssertionError: expected [Function] to throw error including 'XQST0114' but got 'XPST0003: Unable to parse XPath: "\n        declare default decimal-format decimal-separator = "^" grouping-separator = "\\" decimal-separator = "^";\n      \ttrue()\n      ".\nExpected " ", "(:", ";", "\\n", "\\r", or "\\t" but "d" found.\n\n        declare default decimal-format [Error is around here]decimal-separator = "^" grouping-separator = "\\" decimal-separator = "^";\n      \ttrue()\n      '
decimal-format-35,AssertionError: expected [Function] to throw error including 'XQST0097' but got 'XPST0003: Unable to parse XPath: "\n        declare default decimal-format zero-digit = "A";\n      \ttrue()\n      ".\nExpected " ", "(:", ";", "\\n", "\\r", or "\\t" but "z" found.\n\n        declare default decimal-format [Error is around here]zero-digit = "A";\n      \ttrue()\n      '
decimal-format-36,AssertionError: expected [Function] to throw error including 'XQST0098' but got 'XPST0003: Unable to parse XPath: "\n        declare default decimal-format decimal-separator = "~" grouping-separator = "~";\n      \ttrue()\n      ".\nExpected " ", "(:", ";", "\\n", "\\r", or "\\t" but "d" found.\n\n        declare default decimal-format [Error is around here]decimal-separator = "~" grouping-separator = "~";\n      \ttrue()\n      '
decimal-format-37,AssertionError: expected [Function] to throw error including 'XQST0098' but got 'XPST0003: Unable to parse XPath: "\n        declare default decimal-format decimal-separator = ",";\n      \ttrue()\n      ".\nExpected " ", "(:", ";", "\\n", "\\r", or "\\t" but "d" found.\n\n        declare default decimal-format [Error is around here]decimal-separator = ",";\n      \ttrue()\n      '
decimal-format-39,Error: XPST0003: Unable to parse XPath: "         declare default decimal-format minus-sign="-";         format-number(-26931.4,'###,###.###')". Expected " ", "(:", ";", "\n", "\r", or "\t" but "m" found.          declare default decimal-format [Error is around here]minus-sign="-";         format-number(-26931.4,'###,###.###')
decimal-format-40,Error: XPST0003: Unable to parse XPath: "       declare default decimal-format NaN = "0";       format-number(xs:double('NaN'),'###,###.###')". Expected " ", "(:", ";", "\n", "\r", or "\t" but "N" found.        declare default decimal-format [Error is around here]NaN = "0";       format-number(xs:double('NaN'),'###,###.###')
decimal-format-901err,AssertionError: expected [Function] to throw error including 'XQST0098' but got 'XPST0003: Unable to parse XPath: "\n        declare default decimal-format decimal-separator="!" grouping-separator="!";\n        format-number(931.4857,\'###!###!###\')".\nExpected " ", "(:", ";", "\\n", "\\r", or "\\t" but "d" found.\n\n        declare default decimal-format [Error is around here]decimal-separator="!" grouping-separator="!";\n        format-number(931.4857,\'###!###!###\')'
decimal-format-902err,AssertionError: expected [Function] to throw error including 'FODF1310' but got 'XPST0003: Unable to parse XPath: "\n        declare default decimal-format digit=\'$\';\n        format-number(931.4857,\'000.$$0\')".\nExpected " ", "(:", ";", "\\n", "\\r", or "\\t" but "d" found.\n\n        declare default decimal-format [Error is around here]digit=\'$\';\n        format-number(931.4857,\'000.$$0\')'
decimal-format-903err,AssertionError: expected [Function] to throw error including 'XQST0111' but got 'XPST0003: Unable to parse XPath: "\n        declare default decimal-format digit=\'$\';\n        declare default decimal-format minus-sign=\'_\';\n        format-number(931.4857,\'000.$$0\')".\nExpected " ", "(:", ";", "\\n", "\\r", or "\\t" but "d" found.\n\n        declare default decimal-format [Error is around here]digit=\'$\';\n        declare default decimal-format minus-sign=\'_\';\n        format-number(931.4857,\'000.$$0\')'
decimal-format-904err,AssertionError: expected [Function] to throw error including 'XQST0111' but got 'XPST0003: Unable to parse XPath: "\n        declare namespace a="http://a.com/";\n        declare namespace b="http://a.com/";\n        declare decimal-format a:one digit=\'$\';\n        declare decimal-format two digit=\'$\';\n        declare decimal-format three digit=\'$\';\n        declare decimal-format four digit=\'$\';\n        declare decimal-format five digit=\'$\';\n        declare decimal-format b:one minus-sign="_";\n        declare default decimal-format minus-sign=\'_\';\n        format-number(931.4857,\'000.$$0\')".\nExpected " ", "(:", ";", "\\n", "\\r", or "\\t" but "d" found.\n\n        declare namespace a="http://a.com/";\n        declare namespace b="http://a.com/";\n        declare decimal-format a:one [Error is around here]digit=\'$\';\n        declare decimal-format two digit=\'$\';\n        declare decimal-format three digit=\'$\';\n        declare decimal-format four digit=\'$\';\n        declare decimal-format five digit=\'$\';\n        declare decimal-format b:one minus-sign="_";\n        declare default decimal-format minus-sign=\'_\';\n        format-number(931.4857,\'000.$$0\')'
decimal-format-905err,AssertionError: expected [Function] to throw error including 'FODF1310' but got 'XPST0003: Unable to parse XPath: "\n        declare decimal-format q decimal-separator="." grouping-separator=",";\n        format-number(931.4857,\'fred.ginger\', \'q\')".\nExpected " ", "(:", ";", "\\n", "\\r", or "\\t" but "d" found.\n\n        declare decimal-format q [Error is around here]decimal-separator="." grouping-separator=",";\n        format-number(931.4857,\'fred.ginger\', \'q\')'
decimal-format-906err,AssertionError: expected [Function] to throw error including 'FODF1280' but got 'XPST0017: Function format-number with arity of 3 not registered. No similar functions found.'
decimal-format-907err,AssertionError: expected [Function] to throw error including 'XQST0114' but got 'XPST0003: Unable to parse XPath: "\n        declare namespace a="http://a.com/";\n        declare namespace b="http://a.com/";\n        declare decimal-format a:one digit=\'$\' zero-digit="0" minus-sign="_" digit="#";\n        format-number(931.4857,\'000.$$0\', \'a:one\')".\nExpected " ", "(:", ";", "\\n", "\\r", or "\\t" but "d" found.\n\n        declare namespace a="http://a.com/";\n        declare namespace b="http://a.com/";\n        declare decimal-format a:one [Error is around here]digit=\'$\' zero-digit="0" minus-sign="_" digit="#";\n        format-number(931.4857,\'000.$$0\', \'a:one\')'
decimal-format-908err,AssertionError: expected [Function] to throw error including 'XQST0097' but got 'XPST0003: Unable to parse XPath: "\n        declare default decimal-format digit="one";\n        format-number(931.4857,\'000.$$0\')".\nExpected " ", "(:", ";", "\\n", "\\r", or "\\t" but "d" found.\n\n        declare default decimal-format [Error is around here]digit="one";\n        format-number(931.4857,\'000.$$0\')'
decimal-format-909err,AssertionError: expected [Function] to throw error including 'XQST0097' but got 'XPST0003: Unable to parse XPath: "\n        declare default decimal-format zero-digit="1";\n        format-number(931.4857,\'000.$$0\')".\nExpected " ", "(:", ";", "\\n", "\\r", or "\\t" but "z" found.\n\n        declare default decimal-format [Error is around here]zero-digit="1";\n        format-number(931.4857,\'000.$$0\')'
decimal-format-910err,AssertionError: expected [Function] to throw error including 'XQST0097' but got 'XPST0003: Unable to parse XPath: "\n        declare default decimal-format zero-digit="a";\n        format-number(931.4857,\'aaa.$$a\')".\nExpected " ", "(:", ";", "\\n", "\\r", or "\\t" but "z" found.\n\n        declare default decimal-format [Error is around here]zero-digit="a";\n        format-number(931.4857,\'aaa.$$a\')'
decimal-format-911err,AssertionError: expected [Function] to throw error including 'XQST0097' but got 'XPST0003: Unable to parse XPath: "\n        declare default decimal-format minus-sign="--";\n        format-number(931.4857,\'000.$$0\')".\nExpected " ", "(:", ";", "\\n", "\\r", or "\\t" but "m" found.\n\n        declare default decimal-format [Error is around here]minus-sign="--";\n        format-number(931.4857,\'000.$$0\')'
decimal-format-912err,AssertionError: expected [Function] to throw error including 'XQST0098' but got 'XPST0003: Unable to parse XPath: "\n      declare default decimal-format decimal-separator = "6";\n      true()\n    ".\nExpected " ", "(:", ";", "\\n", "\\r", or "\\t" but "d" found.\n\n      declare default decimal-format [Error is around here]decimal-separator = "6";\n      true()\n    '
Constr-attr-enclexpr-9,AssertionError: expected [Function] to throw an error
Constr-attr-id-2,AssertionError: Expected executing the XPath "<elem xml:id=" a{'b c d',' '}"/>" to resolve to one of the expected results, but got AssertionError: Expected XPath <elem xml:id=" a{'b c d',' '}"/> to resolve to the given XML. Expected <elem xml:id=" ab c d  "/> to equal <elem xml:id="ab c d"/>, AssertionError: expected [Function] to throw an error.
K2-DirectConElemAttr-34,Error: XPST0003: Unable to parse XPath: "string(<elem attr="{comment {" content "}}"/>/@attr)". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. string(<elem attr="{comment [Error is around here]{" content "}}"/>/@attr)
K2-DirectConElemAttr-35,Error: XPST0003: Unable to parse XPath: "local-name(<elem attr="{comment {" content "}}"/>/@attr)". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. local-name(<elem attr="{comment [Error is around here]{" content "}}"/>/@attr)
K2-DirectConElemAttr-36,Error: XPST0003: Unable to parse XPath: "string(<elem attr="{processing-instruction name {" content "}}"/>/@attr)". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found. string(<elem attr="{processing-instruction [Error is around here]name {" content "}}"/>/@attr)
K2-DirectConElemAttr-37,Error: XPST0003: Unable to parse XPath: "local-name(<elem attr="{processing-instruction name {" content "}}"/>/@attr)". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found. local-name(<elem attr="{processing-instruction [Error is around here]name {" content "}}"/>/@attr)
K2-DirectConElemAttr-38,Error: XPST0003: Unable to parse XPath: "local-name(<elem attr="{attribute name {" content "}}"/>/@attr)". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found. local-name(<elem attr="{attribute [Error is around here]name {" content "}}"/>/@attr)
K2-DirectConElemAttr-39,Error: XPST0003: Unable to parse XPath: "string(<elem attr="{attribute name {" content "}}"/>/@attr)". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found. string(<elem attr="{attribute [Error is around here]name {" content "}}"/>/@attr)
K2-DirectConElemAttr-44,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-DirectConElemAttr-45,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-DirectConElemAttr-47,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
K2-DirectConElemAttr-70,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-DirectConElemAttr-71,Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://typedecl"; namespace-uri-from-QName(node-name(exactly-one(<e>{attribute attr {()} }/</e>/@attr))) eq """. Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "a" found. declare default element namespace "http://typedecl"; namespace-uri-from-QName(node-name(exactly-one(<e>{attribute [Error is around here]attr {()} }/</e>/@attr))) eq ""
K2-DirectConElemAttr-72,Error: XPST0003: Unable to parse XPath: "namespace-uri-from-QName(node-name(exactly-one(<e xmlns="http://example.com/">{attribute attr {()} }/</e>/@attr))) eq """. Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "a" found. namespace-uri-from-QName(node-name(exactly-one(<e xmlns="http://example.com/">{attribute [Error is around here]attr {()} }/</e>/@attr))) eq ""
K2-DirectConElemAttr-73,Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://example.com/"; namespace-uri-from-QName(node-name(attribute e {()})) eq """. Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found. declare default element namespace "http://example.com/"; namespace-uri-from-QName(node-name(attribute [Error is around here]e {()})) eq ""
K2-DirectConElemAttr-75,Error: XPST0003: Unable to parse XPath: "(:*******************************************************:) (: Test: K2-DirectConElemAttr-75                         :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:21+01:00                       :) (: Purpose: Mix several ways for creating text for various kinds of nodes. This test is useful if an implementation is performing normalization of such constructors. :) (:*******************************************************:) <e attribute="{ "abc", "def", "ghi", 1, 2, 3, xs:untypedAtomic("abc"), text {"a text node"}, text {"a text node"}, xs:untypedAtomic("def"), xs:untypedAtomic("ghi"), xs:hexBinary("FF"), xs:untypedAtomic("abc"), xs:string("def"), xs:untypedAtomic("ghi") } textNode {"xs:string"} textNode {"xs:string"} textNode {"xs:string"} text {"a text node"}, {"xs:string"} {"xs:string"}textnode"> {   attribute name { text {"a text node"}, text {"a text node"}, "abc", "def", text {"a text node"}, "ghi", 1, 2, text {"a text node"}, 3, xs:untypedAtomic("abc"), xs:untypedAtomic("def"), text {"a text node"}, xs:untypedAtomic("ghi"), xs:hexBinary("FF"), xs:untypedAtomic("abc"), xs:string("def"), xs:untypedAtomic("ghi"), "xs:string", xs:untypedAtomic("ghi"), "xs:string", "xs:string", "xs:string", xs:untypedAtomic("ghi") } } { text {"a text node"}, text {"a text node"}, "abc", "def", text {"a text node"}, "ghi", 1, 2, text {"a text node"}, 3, xs:untypedAtomic("abc"), text {"a text node"}, xs:untypedAtomic("def"), xs:untypedAtomic("ghi"), xs:hexBinary("FF"), xs:untypedAtomic("abc"), xs:string("def"), xs:untypedAtomic("ghi") } textNode {"xs:string"} textNode {"xs:string"} textNode {"xs:string"} {"xs:string"} {"xs:string"} text {"a text node"}, text {"a text node"}, text {"a text node"}, text {"a text node"},  { comment { "abc", "def", "ghi", 1, 2, 3, xs:untypedAtomic("abc"), xs:untypedAtomic("def"), xs:untypedAtomic("ghi"), xs:hexBinary("FF"), xs:untypedAtomic("abc"), xs:string("def"), xs:untypedAtomic("ghi"), "xs:string", "xs:string", xs:untypedAtomic("ghi"), "xs:string", text {"a text node"}, text {"a text node"}, "xs:string", xs:untypedAtomic("ghi"), "xs:string" }, processing-instruction target { "abc", "def", "ghi", 1, 2, 3, xs:untypedAtomic("abc"), xs:untypedAtomic("def"), xs:untypedAtomic("ghi"), text {"a text node"}, text {"a text node"}, xs:hexBinary("FF"), xs:untypedAtomic("abc"), xs:string("def"), xs:untypedAtomic("ghi"), "xs:string", "xs:string", xs:untypedAtomic("ghi"), "xs:string", "xs:string", xs:untypedAtomic("ghi"), text {"a text node"}, "xs:string" }, text { text {"a text node"}, text {"a text node"}, text {"a text node"}, text {"a text node"}, "abc", "def", "ghi", 1, 2, text {"a text node"}, 3, xs:untypedAtomic("abc"), text {"a text node"}, xs:untypedAtomic("def"), xs:untypedAtomic("ghi"), xs:hexBinary("FF"), xs:untypedAtomic("abc"), xs:string("def"), xs:untypedAtomic("ghi"), "xs:string", "xs:string", xs:untypedAtomic("ghi"), "xs:string", "xs:string", xs:untypedAtomic("ghi"), "xs:string", text {"a text node"} }  } </e>". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. (:*******************************************************:) (: Test: K2-DirectConElemAttr-75                         :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:21+01:00                       :) (: Purpose: Mix several ways for creating text for various kinds of nodes. This test is useful if an implementation is performing normalization of such constructors. :) (:*******************************************************:) <e attribute="{ "abc", "def", "ghi", 1, 2, 3, xs:untypedAtomic("abc"), text [Error is around here]{"a text node"}, text {"a text node"}, xs:untypedAtomic("def"), xs:untypedAtomic("ghi"), xs:hexBinary("FF"), xs:untypedAtomic("abc"), xs:string("def"), xs:untypedAtomic("ghi") } textNode {"xs:string"} textNode {"xs:string"} textNode {"xs:string"} text {"a text node"}, {"xs:string"} {"xs:string"}textnode"> {   attribute name { text {"a text node"}, text {"a text node"}, "abc", "def", text {"a text node"}, "ghi", 1, 2, text {"a text node"}, 3, xs:untypedAtomic("abc"), xs:untypedAtomic("def"), text {"a text node"}, xs:untypedAtomic("ghi"), xs:hexBinary("FF"), xs:untypedAtomic("abc"), xs:string("def"), xs:untypedAtomic("ghi"), "xs:string", xs:untypedAtomic("ghi"), "xs:string", "xs:string", "xs:string", xs:untypedAtomic("ghi") } } { text {"a text node"}, text {"a text node"}, "abc", "def", text {"a text node"}, "ghi", 1, 2, text {"a text node"}, 3, xs:untypedAtomic("abc"), text {"a text node"}, xs:untypedAtomic("def"), xs:untypedAtomic("ghi"), xs:hexBinary("FF"), xs:untypedAtomic("abc"), xs:string("def"), xs:untypedAtomic("ghi") } textNode {"xs:string"} textNode {"xs:string"} textNode {"xs:string"} {"xs:string"} {"xs:string"} text {"a text node"}, text {"a text node"}, text {"a text node"}, text {"a text node"},  { comment { "abc", "def", "ghi", 1, 2, 3, xs:untypedAtomic("abc"), xs:untypedAtomic("def"), xs:untypedAtomic("ghi"), xs:hexBinary("FF"), xs:untypedAtomic("abc"), xs:string("def"), xs:untypedAtomic("ghi"), "xs:string", "xs:string", xs:untypedAtomic("ghi"), "xs:string", text {"a text node"}, text {"a text node"}, "xs:string", xs:untypedAtomic("ghi"), "xs:string" }, processing-instruction target { "abc", "def", "ghi", 1, 2, 3, xs:untypedAtomic("abc"), xs:untypedAtomic("def"), xs:untypedAtomic("ghi"), text {"a text node"}, text {"a text node"}, xs:hexBinary("FF"), xs:untypedAtomic("abc"), xs:string("def"), xs:untypedAtomic("ghi"), "xs:string", "xs:string", xs:untypedAtomic("ghi"), "xs:string", "xs:string", xs:untypedAtomic("ghi"), text {"a text node"}, "xs:string" }, text { text {"a text node"}, text {"a text node"}, text {"a text node"}, text {"a text node"}, "abc", "def", "ghi", 1, 2, text {"a text node"}, 3, xs:untypedAtomic("abc"), text {"a text node"}, xs:untypedAtomic("def"), xs:untypedAtomic("ghi"), xs:hexBinary("FF"), xs:untypedAtomic("abc"), xs:string("def"), xs:untypedAtomic("ghi"), "xs:string", "xs:string", xs:untypedAtomic("ghi"), "xs:string", "xs:string", xs:untypedAtomic("ghi"), "xs:string", text {"a text node"} }  } </e>
K2-DirectConElemAttr-76,Error: XPST0003: Unable to parse XPath: "         declare function local:t() { text{""}, text{"["}, text{"3"}, text{"]"}, text{""} };          declare variable $var := (text{""}, text{"["}, text{"3"}, text{"]"}, text{""});          <out fromFunction="{local:t()}" fromVariable="{$var}"/>       ". Expected "!", "!=", "#", "(", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", "}", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found.          declare function local:t() { text[Error is around here]{""}, text{"["}, text{"3"}, text{"]"}, text{""} };          declare variable $var := (text{""}, text{"["}, text{"3"}, text{"]"}, text{""});          <out fromFunction="{local:t()}" fromVariable="{$var}"/>
Constr-pi-content-2,Error: XPST0017: Function fn:data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
Constr-pi-content-4,Error: XPST0017: Function fn:data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
Constr-pi-content-6,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
Constr-pi-content-7,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
Constr-comment-2,Error: XPST0017: Function fn:data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
Constr-comment-4,Error: XPST0017: Function fn:data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
K2-DirectConOther-22,AssertionError: expected [Function] to throw an error
K2-DirectConOther-29,Error: XPST0003: Unable to parse XPath: "local-name(<?xmlSUFFIX content?>)". Expected [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�] or [�-�] but "?" found. local-name(<[Error is around here]?xmlSUFFIX content?>)
K2-DirectConOther-44,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
K2-DirectConOther-45,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
K2-DirectConOther-48,AssertionError: Expected executing the XPath "string(exactly-one(<e xml:id=" ab c d "/>/@*))" to resolve to one of the expected results, but got AssertionError: string(exactly-one(<e xml:id=" ab c d "/>/@*)): expected ' ab c d ' to equal 'ab c d', AssertionError: expected [Function] to throw an error.
K2-DirectConOther-66,Error: XPST0003: Unable to parse XPath: "declare namespace a="http://example.com/NotThis"; declare namespace g="http://example.com/NotThis2"; <a xmlns:a="http://example.com/NotThis" xmlns:b="http://example.com"> <b xmlns:a="http://example.com/" xmlns:c="http://example.com/c"> <c xmlns:d="http://example.com/d"/> { for $i in in-scope-prefixes(<e/>) order by $i return $i, "|", for $i in in-scope-prefixes(element e {()}) order by $i return $i } <d xmlns:e="http://example.com/d"/> </b> </a>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare namespace a="http://example.com/NotThis"; declare namespace g="http://example.com/NotThis2"; <a xmlns:a="http://example.com/NotThis" xmlns:b="http://example.com"> <b xmlns:a="http://example.com/" xmlns:c="http://example.com/c"> <c xmlns:d="http://example.com/d"/> { for $i in in-scope-prefixes(<e/>) [Error is around here]order by $i return $i, "|", for $i in in-scope-prefixes(element e {()}) order by $i return $i } <d xmlns:e="http://example.com/d"/> </b> </a>
K2-DirectConOther-67,Error: XPST0003: Unable to parse XPath: "<e xmlns="http://example.com/3">{namespace-uri-from-QName(node-name(<e/>)), namespace-uri-from-QName(node-name(element e2 {()}))}</e>". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found. <e xmlns="http://example.com/3">{namespace-uri-from-QName(node-name(<e/>)), namespace-uri-from-QName(node-name(element [Error is around here]e2 {()}))}</e>
K2-DirectConOther-70,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
K2-DirectConElem-34,Error: XPST0003: Unable to parse XPath: "<foo > {attribute name {"content"}} <doo/> </foo>". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found. <foo > {attribute [Error is around here]name {"content"}} <doo/> </foo>
K2-DirectConElem-35,AssertionError: expected [Function] to throw an error
K2-DirectConElem-36,AssertionError: expected [Function] to throw an error
K2-DirectConElem-37,AssertionError: expected [Function] to throw an error
K2-DirectConElem-39,AssertionError: expected [Function] to throw an error
K2-DirectConElem-40,AssertionError: expected [Function] to throw an error
K2-DirectConElem-41,AssertionError: expected [Function] to throw an error
K2-DirectConElem-42,Error: XPST0003: Unable to parse XPath: "<e> { document{()}/(/) } </e>". Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", "}", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. <e> { document[Error is around here]{()}/(/) } </e>
K2-DirectConElem-43,Error: XPST0003: Unable to parse XPath: "<e> { document{()} } </e>". Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", "}", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. <e> { document[Error is around here]{()} } </e>
K2-DirectConElem-45,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
K2-DirectConElem-51,AssertionError: Expected XPath <e xml:id=" fo"/> to resolve to the given XML. Expected <e xml:id=" fo"/> to equal <e xml:id="fo"/>
K2-DirectConElem-53a,Error: XPST0003: Unable to parse XPath: "(namespace {"p"} {"abc"}) instance of namespace-node()". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. (namespace [Error is around here]{"p"} {"abc"}) instance of namespace-node()
cbcl-directconelem-001,Error: XPST0003: Unable to parse XPath: "  declare default element namespace "http://example.com/0";  declare namespace a = "http://example.com/1";  declare namespace b = "http://example.com/2";  declare copy-namespaces preserve,no-inherit;  declare function local:in-scope-namespace-bindings($arg) {   for $i in in-scope-prefixes($arg)    order by $i    return    concat("xmlns",          if (string-length($i) = 0)          then ""          else ":",          $i,          '="', namespace-uri-for-prefix($i, $arg), '"') };  <a:outer b:outer="attr" xmlns:c="http://example.com/3" c:outer="attr">   <inner a="a:attr" b="b:attr" /> </a:outer>/(local:in-scope-namespace-bindings(.),             '|',              local:in-scope-namespace-bindings((./*)[1]))        ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.   declare default element namespace "http://example.com/0";  declare namespace a = "http://example.com/1";  declare namespace b = "http://example.com/2";  declare copy-namespaces preserve,no-inherit;  declare function local:in-scope-namespace-bindings($arg) {   for $i in in-scope-prefixes($arg)    [Error is around here]order by $i    return    concat("xmlns",          if (string-length($i) = 0)          then ""          else ":",          $i,          '="', namespace-uri-for-prefix($i, $arg), '"') };  <a:outer b:outer="attr" xmlns:c="http://example.com/3" c:outer="attr">   <inner a="a:attr" b="b:attr" /> </a:outer>/(local:in-scope-namespace-bindings(.),             '|',              local:in-scope-namespace-bindings((./*)[1]))
cbcl-directconelem-002,Error: XPST0003: Unable to parse XPath: "  declare default element namespace "http://example.com/0";  declare namespace a = "http://example.com/1";  declare namespace b = "http://example.com/2";  declare copy-namespaces preserve,inherit;  declare function local:in-scope-namespace-bindings($arg) {   for $i in in-scope-prefixes($arg)    order by $i    return    concat("xmlns",          if (string-length($i) = 0)          then ""          else ":",          $i,          '="', namespace-uri-for-prefix($i, $arg), '"') };  <a:outer b:outer="attr" xmlns:c="http://example.com/3" c:outer="attr">   <inner a="a:attr" b="b:attr" /> </a:outer>/(local:in-scope-namespace-bindings(.),             '|',              local:in-scope-namespace-bindings((./*)[1]))        ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.   declare default element namespace "http://example.com/0";  declare namespace a = "http://example.com/1";  declare namespace b = "http://example.com/2";  declare copy-namespaces preserve,inherit;  declare function local:in-scope-namespace-bindings($arg) {   for $i in in-scope-prefixes($arg)    [Error is around here]order by $i    return    concat("xmlns",          if (string-length($i) = 0)          then ""          else ":",          $i,          '="', namespace-uri-for-prefix($i, $arg), '"') };  <a:outer b:outer="attr" xmlns:c="http://example.com/3" c:outer="attr">   <inner a="a:attr" b="b:attr" /> </a:outer>/(local:in-scope-namespace-bindings(.),             '|',              local:in-scope-namespace-bindings((./*)[1]))
Constr-cont-eol-1,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
Constr-cont-eol-2,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
Constr-cont-eol-3,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
Constr-cont-eol-4,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
Constr-cont-entref-1,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
Constr-cont-entref-2,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
Constr-cont-entref-3,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
Constr-cont-entref-4,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
Constr-cont-entref-5,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
Constr-cont-constrmod-1,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-cont-constrmod-2,AssertionError: Expected executing the XPath "declare construction preserve; fn:count(fn:data(<elem>{//*:idrefs}</elem>/*))" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, Error: Not implemented: only module imports and function declarations are implemented in XQuery modules.
Constr-cont-constrmod-3,AssertionError: expected [Function] to throw error including 'FORG0001' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
Constr-cont-constrmod-4,AssertionError: Expected executing the XPath "declare construction preserve; <elem>{//*:decimal}</elem>/* cast as xs:integer" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'FORG0001' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
Constr-cont-constrmod-5,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-cont-constrmod-6,AssertionError: Expected executing the XPath "declare construction preserve; fn:count(fn:data((<elem>{//*:idrefs/@*:attr}</elem>)/@*:attr))" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, Error: Not implemented: only module imports and function declarations are implemented in XQuery modules.
Constr-cont-constrmod-7,AssertionError: expected [Function] to throw error including 'FORG0001' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
Constr-cont-constrmod-8,AssertionError: Expected executing the XPath "declare construction preserve; (<elem>{//*:decimal/@*:attr}</elem>)/@*:attr cast as xs:integer" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'FORG0001' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
Constr-cont-nsmode-1,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-cont-nsmode-2,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-cont-nsmode-3,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-cont-nsmode-4,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-cont-nsmode-5,AssertionError: Expected executing the XPath "declare copy-namespaces no-preserve, inherit; declare construction preserve; <new>{ //*:QName }</new>" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XQTY0086' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
Constr-cont-nsmode-6,AssertionError: Expected executing the XPath "declare copy-namespaces no-preserve, no-inherit; declare construction preserve; <new>{ //*:QName }</new>" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XQTY0086' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
Constr-cont-nsmode-7,AssertionError: expected [Function] to throw error including 'XQTY0086' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
Constr-cont-nsmode-8,AssertionError: expected [Function] to throw error including 'XQTY0086' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
Constr-cont-nsmode-9,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-cont-nsmode-10,AssertionError: expected [Function] to throw error including 'XQTY0086' but got 'XPST0003: Unable to parse XPath: "declare construction preserve; element { "new" } { //*:QName/@* }".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\ndeclare construction preserve; element [Error is around here]{ "new" } { //*:QName/@* }'
Constr-cont-uripres-1,Error: XPST0017: Function fn:base-uri with arity of 1 not registered. No similar functions found.
Constr-cont-doc-1,HierarchyRequestError: HierarchyRequestError: node must be a DocumentFragment, DocumentType, Element, Text, ProcessingInstruction or Comment node
Constr-cont-attr-1,AssertionError: expected [Function] to throw an error
Constr-cont-attr-2,AssertionError: expected [Function] to throw an error
Constr-cont-attr-4,AssertionError: expected [Function] to throw an error
Constr-cont-baseuri-1,Error: XPST0017: Function fn:base-uri with arity of 1 not registered. No similar functions found.
Constr-cont-baseuri-2,Error: XPST0017: Function fn:base-uri with arity of 1 not registered. No similar functions found.
Constr-cont-baseuri-3,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-cont-attr-7,AssertionError: expected [Function] to throw error including 'XQDY0025' but got 'XQST0040: The attribute mark is already present on a constructed element.'
Constr-cont-attr-8,AssertionError: expected [Function] to throw error including 'XQDY0025' but got 'XQST0040: The attribute mark is already present on a constructed element.'
Constr-cont-data-1,Error: XPST0017: Function fn:data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
Constr-cont-document-1,Error: XPST0003: Unable to parse XPath: "count(<wrapper> {'abc', document {'def', <anode/>, 'ghi'}, 'jkl'} </wrapper>/node()) = 3". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. count(<wrapper> {'abc', document [Error is around here]{'def', <anode/>, 'ghi'}, 'jkl'} </wrapper>/node()) = 3
Constr-cont-document-2,Error: XPST0003: Unable to parse XPath: "count(<wrapper> abc {document {'def', <anode/>, 'ghi'}} jkl </wrapper>/node()) = 3". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. count(<wrapper> abc {document [Error is around here]{'def', <anode/>, 'ghi'}} jkl </wrapper>/node()) = 3
Constr-cont-document-3,Error: XPST0003: Unable to parse XPath: "let $result := (         declare variable $codepoints as xs:integer+ := (9, 10, 13, 32 to 55295, 57344 to 65532, 65536 to 1114111 );          declare variable $count as xs:integer := count($codepoints);          declare variable $lineWidth as xs:integer := 70;         <allCodepoints><r>{codepoints-to-string($codepoints)}</r></allCodepoints>          (:<allCodepoints>{              for $i in (1 to $count idiv $lineWidth)              let $startOffset := (($i - 1) * $lineWidth) + 1              return (<r s="{$codepoints[$startOffset]}" e="{$codepoints[$startOffset] + $lineWidth}"> {                  codepoints-to-string(subsequence($codepoints, $startOffset, $lineWidth)) } </r>, "&#xA;")                  } </allCodepoints>:)         ) return sum($result//r/text()/string-length()) = count((9, 10, 13, 32 to 55295, 57344 to 65532, 65536 to 1114111 ))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. let $result := (         declare [Error is around here]variable $codepoints as xs:integer+ := (9, 10, 13, 32 to 55295, 57344 to 65532, 65536 to 1114111 );          declare variable $count as xs:integer := count($codepoints);          declare variable $lineWidth as xs:integer := 70;         <allCodepoints><r>{codepoints-to-string($codepoints)}</r></allCodepoints>          (:<allCodepoints>{              for $i in (1 to $count idiv $lineWidth)              let $startOffset := (($i - 1) * $lineWidth) + 1              return (<r s="{$codepoints[$startOffset]}" e="{$codepoints[$startOffset] + $lineWidth}"> {                  codepoints-to-string(subsequence($codepoints, $startOffset, $lineWidth)) } </r>, "&#xA;")                  } </allCodepoints>:)         ) return sum($result//r/text()/string-length()) = count((9, 10, 13, 32 to 55295, 57344 to 65532, 65536 to 1114111 ))
Constr-cont-document-4,Error: XPST0003: Unable to parse XPath: "count( document {'abc', 'def', document {'ghi', <anode/>, 'jkl'}, 'mno' } /node() ) = 3". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. count( document [Error is around here]{'abc', 'def', document {'ghi', <anode/>, 'jkl'}, 'mno' } /node() ) = 3
Constr-cont-document-5,Error: XPST0003: Unable to parse XPath: "count( document {'abc', 'def', document {'ghi', 'jkl'}, 'mno' } /node() ) = 1". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. count( document [Error is around here]{'abc', 'def', document {'ghi', 'jkl'}, 'mno' } /node() ) = 1
K2-DirectConElemContent-5,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
K2-DirectConElemContent-6,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
K2-DirectConElemContent-9,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
K2-DirectConElemContent-10,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
K2-DirectConElemContent-14,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
K2-DirectConElemContent-15,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
K2-DirectConElemContent-26,AssertionError: expected [Function] to throw an error
K2-DirectConElemContent-29,Error: XPST0003: Unable to parse XPath: "data(text{"content"}) instance of xs:untypedAtomic". Expected "!", "!=", "#", "(", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. data(text[Error is around here]{"content"}) instance of xs:untypedAtomic
K2-DirectConElemContent-32,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
K2-DirectConElemContent-33,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
K2-DirectConElemContent-34,Error: element() with more than 1 argument is not supported.
K2-DirectConElemContent-35,Error: element() with more than 1 argument is not supported.
K2-DirectConElemContent-35a,Error: element() with more than 1 argument is not supported.
K2-DirectConElemContent-35b,Error: element() with more than 1 argument is not supported.
K2-DirectConElemContent-36,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-DirectConElemContent-37,Error: element() with more than 1 argument is not supported.
K2-DirectConElemContent-38,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-DirectConElemContent-46,Error: XPST0003: Unable to parse XPath: "<e>{1}{text{()}}{2}</e>". Expected "!", "!=", "#", "(", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", "}", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. <e>{1}{text[Error is around here]{()}}{2}</e>
K2-DirectConElemContent-47,Error: XPST0003: Unable to parse XPath: "<e>{1}{text{""}}{2}</e>". Expected "!", "!=", "#", "(", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", "}", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. <e>{1}{text[Error is around here]{""}}{2}</e>
K2-DirectConElemContent-48,Error: XPST0003: Unable to parse XPath: "document{       	<e xmlns="http://www.example.com/"> <a xmlns=""/> </e>,        	<e xmlns="http://www.example.com/"> <a xmlns=""/> </e>/count(in-scope-prefixes(a)),        	<e xmlns="http://www.example.com/"> <a xmlns=""> <b xmlns=""/> </a> </e>       }". Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "{" found. document[Error is around here]{       	<e xmlns="http://www.example.com/"> <a xmlns=""/> </e>,        	<e xmlns="http://www.example.com/"> <a xmlns=""/> </e>/count(in-scope-prefixes(a)),        	<e xmlns="http://www.example.com/"> <a xmlns=""> <b xmlns=""/> </a> </e>       }
cbcl-ns-fixup-1,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
ElemContentArray-001,Error: Atomizing array(*) is not implemented.
ElemContentArray-002,Error: Atomizing array(*) is not implemented.
Constr-namespace-6,AssertionError: expected [Function] to throw an error
Constr-namespace-7,AssertionError: expected [Function] to throw an error
Constr-namespace-14,AssertionError: Expected executing the XPath "<foo:elem xmlns:foo="http://www.example.com/parent"><child xmlns:foo=""><foo:grand-child/></child></foo:elem>" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XPST0081' but got 'NamespaceError: Qualified name with prefix can not have a null namespace', AssertionError: expected [Function] to throw error including 'XQST0085' but got 'NamespaceError: Qualified name with prefix can not have a null namespace'.
Constr-namespace-15,AssertionError: Expected executing the XPath "declare namespace foo="http://www.example.com/prolog"; <elem xmlns:foo=""><foo:child/></elem>" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XPST0081' but got 'NamespaceError: Qualified name with prefix can not have a null namespace', AssertionError: expected [Function] to throw error including 'XQST0085' but got 'NamespaceError: Qualified name with prefix can not have a null namespace'.
Constr-namespace-19,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-namespace-21,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-DirectConElemNamespace-5,Error: XPST0017: Function in-scope-prefixes with arity of 1 not registered. No similar functions found.
K2-DirectConElemNamespace-6,Error: XPST0003: Unable to parse XPath: "count(in-scope-prefixes(element e{})[. eq "xml"]) = 1". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found. count(in-scope-prefixes(element [Error is around here]e{})[. eq "xml"]) = 1
K2-DirectConElemNamespace-7,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-DirectConElemNamespace-8,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-DirectConElemNamespace-9,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-DirectConElemNamespace-10,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-DirectConElemNamespace-11,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-DirectConElemNamespace-12,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-DirectConElemNamespace-13,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-DirectConElemNamespace-14,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-DirectConElemNamespace-19,Error: XPST0081: The type integer could not be found.
K2-DirectConElemNamespace-20,Error: XPST0003: Unable to parse XPath: "<e a="{1 treat as integer}" xmlns="http://www.w3.org/2001/XMLSchema"/>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "t" found. <e a="{1 [Error is around here]treat as integer}" xmlns="http://www.w3.org/2001/XMLSchema"/>
K2-DirectConElemNamespace-21,Error: XPST0081: Can not cast: type string is unknown.
K2-DirectConElemNamespace-22,AssertionError: Expected XPath <e a="{1 castable as string}" xmlns="http://www.w3.org/2001/XMLSchema"/> to resolve to the given XML. Expected <e xmlns="http://www.w3.org/2001/XMLSchema" a="false"/> to equal <e xmlns="http://www.w3.org/2001/XMLSchema" a="true"/>
K2-DirectConElemNamespace-29,Error: XPST0081: The type p:integer could not be found.
K2-DirectConElemNamespace-30,Error: XPST0003: Unable to parse XPath: "<e a="{1 treat as p:integer}" xmlns:p="http://www.w3.org/2001/XMLSchema"/>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "t" found. <e a="{1 [Error is around here]treat as p:integer}" xmlns:p="http://www.w3.org/2001/XMLSchema"/>
K2-DirectConElemNamespace-31,Error: XPST0081: Can not cast: type p:string is unknown.
K2-DirectConElemNamespace-32,AssertionError: Expected XPath <e a="{1 castable as p:string}" xmlns:p="http://www.w3.org/2001/XMLSchema"/> to resolve to the given XML. Expected <e a="false"/> to equal <e a="true"/>
K2-DirectConElemNamespace-33,Error: Not implemented: references to variables with a namespace URI or a prefix.
K2-DirectConElemNamespace-39,Error: XPST0003: Unable to parse XPath: "          declare namespace p = "http://example.com/";           document{<p:e xmlns=""/>, count(in-scope-prefixes(<p:e xmlns=""/>))}       ". Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "{" found.           declare namespace p = "http://example.com/";           document[Error is around here]{<p:e xmlns=""/>, count(in-scope-prefixes(<p:e xmlns=""/>))}
K2-DirectConElemNamespace-41,Error: XPST0003: Unable to parse XPath: "declare namespace p = "http://www.example.com/A"; "START", for $i in in-scope-prefixes(<e xmlns="http://www.example.com/A" xmlns:A="http://www.example.com/C"> <b xmlns:B="http://www.example.com/C" /> </e>/p:b) order by $i return $i, "END"". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare namespace p = "http://www.example.com/A"; "START", for $i in in-scope-prefixes(<e xmlns="http://www.example.com/A" xmlns:A="http://www.example.com/C"> <b xmlns:B="http://www.example.com/C" /> </e>/p:b) [Error is around here]order by $i return $i, "END"
K2-DirectConElemNamespace-49,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-DirectConElemNamespace-51,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-DirectConElemNamespace-52,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-DirectConElemNamespace-53,Error: XPST0017: Function in-scope-prefixes with arity of 1 not registered. No similar functions found.
K2-DirectConElemNamespace-55,Error: XPST0003: Unable to parse XPath: "<e xmlns="http://example.com/"> <b xmlns=""> { attribute {QName("http://example.com/2", "p:attr")} {()} } </b> </e>". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. <e xmlns="http://example.com/"> <b xmlns=""> { attribute [Error is around here]{QName("http://example.com/2", "p:attr")} {()} } </b> </e>
K2-DirectConElemNamespace-56,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-DirectConElemNamespace-57,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-DirectConElemNamespace-65,AssertionError: Expected executing the XPath "namespace-uri-for-prefix("p", <e xmlns:p="http://example.com/{{}}{{{{}}}}"/>)" to resolve to one of the expected results, but got Error: XPST0017: Function namespace-uri-for-prefix with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}namespace-uri-from-QName (xs:QName?)", "Q{http://www.w3.org/2005/xpath-functions}namespace-uri (node())" or "Q{http://www.w3.org/2005/xpath-functions}namespace-uri ()"?, AssertionError: expected [Function] to throw error including 'XQST0046' but got 'XPST0017: Function namespace-uri-for-prefix with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}namespace-uri-from-QName (xs:QName?)", "Q{http://www.w3.org/2005/xpath-functions}namespace-uri (node())" or "Q{http://www.w3.org/2005/xpath-functions}namespace-uri ()"?'.
K2-DirectConElemNamespace-78,Error: XPST0003: Unable to parse XPath: "let $e := document{(<X1:L xmlns:X1="http://example.com/URL1">1</X1:L>, <X2:L xmlns:X2="http://example.com/URL2">2</X2:L>)} return <outer xmlns:P="http://example.com/URL1"> { let $outer as element(P:L) := $e/element(P:L) return <inner xmlns:P="http://example.com/URL2"> { let $inner as element(P:L) := $e/element(P:L) return ($outer, $inner) } </inner> } </outer>". Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. let $e := document[Error is around here]{(<X1:L xmlns:X1="http://example.com/URL1">1</X1:L>, <X2:L xmlns:X2="http://example.com/URL2">2</X2:L>)} return <outer xmlns:P="http://example.com/URL1"> { let $outer as element(P:L) := $e/element(P:L) return <inner xmlns:P="http://example.com/URL2"> { let $inner as element(P:L) := $e/element(P:L) return ($outer, $inner) } </inner> } </outer>
K2-DirectConElemNamespace-79,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "let $e := document{(<X1:L xmlns:X1="http://ns.example.com/URL1">1</X1:L>, <X2:L xmlns:X2="http://ns.example.com/URL2">2</X2:L>)} return <outer xmlns:P="http://ns.example.com/URL1"> { let $outer as element(P:L) := $e/element(P:L) return <inner xmlns:P="http://ns.example.com/URL2"> { let $inner as element(P:L) := $outer return $inner } </inner> } </outer>".\nExpected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found.\nlet $e := document[Error is around here]{(<X1:L xmlns:X1="http://ns.example.com/URL1">1</X1:L>, <X2:L xmlns:X2="http://ns.example.com/URL2">2</X2:L>)} return <outer xmlns:P="http://ns.example.com/URL1"> { let $outer as element(P:L) := $e/element(P:L) return <inner xmlns:P="http://ns.example.com/URL2"> { let $inner as element(P:L) := $outer return $inner } </inner> } </outer>'
Constr-inscope-2,AssertionError: Expected XPath <new>{//@*:attr1, //@*:attr2}</new> to resolve to the given XML. Expected <new xmlns:foo="http://www.example.com/parent1" foo:attr1="attr1" xmlns:ns1="http://www.example.com/parent2" ns1:attr2="attr2"/> to equal <new xmlns:foo="http://www.example.com/parent1" foo:attr1="attr1" xmlns:XXX="http://www.example.com/parent2" XXX:attr2="attr2"/>
Constr-inscope-4,AssertionError: Expected XPath for $x in <inscope> <parent1 xmlns:foo="http://www.example.com/parent1" foo:attr1="attr1"/> <parent2 xmlns:foo="http://www.example.com/parent2" foo:attr2="attr2"/></inscope> return <new>{$x//@*:attr1, $x//@*:attr2}</new> to resolve to the given XML. Expected <new xmlns:foo="http://www.example.com/parent1" foo:attr1="attr1" xmlns:ns1="http://www.example.com/parent2" ns1:attr2="attr2"/> to equal <new xmlns:foo="http://www.example.com/parent1" foo:attr1="attr1" xmlns:XXX="http://www.example.com/parent2" XXX:attr2="attr2"/>
Constr-inscope-22,NamespaceError: NamespaceError: Qualified name with prefix can not have a null namespace
K2-ConInScopeNamespace-1,Error: XPST0003: Unable to parse XPath: "let $i := document{<e1/>, <e2/>, <e3/>, <e4/>} return (in-scope-prefixes($i/e1), in-scope-prefixes($i/e2), in-scope-prefixes($i/e3), in-scope-prefixes($i/e4))". Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. let $i := document[Error is around here]{<e1/>, <e2/>, <e3/>, <e4/>} return (in-scope-prefixes($i/e1), in-scope-prefixes($i/e2), in-scope-prefixes($i/e3), in-scope-prefixes($i/e4))
Constr-ws-tag-1,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-tag-2,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-tag-3,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-tag-4,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-tag-5,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-tag-6,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-tag-7,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-tag-8,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-tag-9,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-tag-10,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-enclexpr-1,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-enclexpr-2,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-enclexpr-3,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-enclexpr-4,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-enclexpr-5,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-enclexpr-6,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-enclexpr-7,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-enclexpr-8,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-enclexpr-9,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-enclexpr-10,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-enclexpr-11,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-enclexpr-12,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-enclexpr-13,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-enclexpr-14,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-enclexpr-15,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-enclexpr-16,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-enclexpr-17,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-enclexpr-18,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-enclexpr-19,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-enclexpr-20,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-enclexpr-21,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-enclexpr-22,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-enclexpr-23,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-enclexpr-24,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-nobound-1,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-nobound-2,Error: XPST0003: Unable to parse XPath: "let $result := ((: Name: Constr-ws-nobound-2 :) (: Written by: Andreas Behm :) (: Description: preserve leading line feed :)  declare boundary-space strip; <elem> x</elem>) return string-to-codepoints(string($result))[1] = 10". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "b" found. let $result := ((: Name: Constr-ws-nobound-2 :) (: Written by: Andreas Behm :) (: Description: preserve leading line feed :)  declare [Error is around here]boundary-space strip; <elem> x</elem>) return string-to-codepoints(string($result))[1] = 10
Constr-ws-nobound-3,Error: XPST0003: Unable to parse XPath: "let $result := ((: Name: Constr-ws-nobound-3 :) (: Written by: Andreas Behm :) (: Description: preserve leading tab :)  declare boundary-space strip; <elem>	x</elem>) return string-to-codepoints(string($result))[1] = 9". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "b" found. let $result := ((: Name: Constr-ws-nobound-3 :) (: Written by: Andreas Behm :) (: Description: preserve leading tab :)  declare [Error is around here]boundary-space strip; <elem>	x</elem>) return string-to-codepoints(string($result))[1] = 9
Constr-ws-nobound-4,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-nobound-5,Error: XPST0003: Unable to parse XPath: "let $result := ((: Name: Constr-ws-nobound-5 :) (: Written by: Andreas Behm :) (: Description: preserve trailing line feed :)  declare boundary-space strip; <elem>x </elem>) return deep-equal(string-to-codepoints(string($result)), (120, 10))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "b" found. let $result := ((: Name: Constr-ws-nobound-5 :) (: Written by: Andreas Behm :) (: Description: preserve trailing line feed :)  declare [Error is around here]boundary-space strip; <elem>x </elem>) return deep-equal(string-to-codepoints(string($result)), (120, 10))
Constr-ws-nobound-6,Error: XPST0003: Unable to parse XPath: "let $result := ((: Name: Constr-ws-nobound-6 :) (: Written by: Andreas Behm :) (: Description: preserve trailing tab :)  declare boundary-space strip; <elem>x	</elem>) return deep-equal(string-to-codepoints(string($result)), (120, 9))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "b" found. let $result := ((: Name: Constr-ws-nobound-6 :) (: Written by: Andreas Behm :) (: Description: preserve trailing tab :)  declare [Error is around here]boundary-space strip; <elem>x	</elem>) return deep-equal(string-to-codepoints(string($result)), (120, 9))
Constr-ws-genchref-1,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-genchref-2,Error: XPST0003: Unable to parse XPath: "let $result := (declare boundary-space strip; <elem>&#xA;</elem>) return deep-equal(string-to-codepoints(string($result)), (10))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "b" found. let $result := (declare [Error is around here]boundary-space strip; <elem>&#xA;</elem>) return deep-equal(string-to-codepoints(string($result)), (10))
Constr-ws-genchref-3,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-genchref-4,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-gencdata-1,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-gencdata-3,Error: XPST0003: Unable to parse XPath: "let $result := ((: Name: Constr-ws-gencdata-3 :) (: Written by: Andreas Behm :) (: Description: preserve cdata tab :)  declare boundary-space strip; <elem><![CDATA[	]]></elem>) return deep-equal(string-to-codepoints(string($result)), (9))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "b" found. let $result := ((: Name: Constr-ws-gencdata-3 :) (: Written by: Andreas Behm :) (: Description: preserve cdata tab :)  declare [Error is around here]boundary-space strip; <elem><![CDATA[	]]></elem>) return deep-equal(string-to-codepoints(string($result)), (9))
Constr-ws-adjchref-1,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-adjchref-2,Error: XPST0003: Unable to parse XPath: "let $result := ((: Name: Constr-ws-adjchref-2 :) (: Written by: Andreas Behm :) (: Description: preserve line feed adjacent to character reference :)  declare boundary-space strip; <elem> &#x30; </elem>) return deep-equal(string-to-codepoints(string($result)), (10, 48, 10))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "b" found. let $result := ((: Name: Constr-ws-adjchref-2 :) (: Written by: Andreas Behm :) (: Description: preserve line feed adjacent to character reference :)  declare [Error is around here]boundary-space strip; <elem> &#x30; </elem>) return deep-equal(string-to-codepoints(string($result)), (10, 48, 10))
Constr-ws-adjchref-3,Error: XPST0003: Unable to parse XPath: "let $result := ((: Name: Constr-ws-adjchref-3 :) (: Written by: Andreas Behm :) (: Description: preserve tab adjacent to character reference :)  declare boundary-space strip; <elem>	&#x30;	</elem>) return deep-equal(string-to-codepoints(string($result)), (9, 48, 9))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "b" found. let $result := ((: Name: Constr-ws-adjchref-3 :) (: Written by: Andreas Behm :) (: Description: preserve tab adjacent to character reference :)  declare [Error is around here]boundary-space strip; <elem>	&#x30;	</elem>) return deep-equal(string-to-codepoints(string($result)), (9, 48, 9))
Constr-ws-adjcdata-1,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-adjcdata-2,Error: XPST0003: Unable to parse XPath: "let $result := ((: Name: Constr-ws-adjcdata-2 :) (: Written by: Andreas Behm :) (: Description: preserve line feed adjacent to cdata section :)  declare boundary-space strip; <elem> <![CDATA[]]> </elem>) return deep-equal(string-to-codepoints(string($result)), (10, 10))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "b" found. let $result := ((: Name: Constr-ws-adjcdata-2 :) (: Written by: Andreas Behm :) (: Description: preserve line feed adjacent to cdata section :)  declare [Error is around here]boundary-space strip; <elem> <![CDATA[]]> </elem>) return deep-equal(string-to-codepoints(string($result)), (10, 10))
Constr-ws-adjcdata-3,Error: XPST0003: Unable to parse XPath: "let $result := ((: Name: Constr-ws-adjcdata-3 :) (: Written by: Andreas Behm :) (: Description: preserve tab adjacent to cdata section :)  declare boundary-space strip; <elem>	<![CDATA[]]>	</elem>) return deep-equal(string-to-codepoints(string($result)), (9, 9))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "b" found. let $result := ((: Name: Constr-ws-adjcdata-3 :) (: Written by: Andreas Behm :) (: Description: preserve tab adjacent to cdata section :)  declare [Error is around here]boundary-space strip; <elem>	<![CDATA[]]>	</elem>) return deep-equal(string-to-codepoints(string($result)), (9, 9))
Constr-ws-genenclexpr-1,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-genenclexpr-2,Error: XPST0003: Unable to parse XPath: "let $result := ((: Name: Constr-ws-genenclexpr-2 :) (: Written by: Andreas Behm :) (: Description: preserve enclosed exp line feed :)  declare boundary-space strip; <elem>{" "}</elem>) return deep-equal(string-to-codepoints(string($result)), (10))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "b" found. let $result := ((: Name: Constr-ws-genenclexpr-2 :) (: Written by: Andreas Behm :) (: Description: preserve enclosed exp line feed :)  declare [Error is around here]boundary-space strip; <elem>{" "}</elem>) return deep-equal(string-to-codepoints(string($result)), (10))
Constr-ws-genenclexpr-3,Error: XPST0003: Unable to parse XPath: "let $result := ((: Name: Constr-ws-genenclexpr-3 :) (: Written by: Andreas Behm :) (: Description: preserve enclosed exp tab :)  declare boundary-space strip; <elem>{"	"}</elem>) return deep-equal(string-to-codepoints(string($result)), (9))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "b" found. let $result := ((: Name: Constr-ws-genenclexpr-3 :) (: Written by: Andreas Behm :) (: Description: preserve enclosed exp tab :)  declare [Error is around here]boundary-space strip; <elem>{"	"}</elem>) return deep-equal(string-to-codepoints(string($result)), (9))
Constr-ws-xmlspace-1,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Constr-ws-xmlspace-2,AssertionError: Expected executing the XPath "declare boundary-space preserve; <elem xml:space="strip"> </elem>" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XQDY0092' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
K2-DirectConElemWhitespace-1,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-DirectConElemWhitespace-4,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-DirectConElemWhitespace-5,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-DirectConElemWhitespace-6,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-DirectConElemWhitespace-7,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-DirectConElemWhitespace-8,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
eqname-002,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
eqname-004,Error: XPST0081: The type Q{http://www.w3.org/2001/XMLSchema}integer could not be found.
eqname-005,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
eqname-006,Error: XPST0003: Unable to parse XPath: "(# Q{http://www.example.com/ns}pragma ignore me #) {<a/>}". Expected " ", "$", "'", "(", "(:", ")", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "#" found. ([Error is around here]# Q{http://www.example.com/ns}pragma ignore me #) {<a/>}
eqname-007,Error: XPST0003: Unable to parse XPath: "         declare decimal-format Q{http://www.example.com/ns}format grouping-separator="'";          <a xmlns:ex="http://www.example.com/ns">{format-number(1e9, "#'###'###'##0.00", 'ex:format')}</a>       ". Expected " ", "(:", ";", "\n", "\r", or "\t" but "g" found.          declare decimal-format Q{http://www.example.com/ns}format [Error is around here]grouping-separator="'";          <a xmlns:ex="http://www.example.com/ns">{format-number(1e9, "#'###'###'##0.00", 'ex:format')}</a>
eqname-008,AssertionError: Expected XPath <out>{ (<a xmlns:ex="http://www.example.com/ns"><ex:b>93.7</ex:b></a>) /Q{http://www&#x2e;example&#x2E;com/ns}b }</out> to resolve to the given XML. Expected <out/> to equal <out><ex:b xmlns:ex="http://www.example.com/ns">93.7</ex:b></out>
eqname-015,Error: Not implemented: references to variables with a namespace URI or a prefix.
eqname-017,AssertionError: Expected XPath string-join(<a foo="3" bar="5" xml:space="preserve"/> / @Q{http://www.w3.org/XML/1998/namespace}*, '.') to resolve to "preserve": expected false to be true
eqname-024,Error: Not implemented: references to variables with a namespace URI or a prefix.
eqname-029,Error: XPST0017: Function Q{http:&#x2F;&#x2F;www.w3.org&#x2F;2005&#x2F;xpath-functions&#x2F;math}pi with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/math}pi ()"?
eqname-030,Error: Not implemented: references to variables with a namespace URI or a prefix.
eqname-031,Error: Not implemented: references to variables with a namespace URI or a prefix.
eqname-032,Error: Not implemented: references to variables with a namespace URI or a prefix.
eqname-033,Error: Not implemented: references to variables with a namespace URI or a prefix.
eqname-034,AssertionError: Expected executing the XPath "          let $Q{$Q}a := 12, $Q{//}a := 13, $Q{*}a := 14          return $Q{$Q}a + $Q{//}a + $Q{*}a       " to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0046' but got 'Not implemented: references to variables with a namespace URI or a prefix.', Error: Not implemented: references to variables with a namespace URI or a prefix..
eqname-910,AssertionError: expected [Function] to throw an error
eqname-913,AssertionError: expected [Function] to throw an error
ForExpr006,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
ForExpr008,Error: XPST0003: Unable to parse XPath: "for $AaBbCc.-_Dd in /MyComputer/Drive1/Folder where $AaBbCc.-_Dd/@creator = "Mani" return $AaBbCc.-_Dd/FolderName". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found. for $AaBbCc.-_Dd in /MyComputer/Drive1/Folder [Error is around here]where $AaBbCc.-_Dd/@creator = "Mani" return $AaBbCc.-_Dd/FolderName
ForExpr010,Error: XPST0003: Unable to parse XPath: "for $folder in //Folder for $file in $folder//File return <File folder="{$folder/FolderName}">{string($file/FileName[1])}</File>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found. for $folder in //Folder [Error is around here]for $file in $folder//File return <File folder="{$folder/FolderName}">{string($file/FileName[1])}</File>
ForExpr022,Error: XPST0003: Unable to parse XPath: "for $file at $pos in (//Folder)[1]/File return (string($file/FileName[1]), $pos)". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. for $file [Error is around here]at $pos in (//Folder)[1]/File return (string($file/FileName[1]), $pos)
ForExpr023,Error: XPST0003: Unable to parse XPath: "for $file at $pos in (//Folder)[1]/File, $pos2 in $pos+1 return (string($file/FileName[1]), $pos, $pos2)". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. for $file [Error is around here]at $pos in (//Folder)[1]/File, $pos2 in $pos+1 return (string($file/FileName[1]), $pos, $pos2)
ForExpr024,AssertionError: expected [Function] to throw error including 'XQST0089' but got 'XPST0003: Unable to parse XPath: "for $file at $file in (//Folder)[1]/File return (string($file/FileName[1]), $file)".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\nfor $file [Error is around here]at $file in (//Folder)[1]/File return (string($file/FileName[1]), $file)'
ForExpr029,Error: XPST0003: Unable to parse XPath: "for $var in (1,2) for $var in (2,2) return $var * $var". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found. for $var in (1,2) [Error is around here]for $var in (2,2) return $var * $var
ForExpr031,AssertionError: expected [Function] to throw error including 'XQST0089' but got 'XPST0003: Unable to parse XPath: "for $var at $var in (1, 2) return $var * $var".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\nfor $var [Error is around here]at $var in (1, 2) return $var * $var'
ForExpr032,Error: XPST0003: Unable to parse XPath: "          declare variable $j external := 1;          for $x at $i in (2, 3)          where $i = $j          return $x        = 2". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.           declare variable $j external := 1;          for $x [Error is around here]at $i in (2, 3)          where $i = $j          return $x        = 2
K-ForExprWithout-24,Error: Not implemented: references to variables with a namespace URI or a prefix.
K-ForExprWithout-25,Error: Not implemented: references to variables with a namespace URI or a prefix.
K-ForExprWithout-27,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'Not implemented: references to variables with a namespace URI or a prefix.'
K-ForExprWithout-28,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'Not implemented: references to variables with a namespace URI or a prefix.'
K-ForExprWithout-30,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'Not implemented: references to variables with a namespace URI or a prefix.'
K-ForExprWithout-31,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'Not implemented: references to variables with a namespace URI or a prefix.'
K-ForExprWithout-33,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'Not implemented: references to variables with a namespace URI or a prefix.'
K-ForExprWithout-34,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'Not implemented: references to variables with a namespace URI or a prefix.'
K-ForExprWithout-51,Error: Not implemented: references to variables with a namespace URI or a prefix.
K-ForExprWithout-52,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K-ForExprWithout-53,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K-ForExprWithout-54,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-ForExprWithout-4,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: "declare function local:myFunc() { for $i at $p in (1, 2, 3) return position() }; local:myFunc()".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\ndeclare function local:myFunc() { for $i [Error is around here]at $p in (1, 2, 3) return position() }; local:myFunc()'
K2-ForExprWithout-5,AssertionError: Expected executing the XPath "declare function local:myFunc() { for $i at $p in (1, 2, 3) return position() }; 1" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "declare function local:myFunc() { for $i at $p in (1, 2, 3) return position() }; 1 = 1". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. declare function local:myFunc() { for $i [Error is around here]at $p in (1, 2, 3) return position() }; 1 = 1, AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: "declare function local:myFunc() { for $i at $p in (1, 2, 3) return position() }; 1".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\ndeclare function local:myFunc() { for $i [Error is around here]at $p in (1, 2, 3) return position() }; 1'.
K2-ForExprWithout-8,Error: XPST0003: Unable to parse XPath: "(for $d in <people> <person id="person0"> <name>First</name> </person> <person> <name>Second</name> </person> </people>/person return if (some $id in 1 satisfies typeswitch ($d/@id) case $n as node() return $d/@id = "person0" default $d return ()) then $d/name else ())". Expected "!", "!=", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "(" found. (for $d in <people> <person id="person0"> <name>First</name> </person> <person> <name>Second</name> </person> </people>/person return if (some $id in 1 satisfies typeswitch [Error is around here]($d/@id) case $n as node() return $d/@id = "person0" default $d return ()) then $d/name else ())
K2-ForExprWithout-9,Error: XPST0003: Unable to parse XPath: "for $a at $pos1 in (1, 2, 3) return for $b at $pos2 in (4, 5, 6) return for $c at $pos3 in (7, 8, 9) return ($a, $pos1, $b, $pos2, $c, $pos2)". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. for $a [Error is around here]at $pos1 in (1, 2, 3) return for $b at $pos2 in (4, 5, 6) return for $c at $pos3 in (7, 8, 9) return ($a, $pos1, $b, $pos2, $c, $pos2)
K2-ForExprWithout-10,AssertionError: Expected executing the XPath "         for $a in (3, 2, 1)          for $b in (6, 5, 4)          let $c := $a + $b          let $d := $a - $b          let $e := () stable order by $a ascending, $b descending, $d empty greatest, $e empty least, $c descending empty greatest, $d ascending empty greatest, $e descending empty least, $b ascending empty least          return $a" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "         for $a in (3, 2, 1)          for $b in (6, 5, 4)          let $c := $a + $b          let $d := $a - $b          let $e := () stable order by $a ascending, $b descending, $d empty greatest, $e empty least, $c descending empty greatest, $d ascending empty greatest, $e descending empty least, $b ascending empty least          return $a". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found.          for $a in (3, 2, 1)          [Error is around here]for $b in (6, 5, 4)          let $c := $a + $b          let $d := $a - $b          let $e := () stable order by $a ascending, $b descending, $d empty greatest, $e empty least, $c descending empty greatest, $d ascending empty greatest, $e descending empty least, $b ascending empty least          return $a, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "\n        for $a in (3, 2, 1) \n        for $b in (6, 5, 4) \n        let $c := $a + $b \n        let $d := $a - $b \n        let $e := () stable order by $a ascending, $b descending, $d empty greatest, $e empty least, $c descending empty greatest, $d ascending empty greatest, $e descending empty least, $b ascending empty least \n        return $a".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found.\n\n        for $a in (3, 2, 1) \n        [Error is around here]for $b in (6, 5, 4) \n        let $c := $a + $b \n        let $d := $a - $b \n        let $e := () stable order by $a ascending, $b descending, $d empty greatest, $e empty least, $c descending empty greatest, $d ascending empty greatest, $e descending empty least, $b ascending empty least \n        return $a'.
K2-ForExprWithout-11,Error: XPST0003: Unable to parse XPath: "for $a in (3, 2, 1, 1) stable order by $a return 5". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found. for $a in (3, 2, 1, 1) [Error is around here]stable order by $a return 5
K2-ForExprWithout-12,Error: XPST0003: Unable to parse XPath: "for $a in (3, 2, 1, 1) stable order by 1 return $a". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found. for $a in (3, 2, 1, 1) [Error is around here]stable order by 1 return $a
K2-ForExprWithout-42,Error: XPST0003: Unable to parse XPath: "for $n in attribute return {()} return 1 = 1". Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "{" found. for $n in attribute return [Error is around here]{()} return 1 = 1
K2-ForExprWithout-43,Error: XPST0003: Unable to parse XPath: "for $n in element return {()} return 1 = 1". Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "{" found. for $n in element return [Error is around here]{()} return 1 = 1
K2-ForExprWithout-44,Error: XPST0003: Unable to parse XPath: "for $n in processing-instruction return {()} return 1 = 1". Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "{" found. for $n in processing-instruction return [Error is around here]{()} return 1 = 1
ForExprType001,Error: XPST0003: Unable to parse XPath: "for $file as element(File,xs:untyped) in (//Folder)[1]/File return $file/FileName". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. for $file [Error is around here]as element(File,xs:untyped) in (//Folder)[1]/File return $file/FileName
ForExprType002,Error: XPST0003: Unable to parse XPath: "for $fileName as attribute(name,xs:untypedAtomic) in (//Folder)[1]/File/@name return data($fileName)". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. for $fileName [Error is around here]as attribute(name,xs:untypedAtomic) in (//Folder)[1]/File/@name return data($fileName)
ForExprType003,Error: XPST0003: Unable to parse XPath: "for $PI as processing-instruction() in //processing-instruction() return $PI". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. for $PI [Error is around here]as processing-instruction() in //processing-instruction() return $PI
ForExprType004,Error: XPST0003: Unable to parse XPath: "for $comment as comment() in //comment() return $comment". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. for $comment [Error is around here]as comment() in //comment() return $comment
ForExprType005,Error: XPST0003: Unable to parse XPath: "for $int as xs:int in (xs:int(1), xs:int(2)) return $int". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. for $int [Error is around here]as xs:int in (xs:int(1), xs:int(2)) return $int
ForExprType006,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "for $int as xs:string in (xs:int(1), xs:int(2)) return $int".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\nfor $int [Error is around here]as xs:string in (xs:int(1), xs:int(2)) return $int'
ForExprType009,AssertionError: Expected executing the XPath "         declare namespace xqt="http://www.w3.org/XQueryTestOrderBy";          for $num as element(xqt:NegativeNumbers) in /xqt:DataValues/xqt:NegativeNumbers return $num" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "         declare namespace xqt="http://www.w3.org/XQueryTestOrderBy";          for $num as element(xqt:NegativeNumbers) in /xqt:DataValues/xqt:NegativeNumbers return $num". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.          declare namespace xqt="http://www.w3.org/XQueryTestOrderBy";          for $num [Error is around here]as element(xqt:NegativeNumbers) in /xqt:DataValues/xqt:NegativeNumbers return $num, Error: XPST0003: Unable to parse XPath: "         declare namespace xqt="http://www.w3.org/XQueryTestOrderBy";          for $num as element(xqt:NegativeNumbers) in /xqt:DataValues/xqt:NegativeNumbers return $num". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.          declare namespace xqt="http://www.w3.org/XQueryTestOrderBy";          for $num [Error is around here]as element(xqt:NegativeNumbers) in /xqt:DataValues/xqt:NegativeNumbers return $num.
ForExprType011,AssertionError: expected [Function] to throw error including 'XPST0051' but got 'XPST0003: Unable to parse XPath: "\n        declare namespace xqt="http://www.w3.org/XQueryTestOrderBy"; \n        for $num as xs:undefinedType in data( /xqt:DataValues/xqt:NegativeNumbers/xqt:orderData ) return $num".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\n\n        declare namespace xqt="http://www.w3.org/XQueryTestOrderBy"; \n        for $num [Error is around here]as xs:undefinedType in data( /xqt:DataValues/xqt:NegativeNumbers/xqt:orderData ) return $num'
ForExprType014,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "\n        declare namespace xqt="http://www.w3.org/XQueryTestOrderBy"; \n        for $num as empty-sequence() in data( /xqt:DataValues/xqt:NegativeNumbers/xqt:orderData ) return $num".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\n\n        declare namespace xqt="http://www.w3.org/XQueryTestOrderBy"; \n        for $num [Error is around here]as empty-sequence() in data( /xqt:DataValues/xqt:NegativeNumbers/xqt:orderData ) return $num'
ForExprType015,Error: XPST0003: Unable to parse XPath: "for $num as xs:decimal in (xs:integer(1), xs:integer(2), xs:integer(3)) return $num". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. for $num [Error is around here]as xs:decimal in (xs:integer(1), xs:integer(2), xs:integer(3)) return $num
ForExprType016,Error: XPST0003: Unable to parse XPath: "for $num as xs:decimal in (xs:integer(1), xs:decimal(2), xs:integer(3)) return $num". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. for $num [Error is around here]as xs:decimal in (xs:integer(1), xs:decimal(2), xs:integer(3)) return $num
ForExprType017,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "for $num as xs:double in (xs:int("1"), xs:integer("2"), xs:string("3")) return $num".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\nfor $num [Error is around here]as xs:double in (xs:int("1"), xs:integer("2"), xs:string("3")) return $num'
ForExprType018,Error: XPST0003: Unable to parse XPath: "for $file as node() in (//Folder)[1]/File return $file/FileName". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. for $file [Error is around here]as node() in (//Folder)[1]/File return $file/FileName
ForExprType019,Error: XPST0003: Unable to parse XPath: "for $fileName as text() in (//Folder)[1]/File/FileName/text() return string( $fileName )". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. for $fileName [Error is around here]as text() in (//Folder)[1]/File/FileName/text() return string( $fileName )
ForExprType020,Error: XPST0003: Unable to parse XPath: "for $fileName as item() in data( (//Folder)[1]/File/FileName ) return $fileName". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. for $fileName [Error is around here]as item() in data( (//Folder)[1]/File/FileName ) return $fileName
ForExprType021,Error: XPST0003: Unable to parse XPath: "for $doc as document-node() in (/) return count( $doc ) = 1". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. for $doc [Error is around here]as document-node() in (/) return count( $doc ) = 1
ForExprType022,Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.example.com/typedecl";          for $test as attribute(*) in ( /root/InterleaveType2/@integer, /root/InterleaveType2/@decimal )          return data( $test )       ". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.          declare default element namespace "http://www.example.com/typedecl";          for $test [Error is around here]as attribute(*) in ( /root/InterleaveType2/@integer, /root/InterleaveType2/@decimal )          return data( $test )
ForExprType023,Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.example.com/typedecl";          for $test as attribute(integer) in ( /root/InterleaveType2/@integer ) return data( $test )       ". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.          declare default element namespace "http://www.example.com/typedecl";          for $test [Error is around here]as attribute(integer) in ( /root/InterleaveType2/@integer ) return data( $test )
ForExprType024,Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.example.com/typedecl";          for $test as attribute(att, xs:anySimpleType) in /root/anyAtomicType/@att return data( $test )       ". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.          declare default element namespace "http://www.example.com/typedecl";          for $test [Error is around here]as attribute(att, xs:anySimpleType) in /root/anyAtomicType/@att return data( $test )
ForExprType028,Error: XPST0003: Unable to parse XPath: "         for $test as xs:integer in ( xs:byte("1"), xs:long("10000"), xs:negativeInteger("-10"),                          xs:short("100"), xs:positiveInteger("100"), xs:nonNegativeInteger("100") )          return $test       ". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.          for $test [Error is around here]as xs:integer in ( xs:byte("1"), xs:long("10000"), xs:negativeInteger("-10"),                          xs:short("100"), xs:positiveInteger("100"), xs:nonNegativeInteger("100") )          return $test
ForExprType029,Error: XPST0003: Unable to parse XPath: "         for $test as xs:decimal in ( xs:integer("100"), xs:short("1"), xs:int("10000"),                  xs:nonPositiveInteger("-10"), xs:unsignedShort("100"), xs:positiveInteger("100"), xs:nonNegativeInteger("100") )          return $test       ". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.          for $test [Error is around here]as xs:decimal in ( xs:integer("100"), xs:short("1"), xs:int("10000"),                  xs:nonPositiveInteger("-10"), xs:unsignedShort("100"), xs:positiveInteger("100"), xs:nonNegativeInteger("100") )          return $test
ForExprType030,Error: XPST0003: Unable to parse XPath: "         for $test as xs:normalizedString in ( xs:language("en-US"), xs:NCName("foobar"),              xs:NMTOKEN("token1"), xs:ENTITY("entity1") )          return $test       ". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.          for $test [Error is around here]as xs:normalizedString in ( xs:language("en-US"), xs:NCName("foobar"),              xs:NMTOKEN("token1"), xs:ENTITY("entity1") )          return $test
ForExprType031,Error: XPST0003: Unable to parse XPath: "         for $test as xs:anyAtomicType in ( xs:duration("P0Y1347M0D"), xs:dateTime("1999-05-31T13:20:00-05:00"),                      xs:time("13:00:00-05:00"), xs:date("1999-05-10Z"), xs:gYearMonth("2002-03"), xs:gYear("1999"),                      xs:gMonthDay("--05-10"), xs:gDay("---10"), xs:gMonth("--05") )          return $test       ". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.          for $test [Error is around here]as xs:anyAtomicType in ( xs:duration("P0Y1347M0D"), xs:dateTime("1999-05-31T13:20:00-05:00"),                      xs:time("13:00:00-05:00"), xs:date("1999-05-10Z"), xs:gYearMonth("2002-03"), xs:gYear("1999"),                      xs:gMonthDay("--05-10"), xs:gDay("---10"), xs:gMonth("--05") )          return $test
ForExprType032,Error: XPST0003: Unable to parse XPath: "         for $test as xs:anyAtomicType in ( xs:boolean("true"), xs:base64Binary("abcd"), xs:hexBinary("1234"),                      xs:float("5.7"), xs:double("7.5"), xs:anyURI("http://foo") )          return $test       ". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.          for $test [Error is around here]as xs:anyAtomicType in ( xs:boolean("true"), xs:base64Binary("abcd"), xs:hexBinary("1234"),                      xs:float("5.7"), xs:double("7.5"), xs:anyURI("http://foo") )          return $test
ForExprType033,Error: XPST0003: Unable to parse XPath: "         for $test as xs:anyAtomicType in ( xs:unsignedByte("10"), xs:short("20"), xs:positiveInteger("30"),                  xs:nonPositiveInteger("-40"), xs:decimal("5.5"), xs:ENTITY("entity1"), xs:NCName("foobar"),                  xs:language("en-US"), xs:string("foobar"), xs:hexBinary("ffff"), xs:gYear("1999") )          return $test       ". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.          for $test [Error is around here]as xs:anyAtomicType in ( xs:unsignedByte("10"), xs:short("20"), xs:positiveInteger("30"),                  xs:nonPositiveInteger("-40"), xs:decimal("5.5"), xs:ENTITY("entity1"), xs:NCName("foobar"),                  xs:language("en-US"), xs:string("foobar"), xs:hexBinary("ffff"), xs:gYear("1999") )          return $test
ForExprType034,Error: XPST0003: Unable to parse XPath: "for $test as xs:decimal in ( 1, 0.3 ) return $test". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. for $test [Error is around here]as xs:decimal in ( 1, 0.3 ) return $test
ForExprType035,Error: XPST0003: Unable to parse XPath: "for $test as xs:anyAtomicType in ( 1, "string", 1e2, 0.3 ) return $test". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. for $test [Error is around here]as xs:anyAtomicType in ( 1, "string", 1e2, 0.3 ) return $test
ForExprType036,Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.example.com/typedecl";          for $test as element(*) in /root/InterleaveType/* return $test       ". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.          declare default element namespace "http://www.example.com/typedecl";          for $test [Error is around here]as element(*) in /root/InterleaveType/* return $test
ForExprType045,AssertionError: expected [Function] to throw error including 'XPST0051' but got 'XPST0003: Unable to parse XPath: "for $test as xs:unknownType in ( 1, 2, 3) return $test".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\nfor $test [Error is around here]as xs:unknownType in ( 1, 2, 3) return $test'
ForExprType046,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "for $test as xs:double in ( 1, 1e2, 0.3 ) return $test".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\nfor $test [Error is around here]as xs:double in ( 1, 1e2, 0.3 ) return $test'
ForExprType047,AssertionError: expected [Function] to throw error including 'XPST0051' but got 'XPST0003: Unable to parse XPath: "for $test as xs:NMTOKENS in ( xs:NMTOKEN("ab"), xs:NMTOKEN("cd") ) return $test".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\nfor $test [Error is around here]as xs:NMTOKENS in ( xs:NMTOKEN("ab"), xs:NMTOKEN("cd") ) return $test'
ForExprType054,Error: XPST0003: Unable to parse XPath: "         declare namespace fs="http://www.example.com/filesystem";          for $test as item() in data( (//fs:Folder)[1]/fs:File/fs:FileName ) return $test       ". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.          declare namespace fs="http://www.example.com/filesystem";          for $test [Error is around here]as item() in data( (//fs:Folder)[1]/fs:File/fs:FileName ) return $test
ForExprType055,Error: XPST0003: Unable to parse XPath: "         declare namespace fs="http://www.example.com/filesystem";          for $test as node() in (//fs:Folder)[1]/fs:File return $test/fs:FileName       ". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.          declare namespace fs="http://www.example.com/filesystem";          for $test [Error is around here]as node() in (//fs:Folder)[1]/fs:File return $test/fs:FileName
ForExprType056,Error: XPST0003: Unable to parse XPath: "         declare namespace fs="http://www.example.com/filesystem";          for $test as document-node() in (/) return ($test//fs:Folder)[1]/fs:FolderName       ". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.          declare namespace fs="http://www.example.com/filesystem";          for $test [Error is around here]as document-node() in (/) return ($test//fs:Folder)[1]/fs:FolderName
ForExprType057,Error: XPST0003: Unable to parse XPath: "         declare namespace fs="http://www.example.com/filesystem";          document{for $test as text() in (//fs:Folder)[1]/fs:File/fs:FileName/text() return $test}       ". Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "{" found.          declare namespace fs="http://www.example.com/filesystem";          document[Error is around here]{for $test as text() in (//fs:Folder)[1]/fs:File/fs:FileName/text() return $test}
ForExprType058,Error: XPST0003: Unable to parse XPath: "         declare namespace fs="http://www.example.com/filesystem";          document{for $test as comment() in (//fs:Folder)[1]/comment() return $test}       ". Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "{" found.          declare namespace fs="http://www.example.com/filesystem";          document[Error is around here]{for $test as comment() in (//fs:Folder)[1]/comment() return $test}
ForExprType059,Error: XPST0003: Unable to parse XPath: "         declare namespace fs="http://www.example.com/filesystem";          for $test as processing-instruction() in (//fs:Folder)[1]//processing-instruction() return $test       ". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.          declare namespace fs="http://www.example.com/filesystem";          for $test [Error is around here]as processing-instruction() in (//fs:Folder)[1]//processing-instruction() return $test
ForExprType060,Error: XPST0003: Unable to parse XPath: "declare namespace fs="http://www.example.com/filesystem"; for $test as processing-instruction() in (//fs:Folder)[1]//processing-instruction() return $test". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. declare namespace fs="http://www.example.com/filesystem"; for $test [Error is around here]as processing-instruction() in (//fs:Folder)[1]//processing-instruction() return $test
ForExprType061,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "\n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test as processing-instruction("unknown") in (//fs:Folder)[1]//processing-instruction() return $test\n      ".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\n\n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test [Error is around here]as processing-instruction("unknown") in (//fs:Folder)[1]//processing-instruction() return $test\n      '
ForExprType062,Error: XPST0003: Unable to parse XPath: "         declare namespace fs="http://www.example.com/filesystem";          for $test as item() in (//fs:Folder)[1]/fs:File/fs:FileName return $test       ". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.          declare namespace fs="http://www.example.com/filesystem";          for $test [Error is around here]as item() in (//fs:Folder)[1]/fs:File/fs:FileName return $test
ForExprType063,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "\n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test as node() in data( (//fs:Folder)[1]/fs:File/fs:FileName ) return $test\n      ".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\n\n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test [Error is around here]as node() in data( (//fs:Folder)[1]/fs:File/fs:FileName ) return $test\n      '
ForExprType064,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "\n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test as text() in (//fs:Folder)[1]/fs:File/fs:FileName return $test\n      ".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\n\n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test [Error is around here]as text() in (//fs:Folder)[1]/fs:File/fs:FileName return $test\n      '
ForExprType065,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "\n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test as text() in data( (//fs:Folder)[1]/fs:File/fs:FileName ) return $test\n      ".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\n\n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test [Error is around here]as text() in data( (//fs:Folder)[1]/fs:File/fs:FileName ) return $test\n      '
ForExprType066,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "\n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test as comment() in (//fs:Folder)[1]/fs:File/fs:FileName return $test\n      ".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\n\n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test [Error is around here]as comment() in (//fs:Folder)[1]/fs:File/fs:FileName return $test\n      '
ForExprType067,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "\n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test as comment() in data( (//fs:Folder)[1]/fs:File/fs:FileName ) return $test\n      ".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\n\n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test [Error is around here]as comment() in data( (//fs:Folder)[1]/fs:File/fs:FileName ) return $test\n      '
ForExprType068,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "\n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test as processing-instruction() in (//fs:Folder)[1]/fs:File/fs:FileName return $test\n      ".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\n\n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test [Error is around here]as processing-instruction() in (//fs:Folder)[1]/fs:File/fs:FileName return $test\n      '
ForExprType069,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "\n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test as processing-instruction() in data( (//fs:Folder)[1]/fs:File/fs:FileName ) return $test\n      ".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\n\n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test [Error is around here]as processing-instruction() in data( (//fs:Folder)[1]/fs:File/fs:FileName ) return $test\n      '
ForExprType070,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "\n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test as processing-instruction("foo") in (//fs:Folder)[1]/fs:File/fs:FileName return $test\n      ".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\n\n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test [Error is around here]as processing-instruction("foo") in (//fs:Folder)[1]/fs:File/fs:FileName return $test\n      '
ForExprType071,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "\n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test as processing-instruction("foo") in data( (//fs:Folder)[1]/fs:File/fs:FileName ) return $test\n      ".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\n\n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test [Error is around here]as processing-instruction("foo") in data( (//fs:Folder)[1]/fs:File/fs:FileName ) return $test\n      '
ForExprType072,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "\n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test as document-node() in (//fs:Folder)[1]/fs:File/fs:FileName return $test\n      ".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\n\n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test [Error is around here]as document-node() in (//fs:Folder)[1]/fs:File/fs:FileName return $test\n      '
ForExprType073,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "\n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test as document-node() in data( (//fs:Folder)[1]/fs:File/fs:FileName ) return $test\n      ".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\n\n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test [Error is around here]as document-node() in data( (//fs:Folder)[1]/fs:File/fs:FileName ) return $test\n      '
K2-ForExprWith-1,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "for $i as xs:string in xs:untypedAtomic("input") return $i".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\nfor $i [Error is around here]as xs:string in xs:untypedAtomic("input") return $i'
FunctionCall-009,Error: XPST0003: Unable to parse XPath: "(         declare function local:f($in as xs:decimal*) as xs:decimal {sum($in, 0.0)};         local:f(xs:NMTOKENS('1 1.2 1.3 1.4')!xs:untypedAtomic(.))       ) instance of xs:decimal". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found. (         declare [Error is around here]function local:f($in as xs:decimal*) as xs:decimal {sum($in, 0.0)};         local:f(xs:NMTOKENS('1 1.2 1.3 1.4')!xs:untypedAtomic(.))       ) instance of xs:decimal
FunctionCall-010,Error: XPST0081: Can not cast: type xs:NMTOKENS is unknown.
FunctionCall-011,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
FunctionCall-012,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.'
FunctionCall-013,Error: XPST0003: Unable to parse XPath: "(         declare function local:f($a as xs:integer, $b as xs:integer) as xs:integer {           data(<a>{$a}{$b}</a>)         };         local:f(12, 34)       ) instance of xs:integer". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found. (         declare [Error is around here]function local:f($a as xs:integer, $b as xs:integer) as xs:integer {           data(<a>{$a}{$b}</a>)         };         local:f(12, 34)       ) instance of xs:integer
FunctionCall-014,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
FunctionCall-022,Error: XPST0003: Unable to parse XPath: "deep-equal((          declare function local:unique($in as xs:integer*) as xs:boolean { count($in) = count(distinct-values($in)) };          (local:unique([1,2,3,4,5]), local:unique([1,2,3,4,4]))), (true(), false()))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found. deep-equal((          declare [Error is around here]function local:unique($in as xs:integer*) as xs:boolean { count($in) = count(distinct-values($in)) };          (local:unique([1,2,3,4,5]), local:unique([1,2,3,4,4]))), (true(), false()))
FunctionCall-027,AssertionError: expected [Function] to throw error including 'XPST0051' but got 'XPST0081: Can not cast: type xs:NMTOKENS is unknown.'
FunctionCall-044,AssertionError: expected [Function] to throw an error
FunctionCall-048,AssertionError: expected [Function] to throw an error
K-FunctionCallExpr-5,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPST0017: Function prefix-does-not-exist:func-does-not-exist with arity of 3 not registered. No similar functions found.'
K-FunctionCallExpr-15a,Error: XPST0017: Function format-number with arity of 2 not registered. No similar functions found.
K-FunctionCallExpr-16a,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
K-FunctionCallExpr-17a,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
K-FunctionCallExpr-25a,Error: XPST0017: Function generate-id with arity of 1 not registered. No similar functions found.
K2-FunctionCallExpr-10,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-FunctionCallExpr-11,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
K2-FunctionCallExpr-12,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
cbcl-promotion-002,Error: XPST0003: Unable to parse XPath: "         declare function local:index-of($seq as xs:double*, $item as xs:double) { for $x at $p in $seq return if ($x eq $item) then $p else () };         declare function local:sequence($x as xs:integer) { ("string", 1, 2.0, xs:float(3))[$x] };         local:index-of(for $x in (2,3,4) return local:sequence($x), 2)". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.          declare function local:index-of($seq as xs:double*, $item as xs:double) { for $x [Error is around here]at $p in $seq return if ($x eq $item) then $p else () };         declare function local:sequence($x as xs:integer) { ("string", 1, 2.0, xs:float(3))[$x] };         local:index-of(for $x in (2,3,4) return local:sequence($x), 2)
cbcl-promotion-003,Error: XPST0003: Unable to parse XPath: "         declare function local:index-of($seq as xs:integer*, $item as xs:integer?) as xs:float* {            if (empty($item))              then -1             else for $x at $p in $seq return if ($x eq $item) then $p else ()          };         local:index-of(1 to 10, 3)". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.          declare function local:index-of($seq as xs:integer*, $item as xs:integer?) as xs:float* {            if (empty($item))              then -1             else for $x [Error is around here]at $p in $seq return if ($x eq $item) then $p else ()          };         local:index-of(1 to 10, 3)
cbcl-promotion-005,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "\n        declare function local:index-of($seq, $item) as xs:double? { for $x at $p in $seq return if ($x eq $item) then $p else () };\n        local:index-of((1, 2.0, xs:float(3), 2), 2)".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\n\n        declare function local:index-of($seq, $item) as xs:double? { for $x [Error is around here]at $p in $seq return if ($x eq $item) then $p else () };\n        local:index-of((1, 2.0, xs:float(3), 2), 2)'
cbcl-promotion-006,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function index-of with arity of 2 not registered. No similar functions found.'
function-call-reserved-function-names-014,Error: XPST0003: Unable to parse XPath: " 	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function local:function() { fn:true() }; 	function()       ". Expected " ", "(:", "\n", "\r", "\t", "as", or "{" but end of input found.  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function local:function() { fn:true() }; 	function()       [Error is around here]
function-call-reserved-function-names-015,Error: XPST0003: Unable to parse XPath: " 	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function namespace-node($arg) { fn:true() }; 	namespace-node(1)       ". Expected " ", "(:", "\n", "\r", or "\t" but "n" found.  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function [Error is around here]namespace-node($arg) { fn:true() }; 	namespace-node(1)
function-call-reserved-function-names-016,Error: XPST0003: Unable to parse XPath: " 	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function local:switch() { fn:true() }; 	switch()       ". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found.  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function local:switch() { fn:true() }; 	switch[Error is around here]()
function-call-reserved-function-names-033,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'XPST0003: Unable to parse XPath: "\n\tfunction()\n      ".\nExpected " ", "(:", "\\n", "\\r", "\\t", "as", or "{" but end of input found.\n\n\tfunction()\n      [Error is around here]'
function-call-reserved-function-names-034,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'XPST0003: Unable to parse XPath: "\n\tnamespace-node(1)\n      ".\nExpected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found.\n\n\tnamespace-node[Error is around here](1)\n      '
function-call-reserved-function-names-035,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'XPST0003: Unable to parse XPath: "\n\tswitch()\n      ".\nExpected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found.\n\n\tswitch[Error is around here]()\n      '
function-call-reserved-function-names-039,Error: XPST0003: Unable to parse XPath: " 	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function local:array() { fn:true() }; 	array()       ". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "{", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found.  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function local:array() { fn:true() }; 	array[Error is around here]()
function-call-reserved-function-names-041,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'XPST0003: Unable to parse XPath: "\n\tarray()\n      ".\nExpected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "{", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found.\n\n\tarray[Error is around here]()\n      '
function-call-reserved-function-names-043,Error: XPST0003: Unable to parse XPath: " 	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function local:map() { fn:true() }; 	map()       ". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "{", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found.  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function local:map() { fn:true() }; 	map[Error is around here]()
function-call-reserved-function-names-045,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'XPST0003: Unable to parse XPath: "\n\tmap()\n      ".\nExpected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "{", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found.\n\n\tmap[Error is around here]()\n      '
function-declaration-004,Error: XPST0003: Unable to parse XPath: "         declare function local:summary($emps as element(employee)*) as element(dept)* {              for $d in distinct-values($emps/deptno)              let $e := $emps[deptno = $d]              return <dept>                        <deptno>{$d}</deptno>                        <headcount> {count($e)} </headcount>                        <payroll> {sum($e/salary)} </payroll>                     </dept>          };         local:summary(//employee[location = "Denver"])       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.          declare function local:summary($emps as element(employee)*) as element(dept)* {              for $d in distinct-values($emps/deptno)              [Error is around here]let $e := $emps[deptno = $d]              return <dept>                        <deptno>{$d}</deptno>                        <headcount> {count($e)} </headcount>                        <payroll> {sum($e/salary)} </payroll>                     </dept>          };         local:summary(//employee[location = "Denver"])
function-declaration-005,Error: XPST0003: Unable to parse XPath: "         declare function local:mysum($i as xs:integer, $j as xs:integer) { let $j := $i + $j return $j };         declare function local:invoke_mysum() { let $s := 1 for $d in (1,2,3,4,5) let $s := local:mysum($s, $d) return $s };         local:invoke_mysum()". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found.          declare function local:mysum($i as xs:integer, $j as xs:integer) { let $j := $i + $j return $j };         declare function local:invoke_mysum() { let $s := 1 [Error is around here]for $d in (1,2,3,4,5) let $s := local:mysum($s, $d) return $s };         local:invoke_mysum()
function-declaration-006,Error: XPST0003: Unable to parse XPath: "         declare function local:mysum($i as xs:integer, $j as xs:integer) { let $j := $i + $j return $j };         declare function local:invoke_mysum($st as xs:integer) { for $d in (1,2,3,4,5) let $st := local:mysum($d, $st) return $st };         local:invoke_mysum(0)". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.          declare function local:mysum($i as xs:integer, $j as xs:integer) { let $j := $i + $j return $j };         declare function local:invoke_mysum($st as xs:integer) { for $d in (1,2,3,4,5) [Error is around here]let $st := local:mysum($d, $st) return $st };         local:invoke_mysum(0)
function-declaration-007,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
function-declaration-008,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
function-declaration-017,Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.example.com/filesystem";         declare variable $v as xs:integer := 100;         declare function local:udf1 ($CUSTNO as xs:integer) { <empty> {$CUSTNO*$v} </empty> };         local:udf1(10)       ". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.          declare default element namespace "http://www.example.com/filesystem";         declare variable $v [Error is around here]as xs:integer := 100;         declare function local:udf1 ($CUSTNO as xs:integer) { <empty> {$CUSTNO*$v} </empty> };         local:udf1(10)
function-declaration-018,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
function-declaration-019,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
function-declaration-021,AssertionError: expected [Function] to throw an error
function-declaration-022,AssertionError: expected [Function] to throw error including 'XQST0034' but got 'XQST0049: The function Q{http://www.w3.org/2005/xquery-local-functions}foo#1 has already been declared.'
function-declaration-023,AssertionError: Expected executing the XPath "         declare function foo ($n as xs:integer) { $n };         foo(4)" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XQST0060: Functions declared in a module must reside in a namespace.', AssertionError: expected [Function] to throw error including 'XPST0017' but got 'XQST0060: Functions declared in a module must reside in a namespace.'.
function-declaration-024,AssertionError: expected [Function] to throw an error
function-declaration-025,AssertionError: expected [Function] to throw error including 'XQST0060' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
function-declaration-026,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
function-declaration-027,AssertionError: expected [Function] to throw an error
function-declaration-028,Error: XPST0003: Unable to parse XPath: "(          declare function local:function() { };          local:function()) => empty()". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found. (          declare [Error is around here]function local:function() { };          local:function()) => empty()
function-declaration-029,Error: XPST0003: Unable to parse XPath: "(          declare function local:function($x) { (:there is nothing here:) };          local:function(3)) => empty()". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found. (          declare [Error is around here]function local:function($x) { (:there is nothing here:) };          local:function(3)) => empty()
function-declaration-030,AssertionError: expected [Function] to throw an error
K-FunctionProlog-2,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XQST0060: Functions declared in a module must reside in a namespace.'
K-FunctionProlog-10,AssertionError: expected [Function] to throw an error
K-FunctionProlog-11,AssertionError: expected [Function] to throw an error
K-FunctionProlog-12a,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K-FunctionProlog-12b,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K-FunctionProlog-14,AssertionError: expected [Function] to throw an error
K-FunctionProlog-18,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K-FunctionProlog-24,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XQST0060: Functions declared in a module must reside in a namespace.'
K-FunctionProlog-25,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K-FunctionProlog-26,AssertionError: expected [Function] to throw error including 'XQST0034' but got 'XQST0049: The function Q{http://www.w3.org/2005/xquery-local-functions}myName#0 has already been declared.'
K-FunctionProlog-27,AssertionError: expected [Function] to throw error including 'XQST0034' but got 'XQST0049: The function Q{http://www.w3.org/2005/xquery-local-functions}myName#0 has already been declared.'
K-FunctionProlog-28,AssertionError: expected [Function] to throw error including 'XQST0034' but got 'XQST0049: The function Q{http://www.w3.org/2005/xquery-local-functions}myName#1 has already been declared.'
K-FunctionProlog-29,AssertionError: expected [Function] to throw error including 'XQST0034' but got 'XQST0049: The function Q{http://www.w3.org/2005/xquery-local-functions}myName#1 has already been declared.'
K-FunctionProlog-39,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K-FunctionProlog-40,Error: Not implemented: references to variables with a namespace URI or a prefix.
K-FunctionProlog-41,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Not implemented: references to variables with a namespace URI or a prefix.'
K-FunctionProlog-42,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Not implemented: references to variables with a namespace URI or a prefix.'
K-FunctionProlog-46,AssertionError: Expected executing the XPath "         declare function local:myFunction($arg as empty-sequence()) { $arg };         local:myFunction(1)" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0081: The type empty-sequence() could not be found.', AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0081: The type empty-sequence() could not be found.'.
K-FunctionProlog-49,AssertionError: Expected executing the XPath "         declare function local:myFunction($arg as empty-sequence()) { $arg };         empty(local:myFunction(()))" to resolve to one of the expected results, but got Error: XPTY0004: Multiplicity of function argument of type empty-sequence() for myFunction is incorrect. Expected exactly one, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPTY0004: Multiplicity of function argument of type empty-sequence() for myFunction is incorrect. Expected exactly one'.
K-FunctionProlog-50,AssertionError: expected [Function] to throw an error
K-FunctionProlog-52,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function fn:error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
K-FunctionProlog-53,AssertionError: Expected executing the XPath "declare namespace my = "http://example.com/MyNamespace/";         declare variable $my:error-qname := QName("http:example.org/", "prefix:ncname");         declare function my:error($choice, $msg as xs:string) as empty-sequence() { if($choice) then error($my:error-qname, concat('No luck: ', $msg)) else () };         empty((my:error(false(), "msg"), my:error(false(), "The message")))" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
K-FunctionProlog-56,AssertionError: Expected executing the XPath "declare namespace my = "http://example.com/MyNamespace/";         declare variable $my:error-qname := QName("http://example.com/MyErrorNS", "my:qName");         declare function my:error($choice, $msg as xs:string) as empty-sequence() { if($choice) then error($my:error-qname, concat('No luck: ', $msg)) else () };         empty((my:error(false(), "msg"), my:error(false(), "The message")))" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
K-FunctionProlog-57,AssertionError: expected [Function] to throw an error
K-FunctionProlog-62,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K-FunctionProlog-65,AssertionError: Expected executing the XPath "         declare function local:myFunction() as empty-sequence() { fn:error() };         QName("http://example.com/ANamespace", local:myFunction())" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function fn:error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?', AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function fn:error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'.
K-FunctionProlog-66,AssertionError: Expected executing the XPath "         declare function local:myFunction() { fn:error() };         QName("http://example.com/ANamespace", local:myFunction())" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function fn:error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?', AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function fn:error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'.
K-FunctionProlog-67,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-FunctionProlog-1,Error: XPST0003: Unable to parse XPath: "         declare function local:myFunction($arg as xs:integer) as xs:integer { ((if($arg eq 1) then 1 else $arg - 1), current-time())[1] treat as xs:integer };         local:myFunction(1) eq local:myFunction(2)". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "t" found.          declare function local:myFunction($arg as xs:integer) as xs:integer { ((if($arg eq 1) then 1 else $arg - 1), current-time())[1] [Error is around here]treat as xs:integer };         local:myFunction(1) eq local:myFunction(2)
K2-FunctionProlog-2,Error: XPST0003: Unable to parse XPath: "         declare function local:myFunction($arg as xs:integer) as xs:integer { ((if($arg eq 1) then 1 else $arg - 1), current-time())[1] treat as xs:integer };         not(local:myFunction(1) ne local:myFunction(2))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "t" found.          declare function local:myFunction($arg as xs:integer) as xs:integer { ((if($arg eq 1) then 1 else $arg - 1), current-time())[1] [Error is around here]treat as xs:integer };         not(local:myFunction(1) ne local:myFunction(2))
K2-FunctionProlog-3,Error: XPST0003: Unable to parse XPath: "         declare function local:myFunction($arg as xs:integer) as xs:integer { ((if($arg eq 1) then 1 else $arg - 1), current-time())[1] treat as xs:integer };         local:myFunction(1) = local:myFunction(2)". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "t" found.          declare function local:myFunction($arg as xs:integer) as xs:integer { ((if($arg eq 1) then 1 else $arg - 1), current-time())[1] [Error is around here]treat as xs:integer };         local:myFunction(1) = local:myFunction(2)
K2-FunctionProlog-4,Error: XPST0003: Unable to parse XPath: "         declare function local:myFunction($arg as xs:integer) as xs:integer { ((if($arg eq 1) then 1 else $arg - 1), current-time())[1] treat as xs:integer };         not(local:myFunction(1) != local:myFunction(2))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "t" found.          declare function local:myFunction($arg as xs:integer) as xs:integer { ((if($arg eq 1) then 1 else $arg - 1), current-time())[1] [Error is around here]treat as xs:integer };         not(local:myFunction(1) != local:myFunction(2))
K2-FunctionProlog-6,AssertionError: expected [Function] to throw an error
K2-FunctionProlog-7,AssertionError: Expected XPath          declare function local:myFunction() as xs:float { 4.0 };         (current-time(), 1, 2, "a string", local:myFunction(), 4.0, xs:double("NaN"), current-date())[5] instance of xs:float        to resolve to true: expected false to be true
K2-FunctionProlog-10,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-FunctionProlog-15,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-FunctionProlog-18,Error: XPST0003: Unable to parse XPath: "         declare function local:func() as xs:integer { attribute name {"1"} };         local:func() = 1". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.          declare function local:func() as xs:integer { attribute [Error is around here]name {"1"} };         local:func() = 1
K2-FunctionProlog-19,Error: XPST0003: Unable to parse XPath: "         declare function local:func() as xs:integer { document {"1"} };         local:func() = 1". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.          declare function local:func() as xs:integer { document [Error is around here]{"1"} };         local:func() = 1
K2-FunctionProlog-20,AssertionError: expected [Function] to throw an error
K2-FunctionProlog-21,AssertionError: expected [Function] to throw an error
K2-FunctionProlog-22,Error: XPST0003: Unable to parse XPath: "         declare function local:func() as xs:integer? { text {"1"} };         local:func() = 1". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.          declare function local:func() as xs:integer? { text [Error is around here]{"1"} };         local:func() = 1
K2-FunctionProlog-24,AssertionError: expected [Function] to throw an error
K2-FunctionProlog-25,Error: XPST0003: Unable to parse XPath: "       declare function local:myFunc($recurse as xs:integer) { attribute {concat("name", $recurse)} {()} , if ($recurse = 0) then () else local:myFunc($recurse - 1) };         <e> { local:myFunc((2, current-time())[1] treat as xs:integer) } </e>". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.        declare function local:myFunc($recurse as xs:integer) { attribute [Error is around here]{concat("name", $recurse)} {()} , if ($recurse = 0) then () else local:myFunc($recurse - 1) };         <e> { local:myFunc((2, current-time())[1] treat as xs:integer) } </e>
K2-FunctionProlog-26,AssertionError: expected [Function] to throw an error
K2-FunctionProlog-27,AssertionError: expected [Function] to throw an error
K2-FunctionProlog-30,AssertionError: Expected executing the XPath "       declare function local:foo($arg) as xs:boolean { $arg };         local:foo(<e/>)" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw an error, AssertionError: expected [Function] to throw an error.
K2-FunctionProlog-31,AssertionError:        declare function local:foo($arg) as xs:boolean* { $arg };         local:foo((<e>true</e>, true(), xs:untypedAtomic("false"), false(), <e> true </e>)): expected 'true true false false  true ' to equal 'true true false false true'
K2-FunctionProlog-32,AssertionError: expected [Function] to throw an error
K2-FunctionProlog-33,AssertionError:        declare function local:foo($arg ) as xs:boolean* { $arg };         local:foo((<e>true</e>, true(), xs:untypedAtomic("false"), false(), <e> true </e>)): expected 'true true false false  true ' to equal 'true true false false true'
K2-FunctionProlog-35,AssertionError: Expected XPath          declare function local:foo($arg) as xs:boolean* { $arg };         local:foo(xs:untypedAtomic("false")) to resolve to false: expected true to be false
K2-FunctionProlog-36,AssertionError: Expected XPath          declare function local:foo($arg) as xs:boolean { $arg };         local:foo(xs:untypedAtomic("false")) to resolve to false: expected true to be false
K2-FunctionProlog-37,AssertionError:        declare function local:foo($arg ) as xs:boolean* { $arg };         local:foo((<e>true</e>, true(), xs:untypedAtomic("false"), false(), <e> true </e>)): expected 'true true false false  true ' to equal 'true true false false true'
K2-FunctionProlog-38,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'XPST0003: Unable to parse XPath: "\n        declare function local:foo() as xs:boolean { text {local:doesNotExist()} };\n        1".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.\n\n        declare function local:foo() as xs:boolean { text [Error is around here]{local:doesNotExist()} };\n        1'
K2-FunctionProlog-39,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-FunctionProlog-40,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
function-decl-reserved-function-names-001,Error: XPST0003: Unable to parse XPath: " 	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function attribute() { fn:true() }; 	local:attribute()       ". Expected " ", "(:", "\n", "\r", or "\t" but "a" found.  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function [Error is around here]attribute() { fn:true() }; 	local:attribute()
function-decl-reserved-function-names-003,Error: XPST0003: Unable to parse XPath: " 	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function comment() { fn:true() }; 	local:comment()       ". Expected " ", "(:", "\n", "\r", or "\t" but "c" found.  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function [Error is around here]comment() { fn:true() }; 	local:comment()
function-decl-reserved-function-names-005,Error: XPST0003: Unable to parse XPath: " 	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function document-node() { fn:true() }; 	local:document-node()       ". Expected " ", "(:", "\n", "\r", or "\t" but "d" found.  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function [Error is around here]document-node() { fn:true() }; 	local:document-node()
function-decl-reserved-function-names-007,Error: XPST0003: Unable to parse XPath: " 	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function element() { fn:true() }; 	local:element()       ". Expected " ", "(:", "\n", "\r", or "\t" but "e" found.  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function [Error is around here]element() { fn:true() }; 	local:element()
function-decl-reserved-function-names-009,Error: XPST0003: Unable to parse XPath: " 	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function empty-sequence() { fn:true() }; 	local:empty-sequence()       ". Expected " ", "(:", "\n", "\r", or "\t" but "e" found.  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function [Error is around here]empty-sequence() { fn:true() }; 	local:empty-sequence()
function-decl-reserved-function-names-011,Error: XPST0003: Unable to parse XPath: " 	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function function() { fn:true() }; 	local:function()       ". Expected " ", "(:", "\n", "\r", or "\t" but "f" found.  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function [Error is around here]function() { fn:true() }; 	local:function()
function-decl-reserved-function-names-013,Error: XPST0003: Unable to parse XPath: " 	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function if() { fn:true() }; 	local:if()       ". Expected " ", "(:", "\n", "\r", or "\t" but "i" found.  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function [Error is around here]if() { fn:true() }; 	local:if()
function-decl-reserved-function-names-015,Error: XPST0003: Unable to parse XPath: " 	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function item() { fn:true() }; 	local:item()       ". Expected " ", "(:", "\n", "\r", or "\t" but "i" found.  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function [Error is around here]item() { fn:true() }; 	local:item()
function-decl-reserved-function-names-017,Error: XPST0003: Unable to parse XPath: " 	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function namespace-node() { fn:true() }; 	local:namespace-node()       ". Expected " ", "(:", "\n", "\r", or "\t" but "n" found.  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function [Error is around here]namespace-node() { fn:true() }; 	local:namespace-node()
function-decl-reserved-function-names-019,Error: XPST0003: Unable to parse XPath: " 	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function node() { fn:true() }; 	local:node()       ". Expected " ", "(:", "\n", "\r", or "\t" but "n" found.  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function [Error is around here]node() { fn:true() }; 	local:node()
function-decl-reserved-function-names-021,Error: XPST0003: Unable to parse XPath: " 	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function processing-instruction() { fn:true() }; 	local:processing-instruction()       ". Expected " ", "(:", "\n", "\r", or "\t" but "p" found.  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function [Error is around here]processing-instruction() { fn:true() }; 	local:processing-instruction()
function-decl-reserved-function-names-023,Error: XPST0003: Unable to parse XPath: " 	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function schema-attribute() { fn:true() }; 	local:schema-attribute()       ". Expected " ", "(:", "\n", "\r", or "\t" but "s" found.  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function [Error is around here]schema-attribute() { fn:true() }; 	local:schema-attribute()
function-decl-reserved-function-names-025,Error: XPST0003: Unable to parse XPath: " 	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function schema-element() { fn:true() }; 	local:schema-element()       ". Expected " ", "(:", "\n", "\r", or "\t" but "s" found.  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function [Error is around here]schema-element() { fn:true() }; 	local:schema-element()
function-decl-reserved-function-names-027,Error: XPST0003: Unable to parse XPath: " 	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function switch() { fn:true() }; 	local:switch()       ". Expected " ", "(:", "\n", "\r", or "\t" but "s" found.  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function [Error is around here]switch() { fn:true() }; 	local:switch()
function-decl-reserved-function-names-029,Error: XPST0003: Unable to parse XPath: " 	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function text() { fn:true() }; 	local:text()       ". Expected " ", "(:", "\n", "\r", or "\t" but "t" found.  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function [Error is around here]text() { fn:true() }; 	local:text()
function-decl-reserved-function-names-031,Error: XPST0003: Unable to parse XPath: " 	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function typeswitch() { fn:true() }; 	local:typeswitch()       ". Expected " ", "(:", "\n", "\r", or "\t" but "t" found.  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function [Error is around here]typeswitch() { fn:true() }; 	local:typeswitch()
K-GenCompEq-16,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
K-GenCompEq-17,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
K-GenCompEq-18,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
K-GenCompEq-19,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
K-GenCompEq-54,AssertionError: expected [Function] to throw an error
K2-GenCompEq-1,Error: XPST0003: Unable to parse XPath: "          declare variable $vA as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string;           declare variable $vB as xs:string := ("b string", current-time(), string(<e>content</e>))[1] treat as xs:string;           (lower-case($vA) = lower-case($vB))       ". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.           declare variable $vA [Error is around here]as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string;           declare variable $vB as xs:string := ("b string", current-time(), string(<e>content</e>))[1] treat as xs:string;           (lower-case($vA) = lower-case($vB))
K2-GenCompEq-2,Error: XPST0003: Unable to parse XPath: "          declare variable $vA as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string;           declare variable $vB as xs:string := ("b string", current-time(), string(<e>content</e>))[1] treat as xs:string;           (upper-case($vA) = upper-case($vB))       ". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.           declare variable $vA [Error is around here]as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string;           declare variable $vB as xs:string := ("b string", current-time(), string(<e>content</e>))[1] treat as xs:string;           (upper-case($vA) = upper-case($vB))
K2-GenCompEq-3,Error: XPST0003: Unable to parse XPath: "          declare variable $vA as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string;           declare variable $vB as xs:string := ("no match", current-time(), string(<e>content</e>))[1] treat as xs:string;           (lower-case($vA) = lower-case($vB))       ". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.           declare variable $vA [Error is around here]as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string;           declare variable $vB as xs:string := ("no match", current-time(), string(<e>content</e>))[1] treat as xs:string;           (lower-case($vA) = lower-case($vB))
K2-GenCompEq-4,Error: XPST0003: Unable to parse XPath: "          declare variable $vA as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string;           declare variable $vB as xs:string := ("no match", current-time(), string(<e>content</e>))[1] treat as xs:string;           (upper-case($vA) = upper-case($vB))       ". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.           declare variable $vA [Error is around here]as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string;           declare variable $vB as xs:string := ("no match", current-time(), string(<e>content</e>))[1] treat as xs:string;           (upper-case($vA) = upper-case($vB))
K2-GenCompEq-5,Error: XPST0003: Unable to parse XPath: "          declare variable $vA as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string;           declare variable $vB as xs:string := ("b string", current-time(), string(<e>content</e>))[1] treat as xs:string;           (upper-case($vA) = lower-case($vB))       ". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.           declare variable $vA [Error is around here]as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string;           declare variable $vB as xs:string := ("b string", current-time(), string(<e>content</e>))[1] treat as xs:string;           (upper-case($vA) = lower-case($vB))
K2-GenCompEq-6,Error: XPST0003: Unable to parse XPath: "          declare variable $vA as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string;           declare variable $vB as xs:string := ("b string", current-time(), string(<e>content</e>))[1] treat as xs:string;           (lower-case($vA) = upper-case($vB))       ". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.           declare variable $vA [Error is around here]as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string;           declare variable $vB as xs:string := ("b string", current-time(), string(<e>content</e>))[1] treat as xs:string;           (lower-case($vA) = upper-case($vB))
K2-GenCompEq-7,AssertionError: Expected executing the XPath "let $x := codepoints-to-string(12) return ($x = $x)" to resolve to one of the expected results, but got Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found., AssertionError: expected [Function] to throw error including 'FOCH0001' but got 'XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.'.
K2-GenCompEq-8,AssertionError: Expected executing the XPath "empty(for $b in <e/> where $b/@id="person0" return ())" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "empty(for $b in <e/> where $b/@id="person0" return ())". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found. empty(for $b in <e/> [Error is around here]where $b/@id="person0" return ()), AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "empty(for $b in <e/> where $b/@id="person0" return ())".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.\nempty(for $b in <e/> [Error is around here]where $b/@id="person0" return ())'.
GenCompEq-7,Error: Atomizing array(*) is not implemented.
GenCompEq-8,Error: Atomizing array(*) is not implemented.
GenCompEq-9,Error: Atomizing array(*) is not implemented.
GenCompEq-10,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
GenCompEq-11,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
GenCompEq-12,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
GenCompEq-13,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
GenCompEq-14,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
GenCompEq-15,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
GenCompEq-16,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
GenCompEq-17,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
GenCompEq-18,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
GenCompEq-19,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
GenCompEq-20,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
GenCompEq-21,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
GenCompEq-22,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
GenCompEq-23,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
GenCompLT-9,Error: Atomizing array(*) is not implemented.
GenCompLT-10,Error: Atomizing array(*) is not implemented.
GenCompLT-11,Error: Atomizing array(*) is not implemented.
K-GenCompNE-35,AssertionError: expected [Function] to throw an error
CondExpr017,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
CondExpr018,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
CondExpr20,Error: XPST0003: Unable to parse XPath: "if( false() ) then /Folder[1] cast as xs:double ? else 10 cast as xs:double ? = 10". Expected " ", "!=", "(:", "*", "+", "-", "<", "<<", "<=", "=", ">", ">=", ">>", "\n", "\r", "\t", "and", "castable", "div", "else", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "?" found. if( false() ) then /Folder[1] cast as xs:double [Error is around here]? else 10 cast as xs:double ? = 10
CondExpr21,Error: XPST0003: Unable to parse XPath: "if( true() ) then 10 cast as xs:double ? else /Folder[1] cast as xs:double ? = 10". Expected " ", "!=", "(:", "*", "+", "-", "<", "<<", "<=", "=", ">", ">=", ">>", "\n", "\r", "\t", "and", "castable", "div", "else", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "?" found. if( true() ) then 10 cast as xs:double [Error is around here]? else /Folder[1] cast as xs:double ? = 10
CondExpr022,Error: XPST0017: Function doc-available with arity of 1 not registered. No similar functions found.
K-CondExpr-3,Error: XPST0003: Unable to parse XPath: "(if((1, current-time())[1] treat as xs:integer) then true() else false()) eq true()". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found. (if((1, current-time())[1] [Error is around here]treat as xs:integer) then true() else false()) eq true()
K-CondExpr-4,Error: XPST0003: Unable to parse XPath: "(if(boolean((1, current-time())[1] treat as xs:integer)) then true() else false()) eq true()". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found. (if(boolean((1, current-time())[1] [Error is around here]treat as xs:integer)) then true() else false()) eq true()
K-CondExpr-6,Error: XPST0003: Unable to parse XPath: "string(if(boolean((1, current-time())[1] treat as xs:integer)) then true() else false()) eq "true"". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found. string(if(boolean((1, current-time())[1] [Error is around here]treat as xs:integer)) then true() else false()) eq "true"
K-CondExpr-12,Error: XPST0003: Unable to parse XPath: "if(boolean((1, 2, 3, current-time())[1] treat as xs:integer)) then true() else 4". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found. if(boolean((1, 2, 3, current-time())[1] [Error is around here]treat as xs:integer)) then true() else 4
K2-CondExpr-3,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
inline-fn-006,AssertionError: expected [Function] to throw an error
inline-fn-012a,AssertionError: expected [Function] to throw an error
inline-fn-013,AssertionError: Expected XPath           let $add := function($x, $y) as xs:double {$x + $y}          return $add(3, 4)        to resolve to something of type xs:double: expected false to be true
inline-fn-015,Error: XPST0003: Unable to parse XPath: "          let $add := %Q{http://example.com/speed}fast %Q{http://example.com/origin}author("Mike") function($x, $y) {$x + $y} return $add(2,2)        = 4". Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "%" found.           let $add := [Error is around here]%Q{http://example.com/speed}fast %Q{http://example.com/origin}author("Mike") function($x, $y) {$x + $y} return $add(2,2)        = 4
inline-fn-021,Error: XPST0017: Function function-name with arity of 1 not registered. No similar functions found.
inline-fn-022,Error: XPST0017: Function function-arity with arity of 1 not registered. No similar functions found.
inline-fn-023,Error: XPST0017: Function apply with arity of 2 not registered. No similar functions found.
inline-fn-025,Error: XPST0017: Function function-arity with arity of 1 not registered. No similar functions found.
inline-fn-028,AssertionError: expected [Function] to throw an error
inline-fn-029,AssertionError: expected [Function] to throw an error
inline-fn-030,AssertionError: expected [Function] to throw error including 'FOTY0013' but got 'XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?'
inline-fn-032,Error: No selector counterpart for: anyFunctionTest.
inline-fn-033,Error: No selector counterpart for: anyFunctionTest.
inline-fn-034,Error: XPST0003: Unable to parse XPath: "          declare variable $p as xs:integer external;          declare variable $f := function($a) {$a + $p};          $f(12)        = 19". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.           declare variable $p [Error is around here]as xs:integer external;          declare variable $f := function($a) {$a + $p};          $f(12)        = 19
inline-fn-035,Error: XPST0003: Unable to parse XPath: "          declare variable $p as xs:integer external;          declare function local:negate($x) {-$x};          declare variable $f := let $x := $p return function($a) {local:negate($a + $x + $p)};          $f(12)        = -26". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.           declare variable $p [Error is around here]as xs:integer external;          declare function local:negate($x) {-$x};          declare variable $f := let $x := $p return function($a) {local:negate($a + $x + $p)};          $f(12)        = -26
instanceof111,AssertionError: expected [Function] to throw an error
instanceof121,Error: No selector counterpart for: anyFunctionTest.
instanceof122,Error: No selector counterpart for: functionTest.
instanceof123,Error: No selector counterpart for: functionTest.
instanceof124,Error: No selector counterpart for: functionTest.
instanceof125,Error: No selector counterpart for: functionTest.
instanceof126,Error: No selector counterpart for: functionTest.
instanceof127,Error: No selector counterpart for: functionTest.
instanceof128,Error: No selector counterpart for: functionTest.
instanceof129,Error: No selector counterpart for: functionTest.
instanceof130,Error: No selector counterpart for: functionTest.
instanceof131,Error: No selector counterpart for: functionTest.
instanceof132,Error: No selector counterpart for: functionTest.
instanceof133,Error: No selector counterpart for: functionTest.
instanceof134,Error: No selector counterpart for: functionTest.
K-SeqExprInstanceOf-37,Error: No selector counterpart for: e.
K-SeqExprInstanceOf-38,Error: No selector counterpart for: e.
K-SeqExprInstanceOf-39,Error: No selector counterpart for: e.
K-SeqExprInstanceOf-40,Error: No selector counterpart for: e.
K-SeqExprInstanceOf-41,Error: No selector counterpart for: e.
K-SeqExprInstanceOf-42,Error: No selector counterpart for: e.
K-SeqExprInstanceOf-52,AssertionError: expected [Function] to throw error including 'XPST0051' but got 'XPST0081: The type none could not be found.'
K-SeqExprInstanceOf-53,AssertionError: expected [Function] to throw error including 'XPST0051' but got 'XPST0081: The type void could not be found.'
K-SeqExprInstanceOf-56,AssertionError: Expected executing the XPath "error() instance of xs:integer" to resolve to one of the expected results, but got Error: XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?, AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'.
K-SeqExprInstanceOf-57,AssertionError: Expected executing the XPath "error() instance of xs:integer*" to resolve to one of the expected results, but got Error: XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?, AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'.
K-SeqExprInstanceOf-58,AssertionError: Expected executing the XPath "error() instance of empty-sequence()" to resolve to one of the expected results, but got Error: No selector counterpart for: e., AssertionError: expected [Function] to throw error including 'FOER0000' but got 'No selector counterpart for: e.'.
K-SeqExprInstanceOf-59,AssertionError: Expected executing the XPath "(error(), 1) instance of empty-sequence()" to resolve to one of the expected results, but got Error: No selector counterpart for: e., AssertionError: expected [Function] to throw error including 'FOER0000' but got 'No selector counterpart for: e.'.
K-SeqExprInstanceOf-60,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
K-SeqExprInstanceOf-61,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
K-SeqExprInstanceOf-62,AssertionError: Expected executing the XPath "(1, error()) instance of xs:integer*" to resolve to one of the expected results, but got Error: XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?, AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'.
K-SeqExprInstanceOf-63,AssertionError: Expected executing the XPath "(error(), 1) instance of xs:integer*" to resolve to one of the expected results, but got Error: XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?, AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'.
K-SeqExprInstanceOf-66,AssertionError: Expected XPath ((10)mod(3)) instance of xs:integer to resolve to true: expected false to be true
K2-SeqExprInstanceOf-8,Error: XPST0003: Unable to parse XPath: "attribute e{"content"} instance of attribute(e)". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. attribute [Error is around here]e{"content"} instance of attribute(e)
K2-SeqExprInstanceOf-9,Error: XPST0003: Unable to parse XPath: "attribute e{"content"} instance of attribute()". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. attribute [Error is around here]e{"content"} instance of attribute()
K2-SeqExprInstanceOf-10,Error: XPST0003: Unable to parse XPath: "attribute e{"content"} instance of attribute(*)". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. attribute [Error is around here]e{"content"} instance of attribute(*)
K2-SeqExprInstanceOf-11,Error: XPST0003: Unable to parse XPath: "attribute e{"content"} instance of element(e)". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. attribute [Error is around here]e{"content"} instance of element(e)
K2-SeqExprInstanceOf-12,Error: XPST0003: Unable to parse XPath: "attribute e{"content"} instance of element()". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. attribute [Error is around here]e{"content"} instance of element()
K2-SeqExprInstanceOf-13,Error: XPST0003: Unable to parse XPath: "attribute e{"content"} instance of element(*)". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. attribute [Error is around here]e{"content"} instance of element(*)
K2-SeqExprInstanceOf-14,Error: XPST0003: Unable to parse XPath: "attribute e{"content"} instance of attribute(name)". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found. attribute [Error is around here]e{"content"} instance of attribute(name)
K2-SeqExprInstanceOf-98,Error: XPST0003: Unable to parse XPath: "node-name(text {""}) instance of empty-sequence()". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. node-name(text [Error is around here]{""}) instance of empty-sequence()
K2-SeqExprInstanceOf-99,AssertionError: <e attr=""/>/(@attr instance of attribute(), @* instance of attribute()): expected 'true' to equal 'true true'
K2-SeqExprInstanceOf-100,AssertionError: <a><b/></a>/(b instance of element(), * instance of element()): expected 'true' to equal 'true true'
letexprwith-1,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "let $salary as xs:decimal := "cat" return $salary * 2".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\nlet $salary [Error is around here]as xs:decimal := "cat" return $salary * 2'
letexprwith-2,Error: XPST0003: Unable to parse XPath: "let $var as xs:decimal := 100 return $var = 100". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $var [Error is around here]as xs:decimal := 100 return $var = 100
letexprwith-3,Error: XPST0003: Unable to parse XPath: "let $var as xs:integer := 100 return $var = 100". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $var [Error is around here]as xs:integer := 100 return $var = 100
letexprwith-4,Error: XPST0003: Unable to parse XPath: "let $var as xs:double := 100E1 return $var = 1000". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $var [Error is around here]as xs:double := 100E1 return $var = 1000
letexprwith-5,Error: XPST0003: Unable to parse XPath: "let $var as xs:string := "A String" return $var". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $var [Error is around here]as xs:string := "A String" return $var
letexprwith-6,Error: XPST0003: Unable to parse XPath: "let $var as xs:boolean := fn:true() return $var". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $var [Error is around here]as xs:boolean := fn:true() return $var
letexprwith-7,Error: XPST0003: Unable to parse XPath: "let $var as xs:boolean := fn:false() return $var". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $var [Error is around here]as xs:boolean := fn:false() return $var
letexprwith-8,Error: XPST0003: Unable to parse XPath: "let $var as xs:date := xs:date("1999-05-31Z") return $var". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $var [Error is around here]as xs:date := xs:date("1999-05-31Z") return $var
letexprwith-9,Error: XPST0003: Unable to parse XPath: "let $var as xs:time := xs:time("21:23:00Z") return $var". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $var [Error is around here]as xs:time := xs:time("21:23:00Z") return $var
letexprwith-10,Error: XPST0003: Unable to parse XPath: "let $var as xs:dateTime := xs:dateTime("1999-05-31T13:20:00Z") return $var". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $var [Error is around here]as xs:dateTime := xs:dateTime("1999-05-31T13:20:00Z") return $var
letexprwith-11,Error: XPST0003: Unable to parse XPath: "let $var as xs:float := xs:float(100) return $var = 100". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $var [Error is around here]as xs:float := xs:float(100) return $var = 100
letexprwith-12,Error: XPST0003: Unable to parse XPath: "let $var as xs:integer := 100+200 return $var = 300". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $var [Error is around here]as xs:integer := 100+200 return $var = 300
letexprwith-13,Error: XPST0003: Unable to parse XPath: "let $var as xs:integer := fn:count((100,200)) return $var = 2". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $var [Error is around here]as xs:integer := fn:count((100,200)) return $var = 2
letexprwith-14,Error: XPST0003: Unable to parse XPath: "let $var as xs:boolean := fn:not(fn:true()) return $var". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $var [Error is around here]as xs:boolean := fn:not(fn:true()) return $var
letexprwith-15,Error: XPST0003: Unable to parse XPath: "let $var as xs:boolean := fn:true() and fn:true() return $var". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $var [Error is around here]as xs:boolean := fn:true() and fn:true() return $var
letexprwith-16,Error: XPST0003: Unable to parse XPath: "let $var as xs:boolean := fn:true() and fn:true() return $var". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $var [Error is around here]as xs:boolean := fn:true() and fn:true() return $var
letexprwith-17,Error: XPST0003: Unable to parse XPath: "let $var as xs:integer := fn:string-length("A String") return $var = 8". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $var [Error is around here]as xs:integer := fn:string-length("A String") return $var = 8
letexprwith-18,Error: XPST0003: Unable to parse XPath: "let $var as xs:string := xs:string((xs:integer(100))) return $var". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $var [Error is around here]as xs:string := xs:string((xs:integer(100))) return $var
letexprwith-19,Error: XPST0003: Unable to parse XPath: "let $var as xs:string := xs:string((xs:decimal(100))) return $var". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $var [Error is around here]as xs:string := xs:string((xs:decimal(100))) return $var
letexprwith-20,Error: XPST0003: Unable to parse XPath: "let $var as xs:string := xs:string((xs:double(100E2))) return $var". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $var [Error is around here]as xs:string := xs:string((xs:double(100E2))) return $var
letexprwith-21,Error: XPST0003: Unable to parse XPath: "let $var as xs:string := xs:string(fn:true()) return $var". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $var [Error is around here]as xs:string := xs:string(fn:true()) return $var
letexprwith-22,Error: XPST0003: Unable to parse XPath: "let $var as xs:integer := 100 return $var + 1 = 101". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $var [Error is around here]as xs:integer := 100 return $var + 1 = 101
letexprwith-23,Error: XPST0003: Unable to parse XPath: "let $var as xs:boolean := if (fn:true()) then fn:true() else fn:false() return $var". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $var [Error is around here]as xs:boolean := if (fn:true()) then fn:true() else fn:false() return $var
letexprwith-24,Error: XPST0003: Unable to parse XPath: "let $var as xs:string := typeswitch(fn:true()) case $i as xs:boolean return "Test Passed" default return "Test failed" return $var". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. let $var [Error is around here]as xs:string := typeswitch(fn:true()) case $i as xs:boolean return "Test Passed" default return "Test failed" return $var
LetExpr004,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
LetExpr005,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
LetExpr019,Error: XPST0003: Unable to parse XPath: "let $a := <elem/> let $b := <elem2/> return ($a,$b)". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. let $a := <elem/> [Error is around here]let $b := <elem2/> return ($a,$b)
LetExpr020,Error: XPST0003: Unable to parse XPath: "let $a := 1 let $b := $a let $c := $a+$b return ($c) = 2". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. let $a := 1 [Error is around here]let $b := $a let $c := $a+$b return ($c) = 2
K-LetExprWithout-4,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-LetExprWithout-1,Error: XPST0003: Unable to parse XPath: "deep-equal((<b/>, <b/>, <b/>, <b/>), (for $v1 in (1, 2, 3, 4) let $v2 := <b/> return ($v2))/.)". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. deep-equal((<b/>, <b/>, <b/>, <b/>), (for $v1 in (1, 2, 3, 4) [Error is around here]let $v2 := <b/> return ($v2))/.)
K2-LetExprWithout-2,Error: XPST0003: Unable to parse XPath: "deep-equal((<b/>, <b/>, <b/>, <b/>), (for $v1 in (1, 2, 3, 4) let $v2 := <b/> return ($v2)))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. deep-equal((<b/>, <b/>, <b/>, <b/>), (for $v1 in (1, 2, 3, 4) [Error is around here]let $v2 := <b/> return ($v2)))
K2-LetExprWithout-7,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "let $i as xs:integer := xs:untypedAtomic("1") return $i".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\nlet $i [Error is around here]as xs:integer := xs:untypedAtomic("1") return $i'
K2-LetExprWithout-9,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "let $i as xs:float := 1.1 return $i".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\nlet $i [Error is around here]as xs:float := 1.1 return $i'
K2-LetExprWithout-10,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "let $i as xs:double := 1.1 return $i".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\nlet $i [Error is around here]as xs:double := 1.1 return $i'
K2-LetExprWithout-11,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "let $i as xs:float := 1 return $i".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\nlet $i [Error is around here]as xs:float := 1 return $i'
K2-LetExprWithout-12,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "let $i as xs:double := 1 return $i".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\nlet $i [Error is around here]as xs:double := 1 return $i'
K2-LetExprWithout-13,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "let $i as xs:double := xs:float(3) return $i".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\nlet $i [Error is around here]as xs:double := xs:float(3) return $i'
K2-LetExprWithout-14,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "let $i as xs:string := xs:untypedAtomic("a string") return $i".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\nlet $i [Error is around here]as xs:string := xs:untypedAtomic("a string") return $i'
K2-LetExprWithout-15,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "let $i as xs:string := xs:anyURI("http://www.example.com/") return $i".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\nlet $i [Error is around here]as xs:string := xs:anyURI("http://www.example.com/") return $i'
K2-LetExprWithout-16,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-LetExprWithout-20,Error: XPST0003: Unable to parse XPath: "         let $emps := //employee[location = "Denver"]          for $d in distinct-values($emps/deptno)          let $e := $emps[deptno = $d]          return <dept> <deptno>{$d}</deptno> <headcount> {count($e)} </headcount> <payroll> {sum($e/salary)} </payroll> </dept>       ". Expected " ", "!", "!=", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found.          let $emps := //employee[location = "Denver"]          [Error is around here]for $d in distinct-values($emps/deptno)          let $e := $emps[deptno = $d]          return <dept> <deptno>{$d}</deptno> <headcount> {count($e)} </headcount> <payroll> {sum($e/salary)} </payroll> </dept>
K2-LetExprWithout-23,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
K2-LetExprWithout-26,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "let $e := <element/>, $outer as element() := $e/element() return $outer".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\nlet $e := <element/>, $outer [Error is around here]as element() := $e/element() return $outer'
xquery10keywords,Error: XPST0003: Unable to parse XPath: "let $ancestor-or-self := 1        let $ancestor := 1        let $and := 1        let $as := 1        let $ascending := 1        let $at := 1        let $attribute := 1        let $base-uri := 1        let $boundary-space := 1        let $by := 1        let $case := 1        let $cast := 1        let $castable := 1        let $child := 1        let $collation := 1        let $comment := 1        let $construction := 1        let $copy-namespaces := 1        let $declare := 1        let $default := 1        let $descendant-or-self := 1        let $descendant := 1        let $descending := 1        let $div := 1        let $document-node := 1        let $document := 1        let $element := 1        let $else := 1        let $empty-sequence := 1        let $empty := 1        let $encoding := 1        let $eq := 1 let $every := 1 let $except := 1 let $external := 1 let $following-sibling := 1        let $following := 1 let $for := 1 let $function := 1 let $ge := 1 let $greatest := 1        let $gt := 1 let $idiv := 1 let $if := 1 let $import := 1 let $in := 1 let $inherit := 1        let $instance := 1 let $intersect := 1 let $is := 1 let $item := 1 let $lax := 1        let $le := 1 let $least := 1 let $let := 1 let $lt := 1 let $mod := 1 let $module := 1        let $module := 1 let $namespace := 1 let $ne := 1 let $no-inherit := 1        let $no-preserve := 1 let $node := 1 let $of := 1 let $option := 1 let $or := 1        let $order := 1 let $ordered := 1 let $ordering := 1 let $parent := 1 let $preceding-sibling := 1        let $preceding := 1 let $preserve := 1 let $processing-instruction := 1 let $return := 1        let $satisfies := 1 let $schema-attribute := 1 let $schema-element := 1 let $schema := 1        let $self := 1 let $some := 1 let $stable := 1 let $strict := 1 let $strip := 1        let $text := 1 let $then := 1 let $to := 1 let $treat := 1 let $typeswitch := 1        let $union := 1 let $unordered := 1 let $validate := 1 let $variable := 1 let $version := 1        let $where := 1 let $xquery := 1 return 2 = 2". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. let $ancestor-or-self := 1        [Error is around here]let $ancestor := 1        let $and := 1        let $as := 1        let $ascending := 1        let $at := 1        let $attribute := 1        let $base-uri := 1        let $boundary-space := 1        let $by := 1        let $case := 1        let $cast := 1        let $castable := 1        let $child := 1        let $collation := 1        let $comment := 1        let $construction := 1        let $copy-namespaces := 1        let $declare := 1        let $default := 1        let $descendant-or-self := 1        let $descendant := 1        let $descending := 1        let $div := 1        let $document-node := 1        let $document := 1        let $element := 1        let $else := 1        let $empty-sequence := 1        let $empty := 1        let $encoding := 1        let $eq := 1 let $every := 1 let $except := 1 let $external := 1 let $following-sibling := 1        let $following := 1 let $for := 1 let $function := 1 let $ge := 1 let $greatest := 1        let $gt := 1 let $idiv := 1 let $if := 1 let $import := 1 let $in := 1 let $inherit := 1        let $instance := 1 let $intersect := 1 let $is := 1 let $item := 1 let $lax := 1        let $le := 1 let $least := 1 let $let := 1 let $lt := 1 let $mod := 1 let $module := 1        let $module := 1 let $namespace := 1 let $ne := 1 let $no-inherit := 1        let $no-preserve := 1 let $node := 1 let $of := 1 let $option := 1 let $or := 1        let $order := 1 let $ordered := 1 let $ordering := 1 let $parent := 1 let $preceding-sibling := 1        let $preceding := 1 let $preserve := 1 let $processing-instruction := 1 let $return := 1        let $satisfies := 1 let $schema-attribute := 1 let $schema-element := 1 let $schema := 1        let $self := 1 let $some := 1 let $stable := 1 let $strict := 1 let $strip := 1        let $text := 1 let $then := 1 let $to := 1 let $treat := 1 let $typeswitch := 1        let $union := 1 let $unordered := 1 let $validate := 1 let $variable := 1 let $version := 1        let $where := 1 let $xquery := 1 return 2 = 2
xquery30keywords,Error: XPST0003: Unable to parse XPath: "         let $NaN := 1         let $allowing := 1         let $ancestor-or-self := 1         let $ancestor := 1         let $and := 1         let $as := 1         let $ascending := 1         let $at := 1         let $attribute := 1         let $base-uri := 1         let $boundary-space := 1         let $by := 1         let $case := 1         let $cast := 1         let $castable := 1         let $catch := 1         let $child := 1         let $collation := 1         let $comment := 1         let $construction := 1         let $context := 1         let $copy-namespaces := 1         let $count := 1         let $decimal-format := 1         let $decimal-separator := 1         let $declare := 1         let $default := 1         let $descendant-or-self := 1         let $descendant := 1         let $descending := 1         let $digit := 1         let $div := 1         let $document-node := 1         let $document := 1         let $element := 1         let $else := 1         let $empty-sequence := 1         let $empty := 1         let $encoding := 1         let $end := 1         let $eq := 1         let $every := 1         let $except := 1         let $external := 1         let $following-sibling := 1         let $following := 1         let $for := 1         let $function := 1         let $ge := 1         let $greatest := 1         let $group := 1         let $grouping-separator := 1         let $gt := 1         let $idiv := 1         let $if := 1         let $import := 1         let $in := 1         let $infinity := 1         let $inherit := 1         let $instance := 1         let $intersect := 1         let $is := 1         let $item := 1         let $lax := 1         let $le := 1         let $least := 1         let $let := 1         let $lt := 1         let $minus-sign := 1         let $mod := 1         let $module := 1         let $namespace-node := 1         let $namespace := 1         let $ne := 1         let $next := 1         let $no-inherit := 1         let $no-preserve := 1         let $node := 1         let $of := 1         let $only := 1         let $option := 1         let $or := 1         let $order := 1         let $ordered := 1         let $ordering := 1         let $parent := 1         let $pattern-separator := 1         let $per-mille := 1         let $percent := 1         let $preceding-sibling := 1         let $preceding := 1         let $preserve := 1         let $previous := 1         let $processing-instruction := 1         let $return := 1         let $satisfies := 1         let $schema-attribute := 1         let $schema-element := 1         let $schema := 1         let $self := 1         let $sliding := 1         let $some := 1         let $stable := 1         let $start := 1         let $strict := 1         let $strip := 1         let $switch := 1         let $text := 1         let $then := 1         let $to := 1         let $treat := 1         let $try := 1         let $tumbling := 1         let $type := 1         let $typeswitch := 1         let $union := 1         let $unordered := 1         let $validate := 1         let $variable := 1         let $version := 1         let $when := 1         let $where := 1         let $window := 1         let $xquery := 1         let $zero-digit := 1         return 2        = 2". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.          let $NaN := 1         [Error is around here]let $allowing := 1         let $ancestor-or-self := 1         let $ancestor := 1         let $and := 1         let $as := 1         let $ascending := 1         let $at := 1         let $attribute := 1         let $base-uri := 1         let $boundary-space := 1         let $by := 1         let $case := 1         let $cast := 1         let $castable := 1         let $catch := 1         let $child := 1         let $collation := 1         let $comment := 1         let $construction := 1         let $context := 1         let $copy-namespaces := 1         let $count := 1         let $decimal-format := 1         let $decimal-separator := 1         let $declare := 1         let $default := 1         let $descendant-or-self := 1         let $descendant := 1         let $descending := 1         let $digit := 1         let $div := 1         let $document-node := 1         let $document := 1         let $element := 1         let $else := 1         let $empty-sequence := 1         let $empty := 1         let $encoding := 1         let $end := 1         let $eq := 1         let $every := 1         let $except := 1         let $external := 1         let $following-sibling := 1         let $following := 1         let $for := 1         let $function := 1         let $ge := 1         let $greatest := 1         let $group := 1         let $grouping-separator := 1         let $gt := 1         let $idiv := 1         let $if := 1         let $import := 1         let $in := 1         let $infinity := 1         let $inherit := 1         let $instance := 1         let $intersect := 1         let $is := 1         let $item := 1         let $lax := 1         let $le := 1         let $least := 1         let $let := 1         let $lt := 1         let $minus-sign := 1         let $mod := 1         let $module := 1         let $namespace-node := 1         let $namespace := 1         let $ne := 1         let $next := 1         let $no-inherit := 1         let $no-preserve := 1         let $node := 1         let $of := 1         let $only := 1         let $option := 1         let $or := 1         let $order := 1         let $ordered := 1         let $ordering := 1         let $parent := 1         let $pattern-separator := 1         let $per-mille := 1         let $percent := 1         let $preceding-sibling := 1         let $preceding := 1         let $preserve := 1         let $previous := 1         let $processing-instruction := 1         let $return := 1         let $satisfies := 1         let $schema-attribute := 1         let $schema-element := 1         let $schema := 1         let $self := 1         let $sliding := 1         let $some := 1         let $stable := 1         let $start := 1         let $strict := 1         let $strip := 1         let $switch := 1         let $text := 1         let $then := 1         let $to := 1         let $treat := 1         let $try := 1         let $tumbling := 1         let $type := 1         let $typeswitch := 1         let $union := 1         let $unordered := 1         let $validate := 1         let $variable := 1         let $version := 1         let $when := 1         let $where := 1         let $window := 1         let $xquery := 1         let $zero-digit := 1         return 2        = 2
xquery30keywords5,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
xquery31keywords5,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
Literals016,AssertionError: 65535032e2: expected '6553503200' to equal '6.5535032E9'
Literals017,AssertionError: 65535.032e2: expected '6553503.2' to equal '6.5535032E6'
Literals025,AssertionError: -65535.032e2: expected '-6553503.2' to equal '-6.5535032E6'
Literals027,AssertionError: 65535032E2: expected '6553503200' to equal '6.5535032E9'
Literals028,AssertionError: 65535.032E2: expected '6553503.2' to equal '6.5535032E6'
Literals068,Error: XPST0003: Unable to parse XPath: "text{ 'He said, "I don''t like it."' }". Expected "!", "!=", "#", "(", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "{" found. text[Error is around here]{ 'He said, "I don''t like it."' }
Literals069,Error: XPST0003: Unable to parse XPath: "text{ "He said, ""I don't like it.""" }". Expected "!", "!=", "#", "(", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "{" found. text[Error is around here]{ "He said, ""I don't like it.""" }
K-Literals-29,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'Failed to execute \'evaluateXPath\': xpathExpression must be a string.'
K-Literals-31,AssertionError: expected [Function] to throw an error
K-Literals-32,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XQST0090: The character reference NaN (NaN) does not reference a valid codePoint.'
K-Literals-33,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XQST0090: The character reference NaN (NaN) does not reference a valid codePoint.'
K-Literals-34,AssertionError: expected [Function] to throw an error
K-Literals-35,AssertionError: expected [Function] to throw an error
K-Literals-36,AssertionError: expected [Function] to throw an error
K-Literals-38,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XQST0090: The character reference NaN (NaN) does not reference a valid codePoint.'
K-Literals-39,AssertionError: expected [Function] to throw an error
K-Literals-40,AssertionError: expected [Function] to throw an error
K-Literals-41,AssertionError: expected [Function] to throw an error
K-Literals-44,AssertionError: expected [Function] to throw an error
K-Literals-45,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XQST0090: The character reference NaN (NaN) does not reference a valid codePoint.'
K-Literals-48,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XQST0090: The character reference NaN (NaN) does not reference a valid codePoint.'
K2-Literals-2,AssertionError: expected [Function] to throw an error
K2-Literals-6,AssertionError: Expected executing the XPath "999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999.1" to resolve to one of the expected results, but got AssertionError: 999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999.1: expected '1E+123' to equal '999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999.1', AssertionError: Expected XPath 999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999.1 to resolve to 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000: expected false to be true, AssertionError: expected [Function] to throw an error.
K2-Literals-22,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XQST0090: The character reference -32 (-20) does not reference a valid codePoint.'
K2-Literals-23,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XQST0090: The character reference -20 (-14) does not reference a valid codePoint.'
K2-Literals-24,AssertionError: expected [Function] to throw an error
K2-Literals-25,AssertionError: expected [Function] to throw an error
K2-Literals-26,AssertionError: expected [Function] to throw an error
K2-Literals-27,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XQST0090: The character reference NaN (NaN) does not reference a valid codePoint.'
K2-Literals-28,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
K2-Literals-29,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XQST0090: The character reference 0 (0) does not reference a valid codePoint.'
cbcl-literals-001,AssertionError: expected [Function] to throw an error
cbcl-literals-002,AssertionError: expected [Function] to throw an error
cbcl-literals-003,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XQST0090: The character reference NaN (NaN) does not reference a valid codePoint.'
cbcl-literals-005,AssertionError: expected [Function] to throw an error
cbcl-literals-006,AssertionError: expected [Function] to throw an error
cbcl-literals-007,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XQST0090: The character reference NaN (NaN) does not reference a valid codePoint.'
MapConstructor-025,Error: No selector counterpart for: lookup.
MapConstructor-035,Error: XPST0003: Unable to parse XPath: "          <e><f>4</f></e>!map{*:*div*,*||*:*}          =>          deep-equal(map{"44":<f>4</f>,"4":1})       ". Expected " ", "!", "!=", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "eq", "except", "ge", "gt", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", "||", or "}" but "d" found.           <e><f>4</f></e>!map{*:*[Error is around here]div*,*||*:*}          =>          deep-equal(map{"44":<f>4</f>,"4":1})
MapConstructor-036,AssertionError: expected [Function] to throw error including 'XQDY0137' but got 'FOTY0013: Atomization is not supported for map(*).'
MapConstructor-037,AssertionError: expected [Function] to throw error including 'XQDY0137' but got 'FOTY0013: Atomization is not supported for map(*).'
MapConstructor-038,AssertionError: expected [Function] to throw error including 'XQDY0137' but got 'FOTY0013: Atomization is not supported for map(*).'
MapConstructor-039,AssertionError: expected [Function] to throw error including 'XQDY0137' but got 'FOTY0013: Atomization is not supported for map(*).'
MapConstructor-040,AssertionError: expected [Function] to throw error including 'XQDY0137' but got 'FOTY0013: Atomization is not supported for map(*).'
MapConstructor-041,AssertionError: expected [Function] to throw error including 'XQDY0137' but got 'FOTY0013: Atomization is not supported for map(*).'
MapConstructor-042,AssertionError: expected [Function] to throw error including 'XQDY0137' but got 'FOTY0013: Atomization is not supported for map(*).'
function-literal-005,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}nilled with arity of 0 not registered. No similar functions found.
function-literal-006,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}nilled with arity of 0 not registered. No similar functions found.
function-literal-007,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}nilled with arity of 1 not registered. No similar functions found.
function-literal-008,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}nilled with arity of 1 not registered. No similar functions found.
function-literal-013,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}data with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
function-literal-014,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}data with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
function-literal-015,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
function-literal-016,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
function-literal-017,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}base-uri with arity of 0 not registered. No similar functions found.
function-literal-018,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}base-uri with arity of 0 not registered. No similar functions found.
function-literal-019,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}base-uri with arity of 1 not registered. No similar functions found.
function-literal-020,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}base-uri with arity of 1 not registered. No similar functions found.
function-literal-021,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}document-uri with arity of 0 not registered. No similar functions found.
function-literal-022,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}document-uri with arity of 0 not registered. No similar functions found.
function-literal-023,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}document-uri with arity of 1 not registered. No similar functions found.
function-literal-024,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}document-uri with arity of 1 not registered. No similar functions found.
function-literal-025,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
function-literal-026,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
function-literal-027,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
function-literal-028,AssertionError: expected [Function] to throw error including 'XXXX0000' but got 'XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
function-literal-029,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}error with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
function-literal-030,AssertionError: expected [Function] to throw error including 'XXXX0000' but got 'XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}error with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
function-literal-031,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}error with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
function-literal-032,AssertionError: expected [Function] to throw error including 'XXXX0000' but got 'XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}error with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
function-literal-053,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}format-integer with arity of 2 not registered. No similar functions found.
function-literal-054,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}format-integer with arity of 2 not registered. No similar functions found.
function-literal-055,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}format-integer with arity of 3 not registered. No similar functions found.
function-literal-056,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}format-integer with arity of 3 not registered. No similar functions found.
function-literal-057,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}format-number with arity of 2 not registered. No similar functions found.
function-literal-058,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}format-number with arity of 2 not registered. No similar functions found.
function-literal-059,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}format-number with arity of 3 not registered. No similar functions found.
function-literal-060,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}format-number with arity of 3 not registered. No similar functions found.
function-literal-064,Error: XPST0017: Function format-number with arity of 2 not registered. No similar functions found.
function-literal-089,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}codepoints-to-string with arity of 1 not registered. No similar functions found.
function-literal-090,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}codepoints-to-string with arity of 1 not registered. No similar functions found.
function-literal-091,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}string-to-codepoints with arity of 1 not registered. No similar functions found.
function-literal-092,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}string-to-codepoints with arity of 1 not registered. No similar functions found.
function-literal-096,Error: FOCH0002: No collations are supported
function-literal-097,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}codepoint-equal with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}deep-equal (item()*, item()*)" or "Q{http://www.w3.org/2005/xpath-functions}deep-equal (item()*, item()*, xs:string)"?
function-literal-098,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}codepoint-equal with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}deep-equal (item()*, item()*)" or "Q{http://www.w3.org/2005/xpath-functions}deep-equal (item()*, item()*, xs:string)"?
function-literal-117,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}normalize-unicode with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}normalize-space (xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}normalize-space ()" or "Q{http://www.w3.org/2001/XMLSchema}normalizedString (xs:anyAtomicType?)"?
function-literal-118,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}normalize-unicode with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}normalize-space (xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}normalize-space ()" or "Q{http://www.w3.org/2001/XMLSchema}normalizedString (xs:anyAtomicType?)"?
function-literal-119,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}normalize-unicode with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}normalize-space (xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}normalize-space ()" or "Q{http://www.w3.org/2001/XMLSchema}normalizedString (xs:anyAtomicType?)"?
function-literal-120,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}normalize-unicode with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}normalize-space (xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}normalize-space ()" or "Q{http://www.w3.org/2001/XMLSchema}normalizedString (xs:anyAtomicType?)"?
function-literal-125,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}translate with arity of 3 not registered. No similar functions found.
function-literal-126,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}translate with arity of 3 not registered. No similar functions found.
function-literal-130,Error: FOCH0002: No collations are supported
function-literal-134,Error: FOCH0002: No collations are supported
function-literal-138,Error: FOCH0002: No collations are supported
function-literal-141,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}substring-before with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}insert-before (item()*, xs:integer, item()*)"?
function-literal-142,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}substring-before with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}insert-before (item()*, xs:integer, item()*)"?
function-literal-145,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}substring-after with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)"?
function-literal-146,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}substring-after with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)"?
function-literal-147,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}matches with arity of 2 not registered. No similar functions found.
function-literal-148,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}matches with arity of 2 not registered. No similar functions found.
function-literal-149,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}matches with arity of 3 not registered. No similar functions found.
function-literal-150,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}matches with arity of 3 not registered. No similar functions found.
function-literal-151,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}replace with arity of 3 not registered. No similar functions found.
function-literal-152,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}replace with arity of 3 not registered. No similar functions found.
function-literal-153,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}replace with arity of 4 not registered. No similar functions found.
function-literal-154,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}replace with arity of 4 not registered. No similar functions found.
function-literal-158,Error: Not implemented: Using flags in tokenize is not supported
function-literal-159,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}analyze-string with arity of 2 not registered. No similar functions found.
function-literal-160,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}analyze-string with arity of 2 not registered. No similar functions found.
function-literal-161,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}analyze-string with arity of 3 not registered. No similar functions found.
function-literal-162,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}analyze-string with arity of 3 not registered. No similar functions found.
function-literal-163,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}resolve-uri with arity of 1 not registered. No similar functions found.
function-literal-164,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}resolve-uri with arity of 1 not registered. No similar functions found.
function-literal-165,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}resolve-uri with arity of 2 not registered. No similar functions found.
function-literal-166,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}resolve-uri with arity of 2 not registered. No similar functions found.
function-literal-167,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}encode-for-uri with arity of 1 not registered. No similar functions found.
function-literal-168,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}encode-for-uri with arity of 1 not registered. No similar functions found.
function-literal-169,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}iri-to-uri with arity of 1 not registered. No similar functions found.
function-literal-170,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}iri-to-uri with arity of 1 not registered. No similar functions found.
function-literal-171,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}escape-html-uri with arity of 1 not registered. No similar functions found.
function-literal-172,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}escape-html-uri with arity of 1 not registered. No similar functions found.
function-literal-225,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}adjust-dateTime-to-timezone with arity of 1 not registered. No similar functions found.
function-literal-226,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}adjust-dateTime-to-timezone with arity of 1 not registered. No similar functions found.
function-literal-227,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
function-literal-228,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
function-literal-229,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}adjust-date-to-timezone with arity of 1 not registered. No similar functions found.
function-literal-230,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}adjust-date-to-timezone with arity of 1 not registered. No similar functions found.
function-literal-231,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}adjust-date-to-timezone with arity of 2 not registered. No similar functions found.
function-literal-232,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}adjust-date-to-timezone with arity of 2 not registered. No similar functions found.
function-literal-233,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}adjust-time-to-timezone with arity of 1 not registered. No similar functions found.
function-literal-234,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}adjust-time-to-timezone with arity of 1 not registered. No similar functions found.
function-literal-235,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}adjust-time-to-timezone with arity of 2 not registered. No similar functions found.
function-literal-236,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}adjust-time-to-timezone with arity of 2 not registered. No similar functions found.
function-literal-237,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}format-dateTime with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}current-dateTime ()", "Q{http://www.w3.org/2005/xpath-functions}dateTime (xs:date?, xs:time?)" or "Q{http://www.w3.org/2001/XMLSchema}dateTime (xs:anyAtomicType?)"?
function-literal-238,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}format-dateTime with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}current-dateTime ()", "Q{http://www.w3.org/2005/xpath-functions}dateTime (xs:date?, xs:time?)" or "Q{http://www.w3.org/2001/XMLSchema}dateTime (xs:anyAtomicType?)"?
function-literal-239,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}format-dateTime with arity of 5 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}current-dateTime ()", "Q{http://www.w3.org/2005/xpath-functions}dateTime (xs:date?, xs:time?)" or "Q{http://www.w3.org/2001/XMLSchema}dateTime (xs:anyAtomicType?)"?
function-literal-240,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}format-dateTime with arity of 5 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}current-dateTime ()", "Q{http://www.w3.org/2005/xpath-functions}dateTime (xs:date?, xs:time?)" or "Q{http://www.w3.org/2001/XMLSchema}dateTime (xs:anyAtomicType?)"?
function-literal-241,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}format-date with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}current-date ()"?
function-literal-242,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}format-date with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}current-date ()"?
function-literal-243,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}format-date with arity of 5 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}current-date ()"?
function-literal-244,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}format-date with arity of 5 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}current-date ()"?
function-literal-245,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}format-time with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}current-time ()"?
function-literal-246,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}format-time with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}current-time ()"?
function-literal-247,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}format-time with arity of 5 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}current-time ()"?
function-literal-248,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}format-time with arity of 5 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}current-time ()"?
function-literal-249,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}resolve-QName with arity of 2 not registered. No similar functions found.
function-literal-250,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}resolve-QName with arity of 2 not registered. No similar functions found.
function-literal-259,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}namespace-uri-for-prefix with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}namespace-uri-from-QName (xs:QName?)", "Q{http://www.w3.org/2005/xpath-functions}namespace-uri (node())" or "Q{http://www.w3.org/2005/xpath-functions}namespace-uri ()"?
function-literal-260,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}namespace-uri-for-prefix with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}namespace-uri-from-QName (xs:QName?)", "Q{http://www.w3.org/2005/xpath-functions}namespace-uri (node())" or "Q{http://www.w3.org/2005/xpath-functions}namespace-uri ()"?
function-literal-261,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}in-scope-prefixes with arity of 1 not registered. No similar functions found.
function-literal-262,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}in-scope-prefixes with arity of 1 not registered. No similar functions found.
function-literal-275,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}lang with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}long (xs:anyAtomicType?)"?
function-literal-276,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}lang with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}long (xs:anyAtomicType?)"?
function-literal-277,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}lang with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}long (xs:anyAtomicType?)"?
function-literal-278,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}lang with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}long (xs:anyAtomicType?)"?
function-literal-279,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}root with arity of 0 not registered. No similar functions found.
function-literal-280,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}root with arity of 0 not registered. No similar functions found.
function-literal-281,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}root with arity of 1 not registered. No similar functions found.
function-literal-282,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}root with arity of 1 not registered. No similar functions found.
function-literal-283,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}path with arity of 0 not registered. No similar functions found.
function-literal-284,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}path with arity of 0 not registered. No similar functions found.
function-literal-285,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}path with arity of 1 not registered. No similar functions found.
function-literal-286,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}path with arity of 1 not registered. No similar functions found.
function-literal-287,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}has-children with arity of 0 not registered. No similar functions found.
function-literal-288,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}has-children with arity of 0 not registered. No similar functions found.
function-literal-289,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}has-children with arity of 1 not registered. No similar functions found.
function-literal-290,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}has-children with arity of 1 not registered. No similar functions found.
function-literal-315,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}distinct-values with arity of 1 not registered. No similar functions found.
function-literal-316,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}distinct-values with arity of 1 not registered. No similar functions found.
function-literal-317,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}distinct-values with arity of 2 not registered. No similar functions found.
function-literal-318,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}distinct-values with arity of 2 not registered. No similar functions found.
function-literal-319,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}index-of with arity of 2 not registered. No similar functions found.
function-literal-320,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}index-of with arity of 2 not registered. No similar functions found.
function-literal-321,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}index-of with arity of 3 not registered. No similar functions found.
function-literal-322,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}index-of with arity of 3 not registered. No similar functions found.
function-literal-326,Error: FOCH0002: No collations are supported
function-literal-340,Error: FOCH0002: No collations are supported
function-literal-344,Error: FOCH0002: No collations are supported
function-literal-353,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}element-with-id with arity of 1 not registered. No similar functions found.
function-literal-354,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}element-with-id with arity of 1 not registered. No similar functions found.
function-literal-355,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}element-with-id with arity of 2 not registered. No similar functions found.
function-literal-356,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}element-with-id with arity of 2 not registered. No similar functions found.
function-literal-361,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}generate-id with arity of 0 not registered. No similar functions found.
function-literal-362,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}generate-id with arity of 0 not registered. No similar functions found.
function-literal-363,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}generate-id with arity of 1 not registered. No similar functions found.
function-literal-364,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}generate-id with arity of 1 not registered. No similar functions found.
function-literal-365,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}doc with arity of 1 not registered. No similar functions found.
function-literal-366,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}doc with arity of 1 not registered. No similar functions found.
function-literal-367,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}doc-available with arity of 1 not registered. No similar functions found.
function-literal-368,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}doc-available with arity of 1 not registered. No similar functions found.
function-literal-369,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}collection with arity of 0 not registered. No similar functions found.
function-literal-370,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}collection with arity of 0 not registered. No similar functions found.
function-literal-371,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}collection with arity of 1 not registered. No similar functions found.
function-literal-372,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}collection with arity of 1 not registered. No similar functions found.
function-literal-373,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}uri-collection with arity of 0 not registered. No similar functions found.
function-literal-374,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}uri-collection with arity of 0 not registered. No similar functions found.
function-literal-375,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}uri-collection with arity of 1 not registered. No similar functions found.
function-literal-376,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}uri-collection with arity of 1 not registered. No similar functions found.
function-literal-377,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}unparsed-text with arity of 1 not registered. No similar functions found.
function-literal-378,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}unparsed-text with arity of 1 not registered. No similar functions found.
function-literal-379,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}unparsed-text with arity of 2 not registered. No similar functions found.
function-literal-380,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}unparsed-text with arity of 2 not registered. No similar functions found.
function-literal-381,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}unparsed-text-lines with arity of 1 not registered. No similar functions found.
function-literal-382,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}unparsed-text-lines with arity of 1 not registered. No similar functions found.
function-literal-383,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}unparsed-text-lines with arity of 2 not registered. No similar functions found.
function-literal-384,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}unparsed-text-lines with arity of 2 not registered. No similar functions found.
function-literal-385,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}unparsed-text-available with arity of 1 not registered. No similar functions found.
function-literal-386,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}unparsed-text-available with arity of 1 not registered. No similar functions found.
function-literal-387,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}unparsed-text-available with arity of 2 not registered. No similar functions found.
function-literal-388,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}unparsed-text-available with arity of 2 not registered. No similar functions found.
function-literal-389,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}environment-variable with arity of 1 not registered. No similar functions found.
function-literal-390,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}environment-variable with arity of 1 not registered. No similar functions found.
function-literal-391,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}available-environment-variables with arity of 0 not registered. No similar functions found.
function-literal-392,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}available-environment-variables with arity of 0 not registered. No similar functions found.
function-literal-393,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}parse-xml with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?
function-literal-394,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}parse-xml with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?
function-literal-395,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}parse-xml-fragment with arity of 1 not registered. No similar functions found.
function-literal-396,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}parse-xml-fragment with arity of 1 not registered. No similar functions found.
function-literal-397,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}serialize with arity of 1 not registered. No similar functions found.
function-literal-398,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}serialize with arity of 1 not registered. No similar functions found.
function-literal-399,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}serialize with arity of 2 not registered. No similar functions found.
function-literal-400,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}serialize with arity of 2 not registered. No similar functions found.
function-literal-413,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}default-collation with arity of 0 not registered. No similar functions found.
function-literal-414,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}default-collation with arity of 0 not registered. No similar functions found.
function-literal-415,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}static-base-uri with arity of 0 not registered. No similar functions found.
function-literal-416,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}static-base-uri with arity of 0 not registered. No similar functions found.
function-literal-417,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}function-lookup with arity of 2 not registered. No similar functions found.
function-literal-418,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}function-lookup with arity of 2 not registered. No similar functions found.
function-literal-419,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}function-name with arity of 1 not registered. No similar functions found.
function-literal-420,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}function-name with arity of 1 not registered. No similar functions found.
function-literal-421,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}function-arity with arity of 1 not registered. No similar functions found.
function-literal-422,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}function-arity with arity of 1 not registered. No similar functions found.
function-literal-423,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}for-each with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}for-each (array(*), function(*))" or "Q{http://www.w3.org/2005/xpath-functions/map}for-each (map(*), function(*))"?
function-literal-424,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}for-each with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}for-each (array(*), function(*))" or "Q{http://www.w3.org/2005/xpath-functions/map}for-each (map(*), function(*))"?
function-literal-427,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}fold-left with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}fold-left (array(*), item()*, function(*))" or "Q{http://www.w3.org/2005/xpath-functions/array}fold-right (array(*), item()*, function(*))"?
function-literal-428,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}fold-left with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}fold-left (array(*), item()*, function(*))" or "Q{http://www.w3.org/2005/xpath-functions/array}fold-right (array(*), item()*, function(*))"?
function-literal-429,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}fold-right with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}fold-right (array(*), item()*, function(*))" or "Q{http://www.w3.org/2005/xpath-functions/array}fold-left (array(*), item()*, function(*))"?
function-literal-430,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}fold-right with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}fold-right (array(*), item()*, function(*))" or "Q{http://www.w3.org/2005/xpath-functions/array}fold-left (array(*), item()*, function(*))"?
function-literal-431,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}for-each-pair with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}for-each-pair (array(*), array(*), function(*))", "Q{http://www.w3.org/2005/xpath-functions/map}for-each (map(*), function(*))" or "Q{http://www.w3.org/2005/xpath-functions/array}for-each (array(*), function(*))"?
function-literal-432,Error: XPST0017: Function Q{http://www.w3.org/2005/xpath-functions}for-each-pair with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}for-each-pair (array(*), array(*), function(*))", "Q{http://www.w3.org/2005/xpath-functions/map}for-each (map(*), function(*))" or "Q{http://www.w3.org/2005/xpath-functions/array}for-each (array(*), function(*))"?
function-literal-524,Error: XPST0081: Can not cast: type xs:IDREFS is unknown.
function-literal-526,Error: XPST0081: Can not cast: type xs:NMTOKENS is unknown.
function-literal-528,Error: XPST0081: Can not cast: type xs:ENTITIES is unknown.
function-literal-701,Error: XPST0017: Function function-name with arity of 1 not registered. No similar functions found.
function-literal-702,Error: XPST0017: Function function-arity with arity of 1 not registered. No similar functions found.
function-literal-704,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
function-literal-705,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
function-literal-706,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
function-literal-707,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
function-literal-708,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
named-function-ref-reserved-function-names-001,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function attribute with arity of 0 not registered. No similar functions found.'
named-function-ref-reserved-function-names-002,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function comment with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}count (item()*)"?'
named-function-ref-reserved-function-names-003,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function document-node with arity of 0 not registered. No similar functions found.'
named-function-ref-reserved-function-names-004,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function element with arity of 0 not registered. No similar functions found.'
named-function-ref-reserved-function-names-005,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function empty-sequence with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}subsequence (item()*, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}subsequence (item()*, xs:double, xs:double)"?'
named-function-ref-reserved-function-names-006,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function function with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}duration (xs:anyAtomicType?)"?'
named-function-ref-reserved-function-names-007,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function if with arity of 0 not registered. No similar functions found.'
named-function-ref-reserved-function-names-008,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function item with arity of 0 not registered. No similar functions found.'
named-function-ref-reserved-function-names-009,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function namespace-node with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}namespace-uri (node())" or "Q{http://www.w3.org/2005/xpath-functions}namespace-uri ()"?'
named-function-ref-reserved-function-names-010,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function node with arity of 0 not registered. No similar functions found.'
named-function-ref-reserved-function-names-011,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function processing-instruction with arity of 0 not registered. No similar functions found.'
named-function-ref-reserved-function-names-012,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function schema-attribute with arity of 0 not registered. No similar functions found.'
named-function-ref-reserved-function-names-013,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function schema-element with arity of 0 not registered. No similar functions found.'
named-function-ref-reserved-function-names-014,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function switch with arity of 0 not registered. No similar functions found.'
named-function-ref-reserved-function-names-015,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function text with arity of 0 not registered. No similar functions found.'
named-function-ref-reserved-function-names-016,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function typeswitch with arity of 0 not registered. No similar functions found.'
named-function-ref-reserved-function-names-017,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function array with arity of 0 not registered. No similar functions found.'
named-function-ref-reserved-function-names-018,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function map with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}max (xs:anyAtomicType*)" or "Q{http://www.w3.org/2005/xpath-functions}max (xs:anyAtomicType*, xs:string)"?'
namespaceDecl-1,AssertionError: expected [Function] to throw error including 'XQST0033' but got 'XPDY0002: context is absent, it needs to be present to use axes.'
namespaceDecl-2,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPST0003: Unable to parse XPath: "element foo:anElement {"Element content"}".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.\nelement [Error is around here]foo:anElement {"Element content"}'
namespaceDecl-3,AssertionError: expected [Function] to throw an error
namespaceDecl-4,AssertionError: expected [Function] to throw an error
namespaceDecl-5,AssertionError: expected [Function] to throw an error
namespaceDecl-23,AssertionError: Expected XPath declare namespace abc = "http://www.example.com/abc&amp;"; let $var := <abc:someElement>some content</abc:someElement> return namespace-uri-from-QName(node-name($var)) eq xs:anyURI("http://www.example.com/abc&amp;") to resolve to true: expected false to be true
K2-NamespaceProlog-1,AssertionError: expected [Function] to throw an error
K2-NamespaceProlog-2,AssertionError: expected [Function] to throw an error
K2-NamespaceProlog-3,AssertionError: expected [Function] to throw an error
K2-NamespaceProlog-4,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPST0017: Function xs:integer with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}integer (xs:anyAtomicType?)"?'
K2-NamespaceProlog-6,AssertionError: expected [Function] to throw an error
K2-NamespaceProlog-7,AssertionError: expected [Function] to throw an error
K2-NamespaceProlog-8,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPST0017: Function xdt:untypedAtomic with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}untypedAtomic (xs:anyAtomicType?)"?'
K2-NamespaceProlog-9,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPST0017: Function xs:untypedAtomic with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}untypedAtomic (xs:anyAtomicType?)"?'
K2-NamespaceProlog-10,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPST0017: Function local:untypedAtomic with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}untypedAtomic (xs:anyAtomicType?)"?'
K2-NamespaceProlog-11,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPST0017: Function fn:untypedAtomic with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}untypedAtomic (xs:anyAtomicType?)"?'
K2-NamespaceProlog-12,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPST0017: Function xsi:untypedAtomic with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}untypedAtomic (xs:anyAtomicType?)"?'
K2-NamespaceProlog-15,AssertionError: expected [Function] to throw an error
cbcl-declare-namespace-001,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
nametest-10,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-NameTest-12,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-NameTest-13,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-NameTest-14,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-NameTest-15,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-NameTest-16,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-NameTest-17,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-NameTest-18,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-NameTest-19,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-NameTest-20,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-NameTest-21,AssertionError: expected [Function] to throw an error
K2-NameTest-22,AssertionError: Expected XPath empty(let $e := <a b ="content"><?b asd?><b/></a> return $e/processing-instruction("b ")) to resolve to false: expected true to be false
K2-NameTest-23,AssertionError: expected [Function] to throw an error
K2-NameTest-30,Error: XPST0003: Unable to parse XPath: "let $result := (       	declare namespace a = "http://example.com/1";        	declare namespace b = "http://example.com/2";        	let $e := <e a:n1="content" b:n1="content">        	            <a:n1/>        	            <b:n1/>        	            <?n1 ?>        	            <n1/>        	          </e>        	return $e/*:n1) return count($result) = 3". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. let $result := (       	declare [Error is around here]namespace a = "http://example.com/1";        	declare namespace b = "http://example.com/2";        	let $e := <e a:n1="content" b:n1="content">        	            <a:n1/>        	            <b:n1/>        	            <?n1 ?>        	            <n1/>        	          </e>        	return $e/*:n1) return count($result) = 3
K2-NameTest-31,Error: XPST0003: Unable to parse XPath: "let $result := (       	declare namespace a = "http://example.com/1";        	declare namespace b = "http://example.com/2";        	let $e := <e a:n1="content" b:n1="content">        				<a:n1/>        				<b:n1/>        				<?n1 ?>        				<n1/>        			  </e>        	return $e/a:*) return count($result) = 1". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. let $result := (       	declare [Error is around here]namespace a = "http://example.com/1";        	declare namespace b = "http://example.com/2";        	let $e := <e a:n1="content" b:n1="content">        				<a:n1/>        				<b:n1/>        				<?n1 ?>        				<n1/>        			  </e>        	return $e/a:*) return count($result) = 1
K2-NameTest-32,AssertionError: Expected XPath <a>{<e foo="content2" bar="content1"/>/attribute(foo)}</a> to resolve to the given XML. Expected <a/> to equal <a foo="content2"/>
K2-NameTest-35,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'No selector counterpart for: u.'
K2-NameTest-36,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'No selector counterpart for: u.'
K2-NameTest-37,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'No selector counterpart for: u.'
K2-NameTest-38,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'No selector counterpart for: u.'
K2-NameTest-39,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'No selector counterpart for: u.'
K2-NameTest-40,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'No selector counterpart for: u.'
K2-NameTest-47,NamespaceError: NamespaceError: xmlns prefix or qualifiedName must use the XMLNS namespace
K2-NameTest-48,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-NameTest-50,AssertionError: Expected executing the XPath "declare namespace p = "http://example.com/"; <a>{document {<p:e/>}/@p:*}</a>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "declare namespace p = "http://example.com/"; <a>{document {<p:e/>}/@p:*}</a>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace p = "http://example.com/"; <a>{document [Error is around here]{<p:e/>}/@p:*}</a>, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "declare namespace p = "http://example.com/"; <a>{document {<p:e/>}/@p:*}</a>".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.\ndeclare namespace p = "http://example.com/"; <a>{document [Error is around here]{<p:e/>}/@p:*}</a>'.
K2-NameTest-51,AssertionError: Expected executing the XPath "<a>{attribute name{"content"}/*}</a>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "<a>{attribute name{"content"}/*}</a>". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found. <a>{attribute [Error is around here]name{"content"}/*}</a>, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "<a>{attribute name{"content"}/*}</a>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.\n<a>{attribute [Error is around here]name{"content"}/*}</a>'.
K2-NameTest-52,AssertionError: Expected executing the XPath "<a>{comment {"content"}/*}</a>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "<a>{comment {"content"}/*}</a>". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. <a>{comment [Error is around here]{"content"}/*}</a>, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "<a>{comment {"content"}/*}</a>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.\n<a>{comment [Error is around here]{"content"}/*}</a>'.
K2-NameTest-54,AssertionError: Expected executing the XPath "<a>{processing-instruction name {"content"}/*}</a>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "<a>{processing-instruction name {"content"}/*}</a>". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found. <a>{processing-instruction [Error is around here]name {"content"}/*}</a>, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "<a>{processing-instruction name {"content"}/*}</a>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.\n<a>{processing-instruction [Error is around here]name {"content"}/*}</a>'.
K2-NameTest-56,AssertionError: Expected executing the XPath "declare variable $a := <e><a/><b/><c/></e>; <a>{$a/*:ncname eq 1}</a>" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
K2-NameTest-57,AssertionError: Expected executing the XPath "declare variable $a := <e><a/><b/><c/></e>; <a>{$a/*:ncname eq 1}</a>" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
K2-NameTest-58,AssertionError: Expected executing the XPath "declare namespace prefix = "http://example.com/"; declare variable $a := <e><a/><b/><c/></e>; <a>{$a/prefix:* eq 1}</a>" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
K2-NameTest-59,AssertionError: Expected executing the XPath "declare namespace prefix = "http://example.com/"; declare variable $a := <e><a/><b/><c/></e>; <a>{$a/@prefix:* eq 1}</a>" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
K2-NameTest-60,AssertionError: Expected executing the XPath "         declare variable $input := <e/>;          empty(for $PI as processing-instruction() in $input//processing-instruction() return $PI)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "         declare variable $input := <e/>;          empty(for $PI as processing-instruction() in $input//processing-instruction() return $PI)". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.          declare variable $input := <e/>;          empty(for $PI [Error is around here]as processing-instruction() in $input//processing-instruction() return $PI), AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "\n        declare variable $input := <e/>; \n        empty(for $PI as processing-instruction() in $input//processing-instruction() return $PI)".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\n\n        declare variable $input := <e/>; \n        empty(for $PI [Error is around here]as processing-instruction() in $input//processing-instruction() return $PI)'.
K2-NameTest-64,Error: attribute() with more than 1 argument is not supported.
K2-NameTest-65,Error: attribute() with more than 1 argument is not supported.
K2-NameTest-66,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'attribute() with more than 1 argument is not supported.'
K2-NameTest-67,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'attribute() with more than 1 argument is not supported.'
K2-NameTest-68,AssertionError: Expected executing the XPath "<e>{<e foo="1"/>/attribute(foo, xs:integer)}</e>" to resolve to one of the expected results, but got Error: attribute() with more than 1 argument is not supported., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'attribute() with more than 1 argument is not supported.'.
K2-NameTest-69,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'attribute() with more than 1 argument is not supported.'
K2-NameTest-70,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'attribute() with more than 1 argument is not supported.'
K2-NameTest-71,Error: attribute() with more than 1 argument is not supported.
K2-NameTest-73,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'element() with more than 1 argument is not supported.'
K2-NameTest-74,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'element() with more than 1 argument is not supported.'
K2-NameTest-75,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'element() with more than 1 argument is not supported.'
K2-NameTest-76,Error: element() with more than 1 argument is not supported.
K2-NameTest-77,Error: element() with more than 1 argument is not supported.
K2-NameTest-87,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'attribute() with more than 1 argument is not supported.'
K2-NameTest-88,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'attribute() with more than 1 argument is not supported.'
K2-NameTest-89,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'attribute() with more than 1 argument is not supported.'
K2-NameTest-90,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'attribute() with more than 1 argument is not supported.'
NodeTest013-2,AssertionError: Expected XPath <out>{fn:count(//center/processing-instruction('a&#x2d;pi'))}</out> to resolve to the given XML. Expected <out>0</out> to equal <out>1</out>
K2-NodeTest-19,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'XPDY0002: context is absent, it needs to be present to use axes.'
K2-NodeTest-20,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'XPDY0002: context is absent, it needs to be present to use axes.'
K2-NodeTest-22,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPDY0002: context is absent, it needs to be present to use axes.'
K2-NodeTest-25,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPDY0002: context is absent, it needs to be present to use axes.'
K2-NodeTest-26,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'No selector counterpart for: u.'
K2-NodeTest-27,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'No selector counterpart for: u.'
K2-NodeTest-28,AssertionError: expected [Function] to throw an error
K2-NodeTest-33,AssertionError: expected [Function] to throw error including 'XPTY0018' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-NodeTest-34,AssertionError: expected [Function] to throw error including 'XPTY0018' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
op-logical-and-100,Error: FORG0001: Cannot cast "9223372036854776000" to xs:long, restriction validation failed.
op-logical-and-101,Error: FORG0001: Cannot cast "9223372036854776000" to xs:long, restriction validation failed.
op-logical-or-100,Error: FORG0001: Cannot cast "9223372036854776000" to xs:long, restriction validation failed.
op-logical-or-101,Error: FORG0001: Cannot cast "9223372036854776000" to xs:long, restriction validation failed.
K-LogicExpr-14,Error: XPST0003: Unable to parse XPath: "true() or (0, current-time())[1] treat as xs:integer". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "t" found. true() or (0, current-time())[1] [Error is around here]treat as xs:integer
K-LogicExpr-15,Error: XPST0003: Unable to parse XPath: "(0, current-time())[1] treat as xs:integer or true()". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "t" found. (0, current-time())[1] [Error is around here]treat as xs:integer or true()
K-LogicExpr-25,Error: XPST0003: Unable to parse XPath: "boolean((1, 2, 3, current-time())[1] treat as xs:integer) or boolean((1, 2, 3, current-time())[1] treat as xs:integer)". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found. boolean((1, 2, 3, current-time())[1] [Error is around here]treat as xs:integer) or boolean((1, 2, 3, current-time())[1] treat as xs:integer)
K-LogicExpr-26,Error: XPST0003: Unable to parse XPath: "boolean((1, 2, 3, current-time())[1] treat as xs:integer) and true()". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found. boolean((1, 2, 3, current-time())[1] [Error is around here]treat as xs:integer) and true()
K-LogicExpr-27,Error: XPST0003: Unable to parse XPath: "true() or boolean((1, 2, 3, current-time())[1] treat as xs:integer)". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found. true() or boolean((1, 2, 3, current-time())[1] [Error is around here]treat as xs:integer)
K-LogicExpr-32,Error: XPST0003: Unable to parse XPath: "not((1, current-time())[1] treat as xs:integer and false())". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found. not((1, current-time())[1] [Error is around here]treat as xs:integer and false())
K-LogicExpr-33,Error: XPST0003: Unable to parse XPath: "not(false() and (1, current-time())[1] treat as xs:integer)". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found. not(false() and (1, current-time())[1] [Error is around here]treat as xs:integer)
K-LogicExpr-42,Error: XPST0003: Unable to parse XPath: "boolean((1, 2, 3, current-time())[1] treat as xs:integer) and boolean((1, 2, 3, current-time())[1] treat as xs:integer)". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found. boolean((1, 2, 3, current-time())[1] [Error is around here]treat as xs:integer) and boolean((1, 2, 3, current-time())[1] treat as xs:integer)
K-LogicExpr-43,Error: XPST0003: Unable to parse XPath: "boolean((1, 2, 3, current-time())[1] treat as xs:integer) and true()". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found. boolean((1, 2, 3, current-time())[1] [Error is around here]treat as xs:integer) and true()
K-LogicExpr-44,Error: XPST0003: Unable to parse XPath: "true() and boolean((1, 2, 3, current-time())[1] treat as xs:integer)". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found. true() and boolean((1, 2, 3, current-time())[1] [Error is around here]treat as xs:integer)
orderBy1,Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by $x ascending return $x } </results>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData [Error is around here]order by $x ascending return $x } </results>
orderBy2,Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by $x descending return $x } </results>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData [Error is around here]order by $x descending return $x } </results>
orderBy3,Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by concat($x,"()") ascending return concat($x,"()") } </results>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData [Error is around here]order by concat($x,"()") ascending return concat($x,"()") } </results>
orderBy4,Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by concat($x,"()") descending return concat($x,"()") } </results>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData [Error is around here]order by concat($x,"()") descending return concat($x,"()") } </results>
orderBy5,Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> {              for $x in /DataValues/Strings/orderData              order by concat($x,"another String After") ascending              return concat($x,"another String After")          } </results>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> {              for $x in /DataValues/Strings/orderData              [Error is around here]order by concat($x,"another String After") ascending              return concat($x,"another String After")          } </results>
orderBy6,Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by concat($x,"another String After") descending              return concat($x,"another String After") } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData [Error is around here]order by concat($x,"another String After") descending              return concat($x,"another String After") } </results>
orderBy7,Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by concat($x,"another String Before") ascending              return concat($x,"another String Before") } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData [Error is around here]order by concat($x,"another String Before") ascending              return concat($x,"another String Before") } </results>
orderBy8,Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by concat($x,"another String Before") descending              return concat($x,"another String Before") } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData [Error is around here]order by concat($x,"another String Before") descending              return concat($x,"another String Before") } </results>
orderBy9,Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by concat($x,"") descending return concat($x,"") } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData [Error is around here]order by concat($x,"") descending return concat($x,"") } </results>
orderBy10,Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by concat($x,"") ascending              return concat($x,"") } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData [Error is around here]order by concat($x,"") ascending              return concat($x,"") } </results>
orderBy11,Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by concat("",$x) descending return concat("",$x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData [Error is around here]order by concat("",$x) descending return concat("",$x) } </results>
orderBy12,Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by concat("",$x) ascending return concat("",$x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData [Error is around here]order by concat("",$x) ascending return concat("",$x) } </results>
orderBy13,Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by concat("",$x) ascending return concat("",$x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData [Error is around here]order by concat("",$x) ascending return concat("",$x) } </results>
orderBy14,Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by $x is $x ascending return $x is $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData [Error is around here]order by $x is $x ascending return $x is $x } </results>
orderBy15,Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by $x is $x descending return $x is $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData [Error is around here]order by $x is $x descending return $x is $x } </results>
orderBy16,Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by concat($x,$x) ascending return concat($x,$x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData [Error is around here]order by concat($x,$x) ascending return concat($x,$x) } </results>
orderBy17,Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by string-length($x) ascending return string-length($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData [Error is around here]order by string-length($x) ascending return string-length($x) } </results>
orderBy18,Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by count($x) ascending return count($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData [Error is around here]order by count($x) ascending return count($x) } </results>
orderBy19,Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by string-length($x) ascending return string-length($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData [Error is around here]order by string-length($x) ascending return string-length($x) } </results>
orderBy20,AssertionError: Expected executing the XPath "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by $x ascending return $x } </results>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by $x ascending return $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData [Error is around here]order by $x ascending return $x } </results>, Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by $x ascending return $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData [Error is around here]order by $x ascending return $x } </results>, Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by $x ascending return $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData [Error is around here]order by $x ascending return $x } </results>, Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by $x ascending return $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData [Error is around here]order by $x ascending return $x } </results>.
orderBy21,AssertionError: Expected executing the XPath "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by $x descending return $x } </results>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by $x descending return $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData [Error is around here]order by $x descending return $x } </results>, Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by $x descending return $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData [Error is around here]order by $x descending return $x } </results>, Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by $x descending return $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData [Error is around here]order by $x descending return $x } </results>, Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by $x descending return $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData [Error is around here]order by $x descending return $x } </results>.
orderBy22,AssertionError: Expected executing the XPath "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by ($x + $x) descending return $x + $x } </results>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by ($x + $x) descending return $x + $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData [Error is around here]order by ($x + $x) descending return $x + $x } </results>, Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by ($x + $x) descending return $x + $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData [Error is around here]order by ($x + $x) descending return $x + $x } </results>, Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by ($x + $x) descending return $x + $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData [Error is around here]order by ($x + $x) descending return $x + $x } </results>.
orderBy23,Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by $x is $x ascending return $x is $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData [Error is around here]order by $x is $x ascending return $x is $x } </results>
orderBy24,Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by $x is $x descending return $x is $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData [Error is around here]order by $x is $x descending return $x is $x } </results>
orderBy25,AssertionError: Expected executing the XPath "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by xs:float($x) descending return xs:float($x) } </results>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by xs:float($x) descending return xs:float($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData [Error is around here]order by xs:float($x) descending return xs:float($x) } </results>, Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by xs:float($x) descending return xs:float($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData [Error is around here]order by xs:float($x) descending return xs:float($x) } </results>.
orderBy26,AssertionError: Expected executing the XPath "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by xs:decimal($x) descending return xs:decimal($x) } </results>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by xs:decimal($x) descending return xs:decimal($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData [Error is around here]order by xs:decimal($x) descending return xs:decimal($x) } </results>, Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by xs:decimal($x) descending return xs:decimal($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData [Error is around here]order by xs:decimal($x) descending return xs:decimal($x) } </results>.
orderBy27,AssertionError: Expected executing the XPath "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by xs:double($x) descending return xs:double($x) } </results>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by xs:double($x) descending return xs:double($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData [Error is around here]order by xs:double($x) descending return xs:double($x) } </results>, Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by xs:double($x) descending return xs:double($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData [Error is around here]order by xs:double($x) descending return xs:double($x) } </results>.
orderBy28,Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by xs:integer($x) descending return xs:integer($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData [Error is around here]order by xs:integer($x) descending return xs:integer($x) } </results>
orderBy30,Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData order by $x ascending return $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData [Error is around here]order by $x ascending return $x } </results>
orderBy31,Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData order by $x descending return $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData [Error is around here]order by $x descending return $x } </results>
orderBy32,AssertionError: Expected executing the XPath "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData order by ($x + $x) descending return $x + $x } </results>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData order by ($x + $x) descending return $x + $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData [Error is around here]order by ($x + $x) descending return $x + $x } </results>, Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData order by ($x + $x) descending return $x + $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData [Error is around here]order by ($x + $x) descending return $x + $x } </results>.
orderBy33,Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData order by $x is $x ascending return $x is $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData [Error is around here]order by $x is $x ascending return $x is $x } </results>
orderBy34,Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData order by $x is $x descending return $x is $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData [Error is around here]order by $x is $x descending return $x is $x } </results>
orderBy35,Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData order by xs:float($x) descending return xs:float($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData [Error is around here]order by xs:float($x) descending return xs:float($x) } </results>
orderBy36,Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData order by xs:decimal($x) descending return xs:decimal($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData [Error is around here]order by xs:decimal($x) descending return xs:decimal($x) } </results>
orderBy37,Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData order by xs:double($x) descending return xs:double($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData [Error is around here]order by xs:double($x) descending return xs:double($x) } </results>
orderBy38,Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData order by xs:integer($x) descending return xs:integer($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData [Error is around here]order by xs:integer($x) descending return xs:integer($x) } </results>
orderBy39,Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData order by string($x) ascending return string($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData [Error is around here]order by string($x) ascending return string($x) } </results>
orderBy40,Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallPositiveNumbers/orderData order by $x ascending return $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallPositiveNumbers/orderData [Error is around here]order by $x ascending return $x } </results>
orderBy41,Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallPositiveNumbers/orderData order by $x descending return $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallPositiveNumbers/orderData [Error is around here]order by $x descending return $x } </results>
orderBy42,AssertionError: Expected executing the XPath "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallPositiveNumbers/orderData order by ($x + $x) descending return $x + $x } </results>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallPositiveNumbers/orderData order by ($x + $x) descending return $x + $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallPositiveNumbers/orderData [Error is around here]order by ($x + $x) descending return $x + $x } </results>, Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallPositiveNumbers/orderData order by ($x + $x) descending return $x + $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallPositiveNumbers/orderData [Error is around here]order by ($x + $x) descending return $x + $x } </results>.
orderBy43,Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallPositiveNumbers/orderData order by $x is $x ascending return $x is $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallPositiveNumbers/orderData [Error is around here]order by $x is $x ascending return $x is $x } </results>
orderBy44,Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallPositiveNumbers/orderData order by $x is $x descending return $x is $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallPositiveNumbers/orderData [Error is around here]order by $x is $x descending return $x is $x } </results>
orderBy45,Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallPositiveNumbers/orderData order by xs:float($x) descending return xs:float($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallPositiveNumbers/orderData [Error is around here]order by xs:float($x) descending return xs:float($x) } </results>
orderBy46,Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallPositiveNumbers/orderData order by xs:decimal($x) descending return xs:decimal($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallPositiveNumbers/orderData [Error is around here]order by xs:decimal($x) descending return xs:decimal($x) } </results>
orderBy47,Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallPositiveNumbers/orderData order by xs:double($x) descending return xs:double($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallPositiveNumbers/orderData [Error is around here]order by xs:double($x) descending return xs:double($x) } </results>
orderBy49,Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallPositiveNumbers/orderData order by string($x) ascending return string($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallPositiveNumbers/orderData [Error is around here]order by string($x) ascending return string($x) } </results>
orderBy50,AssertionError: Expected executing the XPath "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData order by $x ascending return $x } </results>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData order by $x ascending return $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData [Error is around here]order by $x ascending return $x } </results>, Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData order by $x ascending return $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData [Error is around here]order by $x ascending return $x } </results>.
orderBy51,AssertionError: Expected executing the XPath "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData order by $x descending return $x } </results>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData order by $x descending return $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData [Error is around here]order by $x descending return $x } </results>, Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData order by $x descending return $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData [Error is around here]order by $x descending return $x } </results>.
orderBy53,Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData order by $x is $x ascending return $x is $x } </results>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData [Error is around here]order by $x is $x ascending return $x is $x } </results>
orderBy54,Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData order by $x is $x descending return $x is $x } </results>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData [Error is around here]order by $x is $x descending return $x is $x } </results>
orderBy55,AssertionError: Expected executing the XPath "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData order by xs:float($x) descending return xs:float($x) } </results>       " to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData order by xs:float($x) descending return xs:float($x) } </results>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData [Error is around here]order by xs:float($x) descending return xs:float($x) } </results>       , Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData order by xs:float($x) descending return xs:float($x) } </results>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData [Error is around here]order by xs:float($x) descending return xs:float($x) } </results>       .
orderBy56,Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData order by xs:decimal($x) descending return xs:decimal($x) } </results>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData [Error is around here]order by xs:decimal($x) descending return xs:decimal($x) } </results>
orderBy57,AssertionError: Expected executing the XPath "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData order by xs:double($x) descending return xs:double($x) } </results>       " to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData order by xs:double($x) descending return xs:double($x) } </results>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData [Error is around here]order by xs:double($x) descending return xs:double($x) } </results>       , Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData order by xs:double($x) descending return xs:double($x) } </results>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData [Error is around here]order by xs:double($x) descending return xs:double($x) } </results>       .
orderBy59,Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData order by string($x) ascending return string($x) } </results>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData [Error is around here]order by string($x) ascending return string($x) } </results>
orderBy60,Error: XPST0003: Unable to parse XPath: "         declare base-uri "http://www.w3.org/2005/xpath-functions/";          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData                      order by concat($x,"()") ascending collation "collation/codepoint"                      return concat($x,"()") } </results>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare base-uri "http://www.w3.org/2005/xpath-functions/";          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData                      [Error is around here]order by concat($x,"()") ascending collation "collation/codepoint"                      return concat($x,"()") } </results>
orderBy61,Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> {              for $x in /DataValues/Strings/orderData              order by concat($x,"()") ascending collation "http://www.w3.org/2005/xpath-functions/collation/codepoint"              return concat($x,"()") }          </results>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> {              for $x in /DataValues/Strings/orderData              [Error is around here]order by concat($x,"()") ascending collation "http://www.w3.org/2005/xpath-functions/collation/codepoint"              return concat($x,"()") }          </results>
orderBy62,Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results>{              for $x in /DataValues/NegativeNumbers/orderData/xs:decimal(.)              where $x > -1000              order by $x ascending collation "http://www.w3.org/2005/xpath-functions/collation/codepoint"              return $x }         </results>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results>{              for $x in /DataValues/NegativeNumbers/orderData/xs:decimal(.)              [Error is around here]where $x > -1000              order by $x ascending collation "http://www.w3.org/2005/xpath-functions/collation/codepoint"              return $x }         </results>
orderBy63,Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";           /DataValues/(          (            for $x in NegativeNumbers/*            order by (if (name(.) = 'orderData') then $x else -$x)            return $x          )[1]         )        ". Expected " ", "!", "!=", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";           /DataValues/(          (            for $x in NegativeNumbers/*            [Error is around here]order by (if (name(.) = 'orderData') then $x else -$x)            return $x          )[1]         )
orderBy64,Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results>{              for $x in /DataValues/NegativeNumbers/orderData/xs:decimal(.)               order by $x ascending collation "http://www.w3.org/2005/xpath-functions/collation/codepoint"              where $x > -1000             return $x }         </results>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results>{              for $x in /DataValues/NegativeNumbers/orderData/xs:decimal(.)               [Error is around here]order by $x ascending collation "http://www.w3.org/2005/xpath-functions/collation/codepoint"              where $x > -1000             return $x }         </results>
orderBy65,Error: XPST0003: Unable to parse XPath: "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results>{              for $x in /DataValues/NegativeNumbers/orderData/xs:decimal(.)              order by $x descending collation "http://www.w3.org/2005/xpath-functions/collation/codepoint"              order by $x ascending collation "http://www.w3.org/2005/xpath-functions/collation/codepoint"              where $x > -1000             return $x }         </results>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results>{              for $x in /DataValues/NegativeNumbers/orderData/xs:decimal(.)              [Error is around here]order by $x descending collation "http://www.w3.org/2005/xpath-functions/collation/codepoint"              order by $x ascending collation "http://www.w3.org/2005/xpath-functions/collation/codepoint"              where $x > -1000             return $x }         </results>
orderBy66,Error: XPST0003: Unable to parse XPath: "deep-equal((         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";                for $i in 1 to 100             order by -$i             count $count             let $e := <e i="{$i}" pos="{$count}"/>             order by number($e/@i)             where $count gt 90             return $e!@pos!number()        ), (100, 99, 98, 97, 96, 95, 94, 93, 92, 91))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found. deep-equal((         declare [Error is around here]default element namespace "http://www.w3.org/XQueryTestOrderBy";                for $i in 1 to 100             order by -$i             count $count             let $e := <e i="{$i}" pos="{$count}"/>             order by number($e/@i)             where $count gt 90             return $e!@pos!number()        ), (100, 99, 98, 97, 96, 95, 94, 93, 92, 91))
orderBy67,Error: XPST0003: Unable to parse XPath: "deep-equal((          for $j in (text{'Az'}, text{'Bx'}, text{'Cy'})           order by $j/substring(., $j/string-length(.))           return $j/string()       ), ("Bx", "Cy", "Az"))". Expected "!", "!=", "#", "(", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. deep-equal((          for $j in (text[Error is around here]{'Az'}, text{'Bx'}, text{'Cy'})           order by $j/substring(., $j/string-length(.))           return $j/string()       ), ("Bx", "Cy", "Az"))
orderBy68,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "\n         declare variable $in := <in><e on="2017-09-18"/><e on="2016-04-15"/><e on="2012-07-09"/></in>;\n         for $j in ($in//e/@on, xs:date(\'1999-12-17\')) \n         order by $j \n         return $j\n      ".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.\n\n         declare variable $in := <in><e on="2017-09-18"/><e on="2016-04-15"/><e on="2012-07-09"/></in>;\n         for $j in ($in//e/@on, xs:date(\'1999-12-17\')) \n         [Error is around here]order by $j \n         return $j\n      '
orderbylocal-1,Error: XPST0003: Unable to parse XPath: "<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String",         "I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String",         "U String","V String","W String","X String","Y String","Z String") order by xs:string($x)          ascending return xs:string($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String",         "I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String",         "U String","V String","W String","X String","Y String","Z String") [Error is around here]order by xs:string($x)          ascending return xs:string($x) } </results>
orderbylocal-2,Error: XPST0003: Unable to parse XPath: "<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String",         "I String","J String","K String","L String","M String","N String","O String","P String","R String","S String",         "T String","U String","V String","W String","X String","Y String","Z String") order by xs:string($x)          descending return xs:string($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String",         "I String","J String","K String","L String","M String","N String","O String","P String","R String","S String",         "T String","U String","V String","W String","X String","Y String","Z String") [Error is around here]order by xs:string($x)          descending return xs:string($x) } </results>
orderbylocal-3,Error: XPST0003: Unable to parse XPath: "<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String",         "I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String",         "U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"()")          ascending return concat(xs:string($x),"()") } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String",         "I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String",         "U String","V String","W String","X String","Y String","Z String") [Error is around here]order by concat(xs:string($x),"()")          ascending return concat(xs:string($x),"()") } </results>
orderbylocal-4,Error: XPST0003: Unable to parse XPath: "<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"()") descending return concat(xs:string($x),"()") } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") [Error is around here]order by concat(xs:string($x),"()") descending return concat(xs:string($x),"()") } </results>
orderbylocal-5,Error: XPST0003: Unable to parse XPath: "<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"another String After") ascending return concat(xs:string($x),"another String After") } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") [Error is around here]order by concat(xs:string($x),"another String After") ascending return concat(xs:string($x),"another String After") } </results>
orderbylocal-6,Error: XPST0003: Unable to parse XPath: "<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"another String After") descending return concat(xs:string($x),"another String After") } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") [Error is around here]order by concat(xs:string($x),"another String After") descending return concat(xs:string($x),"another String After") } </results>
orderbylocal-7,Error: XPST0003: Unable to parse XPath: "<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat("another String Before",xs:string($x)) ascending return concat("another String Before",xs:string($x)) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") [Error is around here]order by concat("another String Before",xs:string($x)) ascending return concat("another String Before",xs:string($x)) } </results>
orderbylocal-8,Error: XPST0003: Unable to parse XPath: "<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat("another String Before",xs:string($x)) descending return concat("another String Before",xs:string($x)) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") [Error is around here]order by concat("another String Before",xs:string($x)) descending return concat("another String Before",xs:string($x)) } </results>
orderbylocal-9,Error: XPST0003: Unable to parse XPath: "<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"") descending return concat(xs:string($x),"") } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") [Error is around here]order by concat(xs:string($x),"") descending return concat(xs:string($x),"") } </results>
orderbylocal-10,Error: XPST0003: Unable to parse XPath: "<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"") ascending return concat(xs:string($x),"") } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") [Error is around here]order by concat(xs:string($x),"") ascending return concat(xs:string($x),"") } </results>
orderbylocal-11,Error: XPST0003: Unable to parse XPath: "<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat("",xs:string($x)) descending return concat("",xs:string($x)) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") [Error is around here]order by concat("",xs:string($x)) descending return concat("",xs:string($x)) } </results>
orderbylocal-12,Error: XPST0003: Unable to parse XPath: "<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat("",xs:string($x)) ascending return concat("",xs:string($x)) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") [Error is around here]order by concat("",xs:string($x)) ascending return concat("",xs:string($x)) } </results>
orderbylocal-16,Error: XPST0003: Unable to parse XPath: "<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),xs:string($x)) ascending return concat(xs:string($x),xs:string($x)) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") [Error is around here]order by concat(xs:string($x),xs:string($x)) ascending return concat(xs:string($x),xs:string($x)) } </results>
orderbylocal-17,Error: XPST0003: Unable to parse XPath: "<results> { for $x in("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by string-length(xs:string($x)) ascending return string-length(xs:string($x)) } </results>". Expected " ", "(:", "\n", "\r", or "\t" but "(" found. <results> { for $x in[Error is around here]("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by string-length(xs:string($x)) ascending return string-length(xs:string($x)) } </results>
orderbylocal-18,Error: XPST0003: Unable to parse XPath: "<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by count(xs:string($x)) ascending return count(xs:string($x)) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") [Error is around here]order by count(xs:string($x)) ascending return count(xs:string($x)) } </results>
orderbylocal-19,Error: XPST0003: Unable to parse XPath: "<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by string-length(xs:string($x)) ascending return string-length(xs:string($x)) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") [Error is around here]order by string-length(xs:string($x)) ascending return string-length(xs:string($x)) } </results>
orderbylocal-20,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by xs:decimal($x) ascending return xs:decimal($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) [Error is around here]order by xs:decimal($x) ascending return xs:decimal($x) } </results>
orderbylocal-21,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by xs:decimal($x) descending return xs:decimal($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) [Error is around here]order by xs:decimal($x) descending return xs:decimal($x) } </results>
orderbylocal-22,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by (xs:decimal($x) + xs:decimal($x)) descending return xs:decimal($x) + xs:decimal($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) [Error is around here]order by (xs:decimal($x) + xs:decimal($x)) descending return xs:decimal($x) + xs:decimal($x) } </results>
orderbylocal-25,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by xs:float($x) descending return xs:float($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) [Error is around here]order by xs:float($x) descending return xs:float($x) } </results>
orderbylocal-26,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by xs:decimal($x) descending return xs:decimal($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) [Error is around here]order by xs:decimal($x) descending return xs:decimal($x) } </results>
orderbylocal-27,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by xs:double($x) descending return xs:double($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) [Error is around here]order by xs:double($x) descending return xs:double($x) } </results>
orderbylocal-28,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by xs:integer($x) descending return xs:integer($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) [Error is around here]order by xs:integer($x) descending return xs:integer($x) } </results>
orderbylocal-29,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by (xs:decimal($x) * -1) descending return (xs:decimal($x) * -1) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) [Error is around here]order by (xs:decimal($x) * -1) descending return (xs:decimal($x) * -1) } </results>
orderbylocal-30,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by xs:decimal($x) ascending return xs:decimal($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) [Error is around here]order by xs:decimal($x) ascending return xs:decimal($x) } </results>
orderbylocal-31,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by xs:decimal($x) descending return xs:decimal($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) [Error is around here]order by xs:decimal($x) descending return xs:decimal($x) } </results>
orderbylocal-32,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by (xs:decimal($x) + xs:decimal($x)) descending return xs:decimal($x) + xs:decimal($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) [Error is around here]order by (xs:decimal($x) + xs:decimal($x)) descending return xs:decimal($x) + xs:decimal($x) } </results>
orderbylocal-35,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by xs:float($x) descending return xs:float($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) [Error is around here]order by xs:float($x) descending return xs:float($x) } </results>
orderbylocal-36,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by xs:decimal($x) descending return xs:decimal($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) [Error is around here]order by xs:decimal($x) descending return xs:decimal($x) } </results>
orderbylocal-37,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by xs:double($x) descending return xs:double($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) [Error is around here]order by xs:double($x) descending return xs:double($x) } </results>
orderbylocal-38,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by xs:integer($x) descending return xs:integer($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) [Error is around here]order by xs:integer($x) descending return xs:integer($x) } </results>
orderbylocal-39,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by string($x) ascending return string($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) [Error is around here]order by string($x) ascending return string($x) } </results>
orderbylocal-40,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) order by $x ascending return $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) [Error is around here]order by $x ascending return $x } </results>
orderbylocal-41,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) order by xs:decimal($x) descending return xs:decimal($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) [Error is around here]order by xs:decimal($x) descending return xs:decimal($x) } </results>
orderbylocal-42,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) order by (xs:decimal($x) + xs:decimal($x)) descending return xs:decimal($x) + xs:decimal($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) [Error is around here]order by (xs:decimal($x) + xs:decimal($x)) descending return xs:decimal($x) + xs:decimal($x) } </results>
orderbylocal-43,Error: XPST0003: Unable to parse XPath: "<results>{ for $x in (<a>0.000000000000000001</a>,<a>0.00000000000000001</a>,<a>0.0000000000000001</a>,<a>0.000000000000001</a>,<a>0.00000000000001</a>,<a>0.0000000000001</a>,<a>0.000000000001</a>,<a>0.00000000001</a>,<a>0.0000000001</a>,<a>0.000000001</a>,<a>0.00000001</a>,<a>0.0000001</a>,<a>0.000001</a>,<a>0.00001</a>,<a>0.0001</a>,<a>0.001</a>,<a>0.01</a>,<a>0.1</a>,<a>0.0</a>) order by $x is $x ascending return $x is $x}</results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results>{ for $x in (<a>0.000000000000000001</a>,<a>0.00000000000000001</a>,<a>0.0000000000000001</a>,<a>0.000000000000001</a>,<a>0.00000000000001</a>,<a>0.0000000000001</a>,<a>0.000000000001</a>,<a>0.00000000001</a>,<a>0.0000000001</a>,<a>0.000000001</a>,<a>0.00000001</a>,<a>0.0000001</a>,<a>0.000001</a>,<a>0.00001</a>,<a>0.0001</a>,<a>0.001</a>,<a>0.01</a>,<a>0.1</a>,<a>0.0</a>) [Error is around here]order by $x is $x ascending return $x is $x}</results>
orderbylocal-44,Error: XPST0003: Unable to parse XPath: "<results>{ for $x in (<a>0.000000000000000001</a>,<a>0.00000000000000001</a>,<a>0.0000000000000001</a>,<a>0.000000000000001</a>,<a>0.00000000000001</a>,<a>0.0000000000001</a>,<a>0.000000000001</a>,<a>0.00000000001</a>,<a>0.0000000001</a>,<a>0.000000001</a>,<a>0.00000001</a>,<a>0.0000001</a>,<a>0.000001</a>,<a>0.00001</a>,<a>0.0001</a>,<a>0.001</a>,<a>0.01</a>,<a>0.1</a>,<a>0.0</a>) order by $x is $x descending return $x is $x }</results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results>{ for $x in (<a>0.000000000000000001</a>,<a>0.00000000000000001</a>,<a>0.0000000000000001</a>,<a>0.000000000000001</a>,<a>0.00000000000001</a>,<a>0.0000000000001</a>,<a>0.000000000001</a>,<a>0.00000000001</a>,<a>0.0000000001</a>,<a>0.000000001</a>,<a>0.00000001</a>,<a>0.0000001</a>,<a>0.000001</a>,<a>0.00001</a>,<a>0.0001</a>,<a>0.001</a>,<a>0.01</a>,<a>0.1</a>,<a>0.0</a>) [Error is around here]order by $x is $x descending return $x is $x }</results>
orderbylocal-45,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) order by xs:float($x) descending return xs:float($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) [Error is around here]order by xs:float($x) descending return xs:float($x) } </results>
orderbylocal-46,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) order by xs:decimal($x) descending return xs:decimal($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) [Error is around here]order by xs:decimal($x) descending return xs:decimal($x) } </results>
orderbylocal-47,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) order by xs:double($x) descending return xs:double($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) [Error is around here]order by xs:double($x) descending return xs:double($x) } </results>
orderbylocal-49,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) order by string($x) ascending return string($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) [Error is around here]order by string($x) ascending return string($x) } </results>
orderbylocal-50,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) order by xs:decimal($x) ascending return xs:decimal($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) [Error is around here]order by xs:decimal($x) ascending return xs:decimal($x) } </results>
orderbylocal-51,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) order by xs:decimal($x) descending return xs:decimal($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) [Error is around here]order by xs:decimal($x) descending return xs:decimal($x) } </results>
orderbylocal-52,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) order by (xs:decimal($x) + xs:decimal($x)) descending return xs:decimal($x) + xs:decimal($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) [Error is around here]order by (xs:decimal($x) + xs:decimal($x)) descending return xs:decimal($x) + xs:decimal($x) } </results>
orderbylocal-55,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) order by xs:float($x) descending return xs:float($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) [Error is around here]order by xs:float($x) descending return xs:float($x) } </results>
orderbylocal-56,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) order by xs:decimal($x) descending return xs:decimal($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) [Error is around here]order by xs:decimal($x) descending return xs:decimal($x) } </results>
orderbylocal-57,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) order by xs:double($x) descending return xs:double($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) [Error is around here]order by xs:double($x) descending return xs:double($x) } </results>
orderbylocal-59,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) order by string($x) ascending return string($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) [Error is around here]order by string($x) ascending return string($x) } </results>
orderbylocal-60,AssertionError: expected [Function] to throw error including 'XQST0076' but got 'XPST0003: Unable to parse XPath: "for $x in ("A","B","C") order by string($x) ascending collation "http://nonexistentcollition.org/ifsupportedwoooayouarethebestQueryimplementation/makeitharder" return string($x)".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.\nfor $x in ("A","B","C") [Error is around here]order by string($x) ascending collation "http://nonexistentcollition.org/ifsupportedwoooayouarethebestQueryimplementation/makeitharder" return string($x)'
orderbywithout-1,Error: XPST0003: Unable to parse XPath: "<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by xs:string($x) return xs:string($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") [Error is around here]order by xs:string($x) return xs:string($x) } </results>
orderbywithout-2,Error: XPST0003: Unable to parse XPath: "<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"()") return concat(xs:string($x),"()") } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") [Error is around here]order by concat(xs:string($x),"()") return concat(xs:string($x),"()") } </results>
orderbywithout-3,Error: XPST0003: Unable to parse XPath: "<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"another String After") return concat(xs:string($x),"another String After") } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") [Error is around here]order by concat(xs:string($x),"another String After") return concat(xs:string($x),"another String After") } </results>
orderbywithout-4,Error: XPST0003: Unable to parse XPath: "<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat("another String Before",xs:string($x)) return concat("another String Before",xs:string($x)) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") [Error is around here]order by concat("another String Before",xs:string($x)) return concat("another String Before",xs:string($x)) } </results>
orderbywithout-5,Error: XPST0003: Unable to parse XPath: "<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"") return concat(xs:string($x),"") } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") [Error is around here]order by concat(xs:string($x),"") return concat(xs:string($x),"") } </results>
orderbywithout-6,Error: XPST0003: Unable to parse XPath: "<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat("",xs:string($x)) return concat("",xs:string($x)) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") [Error is around here]order by concat("",xs:string($x)) return concat("",xs:string($x)) } </results>
orderbywithout-7,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (<a>A String</a>,<a>B String</a>,<a>C String</a>,<a>D String</a>,<a>E String</a>,<a>F String</a>,<a>G String</a>,<a>H String</a>,<a>I String</a>, <a>J String</a>,<a>K String</a>,<a>L String</a>,<a>M String</a>,<a>N String</a>,<a>O String</a>,<a>P String</a>,<a>R String</a>,<a>S String</a>,<a>T String</a>, <a>U String</a>,<a>V String</a>,<a>W String</a>,<a>X String</a>,<a>Y String</a>,<a>Z String</a>) order by $x is $x return $x is $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (<a>A String</a>,<a>B String</a>,<a>C String</a>,<a>D String</a>,<a>E String</a>,<a>F String</a>,<a>G String</a>,<a>H String</a>,<a>I String</a>, <a>J String</a>,<a>K String</a>,<a>L String</a>,<a>M String</a>,<a>N String</a>,<a>O String</a>,<a>P String</a>,<a>R String</a>,<a>S String</a>,<a>T String</a>, <a>U String</a>,<a>V String</a>,<a>W String</a>,<a>X String</a>,<a>Y String</a>,<a>Z String</a>) [Error is around here]order by $x is $x return $x is $x } </results>
orderbywithout-8,Error: XPST0003: Unable to parse XPath: "<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),xs:string($x)) return concat(xs:string($x),xs:string($x)) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") [Error is around here]order by concat(xs:string($x),xs:string($x)) return concat(xs:string($x),xs:string($x)) } </results>
orderbywithout-9,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (<a>A String</a>,<a>B String</a>,<a>C String</a>,<a>D String</a>,<a>E String</a>,<a>F String</a>,<a>G String</a>,<a>H String</a>,<a>I String</a>, <a>J String</a>,<a>K String</a>,<a>L String</a>,<a>M String</a>,<a>N String</a>,<a>O String</a>,<a>P String</a>,<a>R String</a>,<a>S String</a>,<a>T String</a>, <a>U String</a>,<a>V String</a>,<a>W String</a>,<a>X String</a>,<a>Y String</a>,<a>Z String</a>) order by string-length($x) return string-length($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (<a>A String</a>,<a>B String</a>,<a>C String</a>,<a>D String</a>,<a>E String</a>,<a>F String</a>,<a>G String</a>,<a>H String</a>,<a>I String</a>, <a>J String</a>,<a>K String</a>,<a>L String</a>,<a>M String</a>,<a>N String</a>,<a>O String</a>,<a>P String</a>,<a>R String</a>,<a>S String</a>,<a>T String</a>, <a>U String</a>,<a>V String</a>,<a>W String</a>,<a>X String</a>,<a>Y String</a>,<a>Z String</a>) [Error is around here]order by string-length($x) return string-length($x) } </results>
orderbywithout-10,Error: XPST0003: Unable to parse XPath: "<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by count(xs:string($x)) return count(xs:string($x)) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") [Error is around here]order by count(xs:string($x)) return count(xs:string($x)) } </results>
orderbywithout-11,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by xs:decimal($x) return xs:decimal($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) [Error is around here]order by xs:decimal($x) return xs:decimal($x) } </results>
orderbywithout-12,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by (xs:decimal($x) + xs:decimal($x)) return xs:decimal($x) + xs:decimal($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) [Error is around here]order by (xs:decimal($x) + xs:decimal($x)) return xs:decimal($x) + xs:decimal($x) } </results>
orderbywithout-13,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (<orderData>-100000000000000000</orderData>,<orderData>-10000000000000000</orderData>,<orderData>-1000000000000000</orderData>,<orderData>-100000000000000</orderData>, <orderData>-10000000000000</orderData>,<orderData>-1000000000000</orderData>,<orderData>-100000000000</orderData>,<orderData>-10000000000</orderData>,<orderData>-1000000000</orderData>, <orderData>-100000000</orderData>,<orderData>-10000000</orderData>,<orderData>-1000000</orderData>,<orderData>-100000</orderData>,<orderData>-10000</orderData>,<orderData>-1000</orderData>, <orderData>-100</orderData>,<orderData>-10</orderData>,<orderData>-1</orderData>,<orderData>-0</orderData>) order by $x is $x return $x is $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (<orderData>-100000000000000000</orderData>,<orderData>-10000000000000000</orderData>,<orderData>-1000000000000000</orderData>,<orderData>-100000000000000</orderData>, <orderData>-10000000000000</orderData>,<orderData>-1000000000000</orderData>,<orderData>-100000000000</orderData>,<orderData>-10000000000</orderData>,<orderData>-1000000000</orderData>, <orderData>-100000000</orderData>,<orderData>-10000000</orderData>,<orderData>-1000000</orderData>,<orderData>-100000</orderData>,<orderData>-10000</orderData>,<orderData>-1000</orderData>, <orderData>-100</orderData>,<orderData>-10</orderData>,<orderData>-1</orderData>,<orderData>-0</orderData>) [Error is around here]order by $x is $x return $x is $x } </results>
orderbywithout-14,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by xs:float($x) return xs:float($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) [Error is around here]order by xs:float($x) return xs:float($x) } </results>
orderbywithout-15,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by xs:double($x) return xs:double($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) [Error is around here]order by xs:double($x) return xs:double($x) } </results>
orderbywithout-16,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by xs:integer($x) return xs:integer($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) [Error is around here]order by xs:integer($x) return xs:integer($x) } </results>
orderbywithout-17,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by (xs:decimal($x) * -1) return (xs:decimal($x) * -1) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) [Error is around here]order by (xs:decimal($x) * -1) return (xs:decimal($x) * -1) } </results>
orderbywithout-18,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by xs:decimal($x) return xs:decimal($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) [Error is around here]order by xs:decimal($x) return xs:decimal($x) } </results>
orderbywithout-19,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by (xs:decimal($x) + xs:decimal($x)) return xs:decimal($x) + xs:decimal($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) [Error is around here]order by (xs:decimal($x) + xs:decimal($x)) return xs:decimal($x) + xs:decimal($x) } </results>
orderbywithout-20,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (<orderData>100000000000000000</orderData>,<orderData>10000000000000000</orderData>,<orderData>1000000000000000</orderData>, <orderData>100000000000000</orderData>,<orderData>10000000000000</orderData>,<orderData>1000000000000</orderData>,<orderData>100000000000</orderData>, <orderData>10000000000</orderData>,<orderData>1000000000</orderData>,<orderData>100000000</orderData>,<orderData>10000000</orderData>, <orderData>1000000</orderData>,<orderData>100000</orderData>,<orderData>10000</orderData>,<orderData>1000</orderData>,<orderData>100</orderData>, <orderData>10</orderData>,<orderData>1</orderData>,<orderData>0</orderData>) order by $x is $x return $x is $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (<orderData>100000000000000000</orderData>,<orderData>10000000000000000</orderData>,<orderData>1000000000000000</orderData>, <orderData>100000000000000</orderData>,<orderData>10000000000000</orderData>,<orderData>1000000000000</orderData>,<orderData>100000000000</orderData>, <orderData>10000000000</orderData>,<orderData>1000000000</orderData>,<orderData>100000000</orderData>,<orderData>10000000</orderData>, <orderData>1000000</orderData>,<orderData>100000</orderData>,<orderData>10000</orderData>,<orderData>1000</orderData>,<orderData>100</orderData>, <orderData>10</orderData>,<orderData>1</orderData>,<orderData>0</orderData>) [Error is around here]order by $x is $x return $x is $x } </results>
orderbywithout-21,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by xs:float($x) return xs:float($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) [Error is around here]order by xs:float($x) return xs:float($x) } </results>
orderbywithout-22,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by xs:decimal($x) return xs:decimal($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) [Error is around here]order by xs:decimal($x) return xs:decimal($x) } </results>
orderbywithout-23,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by xs:double($x) return xs:double($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) [Error is around here]order by xs:double($x) return xs:double($x) } </results>
orderbywithout-24,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by xs:integer($x) return xs:integer($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) [Error is around here]order by xs:integer($x) return xs:integer($x) } </results>
orderbywithout-25,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by string($x) return string($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) [Error is around here]order by string($x) return string($x) } </results>
orderbywithout-26,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) order by $x return $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) [Error is around here]order by $x return $x } </results>
orderbywithout-27,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) order by xs:decimal($x) return xs:decimal($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) [Error is around here]order by xs:decimal($x) return xs:decimal($x) } </results>
orderbywithout-28,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) order by (xs:decimal($x) + xs:decimal($x)) return xs:decimal($x) + xs:decimal($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) [Error is around here]order by (xs:decimal($x) + xs:decimal($x)) return xs:decimal($x) + xs:decimal($x) } </results>
orderbywithout-29,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (<orderData>0.000000000000000001</orderData>,<orderData>0.00000000000000001</orderData>,<orderData>0.0000000000000001</orderData>,<orderData>0.000000000000001</orderData>, <orderData>0.00000000000001</orderData>,<orderData>0.0000000000001</orderData>,<orderData>0.000000000001</orderData>,<orderData>0.00000000001</orderData>,<orderData>0.0000000001</orderData>, <orderData>0.000000001</orderData>,<orderData>0.00000001</orderData>,<orderData>0.0000001</orderData>,<orderData>0.000001</orderData>,<orderData>0.00001</orderData>, <orderData>0.0001</orderData>,<orderData>0.001</orderData>,<orderData>0.01</orderData>,<orderData>0.1</orderData>,<orderData>0.0</orderData>) order by $x is $x return $x is $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (<orderData>0.000000000000000001</orderData>,<orderData>0.00000000000000001</orderData>,<orderData>0.0000000000000001</orderData>,<orderData>0.000000000000001</orderData>, <orderData>0.00000000000001</orderData>,<orderData>0.0000000000001</orderData>,<orderData>0.000000000001</orderData>,<orderData>0.00000000001</orderData>,<orderData>0.0000000001</orderData>, <orderData>0.000000001</orderData>,<orderData>0.00000001</orderData>,<orderData>0.0000001</orderData>,<orderData>0.000001</orderData>,<orderData>0.00001</orderData>, <orderData>0.0001</orderData>,<orderData>0.001</orderData>,<orderData>0.01</orderData>,<orderData>0.1</orderData>,<orderData>0.0</orderData>) [Error is around here]order by $x is $x return $x is $x } </results>
orderbywithout-30,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) order by xs:float($x) return xs:float($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) [Error is around here]order by xs:float($x) return xs:float($x) } </results>
orderbywithout-31,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) order by xs:decimal($x) return xs:decimal($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) [Error is around here]order by xs:decimal($x) return xs:decimal($x) } </results>
orderbywithout-32,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) order by xs:double($x) return xs:double($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) [Error is around here]order by xs:double($x) return xs:double($x) } </results>
orderbywithout-33,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) order by string($x) return string($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) [Error is around here]order by string($x) return string($x) } </results>
orderbywithout-34,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) order by xs:decimal($x) return xs:decimal($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) [Error is around here]order by xs:decimal($x) return xs:decimal($x) } </results>
orderbywithout-35,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) order by (xs:decimal($x) + xs:decimal($x)) return xs:decimal($x) + xs:decimal($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) [Error is around here]order by (xs:decimal($x) + xs:decimal($x)) return xs:decimal($x) + xs:decimal($x) } </results>
orderbywithout-36,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (<orderData>-0.000000000000000001</orderData>,<orderData>-0.00000000000000001</orderData>,<orderData>-0.0000000000000001</orderData>,<orderData>-0.000000000000001</orderData>,<orderData>-0.00000000000001</orderData>,<orderData>-0.0000000000001</orderData>, <orderData>-0.000000000001</orderData>,<orderData>-0.00000000001</orderData>,<orderData>-0.0000000001</orderData>,<orderData>-0.000000001</orderData>, <orderData>-0.00000001</orderData>,<orderData>-0.0000001</orderData>,<orderData>-0.000001</orderData>,<orderData>-0.00001</orderData>,<orderData>-0.0001</orderData>,<orderData>-0.001</orderData>,<orderData>-0.01</orderData>,<orderData>-0.0</orderData>, <orderData>-0.1</orderData>) order by $x is $x return $x is $x } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (<orderData>-0.000000000000000001</orderData>,<orderData>-0.00000000000000001</orderData>,<orderData>-0.0000000000000001</orderData>,<orderData>-0.000000000000001</orderData>,<orderData>-0.00000000000001</orderData>,<orderData>-0.0000000000001</orderData>, <orderData>-0.000000000001</orderData>,<orderData>-0.00000000001</orderData>,<orderData>-0.0000000001</orderData>,<orderData>-0.000000001</orderData>, <orderData>-0.00000001</orderData>,<orderData>-0.0000001</orderData>,<orderData>-0.000001</orderData>,<orderData>-0.00001</orderData>,<orderData>-0.0001</orderData>,<orderData>-0.001</orderData>,<orderData>-0.01</orderData>,<orderData>-0.0</orderData>, <orderData>-0.1</orderData>) [Error is around here]order by $x is $x return $x is $x } </results>
orderbywithout-37,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) order by xs:float($x) return xs:float($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) [Error is around here]order by xs:float($x) return xs:float($x) } </results>
orderbywithout-38,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) order by xs:decimal($x) return xs:decimal($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) [Error is around here]order by xs:decimal($x) return xs:decimal($x) } </results>
orderbywithout-39,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) order by xs:double($x) return xs:double($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) [Error is around here]order by xs:double($x) return xs:double($x) } </results>
orderbywithout-40,Error: XPST0003: Unable to parse XPath: "<results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) order by string($x) return string($x) } </results>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) [Error is around here]order by string($x) return string($x) } </results>
K2-OrderbyExprWithout-1,Error: XPST0003: Unable to parse XPath: "declare base-uri "http://www.w3.org/2005/xpath-functions/"; let $i as xs:integer* := (1, 2, 3) order by 1 collation "collation/codepoint" return $i". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. declare base-uri "http://www.w3.org/2005/xpath-functions/"; let $i [Error is around here]as xs:integer* := (1, 2, 3) order by 1 collation "collation/codepoint" return $i
K2-OrderbyExprWithout-2,AssertionError: expected [Function] to throw error including 'XQST0076' but got 'XPST0003: Unable to parse XPath: "declare base-uri "http://www.w3.org/2005/xpath-functions/"; let $i as xs:integer* := (1, 2, 3) order by 1 collation "collation/" return $i".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\ndeclare base-uri "http://www.w3.org/2005/xpath-functions/"; let $i [Error is around here]as xs:integer* := (1, 2, 3) order by 1 collation "collation/" return $i'
K2-OrderbyExprWithout-3,AssertionError: expected [Function] to throw error including 'XQST0076' but got 'XPST0003: Unable to parse XPath: "declare base-uri "http://www.w3.org/2005/xpath-functions/"; let $i as xs:integer* := (1, 2, 3) order by 1 collation "collation/" return $i".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\ndeclare base-uri "http://www.w3.org/2005/xpath-functions/"; let $i [Error is around here]as xs:integer* := (1, 2, 3) order by 1 collation "collation/" return $i'
K2-OrderbyExprWithout-5,Error: XPST0003: Unable to parse XPath: "for $i in (1, 3, 2) order by $i return $i". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. for $i in (1, 3, 2) [Error is around here]order by $i return $i
K2-OrderbyExprWithout-6,Error: XPST0003: Unable to parse XPath: "for $i in (1, 3, 2) order by $i return ($i, 2)". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. for $i in (1, 3, 2) [Error is around here]order by $i return ($i, 2)
K2-OrderbyExprWithout-8,AssertionError: Expected executing the XPath "let $i := (1, 3, 2) order by $i return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "let $i := (1, 3, 2) order by $i return $i". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. let $i := (1, 3, 2) [Error is around here]order by $i return $i, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "let $i := (1, 3, 2) order by $i return $i".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.\nlet $i := (1, 3, 2) [Error is around here]order by $i return $i'.
K2-OrderbyExprWithout-9,AssertionError: Expected executing the XPath "let $i := (1, 3, 2), $b := (4, 6, 5) order by $b return $b" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "let $i := (1, 3, 2), $b := (4, 6, 5) order by $b return $b". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. let $i := (1, 3, 2), $b := (4, 6, 5) [Error is around here]order by $b return $b, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "let $i := (1, 3, 2), $b := (4, 6, 5) order by $b return $b".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.\nlet $i := (1, 3, 2), $b := (4, 6, 5) [Error is around here]order by $b return $b'.
K2-OrderbyExprWithout-10,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "for $a in (1, 4, 2) let $i := (1, $a, 2) order by $i return $i".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.\nfor $a in (1, 4, 2) [Error is around here]let $i := (1, $a, 2) order by $i return $i'
K2-OrderbyExprWithout-11,Error: XPST0003: Unable to parse XPath: "for $a in (1, 4, 2) let $i := (1, 3, 2) order by $a return $i". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. for $a in (1, 4, 2) [Error is around here]let $i := (1, 3, 2) order by $a return $i
K2-OrderbyExprWithout-12,Error: XPST0003: Unable to parse XPath: "for $a in (3, 2, 1), $b in (6, 5, 4) order by $a return $a". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. for $a in (3, 2, 1), $b in (6, 5, 4) [Error is around here]order by $a return $a
K2-OrderbyExprWithout-13,Error: XPST0003: Unable to parse XPath: "for $a in (3, 2, 1), $b in (6, 5, 4) stable order by $b return $a". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found. for $a in (3, 2, 1), $b in (6, 5, 4) [Error is around here]stable order by $b return $a
K2-OrderbyExprWithout-14,Error: XPST0003: Unable to parse XPath: "declare variable $e := <e> <a>3</a> <a>2</a> <a>1</a> </e>; <result> { avg(for $i in $e/a order by $i return $i) } </result>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare variable $e := <e> <a>3</a> <a>2</a> <a>1</a> </e>; <result> { avg(for $i in $e/a [Error is around here]order by $i return $i) } </result>
K2-OrderbyExprWithout-15,AssertionError: expected [Function] to throw error including 'FORG0005' but got 'XPST0003: Unable to parse XPath: "declare variable $e := <e> <a>3</a> <a>2</a> <a>1</a> </e>; exactly-one(for $i in $e/a order by $i return $i)".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.\ndeclare variable $e := <e> <a>3</a> <a>2</a> <a>1</a> </e>; exactly-one(for $i in $e/a [Error is around here]order by $i return $i)'
K2-OrderbyExprWithout-16,Error: XPST0003: Unable to parse XPath: "for $i in (false(), true(), true(), false(), true(), false()) order by $i return $i". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. for $i in (false(), true(), true(), false(), true(), false()) [Error is around here]order by $i return $i
K2-OrderbyExprWithout-17,Error: XPST0003: Unable to parse XPath: "boolean((for $i in (false(), true(), true(), false(), true(), false()) order by $i return $i)[1])". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. boolean((for $i in (false(), true(), true(), false(), true(), false()) [Error is around here]order by $i return $i)[1])
K2-OrderbyExprWithout-18,Error: XPST0003: Unable to parse XPath: "(for $i in current-time() order by $i return $i) eq current-time()". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. (for $i in current-time() [Error is around here]order by $i return $i) eq current-time()
K2-OrderbyExprWithout-19,AssertionError: Expected executing the XPath "let $i := (1, 3, 2) order by $i return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "let $i := (1, 3, 2) order by $i return $i". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. let $i := (1, 3, 2) [Error is around here]order by $i return $i, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "let $i := (1, 3, 2) order by $i return $i".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.\nlet $i := (1, 3, 2) [Error is around here]order by $i return $i'.
K2-OrderbyExprWithout-20,AssertionError: Expected executing the XPath "let $i := (<e>1</e>, <e>3</e>, <e>2</e>) order by $i return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "let $i := (<e>1</e>, <e>3</e>, <e>2</e>) order by $i return $i". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. let $i := (<e>1</e>, <e>3</e>, <e>2</e>) [Error is around here]order by $i return $i, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "let $i := (<e>1</e>, <e>3</e>, <e>2</e>) order by $i return $i".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.\nlet $i := (<e>1</e>, <e>3</e>, <e>2</e>) [Error is around here]order by $i return $i'.
K2-OrderbyExprWithout-21,Error: XPST0003: Unable to parse XPath: "let $i := (<e>1</e>, <e>3</e>, <e>2</e>) order by 1 return $i". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. let $i := (<e>1</e>, <e>3</e>, <e>2</e>) [Error is around here]order by 1 return $i
K2-OrderbyExprWithout-22,AssertionError: Expected executing the XPath "for $i in (1, 3, 2) let $c := 3 stable order by () return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "for $i in (1, 3, 2) let $c := 3 stable order by () return $i". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. for $i in (1, 3, 2) [Error is around here]let $c := 3 stable order by () return $i, Error: XPST0003: Unable to parse XPath: "for $i in (1, 3, 2) let $c := 3 stable order by () return $i". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. for $i in (1, 3, 2) [Error is around here]let $c := 3 stable order by () return $i, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "for $i in (1, 3, 2) let $c := 3 stable order by () return $i".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.\nfor $i in (1, 3, 2) [Error is around here]let $c := 3 stable order by () return $i'.
K2-OrderbyExprWithout-23,AssertionError: Expected executing the XPath "let $i := (1, 3, 2) stable order by $i return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "let $i := (1, 3, 2) stable order by $i return $i". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found. let $i := (1, 3, 2) [Error is around here]stable order by $i return $i, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "let $i := (1, 3, 2) stable order by $i return $i".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found.\nlet $i := (1, 3, 2) [Error is around here]stable order by $i return $i'.
K2-OrderbyExprWithout-24,AssertionError: Expected executing the XPath "let $i := (<e>1</e>, <e>3</e>, <e>2</e>) stable order by $i return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "let $i := (<e>1</e>, <e>3</e>, <e>2</e>) stable order by $i return $i". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found. let $i := (<e>1</e>, <e>3</e>, <e>2</e>) [Error is around here]stable order by $i return $i, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "let $i := (<e>1</e>, <e>3</e>, <e>2</e>) stable order by $i return $i".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found.\nlet $i := (<e>1</e>, <e>3</e>, <e>2</e>) [Error is around here]stable order by $i return $i'.
K2-OrderbyExprWithout-25,AssertionError: Expected executing the XPath "let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) stable order by $i return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) stable order by $i return $i". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found. let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) [Error is around here]stable order by $i return $i, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) stable order by $i return $i".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found.\nlet $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) [Error is around here]stable order by $i return $i'.
K2-OrderbyExprWithout-26,AssertionError: Expected executing the XPath "let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) order by $i return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) order by $i return $i". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) [Error is around here]order by $i return $i, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) order by $i return $i".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.\nlet $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) [Error is around here]order by $i return $i'.
K2-OrderbyExprWithout-27,AssertionError: Expected executing the XPath "let $i := (xs:date("2001-02-03"), xs:time("01:02:03Z")) stable order by $i return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "let $i := (xs:date("2001-02-03"), xs:time("01:02:03Z")) stable order by $i return $i". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found. let $i := (xs:date("2001-02-03"), xs:time("01:02:03Z")) [Error is around here]stable order by $i return $i, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "let $i := (xs:date("2001-02-03"), xs:time("01:02:03Z")) stable order by $i return $i".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found.\nlet $i := (xs:date("2001-02-03"), xs:time("01:02:03Z")) [Error is around here]stable order by $i return $i'.
K2-OrderbyExprWithout-28,AssertionError: Expected executing the XPath "let $i := (xs:date("2001-02-03"), xs:time("01:02:03Z")) order by $i return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "let $i := (xs:date("2001-02-03"), xs:time("01:02:03Z")) order by $i return $i". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. let $i := (xs:date("2001-02-03"), xs:time("01:02:03Z")) [Error is around here]order by $i return $i, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "let $i := (xs:date("2001-02-03"), xs:time("01:02:03Z")) order by $i return $i".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.\nlet $i := (xs:date("2001-02-03"), xs:time("01:02:03Z")) [Error is around here]order by $i return $i'.
K2-OrderbyExprWithout-29,AssertionError: Expected executing the XPath "<r> { for $i in attribute name {()} order by () return () } </r>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "<r> { for $i in attribute name {()} order by () return () } </r>". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "n" found. <r> { for $i in attribute [Error is around here]name {()} order by () return () } </r>, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "<r> { for $i in attribute name {()} order by () return () } </r>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "n" found.\n<r> { for $i in attribute [Error is around here]name {()} order by () return () } </r>'.
K2-OrderbyExprWithout-30,AssertionError: Expected executing the XPath "<r> { for $i in 1 order by () return () } </r>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "<r> { for $i in 1 order by () return () } </r>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. <r> { for $i in 1 [Error is around here]order by () return () } </r>, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "<r> { for $i in 1 order by () return () } </r>".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.\n<r> { for $i in 1 [Error is around here]order by () return () } </r>'.
K2-OrderbyExprWithout-31,AssertionError: Expected executing the XPath "let $i := (1, 2, 3) order by $i return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "let $i := (1, 2, 3) order by $i return $i". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. let $i := (1, 2, 3) [Error is around here]order by $i return $i, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "let $i := (1, 2, 3) order by $i return $i".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.\nlet $i := (1, 2, 3) [Error is around here]order by $i return $i'.
K2-OrderbyExprWithout-32,AssertionError: Expected executing the XPath "let $i := (1, 2, 3) stable order by $i return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "let $i := (1, 2, 3) stable order by $i return $i". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found. let $i := (1, 2, 3) [Error is around here]stable order by $i return $i, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "let $i := (1, 2, 3) stable order by $i return $i".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found.\nlet $i := (1, 2, 3) [Error is around here]stable order by $i return $i'.
K2-OrderbyExprWithout-33,AssertionError: Expected executing the XPath "let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) stable order by $i[1] return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) stable order by $i[1] return $i". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found. let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) [Error is around here]stable order by $i[1] return $i, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) stable order by $i[1] return $i".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found.\nlet $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) [Error is around here]stable order by $i[1] return $i'.
K2-OrderbyExprWithout-34,AssertionError: Expected executing the XPath "let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) order by $i[1] return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) order by $i[1] return $i". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) [Error is around here]order by $i[1] return $i, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) order by $i[1] return $i".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.\nlet $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) [Error is around here]order by $i[1] return $i'.
K2-OrderbyExprWithout-35,AssertionError: Expected executing the XPath "let $i := (xs:hexBinary("FF"), xs:time("03:03:03Z"), xs:hexBinary("FF")) stable order by $i[1] return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "let $i := (xs:hexBinary("FF"), xs:time("03:03:03Z"), xs:hexBinary("FF")) stable order by $i[1] return $i". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found. let $i := (xs:hexBinary("FF"), xs:time("03:03:03Z"), xs:hexBinary("FF")) [Error is around here]stable order by $i[1] return $i, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "let $i := (xs:hexBinary("FF"), xs:time("03:03:03Z"), xs:hexBinary("FF")) stable order by $i[1] return $i".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found.\nlet $i := (xs:hexBinary("FF"), xs:time("03:03:03Z"), xs:hexBinary("FF")) [Error is around here]stable order by $i[1] return $i'.
K2-OrderbyExprWithout-36,AssertionError: Expected executing the XPath "let $i := (xs:hexBinary("FF"), xs:time("03:03:03Z"), xs:hexBinary("FF")) order by $i[1] return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "let $i := (xs:hexBinary("FF"), xs:time("03:03:03Z"), xs:hexBinary("FF")) order by $i[1] return $i". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. let $i := (xs:hexBinary("FF"), xs:time("03:03:03Z"), xs:hexBinary("FF")) [Error is around here]order by $i[1] return $i, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "let $i := (xs:hexBinary("FF"), xs:time("03:03:03Z"), xs:hexBinary("FF")) order by $i[1] return $i".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.\nlet $i := (xs:hexBinary("FF"), xs:time("03:03:03Z"), xs:hexBinary("FF")) [Error is around here]order by $i[1] return $i'.
K2-OrderbyExprWithout-37,AssertionError: Expected executing the XPath "for $i in (1, 3, 2) stable order by () return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "for $i in (1, 3, 2) stable order by () return $i". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found. for $i in (1, 3, 2) [Error is around here]stable order by () return $i, Error: XPST0003: Unable to parse XPath: "for $i in (1, 3, 2) stable order by () return $i". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found. for $i in (1, 3, 2) [Error is around here]stable order by () return $i, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "for $i in (1, 3, 2) stable order by () return $i".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found.\nfor $i in (1, 3, 2) [Error is around here]stable order by () return $i'.
K2-OrderbyExprWithout-38,Error: XPST0003: Unable to parse XPath: "for $i in (1, 2, 3) stable order by 1 return reverse(($i, "FO"))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found. for $i in (1, 2, 3) [Error is around here]stable order by 1 return reverse(($i, "FO"))
K2-OrderbyExprWithout-39,AssertionError: Expected executing the XPath "for $a in (1, 4, 2) let $i := (1, 3, 2) order by $i return 1" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "for $a in (1, 4, 2) let $i := (1, 3, 2) order by $i return 1". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. for $a in (1, 4, 2) [Error is around here]let $i := (1, 3, 2) order by $i return 1, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "for $a in (1, 4, 2) let $i := (1, 3, 2) order by $i return 1".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.\nfor $a in (1, 4, 2) [Error is around here]let $i := (1, 3, 2) order by $i return 1'.
K2-OrderbyExprWithout-40,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "for $a in (3, 2, 1) let $a := ($a, 1), $b := (2, 1), $c := (2, 1), $d:= (2, 1) order by $a return $a".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.\nfor $a in (3, 2, 1) [Error is around here]let $a := ($a, 1), $b := (2, 1), $c := (2, 1), $d:= (2, 1) order by $a return $a'
K2-OrderbyExprWithout-41,Error: XPST0003: Unable to parse XPath: "for $a in (3, 2, 1) let $b := (2, 1), $c := (2, 1), $d := (2, 1), $e := (2, 1) order by $a return $a". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. for $a in (3, 2, 1) [Error is around here]let $b := (2, 1), $c := (2, 1), $d := (2, 1), $e := (2, 1) order by $a return $a
K2-OrderbyExprWithout-42,Error: XPST0003: Unable to parse XPath: "(string(for $i in current-date() order by $i return $i)) => count()". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. (string(for $i in current-date() [Error is around here]order by $i return $i)) => count()
K2-OrderbyExprWithout-43,Error: XPST0003: Unable to parse XPath: "if(for $i in <e> <a id="3"/> <b id="2"/> <c id="1"/> </e>/* order by xs:integer($i/@id) return $i) then 4 else 9 = 4". Expected " ", "!", "!=", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. if(for $i in <e> <a id="3"/> <b id="2"/> <c id="1"/> </e>/* [Error is around here]order by xs:integer($i/@id) return $i) then 4 else 9 = 4
K2-OrderbyExprWithout-44,Error: XPST0003: Unable to parse XPath: "for $a in (2, 1) let $b := 1 where true() order by $a return $a". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. for $a in (2, 1) [Error is around here]let $b := 1 where true() order by $a return $a
K2-OrderbyExprWithout-45,Error: XPST0003: Unable to parse XPath: "for $a in (3, 2, 1), $b in (6) stable order by $b return $a". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found. for $a in (3, 2, 1), $b in (6) [Error is around here]stable order by $b return $a
K2-OrderbyExprWithout-46,Error: XPST0003: Unable to parse XPath: "let $numbers := (1, 2, 1.3, 3e3, xs:double("NaN"), xs:double("-INF"), xs:double("INF")) return (for $i in $numbers order by $i empty least return $i, "SEP", for $i in $numbers order by $i empty greatest return $i)". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. let $numbers := (1, 2, 1.3, 3e3, xs:double("NaN"), xs:double("-INF"), xs:double("INF")) return (for $i in $numbers [Error is around here]order by $i empty least return $i, "SEP", for $i in $numbers order by $i empty greatest return $i)
K2-OrderbyExprWithout-47,Error: XPST0003: Unable to parse XPath: "let $numbers := (1, 2, 1.3, 3e3, xs:double("NaN"), xs:double("-INF"), xs:double("INF")) return (for $i in $numbers stable order by $i empty least return $i, "SEP", for $i in $numbers order by $i empty greatest return $i)". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found. let $numbers := (1, 2, 1.3, 3e3, xs:double("NaN"), xs:double("-INF"), xs:double("INF")) return (for $i in $numbers [Error is around here]stable order by $i empty least return $i, "SEP", for $i in $numbers order by $i empty greatest return $i)
K2-OrderbyExprWithout-48,Error: XPST0003: Unable to parse XPath: "let $numbers := (<e>NaN</e>, <e/>, <e/>, <e>NaN</e>, <e>NaN</e>, <e>INF</e>, <e>NaN</e>, <e/>, <e>3</e>, comment{"3"}) return (for $i in $numbers order by xs:double($i/text()) empty least return xs:double($i/text()), "SEP", for $i in $numbers order by xs:double($i/text()) empty greatest return xs:double($i/text()))". Expected "!", "!=", "#", "(", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. let $numbers := (<e>NaN</e>, <e/>, <e/>, <e>NaN</e>, <e>NaN</e>, <e>INF</e>, <e>NaN</e>, <e/>, <e>3</e>, comment[Error is around here]{"3"}) return (for $i in $numbers order by xs:double($i/text()) empty least return xs:double($i/text()), "SEP", for $i in $numbers order by xs:double($i/text()) empty greatest return xs:double($i/text()))
K2-OrderbyExprWithout-49,Error: XPST0003: Unable to parse XPath: "let $numbers := (<e>NaN</e>, <e/>, <e/>, <e>NaN</e>, <e>NaN</e>, <e>INF</e>, <e>NaN</e>, <e/>, <e>3</e>, comment{"3"}) return (for $i in $numbers stable order by xs:double($i/text()) empty least return xs:double($i/text()), "SEP", for $i in $numbers stable order by xs:double($i/text()) empty greatest return xs:double($i/text()))". Expected "!", "!=", "#", "(", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. let $numbers := (<e>NaN</e>, <e/>, <e/>, <e>NaN</e>, <e>NaN</e>, <e>INF</e>, <e>NaN</e>, <e/>, <e>3</e>, comment[Error is around here]{"3"}) return (for $i in $numbers stable order by xs:double($i/text()) empty least return xs:double($i/text()), "SEP", for $i in $numbers stable order by xs:double($i/text()) empty greatest return xs:double($i/text()))
PathExprErr-2,AssertionError: expected [Function] to throw error including 'XPTY0018' but got 'XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?'
PathExpr-5,AssertionError: expected [Function] to throw an error
PathExpr-7,AssertionError: expected [Function] to throw an error
PathExpr-8,AssertionError: expected [Function] to throw an error
PathExpr-9,AssertionError: expected [Function] to throw an error
Parenexpr-11,Error: XPST0003: Unable to parse XPath: "(for $x in (1) where (fn:true()) order by ($x) return ($x)) = 1". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found. (for $x in (1) [Error is around here]where (fn:true()) order by ($x) return ($x)) = 1
K-ForExprPositionalVar-1,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'XPST0003: Unable to parse XPath: "for $a at $p in (1, 2) return 1, $p".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\nfor $a [Error is around here]at $p in (1, 2) return 1, $p'
K-ForExprPositionalVar-2,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'XPST0003: Unable to parse XPath: "for $a at $p1 in (1, 2), $b at $p2 in (1, 2), $c at $p3 in (1, 2) return 1, $p1".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\nfor $a [Error is around here]at $p1 in (1, 2), $b at $p2 in (1, 2), $c at $p3 in (1, 2) return 1, $p1'
K-ForExprPositionalVar-3,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'XPST0003: Unable to parse XPath: "for $a at $p1 in (1, 2), $b at $p2 in (1, 2), $c at $p3 in (1, 2) return 1, $p2".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\nfor $a [Error is around here]at $p1 in (1, 2), $b at $p2 in (1, 2), $c at $p3 in (1, 2) return 1, $p2'
K-ForExprPositionalVar-4,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'XPST0003: Unable to parse XPath: "for $a at $p1 in (1, 2), $b at $p2 in (1, 2), $c at $p3 in (1, 2) return 1, $p3".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\nfor $a [Error is around here]at $p1 in (1, 2), $b at $p2 in (1, 2), $c at $p3 in (1, 2) return 1, $p3'
K-ForExprPositionalVar-6,Error: XPST0003: Unable to parse XPath: "deep-equal((1, 2, 3), for $i at $p in (1, 2, 3) return $p)". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. deep-equal((1, 2, 3), for $i [Error is around here]at $p in (1, 2, 3) return $p)
K-ForExprPositionalVar-7,Error: XPST0003: Unable to parse XPath: "deep-equal((true(), true()), for $i at $p in (1, 2) return boolean($p))". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. deep-equal((true(), true()), for $i [Error is around here]at $p in (1, 2) return boolean($p))
K-ForExprPositionalVar-8,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "for $i at $p in (1, 2, 3) return $p + "1"".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\nfor $i [Error is around here]at $p in (1, 2, 3) return $p + "1"'
K-ForExprPositionalVar-9,Error: XPST0003: Unable to parse XPath: "deep-equal((1, 2, 3), for $i at $p in string-to-codepoints("abc") return $p)". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. deep-equal((1, 2, 3), for $i [Error is around here]at $p in string-to-codepoints("abc") return $p)
K-ForExprPositionalVar-10,Error: XPST0003: Unable to parse XPath: "deep-equal((1, 2, 3), for $i at $p in distinct-values((1, 2, 3, 1, 2)) return $p)". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. deep-equal((1, 2, 3), for $i [Error is around here]at $p in distinct-values((1, 2, 3, 1, 2)) return $p)
K-ForExprPositionalVar-11,AssertionError: Expected executing the XPath "empty(for $i at $p in () return $p)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "empty(for $i at $p in () return $p)". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. empty(for $i [Error is around here]at $p in () return $p), AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "empty(for $i at $p in () return $p)".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\nempty(for $i [Error is around here]at $p in () return $p)'.
K-ForExprPositionalVar-12,Error: XPST0003: Unable to parse XPath: "deep-equal((1, 2, 3, 4), for $i at $p in insert-before((1, current-time()), 13, (current-date(), 3)) return $p)". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. deep-equal((1, 2, 3, 4), for $i [Error is around here]at $p in insert-before((1, current-time()), 13, (current-date(), 3)) return $p)
K-ForExprPositionalVar-13,Error: XPST0003: Unable to parse XPath: "deep-equal((1, 2, 3, 4), for $i at $p in insert-before((1, current-time()), 1, (current-date(), 3)) return $p)". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. deep-equal((1, 2, 3, 4), for $i [Error is around here]at $p in insert-before((1, current-time()), 1, (current-date(), 3)) return $p)
K-ForExprPositionalVar-14,Error: XPST0003: Unable to parse XPath: "deep-equal((1, 2, 3, 4), for $i at $p in insert-before((1, current-time()), 2, (current-date(), 3)) return $p)". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. deep-equal((1, 2, 3, 4), for $i [Error is around here]at $p in insert-before((1, current-time()), 2, (current-date(), 3)) return $p)
K-ForExprPositionalVar-15,Error: XPST0003: Unable to parse XPath: "deep-equal((1, 2, 3, 4), for $i at $p in 1 to 4 return $p)". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. deep-equal((1, 2, 3, 4), for $i [Error is around here]at $p in 1 to 4 return $p)
K-ForExprPositionalVar-16,Error: XPST0003: Unable to parse XPath: "deep-equal((1, 2, 3, 4), for $i at $p in -10 to -7 return $p)". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. deep-equal((1, 2, 3, 4), for $i [Error is around here]at $p in -10 to -7 return $p)
K-ForExprPositionalVar-17,Error: XPST0003: Unable to parse XPath: "deep-equal((1, 2, 3), for $i at $p in remove((1, 2, 3, current-time()), 2) return $p)". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. deep-equal((1, 2, 3), for $i [Error is around here]at $p in remove((1, 2, 3, current-time()), 2) return $p)
K-ForExprPositionalVar-18,Error: XPST0003: Unable to parse XPath: "deep-equal((1, 2, 3), for $i at $p in remove((1, 2, 3, current-time()), 4) return $p)". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. deep-equal((1, 2, 3), for $i [Error is around here]at $p in remove((1, 2, 3, current-time()), 4) return $p)
K-ForExprPositionalVar-19,Error: XPST0003: Unable to parse XPath: "deep-equal((1, 2, 3), for $i at $p in remove((1, 2, current-time()), 10) return $p)". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. deep-equal((1, 2, 3), for $i [Error is around here]at $p in remove((1, 2, current-time()), 10) return $p)
K-ForExprPositionalVar-20,Error: XPST0003: Unable to parse XPath: "deep-equal((1, 2, 3), for $i at $p in remove((1, 2, current-time()), 0) return $p)". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. deep-equal((1, 2, 3), for $i [Error is around here]at $p in remove((1, 2, current-time()), 0) return $p)
K-ForExprPositionalVar-21,Error: XPST0003: Unable to parse XPath: "deep-equal((1, 2, 3), for $i at $p in remove((1, 2, 3, current-time()), 1) return $p)". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. deep-equal((1, 2, 3), for $i [Error is around here]at $p in remove((1, 2, 3, current-time()), 1) return $p)
K-ForExprPositionalVar-22,Error: XPST0003: Unable to parse XPath: "deep-equal((1, 2, 3), for $i at $p in remove((1, 2, 3, current-time()), 3) return $p)". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. deep-equal((1, 2, 3), for $i [Error is around here]at $p in remove((1, 2, 3, current-time()), 3) return $p)
K-ForExprPositionalVar-23,Error: XPST0003: Unable to parse XPath: "1 eq (for $i at $p in subsequence((1, 2, 3, current-time()), 1, 1) return $p)". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. 1 eq (for $i [Error is around here]at $p in subsequence((1, 2, 3, current-time()), 1, 1) return $p)
K-ForExprPositionalVar-24,AssertionError: Expected executing the XPath "empty(for $i at $p in subsequence((1, 2, 3, current-time()), 5) return $p)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "empty(for $i at $p in subsequence((1, 2, 3, current-time()), 5) return $p)". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. empty(for $i [Error is around here]at $p in subsequence((1, 2, 3, current-time()), 5) return $p), AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "empty(for $i at $p in subsequence((1, 2, 3, current-time()), 5) return $p)".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\nempty(for $i [Error is around here]at $p in subsequence((1, 2, 3, current-time()), 5) return $p)'.
K-ForExprPositionalVar-25,AssertionError: Expected executing the XPath "empty(for $i at $p in subsequence((1, 2, 3, current-time()), 5, 8) return $p)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "empty(for $i at $p in subsequence((1, 2, 3, current-time()), 5, 8) return $p)". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. empty(for $i [Error is around here]at $p in subsequence((1, 2, 3, current-time()), 5, 8) return $p), AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "empty(for $i at $p in subsequence((1, 2, 3, current-time()), 5, 8) return $p)".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\nempty(for $i [Error is around here]at $p in subsequence((1, 2, 3, current-time()), 5, 8) return $p)'.
K-ForExprPositionalVar-26,Error: XPST0003: Unable to parse XPath: "deep-equal((1, 2), for $i at $p in subsequence((1, 2, 3, current-time()), 3, 2) return $p)". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. deep-equal((1, 2), for $i [Error is around here]at $p in subsequence((1, 2, 3, current-time()), 3, 2) return $p)
K-ForExprPositionalVar-27,Error: XPST0003: Unable to parse XPath: "deep-equal((1, 2), for $i at $p in subsequence((1, 2, 3, current-time()), 1, 2) return $p)". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. deep-equal((1, 2), for $i [Error is around here]at $p in subsequence((1, 2, 3, current-time()), 1, 2) return $p)
K-ForExprPositionalVar-28,Error: XPST0003: Unable to parse XPath: "deep-equal((1, 2), for $i at $p in subsequence((1, 2, 3, current-time()), 2, 2) return $p)". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. deep-equal((1, 2), for $i [Error is around here]at $p in subsequence((1, 2, 3, current-time()), 2, 2) return $p)
K-ForExprPositionalVar-29,Error: XPST0003: Unable to parse XPath: "1 eq (for $i at $p in 0 return $p)". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. 1 eq (for $i [Error is around here]at $p in 0 return $p)
K-ForExprPositionalVar-30,Error: XPST0003: Unable to parse XPath: "deep-equal(for $i at $p in (1, 2, 3, 4) return ($i, $p), (1, 1, 2, 2, 3, 3, 4, 4))". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. deep-equal(for $i [Error is around here]at $p in (1, 2, 3, 4) return ($i, $p), (1, 1, 2, 2, 3, 3, 4, 4))
K2-ForExprPositionalVar-1,Error: XPST0003: Unable to parse XPath: "for $i at $p in remove((1, 2, 3), 10) return $p". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. for $i [Error is around here]at $p in remove((1, 2, 3), 10) return $p
K2-ForExprPositionalVar-2,AssertionError: Expected executing the XPath "let $tree := <e> <a id="1"/> <a id="2"/> <a id="3"/> </e> for $i at $pos in ("a", "b", "c") return ($tree/@id eq $pos, $pos)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "let $tree := <e> <a id="1"/> <a id="2"/> <a id="3"/> </e> for $i at $pos in ("a", "b", "c") return ($tree/@id eq $pos, $pos)". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found. let $tree := <e> <a id="1"/> <a id="2"/> <a id="3"/> </e> [Error is around here]for $i at $pos in ("a", "b", "c") return ($tree/@id eq $pos, $pos), AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "let $tree := <e> <a id="1"/> <a id="2"/> <a id="3"/> </e> for $i at $pos in ("a", "b", "c") return ($tree/@id eq $pos, $pos)".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found.\nlet $tree := <e> <a id="1"/> <a id="2"/> <a id="3"/> </e> [Error is around here]for $i at $pos in ("a", "b", "c") return ($tree/@id eq $pos, $pos)'.
K2-ForExprPositionalVar-3,Error: XPST0003: Unable to parse XPath: "let $tree := <e> <a id="1"/> <a id="2"/> <a id="3"/> </e> for $i at $pos in ("a", "b", "c") return ($tree/a/@id = $pos, $pos)". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found. let $tree := <e> <a id="1"/> <a id="2"/> <a id="3"/> </e> [Error is around here]for $i at $pos in ("a", "b", "c") return ($tree/a/@id = $pos, $pos)
K2-ForExprPositionalVar-4,Error: XPST0003: Unable to parse XPath: "for $i at $pos in (3 to 6) let $let := $pos + 1 return ($let, $let - 1)". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. for $i [Error is around here]at $pos in (3 to 6) let $let := $pos + 1 return ($let, $let - 1)
K-FilterExpr-4,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'Atomizing array(*) is not implemented.'
K-FilterExpr-5,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'Atomizing array(*) is not implemented.'
K-FilterExpr-51,AssertionError: Expected executing the XPath "((0, 1, 2, "a", "b", "c")[. instance of xs:string][. treat as xs:string eq "c"] treat as xs:string) eq "c"" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "((0, 1, 2, "a", "b", "c")[. instance of xs:string][. treat as xs:string eq "c"] treat as xs:string) eq "c"". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "]", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found. ((0, 1, 2, "a", "b", "c")[. instance of xs:string][. [Error is around here]treat as xs:string eq "c"] treat as xs:string) eq "c", AssertionError: expected [Function] to throw error including 'XPDY0050' but got 'XPST0003: Unable to parse XPath: "((0, 1, 2, "a", "b", "c")[. instance of xs:string][. treat as xs:string eq "c"] treat as xs:string) eq "c"".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "]", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.\n((0, 1, 2, "a", "b", "c")[. instance of xs:string][. [Error is around here]treat as xs:string eq "c"] treat as xs:string) eq "c"'.
K-FilterExpr-52,AssertionError: Expected executing the XPath "((0, 1, 2, "a", "b", "c")[. instance of xs:integer][. treat as xs:integer eq 0] treat as xs:integer) eq 0" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "((0, 1, 2, "a", "b", "c")[. instance of xs:integer][. treat as xs:integer eq 0] treat as xs:integer) eq 0". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "]", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found. ((0, 1, 2, "a", "b", "c")[. instance of xs:integer][. [Error is around here]treat as xs:integer eq 0] treat as xs:integer) eq 0, AssertionError: expected [Function] to throw error including 'XPDY0050' but got 'XPST0003: Unable to parse XPath: "((0, 1, 2, "a", "b", "c")[. instance of xs:integer][. treat as xs:integer eq 0] treat as xs:integer) eq 0".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "]", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.\n((0, 1, 2, "a", "b", "c")[. instance of xs:integer][. [Error is around here]treat as xs:integer eq 0] treat as xs:integer) eq 0'.
K-FilterExpr-92,AssertionError: expected [Function] to throw an error
K-FilterExpr-93,AssertionError: expected [Function] to throw an error
K-FilterExpr-96,Error: XPST0003: Unable to parse XPath: "          document{<works>{/tail(works/employee)}</works>}/works/employee[@name=/works/employee[2]/@name]/@name/string()           = "Jane Doe 3"". Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "{" found.           document[Error is around here]{<works>{/tail(works/employee)}</works>}/works/employee[@name=/works/employee[2]/@name]/@name/string()           = "Jane Doe 3"
K2-FilterExpr-1,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-FilterExpr-2,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-FilterExpr-5,AssertionError: Expected executing the XPath "          let $d := document {<root><child type=""/></root>}           return document{$d//*[let $i := @type return $d//*[$i]], (1, 2, 3)[true()], (4, 5, 6)[false()]}        " to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "          let $d := document {<root><child type=""/></root>}           return document{$d//*[let $i := @type return $d//*[$i]], (1, 2, 3)[true()], (4, 5, 6)[false()]}        ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found.           let $d := document [Error is around here]{<root><child type=""/></root>}           return document{$d//*[let $i := @type return $d//*[$i]], (1, 2, 3)[true()], (4, 5, 6)[false()]}        , AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "\n         let $d := document {<root><child type=""/></root>} \n         return document{$d//*[let $i := @type return $d//*[$i]], (1, 2, 3)[true()], (4, 5, 6)[false()]}\n       ".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found.\n\n         let $d := document [Error is around here]{<root><child type=""/></root>} \n         return document{$d//*[let $i := @type return $d//*[$i]], (1, 2, 3)[true()], (4, 5, 6)[false()]}\n       '.
K2-FilterExpr-6,Error: XPST0003: Unable to parse XPath: "let $d := document { <root><child type=""/></root> } return $d//*[let $i := @type return $d//*[$i]]". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found. let $d := document [Error is around here]{ <root><child type=""/></root> } return $d//*[let $i := @type return $d//*[$i]]
K2-FilterExpr-8,AssertionError: expected [Function] to throw error including 'XPDY0050' but got 'XPST0003: Unable to parse XPath: "(<?z?>, <?y?>)[self::processing-instruction(y)] treat as empty-sequence()".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "t" found.\n(<?z?>, <?y?>)[self::processing-instruction(y)] [Error is around here]treat as empty-sequence()'
predicates-29,AssertionError: expected [Function] to throw an error
predicates-30,Error: XPST0017: Function fn:data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
predicates-31,Error: XPST0017: Function fn:data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
predicates-32,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-Predicates-1,Error: XPST0003: Unable to parse XPath: ""c"[. treat as xs:string]". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "]", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found. "c"[. [Error is around here]treat as xs:string]
K2-Predicates-2,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-Predicates-3,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-Predicates-4,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
cbcl-first-in-sequence-004,Error: XPST0003: Unable to parse XPath: "declare function local:generate($arg as xs:integer?) as xs:integer* { if ($arg = 0) then ( 1, 2, 3 ) else ( $arg ) }; ( local:generate(()), for $x at $p in local:generate(0) return $p + $x)[1]". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. declare function local:generate($arg as xs:integer?) as xs:integer* { if ($arg = 0) then ( 1, 2, 3 ) else ( $arg ) }; ( local:generate(()), for $x [Error is around here]at $p in local:generate(0) return $p + $x)[1]
cbcl-first-in-sequence-005,Error: XPST0003: Unable to parse XPath: "declare function local:generate($arg as xs:integer?) as xs:integer? { if ($arg = 0) then 1 else $arg }; ( local:generate(()), for $x at $p in local:generate(0) return $p + $x)[1]". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. declare function local:generate($arg as xs:integer?) as xs:integer? { if ($arg = 0) then 1 else $arg }; ( local:generate(()), for $x [Error is around here]at $p in local:generate(0) return $p + $x)[1]
quantexpr-61,Error: XPST0003: Unable to parse XPath: "some $x as xs:integer in (1, 2, 3) , $y as xs:integer in (2, 3, 4) satisfies $x + $y = 4". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. some $x [Error is around here]as xs:integer in (1, 2, 3) , $y as xs:integer in (2, 3, 4) satisfies $x + $y = 4
quantexpr-62,Error: XPST0003: Unable to parse XPath: "some $x as xs:string in ("cat","dog","rat") satisfies fn:string-length($x) = 3". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. some $x [Error is around here]as xs:string in ("cat","dog","rat") satisfies fn:string-length($x) = 3
quantexpr-63,Error: XPST0003: Unable to parse XPath: "every $x as xs:string in ("cat","dog","rat") satisfies fn:string-length($x) = 3". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. every $x [Error is around here]as xs:string in ("cat","dog","rat") satisfies fn:string-length($x) = 3
quantexpr-64,Error: XPST0003: Unable to parse XPath: "every $x as xs:string in ("cat","dog","rat"), $y as xs:integer in (3, 3, 3) satisfies fn:string-length($x) = $y". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. every $x [Error is around here]as xs:string in ("cat","dog","rat"), $y as xs:integer in (3, 3, 3) satisfies fn:string-length($x) = $y
quantexpr-65,Error: XPST0003: Unable to parse XPath: "some $x as xs:integer in (1, 2, 3), $y as xs:float in (xs:float(2), xs:float(3)) satisfies $x + $y = 5". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. some $x [Error is around here]as xs:integer in (1, 2, 3), $y as xs:float in (xs:float(2), xs:float(3)) satisfies $x + $y = 5
quantexpr-66,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "\n        declare function local:f($x, $y) {\n          let $a := $x\n          where empty($y)   (every $i in $x satisfies $i = $y)\n          return $a\n        };\n        local:f("x", ())\n      ".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.\n\n        declare function local:f($x, $y) {\n          let $a := $x\n          [Error is around here]where empty($y)   (every $i in $x satisfies $i = $y)\n          return $a\n        };\n        local:f("x", ())\n      '
quantexpr-67,Error: XPST0003: Unable to parse XPath: "         declare function local:f($x, $y) {             let $a := $x             where (every $i in $x satisfies $i = $y) or empty($y)             return $a         };         local:f("x", ())       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.          declare function local:f($x, $y) {             let $a := $x             [Error is around here]where (every $i in $x satisfies $i = $y) or empty($y)             return $a         };         local:f("x", ())
quantexpr-68,Error: XPST0003: Unable to parse XPath: "         declare function local:f($x, $y) {             let $a := $x             where (every $i in $x satisfies $i = $y) or empty($y)             return true()         };         local:f((current-date(), current-date(), current-date()), (current-date()))       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.          declare function local:f($x, $y) {             let $a := $x             [Error is around here]where (every $i in $x satisfies $i = $y) or empty($y)             return true()         };         local:f((current-date(), current-date(), current-date()), (current-date()))
K-QuantExprWithout-7,Error: XPST0003: Unable to parse XPath: "some $i in subsequence((0, 1, 2, current-time()), 1, 3) satisfies boolean($i treat as xs:integer)". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found. some $i in subsequence((0, 1, 2, current-time()), 1, 3) satisfies boolean($i [Error is around here]treat as xs:integer)
K-QuantExprWithout-8,Error: XPST0003: Unable to parse XPath: "every $i in subsequence((1, 2, 3, current-time()), 1, 3) satisfies boolean($i treat as xs:integer)". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found. every $i in subsequence((1, 2, 3, current-time()), 1, 3) satisfies boolean($i [Error is around here]treat as xs:integer)
K-QuantExprWithout-42,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K-QuantExprWithout-43,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K-QuantExprWithout-44,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K-QuantExprWithout-45,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K-QuantExprWithout-56,Error: Not implemented: references to variables with a namespace URI or a prefix.
K-QuantExprWithout-57,Error: Not implemented: references to variables with a namespace URI or a prefix.
K-QuantExprWithout-58,Error: Not implemented: references to variables with a namespace URI or a prefix.
K-QuantExprWithout-59,Error: Not implemented: references to variables with a namespace URI or a prefix.
K2-QuantExprWithout-9,Error: XPST0003: Unable to parse XPath: "let $firstSeq := (<a/>, <b/>, <e><c/></e>) let $secondSeq := (<a attr=""/>, <b>text</b>, <e><c/></e>) return some $i in $firstSeq satisfies $secondSeq[deep-equal(.,$i)]". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. let $firstSeq := (<a/>, <b/>, <e><c/></e>) [Error is around here]let $secondSeq := (<a attr=""/>, <b>text</b>, <e><c/></e>) return some $i in $firstSeq satisfies $secondSeq[deep-equal(.,$i)]
K-QuantExprWith-1,Error: XPST0003: Unable to parse XPath: "every $a as item()* in (1, 2), $b as item()* in $a satisfies $b". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. every $a [Error is around here]as item()* in (1, 2), $b as item()* in $a satisfies $b
K-QuantExprWith-2,Error: XPST0003: Unable to parse XPath: "some $a as item()* in (1, 2), $b as item()* in $a satisfies $b". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. some $a [Error is around here]as item()* in (1, 2), $b as item()* in $a satisfies $b
K-QuantExprWith-3,Error: XPST0003: Unable to parse XPath: "every $a as item()? in (1, 2), $b as item()? in $a satisfies $b". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. every $a [Error is around here]as item()? in (1, 2), $b as item()? in $a satisfies $b
K-QuantExprWith-4,Error: XPST0003: Unable to parse XPath: "some $a as item()? in (1, 2), $b as item()? in $a satisfies $b". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. some $a [Error is around here]as item()? in (1, 2), $b as item()? in $a satisfies $b
K-QuantExprWith-5,Error: XPST0003: Unable to parse XPath: "every $a as item()+ in (1, 2), $b as item()+ in $a satisfies $b". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. every $a [Error is around here]as item()+ in (1, 2), $b as item()+ in $a satisfies $b
K-QuantExprWith-6,Error: XPST0003: Unable to parse XPath: "some $a as item()+ in (1, 2), $b as item()+ in $a satisfies $b". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. some $a [Error is around here]as item()+ in (1, 2), $b as item()+ in $a satisfies $b
K-QuantExprWith-9,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "some $a as xs:anyURI in 1 satisfies count($a)".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\nsome $a [Error is around here]as xs:anyURI in 1 satisfies count($a)'
K-QuantExprWith-10,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "every $a as xs:anyURI in 1 satisfies count($a)".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\nevery $a [Error is around here]as xs:anyURI in 1 satisfies count($a)'
K-QuantExprWith-11,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "every $a as empty-sequence() in (1, 2), $b as xs:integer in $a satisfies $b".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\nevery $a [Error is around here]as empty-sequence() in (1, 2), $b as xs:integer in $a satisfies $b'
K-QuantExprWith-12,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "some $a as empty-sequence() in (1, 2), $b as xs:integer in $a satisfies $b".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\nsome $a [Error is around here]as empty-sequence() in (1, 2), $b as xs:integer in $a satisfies $b'
K-QuantExprWith-13,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "every $a as xs:integer+ in (1, 2), $b as xs:string* in $a satisfies $b".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\nevery $a [Error is around here]as xs:integer+ in (1, 2), $b as xs:string* in $a satisfies $b'
K-QuantExprWith-14,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "some $a as xs:integer+ in (1, 2), $b as xs:string* in $a satisfies $b".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\nsome $a [Error is around here]as xs:integer+ in (1, 2), $b as xs:string* in $a satisfies $b'
K-QuantExprWith-15,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "some $a as item()* in (1, 2), $b as xs:string in $a satisfies $b".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\nsome $a [Error is around here]as item()* in (1, 2), $b as xs:string in $a satisfies $b'
K-QuantExprWith-16,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "every $a as item()* in (1, 2), $b as xs:string in $a satisfies $b".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\nevery $a [Error is around here]as item()* in (1, 2), $b as xs:string in $a satisfies $b'
K-QuantExprWith-17,Error: XPST0003: Unable to parse XPath: "every $a as xs:integer+ in (1, 2), $b as xs:integer in $a satisfies $b". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. every $a [Error is around here]as xs:integer+ in (1, 2), $b as xs:integer in $a satisfies $b
K-QuantExprWith-18,Error: XPST0003: Unable to parse XPath: "every $a as item()* in (1, 2), $b as xs:integer in $a satisfies $b". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. every $a [Error is around here]as item()* in (1, 2), $b as xs:integer in $a satisfies $b
K-QuantExprWith-21,AssertionError: Expected executing the XPath "every $a as empty-sequence() in (), $b as xs:integer in $a satisfies $b" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "every $a as empty-sequence() in (), $b as xs:integer in $a satisfies $b". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. every $a [Error is around here]as empty-sequence() in (), $b as xs:integer in $a satisfies $b, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "every $a as empty-sequence() in (), $b as xs:integer in $a satisfies $b".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\nevery $a [Error is around here]as empty-sequence() in (), $b as xs:integer in $a satisfies $b'.
K-QuantExprWith-22,AssertionError: Expected executing the XPath "not(some $a as empty-sequence() in (), $b as xs:integer in $a satisfies $b)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "not(some $a as empty-sequence() in (), $b as xs:integer in $a satisfies $b)". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. not(some $a [Error is around here]as empty-sequence() in (), $b as xs:integer in $a satisfies $b), AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "not(some $a as empty-sequence() in (), $b as xs:integer in $a satisfies $b)".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\nnot(some $a [Error is around here]as empty-sequence() in (), $b as xs:integer in $a satisfies $b)'.
K-QuantExprWith-23,Error: XPST0003: Unable to parse XPath: "every $a as xs:integer in (1, 2), $b as xs:integer in $a satisfies $b". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. every $a [Error is around here]as xs:integer in (1, 2), $b as xs:integer in $a satisfies $b
K-QuantExprWith-24,Error: XPST0003: Unable to parse XPath: "some $a as xs:integer in (1, 2), $b as xs:integer in $a satisfies $b". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. some $a [Error is around here]as xs:integer in (1, 2), $b as xs:integer in $a satisfies $b
ReturnExpr004,Error: XPST0003: Unable to parse XPath: "for $f in /MyComputer//File where $f/@creation_date="08/06/00" return $f/SecurityObject/Denies/Deny[security/right]/user/string()". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found. for $f in /MyComputer//File [Error is around here]where $f/@creation_date="08/06/00" return $f/SecurityObject/Denies/Deny[security/right]/user/string()
ReturnExpr006,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
ReturnExpr016,Error: XPST0003: Unable to parse XPath: "for $file at $offset in (//Folder)[1]/File return <File>{ $file/@name }{ attribute offset{ $offset }}</File>". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. for $file [Error is around here]at $offset in (//Folder)[1]/File return <File>{ $file/@name }{ attribute offset{ $offset }}</File>
ReturnExpr020,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
SquareArray-001,Error: No selector counterpart for: anyArrayTest.
SquareArray-005,Error: XPST0003: Unable to parse XPath: "(declare function local:fun() {1 to 5}; array:size([local:fun()])) instance of xs:integer". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found. (declare [Error is around here]function local:fun() {1 to 5}; array:size([local:fun()])) instance of xs:integer
SquareArray-007,Error: XPST0003: Unable to parse XPath: "deep-equal((declare function local:fun() {1 to 5}; [local:fun()](1)), ((1, 2, 3, 4, 5)))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found. deep-equal((declare [Error is around here]function local:fun() {1 to 5}; [local:fun()](1)), ((1, 2, 3, 4, 5)))
SquareArray-009,Error: XPST0003: Unable to parse XPath: "deep-equal((declare function local:fun() {1 to 5}; [local:fun()]?1), ((1, 2, 3, 4, 5)))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found. deep-equal((declare [Error is around here]function local:fun() {1 to 5}; [local:fun()]?1), ((1, 2, 3, 4, 5)))
K2-Steps-10,AssertionError: expected [Function] to throw error including 'XPTY0018' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-Steps-12,AssertionError: Expected executing the XPath "declare variable $e := ()/.; declare variable $b := <b/>/.; $e, <b/>" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
K2-Steps-14,AssertionError: Expected executing the XPath "<r> { let $i := <e> <a/> <b/> </e> let $b := ($i/b, $i/a, $i/b, $i/a) return ()/$b } </r>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "<r> { let $i := <e> <a/> <b/> </e> let $b := ($i/b, $i/a, $i/b, $i/a) return ()/$b } </r>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. <r> { let $i := <e> <a/> <b/> </e> [Error is around here]let $b := ($i/b, $i/a, $i/b, $i/a) return ()/$b } </r>, AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: "<r> { let $i := <e> <a/> <b/> </e> let $b := ($i/b, $i/a, $i/b, $i/a) return ()/$b } </r>".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.\n<r> { let $i := <e> <a/> <b/> </e> [Error is around here]let $b := ($i/b, $i/a, $i/b, $i/a) return ()/$b } </r>'.
K2-Steps-15,Error: XPST0003: Unable to parse XPath: "<r> { let $i := <e> <a/> <b/> </e> let $b := ($i/b, $i/a, $i/b, $i/a) return <e/>/$b } </r>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. <r> { let $i := <e> <a/> <b/> </e> [Error is around here]let $b := ($i/b, $i/a, $i/b, $i/a) return <e/>/$b } </r>
K2-Steps-16,Error: XPST0003: Unable to parse XPath: "<r> { let $i := <e> <a/> <b/> </e> let $b := ($i/b, $i/a, $i/b, $i/a) return <e/>/./$b } </r>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. <r> { let $i := <e> <a/> <b/> </e> [Error is around here]let $b := ($i/b, $i/a, $i/b, $i/a) return <e/>/./$b } </r>
K2-Steps-17,Error: XPST0003: Unable to parse XPath: "<r> { let $i := <e> <a/> <b/> </e> let $b := ($i/b, $i/a, $i/b, $i/a) return $b/. } </r>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. <r> { let $i := <e> <a/> <b/> </e> [Error is around here]let $b := ($i/b, $i/a, $i/b, $i/a) return $b/. } </r>
K2-Steps-21,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-Steps-22,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-Steps-23,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-Steps-24,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-Steps-25,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-Steps-26,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-Steps-27,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-Steps-28,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-Steps-29,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-Steps-30,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-Steps-31,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-Steps-32,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-Steps-33,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-Steps-34,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-Steps-35,Error: XPST0003: Unable to parse XPath: "(<e/>[1]/text{string-join(., " ")}, 1) => count()". Expected "!", "!=", "#", "(", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. (<e/>[1]/text[Error is around here]{string-join(., " ")}, 1) => count()
Steps-leading-lone-slash-1a,Error: XPST0003: Unable to parse XPath: "         declare variable $var := document {<a>123</a>}; $var[(/)*5]         ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", ";", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.          declare variable $var := document [Error is around here]{<a>123</a>}; $var[(/)*5]
Steps-leading-lone-slash-2a,Error: XPST0003: Unable to parse XPath: "         declare variable $var := document {<a>123</a>}; $var[(/)<a]         ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", ";", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.          declare variable $var := document [Error is around here]{<a>123</a>}; $var[(/)<a]
Steps-leading-lone-slash-3a,Error: XPST0003: Unable to parse XPath: "         declare variable $var := document {<a>123</a>}; $var[(/)<5]         ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", ";", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.          declare variable $var := document [Error is around here]{<a>123</a>}; $var[(/)<5]
Steps-leading-lone-slash-5a,Error: XPST0003: Unable to parse XPath: "         declare variable $var := document {<a>123</a>}; $var[(/)<a div 3]         ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", ";", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.          declare variable $var := document [Error is around here]{<a>123</a>}; $var[(/)<a div 3]
Steps-leading-lone-slash-7a,Error: XPST0003: Unable to parse XPath: "         declare variable $var := document {<a>123</a>};          declare variable $a := document {<a>123</a>}; $var[(/) is $a]         ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", ";", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.          declare variable $var := document [Error is around here]{<a>123</a>};          declare variable $a := document {<a>123</a>}; $var[(/) is $a]
Steps-leading-lone-slash-8a,Error: XPST0003: Unable to parse XPath: "         declare variable $var := document {<a>123</a>};          $var[(/) instance of document-node(element(x))]         ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", ";", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.          declare variable $var := document [Error is around here]{<a>123</a>};          $var[(/) instance of document-node(element(x))]
Steps-leading-lone-slash-10,Error: XPST0003: Unable to parse XPath: "         declare variable $var := document {<a>123</a>};          $var[/*]         ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", ";", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.          declare variable $var := document [Error is around here]{<a>123</a>};          $var[/*]
Steps-leading-lone-slash-11,Error: XPST0003: Unable to parse XPath: "         declare variable $var := document {<a>123</a>};          $var[/<a/>]         ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", ";", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.          declare variable $var := document [Error is around here]{<a>123</a>};          $var[/<a/>]
Steps-leading-lone-slash-12,Error: XPST0003: Unable to parse XPath: "         declare variable $var := document {<a>123</a>};          $var[/<a div="3"/>]         ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", ";", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.          declare variable $var := document [Error is around here]{<a>123</a>};          $var[/<a div="3"/>]
Steps-leading-lone-slash-13,Error: XPST0003: Unable to parse XPath: "         declare variable $var := document {<a>123</a>};          $var[/unordered{a}]         ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", ";", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.          declare variable $var := document [Error is around here]{<a>123</a>};          $var[/unordered{a}]
Steps-leading-lone-slash-14,Error: XPST0003: Unable to parse XPath: "         declare variable $var := document {<a>123</a>};          $var[/max(a)]         ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", ";", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.          declare variable $var := document [Error is around here]{<a>123</a>};          $var[/max(a)]
Steps-leading-lone-slash-15,Error: XPST0003: Unable to parse XPath: "         declare variable $var := document {<a>123</a>};          $var[/-5]         ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", ";", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.          declare variable $var := document [Error is around here]{<a>123</a>};          $var[/-5]
Steps-leading-lone-slash-16,Error: XPST0003: Unable to parse XPath: "         declare variable $var := document {<a>123</a>};          declare variable $a := document {<a>123</a>};          $var[/=$a]         ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", ";", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.          declare variable $var := document [Error is around here]{<a>123</a>};          declare variable $a := document {<a>123</a>};          $var[/=$a]
Steps-leading-lone-slash-17,Error: XPST0003: Unable to parse XPath: "         declare variable $var := document {<a>123</a>};          declare variable $a := document {<a>123</a>};          $var[5*/]         ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", ";", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.          declare variable $var := document [Error is around here]{<a>123</a>};          declare variable $a := document {<a>123</a>};          $var[5*/]
string-constructor-001,Error: XPST0003: Unable to parse XPath: "(         declare variable $n as xs:integer external := 10;          ``[There were `{$n}` green bottles]``       ) instance of xs:string". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. (         declare [Error is around here]variable $n as xs:integer external := 10;          ``[There were `{$n}` green bottles]``       ) instance of xs:string
string-constructor-002,Error: XPST0003: Unable to parse XPath: "(         declare variable $n as xs:integer external := 10;          ``[There were 10 green bottles]``       ) instance of xs:string". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. (         declare [Error is around here]variable $n as xs:integer external := 10;          ``[There were 10 green bottles]``       ) instance of xs:string
string-constructor-003,Error: XPST0003: Unable to parse XPath: "(         declare variable $n as xs:integer external := 10;          declare variable $thing as xs:string external := ``[wall]``;         ``[There were `{$n}` green bottles hanging on the `{$thing}`]``       ) instance of xs:string". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. (         declare [Error is around here]variable $n as xs:integer external := 10;          declare variable $thing as xs:string external := ``[wall]``;         ``[There were `{$n}` green bottles hanging on the `{$thing}`]``       ) instance of xs:string
string-constructor-004,Error: XPST0003: Unable to parse XPath: "(         declare variable $n as xs:integer external := 10;          ``[There were &lt; `{$n}` green bottles]``       ) instance of xs:string". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. (         declare [Error is around here]variable $n as xs:integer external := 10;          ``[There were &lt; `{$n}` green bottles]``       ) instance of xs:string
string-constructor-005,Error: XPST0003: Unable to parse XPath: "(         declare variable $n as xs:integer external := 10;          ``["{}"'[`]'\\<> `{$n}`]``       ) instance of xs:string". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. (         declare [Error is around here]variable $n as xs:integer external := 10;          ``["{}"'[`]'\\<> `{$n}`]``       ) instance of xs:string
string-constructor-006,Error: XPST0003: Unable to parse XPath: "(         declare variable $n as xs:integer external := 10;          ``[`{$n}``{$n+1}``{$n+2}`]``       ) instance of xs:string". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. (         declare [Error is around here]variable $n as xs:integer external := 10;          ``[`{$n}``{$n+1}``{$n+2}`]``       ) instance of xs:string
string-constructor-007,Error: XPST0003: Unable to parse XPath: "(         declare variable $n as xs:integer external := 10;          ``[ `{$n}` `{$n+1}` `{$n+2}` ]``       ) instance of xs:string". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. (         declare [Error is around here]variable $n as xs:integer external := 10;          ``[ `{$n}` `{$n+1}` `{$n+2}` ]``       ) instance of xs:string
string-constructor-008,Error: XPST0003: Unable to parse XPath: "(         declare variable $n external := <e>10</e>;          ``[There were `{$n}` green bottles]``       ) instance of xs:string". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. (         declare [Error is around here]variable $n external := <e>10</e>;          ``[There were `{$n}` green bottles]``       ) instance of xs:string
string-constructor-009,Error: XPST0003: Unable to parse XPath: "(         declare variable $n external := <e>10</e>;          ``[There were `{``[at least `{$n}`]``}` green bottles]``       ) instance of xs:string". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. (         declare [Error is around here]variable $n external := <e>10</e>;          ``[There were `{``[at least `{$n}`]``}` green bottles]``       ) instance of xs:string
string-constructor-010,Error: XPST0003: Unable to parse XPath: "         declare variable $n external := <e>10</e>;          <a>{``[There were `{$n}` green bottles]``}</a>       ". Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", "}", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "`" found.          declare variable $n external := <e>10</e>;          <a>{[Error is around here]``[There were `{$n}` green bottles]``}</a>
string-constructor-011,Error: XPST0003: Unable to parse XPath: "         declare variable $n external := <e>10</e>;          <a text="{``[There were `{$n}` green bottles]``}"/>       ". Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", "}", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "`" found.          declare variable $n external := <e>10</e>;          <a text="{[Error is around here]``[There were `{$n}` green bottles]``}"/>
string-constructor-012,Error: XPST0003: Unable to parse XPath: "(         declare variable $n as xs:integer external := 10;          if ($n lt 20) then ``[There were `{$n}` green bottles]`` else ``[There were many green bottles]``       ) instance of xs:string". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. (         declare [Error is around here]variable $n as xs:integer external := 10;          if ($n lt 20) then ``[There were `{$n}` green bottles]`` else ``[There were many green bottles]``       ) instance of xs:string
string-constructor-013,Error: XPST0003: Unable to parse XPath: "(         declare variable $n as xs:integer external := 10;          ``[There were `{$n}` green bottles]``[$n lt 20]       ) instance of xs:string". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. (         declare [Error is around here]variable $n as xs:integer external := 10;          ``[There were `{$n}` green bottles]``[$n lt 20]       ) instance of xs:string
string-constructor-014,Error: XPST0003: Unable to parse XPath: "(         declare variable $n as xs:integer external := 10;          ``[There were `{$n}` green bottles]``       ) instance of xs:string". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. (         declare [Error is around here]variable $n as xs:integer external := 10;          ``[There were `{$n}` green bottles]``       ) instance of xs:string
string-constructor-015,Error: XPST0003: Unable to parse XPath: "(         declare variable $n as xs:integer external := 10;          [``[There were `{$n}` green bottles]``]?1       ) instance of xs:string". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. (         declare [Error is around here]variable $n as xs:integer external := 10;          [``[There were `{$n}` green bottles]``]?1       ) instance of xs:string
string-constructor-016,Error: XPST0003: Unable to parse XPath: "(         declare variable $n as xs:integer external := 10;          ``[There were `{[$n]}` green bottles]``       ) instance of xs:string". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. (         declare [Error is around here]variable $n as xs:integer external := 10;          ``[There were `{[$n]}` green bottles]``       ) instance of xs:string
string-constructor-017,Error: XPST0003: Unable to parse XPath: "(         declare variable $n as xs:integer external := 10;          ``[There were `{array{$n}}` green bottles]``       ) instance of xs:string". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. (         declare [Error is around here]variable $n as xs:integer external := 10;          ``[There were `{array{$n}}` green bottles]``       ) instance of xs:string
string-constructor-018,Error: XPST0003: Unable to parse XPath: "(         declare variable $n as xs:integer external := 10;          ``[There were `{$n, ()}` green bottles]``       ) instance of xs:string". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. (         declare [Error is around here]variable $n as xs:integer external := 10;          ``[There were `{$n, ()}` green bottles]``       ) instance of xs:string
string-constructor-019,Error: XPST0003: Unable to parse XPath: "(         declare variable $n as xs:integer external := 10;          ``[There were ``{$n}`` green bottles]``       ) instance of xs:string". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. (         declare [Error is around here]variable $n as xs:integer external := 10;          ``[There were ``{$n}`` green bottles]``       ) instance of xs:string
string-constructor-020,Error: XPST0003: Unable to parse XPath: "(         declare variable $n as xs:integer external := 10;          ``[``[There were `{"`{"}``{$n}`}` green bottles`{"]``"}`]``       ) instance of xs:string". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. (         declare [Error is around here]variable $n as xs:integer external := 10;          ``[``[There were `{"`{"}``{$n}`}` green bottles`{"]``"}`]``       ) instance of xs:string
string-constructor-021,Error: XPST0003: Unable to parse XPath: "         matches("""", ``[["']]``)       ". Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "`" found.          matches("""", [Error is around here]``[["']]``)
string-constructor-022,Error: XPST0003: Unable to parse XPath: "``[]`` = """. Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "declare", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "import", "let", "map", "module", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", "xquery", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "`" found. [Error is around here]``[]`` = ""
string-constructor-023,Error: XPST0003: Unable to parse XPath: "``[` {$n}`]`` = "` {$n}`"". Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "declare", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "import", "let", "map", "module", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", "xquery", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "`" found. [Error is around here]``[` {$n}`]`` = "` {$n}`"
string-constructor-024,Error: XPST0003: Unable to parse XPath: "``[` *`{}`* `]`` = "` ** `"". Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "declare", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "import", "let", "map", "module", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", "xquery", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "`" found. [Error is around here]``[` *`{}`* `]`` = "` ** `"
string-constructor-025,Error: XPST0003: Unable to parse XPath: "``[` *`{(:Nothing here:)}`* `]`` = "` ** `"". Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "declare", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "import", "let", "map", "module", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", "xquery", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "`" found. [Error is around here]``[` *`{(:Nothing here:)}`* `]`` = "` ** `"
string-constructor-026,Error: XPST0003: Unable to parse XPath: "``[ *`{xs:date('2012-05-05')}`* ]`` = " *2012-05-05* "". Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "declare", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "import", "let", "map", "module", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", "xquery", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "`" found. [Error is around here]``[ *`{xs:date('2012-05-05')}`* ]`` = " *2012-05-05* "
string-constructor-910,AssertionError: expected [Function] to throw error including 'FOTY0013' but got 'XPST0003: Unable to parse XPath: "\n        declare variable $n external := map{\'a\':10}; \n        ``[There were `{$n}` green bottles]``\n      ".\nExpected " ", "$", "\'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\\"", "\\n", "\\r", "\\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "declare", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "`" found.\n\n        declare variable $n external := map{\'a\':10}; \n        [Error is around here]``[There were `{$n}` green bottles]``\n      '
string-constructor-911,AssertionError: expected [Function] to throw error including 'FOTY0013' but got 'XPST0003: Unable to parse XPath: "\n        declare variable $n external := map{\'a\':10}; \n        ``[There were `{map{\'a\':10}}` green bottles]``\n      ".\nExpected " ", "$", "\'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\\"", "\\n", "\\r", "\\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "declare", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "`" found.\n\n        declare variable $n external := map{\'a\':10}; \n        [Error is around here]``[There were `{map{\'a\':10}}` green bottles]``\n      '
string-constructor-912,Error: XPST0003: Unable to parse XPath: "         declare variable $n as xs:integer external := 10;          ``[There were `{1 to $n}` green bottles]``        = "There were 1 2 3 4 5 6 7 8 9 10 green bottles"". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.          declare variable $n [Error is around here]as xs:integer external := 10;          ``[There were `{1 to $n}` green bottles]``        = "There were 1 2 3 4 5 6 7 8 9 10 green bottles"
Orderexpr-1,Error: XPST0003: Unable to parse XPath: "ordered {//part[@partid < 2]}". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. ordered [Error is around here]{//part[@partid < 2]}
Orderexpr-2,AssertionError: Expected executing the XPath "unordered {//part[@partid < 2]}" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "unordered {//part[@partid < 2]}". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. unordered [Error is around here]{//part[@partid < 2]}, Error: XPST0003: Unable to parse XPath: "unordered {//part[@partid < 2]}". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. unordered [Error is around here]{//part[@partid < 2]}.
Orderexpr-5,Error: XPST0003: Unable to parse XPath: "ordered {//part[@partid < 2][2]}". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. ordered [Error is around here]{//part[@partid < 2][2]}
Orderexpr-6,AssertionError: Expected executing the XPath "unordered {//part[@partid < 2][2]}" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "unordered {//part[@partid < 2][2]}". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. unordered [Error is around here]{//part[@partid < 2][2]}, Error: XPST0003: Unable to parse XPath: "unordered {//part[@partid < 2][2]}". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. unordered [Error is around here]{//part[@partid < 2][2]}.
Orderexpr-9,Error: XPST0003: Unable to parse XPath: "ordered {//part[@partof = 1] union //part[@partid = 1] }". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. ordered [Error is around here]{//part[@partof = 1] union //part[@partid = 1] }
Orderexpr-10,AssertionError: Expected executing the XPath "unordered {//part[@partof = 1] union //part[@partid = 1] }" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "unordered {//part[@partof = 1] union //part[@partid = 1] }". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. unordered [Error is around here]{//part[@partof = 1] union //part[@partid = 1] }, Error: XPST0003: Unable to parse XPath: "unordered {//part[@partof = 1] union //part[@partid = 1] }". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. unordered [Error is around here]{//part[@partof = 1] union //part[@partid = 1] }.
Orderexpr-11,Error: XPST0003: Unable to parse XPath: "ordered {//part[@partof < 2] intersect //part[@partid = 1 or @partid > 2] }". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. ordered [Error is around here]{//part[@partof < 2] intersect //part[@partid = 1 or @partid > 2] }
Orderexpr-12,AssertionError: Expected executing the XPath "unordered {//part[@partof < 2] intersect //part[@partid = 1 or @partid > 2] }" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "unordered {//part[@partof < 2] intersect //part[@partid = 1 or @partid > 2] }". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. unordered [Error is around here]{//part[@partof < 2] intersect //part[@partid = 1 or @partid > 2] }, Error: XPST0003: Unable to parse XPath: "unordered {//part[@partof < 2] intersect //part[@partid = 1 or @partid > 2] }". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. unordered [Error is around here]{//part[@partof < 2] intersect //part[@partid = 1 or @partid > 2] }.
Orderexpr-13,Error: XPST0003: Unable to parse XPath: "ordered {//part[@partof < 2] except //part[@partid = 2] }". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. ordered [Error is around here]{//part[@partof < 2] except //part[@partid = 2] }
Orderexpr-14,AssertionError: Expected executing the XPath "unordered {//part[@partof < 2] except //part[@partid = 2] }" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "unordered {//part[@partof < 2] except //part[@partid = 2] }". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. unordered [Error is around here]{//part[@partof < 2] except //part[@partid = 2] }, Error: XPST0003: Unable to parse XPath: "unordered {//part[@partof < 2] except //part[@partid = 2] }". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. unordered [Error is around here]{//part[@partof < 2] except //part[@partid = 2] }.
Orderexpr-15,Error: XPST0003: Unable to parse XPath: "ordered {fn:subsequence((1,2,3,4),2,2)}". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. ordered [Error is around here]{fn:subsequence((1,2,3,4),2,2)}
Orderexpr-16,AssertionError: Expected executing the XPath "unordered {fn:subsequence((1,2,3,4),2,2)}" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "unordered {fn:subsequence((1,2,3,4),2,2)}". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. unordered [Error is around here]{fn:subsequence((1,2,3,4),2,2)}, Error: XPST0003: Unable to parse XPath: "unordered {fn:subsequence((1,2,3,4),2,2)}". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. unordered [Error is around here]{fn:subsequence((1,2,3,4),2,2)}.
Orderexpr-17,Error: XPST0003: Unable to parse XPath: "ordered {fn:reverse((3,2))}". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. ordered [Error is around here]{fn:reverse((3,2))}
Orderexpr-18,AssertionError: Expected executing the XPath "unordered {fn:reverse((2,3))}" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "unordered {fn:reverse((2,3))}". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. unordered [Error is around here]{fn:reverse((2,3))}, Error: XPST0003: Unable to parse XPath: "unordered {fn:reverse((2,3))}". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. unordered [Error is around here]{fn:reverse((2,3))}.
Orderexpr-19,Error: XPST0003: Unable to parse XPath: "ordered { for $i in (//part[@partid = 1], //part[@partid = 2]), $j in (//part[@partof = $i/@partid]) where ($i/@partid + $j/@partid) < 7 return $i/@partid + $j/@partid }". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. ordered [Error is around here]{ for $i in (//part[@partid = 1], //part[@partid = 2]), $j in (//part[@partof = $i/@partid]) where ($i/@partid + $j/@partid) < 7 return $i/@partid + $j/@partid }
Orderexpr-20,AssertionError: Expected executing the XPath "unordered { for $i in (//part[@partid = 1], //part[@partid = 2]), $j in (//part[@partof = $i/@partid]) where ($i/@partid + $j/@partid) < 7 return $i/@partid + $j/@partid }" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "unordered { for $i in (//part[@partid = 1], //part[@partid = 2]), $j in (//part[@partof = $i/@partid]) where ($i/@partid + $j/@partid) < 7 return $i/@partid + $j/@partid }". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. unordered [Error is around here]{ for $i in (//part[@partid = 1], //part[@partid = 2]), $j in (//part[@partof = $i/@partid]) where ($i/@partid + $j/@partid) < 7 return $i/@partid + $j/@partid }, Error: XPST0003: Unable to parse XPath: "unordered { for $i in (//part[@partid = 1], //part[@partid = 2]), $j in (//part[@partof = $i/@partid]) where ($i/@partid + $j/@partid) < 7 return $i/@partid + $j/@partid }". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. unordered [Error is around here]{ for $i in (//part[@partid = 1], //part[@partid = 2]), $j in (//part[@partof = $i/@partid]) where ($i/@partid + $j/@partid) < 7 return $i/@partid + $j/@partid }.
orderedunorderedexpr-1,Error: XPST0003: Unable to parse XPath: "ordered {if (fn:true()) then (0,1,2,3,4) else ("A","B","C")}". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. ordered [Error is around here]{if (fn:true()) then (0,1,2,3,4) else ("A","B","C")}
orderedunorderedexpr-2,Error: XPST0003: Unable to parse XPath: "ordered {if (1 eq 1 and 2 eq 2) then (0,1,2,3,4) else ("a","b")}". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. ordered [Error is around here]{if (1 eq 1 and 2 eq 2) then (0,1,2,3,4) else ("a","b")}
orderedunorderedexpr-3,Error: XPST0003: Unable to parse XPath: "ordered {if (1 eq 1 or 2 eq 3) then (0,1,2,3,4) else ("a","b")}". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. ordered [Error is around here]{if (1 eq 1 or 2 eq 3) then (0,1,2,3,4) else ("a","b")}
orderedunorderedexpr-4,Error: XPST0003: Unable to parse XPath: "ordered {if (some $x in (1, 2, 3), $y in (2, 3, 4) satisfies $x + $y = 4) then (0,1,2,3,4) else ("a","b")}". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. ordered [Error is around here]{if (some $x in (1, 2, 3), $y in (2, 3, 4) satisfies $x + $y = 4) then (0,1,2,3,4) else ("a","b")}
orderedunorderedexpr-5,Error: XPST0003: Unable to parse XPath: "ordered {if (every $x in (1, 2, 3) satisfies $x < 4) then (0,1,2,3,4) else ("a","b")}". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. ordered [Error is around here]{if (every $x in (1, 2, 3) satisfies $x < 4) then (0,1,2,3,4) else ("a","b")}
orderedunorderedexpr-6,Error: XPST0003: Unable to parse XPath: "ordered {typeswitch(123) case $i as xs:string return ("a","b","c") case $i as xs:double return ("a","b","c") case $i as xs:integer return (1,2,3,4) default return ("a","b","c") }". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found. ordered [Error is around here]{typeswitch(123) case $i as xs:string return ("a","b","c") case $i as xs:double return ("a","b","c") case $i as xs:integer return (1,2,3,4) default return ("a","b","c") }
K-OrderExpr-1a,Error: XPST0003: Unable to parse XPath: "(ordered{}) => empty()". Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. (ordered[Error is around here]{}) => empty()
K-OrderExpr-2a,Error: XPST0003: Unable to parse XPath: "(unordered{}) => empty()". Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. (unordered[Error is around here]{}) => empty()
K-OrderExpr-3,Error: XPST0003: Unable to parse XPath: "ordered{true()}". Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "{" found. ordered[Error is around here]{true()}
K-OrderExpr-4,Error: XPST0003: Unable to parse XPath: "unordered{true()}". Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "{" found. unordered[Error is around here]{true()}
UnaryLookup-001,Error: XPST0003: Unable to parse XPath: "deep-equal(((['a', 'b'], ['c', 'd'])[?1 eq 'c']), (['c', 'd']))". Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "?" found. deep-equal(((['a', 'b'], ['c', 'd'])[[Error is around here]?1 eq 'c']), (['c', 'd']))
UnaryLookup-002,Error: XPST0003: Unable to parse XPath: "deep-equal((let $i := 1 return (['a', 'b'], ['c', 'd'])[?($i) eq 'c']), (['c', 'd']))". Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "?" found. deep-equal((let $i := 1 return (['a', 'b'], ['c', 'd'])[[Error is around here]?($i) eq 'c']), (['c', 'd']))
UnaryLookup-003,Error: XPST0003: Unable to parse XPath: "deep-equal(((['a', 'b'], ['c', 'd'])[ ? 001 eq 'c']), (['c', 'd']))". Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "?" found. deep-equal(((['a', 'b'], ['c', 'd'])[ [Error is around here]? 001 eq 'c']), (['c', 'd']))
UnaryLookup-005,AssertionError: expected [Function] to throw error including 'FOAY0001' but got 'XPST0003: Unable to parse XPath: "([\'a\', \'b\'], [\'c\', \'d\'])[ ?0 eq \'c\']".\nExpected " ", "$", "\'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\\"", "\\n", "\\r", "\\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "?" found.\n([\'a\', \'b\'], [\'c\', \'d\'])[ [Error is around here]?0 eq \'c\']'
UnaryLookup-006,AssertionError: expected [Function] to throw error including 'FOAY0001' but got 'XPST0003: Unable to parse XPath: "([\'a\', \'b\'], [\'c\', \'d\'], [\'e\'])[ ?2 eq \'b\']".\nExpected " ", "$", "\'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\\"", "\\n", "\\r", "\\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "?" found.\n([\'a\', \'b\'], [\'c\', \'d\'], [\'e\'])[ [Error is around here]?2 eq \'b\']'
UnaryLookup-007,Error: XPST0003: Unable to parse XPath: "deep-equal(((['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[ ?(1 to 2) = 'b']), (['a', 'b', 'c'], ['b', 'c', 'd']))". Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "?" found. deep-equal(((['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[ [Error is around here]?(1 to 2) = 'b']), (['a', 'b', 'c'], ['b', 'c', 'd']))
UnaryLookup-008,Error: XPST0003: Unable to parse XPath: "deep-equal((let $i := (1, 3) return (['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[ ?($i) = 'b']), (['b', 'c', 'd'], ['e', 'f', 'b']))". Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "?" found. deep-equal((let $i := (1, 3) return (['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[ [Error is around here]?($i) = 'b']), (['b', 'c', 'd'], ['e', 'f', 'b']))
UnaryLookup-009,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "([\'a\', \'b\', \'c\'], [\'b\', \'c\', \'d\'], [\'e\', \'f\', \'b\'])[ ?first = \'b\']".\nExpected " ", "$", "\'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\\"", "\\n", "\\r", "\\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "?" found.\n([\'a\', \'b\', \'c\'], [\'b\', \'c\', \'d\'], [\'e\', \'f\', \'b\'])[ [Error is around here]?first = \'b\']'
UnaryLookup-010,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "let $d := current-date() return ([\'a\', \'b\', \'c\'], [\'b\', \'c\', \'d\'], [\'e\', \'f\', \'b\'])[ ?($d) = \'b\']".\nExpected " ", "$", "\'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\\"", "\\n", "\\r", "\\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "?" found.\nlet $d := current-date() return ([\'a\', \'b\', \'c\'], [\'b\', \'c\', \'d\'], [\'e\', \'f\', \'b\'])[ [Error is around here]?($d) = \'b\']'
UnaryLookup-011,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: "let $d := function($x) {$x + ?2} return $d(12)".\nExpected " ", "$", "\'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\\"", "\\n", "\\r", "\\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "?" found.\nlet $d := function($x) {$x + [Error is around here]?2} return $d(12)'
UnaryLookup-012,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "(1 to 10)[?1 = 3]".\nExpected " ", "$", "\'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\\"", "\\n", "\\r", "\\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "?" found.\n(1 to 10)[[Error is around here]?1 = 3]'
UnaryLookup-013,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "(floor#1, ceiling#1, round#1, abs#1)[?1 = 1]".\nExpected " ", "$", "\'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\\"", "\\n", "\\r", "\\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "?" found.\n(floor#1, ceiling#1, round#1, abs#1)[[Error is around here]?1 = 1]'
UnaryLookup-014,Error: XPST0003: Unable to parse XPath: "deep-equal(((['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[ ?* = 'c']), (['a', 'b', 'c'], ['b', 'c', 'd']))". Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "?" found. deep-equal(((['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[ [Error is around here]?* = 'c']), (['a', 'b', 'c'], ['b', 'c', 'd']))
UnaryLookup-015,Error: XPST0003: Unable to parse XPath: "deep-equal((([1, [2], [3]], [[2], 2, [4]])[ ?1 = ?2 ]), ([[2], 2, [4]]))". Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "?" found. deep-equal((([1, [2], [3]], [[2], 2, [4]])[ [Error is around here]?1 = ?2 ]), ([[2], 2, [4]]))
UnaryLookup-016,Error: XPST0003: Unable to parse XPath: "deep-equal(((['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[contains(?1, ?, 'http://www.w3.org/2005/xpath-functions/collation/codepoint')('a')]), (['a', 'b', 'c']))". Expected " ", "(:", ")", ",", "\n", "\r", or "\t" but "1" found. deep-equal(((['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[contains(?[Error is around here]1, ?, 'http://www.w3.org/2005/xpath-functions/collation/codepoint')('a')]), (['a', 'b', 'c']))
UnaryLookup-017,Error: XPST0003: Unable to parse XPath: "deep-equal(((['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[contains(?1, ?)('a')]), (['a', 'b', 'c']))". Expected " ", "(:", ")", ",", "\n", "\r", or "\t" but "1" found. deep-equal(((['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[contains(?[Error is around here]1, ?)('a')]), (['a', 'b', 'c']))
UnaryLookup-019,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "([\'a\', \'b\', \'c\'], [\'b\', \'c\', \'d\'], [\'e\', \'f\', \'b\'])[?(1.0) = \'a\']".\nExpected " ", "$", "\'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\\"", "\\n", "\\r", "\\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "?" found.\n([\'a\', \'b\', \'c\'], [\'b\', \'c\', \'d\'], [\'e\', \'f\', \'b\'])[[Error is around here]?(1.0) = \'a\']'
UnaryLookup-021,Error: XPST0003: Unable to parse XPath: "deep-equal((         let $x := (<x>1</x>, <y>2</y>) return         (['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[?($x) = 'b']       ), ((['a', 'b', 'c'], ['b', 'c', 'd'])))". Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "?" found. deep-equal((         let $x := (<x>1</x>, <y>2</y>) return         (['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[[Error is around here]?($x) = 'b']       ), ((['a', 'b', 'c'], ['b', 'c', 'd'])))
UnaryLookup-022,Error: XPST0003: Unable to parse XPath: "deep-equal(([['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b']]?*[?1 = 'a']), (['a', 'b', 'c']))". Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "?" found. deep-equal(([['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b']]?*[[Error is around here]?1 = 'a']), (['a', 'b', 'c']))
UnaryLookup-023,Error: XPST0003: Unable to parse XPath: "deep-equal(([['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b']]!?*!?1), ('a', 'b', 'e'))". Expected " ", "$", "'", "(", "(:", "*", "*:", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "?" found. deep-equal(([['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b']]![Error is around here]?*!?1), ('a', 'b', 'e'))
UnaryLookup-024,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "\n        let $x := (<x>1</x>, <y>2</y>) return $x / ?1\n      ".\nExpected " ", "$", "\'", "(", "(:", "*", "*:", ".", "..", "<!--", "<", "<?", "@", "Q", "[", "\\"", "\\n", "\\r", "\\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "?" found.\n\n        let $x := (<x>1</x>, <y>2</y>) return $x / [Error is around here]?1\n      '
UnaryLookup-025,Error: XPST0003: Unable to parse XPath: "((['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[exists(?())]) => empty()". Expected " ", "(:", ")", ",", "\n", "\r", or "\t" but "(" found. ((['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[exists(?[Error is around here]())]) => empty()
UnaryLookup-040,Error: XPST0003: Unable to parse XPath: "deep-equal(((map{'a':1, 'b':2, 'c':3},  map{'a':2, 'b':3, 'c':4})[?b eq 3]), (map{'a':2, 'b':3, 'c':4}))". Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "?" found. deep-equal(((map{'a':1, 'b':2, 'c':3},  map{'a':2, 'b':3, 'c':4})[[Error is around here]?b eq 3]), (map{'a':2, 'b':3, 'c':4}))
UnaryLookup-041,Error: XPST0003: Unable to parse XPath: "deep-equal(((map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})[?2 eq 3]), (map{1:2, 2:3, 3:4}))". Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "?" found. deep-equal(((map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})[[Error is around here]?2 eq 3]), (map{1:2, 2:3, 3:4}))
UnaryLookup-042,Error: XPST0003: Unable to parse XPath: "deep-equal(((map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})[?(1 to 2) = 3]), (map{1:2, 2:3, 3:4}))". Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "?" found. deep-equal(((map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})[[Error is around here]?(1 to 2) = 3]), (map{1:2, 2:3, 3:4}))
UnaryLookup-043,Error: XPST0003: Unable to parse XPath: "deep-equal(((map{'a-1':1, 'b-1':2, 'c-1':3},  map{'a-1':2, 'b-1':3, 'c-1':4})[?b-1 eq 3]), (map{'a-1':2, 'b-1':3, 'c-1':4}))". Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "?" found. deep-equal(((map{'a-1':1, 'b-1':2, 'c-1':3},  map{'a-1':2, 'b-1':3, 'c-1':4})[[Error is around here]?b-1 eq 3]), (map{'a-1':2, 'b-1':3, 'c-1':4}))
UnaryLookup-044,Error: XPST0003: Unable to parse XPath: "deep-equal(((map{'a-1':1, 'b-1':2, 'c-1':3},  map{'a-1':2, 'b-1':3, 'c-1':4})[? (:confusing?:) b-1 eq 3]), (map{'a-1':2, 'b-1':3, 'c-1':4}))". Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "?" found. deep-equal(((map{'a-1':1, 'b-1':2, 'c-1':3},  map{'a-1':2, 'b-1':3, 'c-1':4})[[Error is around here]? (:confusing?:) b-1 eq 3]), (map{'a-1':2, 'b-1':3, 'c-1':4}))
UnaryLookup-045,Error: XPST0003: Unable to parse XPath: "deep-equal(((map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})[?* = 3]), (map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4}))". Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "?" found. deep-equal(((map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})[[Error is around here]?* = 3]), (map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4}))
UnaryLookup-046,Error: XPST0003: Unable to parse XPath: "((map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})[exists(?())]) => empty()". Expected " ", "(:", ")", ",", "\n", "\r", or "\t" but "(" found. ((map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})[exists(?[Error is around here]())]) => empty()
UnaryLookup-048,Error: XPST0003: Unable to parse XPath: "(map{1.1:1, 2.2:2, 3.3:3},  map{1.1:2, 2.2:3, 3.3:4})[?(2.2) = 3]?(3.3) = 4". Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "?" found. (map{1.1:1, 2.2:2, 3.3:3},  map{1.1:2, 2.2:3, 3.3:4})[[Error is around here]?(2.2) = 3]?(3.3) = 4
K-ValCompTypeChecking-16,AssertionError: expected [Function] to throw an error
K-ValCompTypeChecking-17,AssertionError: expected [Function] to throw an error
K-ValCompTypeChecking-18,AssertionError: expected [Function] to throw an error
K-ValCompTypeChecking-19,AssertionError: expected [Function] to throw an error
K-ValCompTypeChecking-20,AssertionError: expected [Function] to throw an error
K-ValCompTypeChecking-21,AssertionError: expected [Function] to throw an error
K-ValCompTypeChecking-22,AssertionError: expected [Function] to throw an error
K-ValCompTypeChecking-23,AssertionError: expected [Function] to throw an error
K-ValCompTypeChecking-24,AssertionError: expected [Function] to throw an error
K-ValCompTypeChecking-25,AssertionError: expected [Function] to throw an error
K-ValCompTypeChecking-26,AssertionError: expected [Function] to throw an error
K-ValCompTypeChecking-27,AssertionError: expected [Function] to throw an error
K-ValCompTypeChecking-28,AssertionError: expected [Function] to throw an error
K-ValCompTypeChecking-29,AssertionError: expected [Function] to throw an error
K-ValCompTypeChecking-35,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
K-ValCompTypeChecking-36,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
K-ValCompTypeChecking-37,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
K-ValCompTypeChecking-38,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
K-ValCompTypeChecking-39,AssertionError: Expected executing the XPath "3 eq (3, error())" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?', AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'.
K-ValCompTypeChecking-40,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
K-ValCompTypeChecking-41,AssertionError: Expected executing the XPath "(3, error()) eq 3" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?', AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'.
value-comparison-5,Error: Atomizing array(*) is not implemented.
value-comparison-6,Error: Atomizing array(*) is not implemented.
value-comparison-7,Error: Atomizing array(*) is not implemented.
value-comparison-8,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Atomizing array(*) is not implemented.'
VarDecl001,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl002,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl003,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl004,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl005,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl006,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl007,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl008,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl009,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl010,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl011,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl012,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl013,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl014,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl015,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl016,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl017,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl018,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl019,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl020,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl021,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl022,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl023,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl024,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl025,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl026,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl027,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl028,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl029,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl030,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl031,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl032,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl033,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl034,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl035,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl036,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl037,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl038,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl039,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl040,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl041,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl042,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl043,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl044,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl045,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl046,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl047,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl048,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl049,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl050,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl051,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl052,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl053,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl054,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl055,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl056,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl057,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl058,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl059,Error: XPST0003: Unable to parse XPath: "declare variable $x := (//book/price, (), (1)) ; document{$x}". Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "{" found. declare variable $x := (//book/price, (), (1)) ; document[Error is around here]{$x}
VarDecl060,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl061,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl062,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl063,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
VarDecl064,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
vardeclerr,AssertionError: expected [Function] to throw error including 'XQST0054' but got 'XPST0003: Unable to parse XPath: "\n      declare namespace foo = "http://www..oracle.com/xquery/test"; \n      declare variable $var1 as xs:integer := foo:price(xs:integer(2)); \n      declare function foo:price ($b as xs:integer) as xs:integer { $var1 + 1 }; \n      $var1".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\n\n      declare namespace foo = "http://www..oracle.com/xquery/test"; \n      declare variable $var1 [Error is around here]as xs:integer := foo:price(xs:integer(2)); \n      declare function foo:price ($b as xs:integer) as xs:integer { $var1 + 1 }; \n      $var1'
vardeclerr-1,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'XPST0003: Unable to parse XPath: "\n      declare namespace foo = "http://www..oracle.com/xquery/test"; \n      declare variable $var1 as xs:integer := foo:price(xs:integer(2)); \n      declare function foo:price ($b as xs:integer) as xs:integer { $var1 + 1 }; \n      $var1".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\n\n      declare namespace foo = "http://www..oracle.com/xquery/test"; \n      declare variable $var1 [Error is around here]as xs:integer := foo:price(xs:integer(2)); \n      declare function foo:price ($b as xs:integer) as xs:integer { $var1 + 1 }; \n      $var1'
internalvar-2,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-InternalVariablesWithout-1,AssertionError: expected [Function] to throw error including 'XQST0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-InternalVariablesWithout-1a,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-InternalVariablesWithout-1b,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-InternalVariablesWithout-1c,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-InternalVariablesWithout-2,AssertionError: expected [Function] to throw error including 'XQST0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-InternalVariablesWithout-2a,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-InternalVariablesWithout-3,AssertionError: expected [Function] to throw error including 'XQST0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-InternalVariablesWithout-3a,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-InternalVariablesWithout-4,AssertionError: expected [Function] to throw error including 'XQST0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-InternalVariablesWithout-4a,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-InternalVariablesWithout-5,AssertionError: expected [Function] to throw error including 'XQST0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-InternalVariablesWithout-5a,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-InternalVariablesWithout-6,AssertionError: expected [Function] to throw error including 'XQST0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-InternalVariablesWithout-6a,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-InternalVariablesWithout-7,AssertionError: expected [Function] to throw error including 'XQST0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-InternalVariablesWithout-7a,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-InternalVariablesWithout-8,AssertionError: expected [Function] to throw error including 'XQST0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-InternalVariablesWithout-8a,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-InternalVariablesWithout-9,AssertionError: expected [Function] to throw error including 'XQST0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-InternalVariablesWithout-9a,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-InternalVariablesWithout-10,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-InternalVariablesWithout-11,AssertionError: Expected executing the XPath "declare variable $local:myVar := local:thisFunctionDoesNotExist(); 1" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XPST0017' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
K2-InternalVariablesWithout-12,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-InternalVariablesWithout-13,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-InternalVariablesWithout-14,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
vardeclwithtype-1,Error: XPST0003: Unable to parse XPath: "declare variable $var as xs:string := "abc"; $var". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $var [Error is around here]as xs:string := "abc"; $var
vardeclwithtype-2,Error: XPST0003: Unable to parse XPath: "declare variable $var as xs:integer := 100; $var = 100". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $var [Error is around here]as xs:integer := 100; $var = 100
vardeclwithtype-3,Error: XPST0003: Unable to parse XPath: "declare variable $var as xs:decimal := 100; $var = 100". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $var [Error is around here]as xs:decimal := 100; $var = 100
vardeclwithtype-4,Error: XPST0003: Unable to parse XPath: "declare variable $var as xs:boolean := fn:true(); $var". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $var [Error is around here]as xs:boolean := fn:true(); $var
vardeclwithtype-5,Error: XPST0003: Unable to parse XPath: "declare variable $var as xs:boolean := fn:false(); $var". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $var [Error is around here]as xs:boolean := fn:false(); $var
vardeclwithtype-6,Error: XPST0003: Unable to parse XPath: "declare variable $var as xs:float := xs:float(12.5E10); $var". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $var [Error is around here]as xs:float := xs:float(12.5E10); $var
vardeclwithtype-7,Error: XPST0003: Unable to parse XPath: "declare variable $var as xs:double := xs:double(1267.43233E12); $var". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $var [Error is around here]as xs:double := xs:double(1267.43233E12); $var
vardeclwithtype-8,Error: XPST0003: Unable to parse XPath: "declare variable $var as xs:anyURI := xs:anyURI("http://example.com"); $var". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $var [Error is around here]as xs:anyURI := xs:anyURI("http://example.com"); $var
vardeclwithtype-9,Error: XPST0003: Unable to parse XPath: "declare variable $var as xs:dateTime := xs:dateTime("1999-11-28T09:00:00Z"); $var". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $var [Error is around here]as xs:dateTime := xs:dateTime("1999-11-28T09:00:00Z"); $var
vardeclwithtype-10,Error: XPST0003: Unable to parse XPath: "declare variable $var as xs:time := xs:time("11:12:00Z"); $var". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $var [Error is around here]as xs:time := xs:time("11:12:00Z"); $var
vardeclwithtype-11,Error: XPST0003: Unable to parse XPath: "declare variable $var as xs:date := xs:date("1999-11-28Z"); $var". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $var [Error is around here]as xs:date := xs:date("1999-11-28Z"); $var
vardeclwithtype-12,AssertionError: expected [Function] to throw error including 'XQST0049' but got 'XPST0003: Unable to parse XPath: "\n      \tdeclare variable $var as xs:date := xs:date("1999-11-28Z"); \n      \tdeclare variable $var as xs:date := xs:date("1999-11-28Z"); \n      \t$var\n      ".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\n\n      \tdeclare variable $var [Error is around here]as xs:date := xs:date("1999-11-28Z"); \n      \tdeclare variable $var as xs:date := xs:date("1999-11-28Z"); \n      \t$var\n      '
vardeclwithtype-13,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "declare variable $var as xs:date := fn:true() and fn:true(); $var".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\ndeclare variable $var [Error is around here]as xs:date := fn:true() and fn:true(); $var'
vardeclwithtype-14,Error: XPST0003: Unable to parse XPath: "declare variable $x as xs:integer := 10; declare variable $var as xs:integer := $x +1; $var = 11". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $x [Error is around here]as xs:integer := 10; declare variable $var as xs:integer := $x +1; $var = 11
vardeclwithtype-15a,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'XPST0003: Unable to parse XPath: "\n        declare variable $var as xs:integer := $e +1; \n        declare variable $e as xs:integer := 10;  \n        $var\n      ".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\n\n        declare variable $var [Error is around here]as xs:integer := $e +1; \n        declare variable $e as xs:integer := 10;  \n        $var\n      '
vardeclwithtype-15b,Error: XPST0003: Unable to parse XPath: "       declare variable $var as xs:integer := $e +1;        declare variable $e as xs:integer := 10;         $var = 11". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.        declare variable $var [Error is around here]as xs:integer := $e +1;        declare variable $e as xs:integer := 10;         $var = 11
vardeclwithtype-16,Error: XPST0003: Unable to parse XPath: "       	declare namespace p1 = "http://www.example.com";        	declare variable $p1:var as xs:integer := 10;        	$p1:var        = 10". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.        	declare namespace p1 = "http://www.example.com";        	declare variable $p1:var [Error is around here]as xs:integer := 10;        	$p1:var        = 10
vardeclwithtype-17,Error: XPST0003: Unable to parse XPath: "       	declare namespace p1 = "http://www.example.com";        	declare namespace p2 = "http://www.example.com/examples";        	declare variable $p1:var as xs:integer := 10;        	declare variable $p2:var as xs:integer := 20;        	$p2:var        = 20". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.        	declare namespace p1 = "http://www.example.com";        	declare namespace p2 = "http://www.example.com/examples";        	declare variable $p1:var [Error is around here]as xs:integer := 10;        	declare variable $p2:var as xs:integer := 20;        	$p2:var        = 20
vardeclwithtype-18,AssertionError: expected [Function] to throw error including 'XQST0049' but got 'XPST0003: Unable to parse XPath: "\n      \tdeclare namespace p1 = "http://www.example.com"; \n      \tdeclare namespace p2 = "http://www.example.com"; \n      \tdeclare variable $p1:var as xs:integer := 10; \n      \tdeclare variable $p2:var as xs:integer := 20; \n      \t$p2:var\n      ".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\n\n      \tdeclare namespace p1 = "http://www.example.com"; \n      \tdeclare namespace p2 = "http://www.example.com"; \n      \tdeclare variable $p1:var [Error is around here]as xs:integer := 10; \n      \tdeclare variable $p2:var as xs:integer := 20; \n      \t$p2:var\n      '
vardeclwithtype-19,Error: XPST0003: Unable to parse XPath: "declare variable $var as xs:integer := fn:count((10,2)); $var = 2". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $var [Error is around here]as xs:integer := fn:count((10,2)); $var = 2
vardeclwithtype-20,Error: XPST0003: Unable to parse XPath: "declare variable $var as xs:integer := fn:string-length("ABC"); $var = 3". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $var [Error is around here]as xs:integer := fn:string-length("ABC"); $var = 3
vardeclwithtype-21,Error: XPST0003: Unable to parse XPath: "declare variable $var as xs:boolean := fn:not(fn:true()); $var". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $var [Error is around here]as xs:boolean := fn:not(fn:true()); $var
vardeclwithtype-22,Error: XPST0003: Unable to parse XPath: "declare variable $var as xs:boolean := fn:empty((1,2,3)); $var". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $var [Error is around here]as xs:boolean := fn:empty((1,2,3)); $var
internalvar-1,Error: XPST0003: Unable to parse XPath: "declare(::)variable(::)$var(::)as(::)item((: :))*(::):=(::)1(::);(::) 1(::)eq(::)1(::)". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare(::)variable(::)$var(::)[Error is around here]as(::)item((: :))*(::):=(::)1(::);(::) 1(::)eq(::)1(::)
K-InternalVariablesWith-1,Error: XPST0003: Unable to parse XPath: "declare(::)variable(::)$local:var(::)as(::)item((: :))* :=3(::);(::)1(::)eq(::)1". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare(::)variable(::)$local:var(::)[Error is around here]as(::)item((: :))* :=3(::);(::)1(::)eq(::)1
K-InternalVariablesWith-2,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K-InternalVariablesWith-3,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "declare variable $myVar as xs:integer := subsequence((1, 2, "a string"), 3, 1); $myVar eq 3".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\ndeclare variable $myVar [Error is around here]as xs:integer := subsequence((1, 2, "a string"), 3, 1); $myVar eq 3'
K-InternalVariablesWith-4,AssertionError: Expected executing the XPath "declare variable $myVar as xs:gYear := 2006; true()" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "declare variable $myVar as xs:gYear := 2006; true()". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $myVar [Error is around here]as xs:gYear := 2006; true(), AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "declare variable $myVar as xs:gYear := 2006; true()".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\ndeclare variable $myVar [Error is around here]as xs:gYear := 2006; true()'.
K-InternalVariablesWith-5,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "declare variable $myVar as xs:gYear := 2006; $myVar".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\ndeclare variable $myVar [Error is around here]as xs:gYear := 2006; $myVar'
K-InternalVariablesWith-6a,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K-InternalVariablesWith-6b,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K-InternalVariablesWith-9a,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K-InternalVariablesWith-9b,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K-InternalVariablesWith-11,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K-InternalVariablesWith-12,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K-InternalVariablesWith-13,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "declare variable $var1 as xs:string := local:myFunc(); declare function local:myFunc() as xs:integer { 1 }; $var1 eq 1".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\ndeclare variable $var1 [Error is around here]as xs:string := local:myFunc(); declare function local:myFunc() as xs:integer { 1 }; $var1 eq 1'
K-InternalVariablesWith-14,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "declare variable $var1 as xs:string := local:myFunc(); declare function local:myFunc() { 1 }; $var1 eq 1".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\ndeclare variable $var1 [Error is around here]as xs:string := local:myFunc(); declare function local:myFunc() { 1 }; $var1 eq 1'
K-InternalVariablesWith-15a,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K-InternalVariablesWith-15b,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K-InternalVariablesWith-16,AssertionError: expected [Function] to throw error including 'XQST0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K-InternalVariablesWith-16a,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K-InternalVariablesWith-17,AssertionError: expected [Function] to throw error including 'XQST0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K-InternalVariablesWith-17a,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K-InternalVariablesWith-18,AssertionError: expected [Function] to throw error including 'XQST0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K-InternalVariablesWith-18a,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K-InternalVariablesWith-19,AssertionError: expected [Function] to throw error including 'XQST0054' but got 'XPST0003: Unable to parse XPath: "declare variable $var2 := local:func1(); declare variable $var := ($var2 treat as xs:integer) + 1; declare function local:func1() { local:func2() }; declare function local:func2() { local:func3() }; declare function local:func3() { local:func4() }; declare function local:func4() { $var }; boolean($var)".\nExpected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.\ndeclare variable $var2 := local:func1(); declare variable $var := ($var2 [Error is around here]treat as xs:integer) + 1; declare function local:func1() { local:func2() }; declare function local:func2() { local:func3() }; declare function local:func3() { local:func4() }; declare function local:func4() { $var }; boolean($var)'
K-InternalVariablesWith-19a,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'XPST0003: Unable to parse XPath: "declare variable $var2 := local:func1(); declare variable $var := ($var2 treat as xs:integer) + 1; declare function local:func1() { local:func2() }; declare function local:func2() { local:func3() }; declare function local:func3() { local:func4() }; declare function local:func4() { $var }; boolean($var)".\nExpected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.\ndeclare variable $var2 := local:func1(); declare variable $var := ($var2 [Error is around here]treat as xs:integer) + 1; declare function local:func1() { local:func2() }; declare function local:func2() { local:func3() }; declare function local:func3() { local:func4() }; declare function local:func4() { $var }; boolean($var)'
K-InternalVariablesWith-20,AssertionError: expected [Function] to throw error including 'XQST0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K-InternalVariablesWith-20a,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K-InternalVariablesWith-21,Error: XPST0003: Unable to parse XPath: "declare variable $local:var as item() *:=3; true()". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $local:var [Error is around here]as item() *:=3; true()
K2-InternalVariablesWith-1,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "declare variable $var1 as xs:string := 1 treat as item(); $var1".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\ndeclare variable $var1 [Error is around here]as xs:string := 1 treat as item(); $var1'
extvardeclwithouttype-1,AssertionError: Expected executing the XPath "declare variable $x external; fn:string($x)" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
extvardeclwithouttype-2,AssertionError: Expected executing the XPath "declare variable $x external; $x" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
extvardeclwithouttype-3,AssertionError: Expected executing the XPath "declare variable $x external; xs:integer($x)" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
extvardeclwithouttype-4,AssertionError: Expected executing the XPath "declare variable $x external; $x" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
extvardeclwithouttype-5,AssertionError: Expected executing the XPath "declare variable $x external; $x" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
extvardeclwithouttype-6,AssertionError: Expected executing the XPath "declare variable $x external; xs:float($x)" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
extvardeclwithouttype-7,AssertionError: Expected executing the XPath "declare variable $x external; $x" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
extvardeclwithouttype-8,AssertionError: Expected executing the XPath "declare variable $x external; $x + $x" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
extvardeclwithouttype-9,AssertionError: Expected executing the XPath "declare variable $x external; $x" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
extvardeclwithouttype-10,AssertionError: Expected executing the XPath "declare variable $x external; $x + $x" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
extvardeclwithouttype-11,AssertionError: Expected executing the XPath "declare variable $x external; $x * $x" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
extvardeclwithouttype-12,AssertionError: Expected executing the XPath "declare variable $x external; $x - 1" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
extvardeclwithouttype-13,AssertionError: Expected executing the XPath "declare variable $x external; $x idiv 2" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
extvardeclwithouttype-14,AssertionError: Expected executing the XPath "declare variable $x external; $x div 10" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
extvardeclwithouttype-15,AssertionError: Expected executing the XPath "declare variable $x external; $x mod 2" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
extvardeclwithouttype-16,AssertionError: Expected executing the XPath "declare variable $x external; $x and fn:false()" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'FORG0006' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
extvardeclwithouttype-17,AssertionError: Expected executing the XPath "declare variable $x external; $x or fn:false()" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'FORG0006' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
extvardeclwithouttype-18,Error: XPST0003: Unable to parse XPath: "let $result := (declare variable $x external; $x) return $result ge 2.33333333333333". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. let $result := (declare [Error is around here]variable $x external; $x) return $result ge 2.33333333333333
extvardeclwithouttype-19,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
extvardeclwithouttype-20,AssertionError: Expected executing the XPath "declare variable $x external; fn:upper-case($x)" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
extvardeclwithouttype-21,AssertionError: Expected executing the XPath "declare variable $x external; fn:lower-case($x)" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
extvardeclwithouttype-22,AssertionError: Expected executing the XPath "declare variable $x external; fn:not($x)" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'FORG0006' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
extvardeclwithouttype-23,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
extvardeclwithouttype-24,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-ExternalVariablesWithout-1,AssertionError: expected [Function] to throw error including 'XQST0049' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-ExternalVariablesWithout-2,AssertionError: expected [Function] to throw error including 'XQST0049' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-ExternalVariablesWithout-3,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-ExternalVariablesWithout-4,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-ExternalVariablesWithout-5,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-ExternalVariablesWithout-6,AssertionError: Expected executing the XPath "declare variable $exampleComThisVarIsNotRecognized external; 1" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
K2-ExternalVariablesWithout-7,AssertionError: Expected executing the XPath "declare namespace e = "http://example.com/ANamespace"; declare variable $e:exampleComThisVarIsNotRecognized external; 1" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
K2-ExternalVariablesWithout-8,Error: XPST0003: Unable to parse XPath: "declare variable $ name := 3; $ name = 3". Expected "Q", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but " " found. declare variable $ name := 3; $[Error is around here] name = 3
K2-ExternalVariablesWithout-9,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-ExternalVariablesWithout-10,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-ExternalVariablesWithout-11,Error: XPST0003: Unable to parse XPath: "declare variable $a as attribute()* := (attribute name1 {()}, attribute name2 {()}, attribute name3 {()}); declare variable $b as attribute()* := (attribute name1 {()}, attribute name2 {()}, attribute name3 {()}); $a/(let $p := position() return . is $b[$p])". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $a [Error is around here]as attribute()* := (attribute name1 {()}, attribute name2 {()}, attribute name3 {()}); declare variable $b as attribute()* := (attribute name1 {()}, attribute name2 {()}, attribute name3 {()}); $a/(let $p := position() return . is $b[$p])
K2-ExternalVariablesWithout-12,Error: XPST0003: Unable to parse XPath: "declare variable $a as attribute()* := (attribute name1 {()}, attribute name2 {()}, attribute name3 {()}); <r> <e> { $a } </e> <e> { $a } </e> </r>". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $a [Error is around here]as attribute()* := (attribute name1 {()}, attribute name2 {()}, attribute name3 {()}); <r> <e> { $a } </e> <e> { $a } </e> </r>
K2-ExternalVariablesWithout-13,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-ExternalVariablesWithout-18,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-ExternalVariablesWithout-18b,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-ExternalVariablesWithout-19,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-ExternalVariablesWithout-20,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-ExternalVariablesWithout-21,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
K2-ExternalVariablesWithout-22,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
extvardeclwithtype-1,Error: XPST0003: Unable to parse XPath: "declare variable $x as xs:string external; $x". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $x [Error is around here]as xs:string external; $x
extvardeclwithtype-2,Error: XPST0003: Unable to parse XPath: "declare variable $x as xs:date external; fn:string($x)". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $x [Error is around here]as xs:date external; fn:string($x)
extvardeclwithtype-3,Error: XPST0003: Unable to parse XPath: "declare variable $x as xs:integer external; $x = 2". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $x [Error is around here]as xs:integer external; $x = 2
extvardeclwithtype-4,Error: XPST0003: Unable to parse XPath: "declare variable $x as xs:double external; $x = 120". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $x [Error is around here]as xs:double external; $x = 120
extvardeclwithtype-5,Error: XPST0003: Unable to parse XPath: "declare variable $x as xs:boolean external; fn:string($x)". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $x [Error is around here]as xs:boolean external; fn:string($x)
extvardeclwithtype-6,AssertionError: Expected executing the XPath "declare variable $x as xs:float external; $x" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "declare variable $x as xs:float external; $x". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $x [Error is around here]as xs:float external; $x, Error: XPST0003: Unable to parse XPath: "declare variable $x as xs:float external; $x". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $x [Error is around here]as xs:float external; $x.
extvardeclwithtype-7,Error: XPST0003: Unable to parse XPath: "declare variable $x as xs:decimal external; $x". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $x [Error is around here]as xs:decimal external; $x
extvardeclwithtype-8,Error: XPST0003: Unable to parse XPath: "declare variable $x as xs:integer external; $x + $x = 4". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $x [Error is around here]as xs:integer external; $x + $x = 4
extvardeclwithtype-9,Error: XPST0003: Unable to parse XPath: "declare variable $x as xs:integer external; $x = 2". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $x [Error is around here]as xs:integer external; $x = 2
extvardeclwithtype-10,Error: XPST0003: Unable to parse XPath: "declare variable $x as xs:integer external; $x + $x = 2". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $x [Error is around here]as xs:integer external; $x + $x = 2
extvardeclwithtype-11,Error: XPST0003: Unable to parse XPath: "declare variable $x as xs:integer external; $x * $x = 16". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $x [Error is around here]as xs:integer external; $x * $x = 16
extvardeclwithtype-12,Error: XPST0003: Unable to parse XPath: "declare variable $x as xs:integer external; $x - xs:integer(1) = 2". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $x [Error is around here]as xs:integer external; $x - xs:integer(1) = 2
extvardeclwithtype-13,Error: XPST0003: Unable to parse XPath: "declare variable $x as xs:integer external; $x idiv xs:integer(2) = 5". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $x [Error is around here]as xs:integer external; $x idiv xs:integer(2) = 5
extvardeclwithtype-14,Error: XPST0003: Unable to parse XPath: "declare variable $x as xs:integer external; $x div xs:integer(10) = 2". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $x [Error is around here]as xs:integer external; $x div xs:integer(10) = 2
extvardeclwithtype-15,Error: XPST0003: Unable to parse XPath: "declare variable $x as xs:integer external; $x mod xs:integer(2) = 1". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $x [Error is around here]as xs:integer external; $x mod xs:integer(2) = 1
extvardeclwithtype-16,Error: XPST0003: Unable to parse XPath: "declare variable $x as xs:boolean external; $x and fn:false()". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $x [Error is around here]as xs:boolean external; $x and fn:false()
extvardeclwithtype-17,Error: XPST0003: Unable to parse XPath: "declare variable $x as xs:boolean external; $x or fn:false()". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $x [Error is around here]as xs:boolean external; $x or fn:false()
extvardeclwithtype-18,AssertionError: Expected executing the XPath "declare variable $x as xs:float external; $x" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "declare variable $x as xs:float external; $x". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $x [Error is around here]as xs:float external; $x, Error: XPST0003: Unable to parse XPath: "declare variable $x as xs:float external; $x". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $x [Error is around here]as xs:float external; $x.
extvardeclwithtype-19,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "declare variable $x as xs:dateTime external; $x".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\ndeclare variable $x [Error is around here]as xs:dateTime external; $x'
extvardeclwithtype-20,Error: XPST0003: Unable to parse XPath: "declare variable $x as xs:string external; fn:upper-case($x)". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $x [Error is around here]as xs:string external; fn:upper-case($x)
extvardeclwithtype-21,Error: XPST0003: Unable to parse XPath: "declare variable $x as xs:string external; fn:lower-case($x)". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $x [Error is around here]as xs:string external; fn:lower-case($x)
extvardeclwithtype-22,Error: XPST0003: Unable to parse XPath: "declare variable $x as xs:boolean external; fn:not($x)". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $x [Error is around here]as xs:boolean external; fn:not($x)
extvardeclwithtype-23,Error: XPST0003: Unable to parse XPath: "(:      This query opens a C++ GCC-XML output file, and outputs a report describing the use     of globals variables. :) declare variable $inputDocument := (/);  (: Determines whether the type by ID @p typeId is a complex type such as QString. :) declare function local:isComplexType($typeID as xs:string) as xs:boolean {     (: We're being a bit crude here and only checks whether it's a class. We        actually should check whether it has non-synthesized,         constructors, I believe. :)          exists($inputDocument/xml/Class[@id = $typeID])     or     (: We also want const-qualified variables. :)     exists($inputDocument/xml/Class[@id = $inputDocument/xml/CvQualifiedType[@id = $typeID]/@type]) };  declare function local:isPrimitive($typeId as xs:string) as xs:boolean {     exists($inputDocument/xml/FundamentalType[@id = $typeId]) };  (: Returns a string for human consumption that describes    the location of @p block. :) declare function local:location($block as element()) as xs:string {     concat($inputDocument/xml/File[@id = $block/@file]/@name, " at line ", $block/@line) };  declare function local:report() as element()+ {             let $complexVariables as element(Variable)* := $inputDocument/xml/Variable[local:isComplexType(@type)]             return if(exists($complexVariables)) (: Is the length larger than zero? :)                     then (<p xmlns="http://www.w3.org/1999/xhtml/">The following global, complex variables were found:</p>,                          <ol xmlns="http://www.w3.org/1999/xhtml/">                             {                                 (: For each Variable in $complexVariables... :)                                 for $v in $complexVariables                                 return $v/<li><span class="variableName">{string(@name)}</span> in {local:location(.)}</li>                             }                          </ol>)                     else <p xmlns="http://www.w3.org/1999/xhtml/">No global variables that are of complex types were found.</p>              ,              (: List primitive, mutable types. :)             let $primitiveVariables as element(Variable)+ := $inputDocument/xml/Variable[local:isPrimitive(@type)]             return if(exists($primitiveVariables))                     then (<p xmlns="http://www.w3.org/1999/xhtml/">The following mutable primitives were found:</p>,                          <ol xmlns="http://www.w3.org/1999/xhtml/">                             {                                 (: For each Variable in $complexVariables... :)                                 for $v in $primitiveVariables                                 return $v/<li><span class="variableName">{string(@name)}</span> in {local:location(.)}</li>                             }                          </ol>)                     else <p xmlns="http://www.w3.org/1999/xhtml/">No global variables that are of complex types were found.</p> };  <html xmlns="http://www.w3.org/1999/xhtml/" xml:lang="en" lang="en">     <head>         <title>Global variables report for {"Globals.cpp"}</title>     </head>     <style type="text/css">         .details         {{             text-align: center;             font-size: 80%;             color: gray         }}         .variableName         {{             font-family: courier         }}     </style>      <body>         {             (: We don't want simple types that are const, but all other types.                One could frown upon const integers and say enums should be used instead, but                let's be gentle. :)              local:report()         }          <p class="details">This report was generated on</p>     </body>  </html> ". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. (:      This query opens a C++ GCC-XML output file, and outputs a report describing the use     of globals variables. :) declare variable $inputDocument := (/);  (: Determines whether the type by ID @p typeId is a complex type such as QString. :) declare function local:isComplexType($typeID as xs:string) as xs:boolean {     (: We're being a bit crude here and only checks whether it's a class. We        actually should check whether it has non-synthesized,         constructors, I believe. :)          exists($inputDocument/xml/Class[@id = $typeID])     or     (: We also want const-qualified variables. :)     exists($inputDocument/xml/Class[@id = $inputDocument/xml/CvQualifiedType[@id = $typeID]/@type]) };  declare function local:isPrimitive($typeId as xs:string) as xs:boolean {     exists($inputDocument/xml/FundamentalType[@id = $typeId]) };  (: Returns a string for human consumption that describes    the location of @p block. :) declare function local:location($block as element()) as xs:string {     concat($inputDocument/xml/File[@id = $block/@file]/@name, " at line ", $block/@line) };  declare function local:report() as element()+ {             let $complexVariables [Error is around here]as element(Variable)* := $inputDocument/xml/Variable[local:isComplexType(@type)]             return if(exists($complexVariables)) (: Is the length larger than zero? :)                     then (<p xmlns="http://www.w3.org/1999/xhtml/">The following global, complex variables were found:</p>,                          <ol xmlns="http://www.w3.org/1999/xhtml/">                             {                                 (: For each Variable in $complexVariables... :)                                 for $v in $complexVariables                                 return $v/<li><span class="variableName">{string(@name)}</span> in {local:location(.)}</li>                             }                          </ol>)                     else <p xmlns="http://www.w3.org/1999/xhtml/">No global variables that are of complex types were found.</p>              ,              (: List primitive, mutable types. :)             let $primitiveVariables as element(Variable)+ := $inputDocument/xml/Variable[local:isPrimitive(@type)]             return if(exists($primitiveVariables))                     then (<p xmlns="http://www.w3.org/1999/xhtml/">The following mutable primitives were found:</p>,                          <ol xmlns="http://www.w3.org/1999/xhtml/">                             {                                 (: For each Variable in $complexVariables... :)                                 for $v in $primitiveVariables                                 return $v/<li><span class="variableName">{string(@name)}</span> in {local:location(.)}</li>                             }                          </ol>)                     else <p xmlns="http://www.w3.org/1999/xhtml/">No global variables that are of complex types were found.</p> };  <html xmlns="http://www.w3.org/1999/xhtml/" xml:lang="en" lang="en">     <head>         <title>Global variables report for {"Globals.cpp"}</title>     </head>     <style type="text/css">         .details         {{             text-align: center;             font-size: 80%;             color: gray         }}         .variableName         {{             font-family: courier         }}     </style>      <body>         {             (: We don't want simple types that are const, but all other types.                One could frown upon const integers and say enums should be used instead, but                let's be gentle. :)              local:report()         }          <p class="details">This report was generated on</p>     </body>  </html>
extvardeclwithtype-24,Error: XPST0003: Unable to parse XPath: "declare namespace test = "http://www.w3.org/fots/example-test-namespace";          declare variable $test:x as xs:integer external; $test:x = 2". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare namespace test = "http://www.w3.org/fots/example-test-namespace";          declare variable $test:x [Error is around here]as xs:integer external; $test:x = 2
K2-ExternalVariablesWith-1,AssertionError: expected [Function] to throw error including 'XQST0049' but got 'XPST0003: Unable to parse XPath: "declare variable $input-context as item()* external; declare variable $input-context external; 1".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\ndeclare variable $input-context [Error is around here]as item()* external; declare variable $input-context external; 1'
K2-ExternalVariablesWith-2,AssertionError: expected [Function] to throw error including 'XQST0049' but got 'XPST0003: Unable to parse XPath: "declare variable $input-context external; declare variable $input-context as item()* external; 1".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\ndeclare variable $input-context external; declare variable $input-context [Error is around here]as item()* external; 1'
K2-ExternalVariablesWith-3,AssertionError: expected [Function] to throw error including 'XQST0049' but got 'XPST0003: Unable to parse XPath: "declare variable $input-context as item()* external ; declare variable $input-context as item()*external ; 1".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\ndeclare variable $input-context [Error is around here]as item()* external ; declare variable $input-context as item()*external ; 1'
K2-ExternalVariablesWith-4,AssertionError: expected [Function] to throw error including 'XQST0049' but got 'XPST0003: Unable to parse XPath: "declare variable $input-context as item()* external ; declare variable $input-context as item()*external ; $input-context".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\ndeclare variable $input-context [Error is around here]as item()* external ; declare variable $input-context as item()*external ; $input-context'
K2-ExternalVariablesWith-5,AssertionError: expected [Function] to throw error including 'XQST0049' but got 'XPST0003: Unable to parse XPath: "declare variable $input-context as item()* external; declare variable $input-context as item()*external; 1".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\ndeclare variable $input-context [Error is around here]as item()* external; declare variable $input-context as item()*external; 1'
K2-ExternalVariablesWith-6,AssertionError: expected [Function] to throw error including 'XQST0049' but got 'XPST0003: Unable to parse XPath: "declare variable $input-context as xs:string* external; declare variable $input-context as item()*external; 1".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\ndeclare variable $input-context [Error is around here]as xs:string* external; declare variable $input-context as item()*external; 1'
K2-ExternalVariablesWith-7,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: "declare variable $exampleComThisVarIsNotRecognized as xs:string *external; $exampleComThisVarIsNotRecognized".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\ndeclare variable $exampleComThisVarIsNotRecognized [Error is around here]as xs:string *external; $exampleComThisVarIsNotRecognized'
K2-ExternalVariablesWith-8,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: "declare namespace e = "http://example.com/ANamespace"; declare variable $e:exampleComThisVarIsNotRecognized as comment() *external; $e:exampleComThisVarIsNotRecognized".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\ndeclare namespace e = "http://example.com/ANamespace"; declare variable $e:exampleComThisVarIsNotRecognized [Error is around here]as comment() *external; $e:exampleComThisVarIsNotRecognized'
K2-ExternalVariablesWith-9,AssertionError: Expected executing the XPath "declare variable $exampleComThisVarIsNotRecognized as processing-instruction()? external; 1" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "declare variable $exampleComThisVarIsNotRecognized as processing-instruction()? external; 1 = 1". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $exampleComThisVarIsNotRecognized [Error is around here]as processing-instruction()? external; 1 = 1, AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: "declare variable $exampleComThisVarIsNotRecognized as processing-instruction()? external; 1".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\ndeclare variable $exampleComThisVarIsNotRecognized [Error is around here]as processing-instruction()? external; 1'.
K2-ExternalVariablesWith-10,AssertionError: Expected executing the XPath "declare namespace e = "http://example.com/ANamespace"; declare variable $e:exampleComThisVarIsNotRecognized as element(*) external; 1" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "declare namespace e = "http://example.com/ANamespace"; declare variable $e:exampleComThisVarIsNotRecognized as element(*) external; 1 = 1". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare namespace e = "http://example.com/ANamespace"; declare variable $e:exampleComThisVarIsNotRecognized [Error is around here]as element(*) external; 1 = 1, AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: "declare namespace e = "http://example.com/ANamespace"; declare variable $e:exampleComThisVarIsNotRecognized as element(*) external; 1".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\ndeclare namespace e = "http://example.com/ANamespace"; declare variable $e:exampleComThisVarIsNotRecognized [Error is around here]as element(*) external; 1'.
K2-ExternalVariablesWith-12,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "declare variable $i as xs:integer := xs:untypedAtomic("1"); $i".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\ndeclare variable $i [Error is around here]as xs:integer := xs:untypedAtomic("1"); $i'
K2-ExternalVariablesWith-13,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "declare variable $i as xs:float := 1.1 ; $i".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\ndeclare variable $i [Error is around here]as xs:float := 1.1 ; $i'
K2-ExternalVariablesWith-14,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "declare variable $i as xs:double := 1.1 ; $i".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\ndeclare variable $i [Error is around here]as xs:double := 1.1 ; $i'
K2-ExternalVariablesWith-15,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "declare variable $i as xs:float := 1 ; $i".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\ndeclare variable $i [Error is around here]as xs:float := 1 ; $i'
K2-ExternalVariablesWith-16,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "declare variable $i as xs:double := 1 ; $i".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\ndeclare variable $i [Error is around here]as xs:double := 1 ; $i'
K2-ExternalVariablesWith-17,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "declare variable $i as xs:double := xs:float(3) ; $i".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\ndeclare variable $i [Error is around here]as xs:double := xs:float(3) ; $i'
K2-ExternalVariablesWith-18,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "declare variable $i as xs:string := xs:untypedAtomic("a string") ; $i".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\ndeclare variable $i [Error is around here]as xs:string := xs:untypedAtomic("a string") ; $i'
K2-ExternalVariablesWith-19,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "declare variable $i as xs:string := xs:anyURI("http://www.example.com/") ; $i".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\ndeclare variable $i [Error is around here]as xs:string := xs:anyURI("http://www.example.com/") ; $i'
K2-ExternalVariablesWith-20,AssertionError: expected [Function] to throw error including 'XQST0049' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-ExternalVariablesWith-21,AssertionError: expected [Function] to throw error including 'XQST0049' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
K2-ExternalVariablesWith-22,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "declare variable $v as element(*, xs:untyped?)+ := <e/>; exists($v/*)".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\ndeclare variable $v [Error is around here]as element(*, xs:untyped?)+ := <e/>; exists($v/*)'
K2-ExternalVariablesWith-22a,Error: XPST0003: Unable to parse XPath: "declare variable $v as element(*, xs:untyped?)+ := <e/>; exists($v/*)". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $v [Error is around here]as element(*, xs:untyped?)+ := <e/>; exists($v/*)
K2-ExternalVariablesWith-23,Error: XPST0003: Unable to parse XPath: "declare variable $v as element(elementName, xs:anyType?)+ := <elementName/>; 1 = 1". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $v [Error is around here]as element(elementName, xs:anyType?)+ := <elementName/>; 1 = 1
extvardef-001,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
extvardef-001a,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
extvardef-002,Error: XPST0003: Unable to parse XPath: "declare variable $ext as xs:integer external := 0; <a>{$ext}</a>". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $ext [Error is around here]as xs:integer external := 0; <a>{$ext}</a>
extvardef-002a,Error: XPST0003: Unable to parse XPath: "declare variable $ext as xs:integer external := 0; <a>{$ext}</a>". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $ext [Error is around here]as xs:integer external := 0; <a>{$ext}</a>
extvardef-002b,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "declare variable $ext as xs:integer external := 0; <a>{$ext}</a>".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\ndeclare variable $ext [Error is around here]as xs:integer external := 0; <a>{$ext}</a>'
extvardef-003,Error: XPST0003: Unable to parse XPath: "declare variable $ext as xs:integer* external := (0,1,2); <a>{sum($ext)}</a>". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $ext [Error is around here]as xs:integer* external := (0,1,2); <a>{sum($ext)}</a>
extvardef-003a,Error: XPST0003: Unable to parse XPath: "declare variable $ext as xs:integer* external := (0,1,2); <a>{sum($ext)}</a>". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $ext [Error is around here]as xs:integer* external := (0,1,2); <a>{sum($ext)}</a>
extvardef-003b,Error: XPST0003: Unable to parse XPath: "declare variable $ext as xs:integer* external := (0,1,2); <a>{sum($ext)}</a>". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found. declare variable $ext [Error is around here]as xs:integer* external := (0,1,2); <a>{sum($ext)}</a>
extvardef-006,Error: XPST0003: Unable to parse XPath: "          declare variable $var as xs:integer := 17;           declare variable $ext as element(a) external := <a>{$var}</a>;           <out>{$ext}</out>". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.           declare variable $var [Error is around here]as xs:integer := 17;           declare variable $ext as element(a) external := <a>{$var}</a>;           <out>{$ext}</out>
extvardef-006a,Error: XPST0003: Unable to parse XPath: "         declare variable $var as xs:integer := 17;          declare variable $ext as xs:integer external := $var;          <out>{$ext}</out>       ". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.          declare variable $var [Error is around here]as xs:integer := 17;          declare variable $ext as xs:integer external := $var;          <out>{$ext}</out>
extvardef-006b,AssertionError: Expected executing the XPath "         declare variable $var as xs:integer := 17;          declare variable $ext as xs:integer external := <a>{$var}</a>;          <out>{$ext}</out>       " to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "\n        declare variable $var as xs:integer := 17; \n        declare variable $ext as xs:integer external := <a>{$var}</a>; \n        <out>{$ext}</out>\n      ".\nExpected " ", "(:", ":=", "\\n", "\\r", "\\t", or "external" but "a" found.\n\n        declare variable $var [Error is around here]as xs:integer := 17; \n        declare variable $ext as xs:integer external := <a>{$var}</a>; \n        <out>{$ext}</out>\n      ', Error: XPST0003: Unable to parse XPath: "         declare variable $var as xs:integer := 17;          declare variable $ext as xs:integer external := <a>{$var}</a>;          <out>{$ext}</out>       ". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.          declare variable $var [Error is around here]as xs:integer := 17;          declare variable $ext as xs:integer external := <a>{$var}</a>;          <out>{$ext}</out>       .
extvardef-007,Error: XPST0003: Unable to parse XPath: "         declare variable $ext as xs:date external := current-date() + xs:dayTimeDuration('P30D');          $ext gt xs:date('2008-12-30')       ". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.          declare variable $ext [Error is around here]as xs:date external := current-date() + xs:dayTimeDuration('P30D');          $ext gt xs:date('2008-12-30')
extvardef-008,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
extvardef-009,AssertionError: Expected executing the XPath "declare variable $x external; "result"" to resolve to one of the expected results, but got Error: Not implemented: only module imports and function declarations are implemented in XQuery modules, AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
extvardef-010,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
extvardef-010a,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
extvardef-011,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
extvardef-011a,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
extvardef-012,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
extvardef-013,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
extvardef-014,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
extvardef-015,AssertionError: Expected executing the XPath "         declare variable $y := /works/employee;         declare context item := $y[9];         declare variable $x external := fn:position();         $x       " to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules', AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
extvardef-016a,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
extvardef-016b,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
extvardef-017,Error: XPST0003: Unable to parse XPath: "         declare variable $x as xs:decimal external := xs:integer(10);         $x        = 10". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.          declare variable $x [Error is around here]as xs:decimal external := xs:integer(10);         $x        = 10
extvardef-018,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
extvardef-019,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
extvardef-020,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
extvardef-021,Error: XPST0003: Unable to parse XPath: "         declare variable $x as xs:integer external := xs:int(5);         declare variable $y as xs:decimal external := $x;         $y instance of xs:decimal        = fn:true()". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.          declare variable $x [Error is around here]as xs:integer external := xs:int(5);         declare variable $y as xs:decimal external := $x;         $y instance of xs:decimal        = fn:true()
extvardef-022,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
version_declaration-023-v1,AssertionError: expected [Function] to throw an error
version_declaration-007,AssertionError: expected [Function] to throw an error
version_declaration-008,AssertionError: expected [Function] to throw an error
VersionDecl-v1-processor-and-v3-query,AssertionError: expected [Function] to throw an error
version_declaration-010,AssertionError: expected [Function] to throw an error
version_declaration-010-v3,AssertionError: expected [Function] to throw an error
K-VersionProlog-3,AssertionError: expected [Function] to throw an error
K-VersionProlog-3-v3,AssertionError: expected [Function] to throw an error
K-VersionProlog-4,AssertionError: expected [Function] to throw an error
K-VersionProlog-4-v3,AssertionError: expected [Function] to throw an error
K-VersionProlog-2,Error: XPST0003: Unable to parse XPath: "xquery version "1.0" ; 1 eq 1". Expected " ", "(:", "\n", "\r", "\t", or "encoding" but ";" found. xquery version "1.0" [Error is around here]; 1 eq 1
K-VersionProlog-2-v3,Error: XPST0003: Unable to parse XPath: "xquery version "3.0" ; 1 eq 1". Expected " ", "(:", "\n", "\r", "\t", or "encoding" but ";" found. xquery version "3.0" [Error is around here]; 1 eq 1
K-VersionProlog-2-v31,Error: XPST0003: Unable to parse XPath: "xquery version "3.1" ; 1 eq 1". Expected " ", "(:", "\n", "\r", "\t", or "encoding" but ";" found. xquery version "3.1" [Error is around here]; 1 eq 1
prolog-version-6,Error: XPST0003: Unable to parse XPath: "         xquery version '1.0';          declare boundary-space preserve;          declare default order empty greatest;          declare namespace ns = "http://www.example.org/";          for $b in//book stable order by xs:decimal($b/price[1]) empty greatest          return $b/title". Expected " ", "(:", "\n", "\r", or "\t" but "/" found.          xquery version '1.0';          declare boundary-space preserve;          declare default order empty greatest;          declare namespace ns = "http://www.example.org/";          for $b in[Error is around here]//book stable order by xs:decimal($b/price[1]) empty greatest          return $b/title
prolog-version-6-v3,Error: XPST0003: Unable to parse XPath: "         xquery version '3.0';          declare boundary-space preserve;          declare default order empty greatest;          declare namespace ns = "http://www.example.org/";          for $b in//book stable order by xs:decimal($b/price[1]) empty greatest          return $b/title". Expected " ", "(:", "\n", "\r", or "\t" but "/" found.          xquery version '3.0';          declare boundary-space preserve;          declare default order empty greatest;          declare namespace ns = "http://www.example.org/";          for $b in[Error is around here]//book stable order by xs:decimal($b/price[1]) empty greatest          return $b/title
prolog-version-6-v31,Error: XPST0003: Unable to parse XPath: "          xquery version '3.1';           declare boundary-space preserve;           declare default order empty greatest;           declare namespace ns = "http://www.example.org/";           for $b in//book stable order by xs:decimal($b/price[1]) empty greatest           return $b/title". Expected " ", "(:", "\n", "\r", or "\t" but "/" found.           xquery version '3.1';           declare boundary-space preserve;           declare default order empty greatest;           declare namespace ns = "http://www.example.org/";           for $b in[Error is around here]//book stable order by xs:decimal($b/price[1]) empty greatest           return $b/title
prolog-version-7,Error: XPST0003: Unable to parse XPath: "         xquery version "1.0";          declare boundary-space preserve;          declare default order empty greatest;          declare namespace ns = "http://www.example.org/";          for $b in //book stable order by xs:decimal($b/price[1]) empty greatest          return $b/title". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found.          xquery version "1.0";          declare boundary-space preserve;          declare default order empty greatest;          declare namespace ns = "http://www.example.org/";          for $b in //book [Error is around here]stable order by xs:decimal($b/price[1]) empty greatest          return $b/title
prolog-version-7-v3,Error: XPST0003: Unable to parse XPath: "         xquery version "3.0";          declare boundary-space preserve;          declare default order empty greatest;          declare namespace ns = "http://www.example.org/";          for $b in //book stable order by xs:decimal($b/price[1]) empty greatest          return $b/title". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found.          xquery version "3.0";          declare boundary-space preserve;          declare default order empty greatest;          declare namespace ns = "http://www.example.org/";          for $b in //book [Error is around here]stable order by xs:decimal($b/price[1]) empty greatest          return $b/title
prolog-version-7-v31,Error: XPST0003: Unable to parse XPath: "          xquery version "3.1";           declare boundary-space preserve;           declare default order empty greatest;           declare namespace ns = "http://www.example.org/";           for $b in //book stable order by xs:decimal($b/price[1]) empty greatest           return $b/title". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found.           xquery version "3.1";           declare boundary-space preserve;           declare default order empty greatest;           declare namespace ns = "http://www.example.org/";           for $b in //book [Error is around here]stable order by xs:decimal($b/price[1]) empty greatest           return $b/title
K-VersionProlog-5,Error: XPST0003: Unable to parse XPath: "         xquery version "1.0" encoding "ISO-8859-1";          declare boundary-space preserve;          declare default collation "http://www.w3.org/2005/xpath-functions/collation/codepoint";          declare base-uri "http://example.com/";          declare construction strip;          declare ordering ordered;          declare default order empty greatest;          declare copy-namespaces no-preserve, no-inherit;          declare namespace ex = "http://example.com/a/Namespace";          declare default element namespace "http://example.com/";          declare default function namespace "http://example.com/";          declare option fn:x-notRecognized "option content";          1 eq 1". Expected " ", "(:", "\n", "\r", "\t", "decimal-format", "element", "function", or "order" but "c" found.          xquery version "1.0" encoding "ISO-8859-1";          declare boundary-space preserve;          declare default [Error is around here]collation "http://www.w3.org/2005/xpath-functions/collation/codepoint";          declare base-uri "http://example.com/";          declare construction strip;          declare ordering ordered;          declare default order empty greatest;          declare copy-namespaces no-preserve, no-inherit;          declare namespace ex = "http://example.com/a/Namespace";          declare default element namespace "http://example.com/";          declare default function namespace "http://example.com/";          declare option fn:x-notRecognized "option content";          1 eq 1
K-VersionProlog-5-v3,Error: XPST0003: Unable to parse XPath: "         xquery version "3.0" encoding "ISO-8859-1";          declare boundary-space preserve;          declare default collation "http://www.w3.org/2005/xpath-functions/collation/codepoint";          declare base-uri "http://example.com/";          declare construction strip;          declare ordering ordered;          declare default order empty greatest;          declare copy-namespaces no-preserve, no-inherit;          declare namespace ex = "http://example.com/a/Namespace";          declare default element namespace "http://example.com/";          declare default function namespace "http://example.com/";          declare option fn:x-notRecognized "option content";          1 eq 1". Expected " ", "(:", "\n", "\r", "\t", "decimal-format", "element", "function", or "order" but "c" found.          xquery version "3.0" encoding "ISO-8859-1";          declare boundary-space preserve;          declare default [Error is around here]collation "http://www.w3.org/2005/xpath-functions/collation/codepoint";          declare base-uri "http://example.com/";          declare construction strip;          declare ordering ordered;          declare default order empty greatest;          declare copy-namespaces no-preserve, no-inherit;          declare namespace ex = "http://example.com/a/Namespace";          declare default element namespace "http://example.com/";          declare default function namespace "http://example.com/";          declare option fn:x-notRecognized "option content";          1 eq 1
combined-errors-1,Error: XQST0051: No modules found with the namespace uri http://www.w3.org/TestModules/test1
combined-errors-2,AssertionError: Expected executing the XPath "import schema namespace atomic="http://www.w3.org/XQueryTest"; "ABC"" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "import schema namespace atomic="http://www.w3.org/XQueryTest"; "ABC"". Expected " ", "(:", "\n", "\r", "\t", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "=" found. import schema namespace atomic[Error is around here]="http://www.w3.org/XQueryTest"; "ABC", AssertionError: expected [Function] to throw error including 'XQST0009' but got 'XPST0003: Unable to parse XPath: "import schema namespace atomic="http://www.w3.org/XQueryTest"; "ABC"".\nExpected " ", "(:", "\\n", "\\r", "\\t", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\\-.0-9·̀-ͯ‿⁀], or [�-�] but "=" found.\nimport schema namespace atomic[Error is around here]="http://www.w3.org/XQueryTest"; "ABC"'.
combined-errors-3,AssertionError: Expected executing the XPath "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          import schema "http://www.w3.org/XQueryTestOrderBy";          validate strict {<Strings><orderData>one string</orderData></Strings>}" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          import schema "http://www.w3.org/XQueryTestOrderBy";          validate strict {<Strings><orderData>one string</orderData></Strings>}". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "s" found. declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          import schema "http://www.w3.org/XQueryTestOrderBy";          validate [Error is around here]strict {<Strings><orderData>one string</orderData></Strings>}, AssertionError: expected [Function] to throw error including 'XQST0075' but got 'XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy"; \n        import schema "http://www.w3.org/XQueryTestOrderBy"; \n        validate strict {<Strings><orderData>one string</orderData></Strings>}".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "s" found.\ndeclare default element namespace "http://www.w3.org/XQueryTestOrderBy"; \n        import schema "http://www.w3.org/XQueryTestOrderBy"; \n        validate [Error is around here]strict {<Strings><orderData>one string</orderData></Strings>}', AssertionError: expected [Function] to throw error including 'XQST0009' but got 'XPST0003: Unable to parse XPath: "declare default element namespace "http://www.w3.org/XQueryTestOrderBy"; \n        import schema "http://www.w3.org/XQueryTestOrderBy"; \n        validate strict {<Strings><orderData>one string</orderData></Strings>}".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "s" found.\ndeclare default element namespace "http://www.w3.org/XQueryTestOrderBy"; \n        import schema "http://www.w3.org/XQueryTestOrderBy"; \n        validate [Error is around here]strict {<Strings><orderData>one string</orderData></Strings>}'.
K-CombinedErrorCodes-1,AssertionError: Expected executing the XPath "import schema "http://example.com/NSNOTRECOGNIZED"; 1 eq 1" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0009' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules', AssertionError: expected [Function] to throw error including 'XQST0059' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
K-CombinedErrorCodes-2,AssertionError: Expected executing the XPath "import schema "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST"; 1 eq 1" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0009' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules', AssertionError: expected [Function] to throw error including 'XQST0059' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
K-CombinedErrorCodes-3,AssertionError: Expected executing the XPath "import schema "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST", "http://example.com/2", "http://example.com/3"; 1 eq 1" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0009' but got 'XPST0003: Unable to parse XPath: "import schema "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST", "http://example.com/2", "http://example.com/3"; 1 eq 1".\nExpected " ", "(:", ";", "\\n", "\\r", or "\\t" but "," found.\nimport schema "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST"[Error is around here], "http://example.com/2", "http://example.com/3"; 1 eq 1', AssertionError: expected [Function] to throw error including 'XQST0059' but got 'XPST0003: Unable to parse XPath: "import schema "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST", "http://example.com/2", "http://example.com/3"; 1 eq 1".\nExpected " ", "(:", ";", "\\n", "\\r", or "\\t" but "," found.\nimport schema "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST"[Error is around here], "http://example.com/2", "http://example.com/3"; 1 eq 1'.
K-CombinedErrorCodes-4,AssertionError: Expected executing the XPath "import schema "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST", "http://example.com/2", "http://example.com/3"; 1 eq 1" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0009' but got 'XPST0003: Unable to parse XPath: "import schema "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST", "http://example.com/2", "http://example.com/3"; 1 eq 1".\nExpected " ", "(:", ";", "\\n", "\\r", or "\\t" but "," found.\nimport schema "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST"[Error is around here], "http://example.com/2", "http://example.com/3"; 1 eq 1', AssertionError: expected [Function] to throw error including 'XQST0059' but got 'XPST0003: Unable to parse XPath: "import schema "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST", "http://example.com/2", "http://example.com/3"; 1 eq 1".\nExpected " ", "(:", ";", "\\n", "\\r", or "\\t" but "," found.\nimport schema "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST"[Error is around here], "http://example.com/2", "http://example.com/3"; 1 eq 1'.
K-CombinedErrorCodes-5,AssertionError: Expected executing the XPath "import schema namespace prefix = "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST", "http://example.com/2DOESNOTEXIST", "http://example.com/3DOESNOTEXIST"; 1 eq 1" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0009' but got 'XPST0003: Unable to parse XPath: "import schema namespace prefix = "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST", "http://example.com/2DOESNOTEXIST", "http://example.com/3DOESNOTEXIST"; 1 eq 1".\nExpected " ", "(:", ";", "\\n", "\\r", or "\\t" but "," found.\nimport schema namespace prefix = "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST"[Error is around here], "http://example.com/2DOESNOTEXIST", "http://example.com/3DOESNOTEXIST"; 1 eq 1', AssertionError: expected [Function] to throw error including 'XQST0059' but got 'XPST0003: Unable to parse XPath: "import schema namespace prefix = "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST", "http://example.com/2DOESNOTEXIST", "http://example.com/3DOESNOTEXIST"; 1 eq 1".\nExpected " ", "(:", ";", "\\n", "\\r", or "\\t" but "," found.\nimport schema namespace prefix = "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST"[Error is around here], "http://example.com/2DOESNOTEXIST", "http://example.com/3DOESNOTEXIST"; 1 eq 1'.
K-CombinedErrorCodes-6,AssertionError: Expected executing the XPath "import schema default element namespace "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST", "http://example.com/2DOESNOTEXIST", "http://example.com/3DOESNOTEXIST"; 1 eq 1" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0009' but got 'XPST0003: Unable to parse XPath: "import schema default element namespace "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST", "http://example.com/2DOESNOTEXIST", "http://example.com/3DOESNOTEXIST"; 1 eq 1".\nExpected " ", "(:", ";", "\\n", "\\r", or "\\t" but "," found.\nimport schema default element namespace "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST"[Error is around here], "http://example.com/2DOESNOTEXIST", "http://example.com/3DOESNOTEXIST"; 1 eq 1', AssertionError: expected [Function] to throw error including 'XQST0059' but got 'XPST0003: Unable to parse XPath: "import schema default element namespace "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST", "http://example.com/2DOESNOTEXIST", "http://example.com/3DOESNOTEXIST"; 1 eq 1".\nExpected " ", "(:", ";", "\\n", "\\r", or "\\t" but "," found.\nimport schema default element namespace "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST"[Error is around here], "http://example.com/2DOESNOTEXIST", "http://example.com/3DOESNOTEXIST"; 1 eq 1'.
K-CombinedErrorCodes-9,AssertionError: Expected executing the XPath "validate { 1 }" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQTY0030' but got 'XPST0003: Unable to parse XPath: "validate { 1 }".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nvalidate [Error is around here]{ 1 }', AssertionError: expected [Function] to throw error including 'XQST0075' but got 'XPST0003: Unable to parse XPath: "validate { 1 }".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nvalidate [Error is around here]{ 1 }'.
K-CombinedErrorCodes-10,AssertionError: Expected executing the XPath "validate { () }" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQTY0030' but got 'XPST0003: Unable to parse XPath: "validate { () }".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nvalidate [Error is around here]{ () }', AssertionError: expected [Function] to throw error including 'XQST0075' but got 'XPST0003: Unable to parse XPath: "validate { () }".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nvalidate [Error is around here]{ () }'.
K-CombinedErrorCodes-11,AssertionError: Expected executing the XPath "validate lax { 1 }" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQTY0030' but got 'XPST0003: Unable to parse XPath: "validate lax { 1 }".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "l" found.\nvalidate [Error is around here]lax { 1 }', AssertionError: expected [Function] to throw error including 'XQST0075' but got 'XPST0003: Unable to parse XPath: "validate lax { 1 }".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "l" found.\nvalidate [Error is around here]lax { 1 }'.
K-CombinedErrorCodes-12,AssertionError: Expected executing the XPath "validate strict { 1 }" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQTY0030' but got 'XPST0003: Unable to parse XPath: "validate strict { 1 }".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "s" found.\nvalidate [Error is around here]strict { 1 }', AssertionError: expected [Function] to throw error including 'XQST0075' but got 'XPST0003: Unable to parse XPath: "validate strict { 1 }".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "s" found.\nvalidate [Error is around here]strict { 1 }'.
FOAR0001_1,AssertionError: expected [Function] to throw an error
FOAR0001_2,AssertionError: expected [Function] to throw an error
FOAR0001_6,AssertionError: expected [Function] to throw an error
FOAR0001_7,AssertionError: expected [Function] to throw an error
FOAR0001_8,AssertionError: expected [Function] to throw an error
FOAR0001_9,AssertionError: expected [Function] to throw an error
FOCA0001_1,AssertionError: Expected executing the XPath "xs:decimal(1e308)" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw an error, AssertionError: xs:decimal(1e308): expected false to be true.
FOCA0002_7,AssertionError: expected [Function] to throw error including 'FOCA0002' but got 'XPST0017: Function resolve-QName with arity of 2 not registered. No similar functions found.'
FOCA0002_8,AssertionError: expected [Function] to throw error including 'FOCA0002' but got 'XPST0017: Function resolve-QName with arity of 2 not registered. No similar functions found.'
FOCA0002_9,AssertionError: expected [Function] to throw error including 'FOCA0002' but got 'XPST0017: Function resolve-QName with arity of 2 not registered. No similar functions found.'
FOCA0003_1,AssertionError: Expected executing the XPath "xs:integer(xs:double(1e308))" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FOCA0003' but got 'FOAR0002: can not cast 1e+308 to xs:integer, it is out of bounds for JavaScript numbers.', Error: FOAR0002: can not cast 1e+308 to xs:integer, it is out of bounds for JavaScript numbers..
FOCH0001,AssertionError: expected [Function] to throw error including 'FOCH0001' but got 'XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.'
FOCH0002_10,AssertionError: expected [Function] to throw error including 'FOCH0002' but got 'XPST0017: Function substring-before with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}insert-before (item()*, xs:integer, item()*)"?'
FOCH0002_3,AssertionError: expected [Function] to throw error including 'FOCH0002' but got 'XPST0017: Function distinct-values with arity of 2 not registered. No similar functions found.'
FOCH0002_5,AssertionError: expected [Function] to throw error including 'FOCH0002' but got 'XPST0017: Function index-of with arity of 3 not registered. No similar functions found.'
FOCH0002_9,AssertionError: expected [Function] to throw error including 'FOCH0002' but got 'XPST0017: Function substring-after with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)"?'
FODC0001_1,AssertionError: expected [Function] to throw an error
FODC0001_2,AssertionError: expected [Function] to throw an error
FODC0002_1,AssertionError: expected [Function] to throw error including 'FODC0002' but got 'XPST0017: Function doc with arity of 1 not registered. No similar functions found.'
FODC0002_2,AssertionError: expected [Function] to throw error including 'FODC0002' but got 'XPST0017: Function doc with arity of 1 not registered. No similar functions found.'
FODC0002_3,AssertionError: expected [Function] to throw error including 'FODC0002' but got 'XPST0017: Function doc with arity of 1 not registered. No similar functions found.'
FODC0002_4,AssertionError: expected [Function] to throw error including 'FODC0002' but got 'XPST0017: Function collection with arity of 0 not registered. No similar functions found.'
FODC0004,AssertionError: Expected executing the XPath "collection('%gg')" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FODC0004' but got 'XPST0017: Function collection with arity of 1 not registered. No similar functions found.', AssertionError: expected [Function] to throw error including 'FODC0002' but got 'XPST0017: Function collection with arity of 1 not registered. No similar functions found.'.
FODC0005-1,AssertionError: Expected executing the XPath "doc('%gg')" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FODC0005' but got 'XPST0017: Function doc with arity of 1 not registered. No similar functions found.', AssertionError: expected [Function] to throw error including 'FODC0002' but got 'XPST0017: Function doc with arity of 1 not registered. No similar functions found.'.
FODC0005-2,AssertionError: Expected executing the XPath "doc-available('%gg')" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FODC0005' but got 'XPST0017: Function doc-available with arity of 1 not registered. No similar functions found.', Error: XPST0017: Function doc-available with arity of 1 not registered. No similar functions found..
FODT0001-1,AssertionError: expected [Function] to throw error including 'FODT0001' but got 'XPST0017: Function adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.'
FODT0001-2,AssertionError: expected [Function] to throw error including 'FODT0001' but got 'XPST0017: Function adjust-date-to-timezone with arity of 2 not registered. No similar functions found.'
FODT0003-1,AssertionError: expected [Function] to throw error including 'FODT0003' but got 'XPST0017: Function adjust-date-to-timezone with arity of 2 not registered. No similar functions found.'
FODT0003-2,AssertionError: expected [Function] to throw error including 'FODT0003' but got 'XPST0017: Function adjust-date-to-timezone with arity of 2 not registered. No similar functions found.'
FOER0000,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
FONS0004-1,AssertionError: expected [Function] to throw error including 'FONS0004' but got 'XPST0017: Function resolve-QName with arity of 2 not registered. No similar functions found.'
FORG0002,AssertionError: expected [Function] to throw error including 'FORG0002' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
FORG0009,AssertionError: expected [Function] to throw error including 'FORG0002' but got 'XPST0017: Function resolve-uri with arity of 2 not registered. No similar functions found.'
XPDY0002_02,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
XPDY0050,AssertionError: expected [Function] to throw error including 'XPDY0050' but got 'XPST0003: Unable to parse XPath: "1 treat as node()".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "t" found.\n1 [Error is around here]treat as node()'
XPTY0004_01,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "attribute { 1 } { 1 }".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nattribute [Error is around here]{ 1 } { 1 }'
XPTY0019_2,AssertionError: expected [Function] to throw error including 'XPTY0019' but got 'XPTY0018: The path operator should either return nodes or non-nodes. Mixed sequences are not allowed.'
XPTY0019_3,AssertionError: expected [Function] to throw error including 'XPTY0019' but got 'XPTY0018: The path operator should either return nodes or non-nodes. Mixed sequences are not allowed.'
XPTY0004_02,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "element { 1 } { }".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\nelement [Error is around here]{ 1 } { }'
XPTY0004_05,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "let $x as node() := 1 return $x".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\nlet $x [Error is around here]as node() := 1 return $x'
XPTY0004_06,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "for $x as node() in (1, 2, 3) return $x".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\nfor $x [Error is around here]as node() in (1, 2, 3) return $x'
XPTY0004_07,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "document { attribute {\'foo\'} {} }".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\ndocument [Error is around here]{ attribute {\'foo\'} {} }'
XPTY0004_08,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "declare namespace foo = "http://www.example.org"; declare function foo:content($type as xs:integer) { if ($type eq 1) then attribute {\'foo\'} {} else <foo /> }; document { foo:content(1) }".\nExpected "!", "!=", "(", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "else", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.\ndeclare namespace foo = "http://www.example.org"; declare function foo:content($type as xs:integer) { if ($type eq 1) then attribute [Error is around here]{\'foo\'} {} else <foo /> }; document { foo:content(1) }'
XPTY0004_09,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "for $x in (1, \'hello\', xs:date(\'2007-11-28\')) order by $x return $x".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.\nfor $x in (1, \'hello\', xs:date(\'2007-11-28\')) [Error is around here]order by $x return $x'
XPTY0004_12,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function fn:error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
XPTY0004_12a,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function fn:error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
XPTY0004_29,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "declare namespace foo = "http://www.example.org"; declare function foo:something($type as xs:integer) { if ($type eq 1) then xs:date(\'2007-11-28\') else \'foo\' }; element { foo:something(1) } { }".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\ndeclare namespace foo = "http://www.example.org"; declare function foo:something($type as xs:integer) { if ($type eq 1) then xs:date(\'2007-11-28\') else \'foo\' }; element [Error is around here]{ foo:something(1) } { }'
XPTY0004_30,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "declare namespace foo = "http://www.example.org"; declare function foo:something($type as xs:integer) { if ($type eq 1) then xs:date(\'2007-11-28\') else \'foo\' }; processing-instruction { foo:something(1) } { }".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.\ndeclare namespace foo = "http://www.example.org"; declare function foo:something($type as xs:integer) { if ($type eq 1) then xs:date(\'2007-11-28\') else \'foo\' }; processing-instruction [Error is around here]{ foo:something(1) } { }'
XPTY0004_31,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "declare namespace foo = "http://www.example.org"; declare function foo:something($type as xs:integer) { if ($type eq 1) then xs:date(\'2007-11-28\') else \'foo\' }; <e> { attribute { foo:something(1) } { } } </e>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.\ndeclare namespace foo = "http://www.example.org"; declare function foo:something($type as xs:integer) { if ($type eq 1) then xs:date(\'2007-11-28\') else \'foo\' }; <e> { attribute [Error is around here]{ foo:something(1) } { } } </e>'
XPTY0004_32,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "declare namespace foo = "http://www.example.org"; declare function foo:something($type as xs:integer) { if ($type eq 1) then (\'foo\', xs:date(\'2007-11-28\'), \'foo\') else \'foo\' }; let $x as xs:string* := foo:something(1) return $x".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\ndeclare namespace foo = "http://www.example.org"; declare function foo:something($type as xs:integer) { if ($type eq 1) then (\'foo\', xs:date(\'2007-11-28\'), \'foo\') else \'foo\' }; let $x [Error is around here]as xs:string* := foo:something(1) return $x'
XPTY0004_33,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "declare namespace foo = "http://www.example.org"; declare function foo:something($type as xs:integer) { if ($type eq 1) then xs:date(\'2007-11-28\') else \'foo\' }; for $x as xs:string in foo:something(1) return $x".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\ndeclare namespace foo = "http://www.example.org"; declare function foo:something($type as xs:integer) { if ($type eq 1) then xs:date(\'2007-11-28\') else \'foo\' }; for $x [Error is around here]as xs:string in foo:something(1) return $x'
XPTY0004_34,AssertionError: expected [Function] to throw an error
XPTY0004_35,AssertionError: expected [Function] to throw an error
XPTY0004_37,AssertionError: expected [Function] to throw an error
XPTY0004_38,AssertionError: expected [Function] to throw an error
XPTY0004_39,AssertionError: expected [Function] to throw an error
XPTY0004_40,AssertionError: expected [Function] to throw an error
XPTY0004_45,AssertionError: Expected executing the XPath "concat('prefix:', 'localname') cast as xs:QName" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.', AssertionError: expected [Function] to throw error including 'FONS0004' but got 'Casting to xs:QName is not implemented.'.
XPTY0004_47,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
XPTY0004_48,AssertionError: Expected executing the XPath "let $i := (1, 3, 2) order by $i return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "let $i := (1, 3, 2) order by $i return $i". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. let $i := (1, 3, 2) [Error is around here]order by $i return $i, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "let $i := (1, 3, 2) order by $i return $i".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.\nlet $i := (1, 3, 2) [Error is around here]order by $i return $i'.
XPTY0020,AssertionError: expected [Function] to throw an error
XQDY0025_1,AssertionError: expected [Function] to throw error including 'XQDY0025' but got 'XPST0003: Unable to parse XPath: "let $attr1 := attribute attr { \'foo\' } return let $attr2 := attribute attr { \'bar\' } return <a>{$attr1, $attr2 }</a>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "a" found.\nlet $attr1 := attribute [Error is around here]attr { \'foo\' } return let $attr2 := attribute attr { \'bar\' } return <a>{$attr1, $attr2 }</a>'
XQDY0025_2,AssertionError: expected [Function] to throw error including 'XQDY0025' but got 'XPST0003: Unable to parse XPath: "declare namespace prefix = "http://www/w3.org/"; let $attr1 := attribute prefix:attr { \'foo\' } return let $attr2 := attribute prefix:attr { \'bar\' } return <a>{$attr1, $attr2 }</a>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "p" found.\ndeclare namespace prefix = "http://www/w3.org/"; let $attr1 := attribute [Error is around here]prefix:attr { \'foo\' } return let $attr2 := attribute prefix:attr { \'bar\' } return <a>{$attr1, $attr2 }</a>'
XQDY0025_3,AssertionError: expected [Function] to throw error including 'XQDY0025' but got 'XPST0003: Unable to parse XPath: "declare namespace prefix = "http://www/w3.org/"; let $attr1 := attribute attr { \'foo\' } return let $attr2 := attribute attr { \'bar\' } return <prefix:a>{$attr1, $attr2 }</prefix:a>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "a" found.\ndeclare namespace prefix = "http://www/w3.org/"; let $attr1 := attribute [Error is around here]attr { \'foo\' } return let $attr2 := attribute attr { \'bar\' } return <prefix:a>{$attr1, $attr2 }</prefix:a>'
XQDY0025_4,AssertionError: expected [Function] to throw error including 'XQDY0025' but got 'XPST0003: Unable to parse XPath: "declare namespace prefix = "http://www/w3.org/"; let $attr1 := attribute prefix:attr { \'foo\' } return let $attr2 := attribute prefix:attr { \'bar\' } return <prefix:a>{$attr1, $attr2 }</prefix:a>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "p" found.\ndeclare namespace prefix = "http://www/w3.org/"; let $attr1 := attribute [Error is around here]prefix:attr { \'foo\' } return let $attr2 := attribute prefix:attr { \'bar\' } return <prefix:a>{$attr1, $attr2 }</prefix:a>'
XQDY0026,AssertionError: expected [Function] to throw error including 'XQDY0026' but got 'XPST0003: Unable to parse XPath: "processing-instruction target { \'?>\' }".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "t" found.\nprocessing-instruction [Error is around here]target { \'?>\' }'
XQDY0041,AssertionError: expected [Function] to throw error including 'XQDY0041' but got 'XPST0003: Unable to parse XPath: "<a> { processing-instruction { \'1BadName\' } { \'content\' } } </a>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.\n<a> { processing-instruction [Error is around here]{ \'1BadName\' } { \'content\' } } </a>'
XQDY0044_1,AssertionError: expected [Function] to throw error including 'XQDY0044' but got 'XPST0003: Unable to parse XPath: "<a> { attribute { \'xmlns\' } { \'http://www.w3.org/\' } } </a>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.\n<a> { attribute [Error is around here]{ \'xmlns\' } { \'http://www.w3.org/\' } } </a>'
XQDY0064,AssertionError: expected [Function] to throw error including 'XQDY0064' but got 'XPST0003: Unable to parse XPath: "<a> { processing-instruction { \'xml\' } { \'content\' } } </a>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.\n<a> { processing-instruction [Error is around here]{ \'xml\' } { \'content\' } } </a>'
XQDY0072,AssertionError: expected [Function] to throw error including 'XQDY0072' but got 'XPST0003: Unable to parse XPath: "<a> { comment { \' -- \' } } </a>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.\n<a> { comment [Error is around here]{ \' -- \' } } </a>'
XQDY0074_1,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: "<a> { element { \'prefix:localName\' } { } } </a>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.\n<a> { element [Error is around here]{ \'prefix:localName\' } { } } </a>'
XQDY0074_2,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: "<a> { attribute { \'prefix:localName\' } { } } </a>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.\n<a> { attribute [Error is around here]{ \'prefix:localName\' } { } } </a>'
XQDY0074_3,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: "<a> { element { \'1localName\' } { } } </a>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.\n<a> { element [Error is around here]{ \'1localName\' } { } } </a>'
XQDY0074_4,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: "<a> { attribute { \'1localName\' } { } } </a>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.\n<a> { attribute [Error is around here]{ \'1localName\' } { } } </a>'
XQDY0091,AssertionError: Expected executing the XPath "<e xml:id=" ab c d "/>" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw an error, AssertionError: Expected XPath <e xml:id=" ab c d "/> to resolve to the given XML. Expected <e xml:id=" ab c d "/> to equal <e xml:id="ab c d"/>.
XQST0031,AssertionError: expected [Function] to throw an error
XQST0032,AssertionError: expected [Function] to throw error including 'XQST0032' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
XQST0033,AssertionError: expected [Function] to throw an error
XQST0034,AssertionError: expected [Function] to throw error including 'XQST0034' but got 'XQST0049: The function Q{http://www.example.org/}foo#0 has already been declared.'
XQST0038_1,AssertionError: expected [Function] to throw error including 'XQST0038' but got 'XPST0003: Unable to parse XPath: "declare default collation "http://www.w3.org/2005/xpath-functions/collation/codepoint"; declare default collation "http://www.w3.org/2005/xpath-functions/collation/codepoint"; 1 + 2".\nExpected " ", "(:", "\\n", "\\r", "\\t", "decimal-format", "element", "function", or "order" but "c" found.\ndeclare default [Error is around here]collation "http://www.w3.org/2005/xpath-functions/collation/codepoint"; declare default collation "http://www.w3.org/2005/xpath-functions/collation/codepoint"; 1 + 2'
XQST0038_3,AssertionError: expected [Function] to throw error including 'XQST0038' but got 'XPST0003: Unable to parse XPath: "declare default collation "http://www.example.org/"; 1 + 2".\nExpected " ", "(:", "\\n", "\\r", "\\t", "decimal-format", "element", "function", or "order" but "c" found.\ndeclare default [Error is around here]collation "http://www.example.org/"; 1 + 2'
XQST0039,AssertionError: expected [Function] to throw an error
XQST0045-1,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XQST0060: Functions declared in a module must reside in a namespace.'
XQST0045-4,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0081: The prefix "xsi" could not be resolved'
XQST0046_01,AssertionError: Expected executing the XPath "base-uri(<a xml:base="%gg" />)" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0046' but got 'XPST0017: Function base-uri with arity of 1 not registered. No similar functions found.', AssertionError: expected [Function] to throw error including 'FORG0001' but got 'XPST0017: Function base-uri with arity of 1 not registered. No similar functions found.', Error: XPST0017: Function base-uri with arity of 1 not registered. No similar functions found..
XQST0046_02,AssertionError: Expected executing the XPath "import module "http://www.example.org/test"; true()" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0046' but got 'XQST0051: No modules found with the namespace uri http://www.example.org/test', AssertionError: expected [Function] to throw error including 'XQST0059' but got 'XQST0051: No modules found with the namespace uri http://www.example.org/test'.
XQST0046_04,AssertionError: Expected executing the XPath "declare default element namespace "%gg"; true()" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0046' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules', Error: Not implemented: only module imports and function declarations are implemented in XQuery modules.
XQST0046_05,AssertionError: Expected executing the XPath "declare default function namespace "%gg"; fn:true()" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0046' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules', Error: Not implemented: only module imports and function declarations are implemented in XQuery modules.
XQST0046_06,AssertionError: Expected executing the XPath "declare default collation "%gg"; fn:true()" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0046' but got 'XPST0003: Unable to parse XPath: "declare default collation "%gg"; fn:true()".\nExpected " ", "(:", "\\n", "\\r", "\\t", "decimal-format", "element", "function", or "order" but "c" found.\ndeclare default [Error is around here]collation "%gg"; fn:true()', AssertionError: expected [Function] to throw error including 'XQST0038' but got 'XPST0003: Unable to parse XPath: "declare default collation "%gg"; fn:true()".\nExpected " ", "(:", "\\n", "\\r", "\\t", "decimal-format", "element", "function", or "order" but "c" found.\ndeclare default [Error is around here]collation "%gg"; fn:true()', Error: XPST0003: Unable to parse XPath: "declare default collation "%gg"; fn:true()". Expected " ", "(:", "\n", "\r", "\t", "decimal-format", "element", "function", or "order" but "c" found. declare default [Error is around here]collation "%gg"; fn:true().
XQST0046_07,AssertionError: Expected executing the XPath "declare base-uri "%gg"; true()" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0046' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules', Error: Not implemented: only module imports and function declarations are implemented in XQuery modules.
XQST0046_09,AssertionError: Expected executing the XPath "import schema "http://www.w3.org/" at "%gg"; 1" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0046' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules', AssertionError: expected [Function] to throw error including 'XQST0059' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'.
XQST0046_11,AssertionError: Expected executing the XPath "import module "http://www.w3.org/" at "%gg"; 1" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0046' but got 'XPST0003: Unable to parse XPath: "import module "http://www.w3.org/" at "%gg"; 1".\nExpected "\'" or "\\"" but " " found.\nimport module "http://www.w3.org/" at[Error is around here] "%gg"; 1', AssertionError: expected [Function] to throw error including 'XQST0059' but got 'XPST0003: Unable to parse XPath: "import module "http://www.w3.org/" at "%gg"; 1".\nExpected "\'" or "\\"" but " " found.\nimport module "http://www.w3.org/" at[Error is around here] "%gg"; 1'.
XQST0046_12,AssertionError: Expected executing the XPath "for $x in ("a", "a", "a") order by $x collation "%gg" return $x" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0046' but got 'XPST0003: Unable to parse XPath: "for $x in ("a", "a", "a") order by $x collation "%gg" return $x".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.\nfor $x in ("a", "a", "a") [Error is around here]order by $x collation "%gg" return $x', AssertionError: expected [Function] to throw error including 'XQST0076' but got 'XPST0003: Unable to parse XPath: "for $x in ("a", "a", "a") order by $x collation "%gg" return $x".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.\nfor $x in ("a", "a", "a") [Error is around here]order by $x collation "%gg" return $x', Error: XPST0003: Unable to parse XPath: "for $x in ("a", "a", "a") order by $x collation "%gg" return $x". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. for $x in ("a", "a", "a") [Error is around here]order by $x collation "%gg" return $x.
XQST0047,AssertionError: expected [Function] to throw error including 'XQST0047' but got 'Duplicate function registration'
XQST0048,Error: XQST0048: Functions and variables declared in a module must reside in the module target namespace.
XQST0049,AssertionError: expected [Function] to throw error including 'XQST0049' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
XQST0054,AssertionError: expected [Function] to throw error including 'XQST0054' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
XQST0055,AssertionError: expected [Function] to throw error including 'XQST0055' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
XQST0057,AssertionError: expected [Function] to throw error including 'XQST0057' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
XQST0059_2,AssertionError: expected [Function] to throw error including 'XQST0059' but got 'XPST0003: Unable to parse XPath: "import module namespace foo = "http://www.w3.org/" at "DoesNotExist.xq"; 1".\nExpected "\'" or "\\"" but " " found.\nimport module namespace foo = "http://www.w3.org/" at[Error is around here] "DoesNotExist.xq"; 1'
XQST0059_4,AssertionError: expected [Function] to throw error including 'XQST0059' but got 'XQST0051: No modules found with the namespace uri http://www.w3.org/'
XQST0059_5,AssertionError: expected [Function] to throw error including 'XQST0059' but got 'XQST0051: No modules found with the namespace uri http://www.example.org/'
XQST0060,AssertionError: expected [Function] to throw error including 'XQST0060' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
XQST0065,AssertionError: expected [Function] to throw error including 'XQST0065' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
XQST0066_1,AssertionError: expected [Function] to throw error including 'XQST0066' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
XQST0066_3,AssertionError: expected [Function] to throw error including 'XQST0066' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
XQST0067,AssertionError: expected [Function] to throw error including 'XQST0067' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
XQST0068,AssertionError: expected [Function] to throw error including 'XQST0068' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
XQST0069,AssertionError: expected [Function] to throw error including 'XQST0069' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
XQST0070_1,AssertionError: expected [Function] to throw error including 'XQST0070' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
XQST0070_2,AssertionError: expected [Function] to throw error including 'XQST0070' but got 'XQST0051: No modules found with the namespace uri http://www.example.org/'
XQST0070_3,SyntaxError: Expected " ", "(:", ";", "\n", "\r", or "\t" but end of input found.
XQST0070_4,AssertionError: expected [Function] to throw an error
XQST0076,AssertionError: expected [Function] to throw error including 'XQST0076' but got 'XPST0003: Unable to parse XPath: "for $x in (\'a\', \'b\', \'c\') order by $x collation \'http://www.w3.org/\' return $x".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.\nfor $x in (\'a\', \'b\', \'c\') [Error is around here]order by $x collation \'http://www.w3.org/\' return $x'
XQST0079,AssertionError: expected [Function] to throw error including 'XQST0079' but got 'XPST0003: Unable to parse XPath: "declare namespace prefix = "http://www.w3.org/"; (# prefix:pragma #) { }".\nExpected " ", "$", "\'", "(", "(:", ")", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\\"", "\\n", "\\r", "\\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "#" found.\ndeclare namespace prefix = "http://www.w3.org/"; ([Error is around here]# prefix:pragma #) { }'
XQST0085,AssertionError: expected [Function] to throw an error
XQST0085b,Error: XPST0017: Function in-scope-prefixes with arity of 1 not registered. No similar functions found.
XQST0085c,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'NamespaceError: Qualified name with prefix can not have a null namespace'
XQST0087,AssertionError: expected [Function] to throw an error
XQST0088_1,AssertionError: expected [Function] to throw error including 'XQST0088' but got 'XQST0051: No modules found with the namespace uri '
XQST0088_2,Error: XPST0081: The prefix "cheese" could not be resolved
XQST0089,AssertionError: expected [Function] to throw error including 'XQST0089' but got 'XPST0003: Unable to parse XPath: "for $x at $x in (1, 2, 3) return $x".\nExpected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.\nfor $x [Error is around here]at $x in (1, 2, 3) return $x'
XQST0093,Error: Duplicate function registration
XQST0093a,Error: Duplicate function registration
XQTY0024_1,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: "declare namespace prefix = "http://www.w3.org/"; <prefix:a> { <b />, attribute prefix:foo { \'bar\' } } </prefix:a>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "p" found.\ndeclare namespace prefix = "http://www.w3.org/"; <prefix:a> { <b />, attribute [Error is around here]prefix:foo { \'bar\' } } </prefix:a>'
XQTY0024_2,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: "declare namespace prefix = "http://www.w3.org/"; <prefix:a> { <b />, attribute foo { \'bar\' } } </prefix:a>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "f" found.\ndeclare namespace prefix = "http://www.w3.org/"; <prefix:a> { <b />, attribute [Error is around here]foo { \'bar\' } } </prefix:a>'
XQTY0024_3,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: "declare namespace prefix = "http://www.w3.org/"; <a> { <b />, attribute prefix:foo { \'bar\' } } </a>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "p" found.\ndeclare namespace prefix = "http://www.w3.org/"; <a> { <b />, attribute [Error is around here]prefix:foo { \'bar\' } } </a>'
XQTY0024_4,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: "<a> { <b />, attribute foo { \'bar\' } } </a>".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "f" found.\n<a> { <b />, attribute [Error is around here]foo { \'bar\' } } </a>'
XQTY0086_1,AssertionError: expected [Function] to throw error including 'XQTY0086' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
XQTY0086_2,AssertionError: expected [Function] to throw error including 'XQTY0086' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
XQTY0086_3,AssertionError: expected [Function] to throw error including 'XQTY0086' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
XQST0125_1,AssertionError: expected [Function] to throw error including 'XQST0125' but got 'XPST0003: Unable to parse XPath: "\n        let $f := %public function($arg as xs:integer) as xs:integer \n                          { $arg + 1 }\n        return $f(1)\n      ".\nExpected " ", "$", "\'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\\"", "\\n", "\\r", "\\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "%" found.\n\n        let $f := [Error is around here]%public function($arg as xs:integer) as xs:integer \n                          { $arg + 1 }\n        return $f(1)\n      '
XQST0125_2,AssertionError: expected [Function] to throw error including 'XQST0125' but got 'XPST0003: Unable to parse XPath: "\n        let $f := %private function($arg as xs:integer) as xs:integer \n                           { $arg + 1 }\n        return $f(1)\n      ".\nExpected " ", "$", "\'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\\"", "\\n", "\\r", "\\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "%" found.\n\n        let $f := [Error is around here]%private function($arg as xs:integer) as xs:integer \n                           { $arg + 1 }\n        return $f(1)\n      '
annex-1,Error: XPST0003: Unable to parse XPath: "declare namespace eg = "http://example.org"; declare function eg:if-empty ( $node as node()?, $value as xs:anyAtomicType) as xs:anyAtomicType* { if ($node and $node/child::node()) then fn:data($node) else $value }; let $arg1 := <element1>some data</element1> let $arg2 as xs:anyAtomicType := 1 return eg:if-empty($arg1,$arg2)". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. declare namespace eg = "http://example.org"; declare function eg:if-empty ( $node as node()?, $value as xs:anyAtomicType) as xs:anyAtomicType* { if ($node and $node/child::node()) then fn:data($node) else $value }; let $arg1 := <element1>some data</element1> [Error is around here]let $arg2 as xs:anyAtomicType := 1 return eg:if-empty($arg1,$arg2)
annex-2,Error: XPST0003: Unable to parse XPath: "declare namespace eg = "http://example.org"; declare function eg:if-absent ( $node as node()?, $value as xs:anyAtomicType) as xs:anyAtomicType* { if ($node) then fn:data($node) else $value }; let $arg1 := <element1>some data</element1> let $arg2 as xs:anyAtomicType := 1 return eg:if-absent($arg1,$arg2)". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. declare namespace eg = "http://example.org"; declare function eg:if-absent ( $node as node()?, $value as xs:anyAtomicType) as xs:anyAtomicType* { if ($node) then fn:data($node) else $value }; let $arg1 := <element1>some data</element1> [Error is around here]let $arg2 as xs:anyAtomicType := 1 return eg:if-absent($arg1,$arg2)
annex-3,Error: XPST0003: Unable to parse XPath: "declare namespace eg = "http://example.org"; declare function eg:value-union ( $arg1 as xs:anyAtomicType*, $arg2 as xs:anyAtomicType*) as xs:anyAtomicType* { fn:distinct-values(($arg1, $arg2)) }; let $arg1 as xs:anyAtomicType := 1 let $arg2 as xs:anyAtomicType := 2 return eg:value-union($arg1,$arg2)". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. declare namespace eg = "http://example.org"; declare function eg:value-union ( $arg1 as xs:anyAtomicType*, $arg2 as xs:anyAtomicType*) as xs:anyAtomicType* { fn:distinct-values(($arg1, $arg2)) }; let $arg1 [Error is around here]as xs:anyAtomicType := 1 let $arg2 as xs:anyAtomicType := 2 return eg:value-union($arg1,$arg2)
annex-4,AssertionError: Expected executing the XPath "declare namespace eg = "http://example.org"; declare function eg:value-intersect ( $arg1 as xs:anyAtomicType*, $arg2 as xs:anyAtomicType* ) as xs:anyAtomicType* { fn:distinct-values($arg1[.=$arg2]) }; let $arg1 as xs:anyAtomicType := 1 let $arg2 as xs:anyAtomicType := 1 return eg:value-intersect($arg1,$arg2)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "declare namespace eg = "http://example.org"; declare function eg:value-intersect ( $arg1 as xs:anyAtomicType*, $arg2 as xs:anyAtomicType* ) as xs:anyAtomicType* { fn:distinct-values($arg1[.=$arg2]) }; let $arg1 as xs:anyAtomicType := 1 let $arg2 as xs:anyAtomicType := 1 return eg:value-intersect($arg1,$arg2) = 1". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. declare namespace eg = "http://example.org"; declare function eg:value-intersect ( $arg1 as xs:anyAtomicType*, $arg2 as xs:anyAtomicType* ) as xs:anyAtomicType* { fn:distinct-values($arg1[.=$arg2]) }; let $arg1 [Error is around here]as xs:anyAtomicType := 1 let $arg2 as xs:anyAtomicType := 1 return eg:value-intersect($arg1,$arg2) = 1, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "declare namespace eg = "http://example.org"; declare function eg:value-intersect ( $arg1 as xs:anyAtomicType*, $arg2 as xs:anyAtomicType* ) as xs:anyAtomicType* { fn:distinct-values($arg1[.=$arg2]) }; let $arg1 as xs:anyAtomicType := 1 let $arg2 as xs:anyAtomicType := 1 return eg:value-intersect($arg1,$arg2)".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\ndeclare namespace eg = "http://example.org"; declare function eg:value-intersect ( $arg1 as xs:anyAtomicType*, $arg2 as xs:anyAtomicType* ) as xs:anyAtomicType* { fn:distinct-values($arg1[.=$arg2]) }; let $arg1 [Error is around here]as xs:anyAtomicType := 1 let $arg2 as xs:anyAtomicType := 1 return eg:value-intersect($arg1,$arg2)'.
annex-5,AssertionError: Expected executing the XPath "declare namespace eg = "http://example.org"; declare function eg:value-except ( $arg1 as xs:anyAtomicType*, $arg2 as xs:anyAtomicType*) as xs:anyAtomicType* { fn:distinct-values($arg1[not(.=$arg2)]) }; let $arg1 as xs:anyAtomicType := 1 let $arg2 as xs:anyAtomicType := 2 return eg:value-except($arg1,$arg2)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "declare namespace eg = "http://example.org"; declare function eg:value-except ( $arg1 as xs:anyAtomicType*, $arg2 as xs:anyAtomicType*) as xs:anyAtomicType* { fn:distinct-values($arg1[not(.=$arg2)]) }; let $arg1 as xs:anyAtomicType := 1 let $arg2 as xs:anyAtomicType := 2 return eg:value-except($arg1,$arg2) = 1". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. declare namespace eg = "http://example.org"; declare function eg:value-except ( $arg1 as xs:anyAtomicType*, $arg2 as xs:anyAtomicType*) as xs:anyAtomicType* { fn:distinct-values($arg1[not(.=$arg2)]) }; let $arg1 [Error is around here]as xs:anyAtomicType := 1 let $arg2 as xs:anyAtomicType := 2 return eg:value-except($arg1,$arg2) = 1, AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "declare namespace eg = "http://example.org"; declare function eg:value-except ( $arg1 as xs:anyAtomicType*, $arg2 as xs:anyAtomicType*) as xs:anyAtomicType* { fn:distinct-values($arg1[not(.=$arg2)]) }; let $arg1 as xs:anyAtomicType := 1 let $arg2 as xs:anyAtomicType := 2 return eg:value-except($arg1,$arg2)".\nExpected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.\ndeclare namespace eg = "http://example.org"; declare function eg:value-except ( $arg1 as xs:anyAtomicType*, $arg2 as xs:anyAtomicType*) as xs:anyAtomicType* { fn:distinct-values($arg1[not(.=$arg2)]) }; let $arg1 [Error is around here]as xs:anyAtomicType := 1 let $arg2 as xs:anyAtomicType := 2 return eg:value-except($arg1,$arg2)'.
annex-6,Error: XPST0003: Unable to parse XPath: "declare namespace eg = "http://example.org"; declare function eg:index-of-node($sequence as node()*, $srch as node()) as xs:integer* { for $n at $i in $sequence where ($n is $srch) return $i }; let $arg1 := (<element1>some data 1</element1>,<element2>some data 2</element2>) let $arg2 := $arg1[2] return eg:index-of-node($arg1, exactly-one($arg2)) = 2". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. declare namespace eg = "http://example.org"; declare function eg:index-of-node($sequence as node()*, $srch as node()) as xs:integer* { for $n [Error is around here]at $i in $sequence where ($n is $srch) return $i }; let $arg1 := (<element1>some data 1</element1>,<element2>some data 2</element2>) let $arg2 := $arg1[2] return eg:index-of-node($arg1, exactly-one($arg2)) = 2
annex-7,Error: XPST0003: Unable to parse XPath: "declare namespace eg = "http://example.org"; declare function eg:string-pad ( $padString as xs:string?, $padCount as xs:integer) as xs:string { fn:string-join((for $i in 1 to $padCount return $padString), "") }; let $arg1 as xs:string := "A String" let $arg2 as xs:integer := 3 return eg:string-pad($arg1,$arg2)". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found. declare namespace eg = "http://example.org"; declare function eg:string-pad ( $padString as xs:string?, $padCount as xs:integer) as xs:string { fn:string-join((for $i in 1 to $padCount return $padString), "") }; let $arg1 [Error is around here]as xs:string := "A String" let $arg2 as xs:integer := 3 return eg:string-pad($arg1,$arg2)
annex-8,Error: XPST0003: Unable to parse XPath: "declare namespace eg = "http://example.org"; declare function eg:distinct-nodes-stable ($arg as node()*) as node()* { for $a at $apos in $arg let $before_a := fn:subsequence($arg, 1, $apos - 1) where every $ba in $before_a satisfies not($ba is $a) return $a }; let $arg1 := (<element1>some data 1</element1>,<element2>some data 2</element2>) return eg:distinct-nodes-stable($arg1)". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. declare namespace eg = "http://example.org"; declare function eg:distinct-nodes-stable ($arg as node()*) as node()* { for $a [Error is around here]at $apos in $arg let $before_a := fn:subsequence($arg, 1, $apos - 1) where every $ba in $before_a satisfies not($ba is $a) return $a }; let $arg1 := (<element1>some data 1</element1>,<element2>some data 2</element2>) return eg:distinct-nodes-stable($arg1)
errors-and-optimization-1,Error: XPST0017: Function error with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
errors-and-optimization-2,AssertionError: expected [Function] to throw an error
errors-and-optimization-7,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'Not implemented: references to variables with a namespace URI or a prefix.'
hof-006,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
hof-007,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
hof-010,Error: XPST0003: Unable to parse XPath: "       declare function local:f($x as xs:integer) as xs:integer { $x + 1 };        let $f as function(*) := local:f#1 return $f(2)        = 3". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.        declare function local:f($x as xs:integer) as xs:integer { $x + 1 };        let $f [Error is around here]as function(*) := local:f#1 return $f(2)        = 3
hof-011,Error: XPST0003: Unable to parse XPath: "       declare function local:f($x as xs:integer) as xs:integer { $x + 3 };        let $f as function(xs:integer) as xs:integer := local:f#1        return $f(2)        = 5". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.        declare function local:f($x as xs:integer) as xs:integer { $x + 3 };        let $f [Error is around here]as function(xs:integer) as xs:integer := local:f#1        return $f(2)        = 5
hof-012,Error: XPST0003: Unable to parse XPath: "       declare function local:f($x as xs:integer, $y as xs:long) as xs:integer { $x + $y };        let $f as function(xs:integer, xs:long) as xs:integer := local:f#2        return $f(2, xs:long(5))        = 7". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.        declare function local:f($x as xs:integer, $y as xs:long) as xs:integer { $x + $y };        let $f [Error is around here]as function(xs:integer, xs:long) as xs:integer := local:f#2        return $f(2, xs:long(5))        = 7
hof-013,Error: XPST0003: Unable to parse XPath: "       declare function local:f($x as xs:integer) as xs:integer { $x + 3 };        declare function local:g($x as xs:integer) as xs:integer { $x + 4 };        declare function local:h($x as xs:integer) as xs:integer { $x + 5 };        let $f as (function(xs:integer) as xs:integer)* := (local:f#1, local:g#1, local:h#1) return $f[3](2)[1]        = 7". Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.        declare function local:f($x as xs:integer) as xs:integer { $x + 3 };        declare function local:g($x as xs:integer) as xs:integer { $x + 4 };        declare function local:h($x as xs:integer) as xs:integer { $x + 5 };        let $f [Error is around here]as (function(xs:integer) as xs:integer)* := (local:f#1, local:g#1, local:h#1) return $f[3](2)[1]        = 7
hof-017,Error: XPST0081: The type function(xs:string?) as xs:string could not be found.
hof-018,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
hof-019,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
hof-020,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
hof-021,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
hof-022,Error: XPST0017: Function function-name with arity of 1 not registered. No similar functions found.
hof-023,Error: XPST0017: Function fn:function-name with arity of 1 not registered. No similar functions found.
hof-024,Error: XPST0017: Function function-name with arity of 1 not registered. No similar functions found.
hof-025,Error: XPST0017: Function function-name with arity of 1 not registered. No similar functions found.
hof-026,Error: XPST0003: Unable to parse XPath: "         let $f := function($x as xs:string) as xs:string { upper-case($x) }          let $n := function-name($f)          return <a loc="{local-name-from-QName($n)}" uri="{namespace-uri-from-QName($n)}"         			arity="{function-arity($f)}" eloc="{empty(local-name-from-QName($n))}" euri="{empty(namespace-uri-from-QName($n))}"/>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.          let $f := function($x as xs:string) as xs:string { upper-case($x) }          [Error is around here]let $n := function-name($f)          return <a loc="{local-name-from-QName($n)}" uri="{namespace-uri-from-QName($n)}"         			arity="{function-arity($f)}" eloc="{empty(local-name-from-QName($n))}" euri="{empty(namespace-uri-from-QName($n))}"/>
hof-030,Error: XPST0003: Unable to parse XPath: "       declare variable $sep as xs:string := "\s";        declare function local:splitter() as (function(xs:string) as xs:string*)?        	{ function($x as xs:string) { for $i in tokenize($x, $sep) return upper-case($i)} };        string-join(local:splitter()("A nice cup of tea"), '|')       ". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.        declare variable $sep [Error is around here]as xs:string := "\s";        declare function local:splitter() as (function(xs:string) as xs:string*)?        	{ function($x as xs:string) { for $i in tokenize($x, $sep) return upper-case($i)} };        string-join(local:splitter()("A nice cup of tea"), '|')
hof-033,Error: XPST0017: Function function-name with arity of 1 not registered. No similar functions found.
hof-034,Error: XPST0003: Unable to parse XPath: "local-name-from-QName(function-name((upper-case#1, lower-case#1)[ordered{.}("Mike") = "MIKE"]))". Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "]", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. local-name-from-QName(function-name((upper-case#1, lower-case#1)[ordered[Error is around here]{.}("Mike") = "MIKE"]))
hof-035,Error: XPST0003: Unable to parse XPath: "local-name-from-QName(function-name((upper-case#1, lower-case#1)[ordered{.}("Mike") = "MIKE"]))". Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "]", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "{" found. local-name-from-QName(function-name((upper-case#1, lower-case#1)[ordered[Error is around here]{.}("Mike") = "MIKE"]))
hof-037,Error: No selector counterpart for: anyFunctionTest.
hof-038,Error: No selector counterpart for: functionTest.
hof-039,Error: XPST0003: Unable to parse XPath: "       	declare function local:f($x as xs:long, $y as xs:NCName) as element(e)? { <e x="{$x}" y="{$y}"/> };        	local:f#2 instance of function(xs:long, xs:NCName) as element()?,        	local:f#2 instance of function(xs:long, xs:NCName) as element()*,        	local:f#2 instance of function(xs:long, xs:NCName) as element(e)*,        	local:f#2 instance of function(xs:long, xs:NCName) as element(e, xs:anyType?)*,        	local:f#2 instance of function(xs:long, xs:NCName) as element(*, xs:anyType?)?,        	local:f#2 instance of function(xs:long, xs:NCName) as element(*, xs:untyped)?       ". Expected " ", "(:", ")", "\n", "\r", "\t", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "?" found.        	declare function local:f($x as xs:long, $y as xs:NCName) as element(e)? { <e x="{$x}" y="{$y}"/> };        	local:f#2 instance of function(xs:long, xs:NCName) as element()?,        	local:f#2 instance of function(xs:long, xs:NCName) as element()*,        	local:f#2 instance of function(xs:long, xs:NCName) as element(e)*,        	local:f#2 instance of function(xs:long, xs:NCName) as element(e, xs:anyType[Error is around here]?)*,        	local:f#2 instance of function(xs:long, xs:NCName) as element(*, xs:anyType?)?,        	local:f#2 instance of function(xs:long, xs:NCName) as element(*, xs:untyped)?
hof-040,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
hof-041,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
hof-042,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
hof-043,Error: XPST0081: Can not cast: type xs:numeric is unknown.
hof-045,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
hof-046,Error: XPST0003: Unable to parse XPath: "         declare function local:splitter($x as xs:string) as (function() as xs:string*)* {              for $sep in ('\s', ',', '!')              return function() { for $i in tokenize($x, $sep) return upper-case($i) }          };          <out>{              for $f as function(*) in local:splitter("How nice! Thank you, I enjoyed that.")              return <tokens>{ for $t in $f()                               return <t>{$t}</t>                     }</tokens>         }</out>     ". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.          declare function local:splitter($x as xs:string) as (function() as xs:string*)* {              for $sep in ('\s', ',', '!')              return function() { for $i in tokenize($x, $sep) return upper-case($i) }          };          <out>{              for $f [Error is around here]as function(*) in local:splitter("How nice! Thank you, I enjoyed that.")              return <tokens>{ for $t in $f()                               return <t>{$t}</t>                     }</tokens>         }</out>
hof-047,Error: XPST0003: Unable to parse XPath: "         declare function local:splitter($x as xs:string) as (function() as xs:string*)* {              for $sep in ('\s', ',', '!') return function() {                  for $i in tokenize($x, $sep) return                      let $f := function(){ concat($sep, ':', upper-case($i)) }                      return $f() }          };          <out>{              for $f as function(*) in local:splitter("How nice! Thank you, I enjoyed that.")              return <tokens>{ for $t in $f()                               return <t>{$t}</t> }</tokens>          }</out>      ". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.          declare function local:splitter($x as xs:string) as (function() as xs:string*)* {              for $sep in ('\s', ',', '!') return function() {                  for $i in tokenize($x, $sep) return                      let $f := function(){ concat($sep, ':', upper-case($i)) }                      return $f() }          };          <out>{              for $f [Error is around here]as function(*) in local:splitter("How nice! Thank you, I enjoyed that.")              return <tokens>{ for $t in $f()                               return <t>{$t}</t> }</tokens>          }</out>
hof-052,Error: XPST0003: Unable to parse XPath: "let $f := fn:concat#3(?, '*', ?) let $g := $f('[', ?) return <out>{$g(']')}</out>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. let $f := fn:concat#3(?, '*', ?) [Error is around here]let $g := $f('[', ?) return <out>{$g(']')}</out>
hof-053,Error: XPST0003: Unable to parse XPath: "       	declare function local:f($x as xs:long, $y as xs:NCName) as element(e, xs:anyAtomicType) { <e x="{$x}" y="{$y}"/> };        	local:f#2 instance of function(xs:long, xs:NCName) as element(),        	local:f#2 instance of function(xs:long, xs:NCName) as element()+,        	local:f#2 instance of function(xs:long, xs:NCName) as element()?,        	local:f#2 instance of function(xs:long, xs:NCName) as element()*,        	local:f#2 instance of function(xs:long, xs:NCName) as element(e)*,        	local:f#2 instance of function(xs:long, xs:NCName) as element(e, xs:anyType?)*,        	local:f#2 instance of function(xs:long, xs:NCName) as element(*, xs:anyType?)?,        	local:f#2 instance of function(xs:long, xs:NCName) as element(e, xs:anyType)*,        	local:f#2 instance of function(xs:long, xs:NCName) as element(*, xs:anyType)?,        	local:f#2 instance of function(xs:long, xs:NCName) as element(*, xs:untyped)?       ". Expected " ", "(:", ")", "\n", "\r", "\t", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], or [�-�] but "?" found.        	declare function local:f($x as xs:long, $y as xs:NCName) as element(e, xs:anyAtomicType) { <e x="{$x}" y="{$y}"/> };        	local:f#2 instance of function(xs:long, xs:NCName) as element(),        	local:f#2 instance of function(xs:long, xs:NCName) as element()+,        	local:f#2 instance of function(xs:long, xs:NCName) as element()?,        	local:f#2 instance of function(xs:long, xs:NCName) as element()*,        	local:f#2 instance of function(xs:long, xs:NCName) as element(e)*,        	local:f#2 instance of function(xs:long, xs:NCName) as element(e, xs:anyType[Error is around here]?)*,        	local:f#2 instance of function(xs:long, xs:NCName) as element(*, xs:anyType?)?,        	local:f#2 instance of function(xs:long, xs:NCName) as element(e, xs:anyType)*,        	local:f#2 instance of function(xs:long, xs:NCName) as element(*, xs:anyType)?,        	local:f#2 instance of function(xs:long, xs:NCName) as element(*, xs:untyped)?
hof-905,AssertionError: expected [Function] to throw an error
hof-906,AssertionError: expected [Function] to throw error including 'FOTY0013' but got 'XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?'
hof-907,AssertionError: expected [Function] to throw an error
hof-912,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function translate with arity of 3 not registered. No similar functions found.'
hof-913,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function translate with arity of 3 not registered. No similar functions found.'
hof-914,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0081: The type (function(xs:string) as xs:string) could not be found.'
hof-918,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
hof-919,AssertionError: expected [Function] to throw an error
function-item-1,Error: No selector counterpart for: anyFunctionTest.
function-item-5,AssertionError: expected [Function] to throw error including 'XQTY0105' but got 'XPST0003: Unable to parse XPath: "element a { avg#1 }".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "a" found.\nelement [Error is around here]a { avg#1 }'
function-item-6,AssertionError: expected [Function] to throw error including 'FOTY0013' but got 'XPST0003: Unable to parse XPath: "attribute a { avg#1 }".\nExpected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "a" found.\nattribute [Error is around here]a { avg#1 }'
function-item-8,Error: XPST0017: Function function-name with arity of 1 not registered. No similar functions found.
function-item-9,Error: XPST0017: Function function-name with arity of 1 not registered. No similar functions found.
function-item-10,Error: No selector counterpart for: functionTest.
function-item-12,Error: No selector counterpart for: anyFunctionTest.
function-item-13,Error: No selector counterpart for: functionTest.
function-item-14,Error: No selector counterpart for: functionTest.
function-item-15,Error: No selector counterpart for: functionTest.
function-item-16,Error: No selector counterpart for: functionTest.
function-item-17,Error: No selector counterpart for: functionTest.
inline-function-1,Error: No selector counterpart for: anyFunctionTest.
inline-function-2,Error: XPST0017: Function function-name with arity of 1 not registered. No similar functions found.
inline-function-6,Error: No selector counterpart for: functionTest.
inline-function-7,Error: No selector counterpart for: functionTest.
inline-function-8,Error: No selector counterpart for: functionTest.
inline-function-9,Error: No selector counterpart for: functionTest.
inline-function-12a,AssertionError: expected [Function] to throw an error
inline-function-13,AssertionError: expected [Function] to throw error including 'XQST0039' but got 'Not implemented: references to variables with a namespace URI or a prefix.'
inline-function-14,Error: Not implemented: references to variables with a namespace URI or a prefix.
inline-function-15,AssertionError: expected [Function] to throw error including 'XQST0039' but got 'Not implemented: references to variables with a namespace URI or a prefix.'
inline-function-16,Error: Not implemented: references to variables with a namespace URI or a prefix.
xqhof1,Error: XPST0003: Unable to parse XPath: " declare namespace map = "http://snelson.org.uk/functions/map";  declare function map:key($pair as function() as item()+) as item() {   $pair()[1] };  declare function map:value($pair as function() as item()+) as item()* {   subsequence($pair(), 2) };  declare function map:contains($map as (function() as item()+)*, $key as item())   as xs:boolean {   map:process($map, $key, function($a) { true() }, false(),     function($a) { () }) };  declare function map:get($map as (function() as item()+)*, $key as item())   as item()* {   map:process($map, $key, map:value#1, (), function($a) { () }) };  declare function map:process(   $map as (function() as item()+)*,   $key as item(),   $found as function(function() as item()+) as item()*,   $notfound as item()*,   $unused as function((function() as item()+)*) as item()* ) as item()* {   if(empty($map)) then $notfound   else    let $length := count($map)   let $middle := $length idiv 2 + 1   let $pair := $map[$middle]   let $pair_key := $pair()[1]   return     if($pair_key eq $key) then (       $unused(subsequence($map, 1, $middle - 1)),       $found($pair),       $unused(subsequence($map, $middle + 1))     )     else if($pair_key gt $key) then (       map:process(subsequence($map, 1, $middle - 1), $key,         $found, $notfound, $unused),       $unused(subsequence($map, $middle))     )     else (       $unused(subsequence($map, 1, $middle)),       map:process(subsequence($map, $middle + 1), $key,         $found, $notfound, $unused)     ) };  declare function map:pair($key as item(), $value as item()*)   as function() as item()+ {   function() { $key, $value } };  declare function map:put(   $map as (function() as item()+)*,   $key as item(),   $value as item()* ) as (function() as item()+)+ {   let $pair := map:pair($key, $value)   return     map:process($map, $key, function($a) { $pair }, $pair,       function($a) { $a }) };  string-join(let $map := map:put(map:put(map:put(map:put(map:put(map:put((),   "a", "aardvark"),   "z", "zebra"),   "e", ("elephant", "eagle")),   "o", "osterich"),   "t", "terrapin"),   "a", "antelope") return (   map:get($map, "o"),    for $m in $map   return concat("key: ", map:key($m), ", value: (",     string-join(map:value($m), ", "), ")")) , " ")  = "osterich key: a, value: (antelope) key: e, value: (elephant, eagle) key: o, value: (osterich) key: t, value: (terrapin) key: z, value: (zebra)"". Expected " ", "(:", "\n", "\r", or "\t" but "m" found.  declare namespace map = "http://snelson.org.uk/functions/map";  declare function [Error is around here]map:key($pair as function() as item()+) as item() {   $pair()[1] };  declare function map:value($pair as function() as item()+) as item()* {   subsequence($pair(), 2) };  declare function map:contains($map as (function() as item()+)*, $key as item())   as xs:boolean {   map:process($map, $key, function($a) { true() }, false(),     function($a) { () }) };  declare function map:get($map as (function() as item()+)*, $key as item())   as item()* {   map:process($map, $key, map:value#1, (), function($a) { () }) };  declare function map:process(   $map as (function() as item()+)*,   $key as item(),   $found as function(function() as item()+) as item()*,   $notfound as item()*,   $unused as function((function() as item()+)*) as item()* ) as item()* {   if(empty($map)) then $notfound   else    let $length := count($map)   let $middle := $length idiv 2 + 1   let $pair := $map[$middle]   let $pair_key := $pair()[1]   return     if($pair_key eq $key) then (       $unused(subsequence($map, 1, $middle - 1)),       $found($pair),       $unused(subsequence($map, $middle + 1))     )     else if($pair_key gt $key) then (       map:process(subsequence($map, 1, $middle - 1), $key,         $found, $notfound, $unused),       $unused(subsequence($map, $middle))     )     else (       $unused(subsequence($map, 1, $middle)),       map:process(subsequence($map, $middle + 1), $key,         $found, $notfound, $unused)     ) };  declare function map:pair($key as item(), $value as item()*)   as function() as item()+ {   function() { $key, $value } };  declare function map:put(   $map as (function() as item()+)*,   $key as item(),   $value as item()* ) as (function() as item()+)+ {   let $pair := map:pair($key, $value)   return     map:process($map, $key, function($a) { $pair }, $pair,       function($a) { $a }) };  string-join(let $map := map:put(map:put(map:put(map:put(map:put(map:put((),   "a", "aardvark"),   "z", "zebra"),   "e", ("elephant", "eagle")),   "o", "osterich"),   "t", "terrapin"),   "a", "antelope") return (   map:get($map, "o"),    for $m in $map   return concat("key: ", map:key($m), ", value: (",     string-join(map:value($m), ", "), ")")) , " ")  = "osterich key: a, value: (antelope) key: e, value: (elephant, eagle) key: o, value: (osterich) key: t, value: (terrapin) key: z, value: (zebra)"
xqhof2,SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
xqhof3,SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
xqhof6,Error: XPST0081: The type function(item()*, item()*) as item() could not be found.
xqhof10,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
xqhof12,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function matches with arity of 2 not registered. No similar functions found.'
xqhof14,AssertionError: expected [Function] to throw an error
xqhof15,AssertionError: Expected XPath           let $f := <b/>/name#0          return <a/>/$f()               to resolve to "b": expected false to be true
xqhof16,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
xqhof17,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
xqhof18,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
xqhof19,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
xqhof20,Error: XPST0003: Unable to parse XPath: "deep-equal((           let $m := map {                 "Tuesday" : true(),                 "Wednesday" : true(),                 "Thursday" : false(),                 "Friday" : true(),                 "Monday" : true(),                 "Sunday" : false(),                 "Saturday" : false() }           let $days := ("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")                return fn:filter($days,$m)               ), ("Monday", "Tuesday", "Wednesday", "Friday"))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. deep-equal((           let $m := map {                 "Tuesday" : true(),                 "Wednesday" : true(),                 "Thursday" : false(),                 "Friday" : true(),                 "Monday" : true(),                 "Sunday" : false(),                 "Saturday" : false() }           [Error is around here]let $days := ("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")                return fn:filter($days,$m)               ), ("Monday", "Tuesday", "Wednesday", "Friday"))
xqhof21,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "\n          let $m := map {\n                "Tuesday" : true(),\n                "Wednesday" : true(),\n                "Friday" : true(),\n                "Monday" : true(),\n                "Sunday" : false(),\n                "Saturday" : false() }\n          let $days := ("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")     \n          return fn:filter($days,$m)        \n      ".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.\n\n          let $m := map {\n                "Tuesday" : true(),\n                "Wednesday" : true(),\n                "Friday" : true(),\n                "Monday" : true(),\n                "Sunday" : false(),\n                "Saturday" : false() }\n          [Error is around here]let $days := ("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")     \n          return fn:filter($days,$m)        \n      '
xqhof22,Error: XPST0003: Unable to parse XPath: "deep-equal((           let $m := array {                 true(),                 true(),                 false(),                 true(),                 true(),                 false(),                 false() }           let $indices := (1 to 7)           return fn:filter($indices,$m)               ), (1, 2, 4, 5))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. deep-equal((           let $m := array {                 true(),                 true(),                 false(),                 true(),                 true(),                 false(),                 false() }           [Error is around here]let $indices := (1 to 7)           return fn:filter($indices,$m)               ), (1, 2, 4, 5))
static-context-1,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'element() with more than 1 argument is not supported.'
surrogates04,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
surrogates05,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
surrogates06,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
surrogates07,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
surrogates08,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
surrogates12,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
surrogates13,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
surrogates14,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
surrogates15,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
surrogates16,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
surrogates04a,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
surrogates05a,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
surrogates06a,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
surrogates07a,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
surrogates08a,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
surrogates12a,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
surrogates13a,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
surrogates14a,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
surrogates15a,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
surrogates16a,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
XML10-4ed-Excluded-char-1,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'InvalidCharacterError: The qualified name is not a valid Name or QName'
XML10-4ed-Excluded-char-1-new,InvalidCharacterError: InvalidCharacterError: The qualified name is not a valid Name or QName
XML11-1ed-Included-char-1,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'InvalidCharacterError: The qualified name is not a valid Name or QName'
XML11-1ed-Included-char-1-new,InvalidCharacterError: InvalidCharacterError: The qualified name is not a valid Name or QName
line-ending-Q001,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
line-ending-Q002,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
line-ending-Q003,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
line-ending-Q004,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
line-ending-Q005,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
line-ending-Q006,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
line-ending-Q007,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
line-ending-Q008,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
line-ending-Q009,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
line-ending-P002,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
XML11-c0-001,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
Catalog001,Error: XPST0003: Unable to parse XPath: "(         declare namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";         let $testsets := //fots:test-set/@file/doc(resolve-uri(., base-uri(..))),             $tests := $testsets//fots-test-case,             $environments := (//fots:environment | $testsets//fots:environment)[@name],             $refs := $testsets//fots:environment[@ref]             return $refs[not(@ref = $environments/@name)]       ) => empty()". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. (         declare [Error is around here]namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";         let $testsets := //fots:test-set/@file/doc(resolve-uri(., base-uri(..))),             $tests := $testsets//fots-test-case,             $environments := (//fots:environment | $testsets//fots:environment)[@name],             $refs := $testsets//fots:environment[@ref]             return $refs[not(@ref = $environments/@name)]       ) => empty()
Catalog003,Error: XPST0003: Unable to parse XPath: "(         declare namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";         let $testsets := //fots:test-set/@file/doc(resolve-uri(., base-uri(..)))         for $test in $testsets//fots:test-case[contains(test, "import schema")]         where empty($test/(fots:dependency | ../fots:dependency)[@type='feature' and @value="schemaImport"])          return $test       ) => empty()". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. (         declare [Error is around here]namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";         let $testsets := //fots:test-set/@file/doc(resolve-uri(., base-uri(..)))         for $test in $testsets//fots:test-case[contains(test, "import schema")]         where empty($test/(fots:dependency | ../fots:dependency)[@type='feature' and @value="schemaImport"])          return $test       ) => empty()
Catalog004,Error: XPST0003: Unable to parse XPath: "(         declare namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";         let $testsets := //fots:test-set/@file/doc(resolve-uri(., base-uri(..)))         for $schema in (.|$testsets)//fots:environment/fots:schema         let $targetNamespace := doc(resolve-uri($schema/@file, base-uri($schema)))/*/@targetNamespace         where not($schema/@uri eq $targetNamespace or (empty($targetNamespace) and string(@uri)=''))         return ($schema, <file>{base-uri($schema)}</file>)       ) => empty()". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. (         declare [Error is around here]namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";         let $testsets := //fots:test-set/@file/doc(resolve-uri(., base-uri(..)))         for $schema in (.|$testsets)//fots:environment/fots:schema         let $targetNamespace := doc(resolve-uri($schema/@file, base-uri($schema)))/*/@targetNamespace         where not($schema/@uri eq $targetNamespace or (empty($targetNamespace) and string(@uri)=''))         return ($schema, <file>{base-uri($schema)}</file>)       ) => empty()
Catalog005,Error: XPST0003: Unable to parse XPath: "(         declare namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";         (: ask whether a test is XQuery-only :)         declare function local:needs-xq($t as element(fots:test-case)) as xs:boolean {             let $spec := $t/fots:dependency[@type='spec'][1]             return exists($spec) and contains($spec/@value, 'XQ') and not(contains($spec/@value, 'XP'))                and not(starts-with($t/@name, 'fo-test-' (: special exemption for generated tests :)))         };         let $testsets := //fots:test-set/@file/doc(resolve-uri(., base-uri(..)))         let $nsenvs :=             for $t in ($testsets|.)             for $e in $t//fots:environment[@name]             where exists($e/fots:namespace)              return concat($t/*/@name, '~', $e/@name/string())         let $xq-testcases := $testsets//fots:test-case [local:needs-xq(.)]         for $tc in $xq-testcases [concat(/*/@name, '~', fots:environment/@ref) = $nsenvs or fots:environment[fots:namespace]]         return $tc/@name/string()       ) => empty()". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. (         declare [Error is around here]namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";         (: ask whether a test is XQuery-only :)         declare function local:needs-xq($t as element(fots:test-case)) as xs:boolean {             let $spec := $t/fots:dependency[@type='spec'][1]             return exists($spec) and contains($spec/@value, 'XQ') and not(contains($spec/@value, 'XP'))                and not(starts-with($t/@name, 'fo-test-' (: special exemption for generated tests :)))         };         let $testsets := //fots:test-set/@file/doc(resolve-uri(., base-uri(..)))         let $nsenvs :=             for $t in ($testsets|.)             for $e in $t//fots:environment[@name]             where exists($e/fots:namespace)              return concat($t/*/@name, '~', $e/@name/string())         let $xq-testcases := $testsets//fots:test-case [local:needs-xq(.)]         for $tc in $xq-testcases [concat(/*/@name, '~', fots:environment/@ref) = $nsenvs or fots:environment[fots:namespace]]         return $tc/@name/string()       ) => empty()
Catalog006,Error: XPST0003: Unable to parse XPath: "(         declare namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";         (: ask whether a test is XQuery-only :)         declare function local:needs-xq($t as element(fots:test-case)) as xs:boolean {             let $spec := $t/fots:dependency[@type='spec'][1]             return exists($spec) and contains($spec/@value, 'XQ') and not(contains($spec/@value, 'XP'))                and not(starts-with($t/@name, 'fo-test-' (: special exemption for generated tests :)))         };         let $testsets := //fots:test-set/@file/doc(resolve-uri(., base-uri(..)))         let $nsenvs :=             for $t in ($testsets|.)             for $e in $t//fots:environment             where exists($e/fots:decimal-format)              return $e/@name/string()         let $xq-testcases := $testsets//fots:test-case [local:needs-xq(.)]         for $tc in $xq-testcases [fots:environment/@ref = $nsenvs or fots:environment[fots:decimal-format]]         return $tc/@name/string()       ) => empty()". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. (         declare [Error is around here]namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";         (: ask whether a test is XQuery-only :)         declare function local:needs-xq($t as element(fots:test-case)) as xs:boolean {             let $spec := $t/fots:dependency[@type='spec'][1]             return exists($spec) and contains($spec/@value, 'XQ') and not(contains($spec/@value, 'XP'))                and not(starts-with($t/@name, 'fo-test-' (: special exemption for generated tests :)))         };         let $testsets := //fots:test-set/@file/doc(resolve-uri(., base-uri(..)))         let $nsenvs :=             for $t in ($testsets|.)             for $e in $t//fots:environment             where exists($e/fots:decimal-format)              return $e/@name/string()         let $xq-testcases := $testsets//fots:test-case [local:needs-xq(.)]         for $tc in $xq-testcases [fots:environment/@ref = $nsenvs or fots:environment[fots:decimal-format]]         return $tc/@name/string()       ) => empty()
Catalog007,Error: XPST0003: Unable to parse XPath: "(         xquery version "3.0";         (: output the non-unique test names. There should be none :)         declare namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";         let $testsets := //fots:test-set/@file/doc(resolve-uri(., base-uri(..)))         for $xq-testcase in $testsets//fots:test-case         let $testname := $xq-testcase/@name         group by $testname         where count($xq-testcase) gt 1         return ($testname || "(" || count($xq-testcase) || ")")       ) => empty()". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. (         xquery [Error is around here]version "3.0";         (: output the non-unique test names. There should be none :)         declare namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";         let $testsets := //fots:test-set/@file/doc(resolve-uri(., base-uri(..)))         for $xq-testcase in $testsets//fots:test-case         let $testname := $xq-testcase/@name         group by $testname         where count($xq-testcase) gt 1         return ($testname || "(" || count($xq-testcase) || ")")       ) => empty()
Catalog008,Error: XPST0003: Unable to parse XPath: "(         declare namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";          for $xq-testcase in //fots:test-set         let $testname := $xq-testcase/@name         let $testfile := $xq-testcase/@file/doc(resolve-uri(., base-uri(..)))         let $file-testname := $testfile/fots:test-set/@name         where $testname != $file-testname         return <out catalog-name="{string($testname)}" test-name="{string($file-testname)}"/>       ) => empty()". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. (         declare [Error is around here]namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";          for $xq-testcase in //fots:test-set         let $testname := $xq-testcase/@name         let $testfile := $xq-testcase/@file/doc(resolve-uri(., base-uri(..)))         let $file-testname := $testfile/fots:test-set/@name         where $testname != $file-testname         return <out catalog-name="{string($testname)}" test-name="{string($file-testname)}"/>       ) => empty()
Catalog009,Error: XPST0003: Unable to parse XPath: "(         xquery version "3.0";         declare namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";         let $testsets := //fots:test-set/@file/doc(resolve-uri(., base-uri(..)))         for $dependencyTS in $testsets//fots:dependency         let $name := $dependencyTS/@type         let $value := $dependencyTS/@value         group by $name, $value         order by $name, $value          return <dependency type='{$name}' value='{$value}' />        ) instance of element()*". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. (         xquery [Error is around here]version "3.0";         declare namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";         let $testsets := //fots:test-set/@file/doc(resolve-uri(., base-uri(..)))         for $dependencyTS in $testsets//fots:dependency         let $name := $dependencyTS/@type         let $value := $dependencyTS/@value         group by $name, $value         order by $name, $value          return <dependency type='{$name}' value='{$value}' />        ) instance of element()*
Catalog010,Error: XPST0003: Unable to parse XPath: "(         declare namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";         let $changes := doc('../changes.xml')//change/@id/string()         for $xq-test in //fots:test-set         let $testfile := $xq-test/@file/doc(resolve-uri(., base-uri(..)))         let $testset := $testfile/fots:test-set         let $testcases := $testset/fots:test-case         for $token in distinct-values((tokenize($testset/@covers-30, ' '), $testcases/@covers-30/tokenize(., ' '), tokenize($testset/@covers, ' '), $testcases/@covers/tokenize(., ' ')))         where not($token = $changes)         return <out test-set="{string($testset/@name)}" bad-covers-value="{$token}"/>       ) => empty()". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. (         declare [Error is around here]namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";         let $changes := doc('../changes.xml')//change/@id/string()         for $xq-test in //fots:test-set         let $testfile := $xq-test/@file/doc(resolve-uri(., base-uri(..)))         let $testset := $testfile/fots:test-set         let $testcases := $testset/fots:test-case         for $token in distinct-values((tokenize($testset/@covers-30, ' '), $testcases/@covers-30/tokenize(., ' '), tokenize($testset/@covers, ' '), $testcases/@covers/tokenize(., ' ')))         where not($token = $changes)         return <out test-set="{string($testset/@name)}" bad-covers-value="{$token}"/>       ) => empty()
Catalog011,Error: XPST0003: Unable to parse XPath: "     declare namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";     <r>{         let $changes := doc('../changes.xml')//spec[contains(@name, '31')]/change         let $changesid := $changes/@id/string()         let $testfiles := //fots:test-set/@file/doc(resolve-uri(., base-uri(..)))         let $testsets := $testfiles/fots:test-set         for $token in distinct-values($changesid)         let $relevant-testsets := $testsets[tokenize(@covers, ' ') = $token]         let $relevant-testcases := $testsets/fots:test-case[tokenize(@covers, ' ') = $token]         let $count := count($relevant-testsets/fots:test-case) + count($relevant-testcases)         where $count lt 5         return <out spec="{$changes[@id=$token]/../@name}" change="{$token}" tests="{$count}" names="{$relevant-testcases/@name}">         {$changes[@id=$token]/text()}         </out>      }</r>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.      declare namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";     <r>{         let $changes := doc('../changes.xml')//spec[contains(@name, '31')]/change         [Error is around here]let $changesid := $changes/@id/string()         let $testfiles := //fots:test-set/@file/doc(resolve-uri(., base-uri(..)))         let $testsets := $testfiles/fots:test-set         for $token in distinct-values($changesid)         let $relevant-testsets := $testsets[tokenize(@covers, ' ') = $token]         let $relevant-testcases := $testsets/fots:test-case[tokenize(@covers, ' ') = $token]         let $count := count($relevant-testsets/fots:test-case) + count($relevant-testcases)         where $count lt 5         return <out spec="{$changes[@id=$token]/../@name}" change="{$token}" tests="{$count}" names="{$relevant-testcases/@name}">         {$changes[@id=$token]/text()}         </out>      }</r>
Catalog012,Error: XPST0003: Unable to parse XPath: "(       declare namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";       let $testsets := //fots:test-set/@file/doc(resolve-uri(., base-uri(..)))       return $testsets//fots:test-case[.//fots:assert-xml[starts-with(., '<?xml')]]     ) => empty()". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. (       declare [Error is around here]namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";       let $testsets := //fots:test-set/@file/doc(resolve-uri(., base-uri(..)))       return $testsets//fots:test-case[.//fots:assert-xml[starts-with(., '<?xml')]]     ) => empty()
Catalog013,Error: XPST0003: Unable to parse XPath: "(       declare namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";       let $testsets := //fots:test-set/@file/doc(resolve-uri(., base-uri(..)))       return $testsets//fots:dependency[@type='spec']              [tokenize(normalize-space(@value), ' ')[not (. =                           ('XP20', 'XP20+', 'XP30', 'XP30+', 'XP31', 'XP31+',                             'XQ10', 'XQ10+', 'XQ30', 'XQ30+', 'XQ31', 'XQ31+',                            'XT30', 'XT30+'))]]/                            concat(../@name, ' => ', @value)     ) => empty()". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. (       declare [Error is around here]namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";       let $testsets := //fots:test-set/@file/doc(resolve-uri(., base-uri(..)))       return $testsets//fots:dependency[@type='spec']              [tokenize(normalize-space(@value), ' ')[not (. =                           ('XP20', 'XP20+', 'XP30', 'XP30+', 'XP31', 'XP31+',                             'XQ10', 'XQ10+', 'XQ30', 'XQ30+', 'XQ31', 'XQ31+',                            'XT30', 'XT30+'))]]/                            concat(../@name, ' => ', @value)     ) => empty()
Catalog014,Error: XPST0003: Unable to parse XPath: "(     declare namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";         let $testsets := //fots:test-set/@file/doc(resolve-uri(., base-uri(..)))         for $test in $testsets//fots:test-case         where not(exists($test/(@covers | ../@covers)))         where exists($test/((fots:dependency | ../fots:dependency)[@type='spec' and contains(@value, '31')]))         where not(starts-with($test/@name, 'fo-test-' (: special exemption for generated tests :)))         return <out test="{$test/@name}"/>       ) => empty()". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. (     declare [Error is around here]namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";         let $testsets := //fots:test-set/@file/doc(resolve-uri(., base-uri(..)))         for $test in $testsets//fots:test-case         where not(exists($test/(@covers | ../@covers)))         where exists($test/((fots:dependency | ../fots:dependency)[@type='spec' and contains(@value, '31')]))         where not(starts-with($test/@name, 'fo-test-' (: special exemption for generated tests :)))         return <out test="{$test/@name}"/>       ) => empty()
sudoku,Error: XPST0003: Unable to parse XPath: "         declare namespace fn = "sudoku";         declare variable $board as xs:integer+ :=          	( 1,0,0, 3,0,0, 6,0,0, 0,2,0, 5,0,0, 0,0,4, 0,0,9, 0,0,0,          	5,2,0, 0,0,0, 9,6,3, 0,0,0, 7,1,6, 0,0,0, 0,0,0, 0,0,0,          	0,8,0, 0,4,0, 9,0,0, 0,0,5, 3,0,7, 8,0,0, 4,0,6, 0,0,0,          	3,5,0, 0,0,0, 0,0,1);         declare variable $rowStarts as xs:integer+ := (1, 10, 19, 28, 37, 46, 55, 64,73);         declare variable $groups as xs:integer+ :=          	( 1,1,1, 2,2,2, 3,3,3, 1,1,1, 2,2,2, 3,3,3, 1,1,1, 2,2,2, 3,3,3, 4,4,4,          	5,5,5, 6,6,6, 4,4,4, 5,5,5, 6,6,6, 4,4,4, 5,5,5, 6,6,6, 7,7,7, 8,8,8,          	9,9,9, 7,7,7, 8,8,8, 9,9,9, 7,7,7, 8,8,8, 9,9,9 );         declare function fn:getRow ($board as xs:integer+, $index as xs:integer) as xs:integer+ {          	let $rowStart := floor(($index - 1) div 9) * 9          	return one-or-more($board[position() > $rowStart and position() <= $rowStart + 9])          };         declare function fn:getCol ($board as xs:integer+, $index as xs:integer) as xs:integer+ {          	let $gap := ($index - 1) mod 9,          	    $colIndexes := for $x in $rowStarts          	    		       return $x + $gap          	return one-or-more($board[position() = $colIndexes])          };         declare function fn:getGroup ($board as xs:integer+, $index as xs:integer) as xs:integer+ {          	let $group := $groups[$index]          	return one-or-more($board[for $x in position() return $groups[$x]= $group])          };         declare function fn:getAllowedValues ($board as xs:integer+, $index as xs:integer) as xs:integer* {          	let $existingValues := (fn:getRow($board, $index), fn:getCol($board, $index), fn:getGroup($board, $index))          	return for $x in (1 to 9) return if (not($x = $existingValues)) then $x else ()          };         declare function fn:tryValues($board as xs:integer+, $emptyCells as xs:integer+, $possibleValues as xs:integer+) as xs:integer* {          	let $index as xs:integer := $emptyCells[1],          	    $newBoard as xs:integer+ := ($board[position() <$index], $possibleValues[1], $board[position() > $index]),          	    $result as xs:integer* := fn:populateValues($newBoard, $emptyCells[position() != 1])          	return if (empty($result)) then if (count($possibleValues) > 1) then fn:tryValues($board, $emptyCells, one-or-more($possibleValues[position() != 1])) else () else $result          };         declare function fn:populateValues($board as xs:integer+, $emptyCells as xs:integer*) as xs:integer*{          	if (not(empty($emptyCells)))          	then let $index as xs:integer := exactly-one($emptyCells[1]),          			 $possibleValues as xs:integer* := distinct-values(fn:getAllowedValues($board, $index))          		 return if (count($possibleValues) > 1)          		        then fn:tryValues($board, one-or-more($emptyCells), one-or-more($possibleValues))          		        else if (count($possibleValues) = 1)          		        then let $newBoard as xs:integer+ :=($board[position() < $index],          		                   exactly-one($possibleValues[1]), $board[position() > $index])          		             return fn:populateValues($newBoard, $emptyCells[position() != 1])          		        else ()          	else $board          };         declare function fn:solveSudoku ($startBoard as xs:integer+) as xs:integer+{          	let $emptyCells as xs:integer* :=         			for $x in (1 to 81)          			return if ($startBoard[$x] = 0) then $x else (),          		$endBoard as xs:integer* :=fn:populateValues($startBoard,$emptyCells)          	return if (empty($endBoard)) then $startBoard else one-or-more($endBoard)         };         declare function fn:drawResult ($board as xs:integer+) as element(){          	<html><head><title>Sudoku - XSLT</title><style>table {{ border-collapse: collapse; border: 1px solid black; }} td {{ padding: 10px; }} .norm {{ border-left: 1px solid #CCC; border-top: 1px solid #CCC; }} .csep {{ border-left: 1px solid black; }} .rsep {{ border-top: 1px solid black; }}</style></head><body>{fn:drawBoard($board)}</body></html> };         declare function fn:drawBoard ($board as xs:integer+) as element(){          	<table>{for $i in 1 to 9 return          		<tr>{for $j at $p in 1 to 9          			  let $pos := (($i - 1) * 9) + $j          			  return <td class="{if ($p mod 3 = 1) then 'csep' else ('norm')} {if ($i mod 3 = 1) then 'rsep' else ('norm')}"> {$board[$pos]}</td>          			  }</tr> }</table>          };         fn:drawResult(fn:solveSudoku($board))       ". Expected " ", "(:", ":=", "\n", "\r", "\t", or "external" but "a" found.          declare namespace fn = "sudoku";         declare variable $board [Error is around here]as xs:integer+ :=          	( 1,0,0, 3,0,0, 6,0,0, 0,2,0, 5,0,0, 0,0,4, 0,0,9, 0,0,0,          	5,2,0, 0,0,0, 9,6,3, 0,0,0, 7,1,6, 0,0,0, 0,0,0, 0,0,0,          	0,8,0, 0,4,0, 9,0,0, 0,0,5, 3,0,7, 8,0,0, 4,0,6, 0,0,0,          	3,5,0, 0,0,0, 0,0,1);         declare variable $rowStarts as xs:integer+ := (1, 10, 19, 28, 37, 46, 55, 64,73);         declare variable $groups as xs:integer+ :=          	( 1,1,1, 2,2,2, 3,3,3, 1,1,1, 2,2,2, 3,3,3, 1,1,1, 2,2,2, 3,3,3, 4,4,4,          	5,5,5, 6,6,6, 4,4,4, 5,5,5, 6,6,6, 4,4,4, 5,5,5, 6,6,6, 7,7,7, 8,8,8,          	9,9,9, 7,7,7, 8,8,8, 9,9,9, 7,7,7, 8,8,8, 9,9,9 );         declare function fn:getRow ($board as xs:integer+, $index as xs:integer) as xs:integer+ {          	let $rowStart := floor(($index - 1) div 9) * 9          	return one-or-more($board[position() > $rowStart and position() <= $rowStart + 9])          };         declare function fn:getCol ($board as xs:integer+, $index as xs:integer) as xs:integer+ {          	let $gap := ($index - 1) mod 9,          	    $colIndexes := for $x in $rowStarts          	    		       return $x + $gap          	return one-or-more($board[position() = $colIndexes])          };         declare function fn:getGroup ($board as xs:integer+, $index as xs:integer) as xs:integer+ {          	let $group := $groups[$index]          	return one-or-more($board[for $x in position() return $groups[$x]= $group])          };         declare function fn:getAllowedValues ($board as xs:integer+, $index as xs:integer) as xs:integer* {          	let $existingValues := (fn:getRow($board, $index), fn:getCol($board, $index), fn:getGroup($board, $index))          	return for $x in (1 to 9) return if (not($x = $existingValues)) then $x else ()          };         declare function fn:tryValues($board as xs:integer+, $emptyCells as xs:integer+, $possibleValues as xs:integer+) as xs:integer* {          	let $index as xs:integer := $emptyCells[1],          	    $newBoard as xs:integer+ := ($board[position() <$index], $possibleValues[1], $board[position() > $index]),          	    $result as xs:integer* := fn:populateValues($newBoard, $emptyCells[position() != 1])          	return if (empty($result)) then if (count($possibleValues) > 1) then fn:tryValues($board, $emptyCells, one-or-more($possibleValues[position() != 1])) else () else $result          };         declare function fn:populateValues($board as xs:integer+, $emptyCells as xs:integer*) as xs:integer*{          	if (not(empty($emptyCells)))          	then let $index as xs:integer := exactly-one($emptyCells[1]),          			 $possibleValues as xs:integer* := distinct-values(fn:getAllowedValues($board, $index))          		 return if (count($possibleValues) > 1)          		        then fn:tryValues($board, one-or-more($emptyCells), one-or-more($possibleValues))          		        else if (count($possibleValues) = 1)          		        then let $newBoard as xs:integer+ :=($board[position() < $index],          		                   exactly-one($possibleValues[1]), $board[position() > $index])          		             return fn:populateValues($newBoard, $emptyCells[position() != 1])          		        else ()          	else $board          };         declare function fn:solveSudoku ($startBoard as xs:integer+) as xs:integer+{          	let $emptyCells as xs:integer* :=         			for $x in (1 to 81)          			return if ($startBoard[$x] = 0) then $x else (),          		$endBoard as xs:integer* :=fn:populateValues($startBoard,$emptyCells)          	return if (empty($endBoard)) then $startBoard else one-or-more($endBoard)         };         declare function fn:drawResult ($board as xs:integer+) as element(){          	<html><head><title>Sudoku - XSLT</title><style>table {{ border-collapse: collapse; border: 1px solid black; }} td {{ padding: 10px; }} .norm {{ border-left: 1px solid #CCC; border-top: 1px solid #CCC; }} .csep {{ border-left: 1px solid black; }} .rsep {{ border-top: 1px solid black; }}</style></head><body>{fn:drawBoard($board)}</body></html> };         declare function fn:drawBoard ($board as xs:integer+) as element(){          	<table>{for $i in 1 to 9 return          		<tr>{for $j at $p in 1 to 9          			  let $pos := (($i - 1) * 9) + $j          			  return <td class="{if ($p mod 3 = 1) then 'csep' else ('norm')} {if ($i mod 3 = 1) then 'rsep' else ('norm')}"> {$board[$pos]}</td>          			  }</tr> }</table>          };         fn:drawResult(fn:solveSudoku($board))
currencysvg,Error: XPST0003: Unable to parse XPath: "(: Name: currencysvg :) (: Description: Draw an SVG of currency exchange data :) (: Author: Nick Jones :) (: Date: 2008-10-30 :) (: Declare namespaces :) declare default element namespace "http://www.w3.org/2000/svg"; declare namespace msg="http://www.SDMX.org/resources/SDMXML/schemas/v1_0/message"; declare namespace frbny="http://www.newyorkfed.org/xml/schemas/FX/utility";  (: Currency to lookup :) declare variable $input-context := .;  (: A list of observations :) declare variable $obs := $input-context/msg:UtilityData/frbny:DataSet/frbny:Series/frbny:Obs;  (: Minimum/maximum/average exchange rates :) declare variable $values := $obs/frbny:OBS_VALUE/xs:decimal(.); declare variable $minValue := min($values); declare variable $maxValue := max($values); declare variable $avgValue := avg($values);   (: First/last dates :) declare variable $dates := $obs/frbny:TIME_PERIOD/xs:date(.); declare variable $firstDate := min($dates); declare variable $lastDate := max($dates);  (: Returns the change in exchange rate over a specified number of days :) declare function local:period-change($ob as element(frbny:Obs,xs:untyped),                                      $days as xs:positiveInteger) as xs:decimal {     let $previous := xs:decimal($ob/following-sibling::frbny:Obs[$days]/frbny:OBS_VALUE)     return xs:decimal($ob/frbny:OBS_VALUE - $previous) };   (: Converts an observation to an x,y coordinate pair :) declare function local:coordinate($ob as element(frbny:Obs,xs:untyped)) as xs:decimal+ {   (     xs:decimal((xs:date($ob/frbny:TIME_PERIOD) - $firstDate) div ($lastDate - $firstDate) * 1000)     ,     xs:decimal(1000 - ($ob/frbny:OBS_VALUE - $minValue) div ($maxValue - $minValue) * 1000)   ) };  (: Labels the largest falls and rises over a specified number of days :) declare function local:label-changes($days as xs:positiveInteger) as element(text,xs:anyType)+ {       let $sortedByChange:=            for $ob in $obs[position() <= last() - $days]           order by local:period-change($ob,$days) descending           return $ob       return         (           local:label-observation($sortedByChange[last()]/following-sibling::frbny:Obs[$days],concat('Largest ',$days,'-day rise'))           ,           local:label-observation($sortedByChange[1]/following-sibling::frbny:Obs[$days],concat('Largest ',$days,'-day fall'))         ) };  (: Labels an observation :) declare function local:label-observation($ob as element(frbny:Obs,xs:untyped),$label as xs:string) as element(text,xs:anyType) {       let $coord := local:coordinate($ob)       return         <text x="{round-half-to-even($coord[1], 4)}"                   y="{round-half-to-even($coord[2], 4)}"                   text-anchor="end"                   title="{concat($ob/frbny:TIME_PERIOD,' - ',$ob/frbny:OBS_VALUE)}">           {$label}         </text> };  <svg viewBox="-50,-50,1100,1100">    <!-- Border -->   <path stroke="black" fill="none" stroke-width="1" d="M0,0L1000,0L1000,1000L0,1000L0,0"/>    <!-- Title -->   <text x="500" y="-20" text-anchor="middle">{string($input-context/msg:UtilityData/msg:Header/msg:Name)}</text>    <!-- Generator -->   <text x="500" y="1040" text-anchor="middle">Generated by XQSharp</text>    <!-- Ranges -->   <text x="0" y="1020" text-anchor="middle">{$firstDate}</text>   <text x="1000" y="1020" text-anchor="middle">{$lastDate}</text>   <text x="0" y="0" text-anchor="end">{$maxValue}</text>   <text x="0" y="1000" text-anchor="end">{$minValue}</text>    <!-- Graph -->   <path stroke="red" fill="none" stroke-width="1">     {       attribute {"d"}       {         for $ob at $pos in $obs         let $coord := local:coordinate($ob)         return           concat(if($pos = 1) then "M" else "L",round-half-to-even($coord[1], 4),",",round-half-to-even($coord[2], 4))       }     }   </path>    <!-- Average -->   <path stroke="blue" fill="none" stroke-with="2" d="M0,{round-half-to-even(($maxValue - $avgValue) div ($maxValue - $minValue) * 1000, 4)}l1000,0"/>   <text x="0" y="{round-half-to-even(($maxValue - $avgValue) div ($maxValue - $minValue) * 1000, 4)}" text-anchor="end">Average</text>    {     (: Label largest changes over 1,5,90,365 days :)     for $days in (1,5,90,365)     return local:label-changes(xs:positiveInteger($days))   } </svg> ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. (: Name: currencysvg :) (: Description: Draw an SVG of currency exchange data :) (: Author: Nick Jones :) (: Date: 2008-10-30 :) (: Declare namespaces :) declare default element namespace "http://www.w3.org/2000/svg"; declare namespace msg="http://www.SDMX.org/resources/SDMXML/schemas/v1_0/message"; declare namespace frbny="http://www.newyorkfed.org/xml/schemas/FX/utility";  (: Currency to lookup :) declare variable $input-context := .;  (: A list of observations :) declare variable $obs := $input-context/msg:UtilityData/frbny:DataSet/frbny:Series/frbny:Obs;  (: Minimum/maximum/average exchange rates :) declare variable $values := $obs/frbny:OBS_VALUE/xs:decimal(.); declare variable $minValue := min($values); declare variable $maxValue := max($values); declare variable $avgValue := avg($values);   (: First/last dates :) declare variable $dates := $obs/frbny:TIME_PERIOD/xs:date(.); declare variable $firstDate := min($dates); declare variable $lastDate := max($dates);  (: Returns the change in exchange rate over a specified number of days :) declare function local:period-change($ob as element(frbny:Obs,xs:untyped),                                      $days as xs:positiveInteger) as xs:decimal {     let $previous := xs:decimal($ob/following-sibling::frbny:Obs[$days]/frbny:OBS_VALUE)     return xs:decimal($ob/frbny:OBS_VALUE - $previous) };   (: Converts an observation to an x,y coordinate pair :) declare function local:coordinate($ob as element(frbny:Obs,xs:untyped)) as xs:decimal+ {   (     xs:decimal((xs:date($ob/frbny:TIME_PERIOD) - $firstDate) div ($lastDate - $firstDate) * 1000)     ,     xs:decimal(1000 - ($ob/frbny:OBS_VALUE - $minValue) div ($maxValue - $minValue) * 1000)   ) };  (: Labels the largest falls and rises over a specified number of days :) declare function local:label-changes($days as xs:positiveInteger) as element(text,xs:anyType)+ {       let $sortedByChange:=            for $ob in $obs[position() <= last() - $days]           [Error is around here]order by local:period-change($ob,$days) descending           return $ob       return         (           local:label-observation($sortedByChange[last()]/following-sibling::frbny:Obs[$days],concat('Largest ',$days,'-day rise'))           ,           local:label-observation($sortedByChange[1]/following-sibling::frbny:Obs[$days],concat('Largest ',$days,'-day fall'))         ) };  (: Labels an observation :) declare function local:label-observation($ob as element(frbny:Obs,xs:untyped),$label as xs:string) as element(text,xs:anyType) {       let $coord := local:coordinate($ob)       return         <text x="{round-half-to-even($coord[1], 4)}"                   y="{round-half-to-even($coord[2], 4)}"                   text-anchor="end"                   title="{concat($ob/frbny:TIME_PERIOD,' - ',$ob/frbny:OBS_VALUE)}">           {$label}         </text> };  <svg viewBox="-50,-50,1100,1100">    <!-- Border -->   <path stroke="black" fill="none" stroke-width="1" d="M0,0L1000,0L1000,1000L0,1000L0,0"/>    <!-- Title -->   <text x="500" y="-20" text-anchor="middle">{string($input-context/msg:UtilityData/msg:Header/msg:Name)}</text>    <!-- Generator -->   <text x="500" y="1040" text-anchor="middle">Generated by XQSharp</text>    <!-- Ranges -->   <text x="0" y="1020" text-anchor="middle">{$firstDate}</text>   <text x="1000" y="1020" text-anchor="middle">{$lastDate}</text>   <text x="0" y="0" text-anchor="end">{$maxValue}</text>   <text x="0" y="1000" text-anchor="end">{$minValue}</text>    <!-- Graph -->   <path stroke="red" fill="none" stroke-width="1">     {       attribute {"d"}       {         for $ob at $pos in $obs         let $coord := local:coordinate($ob)         return           concat(if($pos = 1) then "M" else "L",round-half-to-even($coord[1], 4),",",round-half-to-even($coord[2], 4))       }     }   </path>    <!-- Average -->   <path stroke="blue" fill="none" stroke-with="2" d="M0,{round-half-to-even(($maxValue - $avgValue) div ($maxValue - $minValue) * 1000, 4)}l1000,0"/>   <text x="0" y="{round-half-to-even(($maxValue - $avgValue) div ($maxValue - $minValue) * 1000, 4)}" text-anchor="end">Average</text>    {     (: Label largest changes over 1,5,90,365 days :)     for $days in (1,5,90,365)     return local:label-changes(xs:positiveInteger($days))   } </svg>
raytracer,SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
functx-fn-adjust-date-to-timezone-1,Error: XPST0017: Function adjust-date-to-timezone with arity of 2 not registered. No similar functions found.
functx-fn-adjust-date-to-timezone-2,Error: XPST0017: Function adjust-date-to-timezone with arity of 2 not registered. No similar functions found.
functx-fn-adjust-date-to-timezone-3,Error: XPST0017: Function adjust-date-to-timezone with arity of 2 not registered. No similar functions found.
functx-fn-adjust-date-to-timezone-4,Error: XPST0017: Function adjust-date-to-timezone with arity of 2 not registered. No similar functions found.
functx-fn-adjust-date-to-timezone-all,Error: XPST0017: Function adjust-date-to-timezone with arity of 2 not registered. No similar functions found.
functx-fn-adjust-dateTime-to-timezone-1,Error: XPST0017: Function adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
functx-fn-adjust-dateTime-to-timezone-2,Error: XPST0017: Function adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
functx-fn-adjust-dateTime-to-timezone-3,Error: XPST0017: Function adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
functx-fn-adjust-dateTime-to-timezone-4,Error: XPST0017: Function adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
functx-fn-adjust-dateTime-to-timezone-5,Error: XPST0017: Function adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
functx-fn-adjust-dateTime-to-timezone-all,Error: XPST0017: Function adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
functx-fn-adjust-time-to-timezone-1,Error: XPST0017: Function adjust-time-to-timezone with arity of 2 not registered. No similar functions found.
functx-fn-adjust-time-to-timezone-2,Error: XPST0017: Function adjust-time-to-timezone with arity of 2 not registered. No similar functions found.
functx-fn-adjust-time-to-timezone-3,Error: XPST0017: Function adjust-time-to-timezone with arity of 2 not registered. No similar functions found.
functx-fn-adjust-time-to-timezone-4,Error: XPST0017: Function adjust-time-to-timezone with arity of 2 not registered. No similar functions found.
functx-fn-adjust-time-to-timezone-all,Error: XPST0017: Function adjust-time-to-timezone with arity of 2 not registered. No similar functions found.
functx-fn-avg-3,Error: FORG0006: items passed to fn:avg are not all numeric.
functx-fn-avg-all,Error: FORG0006: items passed to fn:avg are not all numeric.
functx-fn-base-uri-1,Error: XPST0017: Function base-uri with arity of 1 not registered. No similar functions found.
functx-fn-base-uri-2,Error: XPST0017: Function base-uri with arity of 1 not registered. No similar functions found.
functx-fn-base-uri-3,Error: XPST0017: Function base-uri with arity of 1 not registered. No similar functions found.
functx-fn-base-uri-all,Error: XPST0017: Function base-uri with arity of 1 not registered. No similar functions found.
functx-fn-codepoint-equal-1,Error: XPST0017: Function codepoint-equal with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}deep-equal (item()*, item()*)" or "Q{http://www.w3.org/2005/xpath-functions}deep-equal (item()*, item()*, xs:string)"?
functx-fn-codepoint-equal-2,Error: XPST0017: Function codepoint-equal with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}deep-equal (item()*, item()*)" or "Q{http://www.w3.org/2005/xpath-functions}deep-equal (item()*, item()*, xs:string)"?
functx-fn-codepoint-equal-3,Error: XPST0017: Function codepoint-equal with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}deep-equal (item()*, item()*)" or "Q{http://www.w3.org/2005/xpath-functions}deep-equal (item()*, item()*, xs:string)"?
functx-fn-codepoint-equal-all,Error: XPST0017: Function codepoint-equal with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}deep-equal (item()*, item()*)" or "Q{http://www.w3.org/2005/xpath-functions}deep-equal (item()*, item()*, xs:string)"?
functx-fn-codepoints-to-string-1,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
functx-fn-codepoints-to-string-2,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
functx-fn-codepoints-to-string-3,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
functx-fn-codepoints-to-string-all,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
functx-fn-count-3,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-fn-count-all,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-fn-data-1,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-fn-data-2,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-fn-data-3,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-fn-data-4,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-fn-data-5,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-fn-data-6,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-fn-data-all,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-fn-default-collation-1,Error: XPST0017: Function default-collation with arity of 0 not registered. No similar functions found.
functx-fn-distinct-values-1,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-fn-distinct-values-2,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-fn-distinct-values-3,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-fn-distinct-values-4,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-fn-distinct-values-5,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-fn-distinct-values-6,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-fn-distinct-values-all,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-fn-doc-available-1,Error: XPST0017: Function doc-available with arity of 1 not registered. No similar functions found.
functx-fn-encode-for-uri-1,Error: XPST0017: Function encode-for-uri with arity of 1 not registered. No similar functions found.
functx-fn-encode-for-uri-2,Error: XPST0017: Function encode-for-uri with arity of 1 not registered. No similar functions found.
functx-fn-encode-for-uri-all,Error: XPST0017: Function encode-for-uri with arity of 1 not registered. No similar functions found.
functx-fn-escape-html-uri-1,Error: XPST0017: Function escape-html-uri with arity of 1 not registered. No similar functions found.
functx-fn-escape-html-uri-2,Error: XPST0017: Function escape-html-uri with arity of 1 not registered. No similar functions found.
functx-fn-escape-html-uri-all,Error: XPST0017: Function escape-html-uri with arity of 1 not registered. No similar functions found.
functx-fn-index-of-1,Error: XPST0017: Function index-of with arity of 2 not registered. No similar functions found.
functx-fn-index-of-2,Error: XPST0017: Function index-of with arity of 2 not registered. No similar functions found.
functx-fn-index-of-3,Error: XPST0017: Function index-of with arity of 2 not registered. No similar functions found.
functx-fn-index-of-4,Error: XPST0017: Function index-of with arity of 2 not registered. No similar functions found.
functx-fn-index-of-5,Error: XPST0017: Function index-of with arity of 2 not registered. No similar functions found.
functx-fn-index-of-6,Error: XPST0017: Function index-of with arity of 2 not registered. No similar functions found.
functx-fn-index-of-7,Error: XPST0017: Function index-of with arity of 2 not registered. No similar functions found.
functx-fn-index-of-all,Error: XPST0017: Function index-of with arity of 2 not registered. No similar functions found.
functx-fn-iri-to-uri-1,Error: XPST0017: Function iri-to-uri with arity of 1 not registered. No similar functions found.
functx-fn-lang-1,Error: XPST0017: Function lang with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}long (xs:anyAtomicType?)"?
functx-fn-lang-2,Error: XPST0017: Function lang with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}long (xs:anyAtomicType?)"?
functx-fn-lang-3,Error: XPST0017: Function lang with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}long (xs:anyAtomicType?)"?
functx-fn-lang-4,Error: XPST0017: Function lang with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}long (xs:anyAtomicType?)"?
functx-fn-lang-5,Error: XPST0017: Function lang with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}long (xs:anyAtomicType?)"?
functx-fn-lang-6,Error: XPST0017: Function lang with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}long (xs:anyAtomicType?)"?
functx-fn-lang-all,Error: XPST0017: Function lang with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}long (xs:anyAtomicType?)"?
functx-fn-matches-1,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-fn-matches-2,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-fn-matches-3,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-fn-matches-4,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-fn-matches-5,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-fn-matches-6,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-fn-matches-7,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-fn-matches-8,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-fn-matches-9,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-fn-matches-10,Error: XPST0017: Function matches with arity of 3 not registered. No similar functions found.
functx-fn-matches-11,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-fn-matches-12,Error: XPST0017: Function matches with arity of 3 not registered. No similar functions found.
functx-fn-matches-13,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-fn-matches-14,Error: XPST0017: Function matches with arity of 3 not registered. No similar functions found.
functx-fn-matches-15,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-fn-matches-16,Error: XPST0017: Function matches with arity of 3 not registered. No similar functions found.
functx-fn-matches-17,Error: XPST0017: Function matches with arity of 3 not registered. No similar functions found.
functx-fn-matches-18,Error: XPST0017: Function matches with arity of 3 not registered. No similar functions found.
functx-fn-matches-all,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-fn-namespace-uri-for-prefix-1,Error: XPST0017: Function namespace-uri-for-prefix with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}namespace-uri-from-QName (xs:QName?)", "Q{http://www.w3.org/2005/xpath-functions}namespace-uri (node())" or "Q{http://www.w3.org/2005/xpath-functions}namespace-uri ()"?
functx-fn-namespace-uri-for-prefix-2,Error: XPST0017: Function namespace-uri-for-prefix with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}namespace-uri-from-QName (xs:QName?)", "Q{http://www.w3.org/2005/xpath-functions}namespace-uri (node())" or "Q{http://www.w3.org/2005/xpath-functions}namespace-uri ()"?
functx-fn-namespace-uri-for-prefix-3,Error: XPST0017: Function namespace-uri-for-prefix with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}namespace-uri-from-QName (xs:QName?)", "Q{http://www.w3.org/2005/xpath-functions}namespace-uri (node())" or "Q{http://www.w3.org/2005/xpath-functions}namespace-uri ()"?
functx-fn-namespace-uri-for-prefix-4,Error: XPST0017: Function namespace-uri-for-prefix with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}namespace-uri-from-QName (xs:QName?)", "Q{http://www.w3.org/2005/xpath-functions}namespace-uri (node())" or "Q{http://www.w3.org/2005/xpath-functions}namespace-uri ()"?
functx-fn-namespace-uri-for-prefix-all,Error: XPST0017: Function namespace-uri-for-prefix with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}namespace-uri-from-QName (xs:QName?)", "Q{http://www.w3.org/2005/xpath-functions}namespace-uri (node())" or "Q{http://www.w3.org/2005/xpath-functions}namespace-uri ()"?
functx-fn-nilled-1,Error: XPST0017: Function nilled with arity of 1 not registered. No similar functions found.
functx-fn-nilled-2,Error: XPST0017: Function nilled with arity of 1 not registered. No similar functions found.
functx-fn-nilled-3,Error: XPST0017: Function nilled with arity of 1 not registered. No similar functions found.
functx-fn-nilled-4,Error: XPST0017: Function nilled with arity of 1 not registered. No similar functions found.
functx-fn-nilled-all,Error: XPST0017: Function nilled with arity of 1 not registered. No similar functions found.
functx-fn-normalize-unicode-1,Error: XPST0017: Function normalize-unicode with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}normalize-space (xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}normalize-space ()" or "Q{http://www.w3.org/2001/XMLSchema}normalizedString (xs:anyAtomicType?)"?
functx-fn-normalize-unicode-2,Error: XPST0017: Function normalize-unicode with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}normalize-space (xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}normalize-space ()" or "Q{http://www.w3.org/2001/XMLSchema}normalizedString (xs:anyAtomicType?)"?
functx-fn-normalize-unicode-all,Error: XPST0017: Function normalize-unicode with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}normalize-space (xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}normalize-space ()" or "Q{http://www.w3.org/2001/XMLSchema}normalizedString (xs:anyAtomicType?)"?
functx-fn-replace-1,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-2,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-3,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-4,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-5,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-6,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-7,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-8,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-9,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-10,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-11,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-12,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-13,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-14,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-15,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-16,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-17,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-18,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-19,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-all,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-resolve-QName-1,Error: XPST0017: Function resolve-QName with arity of 2 not registered. No similar functions found.
functx-fn-resolve-QName-2,Error: XPST0017: Function resolve-QName with arity of 2 not registered. No similar functions found.
functx-fn-resolve-QName-3,Error: XPST0017: Function resolve-QName with arity of 2 not registered. No similar functions found.
functx-fn-resolve-QName-all,Error: XPST0017: Function resolve-QName with arity of 2 not registered. No similar functions found.
functx-fn-resolve-uri-1,Error: XPST0017: Function resolve-uri with arity of 2 not registered. No similar functions found.
functx-fn-resolve-uri-2,Error: XPST0017: Function resolve-uri with arity of 2 not registered. No similar functions found.
functx-fn-resolve-uri-3,Error: XPST0017: Function resolve-uri with arity of 2 not registered. No similar functions found.
functx-fn-resolve-uri-4,AssertionError: Expected executing the XPath "(resolve-uri( 'http://datypic.com', '../base'))" to resolve to one of the expected results, but got Error: XPST0017: Function resolve-uri with arity of 2 not registered. No similar functions found., AssertionError: expected [Function] to throw error including 'FORG0002' but got 'XPST0017: Function resolve-uri with arity of 2 not registered. No similar functions found.'.
functx-fn-resolve-uri-5,AssertionError: Expected executing the XPath "(resolve-uri( '', 'http://datypic.com'))" to resolve to one of the expected results, but got Error: XPST0017: Function resolve-uri with arity of 2 not registered. No similar functions found., Error: XPST0017: Function resolve-uri with arity of 2 not registered. No similar functions found..
functx-fn-resolve-uri-all,Error: XPST0017: Function resolve-uri with arity of 2 not registered. No similar functions found.
functx-fn-root-1,Error: XPST0017: Function root with arity of 1 not registered. No similar functions found.
functx-fn-root-2,Error: XPST0017: Function root with arity of 1 not registered. No similar functions found.
functx-fn-root-all,Error: XPST0003: Unable to parse XPath: "          let $in-xml := <a><x>123</x></a>           return document{(root( (/) //item[1]), root($in-xml/x))}       ". Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "{" found.           let $in-xml := <a><x>123</x></a>           return document[Error is around here]{(root( (/) //item[1]), root($in-xml/x))}
functx-fn-string-to-codepoints-1,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
functx-fn-string-to-codepoints-2,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
functx-fn-string-to-codepoints-3,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
functx-fn-string-to-codepoints-all,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
functx-fn-sum-3,Error: FORG0006: items passed to fn:sum are not all numeric.
functx-fn-sum-all,Error: FORG0006: items passed to fn:sum are not all numeric.
functx-fn-translate-1,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
functx-fn-translate-2,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
functx-fn-translate-3,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
functx-fn-translate-4,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
functx-fn-translate-5,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
functx-fn-translate-6,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
functx-fn-translate-7,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
functx-fn-translate-all,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
functx-functx-add-attributes-1,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";             declare namespace new = "http://new";             (:~                 : Adds attributes to XML elements :                 : @author Priscilla Walmsley, Datypic                 : @version 1.0                 : @see http://www.xqueryfunctions.com/xq/functx_add-attributes.html                 : @param $elements the element(s) to which you wish to add the attribute                 : @param $attrNames the name(s) of the attribute(s) to add                 : @param $attrValues the value(s) of the attribute(s) to add :)             declare function functx:add-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? {                 for $element in $elements return element { node-name($element)} {                    for $attrName at $seq in $attrNames return                                          if ($element/@*[node-name(.) = $attrName]) then () else attribute {$attrName} {$attrValues[$seq]}, $element/@*, $element/node() }              } ;             let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml>              return (functx:add-attributes( $in-xml/a, xs:QName('att1'), 1))       ". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";             declare namespace new = "http://new";             (:~                 : Adds attributes to XML elements :                 : @author Priscilla Walmsley, Datypic                 : @version 1.0                 : @see http://www.xqueryfunctions.com/xq/functx_add-attributes.html                 : @param $elements the element(s) to which you wish to add the attribute                 : @param $attrNames the name(s) of the attribute(s) to add                 : @param $attrValues the value(s) of the attribute(s) to add :)             declare function functx:add-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? {                 for $element in $elements return element [Error is around here]{ node-name($element)} {                    for $attrName at $seq in $attrNames return                                          if ($element/@*[node-name(.) = $attrName]) then () else attribute {$attrName} {$attrValues[$seq]}, $element/@*, $element/node() }              } ;             let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml>              return (functx:add-attributes( $in-xml/a, xs:QName('att1'), 1))
functx-functx-add-attributes-2,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";          (:~              : Adds attributes to XML elements :              : @author Priscilla Walmsley, Datypic              : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-attributes.html              : @param $elements the element(s) to which you wish to add the attribute              : @param $attrNames the name(s) of the attribute(s) to add              : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? {              for $element in $elements              return element { node-name($element)} {                 for $attrName at $seq in $attrNames                 return if ($element/@*[node-name(.) = $attrName]) then () else attribute {$attrName} {$attrValues[$seq]}, $element/@*, $element/node() }           } ;          let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml>           return (functx:add-attributes( $in-xml/a, (xs:QName('att1'),xs:QName('att2')), (1,2)))       ". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";          (:~              : Adds attributes to XML elements :              : @author Priscilla Walmsley, Datypic              : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-attributes.html              : @param $elements the element(s) to which you wish to add the attribute              : @param $attrNames the name(s) of the attribute(s) to add              : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? {              for $element in $elements              return element [Error is around here]{ node-name($element)} {                 for $attrName at $seq in $attrNames                 return if ($element/@*[node-name(.) = $attrName]) then () else attribute {$attrName} {$attrValues[$seq]}, $element/@*, $element/node() }           } ;          let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml>           return (functx:add-attributes( $in-xml/a, (xs:QName('att1'),xs:QName('att2')), (1,2)))
functx-functx-add-attributes-3,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";          (:~              : Adds attributes to XML elements :              : @author Priscilla Walmsley, Datypic              : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-attributes.html              : @param $elements the element(s) to which you wish to add the attribute              : @param $attrNames the name(s) of the attribute(s) to add              : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? {              for $element in $elements              return element { node-name($element)} {                 for $attrName at $seq in $attrNames                 return if ($element/@*[node-name(.) = $attrName]) then () else attribute {$attrName} {$attrValues[$seq]}, $element/@*, $element/node() }           } ;          let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml>           return (functx:add-attributes( $in-xml/b, (xs:QName('att1'),xs:QName('att2')), (1,2)))       ". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";          (:~              : Adds attributes to XML elements :              : @author Priscilla Walmsley, Datypic              : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-attributes.html              : @param $elements the element(s) to which you wish to add the attribute              : @param $attrNames the name(s) of the attribute(s) to add              : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? {              for $element in $elements              return element [Error is around here]{ node-name($element)} {                 for $attrName at $seq in $attrNames                 return if ($element/@*[node-name(.) = $attrName]) then () else attribute {$attrName} {$attrValues[$seq]}, $element/@*, $element/node() }           } ;          let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml>           return (functx:add-attributes( $in-xml/b, (xs:QName('att1'),xs:QName('att2')), (1,2)))
functx-functx-add-attributes-4,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? {              for $element in $elements return element { node-name($element)} {                 for $attrName at $seq in $attrNames                 return if ($element/@*[node-name(.) = $attrName]) then () else attribute {$attrName} {$attrValues[$seq]}, $element/@*, $element/node() }           } ;          let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml>           return (functx:add-attributes( $in-xml/a, xs:QName('new:att1'), 1))       ". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? {              for $element in $elements return element [Error is around here]{ node-name($element)} {                 for $attrName at $seq in $attrNames                 return if ($element/@*[node-name(.) = $attrName]) then () else attribute {$attrName} {$attrValues[$seq]}, $element/@*, $element/node() }           } ;          let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml>           return (functx:add-attributes( $in-xml/a, xs:QName('new:att1'), 1))
functx-functx-add-attributes-5,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? {              for $element in $elements              return element { node-name($element)} {                 for $attrName at $seq in $attrNames                 return if ($element/@*[node-name(.) = $attrName]) then () else attribute {$attrName} {$attrValues[$seq]}, $element/@*, $element/node() }              } ;          let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml>           return (functx:add-attributes( $in-xml/a, QName('http://new','new:att1'), 1))       ". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? {              for $element in $elements              return element [Error is around here]{ node-name($element)} {                 for $attrName at $seq in $attrNames                 return if ($element/@*[node-name(.) = $attrName]) then () else attribute {$attrName} {$attrValues[$seq]}, $element/@*, $element/node() }              } ;          let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml>           return (functx:add-attributes( $in-xml/a, QName('http://new','new:att1'), 1))
functx-functx-add-attributes-all,Error: XPST0003: Unable to parse XPath: "          declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";          (:~              : Adds attributes to XML elements :              : @author Priscilla Walmsley, Datypic              : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-attributes.html              : @param $elements the element(s) to which you wish to add the attribute              : @param $attrNames the name(s) of the attribute(s) to add              : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? {              for $element in $elements              return element { node-name($element)} {                 for $attrName at $seq in $attrNames                 return if ($element/@*[node-name(.) = $attrName]) then () else attribute {$attrName} {$attrValues[$seq]}, $element/@*, $element/node() }           } ;          let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml>           return (functx:add-attributes( $in-xml/a, xs:QName('att1'), 1),                    functx:add-attributes( $in-xml/a, (xs:QName('att1'),xs:QName('att2')), (1,2)),                    functx:add-attributes( $in-xml/b, (xs:QName('att1'),xs:QName('att2')), (1,2)),                    functx:add-attributes( $in-xml/a, xs:QName('new:att1'), 1),                    functx:add-attributes( $in-xml/a, QName('http://new','new:att1'), 1))       ". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.           declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";          (:~              : Adds attributes to XML elements :              : @author Priscilla Walmsley, Datypic              : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-attributes.html              : @param $elements the element(s) to which you wish to add the attribute              : @param $attrNames the name(s) of the attribute(s) to add              : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? {              for $element in $elements              return element [Error is around here]{ node-name($element)} {                 for $attrName at $seq in $attrNames                 return if ($element/@*[node-name(.) = $attrName]) then () else attribute {$attrName} {$attrValues[$seq]}, $element/@*, $element/node() }           } ;          let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml>           return (functx:add-attributes( $in-xml/a, xs:QName('att1'), 1),                    functx:add-attributes( $in-xml/a, (xs:QName('att1'),xs:QName('att2')), (1,2)),                    functx:add-attributes( $in-xml/b, (xs:QName('att1'),xs:QName('att2')), (1,2)),                    functx:add-attributes( $in-xml/a, xs:QName('new:att1'), 1),                    functx:add-attributes( $in-xml/a, QName('http://new','new:att1'), 1))
functx-functx-add-months-1,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-functx-add-months-2,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-functx-add-months-3,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-functx-add-months-all,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-functx-add-or-update-attributes-1,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-or-update-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-or-update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return attribute {$attrName} {$attrValues[$seq]}, $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml> return (functx:add-or-update-attributes( $in-xml/a, xs:QName('att1'), 1))". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-or-update-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-or-update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element [Error is around here]{ node-name($element)} { for $attrName at $seq in $attrNames return attribute {$attrName} {$attrValues[$seq]}, $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml> return (functx:add-or-update-attributes( $in-xml/a, xs:QName('att1'), 1))
functx-functx-add-or-update-attributes-2,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-or-update-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-or-update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return attribute {$attrName} {$attrValues[$seq]}, $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml> return (functx:add-or-update-attributes( $in-xml/a, (xs:QName('att1'),xs:QName('att2')), (1,2)))". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-or-update-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-or-update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element [Error is around here]{ node-name($element)} { for $attrName at $seq in $attrNames return attribute {$attrName} {$attrValues[$seq]}, $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml> return (functx:add-or-update-attributes( $in-xml/a, (xs:QName('att1'),xs:QName('att2')), (1,2)))
functx-functx-add-or-update-attributes-3,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-or-update-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-or-update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return attribute {$attrName} {$attrValues[$seq]}, $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml> return (functx:add-or-update-attributes( $in-xml/b, (xs:QName('att1'),xs:QName('att2')), (1,2)))". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-or-update-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-or-update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element [Error is around here]{ node-name($element)} { for $attrName at $seq in $attrNames return attribute {$attrName} {$attrValues[$seq]}, $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml> return (functx:add-or-update-attributes( $in-xml/b, (xs:QName('att1'),xs:QName('att2')), (1,2)))
functx-functx-add-or-update-attributes-4,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-or-update-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-or-update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return attribute {$attrName} {$attrValues[$seq]}, $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml> return (functx:add-or-update-attributes( $in-xml/a, xs:QName('new:att1'), 1))". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-or-update-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-or-update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element [Error is around here]{ node-name($element)} { for $attrName at $seq in $attrNames return attribute {$attrName} {$attrValues[$seq]}, $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml> return (functx:add-or-update-attributes( $in-xml/a, xs:QName('new:att1'), 1))
functx-functx-add-or-update-attributes-5,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-or-update-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-or-update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return attribute {$attrName} {$attrValues[$seq]}, $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml> return (functx:add-or-update-attributes( $in-xml/a, QName('http://new','new:att1'), 1))". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-or-update-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-or-update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element [Error is around here]{ node-name($element)} { for $attrName at $seq in $attrNames return attribute {$attrName} {$attrValues[$seq]}, $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml> return (functx:add-or-update-attributes( $in-xml/a, QName('http://new','new:att1'), 1))
functx-functx-add-or-update-attributes-all,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-or-update-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-or-update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return attribute {$attrName} {$attrValues[$seq]}, $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml> return (functx:add-or-update-attributes( $in-xml/a, xs:QName('att1'), 1), functx:add-or-update-attributes( $in-xml/a, (xs:QName('att1'),xs:QName('att2')), (1,2)), functx:add-or-update-attributes( $in-xml/b, (xs:QName('att1'),xs:QName('att2')), (1,2)), functx:add-or-update-attributes( $in-xml/a, xs:QName('new:att1'), 1), functx:add-or-update-attributes( $in-xml/a, QName('http://new','new:att1'), 1))". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-or-update-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-or-update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element [Error is around here]{ node-name($element)} { for $attrName at $seq in $attrNames return attribute {$attrName} {$attrValues[$seq]}, $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml> return (functx:add-or-update-attributes( $in-xml/a, xs:QName('att1'), 1), functx:add-or-update-attributes( $in-xml/a, (xs:QName('att1'),xs:QName('att2')), (1,2)), functx:add-or-update-attributes( $in-xml/b, (xs:QName('att1'),xs:QName('att2')), (1,2)), functx:add-or-update-attributes( $in-xml/a, xs:QName('new:att1'), 1), functx:add-or-update-attributes( $in-xml/a, QName('http://new','new:att1'), 1))
functx-functx-are-distinct-values-1,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-are-distinct-values-2,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-are-distinct-values-3,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-are-distinct-values-all,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-camel-case-to-words-1,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-camel-case-to-words-2,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-camel-case-to-words-all,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-change-element-names-deep-1,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";          declare namespace dty = "http://datypic.com";                     (:~ : Changes the names of elements in an XML fragment : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-names-deep.html : @param $nodes the element(s) to change : @param $oldNames the sequence of names to change from : @param $newNames the sequence of names to change to :)          declare function functx:change-element-names-deep ( $nodes as node()* , $oldNames as xs:QName* , $newNames as xs:QName* ) as node()* { if (count($oldNames) != count($newNames)) then error(xs:QName('functx:Different_number_of_names')) else for $node in $nodes return if ($node instance of element()) then element {functx:if-empty ($newNames[index-of($oldNames, node-name($node))], node-name($node)) } {$node/@*, functx:change-element-names-deep($node/node(), $oldNames, $newNames)} else if ($node instance of document-node()) then functx:change-element-names-deep($node/node(), $oldNames, $newNames) else $node } ;                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     let $in-xml-1 := <in-xml> <a> <b>b</b> <c>c</c> </a> </in-xml> return let $in-xml-2 := <in-xml xmlns:dty="http://datypic.com"> <a> <dty:b>b</dty:b> <c>c</c> </a> </in-xml> return (functx:change-element-names-deep( $in-xml-1, xs:QName('b'), xs:QName('y')))". Expected "!", "!=", "(", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "else", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. declare namespace functx = "http://www.example.com/";          declare namespace dty = "http://datypic.com";                     (:~ : Changes the names of elements in an XML fragment : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-names-deep.html : @param $nodes the element(s) to change : @param $oldNames the sequence of names to change from : @param $newNames the sequence of names to change to :)          declare function functx:change-element-names-deep ( $nodes as node()* , $oldNames as xs:QName* , $newNames as xs:QName* ) as node()* { if (count($oldNames) != count($newNames)) then error(xs:QName('functx:Different_number_of_names')) else for $node in $nodes return if ($node instance of element()) then element [Error is around here]{functx:if-empty ($newNames[index-of($oldNames, node-name($node))], node-name($node)) } {$node/@*, functx:change-element-names-deep($node/node(), $oldNames, $newNames)} else if ($node instance of document-node()) then functx:change-element-names-deep($node/node(), $oldNames, $newNames) else $node } ;                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     let $in-xml-1 := <in-xml> <a> <b>b</b> <c>c</c> </a> </in-xml> return let $in-xml-2 := <in-xml xmlns:dty="http://datypic.com"> <a> <dty:b>b</dty:b> <c>c</c> </a> </in-xml> return (functx:change-element-names-deep( $in-xml-1, xs:QName('b'), xs:QName('y')))
functx-functx-change-element-names-deep-2,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";          declare namespace dty = "http://datypic.com";                     (:~ : Changes the names of elements in an XML fragment : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-names-deep.html : @param $nodes the element(s) to change : @param $oldNames the sequence of names to change from : @param $newNames the sequence of names to change to :)          declare function functx:change-element-names-deep ( $nodes as node()* , $oldNames as xs:QName* , $newNames as xs:QName* ) as node()* { if (count($oldNames) != count($newNames)) then error(xs:QName('functx:Different_number_of_names')) else for $node in $nodes return if ($node instance of element()) then element {functx:if-empty ($newNames[index-of($oldNames, node-name($node))], node-name($node)) } {$node/@*, functx:change-element-names-deep($node/node(), $oldNames, $newNames)} else if ($node instance of document-node()) then functx:change-element-names-deep($node/node(), $oldNames, $newNames) else $node } ;                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     let $in-xml-1 := <in-xml> <a> <b>b</b> <c>c</c> </a> </in-xml> return let $in-xml-2 := <in-xml xmlns:dty="http://datypic.com"> <a> <dty:b>b</dty:b> <c>c</c> </a> </in-xml> return (functx:change-element-names-deep( $in-xml-1, (xs:QName('a'), xs:QName('b'),xs:QName('c')), (xs:QName('x'), xs:QName('y'),xs:QName('z'))))". Expected "!", "!=", "(", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "else", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. declare namespace functx = "http://www.example.com/";          declare namespace dty = "http://datypic.com";                     (:~ : Changes the names of elements in an XML fragment : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-names-deep.html : @param $nodes the element(s) to change : @param $oldNames the sequence of names to change from : @param $newNames the sequence of names to change to :)          declare function functx:change-element-names-deep ( $nodes as node()* , $oldNames as xs:QName* , $newNames as xs:QName* ) as node()* { if (count($oldNames) != count($newNames)) then error(xs:QName('functx:Different_number_of_names')) else for $node in $nodes return if ($node instance of element()) then element [Error is around here]{functx:if-empty ($newNames[index-of($oldNames, node-name($node))], node-name($node)) } {$node/@*, functx:change-element-names-deep($node/node(), $oldNames, $newNames)} else if ($node instance of document-node()) then functx:change-element-names-deep($node/node(), $oldNames, $newNames) else $node } ;                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     let $in-xml-1 := <in-xml> <a> <b>b</b> <c>c</c> </a> </in-xml> return let $in-xml-2 := <in-xml xmlns:dty="http://datypic.com"> <a> <dty:b>b</dty:b> <c>c</c> </a> </in-xml> return (functx:change-element-names-deep( $in-xml-1, (xs:QName('a'), xs:QName('b'),xs:QName('c')), (xs:QName('x'), xs:QName('y'),xs:QName('z'))))
functx-functx-change-element-names-deep-3,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";          declare namespace dty = "http://datypic.com";                     (:~ : Changes the names of elements in an XML fragment : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-names-deep.html : @param $nodes the element(s) to change : @param $oldNames the sequence of names to change from : @param $newNames the sequence of names to change to :)          declare function functx:change-element-names-deep ( $nodes as node()* , $oldNames as xs:QName* , $newNames as xs:QName* ) as node()* { if (count($oldNames) != count($newNames)) then error(xs:QName('functx:Different_number_of_names')) else for $node in $nodes return if ($node instance of element()) then element {functx:if-empty ($newNames[index-of($oldNames, node-name($node))], node-name($node)) } {$node/@*, functx:change-element-names-deep($node/node(), $oldNames, $newNames)} else if ($node instance of document-node()) then functx:change-element-names-deep($node/node(), $oldNames, $newNames) else $node } ;                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     let $in-xml-1 := <in-xml> <a> <b>b</b> <c>c</c> </a> </in-xml> return let $in-xml-2 := <in-xml xmlns:dty="http://datypic.com"> <a> <dty:b>b</dty:b> <c>c</c> </a> </in-xml> return (functx:change-element-names-deep( $in-xml-2, (xs:QName('dty:b'),xs:QName('c')), (xs:QName('q'), QName('http://new','new:c'))))". Expected "!", "!=", "(", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "else", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. declare namespace functx = "http://www.example.com/";          declare namespace dty = "http://datypic.com";                     (:~ : Changes the names of elements in an XML fragment : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-names-deep.html : @param $nodes the element(s) to change : @param $oldNames the sequence of names to change from : @param $newNames the sequence of names to change to :)          declare function functx:change-element-names-deep ( $nodes as node()* , $oldNames as xs:QName* , $newNames as xs:QName* ) as node()* { if (count($oldNames) != count($newNames)) then error(xs:QName('functx:Different_number_of_names')) else for $node in $nodes return if ($node instance of element()) then element [Error is around here]{functx:if-empty ($newNames[index-of($oldNames, node-name($node))], node-name($node)) } {$node/@*, functx:change-element-names-deep($node/node(), $oldNames, $newNames)} else if ($node instance of document-node()) then functx:change-element-names-deep($node/node(), $oldNames, $newNames) else $node } ;                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     let $in-xml-1 := <in-xml> <a> <b>b</b> <c>c</c> </a> </in-xml> return let $in-xml-2 := <in-xml xmlns:dty="http://datypic.com"> <a> <dty:b>b</dty:b> <c>c</c> </a> </in-xml> return (functx:change-element-names-deep( $in-xml-2, (xs:QName('dty:b'),xs:QName('c')), (xs:QName('q'), QName('http://new','new:c'))))
functx-functx-change-element-names-deep-all,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";          declare namespace dty = "http://datypic.com";                     (:~ : Changes the names of elements in an XML fragment : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-names-deep.html : @param $nodes the element(s) to change : @param $oldNames the sequence of names to change from : @param $newNames the sequence of names to change to :)          declare function functx:change-element-names-deep ( $nodes as node()* , $oldNames as xs:QName* , $newNames as xs:QName* ) as node()* { if (count($oldNames) != count($newNames)) then error(xs:QName('functx:Different_number_of_names')) else for $node in $nodes return if ($node instance of element()) then element {functx:if-empty ($newNames[index-of($oldNames, node-name($node))], node-name($node)) } {$node/@*, functx:change-element-names-deep($node/node(), $oldNames, $newNames)} else if ($node instance of document-node()) then functx:change-element-names-deep($node/node(), $oldNames, $newNames) else $node } ;                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     let $in-xml-1 := <in-xml> <a> <b>b</b> <c>c</c> </a> </in-xml> return let $in-xml-2 := <in-xml xmlns:dty="http://datypic.com"> <a> <dty:b>b</dty:b> <c>c</c> </a> </in-xml> return (functx:change-element-names-deep( $in-xml-1, xs:QName('b'), xs:QName('y')), functx:change-element-names-deep( $in-xml-1, (xs:QName('a'), xs:QName('b'),xs:QName('c')), (xs:QName('x'), xs:QName('y'),xs:QName('z'))), functx:change-element-names-deep( $in-xml-2, (xs:QName('dty:b'),xs:QName('c')), (xs:QName('q'), QName('http://new','new:c'))))". Expected "!", "!=", "(", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "else", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. declare namespace functx = "http://www.example.com/";          declare namespace dty = "http://datypic.com";                     (:~ : Changes the names of elements in an XML fragment : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-names-deep.html : @param $nodes the element(s) to change : @param $oldNames the sequence of names to change from : @param $newNames the sequence of names to change to :)          declare function functx:change-element-names-deep ( $nodes as node()* , $oldNames as xs:QName* , $newNames as xs:QName* ) as node()* { if (count($oldNames) != count($newNames)) then error(xs:QName('functx:Different_number_of_names')) else for $node in $nodes return if ($node instance of element()) then element [Error is around here]{functx:if-empty ($newNames[index-of($oldNames, node-name($node))], node-name($node)) } {$node/@*, functx:change-element-names-deep($node/node(), $oldNames, $newNames)} else if ($node instance of document-node()) then functx:change-element-names-deep($node/node(), $oldNames, $newNames) else $node } ;                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     let $in-xml-1 := <in-xml> <a> <b>b</b> <c>c</c> </a> </in-xml> return let $in-xml-2 := <in-xml xmlns:dty="http://datypic.com"> <a> <dty:b>b</dty:b> <c>c</c> </a> </in-xml> return (functx:change-element-names-deep( $in-xml-1, xs:QName('b'), xs:QName('y')), functx:change-element-names-deep( $in-xml-1, (xs:QName('a'), xs:QName('b'),xs:QName('c')), (xs:QName('x'), xs:QName('y'),xs:QName('z'))), functx:change-element-names-deep( $in-xml-2, (xs:QName('dty:b'),xs:QName('c')), (xs:QName('q'), QName('http://new','new:c'))))
functx-functx-change-element-ns-deep-1,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Changes the namespace of XML elements and its descendants : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-ns-deep.html : @param $nodes the nodes to change : @param $newns the new namespace : @param $prefix the prefix to use for the new namespace :)          declare function functx:change-element-ns-deep ( $nodes as node()* , $newns as xs:string , $prefix as xs:string ) as node()* { for $node in $nodes return if ($node instance of element()) then (element {QName ($newns, concat($prefix, if ($prefix = '') then '' else ':', local-name($node)))} {$node/@*, functx:change-element-ns-deep($node/node(), $newns, $prefix)}) else if ($node instance of document-node()) then functx:change-element-ns-deep($node/node(), $newns, $prefix) else $node } ;                     let $in-xml := <bar:a xmlns:bar="http://bar"> <bar:b>557</bar:b> <bar:c>xyz</bar:c> </bar:a> return (functx:change-element-ns-deep( $in-xml, 'http://foo',''))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Changes the namespace of XML elements and its descendants : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-ns-deep.html : @param $nodes the nodes to change : @param $newns the new namespace : @param $prefix the prefix to use for the new namespace :)          declare function functx:change-element-ns-deep ( $nodes as node()* , $newns as xs:string , $prefix as xs:string ) as node()* { for $node in $nodes return if ($node instance of element()) then (element [Error is around here]{QName ($newns, concat($prefix, if ($prefix = '') then '' else ':', local-name($node)))} {$node/@*, functx:change-element-ns-deep($node/node(), $newns, $prefix)}) else if ($node instance of document-node()) then functx:change-element-ns-deep($node/node(), $newns, $prefix) else $node } ;                     let $in-xml := <bar:a xmlns:bar="http://bar"> <bar:b>557</bar:b> <bar:c>xyz</bar:c> </bar:a> return (functx:change-element-ns-deep( $in-xml, 'http://foo',''))
functx-functx-change-element-ns-deep-2,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Changes the namespace of XML elements and its descendants : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-ns-deep.html : @param $nodes the nodes to change : @param $newns the new namespace : @param $prefix the prefix to use for the new namespace :)          declare function functx:change-element-ns-deep ( $nodes as node()* , $newns as xs:string , $prefix as xs:string ) as node()* { for $node in $nodes return if ($node instance of element()) then (element {QName ($newns, concat($prefix, if ($prefix = '') then '' else ':', local-name($node)))} {$node/@*, functx:change-element-ns-deep($node/node(), $newns, $prefix)}) else if ($node instance of document-node()) then functx:change-element-ns-deep($node/node(), $newns, $prefix) else $node } ;                     let $in-xml := <bar:a xmlns:bar="http://bar"> <bar:b>557</bar:b> <bar:c>xyz</bar:c> </bar:a> return (functx:change-element-ns-deep( $in-xml, 'http://foo','foo'))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Changes the namespace of XML elements and its descendants : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-ns-deep.html : @param $nodes the nodes to change : @param $newns the new namespace : @param $prefix the prefix to use for the new namespace :)          declare function functx:change-element-ns-deep ( $nodes as node()* , $newns as xs:string , $prefix as xs:string ) as node()* { for $node in $nodes return if ($node instance of element()) then (element [Error is around here]{QName ($newns, concat($prefix, if ($prefix = '') then '' else ':', local-name($node)))} {$node/@*, functx:change-element-ns-deep($node/node(), $newns, $prefix)}) else if ($node instance of document-node()) then functx:change-element-ns-deep($node/node(), $newns, $prefix) else $node } ;                     let $in-xml := <bar:a xmlns:bar="http://bar"> <bar:b>557</bar:b> <bar:c>xyz</bar:c> </bar:a> return (functx:change-element-ns-deep( $in-xml, 'http://foo','foo'))
functx-functx-change-element-ns-deep-all,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Changes the namespace of XML elements and its descendants : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-ns-deep.html : @param $nodes the nodes to change : @param $newns the new namespace : @param $prefix the prefix to use for the new namespace :)          declare function functx:change-element-ns-deep ( $nodes as node()* , $newns as xs:string , $prefix as xs:string ) as node()* { for $node in $nodes return if ($node instance of element()) then (element {QName ($newns, concat($prefix, if ($prefix = '') then '' else ':', local-name($node)))} {$node/@*, functx:change-element-ns-deep($node/node(), $newns, $prefix)}) else if ($node instance of document-node()) then functx:change-element-ns-deep($node/node(), $newns, $prefix) else $node } ;                     let $in-xml := <bar:a xmlns:bar="http://bar"> <bar:b>557</bar:b> <bar:c>xyz</bar:c> </bar:a> return (functx:change-element-ns-deep( $in-xml, 'http://foo',''), functx:change-element-ns-deep( $in-xml, 'http://foo','foo'))". Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Changes the namespace of XML elements and its descendants : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-ns-deep.html : @param $nodes the nodes to change : @param $newns the new namespace : @param $prefix the prefix to use for the new namespace :)          declare function functx:change-element-ns-deep ( $nodes as node()* , $newns as xs:string , $prefix as xs:string ) as node()* { for $node in $nodes return if ($node instance of element()) then (element [Error is around here]{QName ($newns, concat($prefix, if ($prefix = '') then '' else ':', local-name($node)))} {$node/@*, functx:change-element-ns-deep($node/node(), $newns, $prefix)}) else if ($node instance of document-node()) then functx:change-element-ns-deep($node/node(), $newns, $prefix) else $node } ;                     let $in-xml := <bar:a xmlns:bar="http://bar"> <bar:b>557</bar:b> <bar:c>xyz</bar:c> </bar:a> return (functx:change-element-ns-deep( $in-xml, 'http://foo',''), functx:change-element-ns-deep( $in-xml, 'http://foo','foo'))
functx-functx-change-element-ns-1,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Changes the namespace of XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-ns.html : @param $elements the elements to change : @param $newns the new namespace : @param $prefix the prefix to use for the new namespace :)          declare function functx:change-element-ns ( $elements as element()* , $newns as xs:string , $prefix as xs:string ) as element()? { for $element in $elements return element {QName ($newns, concat($prefix, if ($prefix = '') then '' else ':', local-name($element)))} {$element/@*, $element/node()} } ;                     let $in-xml := <bar:a xmlns:bar="http://bar"> <bar:b>557</bar:b> <bar:c>xyz</bar:c> </bar:a> return (functx:change-element-ns( $in-xml, 'http://foo',''))". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Changes the namespace of XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-ns.html : @param $elements the elements to change : @param $newns the new namespace : @param $prefix the prefix to use for the new namespace :)          declare function functx:change-element-ns ( $elements as element()* , $newns as xs:string , $prefix as xs:string ) as element()? { for $element in $elements return element [Error is around here]{QName ($newns, concat($prefix, if ($prefix = '') then '' else ':', local-name($element)))} {$element/@*, $element/node()} } ;                     let $in-xml := <bar:a xmlns:bar="http://bar"> <bar:b>557</bar:b> <bar:c>xyz</bar:c> </bar:a> return (functx:change-element-ns( $in-xml, 'http://foo',''))
functx-functx-change-element-ns-2,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Changes the namespace of XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-ns.html : @param $elements the elements to change : @param $newns the new namespace : @param $prefix the prefix to use for the new namespace :)          declare function functx:change-element-ns ( $elements as element()* , $newns as xs:string , $prefix as xs:string ) as element()? { for $element in $elements return element {QName ($newns, concat($prefix, if ($prefix = '') then '' else ':', local-name($element)))} {$element/@*, $element/node()} } ;                     let $in-xml := <bar:a xmlns:bar="http://bar"> <bar:b>557</bar:b> <bar:c>xyz</bar:c> </bar:a> return (functx:change-element-ns( $in-xml, 'http://foo','foo'))". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Changes the namespace of XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-ns.html : @param $elements the elements to change : @param $newns the new namespace : @param $prefix the prefix to use for the new namespace :)          declare function functx:change-element-ns ( $elements as element()* , $newns as xs:string , $prefix as xs:string ) as element()? { for $element in $elements return element [Error is around here]{QName ($newns, concat($prefix, if ($prefix = '') then '' else ':', local-name($element)))} {$element/@*, $element/node()} } ;                     let $in-xml := <bar:a xmlns:bar="http://bar"> <bar:b>557</bar:b> <bar:c>xyz</bar:c> </bar:a> return (functx:change-element-ns( $in-xml, 'http://foo','foo'))
functx-functx-change-element-ns-all,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Changes the namespace of XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-ns.html : @param $elements the elements to change : @param $newns the new namespace : @param $prefix the prefix to use for the new namespace :)          declare function functx:change-element-ns ( $elements as element()* , $newns as xs:string , $prefix as xs:string ) as element()? { for $element in $elements return element {QName ($newns, concat($prefix, if ($prefix = '') then '' else ':', local-name($element)))} {$element/@*, $element/node()} } ;                     let $in-xml := <bar:a xmlns:bar="http://bar"> <bar:b>557</bar:b> <bar:c>xyz</bar:c> </bar:a> return (functx:change-element-ns( $in-xml, 'http://foo',''), functx:change-element-ns( $in-xml, 'http://foo','foo'))". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Changes the namespace of XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-ns.html : @param $elements the elements to change : @param $newns the new namespace : @param $prefix the prefix to use for the new namespace :)          declare function functx:change-element-ns ( $elements as element()* , $newns as xs:string , $prefix as xs:string ) as element()? { for $element in $elements return element [Error is around here]{QName ($newns, concat($prefix, if ($prefix = '') then '' else ':', local-name($element)))} {$element/@*, $element/node()} } ;                     let $in-xml := <bar:a xmlns:bar="http://bar"> <bar:b>557</bar:b> <bar:c>xyz</bar:c> </bar:a> return (functx:change-element-ns( $in-xml, 'http://foo',''), functx:change-element-ns( $in-xml, 'http://foo','foo'))
functx-functx-chars-1,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
functx-functx-chars-2,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
functx-functx-chars-all,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
functx-functx-contains-word-1,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-contains-word-2,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-contains-word-3,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-contains-word-4,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-contains-word-5,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-contains-word-all,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-copy-attributes-1,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Copies attributes from one element to another : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_copy-attributes.html : @param $copyTo the element to copy attributes to : @param $copyFrom the element to copy attributes from :)          declare function functx:copy-attributes ( $copyTo as element() , $copyFrom as element() ) as element() { element { node-name($copyTo)} { $copyTo/@*[not(node-name(.) = $copyFrom/@*/node-name(.))], $copyFrom/@*, $copyTo/node() } } ;                     let $in-xml := <in-xml> <a>123</a>> <b x="1" y="2">456</b> <c x="9">123</c> <d z="5">123</d> </in-xml> return (functx:copy-attributes( $in-xml/a, $in-xml/b))". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Copies attributes from one element to another : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_copy-attributes.html : @param $copyTo the element to copy attributes to : @param $copyFrom the element to copy attributes from :)          declare function functx:copy-attributes ( $copyTo as element() , $copyFrom as element() ) as element() { element [Error is around here]{ node-name($copyTo)} { $copyTo/@*[not(node-name(.) = $copyFrom/@*/node-name(.))], $copyFrom/@*, $copyTo/node() } } ;                     let $in-xml := <in-xml> <a>123</a>> <b x="1" y="2">456</b> <c x="9">123</c> <d z="5">123</d> </in-xml> return (functx:copy-attributes( $in-xml/a, $in-xml/b))
functx-functx-copy-attributes-2,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Copies attributes from one element to another : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_copy-attributes.html : @param $copyTo the element to copy attributes to : @param $copyFrom the element to copy attributes from :)          declare function functx:copy-attributes ( $copyTo as element() , $copyFrom as element() ) as element() { element { node-name($copyTo)} { $copyTo/@*[not(node-name(.) = $copyFrom/@*/node-name(.))], $copyFrom/@*, $copyTo/node() } } ;                     let $in-xml := <in-xml> <a>123</a>> <b x="1" y="2">456</b> <c x="9">123</c> <d z="5">123</d> </in-xml> return (functx:copy-attributes( $in-xml/b, $in-xml/c))". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Copies attributes from one element to another : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_copy-attributes.html : @param $copyTo the element to copy attributes to : @param $copyFrom the element to copy attributes from :)          declare function functx:copy-attributes ( $copyTo as element() , $copyFrom as element() ) as element() { element [Error is around here]{ node-name($copyTo)} { $copyTo/@*[not(node-name(.) = $copyFrom/@*/node-name(.))], $copyFrom/@*, $copyTo/node() } } ;                     let $in-xml := <in-xml> <a>123</a>> <b x="1" y="2">456</b> <c x="9">123</c> <d z="5">123</d> </in-xml> return (functx:copy-attributes( $in-xml/b, $in-xml/c))
functx-functx-copy-attributes-3,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Copies attributes from one element to another : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_copy-attributes.html : @param $copyTo the element to copy attributes to : @param $copyFrom the element to copy attributes from :)          declare function functx:copy-attributes ( $copyTo as element() , $copyFrom as element() ) as element() { element { node-name($copyTo)} { $copyTo/@*[not(node-name(.) = $copyFrom/@*/node-name(.))], $copyFrom/@*, $copyTo/node() } } ;                     let $in-xml := <in-xml> <a>123</a>> <b x="1" y="2">456</b> <c x="9">123</c> <d z="5">123</d> </in-xml> return (functx:copy-attributes( $in-xml/d, $in-xml/c))". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Copies attributes from one element to another : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_copy-attributes.html : @param $copyTo the element to copy attributes to : @param $copyFrom the element to copy attributes from :)          declare function functx:copy-attributes ( $copyTo as element() , $copyFrom as element() ) as element() { element [Error is around here]{ node-name($copyTo)} { $copyTo/@*[not(node-name(.) = $copyFrom/@*/node-name(.))], $copyFrom/@*, $copyTo/node() } } ;                     let $in-xml := <in-xml> <a>123</a>> <b x="1" y="2">456</b> <c x="9">123</c> <d z="5">123</d> </in-xml> return (functx:copy-attributes( $in-xml/d, $in-xml/c))
functx-functx-copy-attributes-all,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Copies attributes from one element to another : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_copy-attributes.html : @param $copyTo the element to copy attributes to : @param $copyFrom the element to copy attributes from :)          declare function functx:copy-attributes ( $copyTo as element() , $copyFrom as element() ) as element() { element { node-name($copyTo)} { $copyTo/@*[not(node-name(.) = $copyFrom/@*/node-name(.))], $copyFrom/@*, $copyTo/node() } } ;                     let $in-xml := <in-xml> <a>123</a>> <b x="1" y="2">456</b> <c x="9">123</c> <d z="5">123</d> </in-xml> return (functx:copy-attributes( $in-xml/a, $in-xml/b), functx:copy-attributes( $in-xml/b, $in-xml/c), functx:copy-attributes( $in-xml/d, $in-xml/c))". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Copies attributes from one element to another : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_copy-attributes.html : @param $copyTo the element to copy attributes to : @param $copyFrom the element to copy attributes from :)          declare function functx:copy-attributes ( $copyTo as element() , $copyFrom as element() ) as element() { element [Error is around here]{ node-name($copyTo)} { $copyTo/@*[not(node-name(.) = $copyFrom/@*/node-name(.))], $copyFrom/@*, $copyTo/node() } } ;                     let $in-xml := <in-xml> <a>123</a>> <b x="1" y="2">456</b> <c x="9">123</c> <d z="5">123</d> </in-xml> return (functx:copy-attributes( $in-xml/a, $in-xml/b), functx:copy-attributes( $in-xml/b, $in-xml/c), functx:copy-attributes( $in-xml/d, $in-xml/c))
functx-functx-date-1,Error: XPST0017: Function error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
functx-functx-date-2,Error: XPST0017: Function error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
functx-functx-date-all,Error: XPST0017: Function error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
functx-functx-dateTime-1,Error: XPST0017: Function error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
functx-functx-dateTime-2,Error: XPST0017: Function error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
functx-functx-dateTime-all,Error: XPST0017: Function error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
functx-functx-day-in-year-1,Error: XPST0017: Function error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
functx-functx-day-in-year-2,Error: XPST0017: Function error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
functx-functx-day-in-year-3,Error: XPST0017: Function error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
functx-functx-day-in-year-all,Error: XPST0017: Function error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
functx-functx-dayTimeDuration-1,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-functx-dayTimeDuration-2,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-functx-dayTimeDuration-3,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-functx-dayTimeDuration-4,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-functx-dayTimeDuration-5,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-functx-dayTimeDuration-all,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-functx-ddmmyyyy-to-date-1,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-ddmmyyyy-to-date-2,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-ddmmyyyy-to-date-3,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-ddmmyyyy-to-date-all,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-distinct-attribute-names-1,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-distinct-element-names-1,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-distinct-element-names-2,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-distinct-element-names-all,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-distinct-element-paths-1,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-distinct-element-paths-2,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-distinct-element-paths-all,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-duration-from-timezone-1,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-duration-from-timezone-2,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-duration-from-timezone-3,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-duration-from-timezone-all,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-dynamic-path-1,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Dynamically evaluates a simple XPath path : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_dynamic-path.html : @param $parent the root to start from : @param $path the path expression :)          declare function functx:dynamic-path ( $parent as node() , $path as xs:string ) as item()* { let $nextStep := functx:substring-before-if-contains($path,'/') let $restOfSteps := substring-after($path,'/') for $child in ($parent/*[functx:name-test(name(),$nextStep)], $parent/@*[functx:name-test(name(), substring-after($nextStep,'@'))]) return if ($restOfSteps) then functx:dynamic-path($child, $restOfSteps) else $child } ;                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     (:~ : Performs substring-before, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-before($arg,$delim) else $arg } ;                     let $in-xml := <authors> <author test="abc"> <first>Kate</first> <last>Jones</last> </author> <author> <first>John</first> <a:last xmlns:a="http://a">Doe</a:last> </author> </authors> return (functx:dynamic-path( $in-xml,'author/first'))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. declare namespace functx = "http://www.example.com/";                     (:~ : Dynamically evaluates a simple XPath path : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_dynamic-path.html : @param $parent the root to start from : @param $path the path expression :)          declare function functx:dynamic-path ( $parent as node() , $path as xs:string ) as item()* { let $nextStep := functx:substring-before-if-contains($path,'/') [Error is around here]let $restOfSteps := substring-after($path,'/') for $child in ($parent/*[functx:name-test(name(),$nextStep)], $parent/@*[functx:name-test(name(), substring-after($nextStep,'@'))]) return if ($restOfSteps) then functx:dynamic-path($child, $restOfSteps) else $child } ;                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     (:~ : Performs substring-before, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-before($arg,$delim) else $arg } ;                     let $in-xml := <authors> <author test="abc"> <first>Kate</first> <last>Jones</last> </author> <author> <first>John</first> <a:last xmlns:a="http://a">Doe</a:last> </author> </authors> return (functx:dynamic-path( $in-xml,'author/first'))
functx-functx-dynamic-path-2,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Dynamically evaluates a simple XPath path : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_dynamic-path.html : @param $parent the root to start from : @param $path the path expression :)          declare function functx:dynamic-path ( $parent as node() , $path as xs:string ) as item()* { let $nextStep := functx:substring-before-if-contains($path,'/') let $restOfSteps := substring-after($path,'/') for $child in ($parent/*[functx:name-test(name(),$nextStep)], $parent/@*[functx:name-test(name(), substring-after($nextStep,'@'))]) return if ($restOfSteps) then functx:dynamic-path($child, $restOfSteps) else $child } ;                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     (:~ : Performs substring-before, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-before($arg,$delim) else $arg } ;                     let $in-xml := <authors> <author test="abc"> <first>Kate</first> <last>Jones</last> </author> <author> <first>John</first> <a:last xmlns:a="http://a">Doe</a:last> </author> </authors> return (name(functx:dynamic-path( $in-xml,'author/@test')))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. declare namespace functx = "http://www.example.com/";                     (:~ : Dynamically evaluates a simple XPath path : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_dynamic-path.html : @param $parent the root to start from : @param $path the path expression :)          declare function functx:dynamic-path ( $parent as node() , $path as xs:string ) as item()* { let $nextStep := functx:substring-before-if-contains($path,'/') [Error is around here]let $restOfSteps := substring-after($path,'/') for $child in ($parent/*[functx:name-test(name(),$nextStep)], $parent/@*[functx:name-test(name(), substring-after($nextStep,'@'))]) return if ($restOfSteps) then functx:dynamic-path($child, $restOfSteps) else $child } ;                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     (:~ : Performs substring-before, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-before($arg,$delim) else $arg } ;                     let $in-xml := <authors> <author test="abc"> <first>Kate</first> <last>Jones</last> </author> <author> <first>John</first> <a:last xmlns:a="http://a">Doe</a:last> </author> </authors> return (name(functx:dynamic-path( $in-xml,'author/@test')))
functx-functx-dynamic-path-3,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Dynamically evaluates a simple XPath path : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_dynamic-path.html : @param $parent the root to start from : @param $path the path expression :)          declare function functx:dynamic-path ( $parent as node() , $path as xs:string ) as item()* { let $nextStep := functx:substring-before-if-contains($path,'/') let $restOfSteps := substring-after($path,'/') for $child in ($parent/*[functx:name-test(name(),$nextStep)], $parent/@*[functx:name-test(name(), substring-after($nextStep,'@'))]) return if ($restOfSteps) then functx:dynamic-path($child, $restOfSteps) else $child } ;                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     (:~ : Performs substring-before, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-before($arg,$delim) else $arg } ;                     let $in-xml := <authors> <author test="abc"> <first>Kate</first> <last>Jones</last> </author> <author> <first>John</first> <a:last xmlns:a="http://a">Doe</a:last> </author> </authors> return (functx:dynamic-path( $in-xml,'author'))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. declare namespace functx = "http://www.example.com/";                     (:~ : Dynamically evaluates a simple XPath path : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_dynamic-path.html : @param $parent the root to start from : @param $path the path expression :)          declare function functx:dynamic-path ( $parent as node() , $path as xs:string ) as item()* { let $nextStep := functx:substring-before-if-contains($path,'/') [Error is around here]let $restOfSteps := substring-after($path,'/') for $child in ($parent/*[functx:name-test(name(),$nextStep)], $parent/@*[functx:name-test(name(), substring-after($nextStep,'@'))]) return if ($restOfSteps) then functx:dynamic-path($child, $restOfSteps) else $child } ;                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     (:~ : Performs substring-before, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-before($arg,$delim) else $arg } ;                     let $in-xml := <authors> <author test="abc"> <first>Kate</first> <last>Jones</last> </author> <author> <first>John</first> <a:last xmlns:a="http://a">Doe</a:last> </author> </authors> return (functx:dynamic-path( $in-xml,'author'))
functx-functx-dynamic-path-4,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Dynamically evaluates a simple XPath path : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_dynamic-path.html : @param $parent the root to start from : @param $path the path expression :)          declare function functx:dynamic-path ( $parent as node() , $path as xs:string ) as item()* { let $nextStep := functx:substring-before-if-contains($path,'/') let $restOfSteps := substring-after($path,'/') for $child in ($parent/*[functx:name-test(name(),$nextStep)], $parent/@*[functx:name-test(name(), substring-after($nextStep,'@'))]) return if ($restOfSteps) then functx:dynamic-path($child, $restOfSteps) else $child } ;                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     (:~ : Performs substring-before, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-before($arg,$delim) else $arg } ;                     let $in-xml := <authors> <author test="abc"> <first>Kate</first> <last>Jones</last> </author> <author> <first>John</first> <a:last xmlns:a="http://a">Doe</a:last> </author> </authors> return (functx:dynamic-path( $in-xml,'author/a:last'))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. declare namespace functx = "http://www.example.com/";                     (:~ : Dynamically evaluates a simple XPath path : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_dynamic-path.html : @param $parent the root to start from : @param $path the path expression :)          declare function functx:dynamic-path ( $parent as node() , $path as xs:string ) as item()* { let $nextStep := functx:substring-before-if-contains($path,'/') [Error is around here]let $restOfSteps := substring-after($path,'/') for $child in ($parent/*[functx:name-test(name(),$nextStep)], $parent/@*[functx:name-test(name(), substring-after($nextStep,'@'))]) return if ($restOfSteps) then functx:dynamic-path($child, $restOfSteps) else $child } ;                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     (:~ : Performs substring-before, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-before($arg,$delim) else $arg } ;                     let $in-xml := <authors> <author test="abc"> <first>Kate</first> <last>Jones</last> </author> <author> <first>John</first> <a:last xmlns:a="http://a">Doe</a:last> </author> </authors> return (functx:dynamic-path( $in-xml,'author/a:last'))
functx-functx-dynamic-path-all,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Dynamically evaluates a simple XPath path : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_dynamic-path.html : @param $parent the root to start from : @param $path the path expression :)          declare function functx:dynamic-path ( $parent as node() , $path as xs:string ) as item()* {              let $nextStep := functx:substring-before-if-contains($path,'/')              let $restOfSteps := substring-after($path,'/')              for $child in ($parent/*[functx:name-test(name(),$nextStep)], $parent/@*[functx:name-test(name(), substring-after($nextStep,'@'))])              return if ($restOfSteps) then functx:dynamic-path($child, $restOfSteps) else $child           } ;                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean {              $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (                for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')]                 return substring-before($name,':*'))           } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? {              if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg           } ;                     (:~ : Performs substring-before, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? {              if (contains($arg,$delim)) then substring-before($arg,$delim) else $arg           } ;          let $in-xml := <authors> <author test="abc"> <first>Kate</first> <last>Jones</last> </author> <author> <first>John</first> <a:last xmlns:a="http://a">Doe</a:last> </author> </authors>           return document{(functx:dynamic-path( $in-xml,'author/first'),                   name(functx:dynamic-path( $in-xml,'author/@test')),                   functx:dynamic-path( $in-xml,'author'),                   functx:dynamic-path( $in-xml,'author/a:last'))}       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. declare namespace functx = "http://www.example.com/";                     (:~ : Dynamically evaluates a simple XPath path : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_dynamic-path.html : @param $parent the root to start from : @param $path the path expression :)          declare function functx:dynamic-path ( $parent as node() , $path as xs:string ) as item()* {              let $nextStep := functx:substring-before-if-contains($path,'/')              [Error is around here]let $restOfSteps := substring-after($path,'/')              for $child in ($parent/*[functx:name-test(name(),$nextStep)], $parent/@*[functx:name-test(name(), substring-after($nextStep,'@'))])              return if ($restOfSteps) then functx:dynamic-path($child, $restOfSteps) else $child           } ;                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean {              $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (                for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')]                 return substring-before($name,':*'))           } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? {              if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg           } ;                     (:~ : Performs substring-before, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? {              if (contains($arg,$delim)) then substring-before($arg,$delim) else $arg           } ;          let $in-xml := <authors> <author test="abc"> <first>Kate</first> <last>Jones</last> </author> <author> <first>John</first> <a:last xmlns:a="http://a">Doe</a:last> </author> </authors>           return document{(functx:dynamic-path( $in-xml,'author/first'),                   name(functx:dynamic-path( $in-xml,'author/@test')),                   functx:dynamic-path( $in-xml,'author'),                   functx:dynamic-path( $in-xml,'author/a:last'))}
functx-functx-escape-for-regex-1,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-escape-for-regex-2,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-escape-for-regex-all,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-first-day-of-month-1,Error: XPST0017: Function error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
functx-functx-first-day-of-month-2,Error: XPST0017: Function error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
functx-functx-first-day-of-month-3,Error: XPST0017: Function error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
functx-functx-first-day-of-month-all,Error: XPST0017: Function error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
functx-functx-first-day-of-year-1,Error: XPST0017: Function error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
functx-functx-first-day-of-year-2,Error: XPST0017: Function error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
functx-functx-first-day-of-year-3,Error: XPST0017: Function error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
functx-functx-first-day-of-year-all,Error: XPST0017: Function error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
functx-functx-format-as-title-en-1,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Moves title words like "the" and "a" to the end of strings : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_format-as-title-en.html : @param $titles the titles to format :)          declare function functx:format-as-title-en ( $titles as xs:string* ) as xs:string* { let $wordsToMoveToEnd := ('A', 'An', 'The') for $title in $titles let $firstWord := functx:substring-before-match($title,'\W') return if ($firstWord = $wordsToMoveToEnd) then replace($title,'(.*?)\W(.*)', '$2, $1') else $title } ;                     (:~ : The substring before the first text that matches a regex : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-match.html : @param $arg the string to substring : @param $regex the regular expression :)          declare function functx:substring-before-match ( $arg as xs:string? , $regex as xs:string ) as xs:string? { tokenize($arg,$regex)[1] } ;                     (functx:format-as-title-en( ('A Midsummer Night''s Dream', 'The Merchant of Venice', 'Hamlet')))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found. declare namespace functx = "http://www.example.com/";                     (:~ : Moves title words like "the" and "a" to the end of strings : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_format-as-title-en.html : @param $titles the titles to format :)          declare function functx:format-as-title-en ( $titles as xs:string* ) as xs:string* { let $wordsToMoveToEnd := ('A', 'An', 'The') [Error is around here]for $title in $titles let $firstWord := functx:substring-before-match($title,'\W') return if ($firstWord = $wordsToMoveToEnd) then replace($title,'(.*?)\W(.*)', '$2, $1') else $title } ;                     (:~ : The substring before the first text that matches a regex : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-match.html : @param $arg the string to substring : @param $regex the regular expression :)          declare function functx:substring-before-match ( $arg as xs:string? , $regex as xs:string ) as xs:string? { tokenize($arg,$regex)[1] } ;                     (functx:format-as-title-en( ('A Midsummer Night''s Dream', 'The Merchant of Venice', 'Hamlet')))
functx-functx-get-matches-and-non-matches-1,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-get-matches-and-non-matches-2,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-get-matches-and-non-matches-3,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-get-matches-and-non-matches-all,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-get-matches-1,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-get-matches-2,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-get-matches-3,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-get-matches-all,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-if-absent-1,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-functx-if-absent-2,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-functx-if-absent-3,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-functx-if-absent-all,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-functx-if-empty-1,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-functx-if-empty-2,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-functx-if-empty-3,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-functx-if-empty-4,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-functx-if-empty-5,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-functx-if-empty-6,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-functx-if-empty-all,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-functx-index-of-match-first-1,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-index-of-match-first-2,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-index-of-match-first-3,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-index-of-match-first-4,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-index-of-match-first-5,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-index-of-match-first-all,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-is-absolute-uri-1,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-is-absolute-uri-2,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-is-absolute-uri-3,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-is-absolute-uri-4,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-is-absolute-uri-5,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-is-absolute-uri-all,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-last-day-of-month-1,Error: XPST0017: Function error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
functx-functx-last-day-of-month-2,Error: XPST0017: Function error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
functx-functx-last-day-of-month-3,Error: XPST0017: Function error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
functx-functx-last-day-of-month-all,Error: XPST0017: Function error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
functx-functx-last-day-of-year-1,Error: XPST0017: Function error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
functx-functx-last-day-of-year-2,Error: XPST0017: Function error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
functx-functx-last-day-of-year-3,Error: XPST0017: Function error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
functx-functx-last-day-of-year-all,Error: XPST0017: Function error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
functx-functx-left-trim-1,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-left-trim-2,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-left-trim-3,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-left-trim-all,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-line-count-2,AssertionError: Expected XPath declare namespace functx = "http://www.example.com/";                     (:~ : The number of lines : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_line-count.html : @param $arg the string to test :)          declare function functx:line-count ( $arg as xs:string? ) as xs:integer { count(functx:lines($arg)) } ;                     (:~ : Split a string into separate lines : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_lines.html : @param $arg the string to split :)          declare function functx:lines ( $arg as xs:string? ) as xs:string* { tokenize($arg, '(\r\n?|\n\r?)') } ;          let $lines := 'a              value              on              many              lines' return (functx:line-count($lines))        to resolve to 5: expected false to be true
functx-functx-line-count-all,AssertionError: declare namespace functx = "http://www.example.com/";                     (:~ : The number of lines : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_line-count.html : @param $arg the string to test :)          declare function functx:line-count ( $arg as xs:string? ) as xs:integer { count(functx:lines($arg)) } ;                     (:~ : Split a string into separate lines : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_lines.html : @param $arg the string to split :)          declare function functx:lines ( $arg as xs:string? ) as xs:string* { tokenize($arg, '(\r\n?|\n\r?)') } ;          let $lines := 'a                      value                      on                      many                      lines'           return (functx:line-count('a value'), functx:line-count($lines)): expected '1 9' to equal '1 5'
functx-functx-mmddyyyy-to-date-1,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-mmddyyyy-to-date-2,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-mmddyyyy-to-date-3,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-mmddyyyy-to-date-all,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-namespaces-in-use-1,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-next-day-1,Error: Not implemented: adding durations to xs:date
functx-functx-next-day-2,Error: Not implemented: adding durations to xs:date
functx-functx-next-day-all,Error: Not implemented: adding durations to xs:date
functx-functx-non-distinct-values-1,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-non-distinct-values-2,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-non-distinct-values-3,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-non-distinct-values-all,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-ordinal-number-en-1,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-ordinal-number-en-2,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-ordinal-number-en-all,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-pad-integer-to-length-1,Error: XPST0017: Function error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
functx-functx-pad-integer-to-length-2,Error: XPST0017: Function error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
functx-functx-pad-integer-to-length-3,Error: XPST0017: Function error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
functx-functx-pad-integer-to-length-all,Error: XPST0017: Function error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
functx-functx-path-to-node-with-pos-1,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on node identity : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[$nodes[$seq] is $nodeToFind] } ;                     (:~ : A unique path to an XML node (or sequence of nodes) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_path-to-node-with-pos.html : @param $node the node sequence :)          declare function functx:path-to-node-with-pos ( $node as node()? ) as xs:string { string-join( for $ancestor in $node/ancestor-or-self::* let $sibsOfSameName := $ancestor/../*[name() = name($ancestor)] return concat(name($ancestor), if (count($sibsOfSameName) <= 1) then '' else concat( '[',functx:index-of-node($sibsOfSameName,$ancestor),']')) , '/') } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:path-to-node-with-pos( $in-xml//lName[. = 'Doe']))". Expected " ", "!", "!=", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on node identity : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[$nodes[$seq] is $nodeToFind] } ;                     (:~ : A unique path to an XML node (or sequence of nodes) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_path-to-node-with-pos.html : @param $node the node sequence :)          declare function functx:path-to-node-with-pos ( $node as node()? ) as xs:string { string-join( for $ancestor in $node/ancestor-or-self::* [Error is around here]let $sibsOfSameName := $ancestor/../*[name() = name($ancestor)] return concat(name($ancestor), if (count($sibsOfSameName) <= 1) then '' else concat( '[',functx:index-of-node($sibsOfSameName,$ancestor),']')) , '/') } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:path-to-node-with-pos( $in-xml//lName[. = 'Doe']))
functx-functx-path-to-node-with-pos-2,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on node identity : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[$nodes[$seq] is $nodeToFind] } ;                     (:~ : A unique path to an XML node (or sequence of nodes) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_path-to-node-with-pos.html : @param $node the node sequence :)          declare function functx:path-to-node-with-pos ( $node as node()? ) as xs:string { string-join( for $ancestor in $node/ancestor-or-self::* let $sibsOfSameName := $ancestor/../*[name() = name($ancestor)] return concat(name($ancestor), if (count($sibsOfSameName) <= 1) then '' else concat( '[',functx:index-of-node($sibsOfSameName,$ancestor),']')) , '/') } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:path-to-node-with-pos($in-xml/*[1]))". Expected " ", "!", "!=", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on node identity : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[$nodes[$seq] is $nodeToFind] } ;                     (:~ : A unique path to an XML node (or sequence of nodes) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_path-to-node-with-pos.html : @param $node the node sequence :)          declare function functx:path-to-node-with-pos ( $node as node()? ) as xs:string { string-join( for $ancestor in $node/ancestor-or-self::* [Error is around here]let $sibsOfSameName := $ancestor/../*[name() = name($ancestor)] return concat(name($ancestor), if (count($sibsOfSameName) <= 1) then '' else concat( '[',functx:index-of-node($sibsOfSameName,$ancestor),']')) , '/') } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:path-to-node-with-pos($in-xml/*[1]))
functx-functx-path-to-node-with-pos-all,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on node identity : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[$nodes[$seq] is $nodeToFind] } ;                     (:~ : A unique path to an XML node (or sequence of nodes) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_path-to-node-with-pos.html : @param $node the node sequence :)          declare function functx:path-to-node-with-pos ( $node as node()? ) as xs:string { string-join( for $ancestor in $node/ancestor-or-self::* let $sibsOfSameName := $ancestor/../*[name() = name($ancestor)] return concat(name($ancestor), if (count($sibsOfSameName) <= 1) then '' else concat( '[',functx:index-of-node($sibsOfSameName,$ancestor),']')) , '/') } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:path-to-node-with-pos( $in-xml//lName[. = 'Doe']), functx:path-to-node-with-pos($in-xml/*[1]))". Expected " ", "!", "!=", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on node identity : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[$nodes[$seq] is $nodeToFind] } ;                     (:~ : A unique path to an XML node (or sequence of nodes) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_path-to-node-with-pos.html : @param $node the node sequence :)          declare function functx:path-to-node-with-pos ( $node as node()? ) as xs:string { string-join( for $ancestor in $node/ancestor-or-self::* [Error is around here]let $sibsOfSameName := $ancestor/../*[name() = name($ancestor)] return concat(name($ancestor), if (count($sibsOfSameName) <= 1) then '' else concat( '[',functx:index-of-node($sibsOfSameName,$ancestor),']')) , '/') } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:path-to-node-with-pos( $in-xml//lName[. = 'Doe']), functx:path-to-node-with-pos($in-xml/*[1]))
functx-functx-previous-day-1,Error: Not implemented: subtracting durations from xs:date
functx-functx-previous-day-2,Error: Not implemented: subtracting durations from xs:date
functx-functx-previous-day-all,Error: Not implemented: subtracting durations from xs:date
functx-functx-remove-attributes-deep-1,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML fragment, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes-deep.html : @param $nodes the root(s) to start from : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then element { node-name($node)} { $node/@*[not(functx:name-test(name(),$names))], functx:remove-attributes-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-attributes-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456"> <b attr1="xzy">abc</b> </a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456"> <b a:attr1="ghi" attr1="xzy">abc</b> </a> return (functx:remove-attributes-deep( $in-xml-1, ('attr1','attr2')))". Expected "!", "!=", "(", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "else", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML fragment, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes-deep.html : @param $nodes the root(s) to start from : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then element [Error is around here]{ node-name($node)} { $node/@*[not(functx:name-test(name(),$names))], functx:remove-attributes-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-attributes-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456"> <b attr1="xzy">abc</b> </a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456"> <b a:attr1="ghi" attr1="xzy">abc</b> </a> return (functx:remove-attributes-deep( $in-xml-1, ('attr1','attr2')))
functx-functx-remove-attributes-deep-2,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML fragment, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes-deep.html : @param $nodes the root(s) to start from : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then element { node-name($node)} { $node/@*[not(functx:name-test(name(),$names))], functx:remove-attributes-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-attributes-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456"> <b attr1="xzy">abc</b> </a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456"> <b a:attr1="ghi" attr1="xzy">abc</b> </a> return (functx:remove-attributes-deep( $in-xml-1, ('attr1','attr3')))". Expected "!", "!=", "(", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "else", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML fragment, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes-deep.html : @param $nodes the root(s) to start from : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then element [Error is around here]{ node-name($node)} { $node/@*[not(functx:name-test(name(),$names))], functx:remove-attributes-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-attributes-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456"> <b attr1="xzy">abc</b> </a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456"> <b a:attr1="ghi" attr1="xzy">abc</b> </a> return (functx:remove-attributes-deep( $in-xml-1, ('attr1','attr3')))
functx-functx-remove-attributes-deep-3,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML fragment, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes-deep.html : @param $nodes the root(s) to start from : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then element { node-name($node)} { $node/@*[not(functx:name-test(name(),$names))], functx:remove-attributes-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-attributes-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456"> <b attr1="xzy">abc</b> </a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456"> <b a:attr1="ghi" attr1="xzy">abc</b> </a> return (functx:remove-attributes-deep( $in-xml-2, 'a:attr1'))". Expected "!", "!=", "(", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "else", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML fragment, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes-deep.html : @param $nodes the root(s) to start from : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then element [Error is around here]{ node-name($node)} { $node/@*[not(functx:name-test(name(),$names))], functx:remove-attributes-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-attributes-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456"> <b attr1="xzy">abc</b> </a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456"> <b a:attr1="ghi" attr1="xzy">abc</b> </a> return (functx:remove-attributes-deep( $in-xml-2, 'a:attr1'))
functx-functx-remove-attributes-deep-all,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML fragment, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes-deep.html : @param $nodes the root(s) to start from : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then element { node-name($node)} { $node/@*[not(functx:name-test(name(),$names))], functx:remove-attributes-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-attributes-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456"> <b attr1="xzy">abc</b> </a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456"> <b a:attr1="ghi" attr1="xzy">abc</b> </a> return (functx:remove-attributes-deep( $in-xml-1, ('attr1','attr2')), functx:remove-attributes-deep( $in-xml-1, ('attr1','attr3')), functx:remove-attributes-deep( $in-xml-2, 'a:attr1'))". Expected "!", "!=", "(", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "else", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML fragment, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes-deep.html : @param $nodes the root(s) to start from : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then element [Error is around here]{ node-name($node)} { $node/@*[not(functx:name-test(name(),$names))], functx:remove-attributes-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-attributes-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456"> <b attr1="xzy">abc</b> </a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456"> <b a:attr1="ghi" attr1="xzy">abc</b> </a> return (functx:remove-attributes-deep( $in-xml-1, ('attr1','attr2')), functx:remove-attributes-deep( $in-xml-1, ('attr1','attr3')), functx:remove-attributes-deep( $in-xml-2, 'a:attr1'))
functx-functx-remove-attributes-1,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML element, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes.html : @param $elements the element(s) from which to remove the attributes : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes ( $elements as element()* , $names as xs:string* ) as element() { for $element in $elements return element {node-name($element)} {$element/@*[not(functx:name-test(name(),$names))], $element/node() } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456">abc</a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456">abc</a> return (functx:remove-attributes( $in-xml-1, ('attr1','attr2')))". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML element, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes.html : @param $elements the element(s) from which to remove the attributes : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes ( $elements as element()* , $names as xs:string* ) as element() { for $element in $elements return element [Error is around here]{node-name($element)} {$element/@*[not(functx:name-test(name(),$names))], $element/node() } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456">abc</a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456">abc</a> return (functx:remove-attributes( $in-xml-1, ('attr1','attr2')))
functx-functx-remove-attributes-2,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML element, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes.html : @param $elements the element(s) from which to remove the attributes : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes ( $elements as element()* , $names as xs:string* ) as element() { for $element in $elements return element {node-name($element)} {$element/@*[not(functx:name-test(name(),$names))], $element/node() } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456">abc</a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456">abc</a> return (functx:remove-attributes( $in-xml-1, ('attr1','attr3')))". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML element, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes.html : @param $elements the element(s) from which to remove the attributes : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes ( $elements as element()* , $names as xs:string* ) as element() { for $element in $elements return element [Error is around here]{node-name($element)} {$element/@*[not(functx:name-test(name(),$names))], $element/node() } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456">abc</a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456">abc</a> return (functx:remove-attributes( $in-xml-1, ('attr1','attr3')))
functx-functx-remove-attributes-3,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML element, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes.html : @param $elements the element(s) from which to remove the attributes : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes ( $elements as element()* , $names as xs:string* ) as element() { for $element in $elements return element {node-name($element)} {$element/@*[not(functx:name-test(name(),$names))], $element/node() } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456">abc</a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456">abc</a> return (functx:remove-attributes($in-xml-1, '*'))". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML element, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes.html : @param $elements the element(s) from which to remove the attributes : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes ( $elements as element()* , $names as xs:string* ) as element() { for $element in $elements return element [Error is around here]{node-name($element)} {$element/@*[not(functx:name-test(name(),$names))], $element/node() } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456">abc</a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456">abc</a> return (functx:remove-attributes($in-xml-1, '*'))
functx-functx-remove-attributes-4,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML element, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes.html : @param $elements the element(s) from which to remove the attributes : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes ( $elements as element()* , $names as xs:string* ) as element() { for $element in $elements return element {node-name($element)} {$element/@*[not(functx:name-test(name(),$names))], $element/node() } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456">abc</a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456">abc</a> return (functx:remove-attributes( $in-xml-2, ('a:attr1')))". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML element, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes.html : @param $elements the element(s) from which to remove the attributes : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes ( $elements as element()* , $names as xs:string* ) as element() { for $element in $elements return element [Error is around here]{node-name($element)} {$element/@*[not(functx:name-test(name(),$names))], $element/node() } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456">abc</a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456">abc</a> return (functx:remove-attributes( $in-xml-2, ('a:attr1')))
functx-functx-remove-attributes-all,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML element, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes.html : @param $elements the element(s) from which to remove the attributes : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes ( $elements as element()* , $names as xs:string* ) as element() { for $element in $elements return element {node-name($element)} {$element/@*[not(functx:name-test(name(),$names))], $element/node() } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456">abc</a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456">abc</a> return (functx:remove-attributes( $in-xml-1, ('attr1','attr2')), functx:remove-attributes( $in-xml-1, ('attr1','attr3')), functx:remove-attributes($in-xml-1, '*'), functx:remove-attributes( $in-xml-2, ('a:attr1')))". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML element, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes.html : @param $elements the element(s) from which to remove the attributes : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes ( $elements as element()* , $names as xs:string* ) as element() { for $element in $elements return element [Error is around here]{node-name($element)} {$element/@*[not(functx:name-test(name(),$names))], $element/node() } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456">abc</a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456">abc</a> return (functx:remove-attributes( $in-xml-1, ('attr1','attr2')), functx:remove-attributes( $in-xml-1, ('attr1','attr3')), functx:remove-attributes($in-xml-1, '*'), functx:remove-attributes( $in-xml-2, ('a:attr1')))
functx-functx-remove-elements-deep-1,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-deep.html : @param $nodes root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then () else element { node-name($node)} { $node/@*, functx:remove-elements-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-elements-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <x:b>b1</x:b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return (functx:remove-elements-deep( $in-xml-1, 'b'))". Expected "!", "!=", "(", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "else", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-deep.html : @param $nodes root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then () else element [Error is around here]{ node-name($node)} { $node/@*, functx:remove-elements-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-elements-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <x:b>b1</x:b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return (functx:remove-elements-deep( $in-xml-1, 'b'))
functx-functx-remove-elements-deep-2,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-deep.html : @param $nodes root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then () else element { node-name($node)} { $node/@*, functx:remove-elements-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-elements-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <x:b>b1</x:b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return (functx:remove-elements-deep( $in-xml-1, 'a'))". Expected "!", "!=", "(", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "else", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-deep.html : @param $nodes root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then () else element [Error is around here]{ node-name($node)} { $node/@*, functx:remove-elements-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-elements-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <x:b>b1</x:b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return (functx:remove-elements-deep( $in-xml-1, 'a'))
functx-functx-remove-elements-deep-3,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-deep.html : @param $nodes root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then () else element { node-name($node)} { $node/@*, functx:remove-elements-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-elements-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <x:b>b1</x:b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return (functx:remove-elements-deep( $in-xml-1, ('b','c')))". Expected "!", "!=", "(", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "else", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-deep.html : @param $nodes root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then () else element [Error is around here]{ node-name($node)} { $node/@*, functx:remove-elements-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-elements-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <x:b>b1</x:b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return (functx:remove-elements-deep( $in-xml-1, ('b','c')))
functx-functx-remove-elements-deep-4,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-deep.html : @param $nodes root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then () else element { node-name($node)} { $node/@*, functx:remove-elements-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-elements-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <x:b>b1</x:b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return (functx:remove-elements-deep( $in-xml-2, 'x:b'))". Expected "!", "!=", "(", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "else", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-deep.html : @param $nodes root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then () else element [Error is around here]{ node-name($node)} { $node/@*, functx:remove-elements-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-elements-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <x:b>b1</x:b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return (functx:remove-elements-deep( $in-xml-2, 'x:b'))
functx-functx-remove-elements-deep-all,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-deep.html : @param $nodes root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then () else element { node-name($node)} { $node/@*, functx:remove-elements-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-elements-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <x:b>b1</x:b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return (functx:remove-elements-deep( $in-xml-1, 'b'), functx:remove-elements-deep( $in-xml-1, 'a'), functx:remove-elements-deep( $in-xml-1, ('b','c')), functx:remove-elements-deep( $in-xml-2, 'x:b'))". Expected "!", "!=", "(", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "else", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-deep.html : @param $nodes root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then () else element [Error is around here]{ node-name($node)} { $node/@*, functx:remove-elements-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-elements-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <x:b>b1</x:b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return (functx:remove-elements-deep( $in-xml-1, 'b'), functx:remove-elements-deep( $in-xml-1, 'a'), functx:remove-elements-deep( $in-xml-1, ('b','c')), functx:remove-elements-deep( $in-xml-2, 'x:b'))
functx-functx-remove-elements-not-contents-1,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant XML elements but keeps their content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-not-contents.html : @param $nodes the root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-not-contents ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then functx:remove-elements-not-contents($node/node(), $names) else element {node-name($node)} {$node/@*, functx:remove-elements-not-contents($node/node(),$names)} else if ($node instance of document-node()) then functx:remove-elements-not-contents($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <x:b>content</x:b></c> </in-xml> return (functx:remove-elements-not-contents( $in-xml-1, 'b'))". Expected "!", "!=", "(", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "else", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant XML elements but keeps their content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-not-contents.html : @param $nodes the root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-not-contents ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then functx:remove-elements-not-contents($node/node(), $names) else element [Error is around here]{node-name($node)} {$node/@*, functx:remove-elements-not-contents($node/node(),$names)} else if ($node instance of document-node()) then functx:remove-elements-not-contents($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <x:b>content</x:b></c> </in-xml> return (functx:remove-elements-not-contents( $in-xml-1, 'b'))
functx-functx-remove-elements-not-contents-2,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant XML elements but keeps their content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-not-contents.html : @param $nodes the root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-not-contents ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then functx:remove-elements-not-contents($node/node(), $names) else element {node-name($node)} {$node/@*, functx:remove-elements-not-contents($node/node(),$names)} else if ($node instance of document-node()) then functx:remove-elements-not-contents($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <x:b>content</x:b></c> </in-xml> return (functx:remove-elements-not-contents( $in-xml-1, ('b','c')))". Expected "!", "!=", "(", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "else", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant XML elements but keeps their content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-not-contents.html : @param $nodes the root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-not-contents ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then functx:remove-elements-not-contents($node/node(), $names) else element [Error is around here]{node-name($node)} {$node/@*, functx:remove-elements-not-contents($node/node(),$names)} else if ($node instance of document-node()) then functx:remove-elements-not-contents($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <x:b>content</x:b></c> </in-xml> return (functx:remove-elements-not-contents( $in-xml-1, ('b','c')))
functx-functx-remove-elements-not-contents-3,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant XML elements but keeps their content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-not-contents.html : @param $nodes the root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-not-contents ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then functx:remove-elements-not-contents($node/node(), $names) else element {node-name($node)} {$node/@*, functx:remove-elements-not-contents($node/node(),$names)} else if ($node instance of document-node()) then functx:remove-elements-not-contents($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <x:b>content</x:b></c> </in-xml> return (functx:remove-elements-not-contents( $in-xml-1, 'a'))". Expected "!", "!=", "(", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "else", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant XML elements but keeps their content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-not-contents.html : @param $nodes the root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-not-contents ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then functx:remove-elements-not-contents($node/node(), $names) else element [Error is around here]{node-name($node)} {$node/@*, functx:remove-elements-not-contents($node/node(),$names)} else if ($node instance of document-node()) then functx:remove-elements-not-contents($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <x:b>content</x:b></c> </in-xml> return (functx:remove-elements-not-contents( $in-xml-1, 'a'))
functx-functx-remove-elements-not-contents-4,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant XML elements but keeps their content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-not-contents.html : @param $nodes the root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-not-contents ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then functx:remove-elements-not-contents($node/node(), $names) else element {node-name($node)} {$node/@*, functx:remove-elements-not-contents($node/node(),$names)} else if ($node instance of document-node()) then functx:remove-elements-not-contents($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <x:b>content</x:b></c> </in-xml> return (functx:remove-elements-not-contents( $in-xml-2, 'x:b'))". Expected "!", "!=", "(", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "else", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant XML elements but keeps their content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-not-contents.html : @param $nodes the root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-not-contents ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then functx:remove-elements-not-contents($node/node(), $names) else element [Error is around here]{node-name($node)} {$node/@*, functx:remove-elements-not-contents($node/node(),$names)} else if ($node instance of document-node()) then functx:remove-elements-not-contents($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <x:b>content</x:b></c> </in-xml> return (functx:remove-elements-not-contents( $in-xml-2, 'x:b'))
functx-functx-remove-elements-not-contents-all,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant XML elements but keeps their content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-not-contents.html : @param $nodes the root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-not-contents ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then functx:remove-elements-not-contents($node/node(), $names) else element {node-name($node)} {$node/@*, functx:remove-elements-not-contents($node/node(),$names)} else if ($node instance of document-node()) then functx:remove-elements-not-contents($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <x:b>content</x:b></c> </in-xml> return (functx:remove-elements-not-contents( $in-xml-1, 'b'), functx:remove-elements-not-contents( $in-xml-1, ('b','c')), functx:remove-elements-not-contents( $in-xml-1, 'a'), functx:remove-elements-not-contents( $in-xml-2, 'x:b'))". Expected "!", "!=", "(", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "else", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant XML elements but keeps their content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-not-contents.html : @param $nodes the root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-not-contents ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then functx:remove-elements-not-contents($node/node(), $names) else element [Error is around here]{node-name($node)} {$node/@*, functx:remove-elements-not-contents($node/node(),$names)} else if ($node instance of document-node()) then functx:remove-elements-not-contents($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <x:b>content</x:b></c> </in-xml> return (functx:remove-elements-not-contents( $in-xml-1, 'b'), functx:remove-elements-not-contents( $in-xml-1, ('b','c')), functx:remove-elements-not-contents( $in-xml-1, 'a'), functx:remove-elements-not-contents( $in-xml-2, 'x:b'))
functx-functx-remove-elements-1,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes child elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements.html : @param $elements the element(s) from which you wish to remove the children : @param $names the names of the child elements to remove :)          declare function functx:remove-elements ( $elements as element()* , $names as xs:string* ) as element()* { for $element in $elements return element {node-name($element)} {$element/@*, $element/node()[not(functx:name-test(name(),$names))] } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a>123</a> <a>456</a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a>123</a> <x:a>456</x:a> <c>Mixed <x:a>content</x:a></c> </in-xml> return (functx:remove-elements( $in-xml-1, 'c'))". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes child elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements.html : @param $elements the element(s) from which you wish to remove the children : @param $names the names of the child elements to remove :)          declare function functx:remove-elements ( $elements as element()* , $names as xs:string* ) as element()* { for $element in $elements return element [Error is around here]{node-name($element)} {$element/@*, $element/node()[not(functx:name-test(name(),$names))] } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a>123</a> <a>456</a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a>123</a> <x:a>456</x:a> <c>Mixed <x:a>content</x:a></c> </in-xml> return (functx:remove-elements( $in-xml-1, 'c'))
functx-functx-remove-elements-2,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes child elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements.html : @param $elements the element(s) from which you wish to remove the children : @param $names the names of the child elements to remove :)          declare function functx:remove-elements ( $elements as element()* , $names as xs:string* ) as element()* { for $element in $elements return element {node-name($element)} {$element/@*, $element/node()[not(functx:name-test(name(),$names))] } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a>123</a> <a>456</a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a>123</a> <x:a>456</x:a> <c>Mixed <x:a>content</x:a></c> </in-xml> return (functx:remove-elements( $in-xml-1, ('a','b')))". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes child elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements.html : @param $elements the element(s) from which you wish to remove the children : @param $names the names of the child elements to remove :)          declare function functx:remove-elements ( $elements as element()* , $names as xs:string* ) as element()* { for $element in $elements return element [Error is around here]{node-name($element)} {$element/@*, $element/node()[not(functx:name-test(name(),$names))] } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a>123</a> <a>456</a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a>123</a> <x:a>456</x:a> <c>Mixed <x:a>content</x:a></c> </in-xml> return (functx:remove-elements( $in-xml-1, ('a','b')))
functx-functx-remove-elements-3,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes child elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements.html : @param $elements the element(s) from which you wish to remove the children : @param $names the names of the child elements to remove :)          declare function functx:remove-elements ( $elements as element()* , $names as xs:string* ) as element()* { for $element in $elements return element {node-name($element)} {$element/@*, $element/node()[not(functx:name-test(name(),$names))] } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a>123</a> <a>456</a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a>123</a> <x:a>456</x:a> <c>Mixed <x:a>content</x:a></c> </in-xml> return (functx:remove-elements( $in-xml-2, 'x:a'))". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes child elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements.html : @param $elements the element(s) from which you wish to remove the children : @param $names the names of the child elements to remove :)          declare function functx:remove-elements ( $elements as element()* , $names as xs:string* ) as element()* { for $element in $elements return element [Error is around here]{node-name($element)} {$element/@*, $element/node()[not(functx:name-test(name(),$names))] } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a>123</a> <a>456</a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a>123</a> <x:a>456</x:a> <c>Mixed <x:a>content</x:a></c> </in-xml> return (functx:remove-elements( $in-xml-2, 'x:a'))
functx-functx-remove-elements-all,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes child elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements.html : @param $elements the element(s) from which you wish to remove the children : @param $names the names of the child elements to remove :)          declare function functx:remove-elements ( $elements as element()* , $names as xs:string* ) as element()* { for $element in $elements return element {node-name($element)} {$element/@*, $element/node()[not(functx:name-test(name(),$names))] } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a>123</a> <a>456</a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a>123</a> <x:a>456</x:a> <c>Mixed <x:a>content</x:a></c> </in-xml> return (functx:remove-elements( $in-xml-1, 'c'), functx:remove-elements( $in-xml-1, ('a','b')), functx:remove-elements( $in-xml-2, 'x:a'))". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes child elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements.html : @param $elements the element(s) from which you wish to remove the children : @param $names the names of the child elements to remove :)          declare function functx:remove-elements ( $elements as element()* , $names as xs:string* ) as element()* { for $element in $elements return element [Error is around here]{node-name($element)} {$element/@*, $element/node()[not(functx:name-test(name(),$names))] } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a>123</a> <a>456</a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a>123</a> <x:a>456</x:a> <c>Mixed <x:a>content</x:a></c> </in-xml> return (functx:remove-elements( $in-xml-1, 'c'), functx:remove-elements( $in-xml-1, ('a','b')), functx:remove-elements( $in-xml-2, 'x:a'))
functx-functx-replace-beginning-1,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-replace-beginning-2,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-replace-beginning-3,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-replace-beginning-4,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-replace-beginning-all,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-replace-element-values-1,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Updates the content of one or more elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-element-values.html : @param $elements the elements whose content you wish to replace : @param $values the replacement values :)          declare function functx:replace-element-values ( $elements as element()* , $values as xs:anyAtomicType* ) as element()* { for $element at $seq in $elements return element { node-name($element)} { $element/@*, $values[$seq] } } ;                     let $in-xml := <in-xml> <price num="1">12</price> <price num="2">20</price> <price num="3">5</price> </in-xml> return (functx:replace-element-values( $in-xml/price, for $p in $in-xml/price return $p * 2))". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. declare namespace functx = "http://www.example.com/";                     (:~ : Updates the content of one or more elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-element-values.html : @param $elements the elements whose content you wish to replace : @param $values the replacement values :)          declare function functx:replace-element-values ( $elements as element()* , $values as xs:anyAtomicType* ) as element()* { for $element [Error is around here]at $seq in $elements return element { node-name($element)} { $element/@*, $values[$seq] } } ;                     let $in-xml := <in-xml> <price num="1">12</price> <price num="2">20</price> <price num="3">5</price> </in-xml> return (functx:replace-element-values( $in-xml/price, for $p in $in-xml/price return $p * 2))
functx-functx-replace-element-values-2,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Updates the content of one or more elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-element-values.html : @param $elements the elements whose content you wish to replace : @param $values the replacement values :)          declare function functx:replace-element-values ( $elements as element()* , $values as xs:anyAtomicType* ) as element()* { for $element at $seq in $elements return element { node-name($element)} { $element/@*, $values[$seq] } } ;                     let $in-xml := <in-xml> <price num="1">12</price> <price num="2">20</price> <price num="3">5</price> </in-xml> return (for $p in $in-xml/price return functx:replace-element-values( $p,concat($p,'.0')))". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. declare namespace functx = "http://www.example.com/";                     (:~ : Updates the content of one or more elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-element-values.html : @param $elements the elements whose content you wish to replace : @param $values the replacement values :)          declare function functx:replace-element-values ( $elements as element()* , $values as xs:anyAtomicType* ) as element()* { for $element [Error is around here]at $seq in $elements return element { node-name($element)} { $element/@*, $values[$seq] } } ;                     let $in-xml := <in-xml> <price num="1">12</price> <price num="2">20</price> <price num="3">5</price> </in-xml> return (for $p in $in-xml/price return functx:replace-element-values( $p,concat($p,'.0')))
functx-functx-replace-element-values-all,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Updates the content of one or more elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-element-values.html : @param $elements the elements whose content you wish to replace : @param $values the replacement values :)          declare function functx:replace-element-values ( $elements as element()* , $values as xs:anyAtomicType* ) as element()* { for $element at $seq in $elements return element { node-name($element)} { $element/@*, $values[$seq] } } ;                     let $in-xml := <in-xml> <price num="1">12</price> <price num="2">20</price> <price num="3">5</price> </in-xml> return (functx:replace-element-values( $in-xml/price, for $p in $in-xml/price return $p * 2), for $p in $in-xml/price return functx:replace-element-values( $p,concat($p,'.0')))". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. declare namespace functx = "http://www.example.com/";                     (:~ : Updates the content of one or more elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-element-values.html : @param $elements the elements whose content you wish to replace : @param $values the replacement values :)          declare function functx:replace-element-values ( $elements as element()* , $values as xs:anyAtomicType* ) as element()* { for $element [Error is around here]at $seq in $elements return element { node-name($element)} { $element/@*, $values[$seq] } } ;                     let $in-xml := <in-xml> <price num="1">12</price> <price num="2">20</price> <price num="3">5</price> </in-xml> return (functx:replace-element-values( $in-xml/price, for $p in $in-xml/price return $p * 2), for $p in $in-xml/price return functx:replace-element-values( $p,concat($p,'.0')))
functx-functx-replace-first-1,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-replace-first-2,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-replace-first-3,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-replace-first-4,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-replace-first-5,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-replace-first-all,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-replace-multi-1,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-reverse-string-1,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
functx-functx-reverse-string-2,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
functx-functx-reverse-string-all,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
functx-functx-right-trim-1,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-right-trim-2,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-right-trim-3,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-right-trim-all,Error: XPST0003: Unable to parse XPath: "deep-equal((declare namespace functx = "http://www.example.com/";                     (:~ : Trims trailing whitespace : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_right-trim.html : @param $arg the string to trim :)          declare function functx:right-trim ( $arg as xs:string? ) as xs:string { replace($arg,'\s+$','') } ;                     (functx:right-trim('xyz '), functx:right-trim(' x   xyz '), functx:right-trim('xyz'))), ("xyz", " x   xyz", "xyz"))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. deep-equal((declare [Error is around here]namespace functx = "http://www.example.com/";                     (:~ : Trims trailing whitespace : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_right-trim.html : @param $arg the string to trim :)          declare function functx:right-trim ( $arg as xs:string? ) as xs:string { replace($arg,'\s+$','') } ;                     (functx:right-trim('xyz '), functx:right-trim(' x   xyz '), functx:right-trim('xyz'))), ("xyz", " x   xyz", "xyz"))
functx-functx-sequence-type-1,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-sequence-type-2,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-sequence-type-3,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-sequence-type-4,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-sequence-type-5,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-sequence-type-6,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-sequence-type-7,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-sequence-type-8,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-sequence-type-9,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-sequence-type-10,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-sequence-type-11,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-sequence-type-all,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-sort-as-numeric-1,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of numeric values or nodes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort-as-numeric.html : @param $seq the sequence to sort :)          declare function functx:sort-as-numeric ( $seq as item()* ) as item()* { for $item in $seq order by number($item) return $item } ;                     let $in-xml := <in-xml> <f>1</f> <f>35</f> <e>4</e> </in-xml> return (functx:sort-as-numeric(('1','100','99')))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of numeric values or nodes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort-as-numeric.html : @param $seq the sequence to sort :)          declare function functx:sort-as-numeric ( $seq as item()* ) as item()* { for $item in $seq [Error is around here]order by number($item) return $item } ;                     let $in-xml := <in-xml> <f>1</f> <f>35</f> <e>4</e> </in-xml> return (functx:sort-as-numeric(('1','100','99')))
functx-functx-sort-as-numeric-2,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of numeric values or nodes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort-as-numeric.html : @param $seq the sequence to sort :)          declare function functx:sort-as-numeric ( $seq as item()* ) as item()* { for $item in $seq order by number($item) return $item } ;                     let $in-xml := <in-xml> <f>1</f> <f>35</f> <e>4</e> </in-xml> return (functx:sort-as-numeric($in-xml/*))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of numeric values or nodes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort-as-numeric.html : @param $seq the sequence to sort :)          declare function functx:sort-as-numeric ( $seq as item()* ) as item()* { for $item in $seq [Error is around here]order by number($item) return $item } ;                     let $in-xml := <in-xml> <f>1</f> <f>35</f> <e>4</e> </in-xml> return (functx:sort-as-numeric($in-xml/*))
functx-functx-sort-as-numeric-all,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of numeric values or nodes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort-as-numeric.html : @param $seq the sequence to sort :)          declare function functx:sort-as-numeric ( $seq as item()* ) as item()* { for $item in $seq order by number($item) return $item } ;          let $in-xml := <in-xml> <f>1</f> <f>35</f> <e>4</e> </in-xml>           return document{(functx:sort-as-numeric(('1','100','99')), functx:sort-as-numeric($in-xml/*))}       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of numeric values or nodes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort-as-numeric.html : @param $seq the sequence to sort :)          declare function functx:sort-as-numeric ( $seq as item()* ) as item()* { for $item in $seq [Error is around here]order by number($item) return $item } ;          let $in-xml := <in-xml> <f>1</f> <f>35</f> <e>4</e> </in-xml>           return document{(functx:sort-as-numeric(('1','100','99')), functx:sort-as-numeric($in-xml/*))}
functx-functx-sort-case-insensitive-1,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of values or nodes regardless of capitalization : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort-case-insensitive.html : @param $seq the sequence to sort :)          declare function functx:sort-case-insensitive ( $seq as item()* ) as item()* { for $item in $seq order by upper-case(string($item)) return $item } ;                     let $in-xml := <in-xml> <f>a</f> <f>c</f> <e>B</e> </in-xml> return (functx:sort-case-insensitive(('a','c','B')))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of values or nodes regardless of capitalization : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort-case-insensitive.html : @param $seq the sequence to sort :)          declare function functx:sort-case-insensitive ( $seq as item()* ) as item()* { for $item in $seq [Error is around here]order by upper-case(string($item)) return $item } ;                     let $in-xml := <in-xml> <f>a</f> <f>c</f> <e>B</e> </in-xml> return (functx:sort-case-insensitive(('a','c','B')))
functx-functx-sort-case-insensitive-2,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of values or nodes regardless of capitalization : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort-case-insensitive.html : @param $seq the sequence to sort :)          declare function functx:sort-case-insensitive ( $seq as item()* ) as item()* { for $item in $seq order by upper-case(string($item)) return $item } ;                     let $in-xml := <in-xml> <f>a</f> <f>c</f> <e>B</e> </in-xml> return (functx:sort-case-insensitive($in-xml/*))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of values or nodes regardless of capitalization : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort-case-insensitive.html : @param $seq the sequence to sort :)          declare function functx:sort-case-insensitive ( $seq as item()* ) as item()* { for $item in $seq [Error is around here]order by upper-case(string($item)) return $item } ;                     let $in-xml := <in-xml> <f>a</f> <f>c</f> <e>B</e> </in-xml> return (functx:sort-case-insensitive($in-xml/*))
functx-functx-sort-case-insensitive-all,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of values or nodes regardless of capitalization : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort-case-insensitive.html : @param $seq the sequence to sort :)          declare function functx:sort-case-insensitive ( $seq as item()* ) as item()* {              for $item in $seq order by upper-case(string($item)) return $item           } ;          let $in-xml := <in-xml> <f>a</f> <f>c</f> <e>B</e> </in-xml>           return document{(functx:sort-case-insensitive(('a','c','B')), functx:sort-case-insensitive($in-xml/*))}       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of values or nodes regardless of capitalization : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort-case-insensitive.html : @param $seq the sequence to sort :)          declare function functx:sort-case-insensitive ( $seq as item()* ) as item()* {              for $item in $seq [Error is around here]order by upper-case(string($item)) return $item           } ;          let $in-xml := <in-xml> <f>a</f> <f>c</f> <e>B</e> </in-xml>           return document{(functx:sort-case-insensitive(('a','c','B')), functx:sort-case-insensitive($in-xml/*))}
functx-functx-sort-1,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of values or nodes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort.html : @param $seq the sequence to sort :)          declare function functx:sort ( $seq as item()* ) as item()* { for $item in $seq order by $item return $item } ;                     let $in-xml := <in-xml> <f>c</f> <f>a</f> <e>b</e> </in-xml> return (functx:sort(('c','a','b')))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of values or nodes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort.html : @param $seq the sequence to sort :)          declare function functx:sort ( $seq as item()* ) as item()* { for $item in $seq [Error is around here]order by $item return $item } ;                     let $in-xml := <in-xml> <f>c</f> <f>a</f> <e>b</e> </in-xml> return (functx:sort(('c','a','b')))
functx-functx-sort-2,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of values or nodes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort.html : @param $seq the sequence to sort :)          declare function functx:sort ( $seq as item()* ) as item()* { for $item in $seq order by $item return $item } ;                     let $in-xml := <in-xml> <f>c</f> <f>a</f> <e>b</e> </in-xml> return (functx:sort($in-xml/*))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of values or nodes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort.html : @param $seq the sequence to sort :)          declare function functx:sort ( $seq as item()* ) as item()* { for $item in $seq [Error is around here]order by $item return $item } ;                     let $in-xml := <in-xml> <f>c</f> <f>a</f> <e>b</e> </in-xml> return (functx:sort($in-xml/*))
functx-functx-sort-all,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of values or nodes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort.html : @param $seq the sequence to sort :)          declare function functx:sort ( $seq as item()* ) as item()* {              for $item in $seq order by $item return $item           };          let $in-xml := <in-xml> <f>c</f> <f>a</f> <e>b</e> </in-xml>           return document{(functx:sort(('c','a','b')), functx:sort($in-xml/*))}        ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found. declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of values or nodes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort.html : @param $seq the sequence to sort :)          declare function functx:sort ( $seq as item()* ) as item()* {              for $item in $seq [Error is around here]order by $item return $item           };          let $in-xml := <in-xml> <f>c</f> <f>a</f> <e>b</e> </in-xml>           return document{(functx:sort(('c','a','b')), functx:sort($in-xml/*))}
functx-functx-substring-after-last-match-1,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-substring-after-last-match-2,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-substring-after-last-match-3,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-substring-after-last-match-all,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-substring-after-last-1,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-substring-after-last-2,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-substring-after-last-3,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-substring-after-last-all,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-substring-after-match-1,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-substring-after-match-2,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-substring-after-match-3,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-substring-after-match-all,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-substring-before-last-match-1,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-substring-before-last-match-2,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-substring-before-last-match-3,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-substring-before-last-match-all,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-substring-before-last-1,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-substring-before-last-2,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-substring-before-last-3,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-substring-before-last-all,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-time-1,Error: XPST0017: Function error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
functx-functx-time-2,Error: XPST0017: Function error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
functx-functx-time-all,Error: XPST0017: Function error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
functx-functx-timezone-from-duration-1,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-timezone-from-duration-2,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-timezone-from-duration-3,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-timezone-from-duration-all,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-trim-1,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-trim-2,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-trim-3,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-functx-trim-all,Error: XPST0003: Unable to parse XPath: "deep-equal((declare namespace functx = "http://www.example.com/";                     (:~ : Trims leading and trailing whitespace : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_trim.html : @param $arg the string to trim :)          declare function functx:trim ( $arg as xs:string? ) as xs:string { replace(replace($arg,'\s+$',''),'^\s+','') } ;                     (functx:trim(' xyz '), functx:trim(' xyz'), functx:trim('x   xyz '))), ("xyz", "xyz",  "x   xyz"))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. deep-equal((declare [Error is around here]namespace functx = "http://www.example.com/";                     (:~ : Trims leading and trailing whitespace : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_trim.html : @param $arg the string to trim :)          declare function functx:trim ( $arg as xs:string? ) as xs:string { replace(replace($arg,'\s+$',''),'^\s+','') } ;                     (functx:trim(' xyz '), functx:trim(' xyz'), functx:trim('x   xyz '))), ("xyz", "xyz",  "x   xyz"))
functx-functx-update-attributes-1,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Updates the attribute value of an XML element : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_update-attributes.html : @param $elements the element(s) for which you wish to update the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return if ($element/@*[node-name(.) = $attrName]) then attribute {$attrName} {$attrValues[$seq]} else (), $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml xmlns:new='http://new'> <a att1='def'>x</a> <b>x</b> <c new:att1='def'>x</c> </in-xml> return (functx:update-attributes( $in-xml/a, xs:QName('att1'), 123))". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Updates the attribute value of an XML element : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_update-attributes.html : @param $elements the element(s) for which you wish to update the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element [Error is around here]{ node-name($element)} { for $attrName at $seq in $attrNames return if ($element/@*[node-name(.) = $attrName]) then attribute {$attrName} {$attrValues[$seq]} else (), $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml xmlns:new='http://new'> <a att1='def'>x</a> <b>x</b> <c new:att1='def'>x</c> </in-xml> return (functx:update-attributes( $in-xml/a, xs:QName('att1'), 123))
functx-functx-update-attributes-2,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Updates the attribute value of an XML element : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_update-attributes.html : @param $elements the element(s) for which you wish to update the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return if ($element/@*[node-name(.) = $attrName]) then attribute {$attrName} {$attrValues[$seq]} else (), $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml xmlns:new='http://new'> <a att1='def'>x</a> <b>x</b> <c new:att1='def'>x</c> </in-xml> return (functx:update-attributes( $in-xml/a, (xs:QName('att1'),xs:QName('att2')), (1,2)))". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Updates the attribute value of an XML element : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_update-attributes.html : @param $elements the element(s) for which you wish to update the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element [Error is around here]{ node-name($element)} { for $attrName at $seq in $attrNames return if ($element/@*[node-name(.) = $attrName]) then attribute {$attrName} {$attrValues[$seq]} else (), $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml xmlns:new='http://new'> <a att1='def'>x</a> <b>x</b> <c new:att1='def'>x</c> </in-xml> return (functx:update-attributes( $in-xml/a, (xs:QName('att1'),xs:QName('att2')), (1,2)))
functx-functx-update-attributes-3,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Updates the attribute value of an XML element : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_update-attributes.html : @param $elements the element(s) for which you wish to update the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return if ($element/@*[node-name(.) = $attrName]) then attribute {$attrName} {$attrValues[$seq]} else (), $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml xmlns:new='http://new'> <a att1='def'>x</a> <b>x</b> <c new:att1='def'>x</c> </in-xml> return (functx:update-attributes( $in-xml/b, xs:QName('att1'), 123))". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Updates the attribute value of an XML element : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_update-attributes.html : @param $elements the element(s) for which you wish to update the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element [Error is around here]{ node-name($element)} { for $attrName at $seq in $attrNames return if ($element/@*[node-name(.) = $attrName]) then attribute {$attrName} {$attrValues[$seq]} else (), $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml xmlns:new='http://new'> <a att1='def'>x</a> <b>x</b> <c new:att1='def'>x</c> </in-xml> return (functx:update-attributes( $in-xml/b, xs:QName('att1'), 123))
functx-functx-update-attributes-4,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Updates the attribute value of an XML element : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_update-attributes.html : @param $elements the element(s) for which you wish to update the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return if ($element/@*[node-name(.) = $attrName]) then attribute {$attrName} {$attrValues[$seq]} else (), $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml xmlns:new='http://new'> <a att1='def'>x</a> <b>x</b> <c new:att1='def'>x</c> </in-xml> return (functx:update-attributes( $in-xml/c, QName('http://new','prefix:att1'), 123))". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Updates the attribute value of an XML element : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_update-attributes.html : @param $elements the element(s) for which you wish to update the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element [Error is around here]{ node-name($element)} { for $attrName at $seq in $attrNames return if ($element/@*[node-name(.) = $attrName]) then attribute {$attrName} {$attrValues[$seq]} else (), $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml xmlns:new='http://new'> <a att1='def'>x</a> <b>x</b> <c new:att1='def'>x</c> </in-xml> return (functx:update-attributes( $in-xml/c, QName('http://new','prefix:att1'), 123))
functx-functx-update-attributes-all,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";                     (:~ : Updates the attribute value of an XML element : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_update-attributes.html : @param $elements the element(s) for which you wish to update the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return if ($element/@*[node-name(.) = $attrName]) then attribute {$attrName} {$attrValues[$seq]} else (), $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml xmlns:new='http://new'> <a att1='def'>x</a> <b>x</b> <c new:att1='def'>x</c> </in-xml> return (functx:update-attributes( $in-xml/a, xs:QName('att1'), 123), functx:update-attributes( $in-xml/a, (xs:QName('att1'),xs:QName('att2')), (1,2)), functx:update-attributes( $in-xml/b, xs:QName('att1'), 123), functx:update-attributes( $in-xml/c, QName('http://new','prefix:att1'), 123))". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";                     (:~ : Updates the attribute value of an XML element : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_update-attributes.html : @param $elements the element(s) for which you wish to update the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element [Error is around here]{ node-name($element)} { for $attrName at $seq in $attrNames return if ($element/@*[node-name(.) = $attrName]) then attribute {$attrName} {$attrValues[$seq]} else (), $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml xmlns:new='http://new'> <a att1='def'>x</a> <b>x</b> <c new:att1='def'>x</c> </in-xml> return (functx:update-attributes( $in-xml/a, xs:QName('att1'), 123), functx:update-attributes( $in-xml/a, (xs:QName('att1'),xs:QName('att2')), (1,2)), functx:update-attributes( $in-xml/b, xs:QName('att1'), 123), functx:update-attributes( $in-xml/c, QName('http://new','prefix:att1'), 123))
functx-functx-value-except-1,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-value-except-2,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-value-except-3,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-value-except-4,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-value-except-all,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-value-intersect-1,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-value-intersect-2,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-value-intersect-3,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-value-intersect-4,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-value-intersect-all,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-value-union-1,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-value-union-2,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-value-union-3,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-value-union-4,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-value-union-all,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-functx-wrap-values-in-elements-1,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";          declare namespace new = "http://newns";                     (:~ : Wraps a sequence of atomic values in XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_wrap-values-in-elements.html : @param $values the values to wrap in elements : @param $elementName the name of the elements to construct :)          declare function functx:wrap-values-in-elements ( $values as xs:anyAtomicType* , $elementName as xs:QName ) as element()* { for $value in $values return element {$elementName} {$value} } ;                     (functx:wrap-values-in-elements( (1,2,3), xs:QName('num')))". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";          declare namespace new = "http://newns";                     (:~ : Wraps a sequence of atomic values in XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_wrap-values-in-elements.html : @param $values the values to wrap in elements : @param $elementName the name of the elements to construct :)          declare function functx:wrap-values-in-elements ( $values as xs:anyAtomicType* , $elementName as xs:QName ) as element()* { for $value in $values return element [Error is around here]{$elementName} {$value} } ;                     (functx:wrap-values-in-elements( (1,2,3), xs:QName('num')))
functx-functx-wrap-values-in-elements-2,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";          declare namespace new = "http://newns";                     (:~ : Wraps a sequence of atomic values in XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_wrap-values-in-elements.html : @param $values the values to wrap in elements : @param $elementName the name of the elements to construct :)          declare function functx:wrap-values-in-elements ( $values as xs:anyAtomicType* , $elementName as xs:QName ) as element()* { for $value in $values return element {$elementName} {$value} } ;                     (functx:wrap-values-in-elements( (1,2,3), xs:QName('new:num')))". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";          declare namespace new = "http://newns";                     (:~ : Wraps a sequence of atomic values in XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_wrap-values-in-elements.html : @param $values the values to wrap in elements : @param $elementName the name of the elements to construct :)          declare function functx:wrap-values-in-elements ( $values as xs:anyAtomicType* , $elementName as xs:QName ) as element()* { for $value in $values return element [Error is around here]{$elementName} {$value} } ;                     (functx:wrap-values-in-elements( (1,2,3), xs:QName('new:num')))
functx-functx-wrap-values-in-elements-3,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";          declare namespace new = "http://newns";                     (:~ : Wraps a sequence of atomic values in XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_wrap-values-in-elements.html : @param $values the values to wrap in elements : @param $elementName the name of the elements to construct :)          declare function functx:wrap-values-in-elements ( $values as xs:anyAtomicType* , $elementName as xs:QName ) as element()* { for $value in $values return element {$elementName} {$value} } ;                     (functx:wrap-values-in-elements( (1,2,3), QName('http://newns','num')))". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";          declare namespace new = "http://newns";                     (:~ : Wraps a sequence of atomic values in XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_wrap-values-in-elements.html : @param $values the values to wrap in elements : @param $elementName the name of the elements to construct :)          declare function functx:wrap-values-in-elements ( $values as xs:anyAtomicType* , $elementName as xs:QName ) as element()* { for $value in $values return element [Error is around here]{$elementName} {$value} } ;                     (functx:wrap-values-in-elements( (1,2,3), QName('http://newns','num')))
functx-functx-wrap-values-in-elements-4,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";          declare namespace new = "http://newns";                     (:~ : Wraps a sequence of atomic values in XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_wrap-values-in-elements.html : @param $values the values to wrap in elements : @param $elementName the name of the elements to construct :)          declare function functx:wrap-values-in-elements ( $values as xs:anyAtomicType* , $elementName as xs:QName ) as element()* { for $value in $values return element {$elementName} {$value} } ;                     (functx:wrap-values-in-elements( (1,2,3), QName('http://newns','new:num')))". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";          declare namespace new = "http://newns";                     (:~ : Wraps a sequence of atomic values in XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_wrap-values-in-elements.html : @param $values the values to wrap in elements : @param $elementName the name of the elements to construct :)          declare function functx:wrap-values-in-elements ( $values as xs:anyAtomicType* , $elementName as xs:QName ) as element()* { for $value in $values return element [Error is around here]{$elementName} {$value} } ;                     (functx:wrap-values-in-elements( (1,2,3), QName('http://newns','new:num')))
functx-functx-wrap-values-in-elements-all,Error: XPST0003: Unable to parse XPath: "declare namespace functx = "http://www.example.com/";          declare namespace new = "http://newns";                     (:~ : Wraps a sequence of atomic values in XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_wrap-values-in-elements.html : @param $values the values to wrap in elements : @param $elementName the name of the elements to construct :)          declare function functx:wrap-values-in-elements ( $values as xs:anyAtomicType* , $elementName as xs:QName ) as element()* { for $value in $values return element {$elementName} {$value} } ;                     (functx:wrap-values-in-elements( (1,2,3), xs:QName('num')), functx:wrap-values-in-elements( (1,2,3), xs:QName('new:num')), functx:wrap-values-in-elements( (1,2,3), QName('http://newns','num')), functx:wrap-values-in-elements( (1,2,3), QName('http://newns','new:num')))". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found. declare namespace functx = "http://www.example.com/";          declare namespace new = "http://newns";                     (:~ : Wraps a sequence of atomic values in XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_wrap-values-in-elements.html : @param $values the values to wrap in elements : @param $elementName the name of the elements to construct :)          declare function functx:wrap-values-in-elements ( $values as xs:anyAtomicType* , $elementName as xs:QName ) as element()* { for $value in $values return element [Error is around here]{$elementName} {$value} } ;                     (functx:wrap-values-in-elements( (1,2,3), xs:QName('num')), functx:wrap-values-in-elements( (1,2,3), xs:QName('new:num')), functx:wrap-values-in-elements( (1,2,3), QName('http://newns','num')), functx:wrap-values-in-elements( (1,2,3), QName('http://newns','new:num')))
functx-functx-yearMonthDuration-1,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-functx-yearMonthDuration-2,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-functx-yearMonthDuration-3,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-functx-yearMonthDuration-4,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-functx-yearMonthDuration-5,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-functx-yearMonthDuration-6,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-functx-yearMonthDuration-7,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-functx-yearMonthDuration-all,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
functx-functx-yyyyddmm-to-date-1,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-yyyyddmm-to-date-2,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-yyyyddmm-to-date-3,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-yyyyddmm-to-date-all,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-yyyymmdd-to-date-1,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-yyyymmdd-to-date-2,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-yyyymmdd-to-date-3,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-functx-yyyymmdd-to-date-all,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
UseCaseCompoundValues-001,Error: XPST0003: Unable to parse XPath: "deep-equal((         declare namespace i = "http://example.com/compound-values";         declare function i:complex($real as xs:double, $imaginary as xs:double) as map(xs:boolean, xs:double)         {           map { true() : $real, false() : $imaginary }         };                  declare function i:real($complex as map(xs:boolean, xs:double)) as xs:double         {           $complex(true())         };                  declare function i:imaginary($complex as map(xs:boolean, xs:double)) as xs:double         {           $complex(false())         };                  declare function i:add($arg1 as map(xs:boolean, xs:double), $arg2 as map(xs:boolean, xs:double)) as map(xs:boolean, xs:double){           i:complex(i:real($arg1)+i:real($arg2),             i:imaginary($arg1)+i:imaginary($arg2))         };                  declare function i:multiply($arg1 as map(xs:boolean, xs:double), $arg2 as map(xs:boolean, xs:double)) as map(xs:boolean, xs:double)         {           i:complex(             i:real($arg1)*i:real($arg2) - i:imaginary($arg1)*i:imaginary($arg2),             i:real($arg1)*i:imaginary($arg2) + i:imaginary($arg1)*i:real($arg2))         };                  i:add(i:complex(2, 3), i:complex(1, -6)),         i:multiply(i:complex(2, -1), i:complex(3, 4))       ), ((map {true() : 3, false() : -3}, map {true() : 10, false() : 5})))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. deep-equal((         declare [Error is around here]namespace i = "http://example.com/compound-values";         declare function i:complex($real as xs:double, $imaginary as xs:double) as map(xs:boolean, xs:double)         {           map { true() : $real, false() : $imaginary }         };                  declare function i:real($complex as map(xs:boolean, xs:double)) as xs:double         {           $complex(true())         };                  declare function i:imaginary($complex as map(xs:boolean, xs:double)) as xs:double         {           $complex(false())         };                  declare function i:add($arg1 as map(xs:boolean, xs:double), $arg2 as map(xs:boolean, xs:double)) as map(xs:boolean, xs:double){           i:complex(i:real($arg1)+i:real($arg2),             i:imaginary($arg1)+i:imaginary($arg2))         };                  declare function i:multiply($arg1 as map(xs:boolean, xs:double), $arg2 as map(xs:boolean, xs:double)) as map(xs:boolean, xs:double)         {           i:complex(             i:real($arg1)*i:real($arg2) - i:imaginary($arg1)*i:imaginary($arg2),             i:real($arg1)*i:imaginary($arg2) + i:imaginary($arg1)*i:real($arg2))         };                  i:add(i:complex(2, 3), i:complex(1, -6)),         i:multiply(i:complex(2, -1), i:complex(3, 4))       ), ((map {true() : 3, false() : -3}, map {true() : 10, false() : 5})))
UseCaseJSON-001,Error: XPST0003: Unable to parse XPath: "json-doc("mildred.json")?phone?*[?type = 'mobile']?number". Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "?" found. json-doc("mildred.json")?phone?*[[Error is around here]?type = 'mobile']?number
UseCaseJSON-002,AssertionError: Expected executing the XPath "         declare namespace array="http://www.w3.org/2005/xpath-functions/array";         declare namespace map="http://www.w3.org/2005/xpath-functions/map";         let $input := json-doc('employees.json') 				for $k in map:keys($input) 				return  				  <department name="{$k}">{ 				    let $array := $input($k) 				    for $i in 1 to array:size($array) 				    let $emp := $array($i) 				    return 				      <employee> 				        <firstName>{ $emp('firstName') }</firstName> 				        <lastName>{ $emp('lastName') }</lastName> 				        <age>{ $emp('age') }</age> 				      </employee> 				  }</department>		  " to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "         declare namespace array="http://www.w3.org/2005/xpath-functions/array";         declare namespace map="http://www.w3.org/2005/xpath-functions/map";         let $input := json-doc('employees.json') 				for $k in map:keys($input) 				return  				  <department name="{$k}">{ 				    let $array := $input($k) 				    for $i in 1 to array:size($array) 				    let $emp := $array($i) 				    return 				      <employee> 				        <firstName>{ $emp('firstName') }</firstName> 				        <lastName>{ $emp('lastName') }</lastName> 				        <age>{ $emp('age') }</age> 				      </employee> 				  }</department>		  ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found.          declare namespace array="http://www.w3.org/2005/xpath-functions/array";         declare namespace map="http://www.w3.org/2005/xpath-functions/map";         let $input := json-doc('employees.json') 				[Error is around here]for $k in map:keys($input) 				return  				  <department name="{$k}">{ 				    let $array := $input($k) 				    for $i in 1 to array:size($array) 				    let $emp := $array($i) 				    return 				      <employee> 				        <firstName>{ $emp('firstName') }</firstName> 				        <lastName>{ $emp('lastName') }</lastName> 				        <age>{ $emp('age') }</age> 				      </employee> 				  }</department>		  , Error: XPST0003: Unable to parse XPath: "         declare namespace array="http://www.w3.org/2005/xpath-functions/array";         declare namespace map="http://www.w3.org/2005/xpath-functions/map";         let $input := json-doc('employees.json') 				for $k in map:keys($input) 				return  				  <department name="{$k}">{ 				    let $array := $input($k) 				    for $i in 1 to array:size($array) 				    let $emp := $array($i) 				    return 				      <employee> 				        <firstName>{ $emp('firstName') }</firstName> 				        <lastName>{ $emp('lastName') }</lastName> 				        <age>{ $emp('age') }</age> 				      </employee> 				  }</department>		  ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found.          declare namespace array="http://www.w3.org/2005/xpath-functions/array";         declare namespace map="http://www.w3.org/2005/xpath-functions/map";         let $input := json-doc('employees.json') 				[Error is around here]for $k in map:keys($input) 				return  				  <department name="{$k}">{ 				    let $array := $input($k) 				    for $i in 1 to array:size($array) 				    let $emp := $array($i) 				    return 				      <employee> 				        <firstName>{ $emp('firstName') }</firstName> 				        <lastName>{ $emp('lastName') }</lastName> 				        <age>{ $emp('age') }</age> 				      </employee> 				  }</department>		  .
UseCaseJSON-003,Error: XPST0003: Unable to parse XPath: "deep-equal((         declare namespace map="http://www.w3.org/2005/xpath-functions/map"; 				declare function local:deep-put($input as item()*, $key as xs:string, $value as item()*) as item()* { 				   for $i in $input return 				     if ($i instance of map(*)) 				     then map:merge(map:for-each($i, function($k, $v) { 				                                             if ($k eq $key) then map{$k : $value} else map{$k : local:deep-put($v, $key, $value)} })) 				      else if ($i instance of array(*)) 				     then array{ local:deep-put($i?*, $key, $value) } 				      else $i 				}; 				local:deep-put(json-doc("bookinfo.json"), "first", "John")		   		  ), (map {"book" : map {"title" : "Data on the Web", "year" : 2000, "author" : [map {"last" : "Abiteboul", "first" : "John"}, map {"last" : "Buneman", "first" : "John"}, map {"last" : "Suciu", "first" : "John"}], "publisher" : "Morgan Kaufmann Publishers", "price" : 39.95}}))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. deep-equal((         declare [Error is around here]namespace map="http://www.w3.org/2005/xpath-functions/map"; 				declare function local:deep-put($input as item()*, $key as xs:string, $value as item()*) as item()* { 				   for $i in $input return 				     if ($i instance of map(*)) 				     then map:merge(map:for-each($i, function($k, $v) { 				                                             if ($k eq $key) then map{$k : $value} else map{$k : local:deep-put($v, $key, $value)} })) 				      else if ($i instance of array(*)) 				     then array{ local:deep-put($i?*, $key, $value) } 				      else $i 				}; 				local:deep-put(json-doc("bookinfo.json"), "first", "John")		   		  ), (map {"book" : map {"title" : "Data on the Web", "year" : 2000, "author" : [map {"last" : "Abiteboul", "first" : "John"}, map {"last" : "Buneman", "first" : "John"}, map {"last" : "Suciu", "first" : "John"}], "publisher" : "Morgan Kaufmann Publishers", "price" : 39.95}}))
UseCaseJSON-004,Error: XPST0003: Unable to parse XPath: "         let $users := json-doc('users.json')?*         for $sarah in $users, $friend in $users         where $sarah?name = "Sarah" and $friend?name = $sarah?friends          return $friend?name 		  ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found.          let $users := json-doc('users.json')?*         [Error is around here]for $sarah in $users, $friend in $users         where $sarah?name = "Sarah" and $friend?name = $sarah?friends          return $friend?name
UseCaseJSON-005,Error: XPST0003: Unable to parse XPath: "deep-equal((         declare namespace map="http://www.w3.org/2005/xpath-functions/map";         let $products := json-doc('sales.json')?*         return map:merge((           for $sales in $products           let $pname := $sales?product           group by $pname           return map { $pname : sum(for $s in $sales return $s?quantity) }         ))     		  ), (map { "broiler" : 20, "toaster" : 200, "blender" : 250, "socks" : 510, "shirt" : 10 }))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. deep-equal((         declare [Error is around here]namespace map="http://www.w3.org/2005/xpath-functions/map";         let $products := json-doc('sales.json')?*         return map:merge((           for $sales in $products           let $pname := $sales?product           group by $pname           return map { $pname : sum(for $s in $sales return $s?quantity) }         ))     		  ), (map { "broiler" : 20, "toaster" : 200, "blender" : 250, "socks" : 510, "shirt" : 10 }))
UseCaseJSON-006,Error: XPST0003: Unable to parse XPath: "deep-equal((         declare namespace map="http://www.w3.org/2005/xpath-functions/map"; 				array { 				  for $store in json-doc('stores.json')?* 				  let $state := $store?state 				  group by $state 				  order by $state 				  return 				    map { 				      $state :  array { 				        for $product in json-doc('products.json')?* 				        let $category := $product?category 				        group by $category 				        order by $category 				        return 				          map { 				            $category :  map:merge(( 				              for $sales in json-doc('sales.json')?* 				              where $sales?("store number") = $store?("store number") and $sales?product = $product?name 				              let $pname := $sales?product 				              group by $pname 				              order by $pname 				              return map { $pname :  sum(for $s in $sales return $s?quantity)} 				            )) 				          } 				      } 				   } 				} 		  ), ([map { "CA" : [ map { "clothes" : map { "socks" : 510 }}, map { "kitchen" : map { "broiler" : 20, "toaster" : 150 }} ] }, map { "MA" : [ map { "clothes" : map { "shirt" : 10 }}, map { "kitchen" : map { "toaster" : 50, "blender" : 250 }}]}]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. deep-equal((         declare [Error is around here]namespace map="http://www.w3.org/2005/xpath-functions/map"; 				array { 				  for $store in json-doc('stores.json')?* 				  let $state := $store?state 				  group by $state 				  order by $state 				  return 				    map { 				      $state :  array { 				        for $product in json-doc('products.json')?* 				        let $category := $product?category 				        group by $category 				        order by $category 				        return 				          map { 				            $category :  map:merge(( 				              for $sales in json-doc('sales.json')?* 				              where $sales?("store number") = $store?("store number") and $sales?product = $product?name 				              let $pname := $sales?product 				              group by $pname 				              order by $pname 				              return map { $pname :  sum(for $s in $sales return $s?quantity)} 				            )) 				          } 				      } 				   } 				} 		  ), ([map { "CA" : [ map { "clothes" : map { "socks" : 510 }}, map { "kitchen" : map { "broiler" : 20, "toaster" : 150 }} ] }, map { "MA" : [ map { "clothes" : map { "shirt" : 10 }}, map { "kitchen" : map { "toaster" : 50, "blender" : 250 }}]}]))
UseCaseJSON-007,AssertionError: Expected executing the XPath "         let $sats := json-doc("satellites.json")("satellites")         return map { "visible" : array { map:keys($sats)[$sats(.)("visible")] }, "invisible" : array { map:keys($sats)[not($sats(.)("visible"))] } } 		  " to resolve to one of the expected results, but got Error: XPST0017: Function json-doc with arity of 1 not registered. No similar functions found., Error: XPST0017: Function json-doc with arity of 1 not registered. No similar functions found..
UseCaseJSON-008,Error: XPST0017: Function doc with arity of 1 not registered. No similar functions found.
UseCaseJSON-009,Error: XPST0003: Unable to parse XPath: "            declare namespace array="http://www.w3.org/2005/xpath-functions/array";         declare variable $data := map {           "color" : "blue",           "closed" : true(),           "points" : [[10,10], [20,10], [20,20], [10,20]]         };               declare variable $stroke := attribute stroke { $data("color") };         declare variable $points := attribute points { array:flatten($data("points")) };         if ($data("closed")) then <svg><polygon>{ $stroke, $points }</polygon></svg>          else <svg><polyline>{ $stroke, $points }</polyline></svg> 		  ". Expected "!", "!=", "(", "*", "+", "-", "/", "//", ";", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "s" found.             declare namespace array="http://www.w3.org/2005/xpath-functions/array";         declare variable $data := map {           "color" : "blue",           "closed" : true(),           "points" : [[10,10], [20,10], [20,20], [10,20]]         };               declare variable $stroke := attribute [Error is around here]stroke { $data("color") };         declare variable $points := attribute points { array:flatten($data("points")) };         if ($data("closed")) then <svg><polygon>{ $stroke, $points }</polygon></svg>          else <svg><polyline>{ $stroke, $points }</polyline></svg>
UseCaseJSON-010,Error: XPST0003: Unable to parse XPath: "         <html> 				  <body>				 				    <table> 				      <tr>  				         { (: Column headings :)  				            <th> </th>, 				            for $th in json-doc("table.json")("col labels")?* 				            return <th>{ $th }</th> 				         } 				      </tr> 				      {  (: Data for each row :) 				         for $r at $i in json-doc("table.json")("data")?* 				         return 				            <tr> 				             { 				               <th>{ json-doc("table.json")("row labels")[$i] }</th>, 				               for $c in $r?* 				               return <td>{ $c }</td> 				             } 				            </tr> 				      } 				    </table>				 				  </body> 				</html>    		  ". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.          <html> 				  <body>				 				    <table> 				      <tr>  				         { (: Column headings :)  				            <th> </th>, 				            for $th in json-doc("table.json")("col labels")?* 				            return <th>{ $th }</th> 				         } 				      </tr> 				      {  (: Data for each row :) 				         for $r [Error is around here]at $i in json-doc("table.json")("data")?* 				         return 				            <tr> 				             { 				               <th>{ json-doc("table.json")("row labels")[$i] }</th>, 				               for $c in $r?* 				               return <td>{ $c }</td> 				             } 				            </tr> 				      } 				    </table>				 				  </body> 				</html>
UseCaseJSON-011,Error: XPST0003: Unable to parse XPath: "         <table>{           for tumbling window $w in json-doc("colors.json")?*           start at $x when fn:true()           end at $y when $y - $x = 2           return             <tr>{ for $i in $w return <td>{ $i?color }</td> }</tr>          }</table> 		  ". Expected " ", "!", "!=", "$", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "t" found.          <table>{           for [Error is around here]tumbling window $w in json-doc("colors.json")?*           start at $x when fn:true()           end at $y when $y - $x = 2           return             <tr>{ for $i in $w return <td>{ $i?color }</td> }</tr>          }</table>
UseCaseJSON-012,Error: XPST0003: Unable to parse XPath: "deep-equal((         let $users := [map { "userid" : "W0342", "firstname" : "Walter", "lastname" : "Denisovich" }, map { "userid" : "M0535", "firstname" : "Mick", "lastname" : "Goulish" }]?*          let $holdings := [map { "userid" : "W0342", "ticker" : "DIS", "shares" : 153212312 }, map { "userid" : "M0535", "ticker" : "DIS", "shares" : 10 }, map { "userid" : "M0535", "ticker" : "AIG", "shares" : 23412 }]?*            return array {           for $u in $users           order by $u("userid")           return map { "userid" : $u("userid"),                         "first" :  $u("firstname"),                         "last" :   $u("lastname"),                         "holdings" : array {                           for $h in $holdings                           where $h("userid") = $u("userid")                           order by $h("ticker") 									        return map { "ticker" : $h("ticker"), "share" : $h("shares") } 										    }                  }         }        		  ), ([map {"userid" : "M0535", "first" : "Mick", "last" : "Goulish", "holdings" : [map {"ticker" : "AIG", "share" : 23412}, map {"ticker" : "DIS", "share" : 10}]}, map {"userid" : "W0342", "first" : "Walter", "last" : "Denisovich", "holdings" : [map {"ticker" : "DIS", "share" : 153212312}]}]))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. deep-equal((         let $users := [map { "userid" : "W0342", "firstname" : "Walter", "lastname" : "Denisovich" }, map { "userid" : "M0535", "firstname" : "Mick", "lastname" : "Goulish" }]?*          [Error is around here]let $holdings := [map { "userid" : "W0342", "ticker" : "DIS", "shares" : 153212312 }, map { "userid" : "M0535", "ticker" : "DIS", "shares" : 10 }, map { "userid" : "M0535", "ticker" : "AIG", "shares" : 23412 }]?*            return array {           for $u in $users           order by $u("userid")           return map { "userid" : $u("userid"),                         "first" :  $u("firstname"),                         "last" :   $u("lastname"),                         "holdings" : array {                           for $h in $holdings                           where $h("userid") = $u("userid")                           order by $h("ticker") 									        return map { "ticker" : $h("ticker"), "share" : $h("shares") } 										    }                  }         }        		  ), ([map {"userid" : "M0535", "first" : "Mick", "last" : "Goulish", "holdings" : [map {"ticker" : "AIG", "share" : 23412}, map {"ticker" : "DIS", "share" : 10}]}, map {"userid" : "W0342", "first" : "Walter", "last" : "Denisovich", "holdings" : [map {"ticker" : "DIS", "share" : 153212312}]}]))
UseCaseJSON-014,Error: No selector counterpart for: lookup.
UseCaseNLP-001,Error: No selector counterpart for: lookup.
UseCaseNLP-002,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
UseCaseNLP-003,Error: No selector counterpart for: lookup.
UseCaseNLP-004,Error: XPST0003: Unable to parse XPath: "                    for $word in json-doc('speech-representation.json')?*           let $pos := $word(2)           let $lexeme := $word(1)           where $pos = ("JJ", "NN", "RB", "VB")           group by $pos           order by $pos           return              <pos name="{$pos}">               {                  for $l in distinct-values($lexeme)                 return <lexeme>{ $l }</lexeme>               }             </pos>                ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.                     for $word in json-doc('speech-representation.json')?*           [Error is around here]let $pos := $word(2)           let $lexeme := $word(1)           where $pos = ("JJ", "NN", "RB", "VB")           group by $pos           order by $pos           return              <pos name="{$pos}">               {                  for $l in distinct-values($lexeme)                 return <lexeme>{ $l }</lexeme>               }             </pos>
UseCaseNLP-005,Error: XPST0003: Unable to parse XPath: "deep-equal((                    declare function local:words-only($s)           {             for $w in $s             where not($w(2) = (".", ",", ";", ":"))             return $w(1)           };                      for sliding window $w in local:words-only(json-doc('speech-representation.json')?*)               start at $i when true()               only end at $j when $j - $i eq 2           return                array { $w }                ), (                         ([ "A", "bride", "you" ],              [ "bride", "you", "know" ],              [ "you", "know", "must" ],              [ "know", "must", "appear" ],              [ "must", "appear", "like" ],              [ "appear", "like", "a" ],              [ "like", "a", "bride" ],              [ "a", "bride", "but" ],              [ "bride", "but", "my" ],              [ "but", "my", "natural" ],              [ "my", "natural", "taste" ],              [ "natural", "taste", "is" ],              [ "taste", "is", "all" ],              [ "is", "all", "for" ],              [ "all", "for", "simplicity" ],              [ "for", "simplicity", "a" ],              [ "simplicity", "a", "simple" ],              [ "a", "simple", "style" ],              [ "simple", "style", "of" ],              [ "style", "of", "dress" ],              [ "of", "dress", "is" ],              [ "dress", "is", "so" ],              [ "is", "so", "infinitely" ],              [ "so", "infinitely", "preferable" ],              [ "infinitely", "preferable", "to" ],              [ "preferable", "to", "finery" ])                    ))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found. deep-equal((                    declare [Error is around here]function local:words-only($s)           {             for $w in $s             where not($w(2) = (".", ",", ";", ":"))             return $w(1)           };                      for sliding window $w in local:words-only(json-doc('speech-representation.json')?*)               start at $i when true()               only end at $j when $j - $i eq 2           return                array { $w }                ), (                         ([ "A", "bride", "you" ],              [ "bride", "you", "know" ],              [ "you", "know", "must" ],              [ "know", "must", "appear" ],              [ "must", "appear", "like" ],              [ "appear", "like", "a" ],              [ "like", "a", "bride" ],              [ "a", "bride", "but" ],              [ "bride", "but", "my" ],              [ "but", "my", "natural" ],              [ "my", "natural", "taste" ],              [ "natural", "taste", "is" ],              [ "taste", "is", "all" ],              [ "is", "all", "for" ],              [ "all", "for", "simplicity" ],              [ "for", "simplicity", "a" ],              [ "simplicity", "a", "simple" ],              [ "a", "simple", "style" ],              [ "simple", "style", "of" ],              [ "style", "of", "dress" ],              [ "of", "dress", "is" ],              [ "dress", "is", "so" ],              [ "is", "so", "infinitely" ],              [ "so", "infinitely", "preferable" ],              [ "infinitely", "preferable", "to" ],              [ "preferable", "to", "finery" ])                    ))
UseCaseNLP-006a,Error: XPST0003: Unable to parse XPath: "deep-equal((                    declare function local:filter($s as item()*, $p as function(item()) as xs:boolean)           {             array { $s[$p(.)] },   array { $s[not($p(.))] }           };                      let $f := function($a) { starts-with($a(2), "VB") }           return             local:filter(json-doc('speech-representation.json')?*, $f)			                  ), (                         [["know", "VBP"], ["appear", "VB"], ["is", "VBZ"], ["is", "VBZ"], ["finery", "VB"]],              [["A", "DT"], ["bride", "NN"], [",", ","], ["you", "PRP"], [",", ","], ["must", "MD"],                ["like", "IN"], ["a", "DT"], ["bride", "NN"], [",", ","], ["but", "CC"], ["my", "PRP$"],                ["natural", "JJ"], ["taste", "NN"], ["all", "DT"], ["for", "IN"], ["simplicity", "NN"],                [";", ":"], ["a", "DT"], ["simple", "JJ"], ["style", "NN"], ["of", "IN"], ["dress", "NN"],                ["so", "RB"], ["infinitely", "RB"], ["preferable", "JJ"], ["to", "TO"], [".", "."]]                    ))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found. deep-equal((                    declare [Error is around here]function local:filter($s as item()*, $p as function(item()) as xs:boolean)           {             array { $s[$p(.)] },   array { $s[not($p(.))] }           };                      let $f := function($a) { starts-with($a(2), "VB") }           return             local:filter(json-doc('speech-representation.json')?*, $f)			                  ), (                         [["know", "VBP"], ["appear", "VB"], ["is", "VBZ"], ["is", "VBZ"], ["finery", "VB"]],              [["A", "DT"], ["bride", "NN"], [",", ","], ["you", "PRP"], [",", ","], ["must", "MD"],                ["like", "IN"], ["a", "DT"], ["bride", "NN"], [",", ","], ["but", "CC"], ["my", "PRP$"],                ["natural", "JJ"], ["taste", "NN"], ["all", "DT"], ["for", "IN"], ["simplicity", "NN"],                [";", ":"], ["a", "DT"], ["simple", "JJ"], ["style", "NN"], ["of", "IN"], ["dress", "NN"],                ["so", "RB"], ["infinitely", "RB"], ["preferable", "JJ"], ["to", "TO"], [".", "."]]                    ))
UseCaseNLP-006b,Error: XPST0003: Unable to parse XPath: "deep-equal((                    declare function local:filter($s as item()*, $p as function(item()) as xs:boolean)           {            map {               true() : array { $s[$p(.)] },                  false() : array { $s[not($p(.))] }             }           };					           let $f := function($a) { starts-with($a(2), "VB") }           return             local:filter(json-doc('speech-representation.json')?*, $f)   			   			), (                           map {                true() :                           [ [ "know", "VBP" ], [ "appear", "VB" ], [ "is", "VBZ" ],                            ["is", "VBZ" ], [ "finery", "VB" ] ],                              false() :                                           [ [ "A", "DT" ], ["bride", "NN" ], [ ",", "," ],                             [ "you", "PRP" ], [ ",", "," ], [ "must", "MD" ],                             [ "like", "IN" ], [ "a", "DT" ], [ "bride", "NN" ],                             [ ",", "," ], [ "but", "CC" ], [ "my", "PRP$" ],                             [ "natural", "JJ" ], [ "taste", "NN" ], [ "all", "DT"],                            [ "for", "IN" ], [ "simplicity", "NN" ], [ ";", ":" ],                            [ "a", "DT" ], [ "simple", "JJ" ], [ "style", "NN" ],                             [ "of", "IN" ], [ "dress", "NN" ], [ "so", "RB" ],                             [ "infinitely", "RB" ], [ "preferable", "JJ" ],                             [ "to", "TO" ], [ ".", "." ] ]                }                    ))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found. deep-equal((                    declare [Error is around here]function local:filter($s as item()*, $p as function(item()) as xs:boolean)           {            map {               true() : array { $s[$p(.)] },                  false() : array { $s[not($p(.))] }             }           };					           let $f := function($a) { starts-with($a(2), "VB") }           return             local:filter(json-doc('speech-representation.json')?*, $f)   			   			), (                           map {                true() :                           [ [ "know", "VBP" ], [ "appear", "VB" ], [ "is", "VBZ" ],                            ["is", "VBZ" ], [ "finery", "VB" ] ],                              false() :                                           [ [ "A", "DT" ], ["bride", "NN" ], [ ",", "," ],                             [ "you", "PRP" ], [ ",", "," ], [ "must", "MD" ],                             [ "like", "IN" ], [ "a", "DT" ], [ "bride", "NN" ],                             [ ",", "," ], [ "but", "CC" ], [ "my", "PRP$" ],                             [ "natural", "JJ" ], [ "taste", "NN" ], [ "all", "DT"],                            [ "for", "IN" ], [ "simplicity", "NN" ], [ ";", ":" ],                            [ "a", "DT" ], [ "simple", "JJ" ], [ "style", "NN" ],                             [ "of", "IN" ], [ "dress", "NN" ], [ "so", "RB" ],                             [ "infinitely", "RB" ], [ "preferable", "JJ" ],                             [ "to", "TO" ], [ ".", "." ] ]                }                    ))
ns-queries-results-q1,AssertionError: Skipped test, it was a assert-permutation
ns-queries-results-q7,Error: XPST0003: Unable to parse XPath: "         declare namespace ma = "http://www.example.com/AuctionWatch";          <Q7 xmlns:xlink="http://www.w3.org/1999/xlink"> {              for $a in //ma:Auction              let $seller_id := $a/ma:Trading_Partners/ma:Seller/*:ID,                  $buyer_id := $a/ma:Trading_Partners/ma:High_Bidder/*:ID              where namespace-uri(exactly-one($seller_id)) = namespace-uri($buyer_id)              return $a/ma:AuctionHomepage } </Q7>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.          declare namespace ma = "http://www.example.com/AuctionWatch";          <Q7 xmlns:xlink="http://www.w3.org/1999/xlink"> {              for $a in //ma:Auction              [Error is around here]let $seller_id := $a/ma:Trading_Partners/ma:Seller/*:ID,                  $buyer_id := $a/ma:Trading_Partners/ma:High_Bidder/*:ID              where namespace-uri(exactly-one($seller_id)) = namespace-uri($buyer_id)              return $a/ma:AuctionHomepage } </Q7>
ns-queries-results-q8,Error: XPST0003: Unable to parse XPath: "         declare namespace ma = "http://www.example.com/AuctionWatch";          <Q8 xmlns:ma="http://www.example.com/AuctionWatch"              xmlns:eachbay="http://www.example.com/auctioneers#eachbay"              xmlns:xlink="http://www.w3.org/1999/xlink"> {                  for $s in //ma:Trading_Partners/(ma:Seller | ma:High_Bidder)                  where $s/*:NegativeComments = 0                  return $s } </Q8>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.          declare namespace ma = "http://www.example.com/AuctionWatch";          <Q8 xmlns:ma="http://www.example.com/AuctionWatch"              xmlns:eachbay="http://www.example.com/auctioneers#eachbay"              xmlns:xlink="http://www.w3.org/1999/xlink"> {                  for $s in //ma:Trading_Partners/(ma:Seller | ma:High_Bidder)                  [Error is around here]where $s/*:NegativeComments = 0                  return $s } </Q8>
parts-queries-results-q1,AssertionError: Expected executing the XPath "         declare variable $input-context := .;         declare function local:one_level($p as element()) as element() {              <part partid="{ $p/@partid }" name="{ $p/@name }" > {                  for $s in ($input-context//part)                 where $s/@partof = $p/@partid                  return local:one_level($s) } </part> };          <parttree> { for $p in //part[empty(@partof)]                       return local:one_level($p) } </parttree>       " to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "         declare variable $input-context := .;         declare function local:one_level($p as element()) as element() {              <part partid="{ $p/@partid }" name="{ $p/@name }" > {                  for $s in ($input-context//part)                 where $s/@partof = $p/@partid                  return local:one_level($s) } </part> };          <parttree> { for $p in //part[empty(@partof)]                       return local:one_level($p) } </parttree>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.          declare variable $input-context := .;         declare function local:one_level($p as element()) as element() {              <part partid="{ $p/@partid }" name="{ $p/@name }" > {                  for $s in ($input-context//part)                 [Error is around here]where $s/@partof = $p/@partid                  return local:one_level($s) } </part> };          <parttree> { for $p in //part[empty(@partof)]                       return local:one_level($p) } </parttree>       , AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "\n        declare variable $input-context := .;\n        declare function local:one_level($p as element()) as element() { \n            <part partid="{ $p/@partid }" name="{ $p/@name }" > { \n                for $s in ($input-context//part)\n                where $s/@partof = $p/@partid \n                return local:one_level($s) } </part> }; \n        <parttree> { for $p in //part[empty(@partof)] \n                     return local:one_level($p) } </parttree>\n      ".\nExpected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.\n\n        declare variable $input-context := .;\n        declare function local:one_level($p as element()) as element() { \n            <part partid="{ $p/@partid }" name="{ $p/@name }" > { \n                for $s in ($input-context//part)\n                [Error is around here]where $s/@partof = $p/@partid \n                return local:one_level($s) } </part> }; \n        <parttree> { for $p in //part[empty(@partof)] \n                     return local:one_level($p) } </parttree>\n      '.
rdb-queries-results-q1,Error: XPST0003: Unable to parse XPath: "         <result> {              for $i in $items//item_tuple              where $i/start_date <= xs:date("1999-01-31")                  and $i/end_date >= xs:date("1999-01-31")                  and contains(exactly-one($i/description), "Bicycle")              order by $i/itemno              return <item_tuple> { $i/itemno } { $i/description } </item_tuple> }          </result>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.          <result> {              for $i in $items//item_tuple              [Error is around here]where $i/start_date <= xs:date("1999-01-31")                  and $i/end_date >= xs:date("1999-01-31")                  and contains(exactly-one($i/description), "Bicycle")              order by $i/itemno              return <item_tuple> { $i/itemno } { $i/description } </item_tuple> }          </result>
rdb-queries-results-q2,Error: XPST0003: Unable to parse XPath: "         <result> {              for $i in $items//item_tuple              let $b := $bids//bid_tuple[itemno = $i/itemno]              where contains(exactly-one($i/description), "Bicycle")              order by $i/itemno              return <item_tuple> { $i/itemno } { $i/description } <high_bid>{ max($b/bid) }</high_bid> </item_tuple> }          </result>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.          <result> {              for $i in $items//item_tuple              [Error is around here]let $b := $bids//bid_tuple[itemno = $i/itemno]              where contains(exactly-one($i/description), "Bicycle")              order by $i/itemno              return <item_tuple> { $i/itemno } { $i/description } <high_bid>{ max($b/bid) }</high_bid> </item_tuple> }          </result>
rdb-queries-results-q3,Error: XPST0003: Unable to parse XPath: "         <result> {              for $u in $users//user_tuple              for $i in $items//item_tuple              where $u/rating > "C" and $i/reserve_price > 1000 and $i/offered_by = $u/userid              return <warning> { $u/name } { $u/rating } { $i/description } { $i/reserve_price } </warning> }          </result>      ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found.          <result> {              for $u in $users//user_tuple              [Error is around here]for $i in $items//item_tuple              where $u/rating > "C" and $i/reserve_price > 1000 and $i/offered_by = $u/userid              return <warning> { $u/name } { $u/rating } { $i/description } { $i/reserve_price } </warning> }          </result>
rdb-queries-results-q4,Error: XPST0003: Unable to parse XPath: "         <result> {              for $i in $items//item_tuple              where empty ($bids//bid_tuple[itemno = $i/itemno])              return <no_bid_item> { $i/itemno } { $i/description } </no_bid_item>          } </result>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.          <result> {              for $i in $items//item_tuple              [Error is around here]where empty ($bids//bid_tuple[itemno = $i/itemno])              return <no_bid_item> { $i/itemno } { $i/description } </no_bid_item>          } </result>
rdb-queries-results-q5,Error: XPST0003: Unable to parse XPath: "         <result> {              unordered (                  for $seller in $users//user_tuple,                      $buyer in $users//user_tuple,                      $item in $items//item_tuple,                      $highbid in $bids//bid_tuple                  where $seller/name = "Tom Jones"                    and $seller/userid = $item/offered_by                    and contains(exactly-one($item/description), "Bicycle")                    and $item/itemno = $highbid/itemno                    and $highbid/userid = $buyer/userid                    and $highbid/bid = max( $bids//bid_tuple [itemno = $item/itemno]/bid )                  return <jones_bike> { $item/itemno } { $item/description }                          <high_bid>{ $highbid/bid }</high_bid>                          <high_bidder>{ $buyer/name }</high_bidder>                         </jones_bike> )          } </result>      ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.          <result> {              unordered (                  for $seller in $users//user_tuple,                      $buyer in $users//user_tuple,                      $item in $items//item_tuple,                      $highbid in $bids//bid_tuple                  [Error is around here]where $seller/name = "Tom Jones"                    and $seller/userid = $item/offered_by                    and contains(exactly-one($item/description), "Bicycle")                    and $item/itemno = $highbid/itemno                    and $highbid/userid = $buyer/userid                    and $highbid/bid = max( $bids//bid_tuple [itemno = $item/itemno]/bid )                  return <jones_bike> { $item/itemno } { $item/description }                          <high_bid>{ $highbid/bid }</high_bid>                          <high_bidder>{ $buyer/name }</high_bidder>                         </jones_bike> )          } </result>
rdb-queries-results-q6,Error: XPST0003: Unable to parse XPath: "         <result> {              for $item in $items//item_tuple              let $b := $bids//bid_tuple[itemno = $item/itemno]              let $z := max($b/bid)              where exactly-one($item/reserve_price) * 2 < $z              return <successful_item> { $item/itemno } { $item/description } { $item/reserve_price }                      <high_bid>{$z }</high_bid>                     </successful_item>          } </result>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.          <result> {              for $item in $items//item_tuple              [Error is around here]let $b := $bids//bid_tuple[itemno = $item/itemno]              let $z := max($b/bid)              where exactly-one($item/reserve_price) * 2 < $z              return <successful_item> { $item/itemno } { $item/description } { $item/reserve_price }                      <high_bid>{$z }</high_bid>                     </successful_item>          } </result>
rdb-queries-results-q7,Error: XPST0003: Unable to parse XPath: "         let $allbikes := $items//item_tuple [contains(exactly-one(description), "Bicycle") or contains(exactly-one(description), "Tricycle")]          let $bikebids := $bids//bid_tuple[itemno = $allbikes/itemno]          return <high_bid> { max($bikebids/bid) } </high_bid>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "[" found.          let $allbikes := $items//item_tuple [Error is around here][contains(exactly-one(description), "Bicycle") or contains(exactly-one(description), "Tricycle")]          let $bikebids := $bids//bid_tuple[itemno = $allbikes/itemno]          return <high_bid> { max($bikebids/bid) } </high_bid>
rdb-queries-results-q8,Error: XPST0003: Unable to parse XPath: "         let $item := $items//item_tuple [end_date >= xs:date("1999-03-01") and end_date <= xs:date("1999-03-31")]              return <item_count> { count($item) } </item_count>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "[" found.          let $item := $items//item_tuple [Error is around here][end_date >= xs:date("1999-03-01") and end_date <= xs:date("1999-03-31")]              return <item_count> { count($item) } </item_count>
rdb-queries-results-q9,Error: XPST0003: Unable to parse XPath: "         <result> {              let $end_dates := $items//item_tuple/end_date              for $m in distinct-values(                         for $e in $end_dates                          return month-from-date($e))              let $item := $items//item_tuple[year-from-date(exactly-one(end_date)) = 1999 and month-from-date(exactly-one(end_date)) = $m]              order by $m              return <monthly_result>                      <month>{ $m }</month>                      <item_count>{ count($item) }</item_count>                    </monthly_result>          } </result>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found.          <result> {              let $end_dates := $items//item_tuple/end_date              [Error is around here]for $m in distinct-values(                         for $e in $end_dates                          return month-from-date($e))              let $item := $items//item_tuple[year-from-date(exactly-one(end_date)) = 1999 and month-from-date(exactly-one(end_date)) = $m]              order by $m              return <monthly_result>                      <month>{ $m }</month>                      <item_count>{ count($item) }</item_count>                    </monthly_result>          } </result>
rdb-queries-results-q10,Error: XPST0003: Unable to parse XPath: "         <result> {              for $highbid in $bids//bid_tuple,                  $user in $users//user_tuple              where $user/userid = $highbid/userid and $highbid/bid = max($bids//bid_tuple[itemno=$highbid/itemno]/bid)              order by exactly-one($highbid/itemno)              return <high_bid> { $highbid/itemno } { $highbid/bid }                       <bidder>{ $user/name/text() }</bidder>                     </high_bid>          } </result>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.          <result> {              for $highbid in $bids//bid_tuple,                  $user in $users//user_tuple              [Error is around here]where $user/userid = $highbid/userid and $highbid/bid = max($bids//bid_tuple[itemno=$highbid/itemno]/bid)              order by exactly-one($highbid/itemno)              return <high_bid> { $highbid/itemno } { $highbid/bid }                       <bidder>{ $user/name/text() }</bidder>                     </high_bid>          } </result>
rdb-queries-results-q11,Error: XPST0003: Unable to parse XPath: "         let $highbid := max($bids//bid_tuple/bid)          return <result> { for $item in $items//item_tuple,                                $b in $bids//bid_tuple[itemno = $item/itemno]                            where $b/bid = $highbid                            return <expensive_item> { $item/itemno } { $item/description }                                      <high_bid>{ $highbid }</high_bid>                                   </expensive_item>                 } </result>       ". Expected " ", "!", "!=", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.          let $highbid := max($bids//bid_tuple/bid)          return <result> { for $item in $items//item_tuple,                                $b in $bids//bid_tuple[itemno = $item/itemno]                            [Error is around here]where $b/bid = $highbid                            return <expensive_item> { $item/itemno } { $item/description }                                      <high_bid>{ $highbid }</high_bid>                                   </expensive_item>                 } </result>
rdb-queries-results-q12,Error: XPST0003: Unable to parse XPath: "         declare function local:bid_summary() as element()* {              for $i in distinct-values($bids//itemno)              let $b := $bids//bid_tuple[itemno = $i]              return <bid_count>                          <itemno>{ $i }</itemno>                          <nbids>{ count($b) }</nbids>                     </bid_count> };         <result> {              let $bid_counts := local:bid_summary(),                  $maxbids := max($bid_counts/nbids),                  $maxitemnos := $bid_counts[nbids = $maxbids]                  for $item in $items//item_tuple,                      $bc in $bid_counts                  where $bc/nbids = $maxbids and $item/itemno = $bc/itemno                  return <popular_item> { $item/itemno } { $item/description }                          <bid_count>{ $bc/nbids/text() }</bid_count>                         </popular_item>          } </result>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.          declare function local:bid_summary() as element()* {              for $i in distinct-values($bids//itemno)              [Error is around here]let $b := $bids//bid_tuple[itemno = $i]              return <bid_count>                          <itemno>{ $i }</itemno>                          <nbids>{ count($b) }</nbids>                     </bid_count> };         <result> {              let $bid_counts := local:bid_summary(),                  $maxbids := max($bid_counts/nbids),                  $maxitemnos := $bid_counts[nbids = $maxbids]                  for $item in $items//item_tuple,                      $bc in $bid_counts                  where $bc/nbids = $maxbids and $item/itemno = $bc/itemno                  return <popular_item> { $item/itemno } { $item/description }                          <bid_count>{ $bc/nbids/text() }</bid_count>                         </popular_item>          } </result>
rdb-queries-results-q13,Error: XPST0003: Unable to parse XPath: "         <result> {              for $uid in distinct-values($bids//userid),                  $u in $users//user_tuple[userid = $uid]              let $b := $bids//bid_tuple[userid = $uid]              order by exactly-one($u/userid)              return <bidder> { $u/userid } { $u/name } <bidcount>{ count($b) }</bidcount> <avgbid>{ avg($b/bid) }</avgbid> </bidder>          } </result>       ". Expected " ", "!", "!=", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.          <result> {              for $uid in distinct-values($bids//userid),                  $u in $users//user_tuple[userid = $uid]              [Error is around here]let $b := $bids//bid_tuple[userid = $uid]              order by exactly-one($u/userid)              return <bidder> { $u/userid } { $u/name } <bidcount>{ count($b) }</bidcount> <avgbid>{ avg($b/bid) }</avgbid> </bidder>          } </result>
rdb-queries-results-q14,Error: XPST0003: Unable to parse XPath: "         <result> {              for $i in distinct-values($items//itemno)              let $b := $bids//bid_tuple[itemno = $i]              let $avgbid := avg($b/bid)              where count($b) >= 3              order by $avgbid descending              return <popular_item> <itemno>{ $i }</itemno> <avgbid>{ $avgbid }</avgbid> </popular_item>          } </result>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.          <result> {              for $i in distinct-values($items//itemno)              [Error is around here]let $b := $bids//bid_tuple[itemno = $i]              let $avgbid := avg($b/bid)              where count($b) >= 3              order by $avgbid descending              return <popular_item> <itemno>{ $i }</itemno> <avgbid>{ $avgbid }</avgbid> </popular_item>          } </result>
rdb-queries-results-q15,Error: XPST0003: Unable to parse XPath: "         <result> {              for $u in $users//user_tuple              let $b := $bids//bid_tuple[userid=$u/userid and bid>=100]              where count($b) > 1              return <big_spender>{ $u/name/text() }</big_spender>          } </result>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.          <result> {              for $u in $users//user_tuple              [Error is around here]let $b := $bids//bid_tuple[userid=$u/userid and bid>=100]              where count($b) > 1              return <big_spender>{ $u/name/text() }</big_spender>          } </result>
rdb-queries-results-q16,Error: XPST0003: Unable to parse XPath: "         <result> {              for $u in $users//user_tuple              let $b := $bids//bid_tuple[userid = $u/userid]              order by exactly-one($u/userid)              return <user> { $u/userid } { $u/name } {                  if (empty($b))                  then <status>inactive</status>                  else <status>active</status> } </user>          } </result>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.          <result> {              for $u in $users//user_tuple              [Error is around here]let $b := $bids//bid_tuple[userid = $u/userid]              order by exactly-one($u/userid)              return <user> { $u/userid } { $u/name } {                  if (empty($b))                  then <status>inactive</status>                  else <status>active</status> } </user>          } </result>
rdb-queries-results-q17,Error: XPST0003: Unable to parse XPath: "         <frequent_bidder> {              for $u in $users//user_tuple              where every $item in $items//item_tuple                    satisfies some $b in $bids//bid_tuple                              satisfies ($item/itemno = $b/itemno and $u/userid = $b/userid)              return $u/name          } </frequent_bidder>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.          <frequent_bidder> {              for $u in $users//user_tuple              [Error is around here]where every $item in $items//item_tuple                    satisfies some $b in $bids//bid_tuple                              satisfies ($item/itemno = $b/itemno and $u/userid = $b/userid)              return $u/name          } </frequent_bidder>
rdb-queries-results-q18,Error: XPST0003: Unable to parse XPath: "         <result> {              for $u in $users//user_tuple              order by $u/name              return <user> { $u/name } {                  for $b in distinct-values($bids//bid_tuple [userid = $u/userid]/itemno)                  for $i in $items//item_tuple[itemno = $b]                  let $descr := $i/description/text()                  order by exactly-one($descr)                  return <bid_on_item>{ $descr }</bid_on_item> } </user>          } </result>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.          <result> {              for $u in $users//user_tuple              [Error is around here]order by $u/name              return <user> { $u/name } {                  for $b in distinct-values($bids//bid_tuple [userid = $u/userid]/itemno)                  for $i in $items//item_tuple[itemno = $b]                  let $descr := $i/description/text()                  order by exactly-one($descr)                  return <bid_on_item>{ $descr }</bid_on_item> } </user>          } </result>
UseCaseR31-001,Error: XPST0003: Unable to parse XPath: "let $result := (         for $e in /employees/employee,     $d in $e/department group by $d return    <department name="{$d}">      {        let $max := max($e/salary)        return $e[salary=$max]      }    </department>       ) return $result/@name='Management'". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "g" found. let $result := (         for $e in /employees/employee,     $d in $e/department [Error is around here]group by $d return    <department name="{$d}">      {        let $max := max($e/salary)        return $e[salary=$max]      }    </department>       ) return $result/@name='Management'
UseCaseR31-002,Error: XPST0003: Unable to parse XPath: "let $result := (         for $e in /employees/employee,     $d in $e/department group by $d return    map {      "department" : $d,      "highest paid employee" :        let $max := max($e/salary)        return $e[salary=$max]/name/text()}) return $result?("highest paid employee") = "Charles Madigen"". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "g" found. let $result := (         for $e in /employees/employee,     $d in $e/department [Error is around here]group by $d return    map {      "department" : $d,      "highest paid employee" :        let $max := max($e/salary)        return $e[salary=$max]/name/text()}) return $result?("highest paid employee") = "Charles Madigen"
UseCaseR31-003,Error: XPST0003: Unable to parse XPath: "let $result := (   <out>  { for $employee in /employees/employee let $salary := $employee/salary group by $department := $employee/department let $max-salary := max($salary) let $highest-earners := $employee[salary = $max-salary] return    <department name="{$department}">{ $highest-earners }</department>,  for $employee in /employees/employee let $salary := $employee/salary group by $job-type := $employee/employeeType let $totals := count($employee) return     <total-by-job-type type="{$job-type}">{ $totals }</total-by-job-type>     }</out>       ) return $result/department/@name='Management'". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. let $result := (   <out>  { for $employee in /employees/employee [Error is around here]let $salary := $employee/salary group by $department := $employee/department let $max-salary := max($salary) let $highest-earners := $employee[salary = $max-salary] return    <department name="{$department}">{ $highest-earners }</department>,  for $employee in /employees/employee let $salary := $employee/salary group by $job-type := $employee/employeeType let $totals := count($employee) return     <total-by-job-type type="{$job-type}">{ $totals }</total-by-job-type>     }</out>       ) return $result/department/@name='Management'
UseCaseR31-004,Error: XPST0003: Unable to parse XPath: "let $result := (         declare namespace map="http://www.w3.org/2005/xpath-functions/map";          for $employee in /employees/employee let $salary := $employee/salary group by $department := $employee/department let $max-salary := max($salary) let $highest-earners := $employee[salary = $max-salary] return   map{ "first" : map {      "department" : $department,      "highest earners" : $highest-earners/name/text()    } , "job type count" : map:merge( for $employee in /employees/employee let $salary := $employee/salary group by $job-type := $employee/employeeType let $totals := count($employee) return map {       $job-type : $totals    }    )}       ) return $result?first?("highest earners") = "Charles Madigen"". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. let $result := (         declare [Error is around here]namespace map="http://www.w3.org/2005/xpath-functions/map";          for $employee in /employees/employee let $salary := $employee/salary group by $department := $employee/department let $max-salary := max($salary) let $highest-earners := $employee[salary = $max-salary] return   map{ "first" : map {      "department" : $department,      "highest earners" : $highest-earners/name/text()    } , "job type count" : map:merge( for $employee in /employees/employee let $salary := $employee/salary group by $job-type := $employee/employeeType let $totals := count($employee) return map {       $job-type : $totals    }    )}       ) return $result?first?("highest earners") = "Charles Madigen"
UseCaseR31-009,Error: XPST0003: Unable to parse XPath: "let $result := (       declare namespace map="http://www.w3.org/2005/xpath-functions/map";       declare variable $book:= (<book> <isbn>0470192747</isbn> <publisher>Wiley</publisher> <title>XSLT 2.0 and XPath 2.0 Programmer's Reference</title> </book>);  declare variable $author := (<author> <name>Michael H. Kay</name> <isbn>0470192747</isbn> <isbn>...</isbn> </author>);        declare variable $index := map:merge($book ! map{isbn : .});  <table>{   for $a in $author   return <tr>     <td>{ $a/name/string() }</td>     <td>{ string-join($a/isbn ! $index(.)/title/string(), ", ") }</td>   </tr> }</table>       ) return $result//td[1]='Michael H. Kay'". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. let $result := (       declare [Error is around here]namespace map="http://www.w3.org/2005/xpath-functions/map";       declare variable $book:= (<book> <isbn>0470192747</isbn> <publisher>Wiley</publisher> <title>XSLT 2.0 and XPath 2.0 Programmer's Reference</title> </book>);  declare variable $author := (<author> <name>Michael H. Kay</name> <isbn>0470192747</isbn> <isbn>...</isbn> </author>);        declare variable $index := map:merge($book ! map{isbn : .});  <table>{   for $a in $author   return <tr>     <td>{ $a/name/string() }</td>     <td>{ string-join($a/isbn ! $index(.)/title/string(), ", ") }</td>   </tr> }</table>       ) return $result//td[1]='Michael H. Kay'
UseCaseR31-012,Error: XPST0003: Unable to parse XPath: "declare function local:play(   $secret-number as xs:integer,   $guessed-number as xs:integer,   $translator as function(xs:string) as xs:string) {   switch (true())   case $guessed-number eq $secret-number     return $translator("You won!")   case $guessed-number lt $secret-number     return $translator("The secret number is greater.")   default (: $guessed-number gt $secret-number :)     return $translator("The secret number is lower.") };  local:play(76, 86, function($x) { $x }), (: Keep English :)  local:play(76, 86, map {   "You won!" : "Du hast gewonnen!",   "The secret number is greater." : "Die geheime Zahl ist groesser.",   "The secret number is lower." :  "Die geheime Zahl ist kleiner." } )        ". Expected "!", "!=", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "(" found. declare function local:play(   $secret-number as xs:integer,   $guessed-number as xs:integer,   $translator as function(xs:string) as xs:string) {   switch [Error is around here](true())   case $guessed-number eq $secret-number     return $translator("You won!")   case $guessed-number lt $secret-number     return $translator("The secret number is greater.")   default (: $guessed-number gt $secret-number :)     return $translator("The secret number is lower.") };  local:play(76, 86, function($x) { $x }), (: Keep English :)  local:play(76, 86, map {   "You won!" : "Du hast gewonnen!",   "The secret number is greater." : "Die geheime Zahl ist groesser.",   "The secret number is lower." :  "Die geheime Zahl ist kleiner." } )
UseCaseR31-013,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
UseCaseR31-014,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
UseCaseR31-015,Error: XPST0003: Unable to parse XPath: "               declare variable $s :=[['A', 'DT'], ['bride', 'NN'], [',', ','], ['you', 'PRP'], ['know', 'VBP'], [',', ','], ['must', 'MD'],  ['appear', 'VB'], ['like', 'IN'], ['a', 'DT'], ['bride', 'NN'], [',', ','], ['but', 'CC'], ['my', 'PRP$'],  ['natural', 'JJ'], ['taste', 'NN'], ['is', 'VBZ'], ['all', 'DT'], ['for', 'IN'], ['simplicity', 'NN'], [';', ':'],  ['a', 'DT'], ['simple', 'JJ'], ['style', 'NN'], ['of', 'IN'], ['dress', 'NN'], ['is', 'VBZ'],  ['so', 'RB'], ['infinitely', 'RB'], ['preferable', 'JJ'], ['to', 'TO'], ['finery', 'VB'], ['.', '.'] ]; declare variable $index := map { "pos" : 2, "lemma" : 1 };  for $word in $s?* let $pos := $word(2) let $lexeme := $word(1) where $pos = ("JJ", "NN", "RB", "VB") group by $pos order by $pos return   <pos name="{$pos}">     {       for $l in distinct-values($lexeme)       return <lexeme>{ $l }</lexeme>     }   </pos>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.                declare variable $s :=[['A', 'DT'], ['bride', 'NN'], [',', ','], ['you', 'PRP'], ['know', 'VBP'], [',', ','], ['must', 'MD'],  ['appear', 'VB'], ['like', 'IN'], ['a', 'DT'], ['bride', 'NN'], [',', ','], ['but', 'CC'], ['my', 'PRP$'],  ['natural', 'JJ'], ['taste', 'NN'], ['is', 'VBZ'], ['all', 'DT'], ['for', 'IN'], ['simplicity', 'NN'], [';', ':'],  ['a', 'DT'], ['simple', 'JJ'], ['style', 'NN'], ['of', 'IN'], ['dress', 'NN'], ['is', 'VBZ'],  ['so', 'RB'], ['infinitely', 'RB'], ['preferable', 'JJ'], ['to', 'TO'], ['finery', 'VB'], ['.', '.'] ]; declare variable $index := map { "pos" : 2, "lemma" : 1 };  for $word in $s?* [Error is around here]let $pos := $word(2) let $lexeme := $word(1) where $pos = ("JJ", "NN", "RB", "VB") group by $pos order by $pos return   <pos name="{$pos}">     {       for $l in distinct-values($lexeme)       return <lexeme>{ $l }</lexeme>     }   </pos>
UseCaseR31-016,Error: XPST0003: Unable to parse XPath: "deep-equal((               declare variable $s :=[['A', 'DT'], ['bride', 'NN'], [',', ','], ['you', 'PRP'], ['know', 'VBP'], [',', ','], ['must', 'MD'],  ['appear', 'VB'], ['like', 'IN'], ['a', 'DT'], ['bride', 'NN'], [',', ','], ['but', 'CC'], ['my', 'PRP$'],  ['natural', 'JJ'], ['taste', 'NN'], ['is', 'VBZ'], ['all', 'DT'], ['for', 'IN'], ['simplicity', 'NN'], [';', ':'],  ['a', 'DT'], ['simple', 'JJ'], ['style', 'NN'], ['of', 'IN'], ['dress', 'NN'], ['is', 'VBZ'],  ['so', 'RB'], ['infinitely', 'RB'], ['preferable', 'JJ'], ['to', 'TO'], ['finery', 'VB'], ['.', '.'] ]; declare function local:words-only($s) {   for $w in $s   where not($w(2) = (".", ",", ";", ":"))   return $w(1) };  for sliding window $w in local:words-only($s?*)     start at $i when true()     only end at $j when $j - $i eq 2 return     array { $w }), ([ "A", "bride", "you" ], [ "bride", "you", "know" ], [ "you", "know", "must" ], [ "know", "must", "appear" ], [ "must", "appear", "like" ], [ "appear", "like", "a" ], [ "like", "a", "bride" ], [ "a", "bride", "but" ], [ "bride", "but", "my" ], [ "but", "my", "natural" ], [ "my", "natural", "taste" ], [ "natural", "taste", "is" ], [ "taste", "is", "all" ], [ "is", "all", "for" ], [ "all", "for", "simplicity" ], [ "for", "simplicity", "a" ], [ "simplicity", "a", "simple" ], [ "a", "simple", "style" ], [ "simple", "style", "of" ], [ "style", "of", "dress" ], [ "of", "dress", "is" ], [ "dress", "is", "so" ], [ "is", "so", "infinitely" ], [ "so", "infinitely", "preferable" ], [ "infinitely", "preferable", "to" ], [ "preferable", "to", "finery" ]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((               declare [Error is around here]variable $s :=[['A', 'DT'], ['bride', 'NN'], [',', ','], ['you', 'PRP'], ['know', 'VBP'], [',', ','], ['must', 'MD'],  ['appear', 'VB'], ['like', 'IN'], ['a', 'DT'], ['bride', 'NN'], [',', ','], ['but', 'CC'], ['my', 'PRP$'],  ['natural', 'JJ'], ['taste', 'NN'], ['is', 'VBZ'], ['all', 'DT'], ['for', 'IN'], ['simplicity', 'NN'], [';', ':'],  ['a', 'DT'], ['simple', 'JJ'], ['style', 'NN'], ['of', 'IN'], ['dress', 'NN'], ['is', 'VBZ'],  ['so', 'RB'], ['infinitely', 'RB'], ['preferable', 'JJ'], ['to', 'TO'], ['finery', 'VB'], ['.', '.'] ]; declare function local:words-only($s) {   for $w in $s   where not($w(2) = (".", ",", ";", ":"))   return $w(1) };  for sliding window $w in local:words-only($s?*)     start at $i when true()     only end at $j when $j - $i eq 2 return     array { $w }), ([ "A", "bride", "you" ], [ "bride", "you", "know" ], [ "you", "know", "must" ], [ "know", "must", "appear" ], [ "must", "appear", "like" ], [ "appear", "like", "a" ], [ "like", "a", "bride" ], [ "a", "bride", "but" ], [ "bride", "but", "my" ], [ "but", "my", "natural" ], [ "my", "natural", "taste" ], [ "natural", "taste", "is" ], [ "taste", "is", "all" ], [ "is", "all", "for" ], [ "all", "for", "simplicity" ], [ "for", "simplicity", "a" ], [ "simplicity", "a", "simple" ], [ "a", "simple", "style" ], [ "simple", "style", "of" ], [ "style", "of", "dress" ], [ "of", "dress", "is" ], [ "dress", "is", "so" ], [ "is", "so", "infinitely" ], [ "so", "infinitely", "preferable" ], [ "infinitely", "preferable", "to" ], [ "preferable", "to", "finery" ]))
UseCaseR31-017,Error: XPST0003: Unable to parse XPath: "deep-equal((               declare variable $s :=[['A', 'DT'], ['bride', 'NN'], [',', ','], ['you', 'PRP'], ['know', 'VBP'], [',', ','], ['must', 'MD'],  ['appear', 'VB'], ['like', 'IN'], ['a', 'DT'], ['bride', 'NN'], [',', ','], ['but', 'CC'], ['my', 'PRP$'],  ['natural', 'JJ'], ['taste', 'NN'], ['is', 'VBZ'], ['all', 'DT'], ['for', 'IN'], ['simplicity', 'NN'], [';', ':'],  ['a', 'DT'], ['simple', 'JJ'], ['style', 'NN'], ['of', 'IN'], ['dress', 'NN'], ['is', 'VBZ'],  ['so', 'RB'], ['infinitely', 'RB'], ['preferable', 'JJ'], ['to', 'TO'], ['finery', 'VB'], ['.', '.'] ]; declare function local:filter($s as item()*, $p as function(item()) as xs:boolean) {   array { $s[$p(.)] },   array { $s[not($p(.))] } };  let $f := function($a) { starts-with($a(2), "VB") } return   local:filter($s?*, $f)), ([ [ "know", "VBP" ], [ "appear", "VB" ], [ "is", "VBZ" ], [ "is", "VBZ" ], [ "finery", "VB" ] ],  [ [ "A", "DT" ], [ "bride", "NN" ], [ ",", "," ], [ "you", "PRP" ],   [ ",", "," ], [ "must", "MD" ], [ "like", "IN" ], [ "a", "DT" ],   [ "bride", "NN" ], [ ",", "," ], [ "but", "CC" ], [ "my", "PRP$" ],   [ "natural", "JJ" ], [ "taste", "NN" ], [ "all", "DT" ], [ "for", "IN" ],   [ "simplicity", "NN" ], [ ";", ":" ], [ "a", "DT" ], [ "simple", "JJ" ],   [ "style", "NN" ], [ "of", "IN" ], [ "dress", "NN" ], [ "so", "RB" ],   [ "infinitely", "RB" ], [ "preferable", "JJ" ], [ "to", "TO"],   [ ".", "." ] ]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((               declare [Error is around here]variable $s :=[['A', 'DT'], ['bride', 'NN'], [',', ','], ['you', 'PRP'], ['know', 'VBP'], [',', ','], ['must', 'MD'],  ['appear', 'VB'], ['like', 'IN'], ['a', 'DT'], ['bride', 'NN'], [',', ','], ['but', 'CC'], ['my', 'PRP$'],  ['natural', 'JJ'], ['taste', 'NN'], ['is', 'VBZ'], ['all', 'DT'], ['for', 'IN'], ['simplicity', 'NN'], [';', ':'],  ['a', 'DT'], ['simple', 'JJ'], ['style', 'NN'], ['of', 'IN'], ['dress', 'NN'], ['is', 'VBZ'],  ['so', 'RB'], ['infinitely', 'RB'], ['preferable', 'JJ'], ['to', 'TO'], ['finery', 'VB'], ['.', '.'] ]; declare function local:filter($s as item()*, $p as function(item()) as xs:boolean) {   array { $s[$p(.)] },   array { $s[not($p(.))] } };  let $f := function($a) { starts-with($a(2), "VB") } return   local:filter($s?*, $f)), ([ [ "know", "VBP" ], [ "appear", "VB" ], [ "is", "VBZ" ], [ "is", "VBZ" ], [ "finery", "VB" ] ],  [ [ "A", "DT" ], [ "bride", "NN" ], [ ",", "," ], [ "you", "PRP" ],   [ ",", "," ], [ "must", "MD" ], [ "like", "IN" ], [ "a", "DT" ],   [ "bride", "NN" ], [ ",", "," ], [ "but", "CC" ], [ "my", "PRP$" ],   [ "natural", "JJ" ], [ "taste", "NN" ], [ "all", "DT" ], [ "for", "IN" ],   [ "simplicity", "NN" ], [ ";", ":" ], [ "a", "DT" ], [ "simple", "JJ" ],   [ "style", "NN" ], [ "of", "IN" ], [ "dress", "NN" ], [ "so", "RB" ],   [ "infinitely", "RB" ], [ "preferable", "JJ" ], [ "to", "TO"],   [ ".", "." ] ]))
UseCaseR31-018,Error: XPST0003: Unable to parse XPath: "deep-equal((               declare variable $s :=[['A', 'DT'], ['bride', 'NN'], [',', ','], ['you', 'PRP'], ['know', 'VBP'], [',', ','], ['must', 'MD'],  ['appear', 'VB'], ['like', 'IN'], ['a', 'DT'], ['bride', 'NN'], [',', ','], ['but', 'CC'], ['my', 'PRP$'],  ['natural', 'JJ'], ['taste', 'NN'], ['is', 'VBZ'], ['all', 'DT'], ['for', 'IN'], ['simplicity', 'NN'], [';', ':'],  ['a', 'DT'], ['simple', 'JJ'], ['style', 'NN'], ['of', 'IN'], ['dress', 'NN'], ['is', 'VBZ'],  ['so', 'RB'], ['infinitely', 'RB'], ['preferable', 'JJ'], ['to', 'TO'], ['finery', 'VB'], ['.', '.'] ]; declare function local:filter($s as item()*, $p as function(item()) as xs:boolean) {   map {     true() : array { $s[$p(.)] },     false() : array { $s[not($p(.))] }   } };   let $f := function($a) { starts-with($a(2), "VB") } return   local:filter($s?*, $f)), (map {    true() :              [ [ "know", "VBP" ], [ "appear", "VB" ], [ "is", "VBZ" ],                ["is", "VBZ" ], [ "finery", "VB" ] ],    false() :               [ [ "A", "DT" ], ["bride", "NN" ], [ ",", "," ],                [ "you", "PRP" ], [ ",", "," ], [ "must", "MD" ],                [ "like", "IN" ], [ "a", "DT" ], [ "bride", "NN" ],                [ ",", "," ], [ "but", "CC" ], [ "my", "PRP$" ],                [ "natural", "JJ" ], [ "taste", "NN" ], [ "all", "DT"],                [ "for", "IN" ], [ "simplicity", "NN" ], [ ";", ":" ],                [ "a", "DT" ], [ "simple", "JJ" ], [ "style", "NN" ],                [ "of", "IN" ], [ "dress", "NN" ], [ "so", "RB" ],                [ "infinitely", "RB" ], [ "preferable", "JJ" ],                [ "to", "TO" ], [ ".", "." ] ] }))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((               declare [Error is around here]variable $s :=[['A', 'DT'], ['bride', 'NN'], [',', ','], ['you', 'PRP'], ['know', 'VBP'], [',', ','], ['must', 'MD'],  ['appear', 'VB'], ['like', 'IN'], ['a', 'DT'], ['bride', 'NN'], [',', ','], ['but', 'CC'], ['my', 'PRP$'],  ['natural', 'JJ'], ['taste', 'NN'], ['is', 'VBZ'], ['all', 'DT'], ['for', 'IN'], ['simplicity', 'NN'], [';', ':'],  ['a', 'DT'], ['simple', 'JJ'], ['style', 'NN'], ['of', 'IN'], ['dress', 'NN'], ['is', 'VBZ'],  ['so', 'RB'], ['infinitely', 'RB'], ['preferable', 'JJ'], ['to', 'TO'], ['finery', 'VB'], ['.', '.'] ]; declare function local:filter($s as item()*, $p as function(item()) as xs:boolean) {   map {     true() : array { $s[$p(.)] },     false() : array { $s[not($p(.))] }   } };   let $f := function($a) { starts-with($a(2), "VB") } return   local:filter($s?*, $f)), (map {    true() :              [ [ "know", "VBP" ], [ "appear", "VB" ], [ "is", "VBZ" ],                ["is", "VBZ" ], [ "finery", "VB" ] ],    false() :               [ [ "A", "DT" ], ["bride", "NN" ], [ ",", "," ],                [ "you", "PRP" ], [ ",", "," ], [ "must", "MD" ],                [ "like", "IN" ], [ "a", "DT" ], [ "bride", "NN" ],                [ ",", "," ], [ "but", "CC" ], [ "my", "PRP$" ],                [ "natural", "JJ" ], [ "taste", "NN" ], [ "all", "DT"],                [ "for", "IN" ], [ "simplicity", "NN" ], [ ";", ":" ],                [ "a", "DT" ], [ "simple", "JJ" ], [ "style", "NN" ],                [ "of", "IN" ], [ "dress", "NN" ], [ "so", "RB" ],                [ "infinitely", "RB" ], [ "preferable", "JJ" ],                [ "to", "TO" ], [ ".", "." ] ] }))
UseCaseR31-019,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
UseCaseR31-022,Error: XPST0003: Unable to parse XPath: "json-doc("http://www.w3.org/qt3/app/UseCaseR31/mildred-json")?phone?*[?type = 'mobile']?number". Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "?" found. json-doc("http://www.w3.org/qt3/app/UseCaseR31/mildred-json")?phone?*[[Error is around here]?type = 'mobile']?number
UseCaseR31-023,Error: XPST0003: Unable to parse XPath: " declare namespace map = "http://www.w3.org/2005/xpath-functions/map"; declare namespace array = "http://www.w3.org/2005/xpath-functions/array";  let $input := json-doc('http://www.w3.org/qt3/app/UseCaseR31/employees-json') for $k in map:keys($input) return   <department name="{ $k }">     {     let $array := $input($k)     for $i in 1 to array:size($array)     let $emp := $array($i)     return       <employee>         <firstName>{ $emp('firstName') }</firstName>         <lastName>{ $emp('lastName') }</lastName>         <age>{ $emp('age') }</age>       </employee>     }   </department>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found.  declare namespace map = "http://www.w3.org/2005/xpath-functions/map"; declare namespace array = "http://www.w3.org/2005/xpath-functions/array";  let $input := json-doc('http://www.w3.org/qt3/app/UseCaseR31/employees-json') [Error is around here]for $k in map:keys($input) return   <department name="{ $k }">     {     let $array := $input($k)     for $i in 1 to array:size($array)     let $emp := $array($i)     return       <employee>         <firstName>{ $emp('firstName') }</firstName>         <lastName>{ $emp('lastName') }</lastName>         <age>{ $emp('age') }</age>       </employee>     }   </department>
UseCaseR31-025,Error: XPST0003: Unable to parse XPath: "deep-equal((declare namespace map="http://www.w3.org/2005/xpath-functions/map";  declare function local:deep-put($input as item()*, $key as xs:string, $value as item()*) as item()* {   let $mf := function($k, $v) {                 if ($k eq $key)                 then map{$k : $value}                 else map{$k : local:deep-put($v, $key, $value)}              }   for $i in $input   return     if ($i instance of map(*))     then map:merge(map:for-each($i, $mf))     else if ($i instance of array(*))     then array{ local:deep-put($i?*, $key, $value) }     else $i };  local:deep-put(json-doc("http://www.w3.org/qt3/app/UseCaseR31/bookinfo-json"), "first", "John")), (map {     "book": map {         "title": "Data on the Web",         "year": 2000,         "author": [             map {                 "last": "Abiteboul",                 "first": "John"             },             map {                 "last": "Buneman",                 "first": "John"             },             map {                 "last": "Suciu",                 "first": "John"             }         ],         "publisher": "Morgan Kaufmann Publishers",         "price": 39.95     } }))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. deep-equal((declare [Error is around here]namespace map="http://www.w3.org/2005/xpath-functions/map";  declare function local:deep-put($input as item()*, $key as xs:string, $value as item()*) as item()* {   let $mf := function($k, $v) {                 if ($k eq $key)                 then map{$k : $value}                 else map{$k : local:deep-put($v, $key, $value)}              }   for $i in $input   return     if ($i instance of map(*))     then map:merge(map:for-each($i, $mf))     else if ($i instance of array(*))     then array{ local:deep-put($i?*, $key, $value) }     else $i };  local:deep-put(json-doc("http://www.w3.org/qt3/app/UseCaseR31/bookinfo-json"), "first", "John")), (map {     "book": map {         "title": "Data on the Web",         "year": 2000,         "author": [             map {                 "last": "Abiteboul",                 "first": "John"             },             map {                 "last": "Buneman",                 "first": "John"             },             map {                 "last": "Suciu",                 "first": "John"             }         ],         "publisher": "Morgan Kaufmann Publishers",         "price": 39.95     } }))
UseCaseR31-026,Error: XPST0003: Unable to parse XPath: "       for $sarah in collection($users-collection-uri),           $friend in collection($users-collection-uri)       where $sarah('name') = "Sarah"        and $friend('name') = $sarah('friends')?*       return $friend('name')       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.        for $sarah in collection($users-collection-uri),           $friend in collection($users-collection-uri)       [Error is around here]where $sarah('name') = "Sarah"        and $friend('name') = $sarah('friends')?*       return $friend('name')
UseCaseR31-027,Error: XPST0003: Unable to parse XPath: "deep-equal(( Q{http://www.w3.org/2005/xpath-functions/map}merge(   for $sales in collection($sales-collection-uri)   let $pname := $sales('product')   group by $pname   return map { $pname : sum(for $s in $sales return $s('quantity')) })), (map {   "blender" : 250,   "broiler" : 20,   "shirt" : 10,   "socks" : 510,   "toaster" : 200   }))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. deep-equal(( Q{http://www.w3.org/2005/xpath-functions/map}merge(   for $sales in collection($sales-collection-uri)   [Error is around here]let $pname := $sales('product')   group by $pname   return map { $pname : sum(for $s in $sales return $s('quantity')) })), (map {   "blender" : 250,   "broiler" : 20,   "shirt" : 10,   "socks" : 510,   "toaster" : 200   }))
UseCaseR31-028,Error: XPST0003: Unable to parse XPath: "deep-equal((       declare namespace map="http://www.w3.org/2005/xpath-functions/map";       declare variable $storesVar := array { unparsed-text-lines("UseCaseR31/stores.json") ! parse-json(.) };       declare variable $productsVar := array { unparsed-text-lines("UseCaseR31/products.json") ! parse-json(.) };       declare variable $salesVar := array { unparsed-text-lines("UseCaseR31/sales.json") ! parse-json(.) };       array {   for $store in $storesVar ? *   let $state := $store?state   group by $state   order by $state   return     map {       $state :  array {         for $product in $productsVar ? *         let $category := $product?category         group by $category         order by $category         return           map {             $category :  map:merge((               for $sales in $salesVar ? *               where $sales?("store number") = $store?("store number") and $sales?product = $product?name               let $pname := $sales?product               group by $pname               return map { $pname :  sum(for $s in $sales return $s?quantity)}             ))           }       }     } }), ([map{"CA":[map{"clothes":map{"socks":510}},map{"kitchen":map{"broiler":20,"toaster":150}}]},map{"MA":[map{"clothes":map{"shirt":10}},map{"kitchen":map{"toaster":50,"blender":250}}]}]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. deep-equal((       declare [Error is around here]namespace map="http://www.w3.org/2005/xpath-functions/map";       declare variable $storesVar := array { unparsed-text-lines("UseCaseR31/stores.json") ! parse-json(.) };       declare variable $productsVar := array { unparsed-text-lines("UseCaseR31/products.json") ! parse-json(.) };       declare variable $salesVar := array { unparsed-text-lines("UseCaseR31/sales.json") ! parse-json(.) };       array {   for $store in $storesVar ? *   let $state := $store?state   group by $state   order by $state   return     map {       $state :  array {         for $product in $productsVar ? *         let $category := $product?category         group by $category         order by $category         return           map {             $category :  map:merge((               for $sales in $salesVar ? *               where $sales?("store number") = $store?("store number") and $sales?product = $product?name               let $pname := $sales?product               group by $pname               return map { $pname :  sum(for $s in $sales return $s?quantity)}             ))           }       }     } }), ([map{"CA":[map{"clothes":map{"socks":510}},map{"kitchen":map{"broiler":20,"toaster":150}}]},map{"MA":[map{"clothes":map{"shirt":10}},map{"kitchen":map{"toaster":50,"blender":250}}]}]))
UseCaseR31-029,AssertionError: Expected executing the XPath "declare namespace map="http://www.w3.org/2005/xpath-functions/map"; let $sats := json-doc("http://www.w3.org/qt3/app/UseCaseR31/satellites-json")("satellites") return map {   "visible" : array {      map:keys($sats)[$sats(.)("visible")]   },   "invisible" : array {      map:keys($sats)[not($sats(.)("visible"))]   } }" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: "deep-equal((declare namespace map="http://www.w3.org/2005/xpath-functions/map"; let $sats := json-doc("http://www.w3.org/qt3/app/UseCaseR31/satellites-json")("satellites") return map {   "visible" : array {      map:keys($sats)[$sats(.)("visible")]   },   "invisible" : array {      map:keys($sats)[not($sats(.)("visible"))]   } }), (map { "visible" : ["AKARI (ASTRO-F)","AJISAI (EGS)"], "invisible" : ["AAU CUBESAT"]}))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. deep-equal((declare [Error is around here]namespace map="http://www.w3.org/2005/xpath-functions/map"; let $sats := json-doc("http://www.w3.org/qt3/app/UseCaseR31/satellites-json")("satellites") return map {   "visible" : array {      map:keys($sats)[$sats(.)("visible")]   },   "invisible" : array {      map:keys($sats)[not($sats(.)("visible"))]   } }), (map { "visible" : ["AKARI (ASTRO-F)","AJISAI (EGS)"], "invisible" : ["AAU CUBESAT"]})), Error: XPST0003: Unable to parse XPath: "deep-equal((declare namespace map="http://www.w3.org/2005/xpath-functions/map"; let $sats := json-doc("http://www.w3.org/qt3/app/UseCaseR31/satellites-json")("satellites") return map {   "visible" : array {      map:keys($sats)[$sats(.)("visible")]   },   "invisible" : array {      map:keys($sats)[not($sats(.)("visible"))]   } }), (map { "visible" : ["AJISAI (EGS)", "AKARI (ASTRO-F)"], "invisible" : ["AAU CUBESAT"]}))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. deep-equal((declare [Error is around here]namespace map="http://www.w3.org/2005/xpath-functions/map"; let $sats := json-doc("http://www.w3.org/qt3/app/UseCaseR31/satellites-json")("satellites") return map {   "visible" : array {      map:keys($sats)[$sats(.)("visible")]   },   "invisible" : array {      map:keys($sats)[not($sats(.)("visible"))]   } }), (map { "visible" : ["AJISAI (EGS)", "AKARI (ASTRO-F)"], "invisible" : ["AAU CUBESAT"]})).
UseCaseR31-030,Error: No selector counterpart for: lookup.
UseCaseR31-031,Error: XPST0003: Unable to parse XPath: "let $result := (   <html><body><table>     <tr> (: Column headings :)          {             <th> </th>,             for $th in json-doc('http://www.w3.org/qt3/app/UseCaseR31/table-json')?col-labels?*             return <th>{ $th }</th>          }       </tr>       {  (: Data for each row :)          for $r at $i in json-doc('http://www.w3.org/qt3/app/UseCaseR31/table-json')?data?*          return             <tr>              {                <th>{ json-doc('http://www.w3.org/qt3/app/UseCaseR31/table-json')?row-labels[$i] }</th>,                for $c in $r?*                return <td>{ $c }</td>              }             </tr>       }     </table>    </body> </html>    ) return count($result//td[text()='spinnen'])=2". Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found. let $result := (   <html><body><table>     <tr> (: Column headings :)          {             <th> </th>,             for $th in json-doc('http://www.w3.org/qt3/app/UseCaseR31/table-json')?col-labels?*             return <th>{ $th }</th>          }       </tr>       {  (: Data for each row :)          for $r [Error is around here]at $i in json-doc('http://www.w3.org/qt3/app/UseCaseR31/table-json')?data?*          return             <tr>              {                <th>{ json-doc('http://www.w3.org/qt3/app/UseCaseR31/table-json')?row-labels[$i] }</th>,                for $c in $r?*                return <td>{ $c }</td>              }             </tr>       }     </table>    </body> </html>    ) return count($result//td[text()='spinnen'])=2
UseCaseR31-032,Error: XPST0003: Unable to parse XPath: "   <table>{   for tumbling window $w in json-doc("http://www.w3.org/qt3/app/UseCaseR31/colors-json")?colors?*    start at $x when fn:true()     end at $y when $y - $x = 2   return     <tr>{       for $i in $w?color       return         <td>{ $i }</td>     }</tr> }</table>    ". Expected " ", "!", "!=", "$", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "t" found.    <table>{   for [Error is around here]tumbling window $w in json-doc("http://www.w3.org/qt3/app/UseCaseR31/colors-json")?colors?*    start at $x when fn:true()     end at $y when $y - $x = 2   return     <tr>{       for $i in $w?color       return         <td>{ $i }</td>     }</tr> }</table>
UseCaseR31-033,Error: XPST0003: Unable to parse XPath: "deep-equal((         declare namespace map="http://www.w3.org/2005/xpath-functions/map";   let $dbj := json-doc("http://www.w3.org/qt3/app/UseCaseR31/users2-json")[ .("name") = "Deadbeat Jim" ] return map:put($dbj, "status", "credit card declined")    ), (map {   "name" : "Deadbeat Jim",   "address" : "1 E 161st St, Bronx, NY 10451",   "status" : "credit card declined",   "risk tolerance" : "high" }))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. deep-equal((         declare [Error is around here]namespace map="http://www.w3.org/2005/xpath-functions/map";   let $dbj := json-doc("http://www.w3.org/qt3/app/UseCaseR31/users2-json")[ .("name") = "Deadbeat Jim" ] return map:put($dbj, "status", "credit card declined")    ), (map {   "name" : "Deadbeat Jim",   "address" : "1 E 161st St, Bronx, NY 10451",   "status" : "credit card declined",   "risk tolerance" : "high" }))
UseCaseR31-034-err,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function json-doc with arity of 1 not registered. No similar functions found.'
seq-queries-results-q3,Error: XPST0003: Unable to parse XPath: "let $i2 := (//incision)[2] for $a in (//action)[. >> $i2][position()<=2] return $a//instrument". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found. let $i2 := (//incision)[2] [Error is around here]for $a in (//action)[. >> $i2][position()<=2] return $a//instrument
seq-queries-results-q4,Error: XPST0003: Unable to parse XPath: "for $p in //section[section.title = "Procedure"] where not(some $a in $p//anesthesia satisfies $a << ($p//incision)[1] ) return $p". Expected " ", "!", "!=", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found. for $p in //section[section.title = "Procedure"] [Error is around here]where not(some $a in $p//anesthesia satisfies $a << ($p//incision)[1] ) return $p
seq-queries-results-q5,Error: XPST0003: Unable to parse XPath: "<critical_sequence> { let $proc := //section[section.title="Procedure"][1], $i1 := ($proc//incision)[1], $i2 := ($proc//incision)[2] for $n in $proc//node() except $i1//node() where $n >> $i1 and $n << $i2 return $n } </critical_sequence>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found. <critical_sequence> { let $proc := //section[section.title="Procedure"][1], $i1 := ($proc//incision)[1], $i2 := ($proc//incision)[2] [Error is around here]for $n in $proc//node() except $i1//node() where $n >> $i1 and $n << $i2 return $n } </critical_sequence>
sgml-queries-results-q3,Error: XPST0003: Unable to parse XPath: "<result> { for $c in //chapter where empty($c/intro) return $c/section/intro/para } </result>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found. <result> { for $c in //chapter [Error is around here]where empty($c/intro) return $c/section/intro/para } </result>
string-queries-results-q2,Error: XPST0003: Unable to parse XPath: "         declare variable $input-context1 := $string;         declare variable $input-context2 := $company-data;          declare function local:partners($company as xs:string) as element()*         {             let $c := $input-context2//company[name = $company]             return $c//partner         };          let $foobar_partners := local:partners("Foobar Corporation")          for $item in $input-context1//news_item         where           some $t in $item//title satisfies             (contains(exactly-one($t/text()), "Foobar Corporation")             and (some $partner in $foobar_partners satisfies               contains(exactly-one($t/text()), $partner/text())))           or (some $par in $item//par satisfies            (contains(string($par), "Foobar Corporation")              and (some $partner in $foobar_partners satisfies                 contains(string($par), $partner/text()))))         return             <news_item>                 { $item/title }                 { $item/date }             </news_item>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found.          declare variable $input-context1 := $string;         declare variable $input-context2 := $company-data;          declare function local:partners($company as xs:string) as element()*         {             let $c := $input-context2//company[name = $company]             return $c//partner         };          let $foobar_partners := local:partners("Foobar Corporation")          [Error is around here]for $item in $input-context1//news_item         where           some $t in $item//title satisfies             (contains(exactly-one($t/text()), "Foobar Corporation")             and (some $partner in $foobar_partners satisfies               contains(exactly-one($t/text()), $partner/text())))           or (some $par in $item//par satisfies            (contains(string($par), "Foobar Corporation")              and (some $partner in $foobar_partners satisfies                 contains(string($par), $partner/text()))))         return             <news_item>                 { $item/title }                 { $item/date }             </news_item>
string-queries-results-q4,Error: XPST0003: Unable to parse XPath: "         declare function local:partners($c as xs:string) as element()* {              let $c := $company-data//company[name = $c]              return $c//partner          };          for $item in $string//news_item,              $c in $company-data//company          let $partners := local:partners(exactly-one($c/name))          where contains(string($item), $c/name)            and (some $p in $partners satisfies contains(string($item), $p) and $item/news_agent != $c/name)          return $item". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.          declare function local:partners($c as xs:string) as element()* {              let $c := $company-data//company[name = $c]              return $c//partner          };          for $item in $string//news_item,              $c in $company-data//company          [Error is around here]let $partners := local:partners(exactly-one($c/name))          where contains(string($item), $c/name)            and (some $p in $partners satisfies contains(string($item), $p) and $item/news_agent != $c/name)          return $item
string-queries-results-q5,Error: XPST0003: Unable to parse XPath: "         for $item in //news_item          where contains(string(exactly-one($item/content)), "Gorilla Corporation")          return <item_summary> { concat($item/title,". ") }                                { concat($item/date,". ") }                                { string(($item//par)[1]) }                 </item_summary>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.          for $item in //news_item          [Error is around here]where contains(string(exactly-one($item/content)), "Gorilla Corporation")          return <item_summary> { concat($item/title,". ") }                                { concat($item/date,". ") }                                { string(($item//par)[1]) }                 </item_summary>
tree-queries-results-q5,Error: XPST0003: Unable to parse XPath: "<section_list> { for $s in //section let $f := $s/figure return <section title="{ $s/title/text() }" figcount="{ count($f) }"/> } </section_list>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. <section_list> { for $s in //section [Error is around here]let $f := $s/figure return <section title="{ $s/title/text() }" figcount="{ count($f) }"/> } </section_list>
xmp-queries-results-q1,Error: XPST0003: Unable to parse XPath: "       	<bib> {        		for $b in /bib/book        		where $b/publisher = "Addison-Wesley" and $b/@year > 1991        		return <book year="{ $b/@year }">{ $b/title }</book> }        	</bib>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.        	<bib> {        		for $b in /bib/book        		[Error is around here]where $b/publisher = "Addison-Wesley" and $b/@year > 1991        		return <book year="{ $b/@year }">{ $b/title }</book> }        	</bib>
xmp-queries-results-q4,Error: XPST0003: Unable to parse XPath: "       	<results> {        		let $a := //author        		for $last in distinct-values($a/last), $first in distinct-values($a[last=$last]/first)        		order by $last, $first        		return <result>        				<author> <last>{ $last }</last> <first>{ $first }</first> </author>        				{ for $b in /bib/book        					where some $ba in $b/author satisfies ($ba/last = $last and $ba/first=$first)        					return $b/title }        			   </result> }        	</results>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found.        	<results> {        		let $a := //author        		[Error is around here]for $last in distinct-values($a/last), $first in distinct-values($a[last=$last]/first)        		order by $last, $first        		return <result>        				<author> <last>{ $last }</last> <first>{ $first }</first> </author>        				{ for $b in /bib/book        					where some $ba in $b/author satisfies ($ba/last = $last and $ba/first=$first)        					return $b/title }        			   </result> }        	</results>
xmp-queries-results-q5,Error: XPST0003: Unable to parse XPath: "<books-with-prices> {          for $b in $bib//book, $a in $reviews//entry          where $b/title = $a/title          return <book-with-prices> { $b/title } <price-bstore2>{ $a/price/text() }</price-bstore2> <price-bstore1>{ $b/price/text() }</price-bstore1> </book-with-prices> } </books-with-prices>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found. <books-with-prices> {          for $b in $bib//book, $a in $reviews//entry          [Error is around here]where $b/title = $a/title          return <book-with-prices> { $b/title } <price-bstore2>{ $a/price/text() }</price-bstore2> <price-bstore1>{ $b/price/text() }</price-bstore1> </book-with-prices> } </books-with-prices>
xmp-queries-results-q6,Error: XPST0003: Unable to parse XPath: "       	<bib> {        		for $b in //book        		where count($b/author) > 0        		return <book>        			{ $b/title }        			{ for $a in $b/author[position()<=2] return $a }        			{ if (count($b/author) > 2) then <et-al/> else () }        			</book> }        	</bib>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.        	<bib> {        		for $b in //book        		[Error is around here]where count($b/author) > 0        		return <book>        			{ $b/title }        			{ for $a in $b/author[position()<=2] return $a }        			{ if (count($b/author) > 2) then <et-al/> else () }        			</book> }        	</bib>
xmp-queries-results-q7,Error: XPST0003: Unable to parse XPath: "       	<bib> {        		for $b in //book        		where $b/publisher = "Addison-Wesley" and $b/@year > 1991        		order by exactly-one($b/title)        		return <book> { $b/@year } { $b/title } </book> }        	</bib>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.        	<bib> {        		for $b in //book        		[Error is around here]where $b/publisher = "Addison-Wesley" and $b/@year > 1991        		order by exactly-one($b/title)        		return <book> { $b/@year } { $b/title } </book> }        	</bib>
xmp-queries-results-q8,Error: XPST0003: Unable to parse XPath: "       	for $b in //book        	let $e := $b/*[contains(string(.), "Suciu") and ends-with(local-name(.), "or")]        	where exists($e)        	return <book> { $b/title } { $e } </book>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.        	for $b in //book        	[Error is around here]let $e := $b/*[contains(string(.), "Suciu") and ends-with(local-name(.), "or")]        	where exists($e)        	return <book> { $b/title } { $e } </book>
xmp-queries-results-q9,Error: XPST0003: Unable to parse XPath: "       	<results> {        		for $t in //(chapter | section)/title        		where contains(exactly-one($t/text()), "XML")        		return $t }        	</results>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.        	<results> {        		for $t in //(chapter | section)/title        		[Error is around here]where contains(exactly-one($t/text()), "XML")        		return $t }        	</results>
xmp-queries-results-q10,Error: XPST0003: Unable to parse XPath: "       	<results> {        		let $doc := (/)        		for $t in distinct-values($doc//book/title)        		let $p := $doc//book[title = $t]/price        		return <minprice title="{ $t }"> <price>{ min($p) }</price> </minprice> }        	</results>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found.        	<results> {        		let $doc := (/)        		[Error is around here]for $t in distinct-values($doc//book/title)        		let $p := $doc//book[title = $t]/price        		return <minprice title="{ $t }"> <price>{ min($p) }</price> </minprice> }        	</results>
xmp-queries-results-q12,Error: XPST0003: Unable to parse XPath: "       	<bib> {        		for $book1 in //book, $book2 in //book        		let $aut1 :=        			for $a in $book1/author        			order by exactly-one($a/last), exactly-one($a/first)        			return $a        		let $aut2 :=        			for $a in $book2/author        			order by exactly-one($a/last), exactly-one($a/first)        			return $a        		where $book1 << $book2 and not($book1/title = $book2/title) and deep-equal($aut1, $aut2)        		return <book-pair> { $book1/title } { $book2/title } </book-pair> }        	</bib>       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.        	<bib> {        		for $book1 in //book, $book2 in //book        		[Error is around here]let $aut1 :=        			for $a in $book1/author        			order by exactly-one($a/last), exactly-one($a/first)        			return $a        		let $aut2 :=        			for $a in $book2/author        			order by exactly-one($a/last), exactly-one($a/first)        			return $a        		where $book1 << $book2 and not($book1/title = $book2/title) and deep-equal($aut1, $aut2)        		return <book-pair> { $book1/title } { $book2/title } </book-pair> }        	</bib>
d1e11215,Error: XPST0017: Function sort with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}sort (array(*))", "Q{http://www.w3.org/2001/XMLSchema}short (xs:anyAtomicType?)" or "Q{http://www.w3.org/2005/xpath-functions/math}sqrt (xs:double?)"?
d1e13048,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
d1e20420,Error: XPST0003: Unable to parse XPath: "deep-equal((  xquery version "3.1" encoding "UTF-8"; "inserted for testing prolog only examples"), ("inserted for testing prolog only examples"))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  xquery [Error is around here]version "3.1" encoding "UTF-8"; "inserted for testing prolog only examples"), ("inserted for testing prolog only examples"))
d1e41029,Error: XPST0017: Function doc with arity of 1 not registered. No similar functions found.
d1e41041,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare variable $deptnames := map {   "ACC" : "Accessories",   "WMN" : "Women's",   "MEN" : "Men's" }; declare variable $deptinfo := map {   "ACC": map {             "deptname": "Accessories",             "deptnum": 300 } ,   "WMN": map {             "deptname": "Women's",             "deptnum": 310 } ,   "MEN": map {             "deptname": "Men's",             "deptnum": 320 }  }; "inserted for testing prolog only examples"), ("inserted for testing prolog only examples"))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  declare [Error is around here]variable $deptnames := map {   "ACC" : "Accessories",   "WMN" : "Women's",   "MEN" : "Men's" }; declare variable $deptinfo := map {   "ACC": map {             "deptname": "Accessories",             "deptnum": 300 } ,   "WMN": map {             "deptname": "Women's",             "deptnum": 310 } ,   "MEN": map {             "deptname": "Men's",             "deptnum": 320 }  }; "inserted for testing prolog only examples"), ("inserted for testing prolog only examples"))
d1e41054,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare variable $deptnames := map {   "ACC" : "Accessories",   "WMN" : "Women's",   "MEN" : "Men's" };  map:get($deptnames, "ACC")), ("Accessories"))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  declare [Error is around here]variable $deptnames := map {   "ACC" : "Accessories",   "WMN" : "Women's",   "MEN" : "Men's" };  map:get($deptnames, "ACC")), ("Accessories"))
d1e41054b,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare variable $deptnames := map {   "ACC" : "Accessories",   "WMN" : "Women's",   "MEN" : "Men's" };  $deptnames?("ACC")), ("Accessories"))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  declare [Error is around here]variable $deptnames := map {   "ACC" : "Accessories",   "WMN" : "Women's",   "MEN" : "Men's" };  $deptnames?("ACC")), ("Accessories"))
d1e41094,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e41148,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e41173,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare variable $deptnames := map {   "ACC" : "Accessories",   "WMN" : "Women's",   "MEN" : "Men's" };  $deptnames?("ACC")), ("Accessories"))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  declare [Error is around here]variable $deptnames := map {   "ACC" : "Accessories",   "WMN" : "Women's",   "MEN" : "Men's" };  $deptnames?("ACC")), ("Accessories"))
d1e41180,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare variable $deptnames := map {   "ACC" : "Accessories",   "WMN" : "Women's",   "MEN" : "Men's" };  $deptnames?("ACC","MEN")), (("Accessories","Men's")))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  declare [Error is around here]variable $deptnames := map {   "ACC" : "Accessories",   "WMN" : "Women's",   "MEN" : "Men's" };  $deptnames?("ACC","MEN")), (("Accessories","Men's")))
d1e41190,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare variable $deptnames := map {   "ACC" : "Accessories",   "WMN" : "Women's",   "MEN" : "Men's" };  for $d in ("ACC","MEN") return $deptnames?($d)), (("Accessories","Men's")))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  declare [Error is around here]variable $deptnames := map {   "ACC" : "Accessories",   "WMN" : "Women's",   "MEN" : "Men's" };  for $d in ("ACC","MEN") return $deptnames?($d)), (("Accessories","Men's")))
d1e41194,Error: XPST0003: Unable to parse XPath: "deep-equal(( declare variable $deptnames := map {   "ACC" : "Accessories",   "WMN" : "Women's",   "MEN" : "Men's" };  $deptnames?(doc("catalog.xml")//@dept)), (("Women's","Accessories","Accessories","Men's")))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal(( declare [Error is around here]variable $deptnames := map {   "ACC" : "Accessories",   "WMN" : "Women's",   "MEN" : "Men's" };  $deptnames?(doc("catalog.xml")//@dept)), (("Women's","Accessories","Accessories","Men's")))
d1e41194b,AssertionError: Skipped test, it was a assert-permutation
d1e41213,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare variable $map-with-integer-keys := map{ 10:"a", 20:"b"}; $map-with-integer-keys?20), ("b"))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  declare [Error is around here]variable $map-with-integer-keys := map{ 10:"a", 20:"b"}; $map-with-integer-keys?20), ("b"))
d1e41225,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare variable $deptnames := map {   "ACC" : "Accessories",   "WMN" : "Women's",   "MEN" : "Men's" };  $deptnames?ACC), ("Accessories"))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  declare [Error is around here]variable $deptnames := map {   "ACC" : "Accessories",   "WMN" : "Women's",   "MEN" : "Men's" };  $deptnames?ACC), ("Accessories"))
d1e41255,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e41271,Error: XPST0003: Unable to parse XPath: "          declare variable $deptinfo := map {   "ACC": map {             "deptname": "Accessories",             "deptnum": 300 } ,   "WMN": map {             "deptname": "Women's",             "deptnum": 310 } ,   "MEN": map {             "deptname": "Men's",             "deptnum": 320 }  }; deep-equal( $deptinfo?*[?deptname = "Accessories"], map { "deptname": "Accessories",             "deptnum": 300 }) ". Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but "?" found.           declare variable $deptinfo := map {   "ACC": map {             "deptname": "Accessories",             "deptnum": 300 } ,   "WMN": map {             "deptname": "Women's",             "deptnum": 310 } ,   "MEN": map {             "deptname": "Men's",             "deptnum": 320 }  }; deep-equal( $deptinfo?*[[Error is around here]?deptname = "Accessories"], map { "deptname": "Accessories",             "deptnum": 300 })
d1e41301,Error: XPST0003: Unable to parse XPath: "deep-equal((          declare variable $deptinfo := map {   "ACC": map {             "deptname": "Accessories",             "deptnum": 300 } ,   "WMN": map {             "deptname": "Women's",             "deptnum": 310 } ,   "MEN": map {             "deptname": "Men's",             "deptnum": 320 }  };  $deptinfo?*[?deptname = "Accessories"]?deptnum), (300))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((          declare [Error is around here]variable $deptinfo := map {   "ACC": map {             "deptname": "Accessories",             "deptnum": 300 } ,   "WMN": map {             "deptname": "Women's",             "deptnum": 310 } ,   "MEN": map {             "deptname": "Men's",             "deptnum": 320 }  };  $deptinfo?*[?deptname = "Accessories"]?deptnum), (300))
d1e41301a,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare variable $deptnames := map {   "ACC" : "Accessories",   "WMN" : "Women's",   "MEN" : "Men's" };  map:size($deptnames)), (3))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  declare [Error is around here]variable $deptnames := map {   "ACC" : "Accessories",   "WMN" : "Women's",   "MEN" : "Men's" };  map:size($deptnames)), (3))
d1e41301b,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e41301c,AssertionError: Skipped test, it was a assert-permutation
d1e41301d,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e41301e,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e41301f,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e41517,AssertionError: Skipped test, it was a assert-permutation
d1e41255b,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e41255c,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e41255d,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e41255e,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e41590,AssertionError: Skipped test, it was a assert-permutation
d1e41655,Error: XPST0003: Unable to parse XPath: "let $result := ( declare variable $myitems := 3;  [$myitems, doc("catalog.xml")//product,    12, xs:date('2015-01-15'), <foo>bar</foo>]) return array:size($result) eq 5". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. let $result := ( declare [Error is around here]variable $myitems := 3;  [$myitems, doc("catalog.xml")//product,    12, xs:date('2015-01-15'), <foo>bar</foo>]) return array:size($result) eq 5
d1e41709,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  array:get($array-of-ints, 2)), (20))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  declare [Error is around here]variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  array:get($array-of-ints, 2)), (20))
d1e41709b,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  $array-of-ints?2), (20))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  declare [Error is around here]variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  $array-of-ints?2), (20))
d1e41709c,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  let $pos := 2 return $array-of-ints?($pos)), (20))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  declare [Error is around here]variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  let $pos := 2 return $array-of-ints?($pos)), (20))
d1e41709d,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  $array-of-arrays?2?1), ("d"))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  declare [Error is around here]variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  $array-of-arrays?2?1), ("d"))
d1e41791,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare variable $array-of-ints := [10,20,30];  $array-of-ints?(2)), (20))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  declare [Error is around here]variable $array-of-ints := [10,20,30];  $array-of-ints?(2)), (20))
d1e41795,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare variable $array-of-ints := [10,20,30];  $array-of-ints?(2,3)), (20,30))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  declare [Error is around here]variable $array-of-ints := [10,20,30];  $array-of-ints?(2,3)), (20,30))
d1e41799,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare variable $array-of-ints := [10,20,30];  for $i in (2,3) return $array-of-ints?($i)), (20,30))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  declare [Error is around here]variable $array-of-ints := [10,20,30];  for $i in (2,3) return $array-of-ints?($i)), (20,30))
d1e41803,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare variable $array-of-ints := [10,20,30];  $array-of-ints?(1 to 2)), (10,20))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  declare [Error is around here]variable $array-of-ints := [10,20,30];  $array-of-ints?(1 to 2)), (10,20))
d1e41803b,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare variable $array-of-ints := [10,20,30];  $array-of-ints?2), (20))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  declare [Error is around here]variable $array-of-ints := [10,20,30];  $array-of-ints?2), (20))
d1e41803c,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare variable $array-of-ints := [10,20,30];  $array-of-ints?*), (10,20,30))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  declare [Error is around here]variable $array-of-ints := [10,20,30];  $array-of-ints?*), (10,20,30))
d1e41709e,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  $array-of-arrays?2?1), ("d"))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  declare [Error is around here]variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  $array-of-arrays?2?1), ("d"))
d1e41709f,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  $array-of-arrays?*), (["a","b","c"], ["d","e","f"]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  declare [Error is around here]variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  $array-of-arrays?*), (["a","b","c"], ["d","e","f"]))
d1e41709g,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  $array-of-arrays?*[?2 = "b"]), (["a","b","c"]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  declare [Error is around here]variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  $array-of-arrays?*[?2 = "b"]), (["a","b","c"]))
d1e41709h,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  array:size($array-of-ints)), (3))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  declare [Error is around here]variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  array:size($array-of-ints)), (3))
d1e41709i,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  array:head($array-of-ints)), (10))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  declare [Error is around here]variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  array:head($array-of-ints)), (10))
d1e41709j,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  array:tail($array-of-ints)), ([20,30]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  declare [Error is around here]variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  array:tail($array-of-ints)), ([20,30]))
d1e41709k,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  array:append($array-of-ints,40)), ([10,20,30,40]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  declare [Error is around here]variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  array:append($array-of-ints,40)), ([10,20,30,40]))
d1e41709l,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];   array:insert-before($array-of-ints,2,40)), ([10,40,20,30]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  declare [Error is around here]variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];   array:insert-before($array-of-ints,2,40)), ([10,40,20,30]))
d1e41709m,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  array:remove($array-of-ints,2)), ([10,30]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  declare [Error is around here]variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  array:remove($array-of-ints,2)), ([10,30]))
d1e41709n,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  array:subarray($array-of-ints,2,2)), ([20,30]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  declare [Error is around here]variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  array:subarray($array-of-ints,2,2)), ([20,30]))
d1e41709o,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  array:filter($array-of-ints,function($n) {$n > 15})), ([20,30]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  declare [Error is around here]variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  array:filter($array-of-ints,function($n) {$n > 15})), ([20,30]))
d1e41709p,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  array:flatten($array-of-arrays)), ("a","b","c","d","e","f"))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  declare [Error is around here]variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  array:flatten($array-of-arrays)), ("a","b","c","d","e","f"))
d1e41709q,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  array:join(($array-of-ints,["a","b","c"]))), ([10,20,30,"a","b","c"]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  declare [Error is around here]variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  array:join(($array-of-ints,["a","b","c"]))), ([10,20,30,"a","b","c"]))
d1e41709r,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  array:sort([6,2,-4],(),abs#1)), ([2,-4,6]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  declare [Error is around here]variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  array:sort([6,2,-4],(),abs#1)), ([2,-4,6]))
d1e41709s,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  array:reverse($array-of-ints)), ([30,20,10]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((  declare [Error is around here]variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  array:reverse($array-of-ints)), ([30,20,10]))
d1e41709t,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e41709u,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e41709v,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e41709w,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e41709x,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e42207,Error: XPST0003: Unable to parse XPath: "deep-equal((  declare function local:larger-values   ($arrayarg as array(xs:integer))as xs:integer* {    array:flatten($arrayarg)[. > 15] };  local:larger-values([10,20,30])), (20,30))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found. deep-equal((  declare [Error is around here]function local:larger-values   ($arrayarg as array(xs:integer))as xs:integer* {    array:flatten($arrayarg)[. > 15] };  local:larger-values([10,20,30])), (20,30))
d1e42340,Error: XPST0017: Function json-doc with arity of 1 not registered. No similar functions found.
d1e42362,Error: XPST0003: Unable to parse XPath: "( declare namespace output = "http://www.w3.org/2010/xslt-xquery-serialization";  declare option output:method "json"; map {    "number": 557,    "properties": <props>                    <length>31</length>                    <height>12</height>                  </props> }) instance of map(*)". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found. ( declare [Error is around here]namespace output = "http://www.w3.org/2010/xslt-xquery-serialization";  declare option output:method "json"; map {    "number": 557,    "properties": <props>                    <length>31</length>                    <height>12</height>                  </props> }) instance of map(*)
d1e48503,Error: XPST0003: Unable to parse XPath: "deep-equal((declare variable $array1 := ["abc","def","ghi"];  array:append($array1,"jkl")), (["abc","def","ghi","jkl"]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((declare [Error is around here]variable $array1 := ["abc","def","ghi"];  array:append($array1,"jkl")), (["abc","def","ghi","jkl"]))
d1e48514,Error: XPST0003: Unable to parse XPath: "deep-equal((declare variable $array1 := ["abc","def","ghi"];  array:append($array1,("jkl","mno"))), (["abc","def","ghi",("jkl","mno")]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((declare [Error is around here]variable $array1 := ["abc","def","ghi"];  array:append($array1,("jkl","mno"))), (["abc","def","ghi",("jkl","mno")]))
d1e48525,Error: XPST0003: Unable to parse XPath: "deep-equal((declare variable $array1 := ["abc","def","ghi"];  array:append(array:append($array1,"jkl"),"mno")), (["abc","def","ghi","jkl","mno"]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((declare [Error is around here]variable $array1 := ["abc","def","ghi"];  array:append(array:append($array1,"jkl"),"mno")), (["abc","def","ghi","jkl","mno"]))
d1e48536,Error: XPST0003: Unable to parse XPath: "deep-equal((declare variable $array1 := ["abc","def","ghi"];  array:append($array1,["jkl","mno"])), (["abc","def","ghi",["jkl","mno"]]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((declare [Error is around here]variable $array1 := ["abc","def","ghi"];  array:append($array1,["jkl","mno"])), (["abc","def","ghi",["jkl","mno"]]))
d1e48547,Error: XPST0003: Unable to parse XPath: "deep-equal((declare variable $array1 := ["abc","def","ghi"];  array:append($array1,())), (["abc","def","ghi",()]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((declare [Error is around here]variable $array1 := ["abc","def","ghi"];  array:append($array1,())), (["abc","def","ghi",()]))
d1e48617,Error: XPST0017: Function apply with arity of 2 not registered. No similar functions found.
d1e48676,Error: XPST0017: Function apply with arity of 2 not registered. No similar functions found.
d1e48687,Error: XPST0017: Function apply with arity of 2 not registered. No similar functions found.
d1e48698,Error: XPST0017: Function apply with arity of 2 not registered. No similar functions found.
d1e48709,AssertionError: expected [Function] to throw error including 'FOAP0001' but got 'XPST0017: Function apply with arity of 2 not registered. No similar functions found.'
d1e51544,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e51555,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e51565,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e51576,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e51592,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e51729,Error: XPST0017: Function contains-token with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}contains (xs:string?, xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}contains (xs:string?, xs:string?)" or "Q{http://www.w3.org/2005/xpath-functions/map}contains (map(*), xs:anyAtomicType)"?
d1e51740,Error: XPST0017: Function contains-token with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}contains (xs:string?, xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}contains (xs:string?, xs:string?)" or "Q{http://www.w3.org/2005/xpath-functions/map}contains (map(*), xs:anyAtomicType)"?
d1e51751,Error: XPST0017: Function contains-token with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}contains (xs:string?, xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}contains (xs:string?, xs:string?)" or "Q{http://www.w3.org/2005/xpath-functions/map}contains (map(*), xs:anyAtomicType)"?
d1e51762,Error: XPST0017: Function contains-token with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}contains (xs:string?, xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}contains (xs:string?, xs:string?)" or "Q{http://www.w3.org/2005/xpath-functions/map}contains (map(*), xs:anyAtomicType)"?
d1e51773,Error: XPST0017: Function contains-token with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}contains (xs:string?, xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}contains (xs:string?, xs:string?)" or "Q{http://www.w3.org/2005/xpath-functions/map}contains (map(*), xs:anyAtomicType)"?
d1e55090,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e55101,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e55112,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e55123,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e57482,AssertionError: Expected XPath   array:fold-right(["a","b","c"], "", function($a, $b) { concat($a,$b) }) to (deep equally) resolve to "abc": expected false to be true
d1e57493,AssertionError: Expected XPath   array:fold-right(["a","b","c"], "", function($a, $b) { concat($b,$a) }) to (deep equally) resolve to "cba": expected false to be true
d1e57504,AssertionError: Expected XPath   array:fold-right(["a","b","c"], "x", function($a, $b) { concat($a,',',$b) }) to (deep equally) resolve to "a,b,c,x": expected false to be true
d1e57515,AssertionError: Expected XPath   array:fold-right( ["a","b","c"], "", concat(?,?) ) to (deep equally) resolve to "abc": expected false to be true
d1e57818,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
d1e57961,AssertionError: Skipped test, it was a assert-permutation
d1e57972,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e60780,Error: XPST0003: Unable to parse XPath: "deep-equal((declare variable $array1 := ["abc","def","ghi"]; declare variable $array2 := ["abc", [10,20]];  array:get($array1,2)), ("def"))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((declare [Error is around here]variable $array1 := ["abc","def","ghi"]; declare variable $array2 := ["abc", [10,20]];  array:get($array1,2)), ("def"))
d1e60791,Error: XPST0003: Unable to parse XPath: "deep-equal((declare variable $array1 := ["abc","def","ghi"]; declare variable $array2 := ["abc", [10,20]];  array:get($array2,2)), ([10,20]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((declare [Error is around here]variable $array1 := ["abc","def","ghi"]; declare variable $array2 := ["abc", [10,20]];  array:get($array2,2)), ([10,20]))
d1e60802,AssertionError: expected [Function] to throw error including 'FOAY0001' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
d1e60955,Error: XPST0003: Unable to parse XPath: "deep-equal((declare variable $map1 := map {3:"first", 4:"second", 5:()};  map:get($map1,3)), ("first"))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((declare [Error is around here]variable $map1 := map {3:"first", 4:"second", 5:()};  map:get($map1,3)), ("first"))
d1e60966,Error: XPST0003: Unable to parse XPath: "(declare variable $map1 := map {3:"first", 4:"second", 5:()};  map:get($map1,5)) => empty()". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. (declare [Error is around here]variable $map1 := map {3:"first", 4:"second", 5:()};  map:get($map1,5)) => empty()
d1e60976,Error: XPST0003: Unable to parse XPath: "(declare variable $map1 := map {3:"first", 4:"second", 5:()};  map:get($map1,6)) => empty()". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. (declare [Error is around here]variable $map1 := map {3:"first", 4:"second", 5:()};  map:get($map1,6)) => empty()
d1e60986,Error: XPST0003: Unable to parse XPath: "(declare variable $map1 := map {3:"first", 4:"second", 5:()};  map:get($map1,"3")) => empty()". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. (declare [Error is around here]variable $map1 := map {3:"first", 4:"second", 5:()};  map:get($map1,"3")) => empty()
d1e63192,Error: XPST0003: Unable to parse XPath: "deep-equal((declare variable $array1 := ["abc","ghi","jkl"];  array:insert-before($array1,2,"def")), (["abc","def","ghi","jkl"]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((declare [Error is around here]variable $array1 := ["abc","ghi","jkl"];  array:insert-before($array1,2,"def")), (["abc","def","ghi","jkl"]))
d1e63203,Error: XPST0003: Unable to parse XPath: "deep-equal((declare variable $array1 := ["abc","ghi","jkl"];  array:insert-before($array1,4,"mno")), (["abc","ghi","jkl","mno"]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((declare [Error is around here]variable $array1 := ["abc","ghi","jkl"];  array:insert-before($array1,4,"mno")), (["abc","ghi","jkl","mno"]))
d1e63214,AssertionError: expected [Function] to throw error including 'FOAY0001' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
d1e63227,AssertionError: expected [Function] to throw error including 'FOAY0001' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
d1e63488,Error: XPST0003: Unable to parse XPath: "deep-equal((declare variable $array1 := ["abc","def","ghi"]; declare variable $array2 := [1,2,3];  array:join( ($array1,$array2) )), (["abc","def","ghi",1,2,3]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((declare [Error is around here]variable $array1 := ["abc","def","ghi"]; declare variable $array2 := [1,2,3];  array:join( ($array1,$array2) )), (["abc","def","ghi",1,2,3]))
d1e63499,Error: XPST0003: Unable to parse XPath: "deep-equal((declare variable $array1 := ["abc","def","ghi"]; declare variable $array2 := [1,2,3];  array:join( ($array2,$array1) )), ([1,2,3,"abc","def","ghi"]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((declare [Error is around here]variable $array1 := ["abc","def","ghi"]; declare variable $array2 := [1,2,3];  array:join( ($array2,$array1) )), ([1,2,3,"abc","def","ghi"]))
d1e63510,Error: XPST0003: Unable to parse XPath: "deep-equal((declare variable $array1 := ["abc","def","ghi"]; declare variable $array2 := [1,2,3];  array:join( ($array2,$array1,[4,5]) )), ([1,2,3,"abc","def","ghi",4,5]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((declare [Error is around here]variable $array1 := ["abc","def","ghi"]; declare variable $array2 := [1,2,3];  array:join( ($array2,$array1,[4,5]) )), ([1,2,3,"abc","def","ghi",4,5]))
d1e63521,Error: XPST0003: Unable to parse XPath: "deep-equal((declare variable $array1 := ["abc","def","ghi"]; declare variable $array2 := [1,2,3];  array:join( ($array1,[]) )), (["abc","def","ghi"]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((declare [Error is around here]variable $array1 := ["abc","def","ghi"]; declare variable $array2 := [1,2,3];  array:join( ($array1,[]) )), (["abc","def","ghi"]))
d1e63532,Error: XPST0003: Unable to parse XPath: "deep-equal((declare variable $array1 := ["abc","def","ghi"]; declare variable $array2 := [1,2,3];  array:join( () )), ([ ]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((declare [Error is around here]variable $array1 := ["abc","def","ghi"]; declare variable $array2 := [1,2,3];  array:join( () )), ([ ]))
d1e63543,Error: XPST0003: Unable to parse XPath: "deep-equal((declare variable $array1 := ["abc","def","ghi"]; declare variable $array2 := [1,2,3];  array:join( [ ] )), ([ ]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((declare [Error is around here]variable $array1 := ["abc","def","ghi"]; declare variable $array2 := [1,2,3];  array:join( [ ] )), ([ ]))
d1e63783,AssertionError: Skipped test, it was a assert-permutation
d1e63796,Error: XPST0003: Unable to parse XPath: "deep-equal((declare variable $map1 := map {1:"first", 2:"second"}; declare variable $map2 := map {1:"first"}; declare variable $map3 := map {};  map:keys($map2)), (1))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((declare [Error is around here]variable $map1 := map {1:"first", 2:"second"}; declare variable $map2 := map {1:"first"}; declare variable $map3 := map {};  map:keys($map2)), (1))
d1e63807,Error: XPST0003: Unable to parse XPath: "(declare variable $map1 := map {1:"first", 2:"second"}; declare variable $map2 := map {1:"first"}; declare variable $map3 := map {};  map:keys($map3)) => empty()". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. (declare [Error is around here]variable $map1 := map {1:"first", 2:"second"}; declare variable $map2 := map {1:"first"}; declare variable $map3 := map {};  map:keys($map3)) => empty()
d1e66015,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e66026,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e66037,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e66048,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e66059,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e66070,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e66081,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e66092,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e66103,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e69523,Error: XPST0017: Function parse-ietf-date with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}current-date ()"?
d1e69534,Error: XPST0017: Function parse-ietf-date with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}current-date ()"?
d1e69545,Error: XPST0017: Function parse-ietf-date with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}current-date ()"?
d1e69556,Error: XPST0017: Function parse-ietf-date with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}current-date ()"?
d1e69567,Error: XPST0017: Function parse-ietf-date with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}current-date ()"?
d1e70867,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e70878,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e70889,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e71246,Error: No selector counterpart for: lookup.
d1e71254,Error: No selector counterpart for: lookup.
d1e71262,Error: No selector counterpart for: lookup.
d1e71270,Error: No selector counterpart for: lookup.
d1e71288,Error: XPST0003: Unable to parse XPath: "(  declare function local:random-sequence($length as xs:integer,                                        $rng as map(xs:string, item())) {   if ($length eq 0)   then ()   else ($rng?number, local:random-sequence($length - 1, $rng?next())) }; local:random-sequence(5, random-number-generator())) instance of xs:double+". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found. (  declare [Error is around here]function local:random-sequence($length as xs:integer,                                        $rng as map(xs:string, item())) {   if ($length eq 0)   then ()   else ($rng?number, local:random-sequence($length - 1, $rng?next())) }; local:random-sequence(5, random-number-generator())) instance of xs:double+
d1e71531,Error: XPST0003: Unable to parse XPath: "deep-equal((declare variable $array1 := ["abc","def","ghi","jkl"];  array:remove($array1,2)), (["abc","ghi","jkl"]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((declare [Error is around here]variable $array1 := ["abc","def","ghi","jkl"];  array:remove($array1,2)), (["abc","ghi","jkl"]))
d1e71542,Error: XPST0003: Unable to parse XPath: "deep-equal((declare variable $array1 := ["abc","def","ghi","jkl"];  array:remove(["abc"],1)), ([ ]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((declare [Error is around here]variable $array1 := ["abc","def","ghi","jkl"];  array:remove(["abc"],1)), ([ ]))
d1e71553,AssertionError: expected [Function] to throw error including 'FOAY0001' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
d1e71660,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e71671,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e71682,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e74388,Error: XPST0003: Unable to parse XPath: "deep-equal((declare variable $map1 := map {1:"first", 2:"second"}; declare variable $map2 := map {};  map:size( $map1 )), (2))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((declare [Error is around here]variable $map1 := map {1:"first", 2:"second"}; declare variable $map2 := map {};  map:size( $map1 )), (2))
d1e74399,Error: XPST0003: Unable to parse XPath: "deep-equal((declare variable $map1 := map {1:"first", 2:"second"}; declare variable $map2 := map {};  map:size( $map2 )), (0))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((declare [Error is around here]variable $map1 := map {1:"first", 2:"second"}; declare variable $map2 := map {};  map:size( $map2 )), (0))
d1e74563,Error: XPST0017: Function sort with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}sort (array(*))", "Q{http://www.w3.org/2001/XMLSchema}short (xs:anyAtomicType?)" or "Q{http://www.w3.org/2005/xpath-functions/math}sqrt (xs:double?)"?
d1e74585,Error: XPST0017: Function sort with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}sort (array(*))", "Q{http://www.w3.org/2001/XMLSchema}short (xs:anyAtomicType?)" or "Q{http://www.w3.org/2005/xpath-functions/math}sqrt (xs:double?)"?
d1e74596,Error: XPST0017: Function sort with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}sort (array(*))", "Q{http://www.w3.org/2001/XMLSchema}short (xs:anyAtomicType?)" or "Q{http://www.w3.org/2005/xpath-functions/math}sqrt (xs:double?)"?
d1e74610,Error: XPST0017: Function sort with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}sort (array(*))", "Q{http://www.w3.org/2001/XMLSchema}short (xs:anyAtomicType?)" or "Q{http://www.w3.org/2005/xpath-functions/math}sqrt (xs:double?)"?
d1e74627,Error: XPST0017: Function sort with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}sort (array(*))", "Q{http://www.w3.org/2001/XMLSchema}short (xs:anyAtomicType?)" or "Q{http://www.w3.org/2005/xpath-functions/math}sqrt (xs:double?)"?
d1e74809,AssertionError: Expected XPath   array:sort([("a","c","b"), ("a","b","f")]) to (deep equally) resolve to [("a","b","f"), ("a","c","b")]: expected false to be true
d1e74820,Error: XPST0017: Function array:sort with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}sort (array(*))", "Q{http://www.w3.org/2001/XMLSchema}short (xs:anyAtomicType?)" or "Q{http://www.w3.org/2005/xpath-functions/math}sqrt (xs:double?)"?
d1e76034,Error: XPST0003: Unable to parse XPath: "deep-equal((declare variable $array1 := ["abc","def","ghi","jkl"];  array:subarray($array1,2)), (["def","ghi","jkl"]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((declare [Error is around here]variable $array1 := ["abc","def","ghi","jkl"];  array:subarray($array1,2)), (["def","ghi","jkl"]))
d1e76045,Error: XPST0003: Unable to parse XPath: "deep-equal((declare variable $array1 := ["abc","def","ghi","jkl"];  array:subarray($array1,2,2)), (["def","ghi"]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((declare [Error is around here]variable $array1 := ["abc","def","ghi","jkl"];  array:subarray($array1,2,2)), (["def","ghi"]))
d1e76056,Error: XPST0003: Unable to parse XPath: "deep-equal((declare variable $array1 := ["abc","def","ghi","jkl"];  array:subarray($array1,2,1)), (["def"]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((declare [Error is around here]variable $array1 := ["abc","def","ghi","jkl"];  array:subarray($array1,2,1)), (["def"]))
d1e76067,Error: XPST0003: Unable to parse XPath: "deep-equal((declare variable $array1 := ["abc","def","ghi","jkl"];  array:subarray($array1,2,0)), ([ ]))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found. deep-equal((declare [Error is around here]variable $array1 := ["abc","def","ghi","jkl"];  array:subarray($array1,2,0)), ([ ]))
d1e76078,AssertionError: expected [Function] to throw error including 'FOAY0001' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
d1e76091,AssertionError: expected [Function] to throw error including 'FOAY0001' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
d1e76104,AssertionError: expected [Function] to throw error including 'FOAY0002' but got 'Not implemented: only module imports and function declarations are implemented in XQuery modules'
d1e78807,Error: XPST0003: Unable to parse XPath: "          deep-equal(  let $result := transform(   map {     "stylesheet-location" : "render.xsl",     "source-node"    : doc("catalog.xml")   }) return $result?output , document {<p>There are 4 products in the catalog.</p>} )". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.           deep-equal(  let $result := transform(   map {     "stylesheet-location" : "render.xsl",     "source-node"    : doc("catalog.xml")   }) return $result?output , document [Error is around here]{<p>There are 4 products in the catalog.</p>} )
d1e78807c,Error: XPST0017: Function json-to-xml with arity of 1 not registered. No similar functions found.
d1e78807d,Error: XPST0017: Function json-to-xml with arity of 2 not registered. No similar functions found.
d1e78807e,Error: XPST0017: Function xml-to-json with arity of 2 not registered. No similar functions found.
d1e78807g,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?
d1e78807h,Error: XPST0017: Function serialize with arity of 2 not registered. No similar functions found.
d1e78807i,Error: Not implemented: only module imports and function declarations are implemented in XQuery modules
d1e78807j,SyntaxError: Expected "(", "Q", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but " " found.
d1e78807k,SyntaxError: Expected "(", "Q", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], or [�-�] but " " found.
XMark-Q3,Error: XPST0003: Unable to parse XPath: "(: Purpose: Return the IDs of all open auctions whose current increase is at least twice as high as the initial increase. :)          <XMark-result-Q3> {              let $auction := (/)              return for $b in $auction/site/open_auctions/open_auction              where zero-or-one($b/bidder[1]/increase/text()) * 2.0 <= $b/bidder[last()]/increase/text()                  return <increase first="{$b/bidder[1]/increase/text()}" last="{$b/bidder[last()]/increase/text()}"/> }          </XMark-result-Q3>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found. (: Purpose: Return the IDs of all open auctions whose current increase is at least twice as high as the initial increase. :)          <XMark-result-Q3> {              let $auction := (/)              return for $b in $auction/site/open_auctions/open_auction              [Error is around here]where zero-or-one($b/bidder[1]/increase/text()) * 2.0 <= $b/bidder[last()]/increase/text()                  return <increase first="{$b/bidder[1]/increase/text()}" last="{$b/bidder[last()]/increase/text()}"/> }          </XMark-result-Q3>
XMark-Q4,Error: XPST0003: Unable to parse XPath: "(: Purpose: List the reserves of those open auctions where a certain person issued a bid before another person. :)          <XMark-result-Q4> {              let $auction := (/) return              for $b in $auction/site/open_auctions/open_auction              where some $pr1 in $b/bidder/personref[@person = "person20"], $pr2 in $b/bidder/personref[@person = "person51"] satisfies $pr1 << $pr2              return <history>{$b/reserve/text()}</history> }          </XMark-result-Q4>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found. (: Purpose: List the reserves of those open auctions where a certain person issued a bid before another person. :)          <XMark-result-Q4> {              let $auction := (/) return              for $b in $auction/site/open_auctions/open_auction              [Error is around here]where some $pr1 in $b/bidder/personref[@person = "person20"], $pr2 in $b/bidder/personref[@person = "person51"] satisfies $pr1 << $pr2              return <history>{$b/reserve/text()}</history> }          </XMark-result-Q4>
XMark-Q5,Error: XPST0003: Unable to parse XPath: "         <XMark-result-Q5> {            let $auction := (/) return count(             for $i in $auction/site/closed_auctions/closed_auction              where $i/price/text() >= 40.0 return $i/price) }          </XMark-result-Q5>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.          <XMark-result-Q5> {            let $auction := (/) return count(             for $i in $auction/site/closed_auctions/closed_auction              [Error is around here]where $i/price/text() >= 40.0 return $i/price) }          </XMark-result-Q5>
XMark-Q8,Error: XPST0003: Unable to parse XPath: "(: Purpose: List the names of persons and the number of items they bought. (joins person, closed\_auction). :)           <XMark-result-Q8> { let $auction := (/) return           for $p in $auction/site/people/person           let $a := for $t in $auction/site/closed_auctions/closed_auction           where $t/buyer/@person = $p/@id return $t           return <item person="{$p/name/text()}">{count($a)}</item> } </XMark-result-Q8>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. (: Purpose: List the names of persons and the number of items they bought. (joins person, closed\_auction). :)           <XMark-result-Q8> { let $auction := (/) return           for $p in $auction/site/people/person           [Error is around here]let $a := for $t in $auction/site/closed_auctions/closed_auction           where $t/buyer/@person = $p/@id return $t           return <item person="{$p/name/text()}">{count($a)}</item> } </XMark-result-Q8>
XMark-Q9,Error: XPST0003: Unable to parse XPath: "(: Purpose: List the names of persons and the names of the items           they bought in Europe(joins person, closed auction, item). :)           <XMark-result-Q9> {              let $auction := (/)              return let $ca := $auction/site/closed_auctions/closed_auction              return let $ei := $auction/site/regions/europe/item              for $p in $auction/site/people/person              let $a := for $t in $ca where $p/@id = $t/buyer/@person              return let $n := for $t2 in $ei where $t/itemref/@item = $t2/@id              return $t2 return <item>{$n/name/text()}</item>              return <person name="{$p/name/text()}">{$a}</person> } </XMark-result-Q9>". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found. (: Purpose: List the names of persons and the names of the items           they bought in Europe(joins person, closed auction, item). :)           <XMark-result-Q9> {              let $auction := (/)              return let $ca := $auction/site/closed_auctions/closed_auction              return let $ei := $auction/site/regions/europe/item              [Error is around here]for $p in $auction/site/people/person              let $a := for $t in $ca where $p/@id = $t/buyer/@person              return let $n := for $t2 in $ei where $t/itemref/@item = $t2/@id              return $t2 return <item>{$n/name/text()}</item>              return <person name="{$p/name/text()}">{$a}</person> } </XMark-result-Q9>
XMark-Q10,Error: XPST0003: Unable to parse XPath: "(: Purpose: List all persons according to their interest; use French markup in the result. :)           <XMark-result-Q10> { let $auction := (/)              return for $i in distinct-values($auction/site/people/person/profile/interest/@category)              let $p := for $t in $auction/site/people/person where $t/profile/interest/@category = $i              return <personne>                       <statistiques>                          <sexe>{$t/profile/gender/text()}</sexe>                          <age>{$t/profile/age/text()}</age>                          <education>{$t/profile/education/text()}</education>                          <revenu>{fn:data($t/profile/@income)}</revenu>                       </statistiques>                       <coordonnees>                          <nom>{$t/name/text()}</nom>                          <rue>{$t/address/street/text()}</rue>                          <ville>{$t/address/city/text()}</ville>                          <pays>{$t/address/country/text()}</pays>                          <reseau>                             <courrier>{$t/emailaddress/text()}</courrier>                             <pagePerso>{$t/homepage/text()}</pagePerso>                          </reseau>                       </coordonnees>                       <cartePaiement>{$t/creditcard/text()}</cartePaiement>                     </personne>              return <categorie>{<id>{$i}</id>, $p}</categorie> } </XMark-result-Q10>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. (: Purpose: List all persons according to their interest; use French markup in the result. :)           <XMark-result-Q10> { let $auction := (/)              return for $i in distinct-values($auction/site/people/person/profile/interest/@category)              [Error is around here]let $p := for $t in $auction/site/people/person where $t/profile/interest/@category = $i              return <personne>                       <statistiques>                          <sexe>{$t/profile/gender/text()}</sexe>                          <age>{$t/profile/age/text()}</age>                          <education>{$t/profile/education/text()}</education>                          <revenu>{fn:data($t/profile/@income)}</revenu>                       </statistiques>                       <coordonnees>                          <nom>{$t/name/text()}</nom>                          <rue>{$t/address/street/text()}</rue>                          <ville>{$t/address/city/text()}</ville>                          <pays>{$t/address/country/text()}</pays>                          <reseau>                             <courrier>{$t/emailaddress/text()}</courrier>                             <pagePerso>{$t/homepage/text()}</pagePerso>                          </reseau>                       </coordonnees>                       <cartePaiement>{$t/creditcard/text()}</cartePaiement>                     </personne>              return <categorie>{<id>{$i}</id>, $p}</categorie> } </XMark-result-Q10>
XMark-Q11,Error: XPST0003: Unable to parse XPath: "(: Purpoose: For each person, list the number of items currently on sale           whose price does not exceed 0.02% of the person's income. :)           <XMark-result-Q11> {              let $auction := (/) return              for $p in $auction/site/people/person              let $l := for $i in $auction/site/open_auctions/open_auction/initial              where $p/profile/@income > 5000 * exactly-one($i/text())              return $i return <items name="{$p/name/text()}">{count($l)}</items> } </XMark-result-Q11>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. (: Purpoose: For each person, list the number of items currently on sale           whose price does not exceed 0.02% of the person's income. :)           <XMark-result-Q11> {              let $auction := (/) return              for $p in $auction/site/people/person              [Error is around here]let $l := for $i in $auction/site/open_auctions/open_auction/initial              where $p/profile/@income > 5000 * exactly-one($i/text())              return $i return <items name="{$p/name/text()}">{count($l)}</items> } </XMark-result-Q11>
XMark-Q12,Error: XPST0003: Unable to parse XPath: "(: Purpose: For each richer-than-average person, list the           number of items currently on sale whose price does not exceed 0.02% of the person's income. :)           <XMark-result-Q12> {              let $auction := (/) return              for $p in $auction/site/people/person              let $l := for $i in $auction/site/open_auctions/open_auction/initial              where $p/profile/@income > 5000.0 * exactly-one($i/text())              return $i where $p/profile/@income > 50000.0              return <items person="{$p/profile/@income}">{count($l)}</items> } </XMark-result-Q12>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. (: Purpose: For each richer-than-average person, list the           number of items currently on sale whose price does not exceed 0.02% of the person's income. :)           <XMark-result-Q12> {              let $auction := (/) return              for $p in $auction/site/people/person              [Error is around here]let $l := for $i in $auction/site/open_auctions/open_auction/initial              where $p/profile/@income > 5000.0 * exactly-one($i/text())              return $i where $p/profile/@income > 50000.0              return <items person="{$p/profile/@income}">{count($l)}</items> } </XMark-result-Q12>
XMark-Q14,Error: XPST0003: Unable to parse XPath: "(: Purpose: Return the names of all items whose description contains the word `gold'. :)           <XMark-result-Q14> {              let $auction := (/) return              for $i in $auction/site//item              where contains(string(exactly-one($i/description)), "gold")              return $i/name/text() } </XMark-result-Q14>". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found. (: Purpose: Return the names of all items whose description contains the word `gold'. :)           <XMark-result-Q14> {              let $auction := (/) return              for $i in $auction/site//item              [Error is around here]where contains(string(exactly-one($i/description)), "gold")              return $i/name/text() } </XMark-result-Q14>
XMark-Q16,Error: XPST0003: Unable to parse XPath: "(: Purpose: Return the IDs of those auctions that have one or more keywords in emphasis. (cf. Q15) :)           <XMark-result-Q16> {              let $auction := (/) return              for $a in $auction/site/closed_auctions/closed_auction              where not( empty( $a/annotation/description/parlist/listitem/parlist/listitem/text/emph/ keyword/ text() ) )              return <person id="{$a/seller/@person}"/> } </XMark-result-Q16>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found. (: Purpose: Return the IDs of those auctions that have one or more keywords in emphasis. (cf. Q15) :)           <XMark-result-Q16> {              let $auction := (/) return              for $a in $auction/site/closed_auctions/closed_auction              [Error is around here]where not( empty( $a/annotation/description/parlist/listitem/parlist/listitem/text/emph/ keyword/ text() ) )              return <person id="{$a/seller/@person}"/> } </XMark-result-Q16>
XMark-Q17,Error: XPST0003: Unable to parse XPath: "<XMark-result-Q17> {              let $auction := (/)              return for $p in $auction/site/people/person              where empty($p/homepage/text())              return <person name="{$p/name/text()}"/> } </XMark-result-Q17>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found. <XMark-result-Q17> {              let $auction := (/)              return for $p in $auction/site/people/person              [Error is around here]where empty($p/homepage/text())              return <person name="{$p/name/text()}"/> } </XMark-result-Q17>
XMark-Q18,AssertionError: Expected XPath (: Purpose: Convert the currency of the reserve of all open auctions to another currency. :)           declare namespace local = "http://www.example.com/";           declare function local:convert($v as xs:decimal?) as xs:decimal? { 2.20371 * $v };           <XMark-result-Q18> {              let $auction := (/) return              for $i in $auction/site/open_auctions/open_auction              return local:convert(zero-or-one($i/reserve)) } </XMark-result-Q18> to resolve to the given XML. Expected <XMark-result-Q18>546.7845252000001 487.1741697 286.8128565 35.920473 76.3585515 597.0070761000001 11.1287355 419.5423098 788.0907702000001 198.2457516 54.057006300000005 78.7165212 815.4608484 104.91863310000001 22.4117307 647.8246287000001 482.1276738 636.4534851 114.9014394 468.1120782 1236.3033471 1076.4462237 637.2468207000001 172.3521591 32.9013903 586.3631568 563.7971664 592.8861384 21.9930258 1213.2745776 1420.731837 1319.4713625 1383.5772864 175.5475386 1013.9490081 828.0881067 496.16530650000004 267.9931731 43.6775322 840.054252 17.916162300000003 1322.3361854999998 240.2484642 381.1096074 52.91107710000001 1126.1398842 2660.7153798000004 53.0653368 1404.3362346000001 991.3609806000001 496.8704937 2414.5168986000003 151.6593222 360.526956 1503.6354072000001 566.7721749 12.0322566 781.9424193 1039.1374134 1867.3577427 91.7845215 226.3650912 1058.0232081000001 142.1613321 109.70068380000001 109.4582757 328.7274207 33.8489856 119.2427481 3859.0047294000005 192.05332650000003 333.200952 24.196735800000003 72.08335410000001 901.0088706 149.52172349999998 1110.8902110000001 20.4063546 1521.4193469 790.9996674 204.9229929 56.3488647 81.2948619 281.8104348 659.7466998 1221.9131208000001 348.9354414 259.9716687 165.7410291 539.1376515000001 30.2789754 372.8456949 445.4579394 175.1508708 874.5202764 2120.1673539000003 2047.4008497000002 339.37134000000003 2125.6105176 5819.513293800001 369.98087189999995 1648.3310058000002 876.0849105000001 538.1239449 2418.5496879 955.7931012000001 7205.8452177 697.2979182 129.7764819 289.8099021 2041.1863875000001 133.8313083 356.18564729999997 369.121425 28.8245268 223.676565 2015.8216854 107.1443802 130.4375949 692.8023498 606.3728436000001 458.61408810000006 363.36974189999995 832.1870073 406.584495 666.2256072 71.53242660000001 1002.1371225 735.0474705 498.8097585 193.77222030000001 3815.2170117 2456.1449804999997 611.970267 643.1527635000001 187.64590650000002 117.1492236 40.8567834 34.9508406 2419.8058026 1744.5229473 173.6082738 821.4769767 127.15406700000001 2173.519173 325.31167020000004 171.0740073 1412.4458874000002 2032.7461782 349.5745173 435.1666137 1607.0995917 108.44456910000001 83.80709130000001 131.0766708 29.4856398 127.85925420000001 70.9374249 648.4416675 672.3078468 100.5112131 36.735845700000006 333.64169400000003 56.9659035 896.1607086000001 273.6346707 861.209868 56.7234954 366.2786391 259.6411122 1310.1717062999999 1211.2251273 923.6850465 1136.012505 299.88085680000006 415.37729790000003 447.4633155 393.3842721 200.9122407 208.691337</XMark-result-Q18> to equal undefined
XMark-Q19,Error: XPST0003: Unable to parse XPath: "(: Purpose: Give an alphabetically ordered list of all items along with their location. :)           <XMark-result-Q19> {              let $auction := (/) return              for $b in $auction/site/regions//item              let $k := $b/name/text() stable order by zero-or-one($b/location) ascending empty greatest              return <item name="{$k}">{$b/location/text()}</item> } </XMark-result-Q19>". Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. (: Purpose: Give an alphabetically ordered list of all items along with their location. :)           <XMark-result-Q19> {              let $auction := (/) return              for $b in $auction/site/regions//item              [Error is around here]let $k := $b/name/text() stable order by zero-or-one($b/location) ascending empty greatest              return <item name="{$k}">{$b/location/text()}</item> } </XMark-result-Q19>
XMark-Q20,Error: XPST0003: Unable to parse XPath: "<XMark-result-Q20> {              let $auction := (/) return                 <result>                    <preferred> {count($auction/site/people/person/profile[@income >= 100000.0])} </preferred>                   <standard> { count( $auction/site/people/person/ profile[@income < 100000.0 and @income >= 30000.0] ) } </standard>                   <challenge> {count($auction/site/people/person/profile[@income < 30000.0])} </challenge>                   <na> { count( for $p in $auction/site/people/person where empty($p/profile/@income) return $p ) } </na>                </result> } </XMark-result-Q20>". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found. <XMark-result-Q20> {              let $auction := (/) return                 <result>                    <preferred> {count($auction/site/people/person/profile[@income >= 100000.0])} </preferred>                   <standard> { count( $auction/site/people/person/ profile[@income < 100000.0 and @income >= 30000.0] ) } </standard>                   <challenge> {count($auction/site/people/person/profile[@income < 30000.0])} </challenge>                   <na> { count( for $p in $auction/site/people/person [Error is around here]where empty($p/profile/@income) return $p ) } </na>                </result> } </XMark-result-Q20>
XMark-All,Error: XPST0003: Unable to parse XPath: "(: Written By: Frans Englich(maintainer, not original author) :) (: Purpose: Return the name of the person with ID `person0'. :) (: Date: 2007-03-09 :)  declare namespace local = "http://www.example.com/";   declare function local:convert($v as xs:decimal?) as xs:decimal? {   2.20371 * $v (: convert Dfl to Euro :) };  <XMark-result-All>    <XMark-result-Q1>     {       let $auction := (/) return       for $b in $auction/site/people/person[@id = "person0"] return $b/name/text()     }   </XMark-result-Q1>    <XMark-result-Q2>     {       let $auction := (/) return       for $b in $auction/site/open_auctions/open_auction       return <increase>{$b/bidder[1]/increase/text()}</increase>     }   </XMark-result-Q2>      <XMark-result-Q3>     {       let $auction := (/) return       for $b in $auction/site/open_auctions/open_auction       where zero-or-one($b/bidder[1]/increase/text()) * 2.0 <= $b/bidder[last()]/increase/text()       return <increase first="{$b/bidder[1]/increase/text()}"                        last="{$b/bidder[last()]/increase/text()}"/>     }   </XMark-result-Q3>      <XMark-result-Q4>     {       let $auction := (/) return       for $b in $auction/site/open_auctions/open_auction       where         some $pr1 in $b/bidder/personref[@person = "person20"],              $pr2 in $b/bidder/personref[@person = "person51"]         satisfies $pr1 << $pr2       return <history>{$b/reserve/text()}</history>     }   </XMark-result-Q4>      <XMark-result-Q5>     {       let $auction := (/) return       count(for $i in $auction/site/closed_auctions/closed_auction             where $i/price/text() >= 40.0             return $i/price)     }   </XMark-result-Q5>      <XMark-result-Q6>     {       let $auction := (/) return       for $b in $auction//site/regions return count($b//item)     }   </XMark-result-Q6>      <XMark-result-Q7>     {       let $auction := (/) return       for $p in $auction/site       return count($p//description) + count($p//annotation) + count($p//emailaddress)     }   </XMark-result-Q7>      <XMark-result-Q8>     {       let $auction := (/) return       for $p in $auction/site/people/person       let $a := for $t in $auction/site/closed_auctions/closed_auction                 where $t/buyer/@person = $p/@id                 return $t       return <item person="{$p/name/text()}">{count($a)}</item>     }   </XMark-result-Q8>      <XMark-result-Q9>     {       let $auction := (/) return       let $ca := $auction/site/closed_auctions/closed_auction return       let $ei := $auction/site/regions/europe/item       for $p in $auction/site/people/person         let $a := for $t in $ca                   where $p/@id = $t/buyer/@person                   return let $n := for $t2 in $ei where $t/itemref/@item = $t2/@id return $t2                          return <item>{$n/name/text()}</item>       return <person name="{$p/name/text()}">{$a}</person>     }   </XMark-result-Q9>      <XMark-result-Q10>     {     let $auction := (/)     return       for $i in         distinct-values($auction/site/people/person/profile/interest/@category)       let $p :=         for $t in $auction/site/people/person         where $t/profile/interest/@category = $i         return           <personne>             <statistiques>               <sexe>{$t/profile/gender/text()}</sexe>               <age>{$t/profile/age/text()}</age>               <education>{$t/profile/education/text()}</education>               <revenu>{fn:data($t/profile/@income)}</revenu>             </statistiques>             <coordonnees>               <nom>{$t/name/text()}</nom>               <rue>{$t/address/street/text()}</rue>               <ville>{$t/address/city/text()}</ville>               <pays>{$t/address/country/text()}</pays>               <reseau>                 <courrier>{$t/emailaddress/text()}</courrier>                 <pagePerso>{$t/homepage/text()}</pagePerso>               </reseau>             </coordonnees>             <cartePaiement>{$t/creditcard/text()}</cartePaiement>           </personne>       return <categorie>{<id>{$i}</id>, $p}</categorie>     }   </XMark-result-Q10>      <XMark-result-Q11>     {       let $auction := (/) return       for $p in $auction/site/people/person       let $l := for $i in $auction/site/open_auctions/open_auction/initial                 where $p/profile/@income > 5000 * exactly-one($i/text())                 return $i       return <items name="{$p/name/text()}">{count($l)}</items>     }   </XMark-result-Q11>      <XMark-result-Q12>     {       let $auction := (/) return       for $p in $auction/site/people/person       let $l :=         for $i in $auction/site/open_auctions/open_auction/initial         where $p/profile/@income > 5000.0 * exactly-one($i/text())         return $i       where $p/profile/@income > 50000.0       return <items person="{$p/profile/@income}">{count($l)}</items>     }   </XMark-result-Q12>      <XMark-result-Q13>     {       let $auction := (/) return       for $i in $auction/site/regions/australia/item       return <item name="{$i/name/text()}">{$i/description}</item>     }   </XMark-result-Q13>      <XMark-result-Q14>     {       let $auction := (/) return       for $i in $auction/site//item       where contains(string(exactly-one($i/description)), "gold")       return $i/name/text()     }   </XMark-result-Q14>      <XMark-result-Q15>     {       let $auction := (/) return       for $a in         $auction/site/closed_auctions/closed_auction/annotation/description/parlist/          listitem/          parlist/          listitem/          text/          emph/          keyword/          text()       return <text>{$a}</text>     }   </XMark-result-Q15>      <XMark-result-Q16>     {       let $auction := (/) return       for $a in $auction/site/closed_auctions/closed_auction       where         not(           empty(             $a/annotation/description/parlist/listitem/parlist/listitem/text/emph/              keyword/              text()           )         )       return <person id="{$a/seller/@person}"/>     }   </XMark-result-Q16>      <XMark-result-Q17>     {       let $auction := (/) return       for $p in $auction/site/people/person       where empty($p/homepage/text())       return <person name="{$p/name/text()}"/>     }   </XMark-result-Q17>      <XMark-result-Q18>     {       let $auction := (/) return       for $i in $auction/site/open_auctions/open_auction       return local:convert(zero-or-one($i/reserve))     }   </XMark-result-Q18>      <XMark-result-Q19>     {       let $auction := (/) return       for $b in $auction/site/regions//item       let $k := $b/name/text()       stable order by zero-or-one($b/location) ascending empty greatest       return <item name="{$k}">{$b/location/text()}</item>     }   </XMark-result-Q19>      <XMark-result-Q20>     {       let $auction := (/) return       <result>         <preferred>           {count($auction/site/people/person/profile[@income >= 100000.0])}         </preferred>         <standard>           {             count(               $auction/site/people/person/                profile[@income < 100000.0 and @income >= 30000.0]             )           }         </standard>         <challenge>           {count($auction/site/people/person/profile[@income < 30000.0])}         </challenge>         <na>           {             count(               for $p in $auction/site/people/person               where empty($p/profile/@income)               return $p             )           }         </na>       </result>     }   </XMark-result-Q20>  </XMark-result-All> ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found. (: Written By: Frans Englich(maintainer, not original author) :) (: Purpose: Return the name of the person with ID `person0'. :) (: Date: 2007-03-09 :)  declare namespace local = "http://www.example.com/";   declare function local:convert($v as xs:decimal?) as xs:decimal? {   2.20371 * $v (: convert Dfl to Euro :) };  <XMark-result-All>    <XMark-result-Q1>     {       let $auction := (/) return       for $b in $auction/site/people/person[@id = "person0"] return $b/name/text()     }   </XMark-result-Q1>    <XMark-result-Q2>     {       let $auction := (/) return       for $b in $auction/site/open_auctions/open_auction       return <increase>{$b/bidder[1]/increase/text()}</increase>     }   </XMark-result-Q2>      <XMark-result-Q3>     {       let $auction := (/) return       for $b in $auction/site/open_auctions/open_auction       [Error is around here]where zero-or-one($b/bidder[1]/increase/text()) * 2.0 <= $b/bidder[last()]/increase/text()       return <increase first="{$b/bidder[1]/increase/text()}"                        last="{$b/bidder[last()]/increase/text()}"/>     }   </XMark-result-Q3>      <XMark-result-Q4>     {       let $auction := (/) return       for $b in $auction/site/open_auctions/open_auction       where         some $pr1 in $b/bidder/personref[@person = "person20"],              $pr2 in $b/bidder/personref[@person = "person51"]         satisfies $pr1 << $pr2       return <history>{$b/reserve/text()}</history>     }   </XMark-result-Q4>      <XMark-result-Q5>     {       let $auction := (/) return       count(for $i in $auction/site/closed_auctions/closed_auction             where $i/price/text() >= 40.0             return $i/price)     }   </XMark-result-Q5>      <XMark-result-Q6>     {       let $auction := (/) return       for $b in $auction//site/regions return count($b//item)     }   </XMark-result-Q6>      <XMark-result-Q7>     {       let $auction := (/) return       for $p in $auction/site       return count($p//description) + count($p//annotation) + count($p//emailaddress)     }   </XMark-result-Q7>      <XMark-result-Q8>     {       let $auction := (/) return       for $p in $auction/site/people/person       let $a := for $t in $auction/site/closed_auctions/closed_auction                 where $t/buyer/@person = $p/@id                 return $t       return <item person="{$p/name/text()}">{count($a)}</item>     }   </XMark-result-Q8>      <XMark-result-Q9>     {       let $auction := (/) return       let $ca := $auction/site/closed_auctions/closed_auction return       let $ei := $auction/site/regions/europe/item       for $p in $auction/site/people/person         let $a := for $t in $ca                   where $p/@id = $t/buyer/@person                   return let $n := for $t2 in $ei where $t/itemref/@item = $t2/@id return $t2                          return <item>{$n/name/text()}</item>       return <person name="{$p/name/text()}">{$a}</person>     }   </XMark-result-Q9>      <XMark-result-Q10>     {     let $auction := (/)     return       for $i in         distinct-values($auction/site/people/person/profile/interest/@category)       let $p :=         for $t in $auction/site/people/person         where $t/profile/interest/@category = $i         return           <personne>             <statistiques>               <sexe>{$t/profile/gender/text()}</sexe>               <age>{$t/profile/age/text()}</age>               <education>{$t/profile/education/text()}</education>               <revenu>{fn:data($t/profile/@income)}</revenu>             </statistiques>             <coordonnees>               <nom>{$t/name/text()}</nom>               <rue>{$t/address/street/text()}</rue>               <ville>{$t/address/city/text()}</ville>               <pays>{$t/address/country/text()}</pays>               <reseau>                 <courrier>{$t/emailaddress/text()}</courrier>                 <pagePerso>{$t/homepage/text()}</pagePerso>               </reseau>             </coordonnees>             <cartePaiement>{$t/creditcard/text()}</cartePaiement>           </personne>       return <categorie>{<id>{$i}</id>, $p}</categorie>     }   </XMark-result-Q10>      <XMark-result-Q11>     {       let $auction := (/) return       for $p in $auction/site/people/person       let $l := for $i in $auction/site/open_auctions/open_auction/initial                 where $p/profile/@income > 5000 * exactly-one($i/text())                 return $i       return <items name="{$p/name/text()}">{count($l)}</items>     }   </XMark-result-Q11>      <XMark-result-Q12>     {       let $auction := (/) return       for $p in $auction/site/people/person       let $l :=         for $i in $auction/site/open_auctions/open_auction/initial         where $p/profile/@income > 5000.0 * exactly-one($i/text())         return $i       where $p/profile/@income > 50000.0       return <items person="{$p/profile/@income}">{count($l)}</items>     }   </XMark-result-Q12>      <XMark-result-Q13>     {       let $auction := (/) return       for $i in $auction/site/regions/australia/item       return <item name="{$i/name/text()}">{$i/description}</item>     }   </XMark-result-Q13>      <XMark-result-Q14>     {       let $auction := (/) return       for $i in $auction/site//item       where contains(string(exactly-one($i/description)), "gold")       return $i/name/text()     }   </XMark-result-Q14>      <XMark-result-Q15>     {       let $auction := (/) return       for $a in         $auction/site/closed_auctions/closed_auction/annotation/description/parlist/          listitem/          parlist/          listitem/          text/          emph/          keyword/          text()       return <text>{$a}</text>     }   </XMark-result-Q15>      <XMark-result-Q16>     {       let $auction := (/) return       for $a in $auction/site/closed_auctions/closed_auction       where         not(           empty(             $a/annotation/description/parlist/listitem/parlist/listitem/text/emph/              keyword/              text()           )         )       return <person id="{$a/seller/@person}"/>     }   </XMark-result-Q16>      <XMark-result-Q17>     {       let $auction := (/) return       for $p in $auction/site/people/person       where empty($p/homepage/text())       return <person name="{$p/name/text()}"/>     }   </XMark-result-Q17>      <XMark-result-Q18>     {       let $auction := (/) return       for $i in $auction/site/open_auctions/open_auction       return local:convert(zero-or-one($i/reserve))     }   </XMark-result-Q18>      <XMark-result-Q19>     {       let $auction := (/) return       for $b in $auction/site/regions//item       let $k := $b/name/text()       stable order by zero-or-one($b/location) ascending empty greatest       return <item name="{$k}">{$b/location/text()}</item>     }   </XMark-result-Q19>      <XMark-result-Q20>     {       let $auction := (/) return       <result>         <preferred>           {count($auction/site/people/person/profile[@income >= 100000.0])}         </preferred>         <standard>           {             count(               $auction/site/people/person/                profile[@income < 100000.0 and @income >= 30000.0]             )           }         </standard>         <challenge>           {count($auction/site/people/person/profile[@income < 30000.0])}         </challenge>         <na>           {             count(               for $p in $auction/site/people/person               where empty($p/profile/@income)               return $p             )           }         </na>       </result>     }   </XMark-result-Q20>  </XMark-result-All>
fo-test-fn-string-005,AssertionError: expected [Function] to throw an error
fo-test-fn-string-006,AssertionError: expected [Function] to throw an error
fo-test-fn-data-001,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
fo-test-fn-data-002,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
fo-test-fn-data-003,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
fo-test-fn-data-004,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
fo-test-fn-data-005,Error: XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?
fo-test-fn-data-006,AssertionError: expected [Function] to throw error including 'FOTY0013' but got 'XPST0017: Function data with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}date (xs:anyAtomicType?)"?'
fo-test-fn-error-001,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function fn:error with arity of 0 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?'
fo-test-fn-format-integer-001,Error: XPST0017: Function format-integer with arity of 2 not registered. No similar functions found.
fo-test-fn-format-integer-002,Error: XPST0017: Function format-integer with arity of 3 not registered. No similar functions found.
fo-test-fn-format-integer-003,Error: XPST0017: Function format-integer with arity of 2 not registered. No similar functions found.
fo-test-fn-format-integer-004,Error: XPST0017: Function format-integer with arity of 2 not registered. No similar functions found.
fo-test-fn-format-integer-005,Error: XPST0017: Function format-integer with arity of 2 not registered. No similar functions found.
fo-test-fn-format-number-001,Error: XPST0017: Function format-number with arity of 2 not registered. No similar functions found.
fo-test-fn-format-number-002,Error: XPST0017: Function format-number with arity of 2 not registered. No similar functions found.
fo-test-fn-format-number-003,Error: XPST0017: Function format-number with arity of 2 not registered. No similar functions found.
fo-test-fn-format-number-004,Error: XPST0017: Function format-number with arity of 2 not registered. No similar functions found.
fo-test-fn-format-number-005,Error: XPST0017: Function format-number with arity of 2 not registered. No similar functions found.
fo-test-fn-format-number-006,Error: XPST0017: Function format-number with arity of 3 not registered. No similar functions found.
fo-test-fn-format-number-007,Error: XPST0017: Function format-number with arity of 3 not registered. No similar functions found.
fo-test-fn-format-number-008,Error: XPST0017: Function format-number with arity of 3 not registered. No similar functions found.
fo-test-fn-format-number-009,Error: XPST0017: Function format-number with arity of 3 not registered. No similar functions found.
fo-test-fn-format-number-010,Error: XPST0017: Function format-number with arity of 3 not registered. No similar functions found.
fo-test-math-exp-004,AssertionError: Expected XPath          math:exp(2)        to (deep equally) resolve to 7.38905609893065e0: expected false to be true
fo-test-math-exp-006,AssertionError: Expected XPath          math:exp(math:pi())        to (deep equally) resolve to 23.140692632779267e0: expected false to be true
fo-test-fn-codepoints-to-string-001,Error: XPST0017: Function fn:codepoints-to-string with arity of 1 not registered. No similar functions found.
fo-test-fn-codepoints-to-string-002,Error: XPST0017: Function fn:codepoints-to-string with arity of 1 not registered. No similar functions found.
fo-test-fn-codepoints-to-string-003,Error: XPST0017: Function fn:codepoints-to-string with arity of 1 not registered. No similar functions found.
fo-test-fn-codepoints-to-string-004,AssertionError: expected [Function] to throw error including 'FOCH0001' but got 'XPST0017: Function fn:codepoints-to-string with arity of 1 not registered. No similar functions found.'
fo-test-fn-string-to-codepoints-001,Error: XPST0017: Function fn:string-to-codepoints with arity of 1 not registered. No similar functions found.
fo-test-fn-compare-002,AssertionError: Expected XPath          fn:compare('Strasse', 'Straße')        to (deep equally) resolve to 0: expected false to be true
fo-test-fn-compare-003,Error: FOCH0002: No collations are supported
fo-test-fn-compare-004,AssertionError: Expected XPath          fn:compare('Strassen', 'Straße')        to (deep equally) resolve to 1: expected false to be true
fo-test-fn-codepoint-equal-001,Error: XPST0017: Function fn:codepoint-equal with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}deep-equal (item()*, item()*)" or "Q{http://www.w3.org/2005/xpath-functions}deep-equal (item()*, item()*, xs:string)"?
fo-test-fn-codepoint-equal-002,Error: XPST0017: Function fn:codepoint-equal with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}deep-equal (item()*, item()*)" or "Q{http://www.w3.org/2005/xpath-functions}deep-equal (item()*, item()*, xs:string)"?
fo-test-fn-codepoint-equal-003,Error: XPST0017: Function fn:codepoint-equal with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}deep-equal (item()*, item()*)" or "Q{http://www.w3.org/2005/xpath-functions}deep-equal (item()*, item()*, xs:string)"?
fo-test-fn-codepoint-equal-004,Error: XPST0017: Function fn:codepoint-equal with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}deep-equal (item()*, item()*)" or "Q{http://www.w3.org/2005/xpath-functions}deep-equal (item()*, item()*, xs:string)"?
fo-test-fn-codepoint-equal-005,Error: XPST0017: Function fn:codepoint-equal with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}deep-equal (item()*, item()*)" or "Q{http://www.w3.org/2005/xpath-functions}deep-equal (item()*, item()*, xs:string)"?
fo-test-fn-string-join-001,Error: XPTY0004 Unable to convert to type
fo-test-fn-string-join-006,Error: XPTY0004 Unable to convert to type
fo-test-fn-translate-001,Error: XPST0017: Function fn:translate with arity of 3 not registered. No similar functions found.
fo-test-fn-translate-002,Error: XPST0017: Function fn:translate with arity of 3 not registered. No similar functions found.
fo-test-fn-translate-003,Error: XPST0017: Function fn:translate with arity of 3 not registered. No similar functions found.
fo-test-fn-encode-for-uri-001,Error: XPST0017: Function fn:encode-for-uri with arity of 1 not registered. No similar functions found.
fo-test-fn-encode-for-uri-002,Error: XPST0017: Function encode-for-uri with arity of 1 not registered. No similar functions found.
fo-test-fn-encode-for-uri-003,Error: XPST0017: Function encode-for-uri with arity of 1 not registered. No similar functions found.
fo-test-fn-iri-to-uri-001,Error: XPST0017: Function fn:iri-to-uri with arity of 1 not registered. No similar functions found.
fo-test-fn-iri-to-uri-002,Error: XPST0017: Function fn:iri-to-uri with arity of 1 not registered. No similar functions found.
fo-test-fn-escape-html-uri-001,Error: XPST0017: Function fn:escape-html-uri with arity of 1 not registered. No similar functions found.
fo-test-fn-escape-html-uri-002,Error: XPST0017: Function fn:escape-html-uri with arity of 1 not registered. No similar functions found.
fo-test-fn-contains-004,Error: FOCH0002: No collations are supported
fo-test-fn-contains-005,Error: FOCH0002: No collations are supported
fo-test-fn-contains-006,Error: FOCH0002: No collations are supported
fo-test-fn-contains-007,Error: FOCH0002: No collations are supported
fo-test-fn-starts-with-004,Error: FOCH0002: No collations are supported
fo-test-fn-starts-with-005,Error: FOCH0002: No collations are supported
fo-test-fn-starts-with-006,Error: FOCH0002: No collations are supported
fo-test-fn-starts-with-007,Error: FOCH0002: No collations are supported
fo-test-fn-starts-with-008,Error: FOCH0002: No collations are supported
fo-test-fn-ends-with-004,Error: FOCH0002: No collations are supported
fo-test-fn-ends-with-005,Error: FOCH0002: No collations are supported
fo-test-fn-ends-with-006,Error: FOCH0002: No collations are supported
fo-test-fn-ends-with-007,Error: FOCH0002: No collations are supported
fo-test-fn-ends-with-008,Error: FOCH0002: No collations are supported
fo-test-fn-substring-before-004,Error: XPST0017: Function fn:substring-before with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}insert-before (item()*, xs:integer, item()*)"?
fo-test-fn-substring-before-005,Error: XPST0017: Function fn:substring-before with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}insert-before (item()*, xs:integer, item()*)"?
fo-test-fn-substring-before-006,Error: XPST0017: Function fn:substring-before with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}insert-before (item()*, xs:integer, item()*)"?
fo-test-fn-substring-before-007,Error: XPST0017: Function fn:substring-before with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}insert-before (item()*, xs:integer, item()*)"?
fo-test-fn-substring-after-004,Error: XPST0017: Function fn:substring-after with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)"?
fo-test-fn-substring-after-005,Error: XPST0017: Function fn:substring-after with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)"?
fo-test-fn-substring-after-006,Error: XPST0017: Function fn:substring-after with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)"?
fo-test-fn-substring-after-007,Error: XPST0017: Function fn:substring-after with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}substring-after (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring-before (xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double)" or "Q{http://www.w3.org/2005/xpath-functions}substring (xs:string?, xs:double, xs:double)"?
fo-test-fn-matches-001,Error: XPST0017: Function fn:matches with arity of 2 not registered. No similar functions found.
fo-test-fn-matches-002,Error: XPST0017: Function fn:matches with arity of 2 not registered. No similar functions found.
fo-test-fn-matches-003,Error: XPST0017: Function fn:matches with arity of 2 not registered. No similar functions found.
fo-test-fn-matches-004,Error: XPST0017: Function fn:matches with arity of 2 not registered. No similar functions found.
fo-test-fn-matches-005,Error: XPST0017: Function fn:matches with arity of 3 not registered. No similar functions found.
fo-test-fn-matches-006,Error: XPST0017: Function fn:matches with arity of 3 not registered. No similar functions found.
fo-test-fn-matches-007,Error: XPST0017: Function fn:matches with arity of 2 not registered. No similar functions found.
fo-test-fn-matches-008,Error: XPST0017: Function fn:matches with arity of 3 not registered. No similar functions found.
fo-test-fn-replace-001,Error: XPST0017: Function fn:replace with arity of 3 not registered. No similar functions found.
fo-test-fn-replace-002,Error: XPST0017: Function fn:replace with arity of 3 not registered. No similar functions found.
fo-test-fn-replace-003,Error: XPST0017: Function fn:replace with arity of 3 not registered. No similar functions found.
fo-test-fn-replace-004,Error: XPST0017: Function fn:replace with arity of 3 not registered. No similar functions found.
fo-test-fn-replace-005,Error: XPST0017: Function fn:replace with arity of 3 not registered. No similar functions found.
fo-test-fn-replace-006,Error: XPST0017: Function fn:replace with arity of 3 not registered. No similar functions found.
fo-test-fn-replace-007,Error: XPST0017: Function fn:replace with arity of 3 not registered. No similar functions found.
fo-test-fn-replace-008,Error: XPST0017: Function fn:replace with arity of 3 not registered. No similar functions found.
fo-test-fn-tokenize-006,Error: Not implemented: Using flags in tokenize is not supported
fo-test-fn-analyze-string-001,Error: XPST0017: Function fn:analyze-string with arity of 2 not registered. No similar functions found.
fo-test-fn-analyze-string-002,Error: XPST0017: Function fn:analyze-string with arity of 2 not registered. No similar functions found.
fo-test-fn-analyze-string-003,Error: XPST0017: Function fn:analyze-string with arity of 2 not registered. No similar functions found.
fo-test-fn-contains-token-001,Error: XPST0017: Function fn:contains-token with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}contains (xs:string?, xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}contains (xs:string?, xs:string?)" or "Q{http://www.w3.org/2005/xpath-functions/map}contains (map(*), xs:anyAtomicType)"?
fo-test-fn-contains-token-002,Error: XPST0017: Function fn:contains-token with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}contains (xs:string?, xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}contains (xs:string?, xs:string?)" or "Q{http://www.w3.org/2005/xpath-functions/map}contains (map(*), xs:anyAtomicType)"?
fo-test-fn-contains-token-003,Error: XPST0017: Function fn:contains-token with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}contains (xs:string?, xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}contains (xs:string?, xs:string?)" or "Q{http://www.w3.org/2005/xpath-functions/map}contains (map(*), xs:anyAtomicType)"?
fo-test-fn-contains-token-004,Error: XPST0017: Function fn:contains-token with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}contains (xs:string?, xs:string?, xs:string?)", "Q{http://www.w3.org/2005/xpath-functions}contains (xs:string?, xs:string?)" or "Q{http://www.w3.org/2005/xpath-functions/map}contains (map(*), xs:anyAtomicType)"?
fo-test-fn-year-from-dateTime-004,AssertionError: Expected XPath          fn:year-from-dateTime(xs:dateTime("1999-12-31T24:00:00"))        to (deep equally) resolve to 2000: expected false to be true
fo-test-fn-month-from-dateTime-003,Error: XPST0017: Function fn:adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
fo-test-fn-day-from-dateTime-003,Error: XPST0017: Function fn:adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
fo-test-fn-hours-from-dateTime-003,Error: XPST0017: Function fn:adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
fo-test-fn-timezone-from-dateTime-001,AssertionError: Expected XPath          fn:timezone-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))        to (deep equally) resolve to xs:dayTimeDuration("-PT5H"): expected false to be true
fo-test-fn-timezone-from-dateTime-002,AssertionError: Expected XPath          fn:timezone-from-dateTime(xs:dateTime("2000-06-12T13:20:00Z"))        to (deep equally) resolve to xs:dayTimeDuration("PT0S"): expected false to be true
fo-test-fn-timezone-from-date-001,AssertionError: Expected XPath          fn:timezone-from-date(xs:date("1999-05-31-05:00"))        to (deep equally) resolve to xs:dayTimeDuration("-PT5H"): expected false to be true
fo-test-fn-timezone-from-date-002,AssertionError: Expected XPath          fn:timezone-from-date(xs:date("2000-06-12Z"))        to (deep equally) resolve to xs:dayTimeDuration("PT0S"): expected false to be true
fo-test-fn-hours-from-time-004,Error: XPST0017: Function fn:adjust-time-to-timezone with arity of 2 not registered. No similar functions found.
fo-test-fn-timezone-from-time-001,AssertionError: Expected XPath          fn:timezone-from-time(xs:time("13:20:00-05:00"))        to (deep equally) resolve to xs:dayTimeDuration("-PT5H"): expected false to be true
fo-test-fn-adjust-dateTime-to-timezone-002,Error: XPST0017: Function fn:adjust-dateTime-to-timezone with arity of 1 not registered. No similar functions found.
fo-test-fn-adjust-dateTime-to-timezone-003,Error: XPST0017: Function fn:adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
fo-test-fn-adjust-dateTime-to-timezone-004,Error: XPST0017: Function fn:adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
fo-test-fn-adjust-dateTime-to-timezone-005,Error: XPST0017: Function fn:adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
fo-test-fn-adjust-dateTime-to-timezone-006,Error: XPST0017: Function fn:adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
fo-test-fn-adjust-dateTime-to-timezone-007,Error: XPST0017: Function fn:adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
fo-test-fn-adjust-dateTime-to-timezone-008,Error: XPST0017: Function fn:adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
fo-test-fn-adjust-date-to-timezone-003,Error: XPST0017: Function fn:adjust-date-to-timezone with arity of 2 not registered. No similar functions found.
fo-test-fn-adjust-date-to-timezone-004,Error: XPST0017: Function fn:adjust-date-to-timezone with arity of 2 not registered. No similar functions found.
fo-test-fn-adjust-date-to-timezone-005,Error: XPST0017: Function fn:adjust-date-to-timezone with arity of 2 not registered. No similar functions found.
fo-test-fn-adjust-date-to-timezone-006,Error: XPST0017: Function fn:adjust-date-to-timezone with arity of 2 not registered. No similar functions found.
fo-test-fn-adjust-time-to-timezone-002,Error: XPST0017: Function fn:adjust-time-to-timezone with arity of 1 not registered. No similar functions found.
fo-test-fn-adjust-time-to-timezone-003,Error: XPST0017: Function fn:adjust-time-to-timezone with arity of 2 not registered. No similar functions found.
fo-test-fn-adjust-time-to-timezone-004,Error: XPST0017: Function fn:adjust-time-to-timezone with arity of 2 not registered. No similar functions found.
fo-test-fn-adjust-time-to-timezone-005,Error: XPST0017: Function fn:adjust-time-to-timezone with arity of 2 not registered. No similar functions found.
fo-test-fn-adjust-time-to-timezone-006,Error: XPST0017: Function fn:adjust-time-to-timezone with arity of 2 not registered. No similar functions found.
fo-test-fn-adjust-time-to-timezone-007,Error: XPST0017: Function fn:adjust-time-to-timezone with arity of 2 not registered. No similar functions found.
fo-test-fn-parse-ietf-date-001,Error: XPST0017: Function fn:parse-ietf-date with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}current-date ()"?
fo-test-fn-parse-ietf-date-002,Error: XPST0017: Function fn:parse-ietf-date with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}current-date ()"?
fo-test-fn-parse-ietf-date-003,Error: XPST0017: Function fn:parse-ietf-date with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}current-date ()"?
fo-test-fn-parse-ietf-date-004,Error: XPST0017: Function fn:parse-ietf-date with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}current-date ()"?
fo-test-fn-parse-ietf-date-005,Error: XPST0017: Function fn:parse-ietf-date with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}current-date ()"?
fo-test-fn-namespace-uri-for-prefix-001,Error: XPST0017: Function fn:namespace-uri-for-prefix with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}namespace-uri-from-QName (xs:QName?)", "Q{http://www.w3.org/2005/xpath-functions}namespace-uri (node())" or "Q{http://www.w3.org/2005/xpath-functions}namespace-uri ()"?
fo-test-fn-namespace-uri-for-prefix-002,Error: XPST0017: Function fn:namespace-uri-for-prefix with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}namespace-uri-from-QName (xs:QName?)", "Q{http://www.w3.org/2005/xpath-functions}namespace-uri (node())" or "Q{http://www.w3.org/2005/xpath-functions}namespace-uri ()"?
fo-test-fn-namespace-uri-for-prefix-003,Error: XPST0017: Function fn:namespace-uri-for-prefix with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}namespace-uri-from-QName (xs:QName?)", "Q{http://www.w3.org/2005/xpath-functions}namespace-uri (node())" or "Q{http://www.w3.org/2005/xpath-functions}namespace-uri ()"?
fo-test-fn-namespace-uri-for-prefix-004,Error: XPST0017: Function fn:namespace-uri-for-prefix with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}namespace-uri-from-QName (xs:QName?)", "Q{http://www.w3.org/2005/xpath-functions}namespace-uri (node())" or "Q{http://www.w3.org/2005/xpath-functions}namespace-uri ()"?
fo-test-fn-namespace-uri-for-prefix-005,Error: XPST0017: Function fn:namespace-uri-for-prefix with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}namespace-uri-from-QName (xs:QName?)", "Q{http://www.w3.org/2005/xpath-functions}namespace-uri (node())" or "Q{http://www.w3.org/2005/xpath-functions}namespace-uri ()"?
fo-test-fn-path-001,Error: XPST0003: Unable to parse XPath: "deep-equal((           let $e :=             document {             <p xmlns="http://example.com/one" xml:lang="de" author="Friedrich von Schiller"> Freude, schöner Götterfunken,<br/> Tochter aus Elysium,<br/> Wir betreten feuertrunken,<br/> Himmlische, dein Heiligtum.</p>}                      return                    fn:path($e)       ), ('/'))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found. deep-equal((           let $e :=             document [Error is around here]{             <p xmlns="http://example.com/one" xml:lang="de" author="Friedrich von Schiller"> Freude, schöner Götterfunken,<br/> Tochter aus Elysium,<br/> Wir betreten feuertrunken,<br/> Himmlische, dein Heiligtum.</p>}                      return                    fn:path($e)       ), ('/'))
fo-test-fn-path-002,Error: XPST0003: Unable to parse XPath: "deep-equal((           let $e :=             document {             <p xmlns="http://example.com/one" xml:lang="de" author="Friedrich von Schiller"> Freude, schöner Götterfunken,<br/> Tochter aus Elysium,<br/> Wir betreten feuertrunken,<br/> Himmlische, dein Heiligtum.</p>}                      return                    fn:path($e/*:p)       ), ('/Q{http://example.com/one}p[1]'))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found. deep-equal((           let $e :=             document [Error is around here]{             <p xmlns="http://example.com/one" xml:lang="de" author="Friedrich von Schiller"> Freude, schöner Götterfunken,<br/> Tochter aus Elysium,<br/> Wir betreten feuertrunken,<br/> Himmlische, dein Heiligtum.</p>}                      return                    fn:path($e/*:p)       ), ('/Q{http://example.com/one}p[1]'))
fo-test-fn-path-003,Error: XPST0003: Unable to parse XPath: "deep-equal((           let $e :=             document {             <p xmlns="http://example.com/one" xml:lang="de" author="Friedrich von Schiller"> Freude, schöner Götterfunken,<br/> Tochter aus Elysium,<br/> Wir betreten feuertrunken,<br/> Himmlische, dein Heiligtum.</p>}                      return                    fn:path($e/*:p/@xml:lang)       ), ('/Q{http://example.com/one}p[1]/@Q{http://www.w3.org/XML/1998/namespace}lang'))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found. deep-equal((           let $e :=             document [Error is around here]{             <p xmlns="http://example.com/one" xml:lang="de" author="Friedrich von Schiller"> Freude, schöner Götterfunken,<br/> Tochter aus Elysium,<br/> Wir betreten feuertrunken,<br/> Himmlische, dein Heiligtum.</p>}                      return                    fn:path($e/*:p/@xml:lang)       ), ('/Q{http://example.com/one}p[1]/@Q{http://www.w3.org/XML/1998/namespace}lang'))
fo-test-fn-path-004,Error: XPST0003: Unable to parse XPath: "deep-equal((           let $e :=             document {             <p xmlns="http://example.com/one" xml:lang="de" author="Friedrich von Schiller"> Freude, schöner Götterfunken,<br/> Tochter aus Elysium,<br/> Wir betreten feuertrunken,<br/> Himmlische, dein Heiligtum.</p>}                      return                    fn:path($e/*:p/@author)       ), ('/Q{http://example.com/one}p[1]/@author'))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found. deep-equal((           let $e :=             document [Error is around here]{             <p xmlns="http://example.com/one" xml:lang="de" author="Friedrich von Schiller"> Freude, schöner Götterfunken,<br/> Tochter aus Elysium,<br/> Wir betreten feuertrunken,<br/> Himmlische, dein Heiligtum.</p>}                      return                    fn:path($e/*:p/@author)       ), ('/Q{http://example.com/one}p[1]/@author'))
fo-test-fn-path-005,Error: XPST0003: Unable to parse XPath: "deep-equal((           let $e :=             document {             <p xmlns="http://example.com/one" xml:lang="de" author="Friedrich von Schiller"> Freude, schöner Götterfunken,<br/> Tochter aus Elysium,<br/> Wir betreten feuertrunken,<br/> Himmlische, dein Heiligtum.</p>}                      return                    fn:path($e/*:p/*:br[2])       ), ('/Q{http://example.com/one}p[1]/Q{http://example.com/one}br[2]'))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found. deep-equal((           let $e :=             document [Error is around here]{             <p xmlns="http://example.com/one" xml:lang="de" author="Friedrich von Schiller"> Freude, schöner Götterfunken,<br/> Tochter aus Elysium,<br/> Wir betreten feuertrunken,<br/> Himmlische, dein Heiligtum.</p>}                      return                    fn:path($e/*:p/*:br[2])       ), ('/Q{http://example.com/one}p[1]/Q{http://example.com/one}br[2]'))
fo-test-fn-path-006,Error: XPST0003: Unable to parse XPath: "deep-equal((           let $e :=             document {             <p xmlns="http://example.com/one" xml:lang="de" author="Friedrich von Schiller"> Freude, schöner Götterfunken,<br/> Tochter aus Elysium,<br/> Wir betreten feuertrunken,<br/> Himmlische, dein Heiligtum.</p>}                      return                    fn:path($e//text()[starts-with(normalize-space(),                   'Tochter')])       ), ('/Q{http://example.com/one}p[1]/text()[2]'))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found. deep-equal((           let $e :=             document [Error is around here]{             <p xmlns="http://example.com/one" xml:lang="de" author="Friedrich von Schiller"> Freude, schöner Götterfunken,<br/> Tochter aus Elysium,<br/> Wir betreten feuertrunken,<br/> Himmlische, dein Heiligtum.</p>}                      return                    fn:path($e//text()[starts-with(normalize-space(),                   'Tochter')])       ), ('/Q{http://example.com/one}p[1]/text()[2]'))
fo-test-fn-path-007,Error: XPST0017: Function fn:path with arity of 1 not registered. No similar functions found.
fo-test-fn-path-008,Error: XPST0017: Function fn:path with arity of 1 not registered. No similar functions found.
fo-test-fn-path-009,Error: XPST0017: Function fn:path with arity of 1 not registered. No similar functions found.
fo-test-fn-index-of-001,Error: XPST0017: Function fn:index-of with arity of 2 not registered. No similar functions found.
fo-test-fn-index-of-002,Error: XPST0017: Function fn:index-of with arity of 2 not registered. No similar functions found.
fo-test-fn-index-of-003,Error: XPST0017: Function fn:index-of with arity of 2 not registered. No similar functions found.
fo-test-fn-index-of-004,Error: XPST0017: Function fn:index-of with arity of 2 not registered. No similar functions found.
fo-test-fn-index-of-005,Error: XPST0017: Function fn:index-of with arity of 2 not registered. No similar functions found.
fo-test-fn-distinct-values-001,AssertionError: Skipped test, it was a assert-permutation
fo-test-fn-distinct-values-002,AssertionError: Skipped test, it was a assert-permutation
fo-test-fn-unordered-001,AssertionError: Skipped test, it was a assert-permutation
fo-test-fn-avg-002,Error: FORG0006: items passed to fn:avg are not all numeric.
fo-test-fn-max-002,AssertionError: Expected XPath          fn:max([3,4,5])        to (deep equally) resolve to 5: expected false to be true
fo-test-fn-min-002,AssertionError: Expected XPath          fn:min([3,4,5])        to (deep equally) resolve to 3: expected false to be true
fo-test-fn-sum-001,Error: FORG0006: items passed to fn:sum are not all numeric.
fo-test-fn-sum-002,AssertionError: Expected XPath            let $d1 := xs:yearMonthDuration("P20Y")                       return                      let $d2 := xs:yearMonthDuration("P10M")                       return                      let $seq1 := ($d1, $d2)                       return                    fn:sum($seq1[. lt xs:yearMonthDuration('P3M')],                   xs:yearMonthDuration('P0M'))        to (deep equally) resolve to xs:yearMonthDuration("P0M"): expected false to be true
fo-test-fn-sum-007,Error: FORG0006: items passed to fn:sum are not all numeric.
fo-test-fn-sum-008,Error: FORG0006: items passed to fn:sum are not all numeric.
fo-test-fn-sum-009,Error: FORG0006: items passed to fn:sum are not all numeric.
fo-test-fn-id-001,Error: XPST0003: Unable to parse XPath: "deep-equal((           let $emp :=                     validate lax{               document{             <employee xml:id="ID21256"                       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"                         xmlns:xs="http://www.w3.org/2001/XMLSchema">                <empnr xsi:type="xs:ID">E21256</empnr>                <first>John</first>                <last>Brown</last>             </employee>           }         }                      return                    $emp/id('ID21256')/name()       ), ("employee"))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. deep-equal((           let $emp :=                     validate [Error is around here]lax{               document{             <employee xml:id="ID21256"                       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"                         xmlns:xs="http://www.w3.org/2001/XMLSchema">                <empnr xsi:type="xs:ID">E21256</empnr>                <first>John</first>                <last>Brown</last>             </employee>           }         }                      return                    $emp/id('ID21256')/name()       ), ("employee"))
fo-test-fn-id-002,Error: XPST0003: Unable to parse XPath: "deep-equal((           let $emp :=                     validate lax{               document{             <employee xml:id="ID21256"                       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"                         xmlns:xs="http://www.w3.org/2001/XMLSchema">                <empnr xsi:type="xs:ID">E21256</empnr>                <first>John</first>                <last>Brown</last>             </employee>           }         }                      return                    $emp/id('E21256')/name()       ), ("empnr"))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. deep-equal((           let $emp :=                     validate [Error is around here]lax{               document{             <employee xml:id="ID21256"                       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"                         xmlns:xs="http://www.w3.org/2001/XMLSchema">                <empnr xsi:type="xs:ID">E21256</empnr>                <first>John</first>                <last>Brown</last>             </employee>           }         }                      return                    $emp/id('E21256')/name()       ), ("empnr"))
fo-test-fn-element-with-id-001,Error: XPST0003: Unable to parse XPath: "deep-equal((           let $emp :=                      validate lax{               document{             <employee xml:id="ID21256"                       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"                         xmlns:xs="http://www.w3.org/2001/XMLSchema">                <empnr xsi:type="xs:ID">E21256</empnr>                <first>John</first>                <last>Brown</last>             </employee>           }         }                      return                    $emp/fn:element-with-id('ID21256')/name()       ), ("employee"))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. deep-equal((           let $emp :=                      validate [Error is around here]lax{               document{             <employee xml:id="ID21256"                       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"                         xmlns:xs="http://www.w3.org/2001/XMLSchema">                <empnr xsi:type="xs:ID">E21256</empnr>                <first>John</first>                <last>Brown</last>             </employee>           }         }                      return                    $emp/fn:element-with-id('ID21256')/name()       ), ("employee"))
fo-test-fn-element-with-id-002,Error: XPST0003: Unable to parse XPath: "deep-equal((           let $emp :=                      validate lax{               document{             <employee xml:id="ID21256"                       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"                         xmlns:xs="http://www.w3.org/2001/XMLSchema">                <empnr xsi:type="xs:ID">E21256</empnr>                <first>John</first>                <last>Brown</last>             </employee>           }         }                      return                    $emp/fn:element-with-id('E21256')/name()       ), ("employee"))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. deep-equal((           let $emp :=                      validate [Error is around here]lax{               document{             <employee xml:id="ID21256"                       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"                         xmlns:xs="http://www.w3.org/2001/XMLSchema">                <empnr xsi:type="xs:ID">E21256</empnr>                <first>John</first>                <last>Brown</last>             </employee>           }         }                      return                    $emp/fn:element-with-id('E21256')/name()       ), ("employee"))
fo-test-fn-idref-001,Error: XPST0003: Unable to parse XPath: "deep-equal((           let $emp :=                   validate lax {           document {               <employees xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"                        xmlns:xs="http://www.w3.org/2001/XMLSchema">               <employee xml:id="ID21256">                <empnr xsi:type="xs:ID">E21256</empnr>                <first>Anil</first>                <last>Singh</last>                <deputy xsi:type="xs:IDREF">E30561</deputy>             </employee>             <employee xml:id="ID30561">                <empnr xsi:type="xs:ID">E30561</empnr>                <first>John</first>                <last>Brown</last>                <manager xsi:type="xs:IDREF">ID21256</manager>             </employee>           </employees>         }       }                      return                    $emp/(element-with-id('ID21256')/@xml:id => fn:idref())/ancestor::employee/last => string()       ), ("Brown"))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. deep-equal((           let $emp :=                   validate [Error is around here]lax {           document {               <employees xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"                        xmlns:xs="http://www.w3.org/2001/XMLSchema">               <employee xml:id="ID21256">                <empnr xsi:type="xs:ID">E21256</empnr>                <first>Anil</first>                <last>Singh</last>                <deputy xsi:type="xs:IDREF">E30561</deputy>             </employee>             <employee xml:id="ID30561">                <empnr xsi:type="xs:ID">E30561</empnr>                <first>John</first>                <last>Brown</last>                <manager xsi:type="xs:IDREF">ID21256</manager>             </employee>           </employees>         }       }                      return                    $emp/(element-with-id('ID21256')/@xml:id => fn:idref())/ancestor::employee/last => string()       ), ("Brown"))
fo-test-fn-idref-002,Error: XPST0003: Unable to parse XPath: "deep-equal((           let $emp :=                   validate lax {           document {               <employees xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"                        xmlns:xs="http://www.w3.org/2001/XMLSchema">               <employee xml:id="ID21256">                <empnr xsi:type="xs:ID">E21256</empnr>                <first>Anil</first>                <last>Singh</last>                <deputy xsi:type="xs:IDREF">E30561</deputy>             </employee>             <employee xml:id="ID30561">                <empnr xsi:type="xs:ID">E30561</empnr>                <first>John</first>                <last>Brown</last>                <manager xsi:type="xs:IDREF">ID21256</manager>             </employee>           </employees>         }       }                      return                    $emp/(element-with-id('E30561')/empnr => fn:idref())/ancestor::employee/last => string()       ), ("Singh"))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found. deep-equal((           let $emp :=                   validate [Error is around here]lax {           document {               <employees xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"                        xmlns:xs="http://www.w3.org/2001/XMLSchema">               <employee xml:id="ID21256">                <empnr xsi:type="xs:ID">E21256</empnr>                <first>Anil</first>                <last>Singh</last>                <deputy xsi:type="xs:IDREF">E30561</deputy>             </employee>             <employee xml:id="ID30561">                <empnr xsi:type="xs:ID">E30561</empnr>                <first>John</first>                <last>Brown</last>                <manager xsi:type="xs:IDREF">ID21256</manager>             </employee>           </employees>         }       }                      return                    $emp/(element-with-id('E30561')/empnr => fn:idref())/ancestor::employee/last => string()       ), ("Singh"))
fo-test-fn-serialize-001,Error: XPST0017: Function fn:serialize with arity of 2 not registered. No similar functions found.
fo-test-fn-serialize-002,Error: XPST0017: Function fn:serialize with arity of 2 not registered. No similar functions found.
fo-test-fn-function-lookup-001,Error: XPST0017: Function fn:function-lookup with arity of 2 not registered. No similar functions found.
fo-test-fn-function-name-001,Error: XPST0017: Function fn:function-name with arity of 1 not registered. No similar functions found.
fo-test-fn-function-name-002,Error: XPST0017: Function fn:function-name with arity of 1 not registered. No similar functions found.
fo-test-fn-function-arity-001,Error: XPST0017: Function fn:function-arity with arity of 1 not registered. No similar functions found.
fo-test-fn-function-arity-002,Error: XPST0017: Function fn:function-arity with arity of 1 not registered. No similar functions found.
fo-test-fn-function-arity-003,Error: XPST0017: Function fn:function-arity with arity of 1 not registered. No similar functions found.
fo-test-fn-for-each-001,Error: XPST0017: Function fn:for-each with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}for-each (array(*), function(*))" or "Q{http://www.w3.org/2005/xpath-functions/map}for-each (map(*), function(*))"?
fo-test-fn-for-each-002,Error: XPST0017: Function fn:for-each with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}for-each (array(*), function(*))" or "Q{http://www.w3.org/2005/xpath-functions/map}for-each (map(*), function(*))"?
fo-test-fn-for-each-003,Error: XPST0017: Function fn:for-each with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}for-each (array(*), function(*))" or "Q{http://www.w3.org/2005/xpath-functions/map}for-each (map(*), function(*))"?
fo-test-fn-filter-002,Error: XPST0017: Function fn:lang with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}long (xs:anyAtomicType?)"?
fo-test-fn-fold-left-001,Error: XPST0017: Function fn:fold-left with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}fold-left (array(*), item()*, function(*))" or "Q{http://www.w3.org/2005/xpath-functions/array}fold-right (array(*), item()*, function(*))"?
fo-test-fn-fold-left-002,Error: XPST0017: Function fn:fold-left with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}fold-left (array(*), item()*, function(*))" or "Q{http://www.w3.org/2005/xpath-functions/array}fold-right (array(*), item()*, function(*))"?
fo-test-fn-fold-left-003,Error: XPST0017: Function fn:fold-left with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}fold-left (array(*), item()*, function(*))" or "Q{http://www.w3.org/2005/xpath-functions/array}fold-right (array(*), item()*, function(*))"?
fo-test-fn-fold-left-004,Error: XPST0017: Function fn:fold-left with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}fold-left (array(*), item()*, function(*))" or "Q{http://www.w3.org/2005/xpath-functions/array}fold-right (array(*), item()*, function(*))"?
fo-test-fn-fold-left-005,Error: XPST0017: Function fn:fold-left with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}fold-left (array(*), item()*, function(*))" or "Q{http://www.w3.org/2005/xpath-functions/array}fold-right (array(*), item()*, function(*))"?
fo-test-fn-fold-left-006,Error: XPST0017: Function fn:fold-left with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}fold-left (array(*), item()*, function(*))" or "Q{http://www.w3.org/2005/xpath-functions/array}fold-right (array(*), item()*, function(*))"?
fo-test-fn-fold-left-007,Error: XPST0017: Function fn:fold-left with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}fold-left (array(*), item()*, function(*))" or "Q{http://www.w3.org/2005/xpath-functions/array}fold-right (array(*), item()*, function(*))"?
fo-test-fn-fold-left-008,Error: XPST0017: Function fn:fold-left with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}fold-left (array(*), item()*, function(*))" or "Q{http://www.w3.org/2005/xpath-functions/array}fold-right (array(*), item()*, function(*))"?
fo-test-fn-fold-right-001,Error: XPST0017: Function fn:fold-right with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}fold-right (array(*), item()*, function(*))" or "Q{http://www.w3.org/2005/xpath-functions/array}fold-left (array(*), item()*, function(*))"?
fo-test-fn-fold-right-002,Error: XPST0017: Function fn:fold-right with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}fold-right (array(*), item()*, function(*))" or "Q{http://www.w3.org/2005/xpath-functions/array}fold-left (array(*), item()*, function(*))"?
fo-test-fn-fold-right-003,Error: XPST0017: Function fn:fold-right with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}fold-right (array(*), item()*, function(*))" or "Q{http://www.w3.org/2005/xpath-functions/array}fold-left (array(*), item()*, function(*))"?
fo-test-fn-for-each-pair-001,Error: XPST0017: Function fn:for-each-pair with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}for-each-pair (array(*), array(*), function(*))", "Q{http://www.w3.org/2005/xpath-functions/map}for-each (map(*), function(*))" or "Q{http://www.w3.org/2005/xpath-functions/array}for-each (array(*), function(*))"?
fo-test-fn-for-each-pair-002,Error: XPST0017: Function fn:for-each-pair with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}for-each-pair (array(*), array(*), function(*))", "Q{http://www.w3.org/2005/xpath-functions/map}for-each (map(*), function(*))" or "Q{http://www.w3.org/2005/xpath-functions/array}for-each (array(*), function(*))"?
fo-test-fn-for-each-pair-003,Error: XPST0017: Function fn:for-each-pair with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}for-each-pair (array(*), array(*), function(*))", "Q{http://www.w3.org/2005/xpath-functions/map}for-each (map(*), function(*))" or "Q{http://www.w3.org/2005/xpath-functions/array}for-each (array(*), function(*))"?
fo-test-fn-sort-001,Error: XPST0017: Function fn:sort with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}sort (array(*))", "Q{http://www.w3.org/2001/XMLSchema}short (xs:anyAtomicType?)" or "Q{http://www.w3.org/2005/xpath-functions/math}sqrt (xs:double?)"?
fo-test-fn-sort-002,Error: XPST0017: Function fn:sort with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}sort (array(*))", "Q{http://www.w3.org/2001/XMLSchema}short (xs:anyAtomicType?)" or "Q{http://www.w3.org/2005/xpath-functions/math}sqrt (xs:double?)"?
fo-test-fn-apply-001,Error: XPST0017: Function fn:apply with arity of 2 not registered. No similar functions found.
fo-test-map-keys-001,AssertionError: Skipped test, it was a assert-permutation
fo-test-map-find-001,Error: XPST0017: Function map:find with arity of 2 not registered. No similar functions found.
fo-test-map-find-002,Error: XPST0017: Function map:find with arity of 2 not registered. No similar functions found.
fo-test-map-find-003,Error: XPST0017: Function map:find with arity of 2 not registered. No similar functions found.
fo-test-map-find-004,Error: XPST0017: Function map:find with arity of 2 not registered. No similar functions found.
fo-test-map-for-each-001,AssertionError: Skipped test, it was a assert-permutation
fo-test-map-for-each-002,AssertionError: Skipped test, it was a assert-permutation
fo-test-fn-collation-key-001,Error: XPST0017: Function collation-key with arity of 2 not registered. No similar functions found.
fo-test-fn-collation-key-002,Error: XPST0017: Function collation-key with arity of 2 not registered. No similar functions found.
fo-test-fn-json-to-xml-001,Error: XPST0017: Function json-to-xml with arity of 1 not registered. No similar functions found.
fo-test-fn-json-to-xml-002,Error: XPST0017: Function json-to-xml with arity of 2 not registered. No similar functions found.
fo-test-fn-json-to-xml-003,Error: XPST0017: Function json-to-xml with arity of 1 not registered. No similar functions found.
fo-test-fn-json-to-xml-004,Error: XPST0017: Function json-to-xml with arity of 2 not registered. No similar functions found.
fo-test-fn-parse-json-004,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?
fo-test-fn-parse-json-005,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
fo-test-fn-parse-json-006,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?
fo-test-fn-parse-json-007,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions}parse-json (xs:string)"?
fo-test-array-subarray-002,Error: FOAY0001: subarray start out of bounds.
fo-test-array-subarray-006,Error: FOAY0001: subarray start out of bounds.
fo-test-array-subarray-007,Error: FOAY0001: subarray start out of bounds.
fo-test-array-fold-right-003,AssertionError: Expected XPath          array:fold-right([1,2,3], [], function($x, $y){[$x, $y]})        to (deep equally) resolve to [1, [2, [3, []]]]: expected false to be true
fo-test-array-sort-002,Error: XPST0017: Function array:sort with arity of 3 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}sort (array(*))", "Q{http://www.w3.org/2001/XMLSchema}short (xs:anyAtomicType?)" or "Q{http://www.w3.org/2005/xpath-functions/math}sqrt (xs:double?)"?
fo-test-array-sort-003,AssertionError: Expected XPath          array:sort([(1,0), (1,1), (0,1), (0,0)])        to (deep equally) resolve to [(0,0), (0,1), (1,0), (1,1)]: expected false to be true
