cbcl-subsequence-010,Performance: crashes browser when trying to create array of 3000000000 elements
cbcl-subsequence-012,Performance: crashes browser when trying to create array of 3000000000 elements
cbcl-subsequence-013,Performance: crashes browser when trying to create array of 3000000000 elements
cbcl-subsequence-014,Performance: crashes browser when trying to create array of 3000000000 elements
map-keys-014,Tries to make a map of length 500K
map-keys-016,Tries to make a map of huge length
map-remove-012,Tries to make a map of length 500K
map-for-each-014,Tries to make a map of length 500K
map-remove-012,Tries to make a map of length 500K
map-contains-016,Tries to make a map of huge length
map-get-016,Tries to make a map of huge length
RexParser,Loads missing files...
K2-DirectConElemNamespace-76,Fails in Google Chrome because of an uri parsing error
fn-absintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-absintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-absintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-abslng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-abslng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-abslng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-absnint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-absnint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-abspint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-abspint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-absulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-absulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-absnpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-absnpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-absnni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-absnni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-abs-1,Error: XPST0017: Function error with arity of 0 not registered. No similar functions found.
fn-avgintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avglng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avglng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avglng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgpint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgpint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgintg2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgintg2args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgintg2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgintg2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgintg2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgflt2args-2,AssertionError: Expected XPath fn:avg((xs:float("0"),xs:float("-3.4028235E38"))) to resolve to xs:float('-1.7014117E38'): expected false to be true
fn-avgflt2args-4,AssertionError: Expected XPath fn:avg((xs:float("-3.4028235E38"),xs:float("0"))) to resolve to xs:float('-1.7014117E38'): expected false to be true
fn-avglng2args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avglng2args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avglng2args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avglng2args-4,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avglng2args-5,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnint2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnint2args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnint2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnint2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnint2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgpint2args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgpint2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgpint2args-4,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgpint2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgulng2args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgulng2args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgulng2args-4,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgulng2args-5,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnpi2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnpi2args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnpi2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnpi2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnpi2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnni2args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnni2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnni2args-4,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avgnni2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avg-mix-args-002,Error: FORG0006: items passed to fn:avg are not all numeric.
fn-avg-mix-args-012,AssertionError: Expected XPath fn:avg(( (xs:float("-3.4028235E38"), xs:decimal("-999999999999999999") ))) to resolve to xs:float("-1.7014117E38"): expected false to be true
fn-avg-mix-args-014,AssertionError: Expected XPath fn:avg(( (xs:float("3.4028235E38"), xs:decimal("-999999999999999999") ))) to resolve to xs:float("1.7014117E38"): expected false to be true
fn-avg-mix-args-020,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avg-mix-args-021,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avg-mix-args-022,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avg-mix-args-023,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avg-mix-args-024,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avg-mix-args-025,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-avg-mix-args-036,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.'
fn-avg-mix-args-037,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.'
fn-avg-mix-args-038,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.'
fn-avg-mix-args-051,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.'
fn-avg-mix-args-052,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.'
fn-avg-mix-args-053,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.'
fn-avg-mix-args-054,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.'
fn-avg-mix-args-055,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.'
fn-avg-mix-args-056,AssertionError: Expected executing the XPath "fn:avg(( (xs:double("NaN"), xs:integer("-999999999999999999") , "a", (), "3") ))" to resolve to one of the expected results, but got Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers., AssertionError: expected [Function] to throw error including 'FORG0006' but got 'FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.'.
K-SeqAVGFunc-39,Error: FORG0006: items passed to fn:avg are not all numeric.
fn-avg-3,Error: FORG0006: items passed to fn:avg are not all numeric.
fn-avg-4,Error: FORG0006: items passed to fn:avg are not all numeric.
fn-avg-5,Error: FORG0006: items passed to fn:avg are not all numeric.
fn-avg-6,Error: FORG0006: items passed to fn:avg are not all numeric.
fn-avg-10,Error: FORG0006: items passed to fn:avg are not all numeric.
cbcl-avg-001,AssertionError: Expected executing the XPath "fn:avg((xs:decimal("79000000000000000000000000000"),                     xs:decimal("79000000000000000000000000000")))             eq 79000000000000000000000000000       " to resolve to one of the expected results, but got AssertionError: Expected XPath fn:avg((xs:decimal("79000000000000000000000000000"),                     xs:decimal("79000000000000000000000000000")))             eq 79000000000000000000000000000        to resolve to true: expected false to be true, AssertionError: expected [Function] to throw an error.
cbcl-avg-002,AssertionError: expected [Function] to throw error including 'FODT0002' but got 'FORG0006: items passed to fn:avg are not all numeric.'
cbcl-avg-003,AssertionError: expected [Function] to throw error including 'FODT0002' but got 'FORG0006: items passed to fn:avg are not all numeric.'
cbcl-avg-004,Error: FORG0006: items passed to fn:avg are not all numeric.
cbcl-avg-006,Error: FORG0006: items passed to fn:avg are not all numeric.
cbcl-avg-008,Error: XPST0003: Unable to parse XPath: (typeswitch (fn:avg((xs:float(1), xs:double(2), xs:float(3)))) case $x as xs:double return $x default return "FAIL")!string() => string-join(" "). SyntaxError: Expected "!", "!=", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "(" found.
cbcl-avg-010,AssertionError: Expected executing the XPath "avg((xs:double("NaN"), current-date() - xs:date("1997-01-01") ))" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FORG0006' but got 'XPST0017: Function current-date with arity of 0 not registered. No similar functions found.', Error: XPST0017: Function current-date with arity of 0 not registered. No similar functions found..
cbcl-avg-011,Error: XPST0017: Function day-from-date with arity of 1 not registered. No similar functions found.
cbcl-avg-012,Error: XPST0017: Function day-from-date with arity of 1 not registered. No similar functions found.
fn-booleanintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-booleanintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-booleanintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-booleanlng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-booleanlng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-booleanlng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-booleannint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-booleannint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-booleanpint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-booleanpint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-booleanulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-booleanulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-booleannpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-booleannpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-booleannni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-booleannni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-boolean-mixed-args-032,Error: FOCA0003: can not cast -99999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-boolean-mixed-args-035,Error: FOCA0003: can not cast -99999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-boolean-mixed-args-037,Error: FOCA0003: can not cast 99999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-boolean-mixed-args-039,Error: FOCA0003: can not cast 9223372036854775807 to xs:integer, it is out of bounds for JavaScript numbers.
fn-boolean-mixed-args-040,Error: FOCA0003: can not cast -9223372036854775808 to xs:integer, it is out of bounds for JavaScript numbers.
K-SeqBooleanFunc-16,Error: XPST0003: Unable to parse XPath: true() eq boolean(remove((xs:hexBinary("FF"), 1), 1) treat as xs:integer). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.
K-SeqBooleanFunc-32,Error: XPST0017: Function timezone-from-time with arity of 1 not registered. No similar functions found.
cbcl-boolean-001,Error: XPST0003: Unable to parse XPath:        	declare function local:generate($count as xs:integer) {       		if ($count < 0) then "string"        		else for $x in 1 to $count        			 return        			 	if ($x mod 3 = 0) then <a />        			 	else if ($x mod 3 = 1) then <b />        			 	else <c />        	};        	fn:boolean(fn:reverse( local:generate(5) ))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-boolean-002,Error: XPST0003: Unable to parse XPath:        	declare function local:generate($count as xs:integer) {       		for $x in 1 to $count        		return        			if ($x mod 3 = 0) then <a />        			else if ($x mod 3 = 1) then <b />        			else <c />        	};        	fn:boolean(fn:count( local:generate(5) ))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-boolean-003,AssertionError: Expected executing the XPath "declare function local:f() { (<a/>, "a") }; boolean(local:f())" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: declare function local:f() { (<a/>, "a") }; boolean(local:f()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found., AssertionError: expected [Function] to throw error including 'FORG0006' but got 'XPST0003: Unable to parse XPath: declare function local:f() { (<a/>, "a") }; boolean(local:f()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
cbcl-boolean-005,Error: XPST0003: Unable to parse XPath:        declare function local:repeat($count as xs:integer, $arg as xs:string) { for $x in 1 to $count return $arg };        fn:boolean( text { local:repeat(0, "string") } )       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-boolean-006,Error: XPST0003: Unable to parse XPath:        declare function local:repeat($count as xs:integer, $arg as xs:string) as item()* {        	if ($count lt 0) then '$count must not be negative'        	else text { for $x in 1 to $count return $arg }       };        fn:boolean( local:repeat(0, "string") ). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
fn-ceilingintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-ceilingintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-ceilingintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-ceilinglng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-ceilinglng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-ceilinglng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-ceilingnint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-ceilingnint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-ceilingpint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-ceilingpint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-ceilingulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-ceilingulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-ceilingnpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-ceilingnpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-ceilingnni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-ceilingnni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-ceiling-1,Error: XPST0017: Function error with arity of 0 not registered. No similar functions found.
fn-concatintg2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatintg2args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatintg2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatintg2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatintg2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatdec2args-1,AssertionError: fn:concat(xs:decimal("-999999999999999999"),xs:decimal("-999999999999999999")): expected '-1000000000000000000-1000000000000000000' to equal '-999999999999999999-999999999999999999'
fn-concatdec2args-2,AssertionError: fn:concat(xs:decimal("617375191608514839"),xs:decimal("-999999999999999999")): expected '617375191608514800-1000000000000000000' to equal '617375191608514839-999999999999999999'
fn-concatdec2args-3,AssertionError: fn:concat(xs:decimal("999999999999999999"),xs:decimal("-999999999999999999")): expected '1000000000000000000-1000000000000000000' to equal '999999999999999999-999999999999999999'
fn-concatdec2args-4,AssertionError: fn:concat(xs:decimal("-999999999999999999"),xs:decimal("617375191608514839")): expected '-1000000000000000000617375191608514800' to equal '-999999999999999999617375191608514839'
fn-concatdec2args-5,AssertionError: fn:concat(xs:decimal("-999999999999999999"),xs:decimal("999999999999999999")): expected '-10000000000000000001000000000000000000' to equal '-999999999999999999999999999999999999'
fn-concatlng2args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatlng2args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatlng2args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatlng2args-4,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatlng2args-5,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatnint2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatnint2args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatnint2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatnint2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatnint2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatpint2args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatpint2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatpint2args-4,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatpint2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatulng2args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatulng2args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatulng2args-4,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatulng2args-5,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatnpi2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatnpi2args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatnpi2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatnpi2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatnpi2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatnni2args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatnni2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatnni2args-4,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-concatnni2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-contains-17,Error: FOCH0002: No collations are supported
fn-contains-18,Error: FOCH0002: No collations are supported
fn-contains-19,Error: FOCH0002: No collations are supported
fn-contains-20,Error: FOCH0002: No collations are supported
fn-contains-21,Error: FOCH0002: No collations are supported
fn-contains-22,Error: FOCH0002: No collations are supported
fn-contains-23,Error: FOCH0002: No collations are supported
fn-contains-24,Error: FOCH0002: No collations are supported
fn-contains-25,Error: FOCH0002: No collations are supported
fn-contains-26,Error: FOCH0002: No collations are supported
fn-contains-27,Error: FOCH0002: No collations are supported
fn-contains-28,Error: FOCH0002: No collations are supported
fn-contains-29,Error: FOCH0002: No collations are supported
fn-contains-30,Error: FOCH0002: No collations are supported
fn-contains-31,Error: FOCH0002: No collations are supported
fn-contains-35,Error: FOCH0002: No collations are supported
fn-contains-37,Error: FOCH0002: No collations are supported
K-ContainsFunc-5,Error: FOCH0002: No collations are supported
K2-ContainsFunc-1,Error: XPST0003: Unable to parse XPath: let $vA := ("B STRING", current-time(), string("content"))[1] treat as xs:string,                 $vB  := ("b string", current-time(), string("content"))[1] treat as xs:string          return contains(lower-case($vA), lower-case($vB)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found.
K2-ContainsFunc-2,Error: XPST0003: Unable to parse XPath: let $vA := ("B STRING", current-time(), string("content"))[1] treat as xs:string,                 $vB := ("b string", current-time(), string("content"))[1] treat as xs:string          return contains(upper-case($vA), upper-case($vB)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found.
K2-ContainsFunc-3,Error: XPST0003: Unable to parse XPath: let $vA  := ("B STRING", current-time(), string("content"))[1] treat as xs:string,                 $vB := ("no match", current-time(), string("content"))[1] treat as xs:string          return contains(lower-case($vA), lower-case($vB)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found.
K2-ContainsFunc-4,Error: XPST0003: Unable to parse XPath: let $vA := ("B STRING", current-time(), string("content"))[1] treat as xs:string,                 $vB  := ("no match", current-time(), string("content"))[1] treat as xs:string         return contains(upper-case($vA), upper-case($vB)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found.
K2-ContainsFunc-5,Error: XPST0003: Unable to parse XPath: let $vA := ("B STRING", current-time(), string("content"))[1] treat as xs:string,                 $vB := ("b string", current-time(), string("content"))[1] treat as xs:string          return contains(upper-case($vA), lower-case($vB)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found.
K2-ContainsFunc-6,Error: XPST0003: Unable to parse XPath: let $vA := ("B STRING", current-time(), string("content"))[1] treat as xs:string,                 $vB := ("b string", current-time(), string("content"))[1] treat as xs:string          return contains(lower-case($vA), upper-case($vB)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found.
cbcl-contains-001,Error: FOCH0002: No collations are supported
cbcl-contains-002,Error: FOCH0002: No collations are supported
cbcl-contains-003,Error: XPST0017: Function fn:index-of with arity of 2 not registered. No similar functions found.
liam-contains-001,Error: FOCH0002: No collations are supported
liam-contains-002,Error: FOCH0002: No collations are supported
liam-contains-003,Error: FOCH0002: No collations are supported
liam-contains-004,Error: FOCH0002: No collations are supported
fn-countintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-countintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-countintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-countlng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-countlng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-countlng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-countnint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-countnint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-countpint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-countpint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-countulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-countulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-countnpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-countnpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-countnni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-countnni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-SeqCountFunc-18,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
Count015,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
cbcl-count-002,Error: XPST0003: Unable to parse XPath: (declare function local:generate($arg as xs:integer?) { if ($arg = 0) then (1, 2, 3) else $arg }; fn:count( ( (), local:generate( () ), local:generate( 0 ), (1 to 10000000), local:generate( () ), local:generate(1)) ))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-count-003,Error: XPST0017: Function year-from-date with arity of 1 not registered. No similar functions found.
cbcl-count-005,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt 25. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-006,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le 25. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-007,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq 25. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-008,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge 25. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-009,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt 25. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-010,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne 25. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-011,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) lt 25). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-012,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) le 25). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-013,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) eq 25). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-014,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) ge 25). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-015,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) gt 25). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-016,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) ne 25). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-017,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 25 lt count(local:primes(100)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-018,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 25 le count(local:primes(100)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-019,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 25 eq count(local:primes(100)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-020,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 25 ge count(local:primes(100)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-021,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 25 gt count(local:primes(100)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-022,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 25 ne count(local:primes(100)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-023,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(25 lt count(local:primes(100))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-024,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(25 le count(local:primes(100))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-025,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(25 eq count(local:primes(100))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-026,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(25 ge count(local:primes(100))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-027,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(25 gt count(local:primes(100))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-028,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(25 ne count(local:primes(100))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-029,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) lt local:square(5). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-030,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) le local:square(5). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-031,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) eq local:square(5). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-032,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) ge local:square(5). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-033,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) gt local:square(5). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-034,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) ne local:square(5). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-035,Error: XPST0003: Unable to parse XPath: declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(2, 100)) lt count(local:primes(100, 200)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-036,Error: XPST0003: Unable to parse XPath: declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(2, 100)) le count(local:primes(100, 200)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-037,Error: XPST0003: Unable to parse XPath: declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(2, 100)) eq count(local:primes(100, 200)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-038,Error: XPST0003: Unable to parse XPath: declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(2, 100)) ge count(local:primes(100, 200)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-039,Error: XPST0003: Unable to parse XPath: declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(2, 100)) gt count(local:primes(100, 200)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-040,Error: XPST0003: Unable to parse XPath: declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(2, 100)) ne count(local:primes(100, 200)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-041,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt -1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-042,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le -1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-043,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq -1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-044,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge -1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-045,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt -1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-046,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne -1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-047,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) lt -local:square(5). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-048,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) le -local:square(5). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-049,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) eq -local:square(5). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-050,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) ge -local:square(5). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-051,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) gt -local:square(5). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-052,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) ne -local:square(5). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-053,Error: XPST0003: Unable to parse XPath: declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(2, 100)) lt count(local:primes(100, 200))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-054,Error: XPST0003: Unable to parse XPath: declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(2, 100)) le count(local:primes(100, 200))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-055,Error: XPST0003: Unable to parse XPath: declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(2, 100)) eq count(local:primes(100, 200))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-056,Error: XPST0003: Unable to parse XPath: declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(2, 100)) ge count(local:primes(100, 200))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-057,Error: XPST0003: Unable to parse XPath: declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(2, 100)) gt count(local:primes(100, 200))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-058,Error: XPST0003: Unable to parse XPath: declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(2, 100)) ne count(local:primes(100, 200))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-059,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt 25.5. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-060,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le 25.5. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-061,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq 25.5. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-062,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge 25.5. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-063,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt 25.5. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-064,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne 25.5. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-065,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) lt 25.5). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-066,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) le 25.5). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-067,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) eq 25.5). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-068,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) ge 25.5). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-069,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) gt 25.5). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-070,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) ne 25.5). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-071,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 24.5 lt count(local:primes(100)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-072,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 24.5 le count(local:primes(100)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-073,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 24.5 eq count(local:primes(100)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-074,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 24.5 ge count(local:primes(100)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-075,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 24.5 gt count(local:primes(100)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-076,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 24.5 ne count(local:primes(100)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-077,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(24.5 lt count(local:primes(100))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-078,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(24.5 le count(local:primes(100))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-079,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(24.5 eq count(local:primes(100))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-080,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(24.5 ge count(local:primes(100))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-081,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(24.5 gt count(local:primes(100))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-082,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(24.5 ne count(local:primes(100))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-083,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) lt local:square(5.1). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-084,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) le local:square(5.1). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-085,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) eq local:square(5.1). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-086,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) ge local:square(5.1). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-087,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) gt local:square(5.1). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-088,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) ne local:square(5.1). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-089,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt -1.5. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-090,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le -1.5. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-091,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq -1.5. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-092,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge -1.5. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-093,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt -1.5. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-094,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne -1.5. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-095,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) lt -local:square(5.0). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-096,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) le -local:square(5.0). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-097,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) eq -local:square(5.0). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-098,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) ge -local:square(5.0). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-099,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) gt -local:square(5.0). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-100,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) ne -local:square(5.0). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-101,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) ge 1.0. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-102,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt xs:float("25.5"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-103,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le xs:float("25.5"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-104,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq xs:float("25.5"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-105,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge xs:float("25.5"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-106,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt xs:float("25.5"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-107,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne xs:float("25.5"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-108,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) lt xs:float("25.5")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-109,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) le xs:float("25.5")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-110,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) eq xs:float("25.5")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-111,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) ge xs:float("25.5")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-112,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) gt xs:float("25.5")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-113,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) ne xs:float("25.5")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-114,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:float("24.5") lt count(local:primes(100)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-115,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:float("24.5") le count(local:primes(100)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-116,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:float("24.5") eq count(local:primes(100)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-117,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:float("24.5") ge count(local:primes(100)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-118,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:float("24.5") gt count(local:primes(100)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-119,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:float("24.5") ne count(local:primes(100)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-120,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:float("24.5") lt count(local:primes(100))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-121,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:float("24.5") le count(local:primes(100))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-122,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:float("24.5") eq count(local:primes(100))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-123,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:float("24.5") ge count(local:primes(100))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-124,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:float("24.5") gt count(local:primes(100))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-125,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:float("24.5") ne count(local:primes(100))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-126,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) lt local:square(xs:float("4.9")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-127,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) le local:square(xs:float("4.9")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-128,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) eq local:square(xs:float("4.9")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-129,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) ge local:square(xs:float("4.9")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-130,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) gt local:square(xs:float("4.9")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-131,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) ne local:square(xs:float("4.9")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-132,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt xs:float("-1.5"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-133,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le xs:float("-1.5"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-134,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq xs:float("-1.5"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-135,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge xs:float("-1.5"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-136,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt xs:float("-1.5"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-137,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne xs:float("-1.5"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-138,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) lt -local:square(5.0). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-139,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) le -local:square(5.0). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-140,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) eq -local:square(5.0). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-141,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) ge -local:square(5.0). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-142,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) gt -local:square(5.0). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-143,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) ne -local:square(5.0). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-144,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge xs:float("1.0"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-145,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt xs:double("25.5"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-146,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le xs:double("25.5"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-147,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq xs:double("25.5"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-148,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge xs:double("25.5"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-149,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt xs:double("25.5"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-150,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne xs:double("25.5"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-151,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) lt xs:double("25.5")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-152,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) le xs:double("25.5")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-153,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) eq xs:double("25.5")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-154,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) ge xs:double("25.5")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-155,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) gt xs:double("25.5")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-156,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) ne xs:double("25.5")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-157,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:double("24.5") lt count(local:primes(100)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-158,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:double("24.5") le count(local:primes(100)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-159,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:double("24.5") eq count(local:primes(100)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-160,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:double("24.5") ge count(local:primes(100)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-161,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:double("24.5") gt count(local:primes(100)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-162,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:double("24.5") ne count(local:primes(100)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-163,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:double("24.5") lt count(local:primes(100))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-164,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:double("24.5") le count(local:primes(100))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-165,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:double("24.5") eq count(local:primes(100))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-166,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:double("24.5") ge count(local:primes(100))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-167,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:double("24.5") gt count(local:primes(100))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-168,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:double("24.5") ne count(local:primes(100))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-169,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) lt local:square(xs:double("4.9")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-170,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) le local:square(xs:double("4.9")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-171,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) eq local:square(xs:double("4.9")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-172,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) ge local:square(xs:double("4.9")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-173,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) gt local:square(xs:double("4.9")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-174,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) ne local:square(xs:double("4.9")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-175,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt xs:double("-1.5"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-176,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le xs:double("-1.5"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-177,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq xs:double("-1.5"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-178,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge xs:double("-1.5"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-179,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt xs:double("-1.5"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-180,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne xs:double("-1.5"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-181,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) lt -local:square(5.0). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-182,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) le -local:square(5.0). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-183,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) eq -local:square(5.0). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-184,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) ge -local:square(5.0). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-185,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) gt -local:square(5.0). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-186,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) ne -local:square(5.0). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-187,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge xs:double("1.0"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-188,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-189,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt xs:double("NaN"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-190,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le xs:double("NaN"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-191,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq xs:double("NaN"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-192,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge xs:double("NaN"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-193,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt xs:double("NaN"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-194,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne xs:double("NaN"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-195,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt xs:double("INF"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-196,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le xs:double("INF"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-197,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq xs:double("INF"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-198,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge xs:double("INF"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-199,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt xs:double("INF"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-200,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne xs:double("INF"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-201,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt xs:float("NaN"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-202,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le xs:float("NaN"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-203,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq xs:float("NaN"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-204,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge xs:float("NaN"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-205,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt xs:float("NaN"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-206,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne xs:float("NaN"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-207,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt xs:float("INF"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-208,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le xs:float("INF"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-209,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq xs:float("INF"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-210,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge xs:float("INF"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-211,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt xs:float("INF"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-212,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne xs:float("INF"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-213,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) lt local:strange(true()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-214,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) le local:strange(true()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-215,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) eq local:strange(true()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-216,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) ge local:strange(true()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-217,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) gt local:strange(true()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-218,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) ne local:strange(true()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-219,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) lt local:strange(false()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-220,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) le local:strange(false()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-221,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) eq local:strange(false()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-222,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) ge local:strange(false()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-223,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) gt local:strange(false()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-224,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) ne local:strange(false()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-225,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) lt local:strange(true()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-226,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) le local:strange(true()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-227,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) eq local:strange(true()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-228,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) ge local:strange(true()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-229,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) gt local:strange(true()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-230,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) ne local:strange(true()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-231,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) lt local:strange(false()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-232,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) le local:strange(false()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-233,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) eq local:strange(false()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-234,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) ge local:strange(false()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-235,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) gt local:strange(false()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-236,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) ne local:strange(false()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-238,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt -1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-239,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le -1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-240,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq -1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-241,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge -1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-242,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt -1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-243,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne -1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-count-244,Error: XPST0003: Unable to parse XPath: declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
fn-deep-equalintg2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalintg2args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalintg2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalintg2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalintg2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equallng2args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equallng2args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equallng2args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equallng2args-4,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equallng2args-5,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalnint2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalnint2args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalnint2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalnint2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalnint2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalpint2args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalpint2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalpint2args-4,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalpint2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalulng2args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalulng2args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalulng2args-4,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalulng2args-5,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalnpi2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalnpi2args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalnpi2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalnpi2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalnpi2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalnni2args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalnni2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalnni2args-4,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equalnni2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-deep-equal-mix-args-019,AssertionError: Expected XPath fn:deep-equal( xs:float(1.01) , xs:double(1.01)) to resolve to false: expected true to be false
fn-deep-equal-maps-13,Error: FOCH0002: No collations are supported
fn-deep-equal-maps-14,Error: FOCH0002: No collations are supported
fn-deep-equal-maps-16,Error: XPST0017: Function adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
fn-deep-equal-maps-17,Error: XPST0017: Function adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
K-SeqDeepEqualFunc-6,Error: FOCH0002: No collations are supported
K-SeqDeepEqualFunc-32,Error: XPST0017: Function index-of with arity of 2 not registered. No similar functions found.
K-SeqDeepEqualFunc-33,Error: XPST0017: Function index-of with arity of 2 not registered. No similar functions found.
K-SeqDeepEqualFunc-34,Error: XPST0017: Function index-of with arity of 2 not registered. No similar functions found.
K-SeqDeepEqualFunc-35,Error: XPST0017: Function index-of with arity of 2 not registered. No similar functions found.
K-SeqDeepEqualFunc-56,Error: FOCH0002: No collations are supported
K-SeqDeepEqualFunc-57,Error: FOCH0002: No collations are supported
K-SeqDeepEqualFunc-58,Error: FOCH0002: No collations are supported
K-SeqDeepEqualFunc-59,Error: FOCH0002: No collations are supported
K-SeqDeepEqualFunc-60,Error: FOCH0002: No collations are supported
K-SeqDeepEqualFunc-61,Error: FOCH0002: No collations are supported
K-SeqDeepEqualFunc-62,Error: FOCH0002: No collations are supported
K-SeqDeepEqualFunc-63,Error: FOCH0002: No collations are supported
K-SeqDeepEqualFunc-64,Error: FOCH0002: No collations are supported
K-SeqDeepEqualFunc-65,Error: FOCH0002: No collations are supported
K-SeqDeepEqualFunc-66,Error: FOCH0002: No collations are supported
K-SeqDeepEqualFunc-67,Error: FOCH0002: No collations are supported
K-SeqDeepEqualFunc-68,Error: FOCH0002: No collations are supported
K-SeqDeepEqualFunc-69,Error: FOCH0002: No collations are supported
K-SeqDeepEqualFunc-70,Error: FOCH0002: No collations are supported
K-SeqDeepEqualFunc-71,Error: FOCH0002: No collations are supported
K2-SeqDeepEqualFunc-1,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K2-SeqDeepEqualFunc-2,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K2-SeqDeepEqualFunc-3,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K2-SeqDeepEqualFunc-4,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K2-SeqDeepEqualFunc-14,Error: XPST0003: Unable to parse XPath: declare variable $d1 := document { <?target data?>, text{"some text"}}; declare variable $d2 := document {text{"some text"}}; deep-equal($d1, $d2). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-SeqDeepEqualFunc-15,Error: XPST0003: Unable to parse XPath: declare variable $d1 := document {()}; declare variable $d2 := document {<?target data?>}; deep-equal($d1, $d2). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-SeqDeepEqualFunc-16,Error: XPST0003: Unable to parse XPath: declare variable $d1 := document { <?target data?>, text{"some text"}}; declare variable $d2 := document {text{"some text"}}; deep-equal($d1, $d2). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-SeqDeepEqualFunc-17,Error: XPST0003: Unable to parse XPath: declare variable $d1 := document {()}; declare variable $d2 := document {<?target data?>}; deep-equal($d1, $d2). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-SeqDeepEqualFunc-20,Error: XPST0003: Unable to parse XPath: (declare variable $d1 := <e a="1" b="2">te<?target data?>xt</e>; declare variable $d2 := <e b="2" a="1">text</e>; deep-equal($d1, $d2), deep-equal($d2, $d1))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
K2-SeqDeepEqualFunc-21,Error: XPST0003: Unable to parse XPath: (declare variable $d1 := <e a="1" b="2"><?target data?>text</e>; declare variable $d2 := <e b="2" a="1">text</e>; deep-equal($d1, $d2), deep-equal($d2, $d1))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
K2-SeqDeepEqualFunc-22,Error: XPST0003: Unable to parse XPath: (declare variable $d1 := <e a="1" b="2">te<!-- content -->xt</e>; declare variable $d2 := <e b="2" a="1">text</e>; deep-equal($d1, $d2), deep-equal($d2, $d1))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
K2-SeqDeepEqualFunc-23,Error: XPST0003: Unable to parse XPath: (declare variable $d1 := <e a="1" b="2"><!-- content -->text</e>; declare variable $d2 := <e b="2" a="1">text</e>; deep-equal($d1, $d2), deep-equal($d2, $d1))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
K2-SeqDeepEqualFunc-24,Error: XPST0003: Unable to parse XPath: deep-equal(attribute name {"content"}, attribute name {"content"}). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
K2-SeqDeepEqualFunc-25,Error: XPST0003: Unable to parse XPath: deep-equal((attribute name2 {"content"}, attribute name {"content"}), (attribute name {"content"}, attribute name2 {"content"})). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
K2-SeqDeepEqualFunc-26,Error: XPST0003: Unable to parse XPath: deep-equal((attribute name {"content"}, attribute name {"content"}), (attribute name {"content"})). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
K2-SeqDeepEqualFunc-27,Error: XPST0003: Unable to parse XPath: deep-equal((attribute name {"content"}, attribute name {"content"}), attribute name {"content"}). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
K2-SeqDeepEqualFunc-28,Error: XPST0003: Unable to parse XPath: deep-equal(attribute name {}, attribute name {}). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
K2-SeqDeepEqualFunc-29,Error: XPST0003: Unable to parse XPath: deep-equal(attribute name {"content"}, attribute name {"content"}). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
K2-SeqDeepEqualFunc-30,Error: XPST0003: Unable to parse XPath: deep-equal(attribute name {"content"}, attribute name {}). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
K2-SeqDeepEqualFunc-31,Error: XPST0003: Unable to parse XPath: deep-equal(attribute name {}, attribute name2 {}). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
K2-SeqDeepEqualFunc-32,Error: XPST0003: Unable to parse XPath: deep-equal(attribute name {"content "}, attribute name2 {"content "}). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
K2-SeqDeepEqualFunc-36,Error: XPST0003: Unable to parse XPath:          deep-equal(validate type xs:integer {<e>2012</e>}, validate type xs:gYear{<e>2012</e>})       . SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.
K2-SeqDeepEqualFunc-37,Error: XPST0003: Unable to parse XPath:          deep-equal(validate type xs:integer {<e>2012</e>}, validate type xs:decimal{<e>2012</e>})       . SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.
K2-SeqDeepEqualFunc-40,Error: XPST0017: Function implicit-timezone with arity of 0 not registered. No similar functions found.
cbcl-deep-equal-001,Error: XPST0003: Unable to parse XPath: let $doc1 := <doc><?processing-instruction content ?></doc> let $doc2 := <doc><!--comment--></doc> return deep-equal($doc1, $doc2). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
cbcl-deep-equal-002,Error: XPST0003: Unable to parse XPath: let $doc1 := <?cheese brie?> let $doc2 := <?cheese stilton?> return deep-equal($doc1, $doc2). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
cbcl-deep-equal-003,Error: XPST0003: Unable to parse XPath: let $doc1 := <?foo test?> let $doc2 := <?bar test?> return deep-equal($doc1, $doc2). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
cbcl-deep-equal-004,Error: XPST0003: Unable to parse XPath: let $doc1 := <?foo bar?> let $doc2 := <?foo bar?> return deep-equal($doc1, $doc2). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
cbcl-deep-equal-005,Error: XPST0003: Unable to parse XPath: declare function local:f($x as xs:integer)as xs:integer* { 1 to $x }; deep-equal((local:f(3), 2, local:f(1)), (local:f(3), 2)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-deep-equal-006,Error: XPST0003: Unable to parse XPath: declare function local:f($x as xs:integer) as xs:integer* { 1 to $x }; deep-equal((local:f(3), 2), (local:f(3), 2, local:f(1))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-deep-equal-007,Error: XPST0017: Function implicit-timezone with arity of 0 not registered. No similar functions found.
fn-emptyintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-emptyintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-emptyintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-emptylng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-emptylng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-emptylng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-emptynint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-emptynint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-emptypint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-emptypint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-emptyulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-emptyulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-emptynpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-emptynpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-emptynni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-emptynni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-SeqEmptyFunc-9,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
cbcl-empty-func-001,Error: XPST0003: Unable to parse XPath:        	declare function local:generate($arg as xs:integer?) { if ($arg = 0) then (1, 2, 3) else $arg };        	fn:empty( ((), local:generate( () ), local:generate( 0 ), (1 to 10000000), local:generate( () ), local:generate(1)) )       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-empty-func-004,Error: XPST0003: Unable to parse XPath: empty(text {(1 to 10)[. mod 2 = 0]}). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
fn-ends-with-17,Error: FOCH0002: No collations are supported
fn-ends-with-18,Error: FOCH0002: No collations are supported
fn-ends-with-19,Error: FOCH0002: No collations are supported
fn-ends-with-20,Error: FOCH0002: No collations are supported
fn-ends-with-21,Error: FOCH0002: No collations are supported
fn-ends-with-22,Error: FOCH0002: No collations are supported
fn-ends-with-23,Error: FOCH0002: No collations are supported
fn-ends-with-24,Error: FOCH0002: No collations are supported
fn-ends-with-25,Error: FOCH0002: No collations are supported
fn-ends-with-26,Error: FOCH0002: No collations are supported
fn-ends-with-27,Error: FOCH0002: No collations are supported
fn-ends-with-28,Error: FOCH0002: No collations are supported
fn-ends-with-29,Error: FOCH0002: No collations are supported
fn-ends-with-30,Error: FOCH0002: No collations are supported
fn-ends-with-31,Error: FOCH0002: No collations are supported
fn-ends-with-33,AssertionError: Expected executing the XPath "fn:ends-with("Chapter-100", "Chapter-10", "http://www.w3.org/2013/collation/UCA?lang=en;numeric=yes")" to resolve to one of the expected results, but got Error: FOCH0002: No collations are supported, AssertionError: expected [Function] to throw error including 'FOCH0004' but got 'FOCH0002: No collations are supported'.
K-EndsWithFunc-5,Error: FOCH0002: No collations are supported
K2-EndsWithFunc-1,Error: XPST0003: Unable to parse XPath: let $vA := ("B STRING", current-time(), string("content"))[1] treat as xs:string,          $vB := ("b string", current-time(), string("content"))[1] treat as xs:string         return ends-with(lower-case($vA), lower-case($vB)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found.
K2-EndsWithFunc-2,Error: XPST0003: Unable to parse XPath:           let $vA  := ("B STRING", current-time(), string("content"))[1] treat as xs:string,          $vB  := ("b string", current-time(), string("content"))[1] treat as xs:string          return ends-with(upper-case($vA), upper-case($vB)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found.
K2-EndsWithFunc-3,Error: XPST0003: Unable to parse XPath:           let $vA  := ("B STRING", current-time(), string("content"))[1] treat as xs:string,          $vB  := ("no match", current-time(), string("content"))[1] treat as xs:string          return ends-with(lower-case($vA), lower-case($vB)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found.
K2-EndsWithFunc-4,Error: XPST0003: Unable to parse XPath:           let $vA  := ("B STRING", current-time(), string("content"))[1] treat as xs:string,          $vB  := ("no match", current-time(), string("content"))[1] treat as xs:string          return ends-with(upper-case($vA), upper-case($vB)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found.
K2-EndsWithFunc-5,Error: XPST0003: Unable to parse XPath:           let $vA := ("B STRING", current-time(), string("content"))[1] treat as xs:string,          $vB := ("b string", current-time(), string("content"))[1] treat as xs:string         return ends-with(upper-case($vA), lower-case($vB)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found.
K2-EndsWithFunc-6,Error: XPST0003: Unable to parse XPath:           let $vA := ("B STRING", current-time(), string("content"))[1] treat as xs:string,          $vB := ("b string", current-time(), string("content"))[1] treat as xs:string         return ends-with(lower-case($vA), upper-case($vB)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found.
cbcl-ends-with-001,Error: FOCH0002: No collations are supported
fn-exactly-oneintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-exactly-oneintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-exactly-oneintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-exactly-onedec1args-1,AssertionError: fn:exactly-one(xs:decimal("-999999999999999999")): expected '-1000000000000000000' to equal '-999999999999999999'
fn-exactly-onedec1args-2,AssertionError: fn:exactly-one(xs:decimal("617375191608514839")): expected '617375191608514800' to equal '617375191608514839'
fn-exactly-onedec1args-3,AssertionError: fn:exactly-one(xs:decimal("999999999999999999")): expected '1000000000000000000' to equal '999999999999999999'
fn-exactly-onelng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-exactly-onelng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-exactly-onelng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-exactly-onenint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-exactly-onenint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-exactly-onepint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-exactly-onepint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-exactly-oneulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-exactly-oneulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-exactly-onenpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-exactly-onenpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-exactly-onenni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-exactly-onenni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-SeqExactlyOneFunc-6,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'
K-SeqExactlyOneFunc-7,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'
K-SeqExactlyOneFunc-8,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'
cbcl-exactly-one-002,Error: XPST0003: Unable to parse XPath: (       	declare function local:generate($arg as xs:integer) { if ($arg = 0) then (1, 2, 3) else $arg };        	fn:exactly-one(fn:unordered( local:generate(1) ))       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-exactly-one-003,Error: XPST0003: Unable to parse XPath: (       	declare function local:generate($arg as xs:integer?) { if ($arg = 0) then () else if ($arg = 1) then $arg else ($arg, $arg) };        	1 + fn:exactly-one(fn:one-or-more( local:generate( 1 ) ))       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-exactly-one-004,Error: XPST0003: Unable to parse XPath: (       	declare function local:generate($arg as xs:integer?) { if ($arg = 0) then () else if ($arg = 1) then $arg else ($arg, $arg) };        	1 + fn:exactly-one(fn:zero-or-one( local:generate( 1 ) ))       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
fn-existsintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-existsintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-existsintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-existslng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-existslng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-existslng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-existsnint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-existsnint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-existspint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-existspint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-existsulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-existsulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-existsnpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-existsnpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-existsnni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-existsnni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-SeqExistsFunc-10,Error: XPST0017: Function timezone-from-dateTime with arity of 1 not registered. No similar functions found.
K-SeqExistsFunc-11,Error: XPST0017: Function timezone-from-date with arity of 1 not registered. No similar functions found.
K-SeqExistsFunc-12,Error: XPST0017: Function timezone-from-time with arity of 1 not registered. No similar functions found.
K-SeqExistsFunc-13,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-SeqExistsFunc-14,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
cbcl-exists-001,Error: XPST0003: Unable to parse XPath:        	declare function local:generate($arg as xs:integer?) { if ($arg = 0) then (1, 2, 3) else $arg };        	fn:exists( ( (), local:generate( () ), local:generate( 0 ), (1 to 10000000), local:generate( () ), local:generate(1)) ). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-exists-003,Error: XPST0003: Unable to parse XPath: exists(text {(1 to 10)[. mod 2 = 0]}). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
filter-003,Error: XPST0081: The type element(emp) does not exist.
filter-006,Error: XPTY0004: signature of function passed to fn:filter is incompatible.
filter-904,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function current-date with arity of 0 not registered. No similar functions found.'
fn-filter-006,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function fn:current-dateTime with arity of 0 not registered. No similar functions found.'
fn-filter-007,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function fn:current-dateTime with arity of 0 not registered. No similar functions found.'
fn-filter-013,Error: No selector counterpart for: anyFunctionTest.
fn-filter-016,AssertionError: expected [Function] to throw an error
fn-filter-019,AssertionError: expected [Function] to throw an error
fn-filter-022,AssertionError: expected [Function] to throw an error
fn-floorintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-floorintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-floorintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-floordec1args-1,AssertionError: fn:floor(xs:decimal("-999999999999999999")): expected '-1000000000000000000' to equal '-999999999999999999'
fn-floordec1args-2,AssertionError: fn:floor(xs:decimal("617375191608514839")): expected '617375191608514800' to equal '617375191608514839'
fn-floordec1args-3,AssertionError: fn:floor(xs:decimal("999999999999999999")): expected '1000000000000000000' to equal '999999999999999999'
fn-floorlng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-floorlng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-floorlng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-floornint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-floornint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-floorpint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-floorpint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-floorulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-floorulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-floornpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-floornpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-floornni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-floornni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-floor-1,Error: XPST0017: Function error with arity of 0 not registered. No similar functions found.
generate-id-000,Error: XPST0017: Function generate-id with arity of 1 not registered. No similar functions found.
generate-id-001,Error: XPST0017: Function generate-id with arity of 1 not registered. No similar functions found.
generate-id-002,Error: XPST0017: Function generate-id with arity of 1 not registered. No similar functions found.
generate-id-003,Error: XPST0017: Function generate-id with arity of 1 not registered. No similar functions found.
generate-id-004,Error: XPST0017: Function generate-id with arity of 1 not registered. No similar functions found.
generate-id-005,Error: XPST0017: Function generate-id with arity of 1 not registered. No similar functions found.
generate-id-006,Error: XPST0017: Function generate-id with arity of 1 not registered. No similar functions found.
generate-id-008,Error: XPST0017: Function generate-id with arity of 0 not registered. No similar functions found.
generate-id-009,Error: XPST0017: Function generate-id with arity of 0 not registered. No similar functions found.
generate-id-010,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
generate-id-012,Error: XPST0017: Function collection with arity of 0 not registered. No similar functions found.
generate-id-013,Error: XPST0017: Function collection with arity of 0 not registered. No similar functions found.
generate-id-014,Error: XPST0003: Unable to parse XPath: let $result := (         import module namespace copy="http://www.w3.org/QT3/copy";         generate-id(copy:copy(/*))       ) return matches($result, '^[A-Za-z][A-Za-z0-9]*$'). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", or "||" but "m" found.
generate-id-015,Error: XPST0003: Unable to parse XPath: let $result := (         import module namespace copy="http://www.w3.org/QT3/copy";         generate-id(copy:copy((//@*)[1]))       ) return matches($result, '^[A-Za-z][A-Za-z0-9]*$'). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", or "||" but "m" found.
generate-id-016,Error: XPST0003: Unable to parse XPath:          import module namespace copy="http://www.w3.org/QT3/copy";         generate-id(copy:copy(/*)) eq generate-id(/*)       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", "||", or end of input but "m" found.
generate-id-017,Error: XPST0003: Unable to parse XPath:          import module namespace copy="http://www.w3.org/QT3/copy";         let $att := (//@*)[1] return generate-id(copy:copy($att)) eq generate-id($att)       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", "||", or end of input but "m" found.
generate-id-018,Error: XPST0017: Function generate-id with arity of 1 not registered. No similar functions found.
generate-id-019,Error: XPST0017: Function generate-id with arity of 0 not registered. No similar functions found.
generate-id-901,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0017: Function generate-id with arity of 0 not registered. No similar functions found.'
generate-id-902,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function generate-id with arity of 1 not registered. No similar functions found.'
generate-id-903,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function generate-id with arity of 1 not registered. No similar functions found.'
generate-id-904,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function generate-id with arity of 1 not registered. No similar functions found.'
generate-id-905,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function generate-id with arity of 1 not registered. No similar functions found.'
head-002,Error: XPST0017: Function current-dateTime with arity of 0 not registered. No similar functions found.
head-007,Error: XPST0017: Function current-date with arity of 0 not registered. No similar functions found.
head-008,Error: XPST0017: Function current-date with arity of 0 not registered. No similar functions found.
fn-id-2,AssertionError: expected [Function] to throw an error
fn-id-4,AssertionError: expected [Function] to throw error including 'FODC0001' but got 'XPST0003: Unable to parse XPath: \n        import module namespace copy="http://www.w3.org/QT3/copy";\n        let $var := copy:copy(/*) return fn:id("argument1", $var)\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", "||", or end of input but "m" found.'
K2-SeqIDFunc-3,AssertionError: expected [Function] to throw an error
K2-SeqIDFunc-4,AssertionError: expected [Function] to throw error including 'FODC0001' but got 'XPST0003: Unable to parse XPath: \n        import module namespace copy="http://www.w3.org/QT3/copy";\n        id("id", copy:copy((//comment())[1]))\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", "||", or end of input but "m" found.'
K2-SeqIDFunc-5,AssertionError: expected [Function] to throw error including 'FODC0001' but got 'XPST0003: Unable to parse XPath: \n        import module namespace copy="http://www.w3.org/QT3/copy";\n        id("id", copy:copy((//processing-instruction())[1]))\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", "||", or end of input but "m" found.'
K2-SeqIDFunc-6,AssertionError: expected [Function] to throw error including 'FODC0001' but got 'XPST0003: Unable to parse XPath: \n        import module namespace copy="http://www.w3.org/QT3/copy";\n        id("id", copy:copy(/*))\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", "||", or end of input but "m" found.'
K2-SeqIDFunc-7,AssertionError: expected [Function] to throw error including 'FODC0001' but got 'XPST0003: Unable to parse XPath: \n        import module namespace copy="http://www.w3.org/QT3/copy";\n        id("id", (copy:copy(/*)//*:NegativeComments)[last()])\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", "||", or end of input but "m" found.'
K2-SeqIDFunc-8,AssertionError: expected [Function] to throw an error
K2-SeqIDFunc-9,Error: XPST0003: Unable to parse XPath: (let $i := document {<e> <e/> <e/> <e/> <e/> <e/> <e/> <e/> <b xml:id="foo"/> <e/> </e>} return id("foo", $i)/name())!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found.
K2-SeqIDFunc-10,AssertionError: for $i in id(("short", "positiveInteger")) return $i/@name/string(): expected '' to equal 'positiveInteger short'
K2-SeqIDFunc-11,AssertionError: id(("short"), //xs:element/@name[. = "positiveInteger"])/@name: expected '' to equal 'short'
K2-SeqIDFunc-12,AssertionError: id((".", "short", "123"), //xs:element/@name[. = "positiveInteger"])/@name: expected '' to equal 'short'
K2-SeqIDFunc-13,Error: XPST0017: Function data with arity of 1 not registered. No similar functions found.
K2-SeqIDFunc-14,AssertionError: for $i in id(("short positiveInteger")) return $i/@name/string(): expected '' to equal 'positiveInteger short'
K2-SeqIDFunc-15,Error: XPST0017: Function data with arity of 1 not registered. No similar functions found.
cbcl-id-001,Error: XPST0003: Unable to parse XPath:        	declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then () else 'id1', 'id2' };        	let $doc := document { <root /> } return fn:empty( fn:id( local:generate(0), $doc) )       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-id-002,AssertionError: Expected executing the XPath "       	let $doc := document { <root /> } return fn:empty( fn:id( (), $doc) )       " to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath:        	let $doc := document { <root /> } return fn:empty( fn:id( (), $doc) )       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: \n      \tlet $doc := document { <root /> } return fn:empty( fn:id( (), $doc) )\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found.'.
cbcl-id-003,Error: XPST0003: Unable to parse XPath:        	declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then () else 'id1', 'id2' };        	let $doc := document { <root /> } return fn:empty( $doc/fn:id( local:generate(0)) )       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
fn-idref-2,AssertionError: expected [Function] to throw an error
fn-idref-4,AssertionError: expected [Function] to throw error including 'FODC0001' but got 'XPST0003: Unable to parse XPath: \n        import module namespace copy="http://www.w3.org/QT3/copy";\n        let $var := copy:copy(/*) return fn:idref("argument1", $var)\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", "||", or end of input but "m" found.'
K2-SeqIDREFFunc-3,AssertionError: expected [Function] to throw an error
cbcl-idref-001,Error: XPST0003: Unable to parse XPath:        	declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then () else 'id1', 'id2' };        	let $doc := document { <root /> } return fn:empty( fn:idref( local:generate(0), $doc) )       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-idref-002,AssertionError: Expected executing the XPath "       	let $doc := document { <root /> } return fn:empty( fn:idref( (), $doc) )       " to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath:        	let $doc := document { <root /> } return fn:empty( fn:idref( (), $doc) )       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: \n      \tlet $doc := document { <root /> } return fn:empty( fn:idref( (), $doc) )\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found.'.
cbcl-idref-003,Error: XPST0003: Unable to parse XPath:        	declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then () else 'id1', 'id2' };        	let $doc := document { <root /> } return fn:empty( $doc/fn:idref( local:generate(0)) )       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
fn-innermost-007,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function fn:dateTime with arity of 2 not registered. Did you mean "xs:dateTime (xs:anyAtomicType?)"?'
fn-innermost-008,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function fn:current-dateTime with arity of 0 not registered. No similar functions found.'
fn-innermost-009,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function current-date with arity of 0 not registered. No similar functions found.'
fn-innermost-010,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function fn:current-dateTime with arity of 0 not registered. No similar functions found.'
fn-innermost-011,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function current-date with arity of 0 not registered. No similar functions found.'
fn-innermost-045,Error: XPST0003: Unable to parse XPath: (fn:innermost( /root/level[1]/level[last()]/preceding::node() )) => count(). SyntaxError: Expected [A-Z_a-z----------] or [-] but ":" found.
fn-innermost-046,Error: XPST0003: Unable to parse XPath: fn:deep-equal( fn:innermost( /root/level[1]/level[last()]/preceding::node() ),                             let $nodes := /root/level[1]/level[last()]/preceding::node()                            return $nodes except $nodes/ancestor::node() ). SyntaxError: Expected [A-Z_a-z----------] or [-] but ":" found.
fn-innermost-049,Error: No selector counterpart for: following.
fn-innermost-050,Error: No selector counterpart for: following.
fn-innermost-055,Error: XPST0003: Unable to parse XPath: let $in := for $x in //* order by local-name($x) return $x             return deep-equal(fn:innermost($in)/local-name(), fn:innermost(//*)/local-name()). SyntaxError: Expected " ", "!", "!=", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
fn-innermost-056,Error: XPST0003: Unable to parse XPath: let $in := for $x in //* order by local-name($x) return $x             return deep-equal(fn:innermost(($in, $in))/local-name(), fn:innermost(//*)/local-name()). SyntaxError: Expected " ", "!", "!=", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
fn-insert-before-mix-args-018,AssertionError: Expected XPath fn:insert-before( ("a", "b", "c"),4, xs:date("1993-03-31")) to (deep equally) resolve to "a", "b", "c", xs:date('1993-03-31'): expected false to be true
fn-insert-before-mix-args-019,AssertionError: Expected XPath fn:insert-before( ("a", "b", "c"),4, xs:dateTime("1972-12-31T00:00:00")) to (deep equally) resolve to "a", "b", "c", xs:dateTime('1972-12-31T00:00:00'): expected false to be true
fn-insert-before-mix-args-020,AssertionError: Expected XPath fn:insert-before( ("a", "b", "c"),4, xs:time("12:30:00")) to (deep equally) resolve to "a", "b", "c", xs:time('12:30:00'): expected false to be true
K-SeqInsertBeforeFunc-16,AssertionError: Expected executing the XPath "count(insert-before((error(), 1), 1, (1, "two", 3))) > 1" to resolve to one of the expected results, but got Error: XPST0017: Function error with arity of 0 not registered. No similar functions found., AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'.
K-SeqInsertBeforeFunc-17,Error: XPST0003: Unable to parse XPath: (insert-before((1, current-time(), 3), 1, (4, 5, 6))[last()] treat as xs:integer) eq 3. SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.
K-SeqInsertBeforeFunc-18,Error: XPST0003: Unable to parse XPath: (insert-before((1, current-time(), 3), 10, (4, 5, 6))[last()] treat as xs:integer) eq 6. SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.
K-SeqInsertBeforeFunc-19,Error: XPST0003: Unable to parse XPath: (insert-before((1, current-time(), 3), 10, (4, 5, 6))[last() - 3] treat as xs:integer) eq 3. SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.
K-SeqInsertBeforeFunc-20,Error: XPST0003: Unable to parse XPath: (insert-before((1, current-time(), 3), 10, ())[last()] treat as xs:integer) eq 3. SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.
K-SeqInsertBeforeFunc-21,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
last-6,Error: XPST0003: Unable to parse XPath: for $h in (/works) return $h/employee[last()] << $h/employee[last()]. SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.
K-ContextLastFunc-5,Error: XPST0003: Unable to parse XPath: (1, 2, 3, current-time())[last() - 1] treat as xs:integer eq 3. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "t" found.
K-ContextLastFunc-6,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextLastFunc-7,AssertionError: Expected executing the XPath "empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [last() = 0])" to resolve to one of the expected results, but got Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0017: Function current-time with arity of 0 not registered. No similar functions found.'.
K-ContextLastFunc-8,AssertionError: Expected executing the XPath "empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [0 = last()])" to resolve to one of the expected results, but got Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0017: Function current-time with arity of 0 not registered. No similar functions found.'.
K-ContextLastFunc-9,AssertionError: Expected executing the XPath "empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [last() eq 0])" to resolve to one of the expected results, but got Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0017: Function current-time with arity of 0 not registered. No similar functions found.'.
K-ContextLastFunc-10,AssertionError: Expected executing the XPath "empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [0 eq last()])" to resolve to one of the expected results, but got Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0017: Function current-time with arity of 0 not registered. No similar functions found.'.
K-ContextLastFunc-11,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextLastFunc-12,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextLastFunc-13,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextLastFunc-14,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextLastFunc-15,AssertionError: Expected executing the XPath "empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [last() lt 1])" to resolve to one of the expected results, but got Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0017: Function current-time with arity of 0 not registered. No similar functions found.'.
K-ContextLastFunc-16,AssertionError: Expected executing the XPath "empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [last() < 1])" to resolve to one of the expected results, but got Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0017: Function current-time with arity of 0 not registered. No similar functions found.'.
K-ContextLastFunc-17,AssertionError: Expected executing the XPath "empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [last() le 0])" to resolve to one of the expected results, but got Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0017: Function current-time with arity of 0 not registered. No similar functions found.'.
K-ContextLastFunc-18,AssertionError: Expected executing the XPath "empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [last() <= 0])" to resolve to one of the expected results, but got Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0017: Function current-time with arity of 0 not registered. No similar functions found.'.
K-ContextLastFunc-19,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextLastFunc-20,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextLastFunc-21,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextLastFunc-22,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextLastFunc-23,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextLastFunc-24,Error: XPST0003: Unable to parse XPath: (1, 2, 3, 4, current-time(), 4, 5, 6)[last() - 2] treat as xs:integer eq 4. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "t" found.
K-ContextLastFunc-25,Error: XPST0003: Unable to parse XPath: (1, 2, 3, 4, current-time(), 4, 5, 6)[last() - 1] treat as xs:integer eq 5. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "t" found.
K-ContextLastFunc-26,Error: XPST0003: Unable to parse XPath: (1, 2, 3, 4, current-time(), 4, 5, 6)[last()] treat as xs:integer eq 6. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "t" found.
K-ContextLastFunc-27,Error: XPST0003: Unable to parse XPath: (1, 2, 3, 4, current-time(), 4, 5, 6)[last() - 0] treat as xs:integer eq 6. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "t" found.
cbcl-last-in-sequence-001,Error: XPST0003: Unable to parse XPath: (       	declare function local:generate($arg as xs:integer?) { if ($arg = 0) then (1, 2, 3) else () };        	( local:generate(0), 1, local:generate(0) )[last()]       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-last-in-sequence-002,Error: XPST0003: Unable to parse XPath: (       	declare function local:generate($arg as xs:integer?) as xs:integer* { if ($arg = 0) then (1, 2, 3) else $arg };        	( local:generate(()), for $x in local:generate(0) return $x + 2 )[last()]       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-last-in-sequence-003,Error: XPST0003: Unable to parse XPath: (       	declare function local:generate($arg as xs:integer?) as xs:integer? { if ($arg = 0) then 0 else () };        	( local:generate(()), for $x in local:generate(0) return $x + 2 )[last()]       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-last-in-sequence-004,Error: XPST0003: Unable to parse XPath: (       	declare function local:generate($arg as xs:integer?) as xs:integer* { if ($arg = 0) then ( 1, 2, 3 ) else ( $arg ) };        	( local:generate(()), for $x at $p in local:generate(0) return $p + $x)[last()]       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-last-in-sequence-005,Error: XPST0003: Unable to parse XPath: (       	declare function local:generate($arg as xs:integer?) as xs:integer? { if ($arg = 0) then 1 else $arg };        	( local:generate(()), for $x at $p in local:generate(0) return $p + $x)[last()]       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-last-in-sequence-006,Error: XPST0003: Unable to parse XPath: (       	declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then ('a', 'b', 'c') else ('d' ) };        	( if (local:generate(1) = 'd') then () else 1, for $x in local:generate(0) return fn:lower-case($x))[last()]       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-last-in-sequence-007,Error: XPST0003: Unable to parse XPath: (       	declare function local:generate($arg as xs:integer?) as xs:integer? { $arg };        	( if (local:generate(0) = 0) then () else 1, for $x in local:generate(0) return -$x)[last()]       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-last-in-sequence-009,Error: XPST0003: Unable to parse XPath: (       	declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then ('a', 'b', 'c') else () };        	( local:generate(()), for $x in local:generate(0) return 3)[last()]       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-last-in-sequence-010,Error: XPST0003: Unable to parse XPath:        	declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then ('a', 'b', 'c') else () };        	boolean(local:generate(0)[last()])       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-last-in-sequence-011,Error: XPST0003: Unable to parse XPath: declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then ('a', 'b', 'c') else () }; boolean(local:generate(1)[last()]). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-last-in-sequence-012,Error: XPST0003: Unable to parse XPath: (declare function local:generate($arg as xs:boolean) as xs:string+ { if ($arg) then ('a', 'b', 'c') else ('A', 'B', 'C') }; ( for $x in local:generate(true()) return 3)[last()])!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
LocalNameFromQNameFunc015,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
LocalNameFromQNameFunc015a,AssertionError: expected [Function] to throw error including 'XPTY0117' but got 'Casting to xs:QName is not implemented.'
LocalNameFromQNameFunc018,Error: XPST0017: Function data with arity of 1 not registered. No similar functions found.
fn-lower-case-18,Error: XPST0017: Function fn:string-to-codepoints with arity of 1 not registered. No similar functions found.
fn-lower-case-19,Error: XPST0017: Function fn:string-to-codepoints with arity of 1 not registered. No similar functions found.
fn-lower-case-20,Error: XPST0017: Function fn:string-to-codepoints with arity of 1 not registered. No similar functions found.
fn-maxintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxlng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxlng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxlng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxpint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxpint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxintg2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxintg2args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxintg2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxintg2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxintg2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxlng2args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxlng2args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxlng2args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxlng2args-4,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxlng2args-5,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnint2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnint2args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnint2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnint2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnint2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxpint2args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxpint2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxpint2args-4,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxpint2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxulng2args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxulng2args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxulng2args-4,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxulng2args-5,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnpi2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnpi2args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnpi2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnpi2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnpi2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnni2args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnni2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnni2args-4,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-maxnni2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-SeqMAXFunc-21,AssertionError: expected [Function] to throw an error
K-SeqMAXFunc-22,AssertionError: expected [Function] to throw an error
K-SeqMAXFunc-30,AssertionError: Expected XPath max((3, xs:float("NaN"))) instance of xs:float to resolve to true: expected false to be true
K-SeqMAXFunc-38,AssertionError: expected [Function] to throw an error
K-SeqMAXFunc-55,Error: XPST0017: Function current-date with arity of 0 not registered. No similar functions found.
fn-max-5,AssertionError: max(for $x in 1 to 10 return xs:dayTimeDuration(concat("PT",$x,"H"))): expected 'PT1H' to equal 'PT10H'
fn-max-7,AssertionError: max(for $x in 1 to 10 return xs:yearMonthDuration(concat("P",$x,"M"))): expected 'P1M' to equal 'P10M'
fn-max-8,AssertionError: Expected executing the XPath "max((xs:yearMonthDuration("P1Y"), xs:dayTimeDuration("P1D")))" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw an error, AssertionError: expected [Function] to throw an error.
fn-max-9,AssertionError: Expected executing the XPath "max(xs:duration("P1Y1M1D"))" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw an error, AssertionError: expected [Function] to throw an error.
fn-max-10,Error: XPST0003: Unable to parse XPath: (for $p in 1 to 4 let $x := (xs:integer(1), xs:decimal(2), xs:float(3), xs:double(4))[position() le $p] return typeswitch (max($x)) case xs:integer return "integer" case xs:decimal return "decimal" case xs:float return "float" case xs:double return "double" default return error())!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "union", "|", or "||" but "l" found.
fn-max-18,AssertionError: Expected XPath max((xs:token("zither"), xs:anyURI("http://b.com"))) to resolve to something of type xs:token: expected false to be true
fn-max-19,Error: Atomizing array(*) is not implemented.
cbcl-max-001,Error: XPST0003: Unable to parse XPath:        	declare function local:f($x as xs:integer) {        		if ($x = 0) then true() else false()        	};        	max(for $x in (1,2,3) return local:f($x))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-max-002,Error: XPST0003: Unable to parse XPath:        	declare function local:f($x as xs:integer) {        		if ($x = 2) then true() else false()        	};        	max(for $x in (1,2,3) return local:f($x))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-max-003,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:f($x as xs:integer) { \n      \t\tif ($x = 3) then $x else false() \n      \t}; \n      \tmax(for $x in (1,2,3) return local:f($x))\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
cbcl-max-004,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:f($x as xs:integer) {\n      \t\t if ($x < 3) then current-date() else current-time() \n      \t}; \n      \tmax(for $x in (1,2,3) return local:f($x))\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
cbcl-max-005,Error: XPST0003: Unable to parse XPath: (       	declare function local:f($x as xs:integer) {        		if ($x = 2) then xs:dateTime("3000-12-01T12:00:00") else current-dateTime()        	};        	max(for $x in (1,2,3) return local:f($x))       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-max-006,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:f($x as xs:integer) { \n      \t\tif ($x < 3) then current-dateTime() else xs:dayTimeDuration("PT3S") \n      \t}; \n      \tmax(for $x in (1,2,3) return local:f($x))\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
cbcl-max-007,Error: XPST0003: Unable to parse XPath: (       	declare function local:f($x as xs:integer) {        		if ($x = 2) then xs:dayTimeDuration("P1D") else xs:dayTimeDuration("PT3S")        	};        	max(for $x in (1,2,3) return local:f($x))       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-max-008,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:f($x as xs:integer) {\n      \t\t if ($x = 3) then xs:duration("P1D") else xs:dayTimeDuration("PT3S") \n      \t}; \n      \tmax(for $x in (1,2,3) return local:f($x))\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
cbcl-max-009,Error: XPST0003: Unable to parse XPath:        	declare function local:f($x as xs:integer) {       		 (xs:decimal(1.1), xs:float(2.2), xs:double(1.4), xs:integer(2))[$x]        	};        	max(for $x in (1,2,3) return local:f($x)) instance of xs:double       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-max-010,Error: XPST0003: Unable to parse XPath:        	declare function local:f($x as xs:integer) {        		(xs:decimal(1.3), xs:float(1.2), xs:double(1.4), xs:integer(2))[$x]        	};        	max(for $x in (1,2,3) return local:f($x)) instance of xs:double       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-max-011,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:f($x as xs:integer) {\n      \t\t (xs:decimal(1.1), xs:float(1.2), xs:double(0.4), xs:string("2"))[$x] \n      \t}; \n      \tmax(for $x in (1,4,2,3) return local:f($x))\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
cbcl-max-012,Error: XPST0003: Unable to parse XPath:        	declare function local:f($x as xs:integer) {        		(xs:decimal(1.1), xs:float(1.2), xs:double(0.4), xs:integer("-3"))[$x]        	};        	max(for $x in (4,2,1,3) return local:f($x)) instance of xs:double       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-max-013,Error: XPST0003: Unable to parse XPath: (       	declare function local:f($x as xs:integer) {        		if ($x = 2) then xs:time("12:00:00-01:00") else xs:time("12:00:00+01:00")        	};        	max(for $x in (1,2,3) return local:f($x))       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-max-014,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:f($x as xs:integer) { \n      \t\tif ($x < 3) then current-time() else xs:dayTimeDuration("PT3S") \n      \t}; \n      \tmax(for $x in (1,2,3) return local:f($x))\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
cbcl-max-015,Error: XPST0003: Unable to parse XPath: (       	declare function local:f($x as xs:integer) {        		if ($x = 2) then xs:yearMonthDuration("P13M") else xs:yearMonthDuration("P1Y")        	};       	max(for $x in (1,2,3) return local:f($x))       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-max-016,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:f($x as xs:integer) { \n      \t\tif ($x = 3) then xs:duration("P1Y") else xs:yearMonthDuration("P11M") \n      \t}; \n      \tmax(for $x in (1,2,3) return local:f($x))\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
cbcl-max-017,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:f($x as xs:integer) as xs:duration { \n      \t\tif ($x = 1) then xs:duration("P1Y") else xs:yearMonthDuration("P11M") \n      \t}; \n      \tmax(for $x in (1,2,3) return local:f($x)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
cbcl-max-018,Error: XPST0003: Unable to parse XPath: (       	declare function local:f($x as xs:integer) as xs:integer { $x };        	max(local:f(4) to local:f(10)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
fn-minintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minlng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minlng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minlng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minpint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minpint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minintg2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minintg2args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minintg2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minintg2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minintg2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minlng2args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minlng2args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minlng2args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minlng2args-4,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minlng2args-5,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnint2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnint2args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnint2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnint2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnint2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minpint2args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minpint2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minpint2args-4,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minpint2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minulng2args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minulng2args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minulng2args-4,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minulng2args-5,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnpi2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnpi2args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnpi2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnpi2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnpi2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnni2args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnni2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnni2args-4,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-minnni2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-SeqMINFunc-21,AssertionError: expected [Function] to throw an error
K-SeqMINFunc-22,AssertionError: expected [Function] to throw an error
K-SeqMINFunc-30,AssertionError: Expected XPath min((3, xs:float("NaN"))) instance of xs:float to resolve to true: expected false to be true
K-SeqMINFunc-38,AssertionError: expected [Function] to throw an error
K-SeqMINFunc-47,AssertionError: Expected XPath min((xs:date("2005-01-01"), xs:date("2001-01-01"))) eq xs:date("2001-01-01") to resolve to true: expected false to be true
fn-min-8,AssertionError: Expected executing the XPath "min((xs:yearMonthDuration("P1Y"), xs:dayTimeDuration("P1D")))" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw an error, AssertionError: expected [Function] to throw an error.
fn-min-9,AssertionError: Expected executing the XPath "min(xs:duration("P1Y1M1D"))" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw an error, AssertionError: expected [Function] to throw an error.
fn-min-10,Error: XPST0003: Unable to parse XPath: (for $p in 1 to 4 let $x := (xs:integer(4), xs:decimal(3), xs:float(2), xs:double(1))[position() le $p] return typeswitch (min($x)) case xs:integer return "integer" case xs:decimal return "decimal" case xs:float return "float" case xs:double return "double" default return error())!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "union", "|", or "||" but "l" found.
fn-min-18,AssertionError: Expected XPath min((xs:token("http"), xs:anyURI("http://b.com"))) to resolve to something of type xs:token: expected false to be true
fn-min-19,Error: Atomizing array(*) is not implemented.
cbcl-min-001,Error: XPST0003: Unable to parse XPath:        	declare function local:f($x as xs:integer) { if ($x = 0) then false() else true() };        	min(for $x in (1,2,3) return local:f($x))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-min-002,Error: XPST0003: Unable to parse XPath:        	declare function local:f($x as xs:integer) { if ($x = 2) then false() else true() };        	min(for $x in (1,2,3) return local:f($x))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-min-003,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:f($x as xs:integer) { if ($x = 3) then $x else false() }; \n      \tmin(for $x in (1,2,3) return local:f($x))\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
cbcl-min-004,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:f($x as xs:integer) { if ($x < 3) then current-date() else current-time() }; \n      \tmin(for $x in (1,2,3) return local:f($x))\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
cbcl-min-005,Error: XPST0003: Unable to parse XPath: (       	declare function local:f($x as xs:integer) { if ($x = 2) then xs:dateTime("1996-12-01T12:00:00") else current-dateTime() };        	min(for $x in (1,2,3) return local:f($x))       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-min-006,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:f($x as xs:integer) { if ($x < 3) then current-dateTime() else xs:dayTimeDuration("PT3S") }; \n      \tmin(for $x in (1,2,3) return local:f($x))\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
cbcl-min-007,Error: XPST0003: Unable to parse XPath: (       	declare function local:f($x as xs:integer) { if ($x = 2) then xs:dayTimeDuration("P1D") else xs:dayTimeDuration("PT3S") };        	min(for $x in (1,2,3) return local:f($x))       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-min-008,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:f($x as xs:integer) { if ($x = 3) then xs:duration("P1D") else xs:dayTimeDuration("PT3S") }; \n      \tmin(for $x in (1,2,3) return local:f($x))\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
cbcl-min-009,Error: XPST0003: Unable to parse XPath:        	declare function local:f($x as xs:integer) { (xs:decimal(1.1), xs:float(2.2), xs:double(1.4), xs:integer(2))[$x] };        	min(for $x in (1,2,3) return local:f($x)) instance of xs:double       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-min-010,Error: XPST0003: Unable to parse XPath:        	declare function local:f($x as xs:integer) { (xs:decimal(1.3), xs:float(1.2), xs:double(1.4), xs:integer(2))[$x] };        	min(for $x in (1,2,3) return local:f($x)) instance of xs:double. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-min-011,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:f($x as xs:integer) { (xs:decimal(1.1), xs:float(1.2), xs:double(0.4), xs:string("2"))[$x] }; \n      \tmin(for $x in (1,4,2,3) return local:f($x))\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
cbcl-min-012,Error: XPST0003: Unable to parse XPath:        	declare function local:f($x as xs:integer) { (xs:decimal(1.1), xs:float(1.2), xs:double(0.4), xs:integer("-3"))[$x] };        	min(for $x in (4,2,1,3) return local:f($x)) instance of xs:double       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-min-013,Error: XPST0003: Unable to parse XPath: (       	declare function local:f($x as xs:integer) { if ($x = 2) then xs:time("12:00:00-01:00") else xs:time("12:00:00+01:00") };        	min(for $x in (1,2,3) return local:f($x))       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-min-014,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:f($x as xs:integer) { if ($x < 3) then current-time() else xs:dayTimeDuration("PT3S") }; \n      \tmin(for $x in (1,2,3) return local:f($x))\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
cbcl-min-015,Error: XPST0003: Unable to parse XPath: (       	declare function local:f($x as xs:integer) { if ($x = 2) then xs:yearMonthDuration("P11M") else xs:yearMonthDuration("P1Y") };        	min(for $x in (1,2,3) return local:f($x))       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-min-016,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:f($x as xs:integer) { if ($x = 3) then xs:duration("P1Y") else xs:yearMonthDuration("P11M") }; \n      \tmin(for $x in (1,2,3) return local:f($x))\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
cbcl-min-017,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:f($x as xs:integer) as xs:duration { if ($x = 1) then xs:duration("P1Y") else xs:yearMonthDuration("P11M") }; \n      \tmin(for $x in (1,2,3) return local:f($x))\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
cbcl-min-018,Error: XPST0003: Unable to parse XPath: (       	declare function local:f($x as xs:integer) as xs:integer { $x };        	min(local:f(4) to local:f(10))       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
fn-name-13,Error: XPST0017: Function fn:substring with arity of 2 not registered. Did you mean "xs:string (xs:anyAtomicType?)"?
fn-name-16,AssertionError: Expected executing the XPath "for $h in (./works/employee[2]) return fn:count(fn:name($h/self::div))" to resolve to one of the expected results, but got AssertionError: for $h in (./works/employee[2]) return fn:count(fn:name($h/self::div)): expected '0' to equal '1', AssertionError: expected [Function] to throw an error.
K-NameFunc-3,AssertionError: Expected XPath name(()) eq "" to resolve to true: expected false to be true
NamespaceURIFromQNameFunc015,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
NamespaceURIFromQNameFunc015a,AssertionError: expected [Function] to throw error including 'XPTY0117' but got 'Casting to xs:QName is not implemented.'
NamespaceURIFromQNameFunc018,Error: XPST0017: Function data with arity of 1 not registered. No similar functions found.
K2-NamespaceURIFromQNameFunc-1,Error: XPST0003: Unable to parse XPath: (         declare namespace ns = "http://example.com/ANamespace";          string(<name xmlns:ns="http://example.com/BNamespace">{namespace-uri-from-QName("ns:foo" cast as xs:QName)}</name>)       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
K2-NamespaceURIFromQNameFunc-2,Error: XPST0003: Unable to parse XPath: (         <e xmlns="http://example.com/"> {namespace-uri-from-QName(node-name(element anElement{"text"}))} </e>/string()       )!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "a" found.
K2-NamespaceURIFromQNameFunc-3,Error: XPST0003: Unable to parse XPath: (         declare default element namespace "http://example.com/";          <e xmlns="">{namespace-uri-from-QName(xs:QName("l"))}</e>/string()       ) = (""). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found.
K2-NamespaceURIFromQNameFunc-4,Error: XPST0003: Unable to parse XPath: (         declare default element namespace "http://example.com/";          declare namespace p = "http://example.com/2";          <e xmlns="" xmlns:p="http://example.com/3">[{namespace-uri-from-QName(xs:QName("n1"))}|{namespace-uri-from-QName(xs:QName("p:n2"))}]</e>/text()       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found.
fn-node-name-8,Error: XPST0003: Unable to parse XPath: (fn:local-name-from-QName(fn:node-name(element elementName {})))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found.
fn-node-name-9,Error: XPST0003: Unable to parse XPath: (fn:count(fn:namespace-uri-from-QName(fn:node-name(element elementName {}))))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found.
fn-node-name-10,Error: XPST0003: Unable to parse XPath: (fn:local-name-from-QName(fn:node-name(element elementName { element achild {"some text"}})))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found.
fn-node-name-11,Error: XPST0003: Unable to parse XPath: (fn:local-name-from-QName(fn:node-name(attribute attributeName {""})))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "a" found.
fn-node-name-12,Error: XPST0003: Unable to parse XPath: (fn:local-name-from-QName(fn:node-name(attribute attributeName {"an attribute value"})))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "a" found.
fn-node-name-13,Error: XPST0003: Unable to parse XPath: (fn:count(fn:namespace-uri-from-QName(fn:node-name(attribute attributeName {"an attribute value"}))))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "a" found.
fn-node-name-14,Error: XPST0003: Unable to parse XPath: (fn:count(fn:local-name-from-QName(fn:node-name(document {""}))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
fn-node-name-15,Error: XPST0003: Unable to parse XPath: (fn:count(fn:namespace-uri-from-QName(fn:node-name(document {""}))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
fn-node-name-16,Error: XPST0003: Unable to parse XPath: (fn:count(fn:local-name-from-QName(fn:node-name(document {"<element1> text </element1>"}))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
fn-node-name-17,Error: XPST0003: Unable to parse XPath: (fn:count(fn:namespace-uri-from-QName(fn:node-name(document {"<element1> text </element1>"}))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
fn-node-name-18,Error: XPST0003: Unable to parse XPath: (fn:count(fn:local-name-from-QName(fn:node-name(text {""}))))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
fn-node-name-19,Error: XPST0003: Unable to parse XPath: (fn:count(fn:namespace-uri-from-QName(fn:node-name(text {""}))))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
fn-node-name-20,Error: XPST0003: Unable to parse XPath: (fn:count(fn:local-name-from-QName(fn:node-name(text {"a text value"}))))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
fn-node-name-21,Error: XPST0003: Unable to parse XPath: (fn:count(fn:namespace-uri-from-QName(fn:node-name(text {"a text value"}))))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
fn-node-name-22,Error: XPST0003: Unable to parse XPath: (fn:local-name-from-QName(fn:node-name(processing-instruction piName {"Processing Instruction content"})))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "p" found.
fn-node-name-23,Error: XPST0003: Unable to parse XPath: (fn:count(fn:namespace-uri-from-QName(fn:node-name(processing-instruction piName {"Processing Instruction content"}))))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "p" found.
fn-node-name-24,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'XPST0003: Unable to parse XPath: fn:node-name(processing-instruction piName {"Processing Instruction content"},"A Second Argument"). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "p" found.'
fn-node-name-28,Error: XPST0003: Unable to parse XPath: (namespace{"foo"}{"http://example.com/foo"}/node-name()) = (QName("", "foo")). SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
fn-node-name-30,AssertionError: expected [Function] to throw an error
fn-node-name-31,AssertionError: expected [Function] to throw an error
K-NodeNameFunc-1,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'XPDY0002: The function which was called depends on dynamic context, which is absent.'
cbcl-node-name-001,Error: XPST0003: Unable to parse XPath: empty(node-name( comment { "comments have no name " } ) ). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
fn-normalize-space-23,AssertionError: Expected XPath /*/normalize-space() to resolve to "ns:barns:bar2ns:barDerivurn1test1test2": expected false to be true
fn-normalize-space-24,AssertionError: expected [Function] to throw an error
fn-normalize-space-25,Error: XPST0017: Function current-date with arity of 0 not registered. No similar functions found.
fn-normalize-space-26,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function current-date with arity of 0 not registered. No similar functions found.'
K-NormalizeSpaceFunc-9,AssertionError: Expected executing the XPath "normalize-space(normalize-space(("foo", current-time())[1])) eq "foo"" to resolve to one of the expected results, but got Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function current-time with arity of 0 not registered. No similar functions found.'.
fn-notintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-notintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-notintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-notlng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-notlng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-notlng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-notnint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-notnint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-notpint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-notpint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-notulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-notulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-notnpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-notnpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-notnni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-notnni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-NotFunc-10,Error: XPST0003: Unable to parse XPath: not(fn:boolean((1, 2, 3, current-time())[1] treat as xs:integer)) eq false(). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.
cbcl-not-003,Error: XPST0017: Function current-date with arity of 0 not registered. No similar functions found.
cbcl-not-004,Error: XPST0003: Unable to parse XPath:        	declare function local:f($x as xs:integer) as xs:integer { $x };        	not(not(local:f(1)))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-not-005,Error: XPST0003: Unable to parse XPath:        	declare function local:f($x as xs:integer) as xs:integer* { 1 to $x };        	not(exists(local:f(0)))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
fn-numberint1args-1,AssertionError: fn:number(xs:int("-2147483648")): expected '-2147483648' to equal '-2.147483648E9'
fn-numberint1args-2,AssertionError: fn:number(xs:int("-1873914410")): expected '-1873914410' to equal '-1.87391441E9'
fn-numberint1args-3,AssertionError: fn:number(xs:int("2147483647")): expected '2147483647' to equal '2.147483647E9'
fn-numberintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-numberintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-numberintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-numberdec1args-1,AssertionError: fn:number(xs:decimal("-999999999999999999")): expected '-1000000000000000000' to equal '-1.0E18'
fn-numberdec1args-3,AssertionError: fn:number(xs:decimal("999999999999999999")): expected '1000000000000000000' to equal '1.0E18'
fn-numberflt1args-1,AssertionError: Expected XPath fn:number(xs:float("-3.4028235E38")) eq -3.4028234663852885E38 to resolve to true: expected false to be true
fn-numberflt1args-3,AssertionError: Expected executing the XPath "fn:number(xs:float("3.4028235E38"))" to resolve to one of the expected results, but got AssertionError: fn:number(xs:float("3.4028235E38")): expected '3.4028235E38' to equal '3.4028234663852885E38', AssertionError: fn:number(xs:float("3.4028235E38")): expected '3.4028235E38' to equal '3.402823466385289E38', AssertionError: fn:number(xs:float("3.4028235E38")): expected '3.4028235E38' to equal '3.4028234663852886E38'.
fn-numberlng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-numberlng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-numberlng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-numbernint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-numbernint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-numberpint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-numberpint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-numberulng1args-2,AssertionError: Expected executing the XPath "fn:number(xs:unsignedLong("130747108607674654"))" to resolve to one of the expected results, but got Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers..
fn-numberulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-numbernpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-numbernpi1args-2,AssertionError: Expected executing the XPath "fn:number(xs:nonPositiveInteger("-475688437271870490"))" to resolve to one of the expected results, but got Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers..
fn-numbernni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-numbernni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-number-7,Error: XPST0017: Function implicit-timezone with arity of 0 not registered. No similar functions found.
fn-one-or-moreintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-one-or-moreintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-one-or-moreintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-one-or-moredec1args-1,AssertionError: fn:one-or-more(xs:decimal("-999999999999999999")): expected '-1000000000000000000' to equal '-999999999999999999'
fn-one-or-moredec1args-2,AssertionError: fn:one-or-more(xs:decimal("617375191608514839")): expected '617375191608514800' to equal '617375191608514839'
fn-one-or-moredec1args-3,AssertionError: fn:one-or-more(xs:decimal("999999999999999999")): expected '1000000000000000000' to equal '999999999999999999'
fn-one-or-morelng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-one-or-morelng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-one-or-morelng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-one-or-morenint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-one-or-morenint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-one-or-morepint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-one-or-morepint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-one-or-moreulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-one-or-moreulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-one-or-morenpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-one-or-morenpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-one-or-morenni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-one-or-morenni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-SeqOneOrMoreFunc-7,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'
K2-SeqOneOrMoreFunc-1,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
cbcl-one-or-more-001,Error: XPST0003: Unable to parse XPath: (         declare function local:generate($arg as xs:integer?) { if ($arg = 0) then (1, 2, 3) else $arg };         fn:one-or-more(fn:reverse( local:generate( 0 ) )))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-one-or-more-002,AssertionError: expected [Function] to throw error including 'FORG0004' but got 'XPST0003: Unable to parse XPath: \n        declare function local:generate($arg as xs:integer?) { if ($arg = 0) then (1, 2, 3) else $arg };\n        fn:one-or-more(fn:zero-or-one( local:generate( () ) )). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
cbcl-one-or-more-003,Error: XPST0017: Function month-from-date with arity of 1 not registered. No similar functions found.
cbcl-one-or-more-004,AssertionError: expected [Function] to throw error including 'FORG0004' but got 'XPST0017: Function month-from-date with arity of 1 not registered. No similar functions found.'
fn-outermost-007,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function fn:dateTime with arity of 2 not registered. Did you mean "xs:dateTime (xs:anyAtomicType?)"?'
fn-outermost-008,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function fn:current-dateTime with arity of 0 not registered. No similar functions found.'
fn-outermost-009,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function current-date with arity of 0 not registered. No similar functions found.'
fn-outermost-010,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function fn:current-dateTime with arity of 0 not registered. No similar functions found.'
fn-outermost-011,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function current-date with arity of 0 not registered. No similar functions found.'
fn-outermost-045,Error: XPST0003: Unable to parse XPath: (fn:outermost( /root/level[1]/level[last()]/preceding::node() )) => count(). SyntaxError: Expected [A-Z_a-z----------] or [-] but ":" found.
fn-outermost-046,Error: XPST0003: Unable to parse XPath: fn:deep-equal( fn:outermost( /root/level[1]/level[last()]/preceding::node() ),                             let $nodes := /root/level[1]/level[last()]/preceding::node()                            return $nodes except $nodes/descendant::node() ). SyntaxError: Expected [A-Z_a-z----------] or [-] but ":" found.
fn-outermost-049,Error: No selector counterpart for: following.
fn-outermost-050,Error: No selector counterpart for: following.
fn-outermost-055,Error: XPST0003: Unable to parse XPath: let $in := for $x in //* order by local-name($x) return $x             return deep-equal(fn:outermost($in)/local-name(), fn:outermost(//*)/local-name()). SyntaxError: Expected " ", "!", "!=", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
fn-outermost-056,Error: XPST0003: Unable to parse XPath: let $in := for $x in //* order by local-name($x) return $x             return deep-equal(fn:outermost(($in, $in))/local-name(), fn:outermost(//*)/local-name()). SyntaxError: Expected " ", "!", "!=", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
fn-parse-json-002,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?
fn-parse-json-011,Error: No selector counterpart for: anyArrayTest.
fn-parse-json-012,Error: No selector counterpart for: anyArrayTest.
fn-parse-json-013,Error: No selector counterpart for: anyArrayTest.
fn-parse-json-014,Error: No selector counterpart for: anyArrayTest.
fn-parse-json-015,Error: No selector counterpart for: anyArrayTest.
fn-parse-json-016,Error: No selector counterpart for: anyArrayTest.
fn-parse-json-017,Error: No selector counterpart for: anyArrayTest.
fn-parse-json-018,Error: No selector counterpart for: anyArrayTest.
fn-parse-json-019,Error: No selector counterpart for: typedArrayTest.
fn-parse-json-020,Error: No selector counterpart for: anyArrayTest.
fn-parse-json-021,Error: XPST0003: Unable to parse XPath: let $result := (parse-json('[{"x":12,"y":5}, {"x":13,"y":6}]')) return $result?2?y = 6. SyntaxError: Expected "$", "(", "*", [A-Z_a-z----------], or [-] but "2" found.
fn-parse-json-022,Error: XPST0003: Unable to parse XPath: let $result := (parse-json('{"x":[12,3], "y":[14,9]}')) return $result?y?2 = 9. SyntaxError: Expected "$", "(", "*", [A-Z_a-z----------], or [-] but "2" found.
fn-parse-json-023,Error: XPST0003: Unable to parse XPath: let $result := (parse-json('[0.123]')) return $result?1 = 0.123e0. SyntaxError: Expected "$", "(", "*", [A-Z_a-z----------], or [-] but "1" found.
fn-parse-json-024,Error: XPST0003: Unable to parse XPath: let $result := (parse-json('[-0.123]')) return $result?1 = -0.123e0. SyntaxError: Expected "$", "(", "*", [A-Z_a-z----------], or [-] but "1" found.
fn-parse-json-025,Error: XPST0003: Unable to parse XPath: let $result := (parse-json('[-0.123e2]')) return $result?1 = -0.123e2. SyntaxError: Expected "$", "(", "*", [A-Z_a-z----------], or [-] but "1" found.
fn-parse-json-026,Error: XPST0003: Unable to parse XPath: let $result := (parse-json('[-0.123e+2]')) return $result?1 = -0.123e+2. SyntaxError: Expected "$", "(", "*", [A-Z_a-z----------], or [-] but "1" found.
fn-parse-json-027,Error: XPST0003: Unable to parse XPath: let $result := (parse-json('[-0.123e-2]')) return $result?1 = -0.123e-2. SyntaxError: Expected "$", "(", "*", [A-Z_a-z----------], or [-] but "1" found.
fn-parse-json-028,Error: XPST0003: Unable to parse XPath: let $result := (parse-json('["\\"]')) return $result?1 = "\". SyntaxError: Expected "$", "(", "*", [A-Z_a-z----------], or [-] but "1" found.
fn-parse-json-029,Error: XPST0003: Unable to parse XPath: let $result := (parse-json('["\""]')) return $result?1 = '"'. SyntaxError: Expected "$", "(", "*", [A-Z_a-z----------], or [-] but "1" found.
fn-parse-json-030,Error: XPST0003: Unable to parse XPath: let $result := (parse-json('["\r"]')) return $result?1 = codepoints-to-string(13). SyntaxError: Expected "$", "(", "*", [A-Z_a-z----------], or [-] but "1" found.
fn-parse-json-031,Error: XPST0003: Unable to parse XPath: let $result := (parse-json('["\n"]')) return $result?1 = codepoints-to-string(10). SyntaxError: Expected "$", "(", "*", [A-Z_a-z----------], or [-] but "1" found.
fn-parse-json-032,Error: XPST0003: Unable to parse XPath: let $result := (parse-json('["\/"]')) return $result?1 = '/'. SyntaxError: Expected "$", "(", "*", [A-Z_a-z----------], or [-] but "1" found.
fn-parse-json-033,Error: XPST0003: Unable to parse XPath: let $result := (parse-json('["aa\u0030aa"]')) return $result?1 = 'aa0aa'. SyntaxError: Expected "$", "(", "*", [A-Z_a-z----------], or [-] but "1" found.
fn-parse-json-034,Error: XPST0003: Unable to parse XPath: let $result := (parse-json('["\uD834\udD1E"]')) return $result?1 = codepoints-to-string(119070). SyntaxError: Expected "$", "(", "*", [A-Z_a-z----------], or [-] but "1" found.
fn-parse-json-035,Error: XPST0003: Unable to parse XPath: let $result := (parse-json('["\r"]', map{'escape':true()})) return $result?1 = '\r'. SyntaxError: Expected "$", "(", "*", [A-Z_a-z----------], or [-] but "1" found.
fn-parse-json-036,Error: XPST0003: Unable to parse XPath: let $result := (parse-json('["\r"]', map{'escape':false()})) return $result?1 = codepoints-to-string(13). SyntaxError: Expected "$", "(", "*", [A-Z_a-z----------], or [-] but "1" found.
fn-parse-json-037,Error: XPST0003: Unable to parse XPath: let $result := (parse-json('["\u0000"]', map{'escape':true()})) return $result?1 = '\u0000'. SyntaxError: Expected "$", "(", "*", [A-Z_a-z----------], or [-] but "1" found.
fn-parse-json-042,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?
fn-parse-json-050,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?
fn-parse-json-051,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?
fn-parse-json-052,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?
fn-parse-json-053,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
fn-parse-json-054,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
fn-parse-json-055,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
fn-parse-json-056,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
fn-parse-json-057,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
fn-parse-json-058,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
fn-parse-json-059,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?
fn-parse-json-060,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?
fn-parse-json-061,AssertionError: Expected executing the XPath "parse-json('"\b"', map{'fallback':lower-case#1})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?, Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?.
fn-parse-json-062,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?
fn-parse-json-063,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?
fn-parse-json-064,AssertionError: Expected executing the XPath "parse-json('{"\b":""}', map{'fallback':lower-case#1}) => map:keys()" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?, Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?.
fn-parse-json-065,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?
fn-parse-json-066,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?
fn-parse-json-101,Error: XPST0017: Function unparsed-text with arity of 1 not registered. No similar functions found.
fn-parse-json-102,Error: XPST0017: Function unparsed-text with arity of 1 not registered. No similar functions found.
fn-parse-json-103,Error: XPST0017: Function unparsed-text with arity of 1 not registered. No similar functions found.
fn-parse-json-104,Error: XPST0017: Function unparsed-text with arity of 1 not registered. No similar functions found.
fn-parse-json-105,Error: XPST0017: Function unparsed-text with arity of 1 not registered. No similar functions found.
fn-parse-json-106,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?
fn-parse-json-107,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?
fn-parse-json-108,AssertionError: expected [Function] to throw error including 'FOJS0003' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'
fn-parse-json-109,AssertionError: expected [Function] to throw error including 'FOJS0003' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'
fn-parse-json-110,AssertionError: expected [Function] to throw error including 'FOJS0003' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'
fn-parse-json-111,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?
fn-parse-json-801,AssertionError: Expected executing the XPath "parse-json('[-0.123e-2,]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'.
fn-parse-json-802,AssertionError: Expected executing the XPath "parse-json('[FALSE]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'.
fn-parse-json-804,AssertionError: Expected executing the XPath "parse-json('[(5)]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'.
fn-parse-json-806,AssertionError: Expected executing the XPath "parse-json('[{x:23}]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'.
fn-parse-json-809,AssertionError: Expected executing the XPath "parse-json('[1,2,3,]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'.
fn-parse-json-810,AssertionError: Expected executing the XPath "parse-json('{"a":=13}', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'.
fn-parse-json-811,AssertionError: Expected executing the XPath "parse-json('{"a":13,,"b":15}', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'.
fn-parse-json-814,AssertionError: Expected executing the XPath "parse-json('{"a":{"b":12}}}', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'.
fn-parse-json-815,AssertionError: Expected executing the XPath "parse-json('["\"]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'.
fn-parse-json-816,AssertionError: Expected executing the XPath "parse-json('["\1"]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'.
fn-parse-json-817,AssertionError: Expected executing the XPath "parse-json('["\u2"]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'.
fn-parse-json-819,AssertionError: Expected executing the XPath "parse-json('["\b"]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'.
fn-parse-json-820,AssertionError: Expected executing the XPath "parse-json('["\x20"]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'.
fn-parse-json-821,AssertionError: Expected executing the XPath "parse-json('["\s"]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'.
fn-parse-json-822,AssertionError: Expected executing the XPath "parse-json('["\uD834"]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'.
fn-parse-json-823,AssertionError: Expected executing the XPath "parse-json('["\udD1E"]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'.
fn-parse-json-824,AssertionError: Expected executing the XPath "parse-json('["\u0000"]', map{'escape':false(), 'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'.
fn-parse-json-830,AssertionError: Expected executing the XPath "parse-json('[.3]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'.
fn-parse-json-831,AssertionError: Expected executing the XPath "parse-json('[01]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'.
fn-parse-json-832,AssertionError: Expected executing the XPath "parse-json('[00.00]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'.
fn-parse-json-833,AssertionError: Expected executing the XPath "parse-json('[+23]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'.
fn-parse-json-834,AssertionError: Expected executing the XPath "parse-json('[1.234f0]', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'.
fn-parse-json-835,AssertionError: Expected executing the XPath "parse-json("['wrong']", map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'.
fn-parse-json-839,AssertionError: Expected executing the XPath "parse-json('', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'.
fn-parse-json-840,AssertionError: Expected executing the XPath "parse-json('{"'||codepoints-to-string((10, 37))||'":"x", "yyy":"y"}', map{'liberal':true()})" to resolve to one of the expected results, but got Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'.
fn-parse-json-919,AssertionError: Expected executing the XPath "parse-json('["\b"]')" to resolve to one of the expected results, but got AssertionError: Expected XPath parse-json('["\b"]') to (deep equally) resolve to ['']: expected false to be true, AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'Atomizing array(*) is not implemented.'.
fn-parse-json-922,AssertionError: Expected XPath parse-json('["\uD834"]') to (deep equally) resolve to ['']: expected false to be true
fn-parse-json-923,AssertionError: Expected XPath parse-json('["\udD1E"]') to (deep equally) resolve to ['']: expected false to be true
fn-parse-json-924,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?
fn-parse-json-925,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?
fn-parse-json-926,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?
fn-parse-json-927,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?
fn-parse-json-928,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?
fn-parse-json-929,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?
fn-parse-json-936,AssertionError: expected [Function] to throw error including 'FOJS0003' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'
fn-parse-json-937,AssertionError: expected [Function] to throw error including 'FOJS0005' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'
fn-parse-json-938,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'
fn-parse-json-940,AssertionError: expected [Function] to throw error including 'FOJS0005' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'
fn-parse-json-941,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'
fn-parse-json-942,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'
fn-parse-json-943,AssertionError: expected [Function] to throw error including 'Q{}USER9999' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'
fn-parse-json-944,AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'
fn-parse-json-945,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?'
fn-parse-json-946,Error: XPST0017: Function parse-json with arity of 2 not registered. Did you mean "parse-json (xs:string)"?
fn-parse-json-953,AssertionError: expected [Function] to throw error including 'FOJS0001' but got 'XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.'
K-ContextPositionFunc-3,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-4,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-5,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-6,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-7,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-8,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-9,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-10,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-11,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-12,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-13,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-14,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-15,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-16,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-17,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-18,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-19,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-20,Error: XPST0003: Unable to parse XPath: 1 eq (0, 1, current-time(), 4)[position() = 2] treat as xs:integer. SyntaxError: Expected " ", "!", "(", "(:", "*", "+", ",", "-", "/", "//", "=>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "except", "idiv", "instance", "intersect", "mod", "or", "to", "union", "|", "||", or end of input but "t" found.
K-ContextPositionFunc-21,Error: XPST0003: Unable to parse XPath: 1 eq (0, 1, current-time(), 4)[position() eq 2] treat as xs:integer. SyntaxError: Expected " ", "!", "(", "(:", "*", "+", ",", "-", "/", "//", "=>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "except", "idiv", "instance", "intersect", "mod", "or", "to", "union", "|", "||", or end of input but "t" found.
K-ContextPositionFunc-22,Error: XPST0003: Unable to parse XPath: 1 eq (0, 1, current-time(), 4)[2 eq position()] treat as xs:integer. SyntaxError: Expected " ", "!", "(", "(:", "*", "+", ",", "-", "/", "//", "=>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "except", "idiv", "instance", "intersect", "mod", "or", "to", "union", "|", "||", or end of input but "t" found.
K-ContextPositionFunc-23,Error: XPST0003: Unable to parse XPath: 1 eq (0, 1, current-time(), 4)[2 = position()] treat as xs:integer. SyntaxError: Expected " ", "!", "(", "(:", "*", "+", ",", "-", "/", "//", "=>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "except", "idiv", "instance", "intersect", "mod", "or", "to", "union", "|", "||", or end of input but "t" found.
K-ContextPositionFunc-24,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-25,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-26,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-27,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-28,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-29,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-30,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-31,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-32,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-33,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-34,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-35,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-36,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-37,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-38,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-39,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-40,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-41,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-42,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ContextPositionFunc-43,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
fn-prefix-from-qname-15,Error: XPST0017: Function fn:substring with arity of 2 not registered. Did you mean "xs:string (xs:anyAtomicType?)"?
ExpandedQNameConstructFunc001,Error: XPST0003: Unable to parse XPath: element {fn:QName("http://www.example.com/example", "person")}{ "test" }. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
ExpandedQNameConstructFunc002,Error: XPST0003: Unable to parse XPath: element {fn:QName("http://www.example.com/example", "ht:person")}{ "test" }. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
ExpandedQNameConstructFunc003,Error: XPST0003: Unable to parse XPath: element {fn:QName("", "person")}{ "test" }. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
ExpandedQNameConstructFunc004,Error: XPST0003: Unable to parse XPath: element {fn:QName((), "person")}{ "test" }. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
ExpandedQNameConstructFunc017,Error: XPST0003: Unable to parse XPath: element {fn:QName( "http://www.example.com/example", string((//FolderName)[2]) )}{ "test" }. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
ExpandedQNameConstructFunc018,Error: XPST0003: Unable to parse XPath: element {fn:QName( concat('http://www.example.com/', string((//FolderName)[2])), "people" )}{ "test" }. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
ExpandedQNameConstructFunc019,AssertionError: expected [Function] to throw error including 'FOCA0002' but got 'XPST0003: Unable to parse XPath: element {fn:QName( "http://www.example.com/example", "" )}{ "test" }. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
ExpandedQNameConstructFunc020,Error: XPST0003: Unable to parse XPath: declare namespace ht="http://www.example.com/example"; element {fn:QName( "http://www.example.com/another-example", "ht:person" )}{ "test" }. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
ExpandedQNameConstructFunc021,Error: XPST0003: Unable to parse XPath: declare namespace ht="http://www.example.com/example"; element {fn:QName( "http://www.example.com/example", "ht2:person" )}{ "test" }. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
fn-remove-mix-args-018,AssertionError: Expected XPath fn:remove( (xs:boolean("true"), xs:date("1993-03-31"), 4, "a"),3) to (deep equally) resolve to true(), xs:date('1993-03-31'), "a": expected false to be true
fn-remove-mix-args-019,AssertionError: Expected XPath fn:remove( (xs:dateTime("1972-12-31T00:00:00"), xs:boolean("false"), (), (" ")) ,3) to (deep equally) resolve to xs:dateTime("1972-12-31T00:00:00"), false(): expected false to be true
fn-remove-mix-args-020,AssertionError: Expected XPath fn:remove( (xs:time("12:30:00"), xs:decimal("2.000003"), 2), 2) to (deep equally) resolve to xs:time("12:30:00"), 2: expected false to be true
K-SeqRemoveFunc-13,AssertionError: Expected executing the XPath "remove(error(), 1)" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.', AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'.
K-SeqRemoveFunc-17,AssertionError: expected [Function] to throw an error
K-SeqRemoveFunc-18,AssertionError: expected [Function] to throw an error
K-SeqRemoveFunc-19,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-SeqRemoveFunc-20,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-SeqRemoveFunc-21,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-SeqRemoveFunc-22,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-SeqRemoveFunc-23,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-SeqRemoveFunc-24,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
fn-reverseintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-reverseintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-reverseintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-reverselng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-reverselng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-reverselng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-reversenint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-reversenint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-reversepint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-reversepint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-reverseulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-reverseulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-reversenpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-reversenpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-reversenni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-reversenni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-SeqReverseFunc-8,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-SeqReverseFunc-15,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'
K-SeqReverseFunc-20,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-SeqReverseFunc-21,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K2-SeqReverseFunc-2,Error: XPST0003: Unable to parse XPath: declare variable $myVar := unordered{ordered{unordered{fn:reverse((<a/>, <b/>))}}}; deep-equal($myVar, (<a/>, <b/>)) or deep-equal($myVar, (<b/>, <a/>)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-SeqReverseFunc-3,Error: XPST0003: Unable to parse XPath: declare variable $myVar := unordered(fn:reverse((<a/>, <b/>))); deep-equal($myVar, (<a/>, <b/>)) or deep-equal($myVar, (<b/>, <a/>)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-SeqReverseFunc-6,Error: XPST0003: Unable to parse XPath: deep-equal((declare ordering unordered; reverse((1, 2))), (2, 1)). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "to", "union", "|", or "||" but "o" found.
fn-root-1,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0017: Function fn:root with arity of 0 not registered. No similar functions found.'
fn-root-2,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function fn:root with arity of 0 not registered. No similar functions found.'
fn-root-3,AssertionError: Expected executing the XPath "fn:count(fn:root(()))" to resolve to one of the expected results, but got Error: XPST0017: Function fn:root with arity of 1 not registered. No similar functions found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0017: Function fn:root with arity of 1 not registered. No similar functions found.'.
fn-root-4,Error: XPST0017: Function fn:root with arity of 1 not registered. No similar functions found.
fn-root-5,Error: XPST0017: Function fn:root with arity of 1 not registered. No similar functions found.
fn-root-6,Error: XPST0017: Function fn:root with arity of 1 not registered. No similar functions found.
fn-root-7,Error: XPST0017: Function fn:root with arity of 1 not registered. No similar functions found.
fn-root-8,Error: XPST0017: Function fn:root with arity of 1 not registered. No similar functions found.
fn-root-9,Error: XPST0017: Function fn:root with arity of 1 not registered. No similar functions found.
fn-root-10,Error: XPST0003: Unable to parse XPath: let $var := element anElement {attribute anAttribute {"Attribute Value"}} return fn:root($var). SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "a" found.
fn-root-11,Error: XPST0003: Unable to parse XPath: fn:root(element anElement {attribute anAttribute {"Attribute Value"}}). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "a" found.
fn-root-12,Error: XPST0003: Unable to parse XPath: let $var := document {<anElement><anInternalElement>element content</anInternalElement></anElement>} return fn:root($var). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found.
fn-root-13,Error: XPST0003: Unable to parse XPath: fn:root(document {<anElement><anInternalElement>element content</anInternalElement></anElement>}). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
fn-root-14,Error: XPST0017: Function fn:root with arity of 1 not registered. No similar functions found.
fn-root-15,Error: XPST0017: Function fn:root with arity of 1 not registered. No similar functions found.
fn-root-16,Error: XPST0003: Unable to parse XPath: (fn:root(text {"A text Node"}))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
fn-root-17,Error: XPST0003: Unable to parse XPath: (let $var := text {"a text Node"} return fn:root($var))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found.
fn-root-18,Error: XPST0003: Unable to parse XPath: let $var := element anElement {"Element Content"} return fn:root($var) is fn:root($var). SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "a" found.
fn-root-19,Error: XPST0003: Unable to parse XPath: let $var := element anElement {"Element Content"} return fn:root($var) is fn:root($var). SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "a" found.
fn-root-20,Error: XPST0003: Unable to parse XPath: (let $var := element anElement {"Element Content"} return fn:count(fn:namespace-uri(fn:root($var)))) = (1). SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "a" found.
fn-root-21,Error: XPST0017: Function fn:root with arity of 1 not registered. No similar functions found.
fn-root-22,Error: XPST0017: Function fn:root with arity of 1 not registered. No similar functions found.
fn-root-23,Error: XPST0003: Unable to parse XPath: (let $var := text {"A text node"} return fn:count(fn:namespace-uri(fn:root($var)))) = (1). SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found.
fn-root-24,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0017: Function fn:root with arity of 1 not registered. No similar functions found.'
K-NodeRootFunc-2,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function root with arity of 0 not registered. No similar functions found.'
K-NodeRootFunc-3,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function root with arity of 1 not registered. No similar functions found.'
K-NodeRootFunc-4,AssertionError: Expected executing the XPath "empty(root(()))" to resolve to one of the expected results, but got Error: XPST0017: Function root with arity of 1 not registered. No similar functions found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0017: Function root with arity of 1 not registered. No similar functions found.'.
K2-NodeRootFunc-1,Error: XPST0017: Function fn:root with arity of 1 not registered. No similar functions found.
K2-NodeRootFunc-2,Error: XPST0017: Function fn:root with arity of 1 not registered. No similar functions found.
K2-NodeRootFunc-3,Error: XPST0017: Function fn:root with arity of 1 not registered. No similar functions found.
K2-NodeRootFunc-4,Error: XPST0003: Unable to parse XPath: <e>{fn:root(attribute name {"value"})}</e>. SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
K2-NodeRootFunc-5,Error: XPST0017: Function fn:root with arity of 1 not registered. No similar functions found.
K2-NodeRootFunc-6,Error: XPST0003: Unable to parse XPath: (fn:root(text{"text node"}))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "#", "(", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
K2-NodeRootFunc-7,Error: XPST0003: Unable to parse XPath: (fn:root(text{"text node"}))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "#", "(", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
K2-NodeRootFunc-8,Error: XPST0003: Unable to parse XPath: root(document {()}) instance of document-node(). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
fn-roundintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-roundintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-roundintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-roundlng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-roundlng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-roundlng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-roundnint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-roundnint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-roundpint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-roundpint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-roundulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-roundulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-roundnpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-roundnpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-roundnni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-roundnni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-RoundFunc-2,AssertionError: expected [Function] to throw an error
fn-round-1,Error: XPST0017: Function error with arity of 0 not registered. No similar functions found.
fn-round2args-4,AssertionError: Expected XPath fn:round(35.425, 2) to resolve to 35.43: expected false to be true
fn-round-half-to-evenintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-round-half-to-evenintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-round-half-to-evenintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-round-half-to-evenlng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-round-half-to-evenlng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-round-half-to-evenlng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-round-half-to-evennint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-round-half-to-evennint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-round-half-to-evenpint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-round-half-to-evenpint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-round-half-to-evenulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-round-half-to-evenulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-round-half-to-evennpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-round-half-to-evennpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-round-half-to-evennni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-round-half-to-evennni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-round-half-to-even-1,Error: XPST0017: Function error with arity of 0 not registered. No similar functions found.
fn-round-half-to-even-2,Error: XPST0017: Function error with arity of 0 not registered. No similar functions found.
fn-round-half-to-even-14,AssertionError: Expected XPath round-half-to-even(xs:float('0.05'), 1) to resolve to 0.1: expected false to be true
fn-round-half-to-even-15,AssertionError: Expected XPath round-half-to-even(xs:float('-0.05'), 1) to resolve to -0.1: expected false to be true
fn-starts-with-17,Error: FOCH0002: No collations are supported
fn-starts-with-18,Error: FOCH0002: No collations are supported
fn-starts-with-19,Error: FOCH0002: No collations are supported
fn-starts-with-20,Error: FOCH0002: No collations are supported
fn-starts-with-21,Error: FOCH0002: No collations are supported
fn-starts-with-22,Error: FOCH0002: No collations are supported
fn-starts-with-23,Error: FOCH0002: No collations are supported
fn-starts-with-24,Error: FOCH0002: No collations are supported
fn-starts-with-25,Error: FOCH0002: No collations are supported
fn-starts-with-26,Error: FOCH0002: No collations are supported
fn-starts-with-27,Error: FOCH0002: No collations are supported
fn-starts-with-28,Error: FOCH0002: No collations are supported
fn-starts-with-29,Error: FOCH0002: No collations are supported
fn-starts-with-30,Error: FOCH0002: No collations are supported
fn-starts-with-31,Error: FOCH0002: No collations are supported
K-StartsWithFunc-5,Error: FOCH0002: No collations are supported
K2-StartsWithFunc-1,Error: XPST0003: Unable to parse XPath: let $vA := ("B STRING", current-time(), string("content"))[1] treat as xs:string,          $vB := ("b string", current-time(), string("content"))[1] treat as xs:string         return starts-with(lower-case($vA), lower-case($vB)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found.
K2-StartsWithFunc-2,Error: XPST0003: Unable to parse XPath: let $vA := ("B STRING", current-time(), string("content"))[1] treat as xs:string,          $vB := ("b string", current-time(), string("content"))[1] treat as xs:string          return starts-with(upper-case($vA), upper-case($vB)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found.
K2-StartsWithFunc-3,Error: XPST0003: Unable to parse XPath: let $vA := ("B STRING", current-time(), string("content"))[1] treat as xs:string,          $vB := ("no match", current-time(), string("content"))[1] treat as xs:string         return starts-with(lower-case($vA), lower-case($vB)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found.
K2-StartsWithFunc-4,Error: XPST0003: Unable to parse XPath: let $vA := ("B STRING", current-time(), string("content"))[1] treat as xs:string,          $vB := ("no match", current-time(), string("content"))[1] treat as xs:string          return starts-with(upper-case($vA), upper-case($vB)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found.
K2-StartsWithFunc-5,Error: XPST0003: Unable to parse XPath: let $vA := ("B STRING", current-time(), string("content"))[1] treat as xs:string,          $vB := ("b string", current-time(), string("content"))[1] treat as xs:string          return starts-with(upper-case($vA), lower-case($vB)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found.
K2-StartsWithFunc-6,Error: XPST0003: Unable to parse XPath: let $vA := ("B STRING", current-time(), string("content"))[1] treat as xs:string,          $vB := ("b string", current-time(), string("content"))[1] treat as xs:string          return starts-with(lower-case($vA), upper-case($vB)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found.
cbcl-starts-with-001,Error: FOCH0002: No collations are supported
fn-stringintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-stringintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-stringintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-stringdec1args-1,AssertionError: fn:string(xs:decimal("-999999999999999999")): expected '-1000000000000000000' to equal '-999999999999999999'
fn-stringdec1args-2,AssertionError: fn:string(xs:decimal("617375191608514839")): expected '617375191608514800' to equal '617375191608514839'
fn-stringdec1args-3,AssertionError: fn:string(xs:decimal("999999999999999999")): expected '1000000000000000000' to equal '999999999999999999'
fn-stringlng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-stringlng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-stringlng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-stringnint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-stringnint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-stringpint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-stringpint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-stringulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-stringulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-stringnpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-stringnpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-stringnni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-stringnni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-string-4,Error: XPST0017: Function current-date with arity of 0 not registered. No similar functions found.
fn-string-5,AssertionError: Expected XPath string(xs:time("24:00:00")) to resolve to "00:00:00": expected false to be true
fn-string-6,Error: XPST0017: Function dateTime with arity of 2 not registered. Did you mean "xs:dateTime (xs:anyAtomicType?)"?
fn-string-22,AssertionError: Expected XPath /*/string() to resolve to "ns:barns:bar2ns:barDerivurn1test1test2": expected false to be true
fn-string-23,AssertionError: expected [Function] to throw an error
fn-string-32,AssertionError: expected [Function] to throw an error
fn-string-33,AssertionError: expected [Function] to throw an error
fn-string-34,AssertionError: expected [Function] to throw an error
fn-string-35,AssertionError: expected [Function] to throw an error
fn-string-36,AssertionError: expected [Function] to throw an error
fn-string-37,AssertionError: expected [Function] to throw an error
fn-string-38,AssertionError: expected [Function] to throw an error
K-StringFunc-5,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
fn-string-join-27,AssertionError: expected [Function] to throw an error
fn-string-join-29,Error: XPST0017: Function current-date with arity of 0 not registered. No similar functions found.
fn-string-join-31,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
K-StringJoinFunc-1,AssertionError: expected [Function] to throw an error
cbcl-fn-string-join-001,Error: XPST0003: Unable to parse XPath:          declare function local:repeat($count as xs:integer, $arg as xs:string) as xs:string* { if ($count le 0) then "" else for $x in 1 to $count return $arg };         string-join( for $x in 0 to 4 return local:repeat($x, 'a') , ' ') and string-join( for $x in 0 to 4 return local:repeat($x, 'a') , ''). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
fn-string-length-21,AssertionError: expected [Function] to throw error including 'FOTY0013' but got 'XPTY0004 Unable to convert to type'
fn-string-length-22,AssertionError: Expected XPath /*/string-length() to resolve to 38: expected false to be true
fn-string-length-23,AssertionError: expected [Function] to throw an error
fn-subsequence-mix-args-021,AssertionError: Expected XPath fn:subsequence ( ("a", xs:date("1993-03-31"), "b", "c"), 1,2) to (deep equally) resolve to "a", xs:date('1993-03-31'): expected false to be true
fn-subsequence-mix-args-023,AssertionError: Expected XPath fn:subsequence ( ("a", xs:time("12:30:00"), "b", "c"), 1, 2) to (deep equally) resolve to "a", xs:time('12:30:00'): expected false to be true
K-SeqSubsequenceFunc-30,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'
K-SeqSubsequenceFunc-31,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-SeqSubsequenceFunc-32,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-SeqSubsequenceFunc-33,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-SeqSubsequenceFunc-34,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-SeqSubsequenceFunc-35,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-SeqSubsequenceFunc-36,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-SeqSubsequenceFunc-37,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-SeqSubsequenceFunc-38,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-SeqSubsequenceFunc-39,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-SeqSubsequenceFunc-40,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-SeqSubsequenceFunc-41,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-SeqSubsequenceFunc-42,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-SeqSubsequenceFunc-43,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-SeqSubsequenceFunc-44,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K2-SeqSubsequenceFunc-1,Error: XPST0003: Unable to parse XPath: (let $start := (current-time(), 2)[2] treat as xs:integer,                 $len := (current-time(), 1)[2] treat as xs:integer                 return subsequence((1, 2, 3), $start, $len)) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "t" found.
cbcl-subsequence-006,Error: XPST0017: Function year-from-date with arity of 1 not registered. No similar functions found.
fn-sumintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumlng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumlng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumlng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumpint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumpint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumintg2args-1,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumintg2args-2,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumintg2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumintg2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumlng2args-1,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumlng2args-2,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumlng2args-3,Error: FOCA0003: can not cast -45058158165499290 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumlng2args-4,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnint2args-1,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnint2args-2,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnint2args-3,Error: FOCA0003: can not cast -702985924000903206 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnint2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumpint2args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumpint2args-3,Error: FOCA0003: can not cast 999999999999999998 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumpint2args-4,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumpint2args-5,Error: FOCA0003: can not cast 999999999999999998 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumulng2args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumulng2args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumulng2args-4,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumulng2args-5,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnpi2args-1,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnpi2args-2,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnpi2args-3,Error: FOCA0003: can not cast -524311562728129509 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnpi2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnni2args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnni2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnni2args-4,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnni2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumintg3args-1,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumintg3args-2,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumintg3args-3,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumintg3args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumflt3args-1,AssertionError: Expected executing the XPath "fn:sum((xs:float("0"),xs:float("-3.4028235E38"),xs:float("-3.4028235E38")))" to resolve to one of the expected results, but got AssertionError: fn:sum((xs:float("0"),xs:float("-3.4028235E38"),xs:float("-3.4028235E38"))): expected '-6.805647E38' to equal '-INF', AssertionError: expected [Function] to throw an error.
fn-sumlng3args-1,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumlng3args-2,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumlng3args-3,Error: FOCA0003: can not cast -45058158165499290 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumlng3args-4,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumlng3args-5,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumlng3args-6,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnint3args-1,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnint3args-2,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumpint3args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumpint3args-3,Error: FOCA0003: can not cast 999999999999999998 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumpint3args-4,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumpint3args-5,Error: FOCA0003: can not cast 999999999999999998 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumpint3args-6,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumpint3args-7,Error: FOCA0003: can not cast 999999999999999998 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumulng3args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumulng3args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumulng3args-4,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumulng3args-5,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumulng3args-6,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumulng3args-7,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnpi3args-1,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnpi3args-2,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnpi3args-3,Error: FOCA0003: can not cast -524311562728129509 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnpi3args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnpi3args-5,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnni3args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnni3args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnni3args-4,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnni3args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnni3args-6,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-sumnni3args-7,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-SeqSUMFunc-30,Error: FORG0006: items passed to fn:sum are not all numeric.
K-SeqSUMFunc-31,AssertionError: Expected XPath sum((xs:yearMonthDuration("P20Y"), xs:yearMonthDuration("P10M")) [. < xs:yearMonthDuration("P3M")], xs:yearMonthDuration("P0M")) eq xs:yearMonthDuration("P0M") to resolve to true: expected false to be true
K2-SeqSUMFunc-4,AssertionError: Expected XPath sum(xs:unsignedShort("1")) instance of xs:unsignedShort to resolve to true: expected false to be true
fn-sum-1,Error: FORG0006: items passed to fn:sum are not all numeric.
fn-sum-3,Error: FORG0006: items passed to fn:sum are not all numeric.
fn-sum-4,Error: FORG0006: items passed to fn:sum are not all numeric.
fn-sum-6,Error: FORG0006: items passed to fn:sum are not all numeric.
fn-sum-11,Error: FORG0006: items passed to fn:sum are not all numeric.
fn-sum-12,Error: XPST0017: Function year-from-date with arity of 1 not registered. No similar functions found.
fn-sum-13,Error: XPST0017: Function year-from-date with arity of 1 not registered. No similar functions found.
fn-sum-14,Error: XPST0017: Function year-from-date with arity of 1 not registered. No similar functions found.
tail-006,Error: XPST0003: Unable to parse XPath: (declare function local:sum($n) { if (empty($n)) then 0 else head($n) + local:sum(tail($n)) };              local:sum(1 to 5)) = (15). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
fn-unordered-mix-args-001,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-002,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-003,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-004,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-005,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-006,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-007,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-008,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-009,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-010,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-011,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-012,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-013,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-014,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-015,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-016,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-017,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-018,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-019,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-020,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-021,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-022,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-mix-args-023,AssertionError: Skipped test, it was a assert-permutation
K-SeqUnorderedFunc-5,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-SeqUnorderedFunc-8,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'
fn-unordered-102,Error: XPST0003: Unable to parse XPath: (count(/works/employee[last()]/unordered(preceding::*))) = (54). SyntaxError: Expected [A-Z_a-z----------] or [-] but ":" found.
fn-unordered-108,AssertionError: Skipped test, it was a assert-permutation
fn-unordered-109,AssertionError: Skipped test, it was a assert-permutation
fn-upper-case-18,Error: XPST0017: Function fn:string-to-codepoints with arity of 1 not registered. No similar functions found.
fn-upper-case-19,Error: XPST0017: Function fn:string-to-codepoints with arity of 1 not registered. No similar functions found.
fn-upper-case-20,Error: XPST0017: Function fn:string-to-codepoints with arity of 1 not registered. No similar functions found.
fn-upper-case-21,Error: XPST0017: Function fn:string-to-codepoints with arity of 1 not registered. No similar functions found.
fn-upper-case-22,Error: XPST0017: Function fn:string-to-codepoints with arity of 1 not registered. No similar functions found.
fn-zero-or-oneintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-zero-or-oneintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
fn-zero-or-oneintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-zero-or-onedec1args-1,AssertionError: fn:zero-or-one(xs:decimal("-999999999999999999")): expected '-1000000000000000000' to equal '-999999999999999999'
fn-zero-or-onedec1args-2,AssertionError: fn:zero-or-one(xs:decimal("617375191608514839")): expected '617375191608514800' to equal '617375191608514839'
fn-zero-or-onedec1args-3,AssertionError: fn:zero-or-one(xs:decimal("999999999999999999")): expected '1000000000000000000' to equal '999999999999999999'
fn-zero-or-onelng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-zero-or-onelng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
fn-zero-or-onelng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
fn-zero-or-onenint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-zero-or-onenint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
fn-zero-or-onepint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
fn-zero-or-onepint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-zero-or-oneulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
fn-zero-or-oneulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
fn-zero-or-onenpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
fn-zero-or-onenpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
fn-zero-or-onenni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
fn-zero-or-onenni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-SeqZeroOrOneFunc-7,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'
cbcl-zero-or-one-001,Error: XPST0003: Unable to parse XPath:          declare function local:generate($arg as xs:integer?) { if ($arg = 0) then (1, 2, 3) else $arg };         fn:empty( fn:zero-or-one(fn:unordered( local:generate( () ) )) ). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-zero-or-one-002,Error: XPST0003: Unable to parse XPath: (         declare function local:generate($arg as xs:integer?) { if ($arg = 0) then () else if ($arg = 1) then $arg else ($arg, $arg) };         1 + fn:zero-or-one(fn:one-or-more( local:generate( 1 ) )))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
math-exp-004,AssertionError: Expected XPath math:exp(2) to resolve to 7.38905609893065e0: expected false to be true
math-exp-006,AssertionError: Expected XPath math:exp(math:pi()) to resolve to 23.140692632779267e0: expected false to be true
math-pi-005,Error: XPST0017: Function function-lookup with arity of 2 not registered. No similar functions found.
map-contains-017,AssertionError: Expected XPath map:contains(map{1:"Sunday",2:"Monday",3:"Tuesday",xs:duration('P1Y'):"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, xs:yearMonthDuration('P12M')) to resolve to true: expected false to be true
map-contains-018,Error: XPST0017: Function function-name with arity of 1 not registered. No similar functions found.
map-get-017,AssertionError: map:get(map{1:"Sunday",2:"Monday",3:"Tuesday",xs:duration('P1Y'):"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, xs:yearMonthDuration('P12M')): expected '' to equal 'Wednesday'
map-get-018,Error: XPST0017: Function function-name with arity of 1 not registered. No similar functions found.
map-get-023,Error: XPST0017: Function current-dateTime with arity of 0 not registered. No similar functions found.
map-get-024,Error: XPST0017: Function current-date with arity of 0 not registered. No similar functions found.
map-get-100,Error: XPST0017: Function fn:for-each with arity of 2 not registered. Did you mean "map:for-each (map(*), function(*))" or "array:for-each (array(*), function(*))"?
map-entry-001-hof,Error: No selector counterpart for: typedMapTest.
map-entry-001,Error: No selector counterpart for: typedMapTest.
map-entry-002,Error: No selector counterpart for: typedMapTest.
map-entry-003,Error: No selector counterpart for: typedMapTest.
map-entry-004,Error: No selector counterpart for: typedMapTest.
map-entry-005,Error: No selector counterpart for: lookup.
map-entry-006,Error: No selector counterpart for: lookup.
map-entry-007-hof,Error: No selector counterpart for: typedMapTest.
map-entry-007,Error: No selector counterpart for: typedMapTest.
map-size-007,AssertionError: expected [Function] to throw an error
map-size-014,Error: XPST0017: Function current-dateTime with arity of 0 not registered. No similar functions found.
map-keys-007,AssertionError: expected [Function] to throw an error
map-remove-008,Error: No selector counterpart for: typedMapTest.
map-remove-009,Error: No selector counterpart for: typedMapTest.
map-remove-010,Error: No selector counterpart for: typedMapTest.
map-remove-011,Error: No selector counterpart for: typedMapTest.
map-remove-014,Error: XPST0017: Function current-dateTime with arity of 0 not registered. No similar functions found.
map-remove-016,AssertionError: Expected XPath              map{xs:float('1.0'):0, xs:double('1.00000000001'):1}              => map:remove(xs:decimal('1.0000000000100000000001'))              => map:size()          to resolve to 2: expected false to be true
base64-102,AssertionError: xs:hexBinary(xs:base64Binary("AA==")): expected '0' to equal '00'
base64-103,AssertionError: xs:hexBinary(xs:base64Binary("AQ==")): expected '1' to equal '01'
base64-105,AssertionError: xs:hexBinary(xs:base64Binary("AAA=")): expected '00' to equal '0000'
base64-106,AssertionError: xs:hexBinary(xs:base64Binary("AP8=")): expected '0FF' to equal '00FF'
base64-109,AssertionError: xs:hexBinary(xs:base64Binary("AQID")): expected '123' to equal '010203'
base64-110,AssertionError: xs:hexBinary(xs:base64Binary("AQIDBA==")): expected '1234' to equal '01020304'
base64-111,AssertionError: xs:hexBinary(xs:base64Binary("AQIDBAU=")): expected '12345' to equal '0102030405'
base64-112,AssertionError: xs:hexBinary(xs:base64Binary("AQIDBAUG")): expected '123456' to equal '010203040506'
base64-113,AssertionError: xs:hexBinary(xs:base64Binary("AQIDBAUGBw==")): expected '1234567' to equal '01020304050607'
base64-114,AssertionError: xs:hexBinary(xs:base64Binary("AQIDBAUGBwgJCgsMDQ4PEBESExMUFRYXGBkaGxwdHyAhIiMkJSYnKCkqKywtLi8=")): expected '123456789ABCDEF10111213131415161718191A1B1C1D1F202122232425262728292A2B2C2D2E2F' to equal '0102030405060708090A0B0C0D0E0F10111213131415161718191A1B1C1D1F202122232425262728292A2B2C2D2E2F'
base64-115,AssertionError: xs:hexBinary(xs:base64Binary(" AQIDBAUG BwgJCgsM DQ4PEBES ExMUFRYX   GBkaGxwdH yAhIiMkJ SYnKCkqK y w t L i 8 = ")): expected '123456789ABCDEF10111213131415161718191A1B1C1D1F202122232425262728292A2B2C2D2E2F' to equal '0102030405060708090A0B0C0D0E0F10111213131415161718191A1B1C1D1F202122232425262728292A2B2C2D2E2F'
base64-908,AssertionError: expected [Function] to throw error including 'FORG0001' but got 'XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.'
base64-909,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
xs-dateTimeStamp-1,Error: XPST0017: Function fn:timezone-from-dateTime with arity of 1 not registered. No similar functions found.
xs-dateTimeStamp-2,Error: XPST0017: Function fn:timezone-from-dateTime with arity of 1 not registered. No similar functions found.
xs-double-004,AssertionError: expected [Function] to throw an error
xs-error-006,Error: No selector counterpart for: functionTest.
xs-error-007,Error: No selector counterpart for: functionTest.
xs-error-015,Error: No selector counterpart for: functionTest.
xs-error-016,Error: No selector counterpart for: functionTest.
xs-error-017,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0003: Unable to parse XPath: declare function local:identity($arg as xs:error)\n            {\n              $arg\n            };\n       local:identity(fn:error())\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
xs-error-018,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare function local:identity($arg as xs:error)\n            {\n              $arg\n            };\n       local:identity(1)\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
xs-error-019,AssertionError: Expected executing the XPath "declare function local:constant($arg as xs:error)             {               fn:true()             };        local:constant(fn:error())       " to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: declare function local:constant($arg as xs:error)             {               fn:true()             };        local:constant(fn:error())       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare function local:constant($arg as xs:error)\n            {\n              fn:true()\n            };\n       local:constant(fn:error())\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.', AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0003: Unable to parse XPath: declare function local:constant($arg as xs:error)\n            {\n              fn:true()\n            };\n       local:constant(fn:error())\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
xs-error-020,Error: XPST0003: Unable to parse XPath: (declare function local:identity($arg as xs:error?)             {               $arg             };        local:identity(())       ) => empty(). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
xs-error-021,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0003: Unable to parse XPath: declare function local:error() as xs:error\n            {\n               fn:error()\n            };\n       local:error()\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
xs-error-022,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare function local:error() as xs:error\n            {\n\t      1\n            };\n       local:error()\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
xs-error-023,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0003: Unable to parse XPath: let $x as xs:error := fn:error() return $x. SyntaxError: Expected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.'
xs-error-024,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function fn:error with arity of 0 not registered. Did you mean "xs:error (xs:anyAtomicType?)"?'
xs-error-025,AssertionError: Expected executing the XPath "let $x as xs:error := fn:error() return fn:true()" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: let $x as xs:error := fn:error() return fn:true(). SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found., AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0003: Unable to parse XPath: let $x as xs:error := fn:error() return fn:true(). SyntaxError: Expected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.'.
xs-error-026,AssertionError: Expected executing the XPath "let $x := fn:error() return true()" to resolve to one of the expected results, but got Error: XPST0017: Function fn:error with arity of 0 not registered. Did you mean "xs:error (xs:anyAtomicType?)"?, AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function fn:error with arity of 0 not registered. Did you mean "xs:error (xs:anyAtomicType?)"?'.
xs-error-027,AssertionError: Expected executing the XPath "let $x as xs:error := 1 return fn:true()" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: let $x as xs:error := 1 return fn:true(). SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: let $x as xs:error := 1 return fn:true(). SyntaxError: Expected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.'.
xs-error-028,Error: XPST0003: Unable to parse XPath: (for $x as xs:error in () return fn:true()) => empty(). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
xs-error-029,AssertionError: Expected executing the XPath "for $x as xs:error in fn:error() return fn:true()" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: for $x as xs:error in fn:error() return fn:true(). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found., AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0003: Unable to parse XPath: for $x as xs:error in fn:error() return fn:true(). SyntaxError: Expected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.'.
xs-error-030,AssertionError: Expected executing the XPath "for $x in fn:error() return fn:true()" to resolve to one of the expected results, but got Error: XPST0017: Function fn:error with arity of 0 not registered. Did you mean "xs:error (xs:anyAtomicType?)"?, AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function fn:error with arity of 0 not registered. Did you mean "xs:error (xs:anyAtomicType?)"?'.
xs-error-031,AssertionError: Expected executing the XPath "for $x as xs:error in (1, 2, 3) return $x" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: for $x as xs:error in (1, 2, 3) return $x. SyntaxError: Expected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.'.
xs-error-036,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function fn:error with arity of 0 not registered. Did you mean "xs:error (xs:anyAtomicType?)"?'
xs-error-044,AssertionError: Expected executing the XPath "fn:error() instance of xs:error" to resolve to one of the expected results, but got Error: XPST0017: Function fn:error with arity of 0 not registered. Did you mean "xs:error (xs:anyAtomicType?)"?, AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function fn:error with arity of 0 not registered. Did you mean "xs:error (xs:anyAtomicType?)"?'.
xs-error-045,AssertionError: Expected executing the XPath "typeswitch (xs:error(1))              case xs:error return fn:true()             default return false()" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: typeswitch (xs:error(1))              case xs:error return fn:true()             default return false(). SyntaxError: Expected "!", "!=", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "(" found., AssertionError: expected [Function] to throw error including 'FORG0001' but got 'XPST0003: Unable to parse XPath: typeswitch (xs:error(1)) \n            case xs:error return fn:true()\n            default return false(). SyntaxError: Expected "!", "!=", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "(" found.'.
xs-error-046,AssertionError: Expected executing the XPath "typeswitch (fn:error())              case xs:error return fn:true()             default return false()" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: typeswitch (fn:error())              case xs:error return fn:true()             default return false(). SyntaxError: Expected "!", "!=", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "(" found., AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0003: Unable to parse XPath: typeswitch (fn:error()) \n            case xs:error return fn:true()\n            default return false(). SyntaxError: Expected "!", "!=", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "(" found.'.
xs-error-047,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0003: Unable to parse XPath: fn:error() treat as xs:error. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "t" found.'
xs-error-048,AssertionError: expected [Function] to throw error including 'XPDY0050' but got 'XPST0003: Unable to parse XPath: 1 treat as xs:error. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "t" found.'
xs-error-049,Error: XPST0003: Unable to parse XPath: (() treat as xs:error?) => empty(). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.
xs-float-004,AssertionError: expected [Function] to throw an error
cbcl-base64Binary-equal-001,Error: XPST0003: Unable to parse XPath:        declare function local:base64Binary-value($arg as xs:boolean) as xs:base64Binary {        	if ($arg) then xs:base64Binary('aGVsbG8=') else xs:base64Binary('Z29vZGJ5ZQ==')        };        local:base64Binary-value(true()) eq local:base64Binary-value(false()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-base64Binary-equal-002,Error: XPST0003: Unable to parse XPath:        	declare function local:base64Binary-value($arg as xs:boolean) as xs:base64Binary {        		if ($arg) then xs:base64Binary('aGVsbG8=') else xs:base64Binary('Z29vZGJ5ZQ==')        	};        	not(local:base64Binary-value(true()) eq local:base64Binary-value(false())). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-base64Binary-equal-003,Error: XPST0003: Unable to parse XPath:        	declare function local:base64Binary-value($arg as xs:boolean) as xs:base64Binary {        		if ($arg) then xs:base64Binary('aGVsbG8=') else xs:base64Binary('Z29vZGJ5ZQ==')        	};        	not(local:base64Binary-value(true()) ne local:base64Binary-value(false())). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
K2-BooleanEqual-1,AssertionError: expected [Function] to throw an error
K2-BooleanEqual-2,AssertionError: expected [Function] to throw an error
K2-BooleanEqual-3,AssertionError: expected [Function] to throw an error
cbcl-boolean-equal-001,Error: XPST0003: Unable to parse XPath:        declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        fn:false() eq local:is-even(17). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-boolean-equal-002,Error: XPST0003: Unable to parse XPath:        declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        not(local:is-even(13) eq local:is-even(17)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-boolean-equal-003,Error: XPST0003: Unable to parse XPath:        declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        fn:true() ne local:is-even(17). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-boolean-equal-004,Error: XPST0003: Unable to parse XPath:        declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        local:is-even(17) ne fn:true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-boolean-equal-005,Error: XPST0003: Unable to parse XPath:        declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        local:is-even(17) ne fn:false(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-boolean-equal-006,Error: XPST0003: Unable to parse XPath:        declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        not(not(local:is-even(17) eq local:is-even(16))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-boolean-greater-than-001,Error: XPST0003: Unable to parse XPath:        declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        not(local:is-even(15) ge local:is-even(17)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-boolean-greater-than-002,Error: XPST0003: Unable to parse XPath:        declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        fn:true() ge local:is-even(17). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-boolean-greater-than-003,Error: XPST0003: Unable to parse XPath:        declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        fn:false() ge local:is-even(17). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-boolean-greater-than-004,Error: XPST0003: Unable to parse XPath:        declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        not(local:is-even(15) gt local:is-even(17)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-boolean-greater-than-005,Error: XPST0003: Unable to parse XPath:        declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        fn:true() gt local:is-even(17). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-boolean-greater-than-006,Error: XPST0003: Unable to parse XPath:        declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        fn:false() gt local:is-even(17). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-boolean-greater-than-007,Error: XPST0003: Unable to parse XPath:        declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        local:is-even(17) ge fn:true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-boolean-greater-than-008,Error: XPST0003: Unable to parse XPath:        declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        local:is-even(17) ge fn:false(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-boolean-greater-than-009,Error: XPST0003: Unable to parse XPath: declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        local:is-even(17) gt fn:true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-boolean-greater-than-010,Error: XPST0003: Unable to parse XPath:        declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        local:is-even(17) gt fn:false(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-boolean-less-than-001,Error: XPST0003: Unable to parse XPath: declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        not(local:is-even(15) le local:is-even(17)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-boolean-less-than-002,Error: XPST0003: Unable to parse XPath: declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        fn:true() le local:is-even(17). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-boolean-less-than-003,Error: XPST0003: Unable to parse XPath: declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        fn:false() le local:is-even(17). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-boolean-less-than-004,Error: XPST0003: Unable to parse XPath: declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        not(local:is-even(15) lt local:is-even(17)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-boolean-less-than-005,Error: XPST0003: Unable to parse XPath: declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        fn:true() lt local:is-even(17). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-boolean-less-than-006,Error: XPST0003: Unable to parse XPath: declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        fn:false() lt local:is-even(17). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-boolean-less-than-007,Error: XPST0003: Unable to parse XPath: declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        local:is-even(17) le fn:true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-boolean-less-than-008,Error: XPST0003: Unable to parse XPath: declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        local:is-even(17) le fn:false(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-boolean-less-than-009,Error: XPST0003: Unable to parse XPath: declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        local:is-even(17) lt fn:true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-boolean-less-than-010,Error: XPST0003: Unable to parse XPath: declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        local:is-even(17) lt fn:false(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
op-concatintg2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatintg2args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatintg2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatintg2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatintg2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatdec2args-1,AssertionError: (xs:decimal("-999999999999999999")||xs:decimal("-999999999999999999")): expected '-1000000000000000000-1000000000000000000' to equal '-999999999999999999-999999999999999999'
op-concatdec2args-2,AssertionError: (xs:decimal("617375191608514839")||xs:decimal("-999999999999999999")): expected '617375191608514800-1000000000000000000' to equal '617375191608514839-999999999999999999'
op-concatdec2args-3,AssertionError: (xs:decimal("999999999999999999")||xs:decimal("-999999999999999999")): expected '1000000000000000000-1000000000000000000' to equal '999999999999999999-999999999999999999'
op-concatdec2args-4,AssertionError: (xs:decimal("-999999999999999999")||xs:decimal("617375191608514839")): expected '-1000000000000000000617375191608514800' to equal '-999999999999999999617375191608514839'
op-concatdec2args-5,AssertionError: (xs:decimal("-999999999999999999")||xs:decimal("999999999999999999")): expected '-10000000000000000001000000000000000000' to equal '-999999999999999999999999999999999999'
op-concatlng2args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatlng2args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatlng2args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatlng2args-4,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatlng2args-5,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatnint2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatnint2args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatnint2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatnint2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatnint2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatpint2args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatpint2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatpint2args-4,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatpint2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatulng2args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatulng2args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatulng2args-4,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatulng2args-5,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatnpi2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatnpi2args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatnpi2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatnpi2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatnpi2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatnni2args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatnni2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatnni2args-4,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-concatnni2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-date-equal2args-1,AssertionError: Expected XPath xs:date("1970-01-01Z") eq xs:date("1970-01-01Z") to resolve to true: expected false to be true
op-date-equal2args-6,AssertionError: Expected XPath xs:date("1970-01-01Z") ne xs:date("1970-01-01Z") to resolve to false: expected true to be false
K-DateEQ-1,AssertionError: Expected XPath xs:date("2004-08-12") eq xs:date("2004-08-12") to resolve to true: expected false to be true
K-DateEQ-4,AssertionError: Expected XPath not(xs:date("2004-07-12") ne xs:date("2004-07-12")) to resolve to true: expected false to be true
K-DateEQ-5,AssertionError: Expected XPath xs:date("1999-12-04-00:00") eq xs:date("1999-12-04Z") to resolve to true: expected false to be true
K-DateEQ-6,AssertionError: Expected XPath xs:date("1999-12-04+00:00") eq xs:date("1999-12-04Z") to resolve to true: expected false to be true
K-DateEQ-7,AssertionError: Expected XPath xs:date("1999-12-04Z") eq xs:date("1999-12-04Z") to resolve to true: expected false to be true
K-DateEQ-8,AssertionError: Expected XPath xs:date("1999-12-04-00:00") eq xs:date("1999-12-04+00:00") to resolve to true: expected false to be true
cbcl-date-equal-001,Error: XPST0003: Unable to parse XPath: declare function local:two-digit($number as xs:integer) { let $string := string($number) return if (string-length($string) lt 2) then concat('0', $string) else $string }; declare function local:date($year as xs:integer, $month as xs:integer, $day as xs:integer) { let $m := local:two-digit($month), $d := local:two-digit($day) return xs:date(concat($year, '-', $m, '-', $d)) }; not(local:date(2008, 05, 12) eq xs:date("1972-12-15")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-date-equal-006,Error: XPST0003: Unable to parse XPath: declare function local:two-digit($number as xs:integer) { let $string := string($number) return if (string-length($string) lt 2) then concat('0', $string) else $string }; declare function local:date($year as xs:integer, $month as xs:integer, $day as xs:integer) { let $m := local:two-digit($month), $d := local:two-digit($day) return xs:date(concat($year, '-', $m, '-', $d)) }; not(local:date(2008, 05, 12) ne xs:date("1972-12-15")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-date-equal-011,Error: XPST0003: Unable to parse XPath: declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date }; exists(local:date(xs:date("1972-12-15"), fn:true()) eq xs:date("1972-12-15")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-date-equal-012,Error: XPST0003: Unable to parse XPath: declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date }; local:date(xs:date("1972-12-15"), fn:false()) eq xs:date("1972-12-15"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-date-equal-013,Error: XPST0003: Unable to parse XPath: declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date }; exists(local:date(xs:date("1972-12-15"), fn:true()) ne xs:date("1972-12-15")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-date-equal-014,Error: XPST0003: Unable to parse XPath: declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date }; local:date(xs:date("1972-12-15"), fn:false()) ne xs:date("1972-12-15"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-date-equal-015,Error: XPST0003: Unable to parse XPath: declare function local:date($date as xs:string, $timezone as xs:string) { xs:date( concat($date, $timezone) ) }; adjust-date-to-timezone(local:date("1972-12-14", "-12:00")) eq adjust-date-to-timezone(xs:date("1972-12-15+12:00")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-date-equal-016,Error: XPST0003: Unable to parse XPath: declare function local:date($date as xs:string, $timezone as xs:string) { xs:date( concat($date, $timezone) ) }; adjust-date-to-timezone(local:date("1972-12-14", "-12:00")) ne adjust-date-to-timezone(xs:date("1972-12-15+12:00")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-date-greater-equal-001,Error: XPST0003: Unable to parse XPath:        	declare function local:two-digit($number as xs:integer) { let $string := string($number) return if (string-length($string) lt 2) then concat('0', $string) else $string }; declare function local:date($year as xs:integer, $month as xs:integer, $day as xs:integer) { let $m := local:two-digit($month), $d := local:two-digit($day) return xs:date(concat($year, '-', $m, '-', $d)) };        	not(local:date(2008, 05, 12) lt xs:date("1972-12-15"))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-date-greater-equal-004,AssertionError: Expected XPath xs:date("2008-01-31") lt xs:date("2008-01-31+09:00") to resolve to false: expected true to be false
cbcl-date-greater-equal-005,AssertionError: Expected XPath xs:date("2008-01-31+09:00") lt xs:date("2008-01-31") to resolve to true: expected false to be true
cbcl-date-greater-equal-006,Error: XPST0003: Unable to parse XPath:        	declare function local:two-digit($number as xs:integer) { let $string := string($number) return if (string-length($string) lt 2) then concat('0', $string) else $string };        	declare function local:date($year as xs:integer, $month as xs:integer, $day as xs:integer) { let $m := local:two-digit($month), $d := local:two-digit($day) return xs:date(concat($year, '-', $m, '-', $d)) };        	not(local:date(2008, 05, 12) ge xs:date("1972-12-15"))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-date-greater-equal-009,AssertionError: Expected XPath xs:date("2008-01-31") ge xs:date("2008-01-31+09:00") to resolve to true: expected false to be true
cbcl-date-greater-equal-010,AssertionError: Expected XPath xs:date("2008-01-31+09:00") ge xs:date("2008-01-31") to resolve to false: expected true to be false
cbcl-date-greater-than-011,Error: XPST0003: Unable to parse XPath:        	declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date };        	exists(local:date(xs:date("1972-12-15"), fn:true()) gt xs:date("1972-12-15"))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-date-greater-than-012,Error: XPST0003: Unable to parse XPath:        	declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date };        	local:date(xs:date("1972-12-15"), fn:false()) gt xs:date("1972-12-15")       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-date-greater-than-013,Error: XPST0003: Unable to parse XPath:        	declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date };        	exists(local:date(xs:date("1972-12-15"), fn:true()) le xs:date("1972-12-15"))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-date-greater-than-014,Error: XPST0003: Unable to parse XPath:        	declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date };        	local:date(xs:date("1972-12-15"), fn:false()) le xs:date("1972-12-15")       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-date-greater-than-015,Error: XPST0003: Unable to parse XPath:        	declare function local:date($date as xs:string, $timezone as xs:string) { xs:date( concat($date, $timezone) ) };        	adjust-date-to-timezone(local:date("1972-12-14", "-12:00")) gt adjust-date-to-timezone(xs:date("1972-12-15+12:00"))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-date-greater-than-016,Error: XPST0003: Unable to parse XPath:        	declare function local:date($date as xs:string, $timezone as xs:string) { xs:date( concat($date, $timezone) ) };        	adjust-date-to-timezone(local:date("1972-12-14", "-12:00")) ge adjust-date-to-timezone(xs:date("1972-12-15+12:00"))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
op-date-less-than-1,AssertionError: Expected XPath (xs:date("2004-12-25Z") lt xs:date("2004-12-25-05:00")) to resolve to true: expected false to be true
cbcl-date-less-than-001,Error: XPST0003: Unable to parse XPath:        	declare function local:two-digit($number as xs:integer) {        		let $string := string($number) return if (string-length($string) lt 2) then concat('0', $string) else $string        	};        	declare function local:date($year as xs:integer, $month as xs:integer, $day as xs:integer) {        		let $m := local:two-digit($month), $d := local:two-digit($day) return xs:date(concat($year, '-', $m, '-', $d))        	};        	not(local:date(2008, 05, 12) lt xs:date("1972-12-15"))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-date-less-than-004,AssertionError: Expected XPath xs:date("2008-01-31") lt xs:date("2008-01-31+09:00") to resolve to false: expected true to be false
cbcl-date-less-than-005,AssertionError: Expected XPath xs:date("2008-01-31+09:00") lt xs:date("2008-01-31") to resolve to true: expected false to be true
cbcl-date-less-than-006,Error: XPST0003: Unable to parse XPath:        	declare function local:two-digit($number as xs:integer) { let $string := string($number) return if (string-length($string) lt 2) then concat('0', $string) else $string };        	declare function local:date($year as xs:integer, $month as xs:integer, $day as xs:integer) { let $m := local:two-digit($month), $d := local:two-digit($day) return xs:date(concat($year, '-', $m, '-', $d)) };        	not(local:date(2008, 05, 12) le xs:date("1972-12-15"))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-date-less-than-009,AssertionError: Expected XPath xs:date("2008-01-31") le xs:date("2008-01-31+09:00") to resolve to false: expected true to be false
cbcl-date-less-than-010,AssertionError: Expected XPath xs:date("2008-01-31+09:00") le xs:date("2008-01-31") to resolve to true: expected false to be true
cbcl-date-less-than-011,Error: XPST0003: Unable to parse XPath:        	declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date };        	exists(local:date(xs:date("1972-12-15"), fn:true()) lt xs:date("1972-12-15"))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-date-less-than-012,Error: XPST0003: Unable to parse XPath:        	declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date };        	local:date(xs:date("1972-12-15"), fn:false()) lt xs:date("1972-12-15")       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-date-less-than-013,Error: XPST0003: Unable to parse XPath:        	declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date };        	exists(local:date(xs:date("1972-12-15"), fn:true()) ge xs:date("1972-12-15"))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-date-less-than-014,Error: XPST0003: Unable to parse XPath:        	declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date };        	local:date(xs:date("1972-12-15"), fn:false()) ge xs:date("1972-12-15")       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-date-less-than-015,Error: XPST0003: Unable to parse XPath:        	declare function local:date($date as xs:string, $timezone as xs:string) { xs:date( concat($date, $timezone) ) };        	adjust-date-to-timezone(local:date("1972-12-14", "-12:00")) lt adjust-date-to-timezone(xs:date("1972-12-15+12:00"))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-date-less-than-016,Error: XPST0003: Unable to parse XPath:        	declare function local:date($date as xs:string, $timezone as xs:string) { xs:date( concat($date, $timezone) ) };        	adjust-date-to-timezone(local:date("1972-12-14", "-12:00")) le adjust-date-to-timezone(xs:date("1972-12-15+12:00"))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
op-dateTime-equal2args-1,AssertionError: Expected XPath xs:dateTime("1970-01-01T00:00:00Z") eq xs:dateTime("1970-01-01T00:00:00Z") to resolve to true: expected false to be true
op-dateTime-equal2args-6,AssertionError: Expected XPath xs:dateTime("1970-01-01T00:00:00Z") ne xs:dateTime("1970-01-01T00:00:00Z") to resolve to false: expected true to be false
K-DateTimeEQ-1,AssertionError: Expected XPath xs:dateTime("2004-08-12T23:01:04.12") eq xs:dateTime("2004-08-12T23:01:04.12") to resolve to true: expected false to be true
K-DateTimeEQ-4,AssertionError: Expected XPath not(xs:dateTime("2004-07-12T23:01:04.12") ne xs:dateTime("2004-07-12T23:01:04.12")) to resolve to true: expected false to be true
K-DateTimeEQ-5,AssertionError: Expected XPath xs:dateTime("1999-12-04T16:00:12.345-00:00") eq xs:dateTime("1999-12-04T16:00:12.345Z") to resolve to true: expected false to be true
K-DateTimeEQ-6,AssertionError: Expected XPath xs:dateTime("1999-12-04T16:00:12.345+00:00") eq xs:dateTime("1999-12-04T16:00:12.345Z") to resolve to true: expected false to be true
K-DateTimeEQ-7,AssertionError: Expected XPath xs:dateTime("1999-12-04T16:00:12.345Z") eq xs:dateTime("1999-12-04T16:00:12.345Z") to resolve to true: expected false to be true
K-DateTimeEQ-8,AssertionError: Expected XPath xs:dateTime("1999-12-04T16:00:12.345-00:00") eq xs:dateTime("1999-12-04T16:00:12.345+00:00") to resolve to true: expected false to be true
cbcl-dateTime-equal-001,Error: XPST0003: Unable to parse XPath:        	declare function local:two-digit($number as xs:integer) {        		let $string := string($number)        		return if (string-length($string) lt 2) then concat('0', $string) else $string        	};        	declare function local:dateTime($year as xs:integer, $month as xs:integer, $day as xs:integer) {        		let $m := local:two-digit($month), $d := local:two-digit($day)        		return xs:dateTime(concat($year, '-', $m, '-', $d, "T12:00:00"))        	};        	not(local:dateTime(2008, 05, 12) eq xs:dateTime("1972-12-15T12:00:00")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-dateTime-equal-006,Error: XPST0003: Unable to parse XPath:        	declare function local:two-digit($number as xs:integer) {        		let $string := string($number)        		return if (string-length($string) lt 2) then concat('0', $string) else $string        	};        	declare function local:dateTime($year as xs:integer, $month as xs:integer, $day as xs:integer) {        		let $m := local:two-digit($month), $d := local:two-digit($day)        		return xs:dateTime(concat($year, '-', $m, '-', $d, "T12:00:00"))        	};        	not(local:dateTime(2008, 05, 12) ne xs:dateTime("1972-12-15T12:00:00")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-dateTime-equal-011,Error: XPST0003: Unable to parse XPath: declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; exists(local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:true()) eq xs:dateTime("1972-12-15T12:00:00")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-dateTime-equal-012,Error: XPST0003: Unable to parse XPath: declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:false()) eq xs:dateTime("1972-12-15T12:00:00"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-dateTime-equal-013,Error: XPST0003: Unable to parse XPath: declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; exists(local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:true()) ne xs:dateTime("1972-12-15T12:00:00")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-dateTime-equal-014,Error: XPST0003: Unable to parse XPath: declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:false()) ne xs:dateTime("1972-12-15T12:00:00"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-dateTime-equal-015,Error: XPST0003: Unable to parse XPath:        	declare function local:dateTime($dateTime as xs:string, $timezone as xs:string) {        		xs:dateTime( concat($dateTime, $timezone) )        	};        	adjust-dateTime-to-timezone(local:dateTime("1972-12-14T00:00:00", "-12:00")) eq        	adjust-dateTime-to-timezone(xs:dateTime("1972-12-15T00:00:00+12:00"))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-dateTime-equal-016,Error: XPST0003: Unable to parse XPath:        	declare function local:dateTime($dateTime as xs:string, $timezone as xs:string) {        		xs:dateTime( concat($dateTime, $timezone) )        	};        	adjust-dateTime-to-timezone(local:dateTime("1972-12-14T00:00:00", "-12:00")) ne        	adjust-dateTime-to-timezone(xs:dateTime("1972-12-15T00:00:00+12:00"))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-dateTime-greater-than-001,Error: XPST0003: Unable to parse XPath: declare function local:two-digit($number as xs:integer) { let $string := string($number) return if (string-length($string) lt 2) then concat('0', $string) else $string }; declare function local:dateTime($year as xs:integer, $month as xs:integer, $day as xs:integer) { let $m := local:two-digit($month), $d := local:two-digit($day) return xs:dateTime(concat($year, '-', $m, '-', $d, "T12:00:00")) }; not(local:dateTime(2008, 05, 12) gt xs:dateTime("1972-12-15T12:00:00")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-dateTime-greater-than-004,AssertionError: Expected XPath xs:dateTime("2008-01-31T00:01:00") gt xs:dateTime("2008-01-31T00:01:00+09:00") to resolve to true: expected false to be true
cbcl-dateTime-greater-than-005,AssertionError: Expected XPath xs:dateTime("2008-01-31T00:01:00+09:00") gt xs:dateTime("2008-01-31T00:01:00") to resolve to false: expected true to be false
cbcl-dateTime-greater-than-006,Error: XPST0003: Unable to parse XPath: declare function local:two-digit($number as xs:integer) { let $string := string($number) return if (string-length($string) lt 2) then concat('0', $string) else $string }; declare function local:dateTime($year as xs:integer, $month as xs:integer, $day as xs:integer) { let $m := local:two-digit($month), $d := local:two-digit($day) return xs:dateTime(concat($year, '-', $m, '-', $d, "T12:00:00")) }; not(local:dateTime(2008, 05, 12) ge xs:dateTime("1972-12-15T12:00:00")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-dateTime-greater-than-009,AssertionError: Expected XPath xs:dateTime("2008-01-31T00:01:00") ge xs:dateTime("2008-01-31T00:01:00+09:00") to resolve to true: expected false to be true
cbcl-dateTime-greater-than-010,AssertionError: Expected XPath xs:dateTime("2008-01-31T00:01:00+09:00") ge xs:dateTime("2008-01-31T00:01:00") to resolve to false: expected true to be false
cbcl-dateTime-greater-than-011,Error: XPST0003: Unable to parse XPath: declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; exists(local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:true()) gt xs:dateTime("1972-12-15T12:00:00")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-dateTime-greater-than-012,Error: XPST0003: Unable to parse XPath: declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:false()) gt xs:dateTime("1972-12-15T12:00:00"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-dateTime-greater-than-013,Error: XPST0003: Unable to parse XPath: declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; exists(local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:true()) le xs:dateTime("1972-12-15T12:00:00")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-dateTime-greater-than-014,Error: XPST0003: Unable to parse XPath: declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:false()) le xs:dateTime("1972-12-15T12:00:00"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-dateTime-greater-than-015,Error: XPST0003: Unable to parse XPath: declare function local:dateTime($dateTime as xs:string, $timezone as xs:string) { xs:dateTime( concat($dateTime, $timezone) ) }; adjust-dateTime-to-timezone(local:dateTime("1972-12-14T00:00:00", "-12:00")) gt adjust-dateTime-to-timezone(xs:dateTime("1972-12-15T00:00:00+12:00")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-dateTime-greater-than-016,Error: XPST0003: Unable to parse XPath: declare function local:dateTime($dateTime as xs:string, $timezone as xs:string) { xs:dateTime( concat($dateTime, $timezone) ) }; adjust-dateTime-to-timezone(local:dateTime("1972-12-14T00:00:00", "-12:00")) ge adjust-dateTime-to-timezone(xs:dateTime("1972-12-15T00:00:00+12:00")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-dateTime-less-than-001,Error: XPST0003: Unable to parse XPath: declare function local:two-digit($number as xs:integer) { let $string := string($number) return if (string-length($string) lt 2) then concat('0', $string) else $string }; declare function local:dateTime($year as xs:integer, $month as xs:integer, $day as xs:integer) { let $m := local:two-digit($month), $d := local:two-digit($day) return xs:dateTime(concat($year, '-', $m, '-', $d, "T12:00:00")) }; not(local:dateTime(2008, 05, 12) lt xs:dateTime("1972-12-15T12:00:00")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-dateTime-less-than-004,AssertionError: Expected XPath xs:dateTime("2008-01-31T00:01:00") lt xs:dateTime("2008-01-31T00:01:00+09:00") to resolve to false: expected true to be false
cbcl-dateTime-less-than-005,AssertionError: Expected XPath xs:dateTime("2008-01-31T00:01:00+09:00") lt xs:dateTime("2008-01-31T00:01:00") to resolve to true: expected false to be true
cbcl-dateTime-less-than-006,Error: XPST0003: Unable to parse XPath: declare function local:two-digit($number as xs:integer) { let $string := string($number) return if (string-length($string) lt 2) then concat('0', $string) else $string }; declare function local:dateTime($year as xs:integer, $month as xs:integer, $day as xs:integer) { let $m := local:two-digit($month), $d := local:two-digit($day) return xs:dateTime(concat($year, '-', $m, '-', $d, "T12:00:00")) }; not(local:dateTime(2008, 05, 12) le xs:dateTime("1972-12-15T12:00:00")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-dateTime-less-than-009,AssertionError: Expected XPath xs:dateTime("2008-01-31T00:01:00") le xs:dateTime("2008-01-31T00:01:00+09:00") to resolve to false: expected true to be false
cbcl-dateTime-less-than-010,AssertionError: Expected XPath xs:dateTime("2008-01-31T00:01:00+09:00") le xs:dateTime("2008-01-31T00:01:00") to resolve to true: expected false to be true
cbcl-dateTime-less-than-011,Error: XPST0003: Unable to parse XPath: declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; exists(local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:true()) lt xs:dateTime("1972-12-15T12:00:00")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-dateTime-less-than-012,Error: XPST0003: Unable to parse XPath: declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:false()) lt xs:dateTime("1972-12-15T12:00:00"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-dateTime-less-than-013,Error: XPST0003: Unable to parse XPath: declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; exists(local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:true()) ge xs:dateTime("1972-12-15T12:00:00")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-dateTime-less-than-014,Error: XPST0003: Unable to parse XPath: declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:false()) ge xs:dateTime("1972-12-15T12:00:00"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-dateTime-less-than-015,Error: XPST0003: Unable to parse XPath: declare function local:dateTime($dateTime as xs:string, $timezone as xs:string) { xs:dateTime( concat($dateTime, $timezone) ) }; adjust-dateTime-to-timezone(local:dateTime("1972-12-14T00:00:00", "-12:00")) lt adjust-dateTime-to-timezone(xs:dateTime("1972-12-15T00:00:00+12:00")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-dateTime-less-than-016,Error: XPST0003: Unable to parse XPath: declare function local:dateTime($dateTime as xs:string, $timezone as xs:string) { xs:dateTime( concat($dateTime, $timezone) ) }; adjust-dateTime-to-timezone(local:dateTime("1972-12-14T00:00:00", "-12:00")) le adjust-dateTime-to-timezone(xs:dateTime("1972-12-15T00:00:00+12:00")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
op-duration-equal-1,AssertionError: Expected XPath xs:duration("P1Y") eq xs:duration("P12M") to resolve to true: expected false to be true
op-duration-equal-2,AssertionError: Expected XPath xs:duration("PT24H") eq xs:duration("P1D") to resolve to true: expected false to be true
op-duration-equal-4,AssertionError: Expected XPath xs:duration("P1Y") eq xs:duration("P1Y") to resolve to true: expected false to be true
op-duration-equal-5,AssertionError: Expected XPath xs:duration("P1Y") ne xs:duration("P1Y") to resolve to false: expected true to be false
op-duration-equal-6,AssertionError: Expected XPath xs:duration("PT24H") eq xs:duration("PT24H") to resolve to true: expected false to be true
op-duration-equal-7,AssertionError: Expected XPath xs:duration("PT24H") ne xs:duration("PT24H") to resolve to false: expected true to be false
op-duration-equal-8,AssertionError: Expected XPath xs:duration("P12M") eq xs:duration("P12M") to resolve to true: expected false to be true
op-duration-equal-9,AssertionError: Expected XPath xs:duration("P12M") ne xs:duration("P12M") to resolve to false: expected true to be false
op-duration-equal-10,AssertionError: Expected XPath xs:duration("P365D") eq xs:duration("P365D") to resolve to true: expected false to be true
op-duration-equal-11,AssertionError: Expected XPath xs:duration("P365D") ne xs:duration("P365D") to resolve to false: expected true to be false
op-duration-equal-14,AssertionError: Expected XPath fn:not(xs:duration("P36D") eq xs:duration("P36D")) to resolve to false: expected true to be false
op-duration-equal-15,AssertionError: Expected XPath fn:not(xs:duration("P36D") ne xs:duration("P36D")) to resolve to true: expected false to be true
op-duration-equal-16,AssertionError: Expected XPath xs:boolean(xs:duration("P36D") eq xs:duration("P36D")) to resolve to true: expected false to be true
op-duration-equal-17,AssertionError: Expected XPath xs:boolean(xs:duration("P36D") ne xs:duration("P36D")) to resolve to false: expected true to be false
op-duration-equal-18,AssertionError: Expected XPath (xs:duration("P36D") eq xs:duration("P36D")) and fn:true() to resolve to true: expected false to be true
op-duration-equal-19,AssertionError: Expected XPath (xs:duration("P36D") ne xs:duration("P36D")) and fn:true() to resolve to false: expected true to be false
op-duration-equal-24,AssertionError: Expected XPath (xs:duration("P36D") eq xs:duration("P36D")) or fn:false() to resolve to true: expected false to be true
op-duration-equal-25,AssertionError: Expected XPath (xs:duration("P36D") ne xs:duration("P36D")) or fn:false() to resolve to false: expected true to be false
op-duration-equal-26,Error: XPTY0004: Values to compare are not of the same type
op-duration-equal-27,Error: XPTY0004: Values to compare are not of the same type
op-yearMonthDuration-equal2args-1,AssertionError: Expected XPath xs:yearMonthDuration("P0Y0M") eq xs:yearMonthDuration("P0Y0M") to resolve to true: expected false to be true
op-yearMonthDuration-equal2args-6,AssertionError: Expected XPath xs:yearMonthDuration("P0Y0M") ne xs:yearMonthDuration("P0Y0M") to resolve to false: expected true to be false
op-yearMonthDuration-equal2args-12,AssertionError: Expected XPath xs:yearMonthDuration("P1000Y6M") le xs:yearMonthDuration("P0Y0M") to resolve to false: expected true to be false
op-yearMonthDuration-equal2args-13,AssertionError: Expected XPath xs:yearMonthDuration("P2030Y12M") le xs:yearMonthDuration("P0Y0M") to resolve to false: expected true to be false
op-yearMonthDuration-equal2args-19,AssertionError: Expected XPath xs:yearMonthDuration("P0Y0M") ge xs:yearMonthDuration("P1000Y6M") to resolve to false: expected true to be false
op-yearMonthDuration-equal2args-20,AssertionError: Expected XPath xs:yearMonthDuration("P0Y0M") ge xs:yearMonthDuration("P2030Y12M") to resolve to false: expected true to be false
op-dayTimeDuration-equal2args-1,AssertionError: Expected XPath xs:dayTimeDuration("P0DT0H0M0S") eq xs:dayTimeDuration("P0DT0H0M0S") to resolve to true: expected false to be true
op-dayTimeDuration-equal2args-6,AssertionError: Expected XPath xs:dayTimeDuration("P0DT0H0M0S") ne xs:dayTimeDuration("P0DT0H0M0S") to resolve to false: expected true to be false
op-dayTimeDuration-equal2args-12,AssertionError: Expected XPath xs:dayTimeDuration("P15DT11H59M59S") le xs:dayTimeDuration("P0DT0H0M0S") to resolve to false: expected true to be false
op-dayTimeDuration-equal2args-13,AssertionError: Expected XPath xs:dayTimeDuration("P31DT23H59M59S") le xs:dayTimeDuration("P0DT0H0M0S") to resolve to false: expected true to be false
op-dayTimeDuration-equal2args-19,AssertionError: Expected XPath xs:dayTimeDuration("P0DT0H0M0S") ge xs:dayTimeDuration("P15DT11H59M59S") to resolve to false: expected true to be false
op-dayTimeDuration-equal2args-20,AssertionError: Expected XPath xs:dayTimeDuration("P0DT0H0M0S") ge xs:dayTimeDuration("P31DT23H59M59S") to resolve to false: expected true to be false
distinct-duration-equal-1,AssertionError: Expected executing the XPath "fn:distinct-values((xs:yearMonthDuration('P0Y'), xs:dayTimeDuration('P0D')))" to resolve to one of the expected results, but got Error: XPST0017: Function fn:distinct-values with arity of 1 not registered. No similar functions found., Error: XPST0017: Function fn:distinct-values with arity of 1 not registered. No similar functions found..
distinct-duration-equal-2,AssertionError: Expected executing the XPath "fn:distinct-values((xs:yearMonthDuration('P1Y'), xs:dayTimeDuration('P365D')))" to resolve to one of the expected results, but got Error: XPST0017: Function fn:distinct-values with arity of 1 not registered. No similar functions found., Error: XPST0017: Function fn:distinct-values with arity of 1 not registered. No similar functions found..
K-DurationEQ-1,AssertionError: Expected XPath xs:duration("P1999Y10M3DT08H34M12.143S") eq xs:duration("P1999Y10M3DT08H34M12.143S") to resolve to true: expected false to be true
K-DurationEQ-2,AssertionError: Expected XPath xs:duration("PT0S") eq xs:duration("PT0S") to resolve to true: expected false to be true
K-DurationEQ-5,AssertionError: Expected XPath not(xs:duration("P1999Y10M3DT08H34M12.143S") ne xs:duration("P1999Y10M3DT08H34M12.143S")) to resolve to true: expected false to be true
K-DurationEQ-7,AssertionError: Expected XPath xs:duration("P1Y") eq xs:duration("P12M") to resolve to true: expected false to be true
K-DurationEQ-9,AssertionError: Expected XPath xs:duration("-PT0S") eq xs:duration("PT0S") to resolve to true: expected false to be true
K-DurationEQ-11,AssertionError: expected [Function] to throw an error
K-DurationEQ-12,AssertionError: expected [Function] to throw an error
K-DurationEQ-13,AssertionError: expected [Function] to throw an error
K-DurationEQ-14,AssertionError: expected [Function] to throw an error
K-DurationEQ-15,Error: XPTY0004: Values to compare are not of the same type
K-DurationEQ-16,Error: XPTY0004: Values to compare are not of the same type
K-DurationEQ-17,Error: XPTY0004: Values to compare are not of the same type
K-DurationEQ-18,Error: XPTY0004: Values to compare are not of the same type
K-DurationEQ-19,Error: XPTY0004: Values to compare are not of the same type
K-DurationEQ-20,Error: XPTY0004: Values to compare are not of the same type
K-DurationEQ-21,Error: XPTY0004: Values to compare are not of the same type
K-DurationEQ-22,Error: XPTY0004: Values to compare are not of the same type
K-DurationEQ-23,Error: XPTY0004: Values to compare are not of the same type
K-DurationEQ-24,Error: XPTY0004: Values to compare are not of the same type
K-DurationEQ-25,Error: XPTY0004: Values to compare are not of the same type
K-DurationEQ-26,Error: XPTY0004: Values to compare are not of the same type
K-DurationEQ-27,Error: XPTY0004: Values to compare are not of the same type
K-DurationEQ-28,Error: XPTY0004: Values to compare are not of the same type
K-DurationEQ-29,Error: XPTY0004: Values to compare are not of the same type
K-DurationEQ-30,Error: XPTY0004: Values to compare are not of the same type
K-DurationEQ-31,Error: XPTY0004: Values to compare are not of the same type
K-DurationEQ-32,Error: XPTY0004: Values to compare are not of the same type
K-DayTimeDurationEQ-1,AssertionError: Expected XPath xs:dayTimeDuration("P3DT08H34M12.143S") eq xs:dayTimeDuration("P3DT08H34M12.143S") to resolve to true: expected false to be true
K-DayTimeDurationEQ-2,AssertionError: Expected XPath xs:dayTimeDuration("PT0S") eq xs:dayTimeDuration("PT0S") to resolve to true: expected false to be true
K-DayTimeDurationEQ-5,AssertionError: Expected XPath not(xs:dayTimeDuration("P3DT08H34M12.143S") ne xs:dayTimeDuration("P3DT08H34M12.143S")) to resolve to true: expected false to be true
K-DayTimeDurationEQ-6,AssertionError: Expected XPath xs:dayTimeDuration("-PT0S") eq xs:dayTimeDuration("PT0S") to resolve to true: expected false to be true
K-DayTimeDurationEQ-8,AssertionError: Expected XPath xs:dayTimeDuration("P6DT16H34M59.613999S") eq xs:dayTimeDuration("P6DT16H34M59.613999S") to resolve to true: expected false to be true
K-YearMonthDurationEQ-1,AssertionError: Expected XPath xs:yearMonthDuration("P1999Y10M") eq xs:yearMonthDuration("P1999Y10M") to resolve to true: expected false to be true
K-YearMonthDurationEQ-2,AssertionError: Expected XPath xs:yearMonthDuration("P0M") eq xs:yearMonthDuration("P0M") to resolve to true: expected false to be true
K-YearMonthDurationEQ-5,AssertionError: Expected XPath not(xs:yearMonthDuration("P1999Y10M") ne xs:yearMonthDuration("P1999Y10M")) to resolve to true: expected false to be true
cbcl-dayTimeDuration-equal-001,Error: XPST0003: Unable to parse XPath: declare function local:dayTimeDuration($days as xs:integer, $hours as xs:integer ) { xs:dayTimeDuration(concat('P', $days, 'DT', $hours, 'H')) }; not(local:dayTimeDuration(1, 1) eq xs:dayTimeDuration("P0D")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-dayTimeDuration-equal-002,Error: XPST0003: Unable to parse XPath: declare function local:dayTimeDuration($days as xs:integer, $hours as xs:integer ) { xs:dayTimeDuration(concat('P', $days, 'DT', $hours, 'H')) }; not(local:dayTimeDuration(1, 1) ne xs:dayTimeDuration("P0D")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-dayTimeDuration-equal-003,Error: XPST0003: Unable to parse XPath: declare function local:dayTimeDuration($dayTimeDuration as xs:dayTimeDuration, $null as xs:boolean) { if ($null) then () else $dayTimeDuration }; exists(local:dayTimeDuration(xs:dayTimeDuration("P0D"), fn:true()) eq xs:dayTimeDuration("P0D")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-dayTimeDuration-equal-004,Error: XPST0003: Unable to parse XPath: declare function local:dayTimeDuration($dayTimeDuration as xs:dayTimeDuration, $null as xs:boolean) { if ($null) then () else $dayTimeDuration }; local:dayTimeDuration(xs:dayTimeDuration("P0D"), fn:false()) eq xs:dayTimeDuration("P0D"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-dayTimeDuration-equal-005,Error: XPST0003: Unable to parse XPath: declare function local:dayTimeDuration($dayTimeDuration as xs:dayTimeDuration, $null as xs:boolean) { if ($null) then () else $dayTimeDuration }; exists(local:dayTimeDuration(xs:dayTimeDuration("P0D"), fn:true()) ne xs:dayTimeDuration("P0D")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-dayTimeDuration-equal-006,Error: XPST0003: Unable to parse XPath: declare function local:dayTimeDuration($dayTimeDuration as xs:dayTimeDuration, $null as xs:boolean) { if ($null) then () else $dayTimeDuration }; local:dayTimeDuration(xs:dayTimeDuration("P0D"), fn:false()) ne xs:dayTimeDuration("P0D"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-duration-equal-001,Error: XPST0003: Unable to parse XPath: declare function local:duration($days as xs:integer, $hours as xs:integer) { xs:duration(concat('P', $days, 'DT', $hours, 'H')) }; not(local:duration(1, 1) eq xs:dayTimeDuration("P0D")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-duration-equal-002,Error: XPST0003: Unable to parse XPath: declare function local:duration($days as xs:integer, $hours as xs:integer) { xs:duration(concat('P', $days, 'DT', $hours, 'H')) }; not(local:duration(1, 1) ne xs:dayTimeDuration("P0D")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-duration-equal-003,Error: XPST0003: Unable to parse XPath: declare function local:duration($duration as xs:duration, $null as xs:boolean) { if ($null) then () else $duration }; exists(local:duration(xs:duration("P1DT1H"), fn:true()) eq xs:duration("P1DT1H")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-duration-equal-004,Error: XPST0003: Unable to parse XPath: declare function local:duration($duration as xs:duration, $null as xs:boolean) { if ($null) then () else $duration }; local:duration(xs:duration("P1DT1H"), fn:false()) eq xs:duration("P1DT1H"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-duration-equal-005,Error: XPST0003: Unable to parse XPath: declare function local:duration($duration as xs:duration, $null as xs:boolean) { if ($null) then () else $duration }; exists(local:duration(xs:duration("P1DT1H"), fn:true()) ne xs:duration("P1DT1H")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-duration-equal-006,Error: XPST0003: Unable to parse XPath: declare function local:duration($duration as xs:duration, $null as xs:boolean) { if ($null) then () else $duration }; local:duration(xs:duration("P1DT1H"), fn:false()) ne xs:duration("P1DT1H"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-yearMonthDuration-equal-001,Error: XPST0003: Unable to parse XPath:          declare function local:yearMonthDuration($years as xs:integer, $months as xs:integer ) { xs:yearMonthDuration(concat('P', $years, 'Y', $months, 'M')) };         not(local:yearMonthDuration(1, 1) eq xs:yearMonthDuration("P0Y")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-yearMonthDuration-equal-002,Error: XPST0003: Unable to parse XPath:          declare function local:yearMonthDuration($years as xs:integer, $months as xs:integer ) { xs:yearMonthDuration(concat('P', $years, 'Y', $months, 'M')) };         not(local:yearMonthDuration(1, 1) ne xs:yearMonthDuration("P0Y")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
fn-except-node-args-003,Error: XPST0017: Function root with arity of 1 not registered. No similar functions found.
K2-SeqExcept-18,Error: XPST0003: Unable to parse XPath: (count(<e/>/(a except attribute {"name"} {()})))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
K2-SeqExcept-19,Error: XPST0003: Unable to parse XPath: (count(<e/>/(a except attribute name {()})))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
K2-SeqExcept-20,AssertionError: Expected executing the XPath "count(<e/>/(a except element {"name"} {()}))" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (count(<e/>/(a except element {"name"} {()})))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: count(<e/>/(a except element {"name"} {()})). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.'.
K2-SeqExcept-21,AssertionError: Expected executing the XPath "count(<e/>/(a except element name {()}))" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (count(<e/>/(a except element name {()})))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: count(<e/>/(a except element name {()})). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.'.
K2-SeqExcept-22,Error: XPST0003: Unable to parse XPath: (count(<e/>/(a except processing-instruction {"name"} {()})))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
K2-SeqExcept-23,Error: XPST0003: Unable to parse XPath: (count(<e/>/(a except processing-instruction name {})))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
K2-SeqExcept-24,Error: XPST0003: Unable to parse XPath: (count(<e/>/(a except comment {()})))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
K2-SeqExcept-25,Error: XPST0003: Unable to parse XPath: (count(<e/>/(a except text {()})))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
combiningnodeseqexcepthc4,Error: XPST0003: Unable to parse XPath: (for $h in ( count((//hours) except (//hours))) order by number($h) return $h) = (0). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
combiningnodeseqexcepthc5,Error: XPST0003: Unable to parse XPath: (for $h in ( count(($works//hours) except ($staff//grade,$works//hours))) order by number($h) return $h) = (0). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
combiningnodeseqexcepthc6,Error: XPST0003: Unable to parse XPath: for $h in ( ($works//hours) except ($staff//grade)) order by number($h) return $h. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
K-HexBinaryEQ-1,AssertionError: Expected XPath xs:hexBinary("FF") eq xs:hexBinary("ff") to resolve to true: expected false to be true
K-HexBinaryEQ-4,AssertionError: Expected XPath xs:hexBinary(xs:base64Binary(xs:hexBinary("03"))) eq xs:hexBinary("03") to resolve to true: expected false to be true
cbcl-hexBinary-equal-001,Error: XPST0003: Unable to parse XPath:           declare function local:hexBinary-value($arg as xs:boolean) as xs:hexBinary {              if ($arg) then xs:hexBinary('68656c6c6f') else xs:hexBinary('676f6f64627965')           };           local:hexBinary-value(true()) eq local:hexBinary-value(false()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-hexBinary-equal-002,Error: XPST0003: Unable to parse XPath:           declare function local:hexBinary-value($arg as xs:boolean) as xs:hexBinary {              if ($arg) then xs:hexBinary('68656c6c6f') else xs:hexBinary('676f6f64627965')           };           not(local:hexBinary-value(true()) eq local:hexBinary-value(false())). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-hexBinary-equal-003,Error: XPST0003: Unable to parse XPath:           declare function local:hexBinary-value($arg as xs:boolean) as xs:hexBinary {              if ($arg) then xs:hexBinary('68656c6c6f') else xs:hexBinary('676f6f64627965')           };           not(local:hexBinary-value(true()) ne local:hexBinary-value(false())). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
fn-intersect-node-args-003,Error: XPST0017: Function root with arity of 1 not registered. No similar functions found.
K2-SeqIntersect-18,Error: XPST0003: Unable to parse XPath: empty(<e/>/(a intersect attribute {"name"} {()})). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
K2-SeqIntersect-19,Error: XPST0003: Unable to parse XPath: empty(<e/>/(a intersect attribute name {()})). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
K2-SeqIntersect-20,AssertionError: Expected executing the XPath "empty(<e/>/(a intersect element {"name"} {()}))" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: empty(<e/>/(a intersect element {"name"} {()})). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: empty(<e/>/(a intersect element {"name"} {()})). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.'.
K2-SeqIntersect-21,AssertionError: Expected executing the XPath "empty(<e/>/(a intersect element name {()}))" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: empty(<e/>/(a intersect element name {()})). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: empty(<e/>/(a intersect element name {()})). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.'.
K2-SeqIntersect-22,Error: XPST0003: Unable to parse XPath: empty(<e/>/(a intersect processing-instruction {"name"} {()})). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
K2-SeqIntersect-23,Error: XPST0003: Unable to parse XPath: empty(<e/>/(a intersect processing-instruction name {})). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
K2-SeqIntersect-24,Error: XPST0003: Unable to parse XPath: empty(<e/>/(a intersect comment {()})). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
K2-SeqIntersect-25,Error: XPST0003: Unable to parse XPath: empty(<e/>/(a intersect text {()})). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
K2-SeqIntersect-42,Error: XPST0003: Unable to parse XPath:           declare function local:function ($c as node()) { $c intersect $c };           empty(local:function(document{()}))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
combiningnodeseqintersecthc3,Error: XPST0003: Unable to parse XPath: for $h in ( (//hours) intersect (//hours[xs:integer(.) gt 12])) order by number($h) return $h. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
combiningnodeseqintersecthc4,Error: XPST0003: Unable to parse XPath: for $h in ( ($works//hours) intersect ($works//hours, $staff//grade)) order by number($h) return $h. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
K2-NodeSame-1,Error: XPST0003: Unable to parse XPath: declare variable $var := <elem/>; <a>{$var}</a>/elem[1] is $var. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-NodeSame-2,Error: XPST0003: Unable to parse XPath: declare variable $var := <elem/>; $var is $var. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-NodeSame-3,Error: XPST0003: Unable to parse XPath: declare variable $var := <elem/>; not($var is <elem/>). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-NodeSame-4,Error: XPST0003: Unable to parse XPath: (declare variable $e := attribute name {()}; $e is $e, <is/> is <is/>)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
cbcl-is-same-node-001,Error: XPST0003: Unable to parse XPath:        	declare function local:f() as node() { <a/> };        	local:f() is local:f()       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
nodeexpression33,AssertionError: Expected executing the XPath "count(() >> ())" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (count(() >> ())) = (0). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: count(() >> ()). SyntaxError: Expected " ", "$", "\'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\\"", "\\n", "\\r", "\\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.'.
nodeexpression34,AssertionError: Expected executing the XPath "count(() >> <a>50000</a>)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (count(() >> <a>50000</a>)) = (0). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: count(() >> <a>50000</a>). SyntaxError: Expected " ", "$", "\'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\\"", "\\n", "\\r", "\\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.'.
nodeexpression35,AssertionError: Expected executing the XPath "count(() >> /works[1]/employee[1]/empnum[1])" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (count(() >> /works[1]/employee[1]/empnum[1])) = (0). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: count(() >> /works[1]/employee[1]/empnum[1]). SyntaxError: Expected " ", "$", "\'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\\"", "\\n", "\\r", "\\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.'.
nodeexpression36,AssertionError: Expected executing the XPath "count(() >> (/staff[1]/employee[1]/empnum[1]))" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (count(() >> (/staff[1]/employee[1]/empnum[1]))) = (0). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: count(() >> (/staff[1]/employee[1]/empnum[1])). SyntaxError: Expected " ", "$", "\'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\\"", "\\n", "\\r", "\\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.'.
nodeexpression37,AssertionError: Expected executing the XPath "count(<a>50000</a> >> ())" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (count(<a>50000</a> >> ())) = (0). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: count(<a>50000</a> >> ()). SyntaxError: Expected " ", "$", "\'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\\"", "\\n", "\\r", "\\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.'.
nodeexpression38,AssertionError: Expected executing the XPath "<a>50000</a> >> <a>50000</a>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: <a>50000</a> >> <a>50000</a>. SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found., Error: XPST0003: Unable to parse XPath: <a>50000</a> >> <a>50000</a>. SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found..
nodeexpression39,AssertionError: Expected executing the XPath "<a>50000</a> >> /works[1]/employee[1]/empnum[1]" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: <a>50000</a> >> /works[1]/employee[1]/empnum[1]. SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found., Error: XPST0003: Unable to parse XPath: <a>50000</a> >> /works[1]/employee[1]/empnum[1]. SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found..
nodeexpression40,AssertionError: Expected executing the XPath "<a>50000</a> >> (/staff[1]/employee[1]/empnum[1])" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: <a>50000</a> >> (/staff[1]/employee[1]/empnum[1]). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found., Error: XPST0003: Unable to parse XPath: <a>50000</a> >> (/staff[1]/employee[1]/empnum[1]). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found..
nodeexpression41,AssertionError: Expected executing the XPath "count(/works[1]/employee[1]/empnum[1] >> ())" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (count(/works[1]/employee[1]/empnum[1] >> ())) = (0). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: count(/works[1]/employee[1]/empnum[1] >> ()). SyntaxError: Expected " ", "$", "\'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\\"", "\\n", "\\r", "\\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.'.
nodeexpression42,AssertionError: Expected executing the XPath "/works[1]/employee[1]/empnum[1] >> <a>50000</a>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: /works[1]/employee[1]/empnum[1] >> <a>50000</a>. SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found., Error: XPST0003: Unable to parse XPath: /works[1]/employee[1]/empnum[1] >> <a>50000</a>. SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found..
nodeexpression43,Error: XPST0003: Unable to parse XPath: /works[1]/employee[1]/empnum[1] >> /works[1]/employee[1]/empnum[1]. SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.
nodeexpression44,AssertionError: Expected executing the XPath "$works/works[1]/employee[1]/empnum[1] >> ($staff/staff[1]/employee[1]/empnum[1])" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: $works/works[1]/employee[1]/empnum[1] >> ($staff/staff[1]/employee[1]/empnum[1]). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found., Error: XPST0003: Unable to parse XPath: $works/works[1]/employee[1]/empnum[1] >> ($staff/staff[1]/employee[1]/empnum[1]). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found..
nodeexpression45,AssertionError: Expected executing the XPath "count((/staff[1]/employee[1]/empnum[1]) >> ())" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (count((/staff[1]/employee[1]/empnum[1]) >> ())) = (0). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: count((/staff[1]/employee[1]/empnum[1]) >> ()). SyntaxError: Expected " ", "$", "\'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\\"", "\\n", "\\r", "\\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.'.
nodeexpression46,AssertionError: Expected executing the XPath "(/staff[1]/employee[1]/empnum[1]) >> <a>50000</a>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (/staff[1]/employee[1]/empnum[1]) >> <a>50000</a>. SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found., Error: XPST0003: Unable to parse XPath: (/staff[1]/employee[1]/empnum[1]) >> <a>50000</a>. SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found..
nodeexpression47,Error: XPST0003: Unable to parse XPath: (($works/works[1]/employee[1]/empnum[1] >> $staff/staff[1]/employee[1]/empnum[1])           and ($works/works[1]/employee[2]/empnum[1] >> $staff/staff[1]/employee[2]/empnum[1])           and ($works/works[1]/employee[3]/empnum[1] >> $staff/staff[1]/employee[3]/empnum[1]))           or (($works/works[1]/employee[1]/empnum[1] << $staff/staff[1]/employee[1]/empnum[1])           and ($works/works[1]/employee[2]/empnum[1] << $staff/staff[1]/employee[2]/empnum[1])           and ($works/works[1]/employee[3]/empnum[1] << $staff/staff[1]/employee[3]/empnum[1])). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.
nodeexpression48,Error: XPST0003: Unable to parse XPath: (/staff[1]/employee[1]/empnum[1]) >> (/staff[1]/employee[1]/empnum[1]). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.
nodeexpressionhc11,Error: XPST0003: Unable to parse XPath: fn:not((/staff[1]/employee[1]/empnum[1]) >> (/staff[1]/employee[1]/empnum[1])). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.
nodeexpressionhc12,Error: XPST0003: Unable to parse XPath: ((/staff[1]/employee[1]/empnum[1]) >> (/staff[1]/employee[1]/empnum[1]))           lt ((/staff[1]/employee[1]/empnum[1]) >> (/staff[1]/employee[1]/empnum[1])). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.
nodeexpressionhc13,Error: XPST0003: Unable to parse XPath: ((/staff[1]/employee[1]/empnum[1]) >> (/staff[1]/employee[1]/empnum[1]))           ge ((/staff[1]/employee[1]/empnum[1]) >> (/staff[1]/employee[1]/empnum[1])). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.
nodeexpressionhc14,Error: XPST0003: Unable to parse XPath: ((/staff[1]/employee[1]/empnum[1]) >> (/staff[1]/employee[1]/empnum[1]))           gt ((/staff[1]/employee[1]/empnum[1]) >> (/staff[1]/employee[1]/empnum[1])). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.
nodeexpressionhc15,Error: XPST0003: Unable to parse XPath: ((/staff[1]/employee[1]/empnum[1]) >> (/staff[1]/employee[1]/empnum[1]))           le ((/staff[1]/employee[1]/empnum[1]) >> (/staff[1]/employee[1]/empnum[1])). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.
nodecomparisonerr-3,AssertionError: Expected executing the XPath "fn:count(() >> 100)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (fn:count(() >> 100)) = (0). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: fn:count(() >> 100). SyntaxError: Expected " ", "$", "\'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\\"", "\\n", "\\r", "\\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.', AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: fn:count(() >> 100). SyntaxError: Expected " ", "$", "\'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\\"", "\\n", "\\r", "\\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.'.
K-NodeAfter-1,AssertionError: Expected executing the XPath "empty(1 >> ())" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: empty(1 >> ()). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: empty(1 >> ()). SyntaxError: Expected " ", "$", "\'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\\"", "\\n", "\\r", "\\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.', AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: empty(1 >> ()). SyntaxError: Expected " ", "$", "\'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\\"", "\\n", "\\r", "\\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.'.
K-NodeAfter-2,AssertionError: Expected executing the XPath "empty(() >> 1)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: empty(() >> 1). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: empty(() >> 1). SyntaxError: Expected " ", "$", "\'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\\"", "\\n", "\\r", "\\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.', AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: empty(() >> 1). SyntaxError: Expected " ", "$", "\'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\\"", "\\n", "\\r", "\\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.'.
K-NodeAfter-3,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: 1 >> 1. SyntaxError: Expected " ", "$", "\'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\\"", "\\n", "\\r", "\\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.'
K-NodeAfter-4,AssertionError: Expected executing the XPath "empty(() >> ())" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: empty(() >> ()). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: empty(() >> ()). SyntaxError: Expected " ", "$", "\'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\\"", "\\n", "\\r", "\\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.'.
cbcl-node-after-001,Error: XPST0003: Unable to parse XPath:        	let $node := <a> <b/> <c/> </a>        	return not(exactly-one($node/b[1]) >> exactly-one($node/c[1]))       . SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.
cbcl-node-after-002,Error: XPST0003: Unable to parse XPath:        	let $node := <a> <b/> <c/> </a>        	return not(not(exactly-one($node/b[1]) >> exactly-one($node/c[1])))       . SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.
nodeexpression17,AssertionError: Expected executing the XPath "count(() << ())" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (count(() << ())) = (0). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: count(() << ()). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.'.
nodeexpression18,AssertionError: Expected executing the XPath "count(() << <a>50000</a>)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (count(() << <a>50000</a>)) = (0). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: count(() << <a>50000</a>). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.'.
nodeexpression19,AssertionError: Expected executing the XPath "count(() << /works[1]/employee[1]/empnum[1])" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (count(() << /works[1]/employee[1]/empnum[1])) = (0). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: count(() << /works[1]/employee[1]/empnum[1]). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.'.
nodeexpression20,AssertionError: Expected executing the XPath "count(() << /staff[1]/employee[1]/empnum[1])" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (count(() << /staff[1]/employee[1]/empnum[1])) = (0). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: count(() << /staff[1]/employee[1]/empnum[1]). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.'.
nodeexpression21,AssertionError: Expected executing the XPath "count(<a>50000</a> << ())" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (count(<a>50000</a> << ())) = (0). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: count(<a>50000</a> << ()). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.'.
nodeexpression22,AssertionError: Expected executing the XPath "<a>50000</a> << <a>50000</a>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: <a>50000</a> << <a>50000</a>. SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found., Error: XPST0003: Unable to parse XPath: <a>50000</a> << <a>50000</a>. SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found..
nodeexpression23,AssertionError: Expected executing the XPath "<a>50000</a> << /works[1]/employee[1]/empnum[1]" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: <a>50000</a> << /works[1]/employee[1]/empnum[1]. SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found., Error: XPST0003: Unable to parse XPath: <a>50000</a> << /works[1]/employee[1]/empnum[1]. SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found..
nodeexpression24,AssertionError: Expected executing the XPath "<a>50000</a> << (/staff[1]/employee[1]/empnum[1])" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: <a>50000</a> << (/staff[1]/employee[1]/empnum[1]). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found., Error: XPST0003: Unable to parse XPath: <a>50000</a> << (/staff[1]/employee[1]/empnum[1]). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found..
nodeexpression25,AssertionError: Expected executing the XPath "count(/works[1]/employee[1]/empnum[1] << ())" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (count(/works[1]/employee[1]/empnum[1] << ())) = (0). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: count(/works[1]/employee[1]/empnum[1] << ()). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.'.
nodeexpression26,AssertionError: Expected executing the XPath "/works[1]/employee[1]/empnum[1] << <a>50000</a>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: /works[1]/employee[1]/empnum[1] << <a>50000</a>. SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found., Error: XPST0003: Unable to parse XPath: /works[1]/employee[1]/empnum[1] << <a>50000</a>. SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found..
nodeexpression27,Error: XPST0003: Unable to parse XPath: /works[1]/employee[1]/empnum[1] << /works[1]/employee[1]/empnum[1]. SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.
nodeexpression28,AssertionError: Expected executing the XPath "$works/works[1]/employee[1]/empnum[1] << $staff/staff[1]/employee[1]/empnum[1]" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: $works/works[1]/employee[1]/empnum[1] << $staff/staff[1]/employee[1]/empnum[1]. SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found., Error: XPST0003: Unable to parse XPath: $works/works[1]/employee[1]/empnum[1] << $staff/staff[1]/employee[1]/empnum[1]. SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found..
nodeexpression29,AssertionError: Expected executing the XPath "count((/staff[1]/employee[1]/empnum[1]) << ())" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (count((/staff[1]/employee[1]/empnum[1]) << ())) = (0). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: count((/staff[1]/employee[1]/empnum[1]) << ()). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.'.
nodeexpression30,AssertionError: Expected executing the XPath "(/staff[1]/employee[1]/empnum[1]) << <a>50000</a>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (/staff[1]/employee[1]/empnum[1]) << <a>50000</a>. SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found., Error: XPST0003: Unable to parse XPath: (/staff[1]/employee[1]/empnum[1]) << <a>50000</a>. SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found..
nodeexpression31,Error: XPST0003: Unable to parse XPath: (($works/works[1]/employee[1]/empnum[1] << $staff/staff[1]/employee[1]/empnum[1])           and ($works/works[1]/employee[1]/empnum[1] << $staff/staff[1]/employee[2]/empnum[1])           and ($works/works[1]/employee[1]/empnum[1] << $staff/staff[1]/employee[3]/empnum[1]))           or (($works/works[1]/employee[1]/empnum[1] >> $staff/staff[1]/employee[1]/empnum[1])           and ($works/works[1]/employee[1]/empnum[1] >> $staff/staff[1]/employee[2]/empnum[1])           and ($works/works[1]/employee[1]/empnum[1] >> $staff/staff[1]/employee[3]/empnum[1])). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.
nodeexpression32,Error: XPST0003: Unable to parse XPath: (/staff[1]/employee[1]/empnum[1]) << (/staff[1]/employee[1]/empnum[1]). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.
nodeexpressionhc6,Error: XPST0003: Unable to parse XPath: fn:not((/staff[1]/employee[1]/empnum[1]) << (/staff[1]/employee[1]/empnum[1])). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.
nodeexpressionhc7,Error: XPST0003: Unable to parse XPath: ((/staff[1]/employee[1]/empnum[1]) << (/staff[1]/employee[1]/empnum[1]))           lt           ((/staff[1]/employee[1]/empnum[1]) << (/staff[1]/employee[1]/empnum[1])). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.
nodeexpressionhc8,Error: XPST0003: Unable to parse XPath: ((/staff[1]/employee[1]/empnum[1]) << (/staff[1]/employee[1]/empnum[1]))           ge          ((/staff[1]/employee[1]/empnum[1]) << (/staff[1]/employee[1]/empnum[1])). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.
nodeexpressionhc9,Error: XPST0003: Unable to parse XPath: ((/staff[1]/employee[1]/empnum[1]) << (/staff[1]/employee[1]/empnum[1]))           gt ((/staff[1]/employee[1]/empnum[1]) << (/staff[1]/employee[1]/empnum[1])). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.
nodeexpressionhc10,Error: XPST0003: Unable to parse XPath: ((/staff[1]/employee[1]/empnum[1]) << (/staff[1]/employee[1]/empnum[1]))           le ((/staff[1]/employee[1]/empnum[1]) << (/staff[1]/employee[1]/empnum[1])). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.
nodecomparisonerr-2,AssertionError: Expected executing the XPath "fn:count(() << 100)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (fn:count(() << 100)) = (0). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: fn:count(() << 100). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.', AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: fn:count(() << 100). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.'.
K-NodeBefore-1,AssertionError: Expected executing the XPath "empty(1 << ())" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: empty(1 << ()). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: empty(1 << ()). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.', AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: empty(1 << ()). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.'.
K-NodeBefore-2,AssertionError: Expected executing the XPath "empty(() << 1)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: empty(() << 1). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: empty(() << 1). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.', AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: empty(() << 1). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.'.
K-NodeBefore-3,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: 1 << 1. SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.'
K-NodeBefore-4,AssertionError: Expected executing the XPath "empty(() << ())" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: empty(() << ()). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: empty(() << ()). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.'.
K-NodeBefore-12,Error: XPST0003: Unable to parse XPath:     let $doc :=     <catalog>        <product dept="WMN">         <number>557</number>         <name language="en">Fleece Pullover</name>         <colorChoices>navy black</colorChoices>        </product>        <product dept="ACC">         <number>563</number>         <name language="en">Floppy Sun Hat</name>        </product>        <product dept="ACC">         <number>443</number>         <name language="en">Deluxe Travel Bag</name>        </product>        <product dept="MEN">         <number>784</number>         <name language="en">Cotton Dress Shirt</name>         <colorChoices>white gray</colorChoices>         <desc>Our <i>favorite</i> shirt!</desc>        </product>    </catalog>    let $prods := $doc//product    for $prod in $prods    where $prod << $prods[@dept = $prod/@dept][last()]    return $prod. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
cbcl-node-before-001,Error: XPST0003: Unable to parse XPath:        	let $node := <a> <b/> <c/> </a>        	return not(exactly-one($node/b[1]) << exactly-one($node/c[1]))       . SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.
cbcl-node-before-002,Error: XPST0003: Unable to parse XPath:        	let $node := <a> <b/> <c/> </a>        	return not(not(exactly-one($node/b[1]) << exactly-one($node/c[1])))       . SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.
op-numeric-addintg2args-1,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addintg2args-2,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addintg2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addintg2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addlng2args-1,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addlng2args-2,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addlng2args-3,Error: FOCA0003: can not cast -45058158165499290 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addlng2args-4,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addnint2args-1,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addnint2args-2,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addnint2args-3,Error: FOCA0003: can not cast -702985924000903206 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addnint2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addpint2args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addpint2args-3,Error: FOCA0003: can not cast 999999999999999998 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addpint2args-4,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addpint2args-5,Error: FOCA0003: can not cast 999999999999999998 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addulng2args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addulng2args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addulng2args-4,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addulng2args-5,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addnpi2args-1,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addnpi2args-2,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addnpi2args-3,Error: FOCA0003: can not cast -524311562728129509 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addnpi2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addnni2args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addnni2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addnni2args-4,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-addnni2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-NumericAdd-4,AssertionError: Expected XPath 1.1 + 2.2 eq 3.3 to resolve to true: expected false to be true
K-NumericAdd-15,AssertionError: Expected XPath (xs:integer(6) + xs:integer(2)) instance of xs:integer to resolve to true: expected false to be true
K-NumericAdd-17,AssertionError: Expected XPath (xs:decimal(6) + xs:float(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericAdd-18,AssertionError: Expected XPath (xs:float(6) + xs:decimal(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericAdd-19,AssertionError: Expected XPath (xs:float(6) + xs:integer(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericAdd-20,AssertionError: Expected XPath (xs:integer(6) + xs:float(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericAdd-21,AssertionError: Expected XPath (xs:float(6) + xs:float(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericAdd-22,AssertionError: Expected XPath (xs:decimal(6) + xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericAdd-23,AssertionError: Expected XPath (xs:double(6) + xs:decimal(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericAdd-24,AssertionError: Expected XPath (xs:double(6) + xs:float(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericAdd-25,AssertionError: Expected XPath (xs:float(6) + xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericAdd-26,AssertionError: Expected XPath (xs:double(6) + xs:integer(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericAdd-27,AssertionError: Expected XPath (xs:integer(6) + xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericAdd-28,AssertionError: Expected XPath (xs:double(6) + xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericAdd-31,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'
K-NumericAdd-32,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'
K-NumericAdd-33,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'
K-NumericAdd-34,AssertionError: Expected executing the XPath "(4, error()) + 3" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.', AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'.
K-NumericAdd-35,AssertionError: Expected executing the XPath "3 + (4, error())" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.', AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'.
K-NumericAdd-36,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'
K-NumericAdd-41,AssertionError: Expected executing the XPath "error() + 3" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.', AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'.
K-NumericAdd-42,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'
K-NumericAdd-60,AssertionError: Expected XPath (xs:untypedAtomic("3") + 3) instance of xs:double to resolve to true: expected false to be true
op-numeric-add-1,Error: XPST0003: Unable to parse XPath: let $result := (          for $x in (1, xs:decimal(2), xs:float(3), xs:double(4), xs:untypedAtomic(5))           for $y in (1, xs:decimal(2), xs:float(3), xs:double(4), xs:untypedAtomic(5))          return ($x + $y)       ) return $result[1] instance of xs:integer. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found.
op-numeric-add-2,Error: XPST0003: Unable to parse XPath: (          declare namespace atomic="http://www.w3.org/XQueryTest";          /*/atomic:integer + /*/atomic:integer       ) instance of xs:integer. SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
op-numeric-add-3,Error: XPST0003: Unable to parse XPath: (          declare namespace atomic="http://www.w3.org/XQueryTest";          /*/atomic:decimal + /*/atomic:integer       ) instance of xs:decimal. SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
op-numeric-add-4,Error: XPST0003: Unable to parse XPath: (          declare namespace atomic="http://www.w3.org/XQueryTest";          /*/atomic:decimal + /*/atomic:float       ) instance of xs:float. SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
op-numeric-add-5,Error: XPST0003: Unable to parse XPath: (          declare namespace atomic="http://www.w3.org/XQueryTest";          /*/atomic:float + /*/atomic:float       ) instance of xs:float. SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
op-numeric-add-6,Error: XPST0003: Unable to parse XPath: (          declare namespace atomic="http://www.w3.org/XQueryTest";          /*/atomic:float + /*/atomic:double       ) instance of xs:double. SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
op-numeric-add-7,Error: XPST0003: Unable to parse XPath: (          declare namespace atomic="http://www.w3.org/XQueryTest";          /*/atomic:decimal/@* + /*/atomic:double       ) instance of xs:double. SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
op-numeric-add-8,Error: XPST0003: Unable to parse XPath: (          declare namespace atomic="http://www.w3.org/XQueryTest";          /*/atomic:double + /*/atomic:double       ) instance of xs:double. SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
op-numeric-add-9,Error: XPST0003: Unable to parse XPath: (          declare namespace atomic="http://www.w3.org/XQueryTest";          /*/atomic:integer + xs:untypedAtomic('123')       ) instance of xs:double. SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
op-numeric-add-10,Error: XPST0003: Unable to parse XPath: (          declare namespace atomic="http://www.w3.org/XQueryTest";          /*/atomic:decimal + xs:untypedAtomic('123')       ) instance of xs:double. SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
op-numeric-add-11,Error: XPST0003: Unable to parse XPath: (          declare namespace atomic="http://www.w3.org/XQueryTest";          /*/atomic:float + xs:untypedAtomic('123')       ) instance of xs:double. SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
op-numeric-add-12,Error: XPST0003: Unable to parse XPath: (          declare namespace atomic="http://www.w3.org/XQueryTest";          /*/atomic:double + xs:untypedAtomic('123')       ) instance of xs:double. SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
op-numeric-equalintg2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalintg2args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalintg2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalintg2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalintg2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalintg2args-6,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalintg2args-7,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalintg2args-8,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalintg2args-9,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalintg2args-10,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equallng2args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equallng2args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equallng2args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equallng2args-4,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equallng2args-5,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equallng2args-6,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equallng2args-7,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equallng2args-8,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equallng2args-9,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equallng2args-10,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnint2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnint2args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnint2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnint2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnint2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnint2args-6,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnint2args-7,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnint2args-8,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnint2args-9,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnint2args-10,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalpint2args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalpint2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalpint2args-4,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalpint2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalpint2args-7,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalpint2args-8,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalpint2args-9,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalpint2args-10,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalulng2args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalulng2args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalulng2args-4,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalulng2args-5,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalulng2args-7,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalulng2args-8,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalulng2args-9,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalulng2args-10,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnpi2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnpi2args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnpi2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnpi2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnpi2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnpi2args-6,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnpi2args-7,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnpi2args-8,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnpi2args-9,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnpi2args-10,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnni2args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnni2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnni2args-4,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnni2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnni2args-7,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnni2args-8,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnni2args-9,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-equalnni2args-10,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-NumericEqual-41,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-NumericEqual-42,Error: XPST0017: Function timezone-from-time with arity of 1 not registered. No similar functions found.
K-NumericEqual-43,Error: XPST0017: Function timezone-from-time with arity of 1 not registered. No similar functions found.
K2-NumericEqual-5,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: 1 eq text {"1"}. SyntaxError: Expected "!", "(", "*", "+", ",", "-", "/", "//", "=>", "and", "cast", "castable", "div", "except", "idiv", "instance", "intersect", "mod", "or", "to", "union", "|", "||", or end of input but "{" found.'
K2-NumericEqual-6,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: text {"1"} eq 1. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
cbcl-numeric-equal-001,Error: XPST0003: Unable to parse XPath:        	declare function local:square($arg as xs:double) as xs:double { $arg * $arg };        	not( local:square(1e0) eq local:square(2e0) ). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-equal-002,Error: XPST0003: Unable to parse XPath:        	declare function local:square($arg as xs:float) as xs:float { $arg * $arg };        	not( local:square(xs:float(1e0)) eq local:square(xs:float(2e0)) ). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-equal-003,Error: XPST0003: Unable to parse XPath:        	declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };        	not( local:square(1.0) eq local:square(2.0) ). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-equal-004,Error: XPST0003: Unable to parse XPath:        	declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };        	not( local:square(1) eq local:square(2) ). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-equal-005,Error: XPST0003: Unable to parse XPath:        	declare function local:square($arg as xs:double) as xs:double { $arg * $arg };        	not( local:square(1e0) ne local:square(2e0) ). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-equal-006,Error: XPST0003: Unable to parse XPath:        	declare function local:square($arg as xs:float) as xs:float { $arg * $arg };        	not( local:square(xs:float(1e0)) ne local:square(xs:float(2e0)) ). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-equal-007,Error: XPST0003: Unable to parse XPath:        	declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };        	not( local:square(1.0) ne local:square(2.0) ). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-equal-008,Error: XPST0003: Unable to parse XPath:        	declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };        	not( local:square(1) ne local:square(2) ). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-equal-009,Error: XPST0003: Unable to parse XPath:        	declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };        	let $x := local:square(4) return 0 eq $x - 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-equal-010,Error: XPST0003: Unable to parse XPath:        	declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };        	let $x := local:square(4) return 0 eq $x + 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-equal-011,Error: XPST0003: Unable to parse XPath:        	declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };        	let $x := local:square(4) return 4 eq $x + 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-equal-012,Error: XPST0003: Unable to parse XPath:        	declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };        	let $x := local:square(4) return 4 eq 1 + $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-equal-013,AssertionError: Expected executing the XPath "       	declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };        	let $x := local:square(4) return -52676506002282294014967032012 eq $x + 52676506002282294014967032012" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath:        	declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };        	let $x := local:square(4) return -52676506002282294014967032012 eq $x + 52676506002282294014967032012. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found., AssertionError: expected [Function] to throw error including 'FOAR0002' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:square($arg as xs:integer) as xs:integer { $arg * $arg }; \n      \tlet $x := local:square(4) return -52676506002282294014967032012 eq $x + 52676506002282294014967032012. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
cbcl-numeric-equal-014,AssertionError: Expected executing the XPath "       	declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };        	let $x := local:square(4) return -52676506002282294014967032012 eq 52676506002282294014967032012 + $x" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath:        	declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };        	let $x := local:square(4) return -52676506002282294014967032012 eq 52676506002282294014967032012 + $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found., AssertionError: expected [Function] to throw error including 'FOAR0002' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:square($arg as xs:integer) as xs:integer { $arg * $arg }; \n      \tlet $x := local:square(4) return -52676506002282294014967032012 eq 52676506002282294014967032012 + $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
cbcl-numeric-equal-015,AssertionError: Expected executing the XPath "       	declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };        	let $x := local:square(4) return 4 eq 1 - $x" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath:        	declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };        	let $x := local:square(4) return 4 eq 1 - $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found., AssertionError: expected [Function] to throw error including 'FOAR0002' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:square($arg as xs:integer) as xs:integer { $arg * $arg }; \n      \tlet $x := local:square(4) return 4 eq 1 - $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
cbcl-numeric-equal-016,Error: XPST0003: Unable to parse XPath:        	declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };        	let $x := local:square(4) return 4 eq $x - 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-equal-017,AssertionError: Expected executing the XPath "       	declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };        	let $x := local:square(4) return -52676506002282294014967032012 eq 52676506002282294014967032012 - $x" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath:        	declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };        	let $x := local:square(4) return -52676506002282294014967032012 eq 52676506002282294014967032012 - $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found., AssertionError: expected [Function] to throw error including 'FOAR0002' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:square($arg as xs:integer) as xs:integer { $arg * $arg }; \n      \tlet $x := local:square(4) return -52676506002282294014967032012 eq 52676506002282294014967032012 - $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
cbcl-numeric-equal-018,AssertionError: Expected executing the XPath "       	declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };        	let $x := local:square(4) return 52676506002282294014967032012 eq $x - 52676506002282294014967032012" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath:        	declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };        	let $x := local:square(4) return 52676506002282294014967032012 eq $x - 52676506002282294014967032012. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found., AssertionError: expected [Function] to throw error including 'FOAR0002' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:square($arg as xs:integer) as xs:integer { $arg * $arg }; \n      \tlet $x := local:square(4) return 52676506002282294014967032012 eq $x - 52676506002282294014967032012. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
op-numeric-divideintg2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-divideintg2args-2,AssertionError: Expected executing the XPath "fn:round-half-to-even((xs:integer("830993497117024304") div xs:integer("-999999999999999999")),18)" to resolve to one of the expected results, but got Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers..
op-numeric-divideintg2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-divideintg2args-4,AssertionError: Expected executing the XPath "fn:round-half-to-even((xs:integer("-999999999999999999") div xs:integer("830993497117024304")),18)" to resolve to one of the expected results, but got Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers..
op-numeric-divideintg2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-divideintg2args-6,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-dividelng2args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-dividelng2args-2,AssertionError: Expected executing the XPath "fn:round-half-to-even((xs:long("-47175562203048468") div xs:long("-92233720368547758")),17)" to resolve to one of the expected results, but got Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers..
op-numeric-dividelng2args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-dividelng2args-4,AssertionError: Expected executing the XPath "fn:round-half-to-even((xs:long("-92233720368547758") div xs:long("-47175562203048468")),17)" to resolve to one of the expected results, but got Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers..
op-numeric-dividelng2args-5,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-dividenint2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-dividenint2args-2,AssertionError: Expected executing the XPath "fn:round-half-to-even((xs:negativeInteger("-297014075999096793") div xs:negativeInteger("-999999999999999999")),18)" to resolve to one of the expected results, but got Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers..
op-numeric-dividenint2args-3,AssertionError: Expected executing the XPath "xs:negativeInteger("-1") div xs:negativeInteger("-999999999999999999")" to resolve to one of the expected results, but got Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers..
op-numeric-dividenint2args-4,AssertionError: Expected executing the XPath "fn:round-half-to-even((xs:negativeInteger("-999999999999999999") div xs:negativeInteger("-297014075999096793")),18)" to resolve to one of the expected results, but got Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers..
op-numeric-dividenint2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-dividepint2args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-dividepint2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-dividepint2args-4,AssertionError: Expected executing the XPath "fn:round-half-to-even((xs:positiveInteger("1") div xs:positiveInteger("52704602390610033")),17)" to resolve to one of the expected results, but got Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers..
op-numeric-dividepint2args-5,AssertionError: Expected executing the XPath "xs:positiveInteger("1") div xs:positiveInteger("999999999999999999")" to resolve to one of the expected results, but got Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers..
op-numeric-divideulng2args-1,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-divideulng2args-2,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-dividenpi2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-dividenpi2args-2,AssertionError: Expected executing the XPath "fn:round-half-to-even((xs:nonPositiveInteger("-475688437271870490") div xs:nonPositiveInteger("-999999999999999999")),18)" to resolve to one of the expected results, but got Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers..
op-numeric-dividenpi2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-dividenpi2args-4,AssertionError: Expected executing the XPath "fn:round-half-to-even((xs:nonPositiveInteger("-999999999999999999") div xs:nonPositiveInteger("-475688437271870490")),18)" to resolve to one of the expected results, but got Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers., Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers..
op-numeric-dividenni2args-1,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-dividenni2args-2,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-NumericDivide-20,AssertionError: Expected XPath (xs:float(6) div xs:decimal(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericDivide-21,AssertionError: Expected XPath (xs:decimal(6) div xs:float(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericDivide-22,AssertionError: Expected XPath (xs:float(6) div xs:integer(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericDivide-23,AssertionError: Expected XPath (xs:integer(6) div xs:float(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericDivide-24,AssertionError: Expected XPath (xs:float(6) div xs:float(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericDivide-25,AssertionError: Expected XPath (xs:decimal(6) div xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericDivide-26,AssertionError: Expected XPath (xs:double(6) div xs:decimal(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericDivide-27,AssertionError: Expected XPath (xs:double(6) div xs:float(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericDivide-28,AssertionError: Expected XPath (xs:float(6) div xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericDivide-29,AssertionError: Expected XPath (xs:double(6) div xs:integer(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericDivide-30,AssertionError: Expected XPath (xs:integer(6) div xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericDivide-31,AssertionError: Expected XPath (xs:double(6) div xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K2-NumericDivide-1,AssertionError: expected [Function] to throw an error
K2-NumericDivide-2,AssertionError: expected [Function] to throw an error
K2-NumericDivide-3,AssertionError: expected [Function] to throw an error
K2-NumericDivide-4,AssertionError: expected [Function] to throw an error
K2-NumericDivide-5,AssertionError: 1 div 0e0: expected 'Infinity' to equal 'INF'
K2-NumericDivide-6,AssertionError: -1 div 0e0: expected '-Infinity' to equal '-INF'
K2-NumericDivide-7,AssertionError: 1 div xs:float(0): expected 'Infinity' to equal 'INF'
K2-NumericDivide-8,AssertionError: -1 div xs:float(0): expected '-Infinity' to equal '-INF'
K2-NumericDivide-13,AssertionError: +3 div +0e0: expected 'Infinity' to equal 'INF'
K2-NumericDivide-14,AssertionError: -3 div +0e0: expected '-Infinity' to equal '-INF'
K2-NumericDivide-15,AssertionError: +3 div -0e0: expected '-Infinity' to equal '-INF'
K2-NumericDivide-16,AssertionError: -3 div -0e0: expected 'Infinity' to equal 'INF'
op-numeric-divide-1,Error: XPST0017: Function error with arity of 0 not registered. No similar functions found.
cbcl-numeric-divide-001,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:double) as xs:double { $arg * $arg };        	xs:double('NaN') div local:square(7)       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-divide-002,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:double) as xs:double { $arg * $arg };        	local:square(7) div xs:double('NaN')       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-divide-003,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:double) as xs:double { $arg * $arg };        	local:square(7) div 1e0       	)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-divide-004,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:double) as xs:double { $arg * $arg };        	local:square(7) div -1e0       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-divide-005,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:float) as xs:float { $arg * $arg };        	xs:float('NaN') div local:square(7)       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-divide-006,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:float) as xs:float { $arg * $arg };        	local:square(7) div xs:float('NaN')       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-divide-007,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:float) as xs:float { $arg * $arg };        	local:square(7) div xs:float(1)       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-divide-008,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:float) as xs:float { $arg * $arg };        	local:square(7) div xs:float(-1)       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-divide-009,AssertionError: expected [Function] to throw error including 'FOAR0001' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg }; \n      \tlocal:square(2.0) div 0.0\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
cbcl-numeric-divide-010,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };        	local:square(7.0) div 1.0       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-divide-011,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };        	local:square(7.0) div -1.0       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-divide-012,AssertionError: expected [Function] to throw error including 'FOAR0001' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:square($arg as xs:integer) as xs:integer { $arg * $arg }; \n      \tlocal:square(2) div 0\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
cbcl-numeric-divide-013,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };        	local:square(7) div 1       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-divide-014,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };        	local:square(7) div -1       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
op-numeric-divide-big-01,AssertionError: Expected executing the XPath "(10000000000000000000000000000.0 div 0.1) cast as xs:string" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw an error, AssertionError: (10000000000000000000000000000.0 div 0.1) cast as xs:string: expected '1E+29' to equal '100000000000000000000000000000'.
op-numeric-greater-thanintg2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thanintg2args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thanintg2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thanintg2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thanintg2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thanlng2args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thanlng2args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thanlng2args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thanlng2args-4,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thanlng2args-5,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thannint2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thannint2args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thannint2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thannint2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thannint2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thanpint2args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thanpint2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thanpint2args-4,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thanpint2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thanulng2args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thanulng2args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thanulng2args-4,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thanulng2args-5,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thannpi2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thannpi2args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thannpi2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thannpi2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thannpi2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thannni2args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thannni2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thannni2args-4,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-greater-thannni2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-NumericGT-21,Error: XPST0017: Function timezone-from-time with arity of 1 not registered. No similar functions found.
K-NumericGT-22,Error: XPST0017: Function timezone-from-time with arity of 1 not registered. No similar functions found.
K-NumericGT-23,Error: XPST0017: Function timezone-from-time with arity of 1 not registered. No similar functions found.
K2-NumericGT-1,Error: FOCA0003: can not cast 18446744073709551615 to xs:integer, it is out of bounds for JavaScript numbers.
K2-NumericGT-2,Error: FOCA0003: can not cast 18446744073709551615 to xs:integer, it is out of bounds for JavaScript numbers.
cbcl-numeric-greater-than-001,Error: XPST0003: Unable to parse XPath: declare function local:square($arg as xs:double) as xs:double { $arg * $arg }; not( local:square(1e0) gt local:square(2e0) ). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-greater-than-002,Error: XPST0003: Unable to parse XPath: declare function local:square($arg as xs:float) as xs:float { $arg * $arg }; not( local:square(xs:float(1e0)) gt local:square(xs:float(2e0)) ). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-greater-than-003,Error: XPST0003: Unable to parse XPath: declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg }; not( local:square(1.0) gt local:square(2.0) ). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-greater-than-004,Error: XPST0003: Unable to parse XPath: declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg }; not( local:square(1) gt local:square(2) ). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-greater-than-005,Error: XPST0003: Unable to parse XPath: declare function local:square($arg as xs:double) as xs:double { $arg * $arg }; not( local:square(1e0) le local:square(2e0) ). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-greater-than-006,Error: XPST0003: Unable to parse XPath: declare function local:square($arg as xs:float) as xs:float { $arg * $arg }; not( local:square(xs:float(1e0)) le local:square(xs:float(2e0)) ). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-greater-than-007,Error: XPST0003: Unable to parse XPath: declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg }; not( local:square(1.0) le local:square(2.0) ). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-greater-than-008,Error: XPST0003: Unable to parse XPath: declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg }; not( local:square(1) le local:square(2) ). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-greater-than-009,Error: XPST0003: Unable to parse XPath: declare function local:square($arg as xs:double) as xs:double { $arg * $arg }; not(not( local:square(1e0) gt local:square(2e0) )). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-greater-than-010,Error: XPST0003: Unable to parse XPath: declare function local:square($arg as xs:float) as xs:float { $arg * $arg }; not(not( local:square(xs:float(1e0)) gt local:square(xs:float(2e0)) )). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-greater-than-011,Error: XPST0003: Unable to parse XPath: declare function local:square($arg as xs:double) as xs:double { $arg * $arg }; not(not( local:square(1e0) le local:square(2e0) )). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-greater-than-012,Error: XPST0003: Unable to parse XPath: declare function local:square($arg as xs:float) as xs:float { $arg * $arg }; not(not( local:square(xs:float(1e0)) le local:square(xs:float(2e0)) )). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-greater-than-013,Error: XPST0003: Unable to parse XPath: declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x + 1 gt 121. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-greater-than-014,Error: XPST0003: Unable to parse XPath: declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x - 1 gt 121. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-greater-than-015,Error: XPST0003: Unable to parse XPath: declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 gt $x + 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-greater-than-016,Error: XPST0003: Unable to parse XPath: declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 gt 1 + $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-greater-than-017,Error: XPST0003: Unable to parse XPath: declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x + 1 le 121. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-greater-than-018,Error: XPST0003: Unable to parse XPath: declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x - 1 le 121. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-greater-than-019,Error: XPST0003: Unable to parse XPath: declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 le $x + 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-greater-than-020,Error: XPST0003: Unable to parse XPath: declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 le 1 + $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-greater-than-021,Error: XPST0003: Unable to parse XPath: declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 gt $x - 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-greater-than-022,Error: XPST0003: Unable to parse XPath: declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 1 + $x gt 121. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-greater-than-023,Error: XPST0003: Unable to parse XPath: declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 1 + $x le 121. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-greater-than-024,Error: XPST0003: Unable to parse XPath: declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 le $x - 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
op-numeric-integer-divideintg2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-divideintg2args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-divideintg2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-divideintg2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-divideintg2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividelng2args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividelng2args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividelng2args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividelng2args-4,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividelng2args-5,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividenint2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividenint2args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividenint2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividenint2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividenint2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividepint2args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividepint2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividepint2args-4,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividepint2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-divideulng2args-1,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-divideulng2args-2,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividenpi2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividenpi2args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividenpi2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividenpi2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividenni2args-1,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividenni2args-2,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-integer-dividemix2args-10,AssertionError: expected [Function] to throw an error
op-numeric-integer-divide-1,AssertionError: expected [Function] to throw an error
K-NumericIntegerDivide-31,AssertionError: expected [Function] to throw an error
K-NumericIntegerDivide-32,AssertionError: expected [Function] to throw an error
K-NumericIntegerDivide-33,AssertionError: expected [Function] to throw an error
K-NumericIntegerDivide-34,AssertionError: expected [Function] to throw an error
K-NumericIntegerDivide-37,AssertionError: expected [Function] to throw an error
K-NumericIntegerDivide-38,AssertionError: expected [Function] to throw an error
K-NumericIntegerDivide-39,AssertionError: expected [Function] to throw an error
K-NumericIntegerDivide-40,AssertionError: expected [Function] to throw an error
K2-NumericIntegerDivide-1,AssertionError: expected [Function] to throw an error
K2-NumericIntegerDivide-2,AssertionError: expected [Function] to throw an error
K2-NumericIntegerDivide-3,AssertionError: expected [Function] to throw an error
K2-NumericIntegerDivide-4,AssertionError: expected [Function] to throw an error
K2-NumericIntegerDivide-5,AssertionError: expected [Function] to throw an error
K2-NumericIntegerDivide-6,AssertionError: expected [Function] to throw an error
K2-NumericIntegerDivide-7,AssertionError: expected [Function] to throw an error
K2-NumericIntegerDivide-8,AssertionError: expected [Function] to throw an error
op-numeric-integer-dividefloat2args-1,AssertionError: expected [Function] to throw an error
op-numeric-integer-dividefloat2args-2,AssertionError: expected [Function] to throw an error
op-numeric-integer-dividefloat2args-3,AssertionError: expected [Function] to throw an error
op-numeric-integer-dividefloat2args-4,AssertionError: expected [Function] to throw an error
op-numeric-integer-dividedouble2args-1,AssertionError: expected [Function] to throw an error
op-numeric-integer-dividedouble2args-2,AssertionError: expected [Function] to throw an error
op-numeric-integer-dividedouble2args-3,AssertionError: expected [Function] to throw an error
op-numeric-integer-dividedouble2args-4,AssertionError: expected [Function] to throw an error
cbcl-numeric-idivide-001,AssertionError: Expected executing the XPath "       	declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };        	local:square(4294967296.0) idiv 0.0000000000005 gt 0" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath:        	declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };        	local:square(4294967296.0) idiv 0.0000000000005 gt 0. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found., AssertionError: expected [Function] to throw error including 'FOAR0002' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg }; \n      \tlocal:square(4294967296.0) idiv 0.0000000000005 gt 0. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
cbcl-numeric-idivide-002,AssertionError: Expected executing the XPath "       	declare function local:square($arg as xs:double) as xs:double { $arg * $arg };        	local:square(1e100) idiv 5e-100" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FOAR0002' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:square($arg as xs:double) as xs:double { $arg * $arg }; \n      \tlocal:square(1e100) idiv 5e-100. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.', Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:double) as xs:double { $arg * $arg };        	local:square(1e100) idiv 5e-100) instance of xs:integer. SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found..
cbcl-numeric-idivide-003,AssertionError: expected [Function] to throw error including 'FOAR0002' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:square($arg as xs:float) as xs:float { $arg * $arg }; \n      \tlocal:square(xs:float(1e30)) idiv xs:float(5e-30). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
cbcl-numeric-idivide-004,Error: XPST0003: Unable to parse XPath:        	declare function local:integer($x as xs:decimal) { if ($x mod 1 eq 0) then xs:integer($x) else $x };       	 (local:integer(2) idiv local:integer(2)) instance of xs:integer. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-idivide-008,AssertionError: Expected executing the XPath "xs:float('1e38') idiv xs:float('1e-37')" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw an error, AssertionError: expected [Function] to throw an error, Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found..
cbcl-numeric-idivide-009,AssertionError: Expected executing the XPath "       	declare function local:value($number as xs:boolean) { if ($number) then 1 else xs:string('1') };        	local:value(true()) idiv local:value(true())       " to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (       	declare function local:value($number as xs:boolean) { if ($number) then 1 else xs:string('1') };        	local:value(true()) idiv local:value(true())       ) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:value($number as xs:boolean) { if ($number) then 1 else xs:string(\'1\') }; \n      \tlocal:value(true()) idiv local:value(true())\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
op-numeric-less-thanintg2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanintg2args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanintg2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanintg2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanintg2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanintg2args-6,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanintg2args-7,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanintg2args-8,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanintg2args-9,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanintg2args-10,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanlng2args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanlng2args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanlng2args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanlng2args-4,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanlng2args-5,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanlng2args-6,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanlng2args-7,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanlng2args-8,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanlng2args-9,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanlng2args-10,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannint2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannint2args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannint2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannint2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannint2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannint2args-6,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannint2args-7,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannint2args-8,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannint2args-9,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannint2args-10,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanpint2args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanpint2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanpint2args-4,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanpint2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanpint2args-7,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanpint2args-8,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanpint2args-9,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanpint2args-10,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanulng2args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanulng2args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanulng2args-4,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanulng2args-5,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanulng2args-7,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanulng2args-8,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanulng2args-9,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thanulng2args-10,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannpi2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannpi2args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannpi2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannpi2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannpi2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannpi2args-6,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannpi2args-7,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannpi2args-8,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannpi2args-9,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannpi2args-10,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannni2args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannni2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannni2args-4,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannni2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannni2args-7,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannni2args-8,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannni2args-9,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-less-thannni2args-10,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-NumericLT-21,Error: XPST0017: Function timezone-from-time with arity of 1 not registered. No similar functions found.
K-NumericLT-22,Error: XPST0017: Function timezone-from-time with arity of 1 not registered. No similar functions found.
K2-NumericLT-1,Error: FOCA0003: can not cast 18446744073709551615 to xs:integer, it is out of bounds for JavaScript numbers.
K2-NumericLT-2,Error: FOCA0003: can not cast 18446744073709551615 to xs:integer, it is out of bounds for JavaScript numbers.
cbcl-numeric-less-than-001,Error: XPST0003: Unable to parse XPath: declare function local:square($arg as xs:double) as xs:double { $arg * $arg }; not( local:square(1e0) lt local:square(2e0) ). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-less-than-002,Error: XPST0003: Unable to parse XPath: declare function local:square($arg as xs:float) as xs:float { $arg * $arg }; not( local:square(xs:float(1e0)) lt local:square(xs:float(2e0)) ). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-less-than-003,Error: XPST0003: Unable to parse XPath: declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg }; not( local:square(1.0) lt local:square(2.0) ). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-less-than-004,Error: XPST0003: Unable to parse XPath: declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg }; not( local:square(1) lt local:square(2) ). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-less-than-005,Error: XPST0003: Unable to parse XPath: declare function local:square($arg as xs:double) as xs:double { $arg * $arg }; not( local:square(1e0) ge local:square(2e0) ). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-less-than-006,Error: XPST0003: Unable to parse XPath: declare function local:square($arg as xs:float) as xs:float { $arg * $arg }; not( local:square(xs:float(1e0)) ge local:square(xs:float(2e0)) ). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-less-than-007,Error: XPST0003: Unable to parse XPath: declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg }; not( local:square(1.0) ge local:square(2.0) ). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-less-than-008,Error: XPST0003: Unable to parse XPath: declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg }; not( local:square(1) ge local:square(2) ). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-less-than-009,Error: XPST0003: Unable to parse XPath: declare function local:square($arg as xs:double) as xs:double { $arg * $arg }; not(not( local:square(1e0) lt local:square(2e0) )). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-less-than-010,Error: XPST0003: Unable to parse XPath: declare function local:square($arg as xs:float) as xs:float { $arg * $arg }; not(not( local:square(xs:float(1e0)) lt local:square(xs:float(2e0)) )). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-less-than-011,Error: XPST0003: Unable to parse XPath: declare function local:square($arg as xs:double) as xs:double { $arg * $arg }; not(not( local:square(1e0) ge local:square(2e0) )). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-less-than-012,Error: XPST0003: Unable to parse XPath: declare function local:square($arg as xs:float) as xs:float { $arg * $arg }; not(not( local:square(xs:float(1e0)) ge local:square(xs:float(2e0)) )). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-less-than-013,Error: XPST0003: Unable to parse XPath: declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x + 1 lt 121. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-less-than-014,Error: XPST0003: Unable to parse XPath: declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x - 1 lt 121. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-less-than-015,Error: XPST0003: Unable to parse XPath: declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 lt $x + 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-less-than-016,Error: XPST0003: Unable to parse XPath: declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 lt 1 + $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-less-than-017,Error: XPST0003: Unable to parse XPath: declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x + 1 ge 121. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-less-than-018,Error: XPST0003: Unable to parse XPath: declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x - 1 ge 121. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-less-than-019,Error: XPST0003: Unable to parse XPath: declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 ge $x + 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-less-than-020,Error: XPST0003: Unable to parse XPath: declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 ge 1 + $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-less-than-021,Error: XPST0003: Unable to parse XPath: declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x + 2 lt 121. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-less-than-022,Error: XPST0003: Unable to parse XPath: declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x - 2 lt 12. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-less-than-023,Error: XPST0003: Unable to parse XPath: declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 lt $x + 2. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-less-than-024,Error: XPST0003: Unable to parse XPath: declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 lt 2 + $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-less-than-025,Error: XPST0003: Unable to parse XPath: declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x + 2 ge 121. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-less-than-026,Error: XPST0003: Unable to parse XPath: declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x - 2 ge 12. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-less-than-027,Error: XPST0003: Unable to parse XPath: declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 ge $x + 2. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-less-than-028,Error: XPST0003: Unable to parse XPath: declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 ge $x + 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-less-than-029,Error: XPST0003: Unable to parse XPath: declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 ge 2 + $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
op-numeric-modintg2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-modintg2args-2,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-modlng2args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-modpint2args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-modpint2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-modpint2args-4,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-modpint2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-modulng2args-1,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-modulng2args-2,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-modnni2args-1,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-modnni2args-2,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-NumericMod-3,AssertionError: Expected XPath (xs:integer(6) mod xs:integer(2)) instance of xs:integer to resolve to true: expected false to be true
K-NumericMod-5,AssertionError: Expected XPath (xs:decimal(6) mod xs:float(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericMod-6,AssertionError: Expected XPath (xs:float(6) mod xs:decimal(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericMod-7,AssertionError: Expected XPath (xs:float(6) mod xs:integer(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericMod-8,AssertionError: Expected XPath (xs:integer(6) mod xs:float(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericMod-9,AssertionError: Expected XPath (xs:float(6) mod xs:float(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericMod-10,AssertionError: Expected XPath (xs:decimal(6) mod xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericMod-11,AssertionError: Expected XPath (xs:double(6) mod xs:decimal(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericMod-12,AssertionError: Expected XPath (xs:double(6) mod xs:float(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericMod-13,AssertionError: Expected XPath (xs:float(6) mod xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericMod-14,AssertionError: Expected XPath (xs:double(6) mod xs:integer(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericMod-15,AssertionError: Expected XPath (xs:integer(6) mod xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericMod-16,AssertionError: Expected XPath (xs:double(6) mod xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericMod-19,AssertionError: Expected XPath 4.5 mod 1.2 eq 0.9 to resolve to true: expected false to be true
K2-NumericMod-59,AssertionError: expected [Function] to throw an error
K2-NumericMod-60,AssertionError: expected [Function] to throw an error
K2-NumericMod-61,AssertionError: expected [Function] to throw an error
op-numeric-mod-1,Error: XPST0003: Unable to parse XPath: let $result := (          for $x in (1, xs:decimal(2), xs:float(3), xs:double(4), xs:untypedAtomic(5))           for $y in (1, xs:decimal(2), xs:float(3), xs:double(4), xs:untypedAtomic(5))          return ($x mod $y)       ) return $result[1] instance of xs:integer. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-mod-001,Error: XPST0003: Unable to parse XPath:        	declare function local:integer($x as xs:decimal) { if ($x mod 1 eq 0) then xs:integer($x) else $x };        	(local:integer(3) mod local:integer(2)) instance of xs:integer. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-mod-002,Error: XPST0003: Unable to parse XPath:        	declare function local:integer($x as xs:decimal) { if ($x mod 1 eq 0) then xs:integer($x) else $x };        	(local:integer(3.5) mod local:integer(2)) instance of xs:integer. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-mod-003,AssertionError: Expected executing the XPath "       	declare function local:value($number as xs:boolean) { if ($number) then 1 else xs:string('1') };        	local:value(true()) mod local:value(true())" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (       	declare function local:value($number as xs:boolean) { if ($number) then 1 else xs:string('1') };        	local:value(true()) mod local:value(true()))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:value($number as xs:boolean) { if ($number) then 1 else xs:string(\'1\') }; \n      \tlocal:value(true()) mod local:value(true()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
op-numeric-multiplypint2args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-multiplypint2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-multiplypint2args-4,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-multiplypint2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-multiplyulng2args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-multiplyulng2args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-multiplyulng2args-4,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-multiplyulng2args-5,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-multiplynpi2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-multiplynpi2args-2,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-multiplynni2args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-multiplynni2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-multiplynni2args-4,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-multiplynni2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-NumericMultiply-7,AssertionError: Expected XPath (xs:integer(6) * xs:integer(2)) instance of xs:integer to resolve to true: expected false to be true
K-NumericMultiply-9,AssertionError: Expected XPath (xs:decimal(6) * xs:float(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericMultiply-10,AssertionError: Expected XPath (xs:float(6) * xs:decimal(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericMultiply-11,AssertionError: Expected XPath (xs:float(6) * xs:integer(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericMultiply-12,AssertionError: Expected XPath (xs:integer(6) * xs:float(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericMultiply-13,AssertionError: Expected XPath (xs:float(6) * xs:float(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericMultiply-14,AssertionError: Expected XPath (xs:decimal(6) * xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericMultiply-15,AssertionError: Expected XPath (xs:double(6) * xs:decimal(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericMultiply-16,AssertionError: Expected XPath (xs:double(6) * xs:float(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericMultiply-17,AssertionError: Expected XPath (xs:float(6) * xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericMultiply-18,AssertionError: Expected XPath (xs:double(6) * xs:integer(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericMultiply-19,AssertionError: Expected XPath (xs:integer(6) * xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericMultiply-20,AssertionError: Expected XPath (xs:double(6) * xs:double(2)) instance of xs:double to resolve to true: expected false to be true
op-numeric-multiply-1,Error: XPST0003: Unable to parse XPath: let $result := (          for $x in (1, xs:decimal(2), xs:float(3), xs:double(4), xs:untypedAtomic(5))           for $y in (1, xs:decimal(2), xs:float(3), xs:double(4), xs:untypedAtomic(5))          return ($x * $y)       ) return $result[1] instance of xs:integer. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-multiply-001,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:double) as xs:double { $arg * $arg };        	xs:double('NaN') * local:square(7))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-multiply-002,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:double) as xs:double { $arg * $arg };        	local:square(7) * xs:double('NaN'))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-multiply-003,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:double) as xs:double { $arg * $arg };        	local:square(7) * 1e0)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-multiply-004,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:double) as xs:double { $arg * $arg };        	1e0 * local:square(7))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-multiply-005,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:double) as xs:double { $arg * $arg };        	local:square(7) * -1e0)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-multiply-006,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:double) as xs:double { $arg * $arg };        	-1e0 * local:square(7))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-multiply-007,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:float) as xs:float { $arg * $arg };        	xs:float('NaN') * local:square(7))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-multiply-008,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:float) as xs:float { $arg * $arg };        	local:square(7) * xs:float('NaN'))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-multiply-009,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:float) as xs:float { $arg * $arg };        	local:square(7) * xs:float(1))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-multiply-010,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:float) as xs:float { $arg * $arg };        	xs:float(1) * local:square(7))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-multiply-011,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:float) as xs:float { $arg * $arg };        	local:square(7) * xs:float(-1))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-multiply-012,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:float) as xs:float { $arg * $arg };        	xs:float(-1) * local:square(7))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-multiply-013,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };        	local:square(2.0) * 0.0)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-multiply-014,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };        	0.0 * local:square(7.0))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-multiply-015,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };        	local:square(7.0) * 1.0)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-multiply-016,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };        	1.0 * local:square(7.0))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-multiply-017,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };        	local:square(7.0) * -1.0)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-multiply-018,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };        	-1.0 * local:square(7.0))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-multiply-019,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };        	local:square(2) * 0)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-multiply-020,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };        	0 * local:square(2))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-multiply-021,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };        	local:square(7) * 1)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-multiply-022,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };        	1 * local:square(7))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-multiply-023,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };        	local:square(7) * -1)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-multiply-024,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };        	-1 * local:square(7))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-multiply-025,AssertionError: Expected executing the XPath "       	declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };        	local:square(9223372036854775808.1) gt 0" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath:        	declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };        	local:square(9223372036854775808.1) gt 0. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found., AssertionError: expected [Function] to throw error including 'FOAR0002' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg }; \n      \tlocal:square(9223372036854775808.1) gt 0. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
cbcl-numeric-multiply-026,AssertionError: Expected executing the XPath "       	declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };        	local:square(9223372036854775808) gt 0" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath:        	declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };        	local:square(9223372036854775808) gt 0. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found., AssertionError: expected [Function] to throw error including 'FOAR0002' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:square($arg as xs:integer) as xs:integer { $arg * $arg }; \n      \tlocal:square(9223372036854775808) gt 0. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
cbcl-numeric-multiply-027,Error: XPST0003: Unable to parse XPath:        	declare function local:integer($x as xs:decimal) { if ($x mod 1 eq 0) then xs:integer($x) else $x };        	(local:integer(2) * local:integer(2)) instance of xs:integer. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
op-numeric-subtractintg2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractintg2args-2,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractintg2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractintg2args-4,Error: FOCA0003: can not cast -169006502882975695 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractintg2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractlng2args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractlng2args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractlng2args-3,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractlng2args-4,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractlng2args-5,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractnint2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractnint2args-2,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractpint2args-1,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractpint2args-2,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractpint2args-3,Error: FOCA0003: can not cast 52704602390610034 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractulng2args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractulng2args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractulng2args-4,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractulng2args-5,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractnpi2args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractnpi2args-2,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractnpi2args-3,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractnpi2args-4,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractnpi2args-5,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractnni2args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractnni2args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractnni2args-4,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-subtractnni2args-5,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-NumericSubtract-7,AssertionError: Expected XPath (xs:integer(6) - xs:integer(2)) instance of xs:integer to resolve to true: expected false to be true
K-NumericSubtract-9,AssertionError: Expected XPath (xs:decimal(6) - xs:float(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericSubtract-10,AssertionError: Expected XPath (xs:float(6) - xs:decimal(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericSubtract-11,AssertionError: Expected XPath (xs:float(6) - xs:integer(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericSubtract-12,AssertionError: Expected XPath (xs:integer(6) - xs:float(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericSubtract-13,AssertionError: Expected XPath (xs:float(6) - xs:float(2)) instance of xs:float to resolve to true: expected false to be true
K-NumericSubtract-14,AssertionError: Expected XPath (xs:decimal(6) - xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericSubtract-15,AssertionError: Expected XPath (xs:double(6) - xs:decimal(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericSubtract-16,AssertionError: Expected XPath (xs:double(6) - xs:float(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericSubtract-17,AssertionError: Expected XPath (xs:float(6) - xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericSubtract-18,AssertionError: Expected XPath (xs:double(6) - xs:integer(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericSubtract-19,AssertionError: Expected XPath (xs:integer(6) - xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericSubtract-20,AssertionError: Expected XPath (xs:double(6) - xs:double(2)) instance of xs:double to resolve to true: expected false to be true
K-NumericSubtract-33,AssertionError: Expected XPath (xs:untypedAtomic("3") - xs:untypedAtomic("3")) instance of xs:double to resolve to true: expected false to be true
K-NumericSubtract-34,AssertionError: Expected XPath (xs:untypedAtomic("3") - 1.1) instance of xs:double to resolve to true: expected false to be true
K-NumericSubtract-35,AssertionError: Expected XPath (1.1 - xs:untypedAtomic("3")) instance of xs:double to resolve to true: expected false to be true
K-NumericSubtract-36,AssertionError: Expected executing the XPath "1 eq (remove((current-time(), 1), 1) - 0)" to resolve to one of the expected results, but got Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function current-time with arity of 0 not registered. No similar functions found.'.
K-NumericSubtract-37,AssertionError: Expected executing the XPath "1 eq (remove((current-time(), 1), 1) + 0)" to resolve to one of the expected results, but got Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function current-time with arity of 0 not registered. No similar functions found.'.
K-NumericSubtract-38,AssertionError: Expected executing the XPath "1 eq (0 + remove((current-time(), 1), 1))" to resolve to one of the expected results, but got Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function current-time with arity of 0 not registered. No similar functions found.'.
op-numeric-subtract-1,Error: XPST0003: Unable to parse XPath: let $result := (          for $x in (1, xs:decimal(2), xs:float(3), xs:double(4), xs:untypedAtomic(5))           for $y in (1, xs:decimal(2), xs:float(3), xs:double(4), xs:untypedAtomic(5))          return ($x - $y)       ) return $result[1] instance of xs:integer. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-subtract-003,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };        	local:square(7.5) - 0.0)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-subtract-004,Error: XPST0003: Unable to parse XPath: (       	declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };        	local:square(7) - 0)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-subtract-005,Error: XPST0003: Unable to parse XPath:        	declare function local:integer($x as xs:decimal) { if ($x mod 1 eq 0) then xs:integer($x) else $x };        	(local:integer(2) - local:integer(2)) instance of xs:integer. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-numeric-subtract-006,Error: XPST0003: Unable to parse XPath: (       	declare function local:integer($x as xs:decimal) { if ($x mod 1 eq 0) then xs:integer($x) else $x };        	-(local:integer(2)) - -(local:integer(4)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-subtract-007,Error: XPST0003: Unable to parse XPath: (       	declare function local:integer($x as xs:decimal) { if ($x mod 1 eq 0) then xs:integer($x) else $x };        	local:integer(2) - -(local:integer(4)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-numeric-subtract-008,Error: XPST0003: Unable to parse XPath: (       	declare function local:integer($x as xs:decimal) { if ($x mod 1 eq 0) then xs:integer($x) else $x };        	-(local:integer(2)) - local:integer(4))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
op-numeric-subtract-big-01,AssertionError: Expected executing the XPath "(-79228162514264337593543950335.0 - 1.0) cast as xs:string" to resolve to one of the expected results, but got AssertionError: (-79228162514264337593543950335.0 - 1.0) cast as xs:string: expected '-7.922816251426434E+28' to equal '-79228162514264337593543950336', AssertionError: expected [Function] to throw an error.
op-numeric-unary-minusintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-minusintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-minusintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-minuslng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-minuslng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-minuslng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-minusnint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-minusnint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-minuspint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-minuspint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-minusulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-minusulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-minusnpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-minusnpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-minusnni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-minusnni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-NumericUnaryMinus-1,AssertionError: expected [Function] to throw an error
K2-NumericUnaryMinus-8,Error: XPST0003: Unable to parse XPath: empty(document{()}/(-element())). SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
cbcl-numeric-unary-minus-001,AssertionError: Expected executing the XPath "declare function local:value($number as xs:boolean) { if ($number) then 1 else xs:string('1') }; -(local:value(true()))" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare function local:value($number as xs:boolean) { if ($number) then 1 else xs:string('1') }; -(local:value(true())))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare function local:value($number as xs:boolean) { if ($number) then 1 else xs:string(\'1\') }; -(local:value(true())). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
op-numeric-unary-plusintg1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-plusintg1args-2,Error: FOCA0003: can not cast 830993497117024304 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-plusintg1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-pluslng1args-1,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-pluslng1args-2,Error: FOCA0003: can not cast -47175562203048468 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-pluslng1args-3,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-plusnint1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-plusnint1args-2,Error: FOCA0003: can not cast -297014075999096793 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-pluspint1args-2,Error: FOCA0003: can not cast 52704602390610033 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-pluspint1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-plusulng1args-2,Error: FOCA0003: can not cast 130747108607674654 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-plusulng1args-3,Error: FOCA0003: can not cast 184467440737095516 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-plusnpi1args-1,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-plusnpi1args-2,Error: FOCA0003: can not cast -475688437271870490 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-plusnni1args-2,Error: FOCA0003: can not cast 303884545991464527 to xs:integer, it is out of bounds for JavaScript numbers.
op-numeric-unary-plusnni1args-3,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K-NumericUnaryPlus-1,AssertionError: expected [Function] to throw an error
K2-NumericUnaryPlus-1,Error: XPST0003: Unable to parse XPath: empty(document{()}/(+element())). SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
cbcl-numeric-unary-plus-001,AssertionError: Expected executing the XPath "       	declare function local:value($number as xs:boolean) { if ($number) then 1 else xs:string('1') };        	+(local:value(true()))" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (       	declare function local:value($number as xs:boolean) { if ($number) then 1 else xs:string('1') };        	+(local:value(true())))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:value($number as xs:boolean) { if ($number) then 1 else xs:string(\'1\') }; \n      \t+(local:value(true())). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
cbcl-QName-equal-001,Error: XPST0003: Unable to parse XPath:          declare function local:QName-value($arg as xs:boolean) as xs:QName { if ($arg) then QName("example.com/", "p:ncname") else QName("example.com/", "q:ncname") };         not(local:QName-value(true()) eq local:QName-value(false())). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-QName-equal-002,Error: XPST0003: Unable to parse XPath:          declare function local:QName-value($arg as xs:boolean) as xs:QName { if ($arg) then QName("example.com/", "p:ncname") else QName("example.com/", "q:ncname") };         not(local:QName-value(true()) ne local:QName-value(false())). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
K2-StringEqual-1,Error: XPST0003: Unable to parse XPath: declare variable $vA as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string; declare variable $vB as xs:string := ("b string", current-time(), string(<e>content</e>))[1] treat as xs:string; (lower-case($vA) eq lower-case($vB)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-StringEqual-2,Error: XPST0003: Unable to parse XPath: declare variable $vA as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string; declare variable $vB as xs:string := ("b string", current-time(), string(<e>content</e>))[1] treat as xs:string; (upper-case($vA) eq upper-case($vB)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-StringEqual-3,Error: XPST0003: Unable to parse XPath: declare variable $vA as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string; declare variable $vB as xs:string := ("no match", current-time(), string(<e>content</e>))[1] treat as xs:string; (lower-case($vA) eq lower-case($vB)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-StringEqual-4,Error: XPST0003: Unable to parse XPath: declare variable $vA as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string; declare variable $vB as xs:string := ("no match", current-time(), string(<e>content</e>))[1] treat as xs:string; (upper-case($vA) eq upper-case($vB)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-StringEqual-5,Error: XPST0003: Unable to parse XPath: declare variable $vA as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string; declare variable $vB as xs:string := ("b string", current-time(), string(<e>content</e>))[1] treat as xs:string; (upper-case($vA) eq lower-case($vB)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-StringEqual-6,Error: XPST0003: Unable to parse XPath:          declare variable $vA as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string;          declare variable $vB as xs:string := ("b string", current-time(), string(<e>content</e>))[1] treat as xs:string;          (lower-case($vA) eq upper-case($vB))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
cbcl-string-equal-001,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
cbcl-string-equal-002,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
cbcl-string-equal-003,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
cbcl-string-equal-004,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
cbcl-string-greater-than-001,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
cbcl-string-greater-than-002,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
cbcl-string-greater-than-003,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
cbcl-string-greater-than-004,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K2-StringLT-1,AssertionError: Expected XPath "" lt "" to resolve to true: expected false to be true
cbcl-string-less-than-001,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
cbcl-string-less-than-002,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
cbcl-string-less-than-003,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
cbcl-string-less-than-004,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
rangeExpr-6,Error: XPTY0004 Unable to convert to type
rangeExpr-19,Error: XPTY0004 Unable to convert to type
rangeExpr-20,Error: XPTY0004 Unable to convert to type
rangeExpr-21,Error: XPTY0004 Unable to convert to type
rangeExpr-22,Error: XPTY0004 Unable to convert to type
rangeExpr-23,Error: XPTY0004 Unable to convert to type
rangeExpr-24,Error: XPTY0004 Unable to convert to type
rangeExpr-28,AssertionError: Expected executing the XPath "18446744073709551616 to 18446744073709551620" to resolve to one of the expected results, but got AssertionError: 18446744073709551616 to 18446744073709551620: expected '18446744073709552000' to equal '18446744073709551616 18446744073709551617 18446744073709551618 18446744073709551619 18446744073709551620', AssertionError: expected [Function] to throw an error.
rangeExpr-29,AssertionError: Expected executing the XPath "count(18446744073709551616 to 18446744073709551620)" to resolve to one of the expected results, but got AssertionError: Expected XPath count(18446744073709551616 to 18446744073709551620) to resolve to 5: expected false to be true, AssertionError: expected [Function] to throw an error.
rangeExpr-30,AssertionError: Expected executing the XPath "(28446744073709551616 to 28446744073709551620)!position()" to resolve to one of the expected results, but got AssertionError: (28446744073709551616 to 28446744073709551620)!position(): expected '1' to equal '1 2 3 4 5', AssertionError: expected [Function] to throw an error.
rangeExpr-31,AssertionError: Expected executing the XPath "((28446744073709551616 to 28446744073709551620)!last())[1]" to resolve to one of the expected results, but got AssertionError: Expected XPath ((28446744073709551616 to 28446744073709551620)!last())[1] to resolve to 5: expected false to be true, AssertionError: expected [Function] to throw an error.
rangeExpr-32,AssertionError: Expected executing the XPath "reverse(28446744073709551616 to 28446744073709551620)" to resolve to one of the expected results, but got AssertionError: reverse(28446744073709551616 to 28446744073709551620): expected '28446744073709550000' to equal '28446744073709551620 28446744073709551619 28446744073709551618 28446744073709551617 28446744073709551616', AssertionError: expected [Function] to throw an error.
rangeExpr-35,Error: XPTY0004 Unable to convert to type
rangeExpr-36,Error: XPST0017: Function year-from-date with arity of 1 not registered. No similar functions found.
rangeExpr-37,Error: XPST0017: Function year-from-date with arity of 1 not registered. No similar functions found.
rangeExpr-38,Error: XPST0017: Function year-from-date with arity of 1 not registered. No similar functions found.
rangeExpr-39,Error: XPST0017: Function year-from-date with arity of 1 not registered. No similar functions found.
rangeExpr-40,Error: XPST0017: Function year-from-date with arity of 1 not registered. No similar functions found.
K-RangeExpr-31,Error: XPST0003: Unable to parse XPath: ((remove((2.e0, 4), 1) treat as xs:integer to 4))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.
K-RangeExpr-32,Error: XPST0003: Unable to parse XPath: ((4 to remove((2e0, 4), 1) treat as xs:integer))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "union", "|", or "||" but "t" found.
fn-union-node-args-003,Error: XPST0017: Function root with arity of 1 not registered. No similar functions found.
K2-SeqUnion-22,Error: XPST0003: Unable to parse XPath: empty(<e/>/(a union attribute {"name"} {()})). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
K2-SeqUnion-23,Error: XPST0003: Unable to parse XPath: empty(<e/>/(a union attribute name {()})). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
K2-SeqUnion-24,AssertionError: Expected executing the XPath "empty(<e/>/(a union element {"name"} {()}))" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: empty(<e/>/(a union element {"name"} {()})). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: empty(<e/>/(a union element {"name"} {()})). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.'.
K2-SeqUnion-25,AssertionError: Expected executing the XPath "empty(<e/>/(a union element name {()}))" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: empty(<e/>/(a union element name {()})). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: empty(<e/>/(a union element name {()})). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.'.
K2-SeqUnion-26,Error: XPST0003: Unable to parse XPath: empty(<e/>/(a union processing-instruction {"name"} {()})). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
K2-SeqUnion-27,Error: XPST0003: Unable to parse XPath: empty(<e/>/(a union processing-instruction name {})). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
K2-SeqUnion-28,Error: XPST0003: Unable to parse XPath: empty(<e/>/(a union comment {()})). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
K2-SeqUnion-29,Error: XPST0003: Unable to parse XPath: empty(<e/>/(a union text {()})). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
combiningnodeseqhc1,Error: XPST0003: Unable to parse XPath: for $h in ( (<hours>0</hours>,<hours>1</hours>) | //hours) order by number($h) return $h. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
combiningnodeseqhc2,Error: XPST0003: Unable to parse XPath: for $h in ( (<hours>0</hours>,<hours>1</hours>) union (//hours)) order by number($h) return $h. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
combiningnodeseqhc3,Error: XPST0003: Unable to parse XPath: for $h in ( (<hours>0</hours>,<hours>40</hours>) | (//hours)) order by number($h) return $h. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
combiningnodeseqhc4,Error: XPST0003: Unable to parse XPath: for $h in ( (<hours>0</hours>,<hours>40</hours>) union (//hours)) order by number($h) return $h. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
combiningnodeseqhc5,Error: XPST0003: Unable to parse XPath: for $h in ( () | (//hours)) order by number($h) return $h. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
combiningnodeseqhc6,Error: XPST0003: Unable to parse XPath: for $h in ( () union (//hours)) order by number($h) return $h. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
combiningnodeseqhc7,Error: XPST0003: Unable to parse XPath: for $h in ( (//hours[xs:integer(.) le 20]) | (//hours[xs:integer(.) gt 20])) order by number($h) return $h. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
combiningnodeseqhc8,Error: XPST0003: Unable to parse XPath: for $h in ( (//hours[xs:integer(.) le 20]) union (//hours[xs:integer(.) gt 20])) order by number($h) return $h. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
combiningnodeseqhc9,Error: XPST0003: Unable to parse XPath: for $h in ( ($works//hours) | ($staff//grade[xs:integer(.) gt 12])) order by number($h) return $h. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
combiningnodeseqhc10,Error: XPST0003: Unable to parse XPath: for $h in ( ($works//hours) union ($staff//grade[xs:integer(.) gt 12])) order by number($h) return $h. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
cbcl-fn-union-001,AssertionError: Expected executing the XPath "         declare variable $x := <b/>;         declare variable $y := <a/>;         ($x union $y) union $x, ($x intersect $y) union $x, ($x except $y) union $x, ($y except $x) union $x, $x union ($x union $y), $x union ($x intersect $y), $x union ($x except $y), $x union ($y except $x)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath:          declare variable $x := <b/>;         declare variable $y := <a/>;         ($x union $y) union $x, ($x intersect $y) union $x, ($x except $y) union $x, ($y except $x) union $x, $x union ($x union $y), $x union ($x intersect $y), $x union ($x except $y), $x union ($y except $x). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found., Error: XPST0003: Unable to parse XPath:          declare variable $x := <b/>;         declare variable $y := <a/>;         ($x union $y) union $x, ($x intersect $y) union $x, ($x except $y) union $x, ($y except $x) union $x, $x union ($x union $y), $x union ($x intersect $y), $x union ($x except $y), $x union ($y except $x). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found..
cbcl-fn-union-002,Error: XPST0003: Unable to parse XPath:          declare variable $doc := <root><test><x/><y/></test></root>;         $doc/test[x] union $doc/test[y]. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
outer-001,Error: XPST0003: Unable to parse XPath:          declare variable $n as xs:integer external := 10;          <out>{ for $x allowing empty in 1 to $n return <a>{$x}</a> }</out>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
outer-002,Error: XPST0003: Unable to parse XPath:          declare variable $n as xs:integer external := 0;          <out>{ for $x allowing empty in 1 to $n return <a>{$x}</a> }</out>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
outer-003,Error: XPST0003: Unable to parse XPath:          declare variable $n as xs:integer external := 10;          <out>{ for $x allowing empty at $p in 1 to $n return <a position="{$p}">{$x}</a> }</out>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
outer-004,Error: XPST0003: Unable to parse XPath:          declare variable $n as xs:integer external := 0;          <out>{ for $x allowing empty at $p in 1 to $n return <a position="{$p}">{$x}</a> }</out>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
outer-005,Error: XPST0003: Unable to parse XPath:          declare variable $n as xs:integer external := 10;         <out>{ string-join(for $x allowing empty in 1 to $n return concat('[',$x,']'), '|') }</out>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
outer-006,Error: XPST0003: Unable to parse XPath:          declare variable $n as xs:integer external := 0;          <out>{ string-join(for $x allowing empty in 1 to $n return concat('[',$x,']'), '|') }</out>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
outer-007,Error: XPST0003: Unable to parse XPath:          declare variable $m as xs:integer external := 5;          declare variable $n as xs:integer external := 5;          <out>{ for $x allowing empty at $p in 1 to $m, $y at $q in 1 to $n return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
outer-008,Error: XPST0003: Unable to parse XPath:          declare variable $m as xs:integer external := 5;          declare variable $n as xs:integer external := 0;          <out>{ for $x allowing empty at $p in 1 to $m, $y allowing empty at $q in 1 to $n return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
outer-009,Error: XPST0003: Unable to parse XPath:          declare variable $m as xs:integer external := 0;          declare variable $n as xs:integer external := 5;          <out>{ for $x allowing empty at $p in 1 to $m, $y at $q in 1 to $n return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
outer-010,Error: XPST0003: Unable to parse XPath:          declare variable $m as xs:integer external := 0;          declare variable $n as xs:integer external := 0;          <out>{ for $x allowing empty at $p in 1 to $m,                     $y allowing empty at $q in 1 to $n return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
outer-011,Error: XPST0003: Unable to parse XPath:          declare variable $n as xs:integer external := 5;          <out>{ for $x allowing empty at $p in 1 to $n, $y allowing empty at $q in ($x+1) to $n return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
outer-012,Error: XPST0003: Unable to parse XPath:          declare variable $n as xs:integer external := 5;          <out>{              for $x as xs:integer allowing empty at $p in 1 to $n,                  $y as xs:integer? allowing empty at $q in ($x+1) to $n              return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
outer-013,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare variable $n as xs:integer external := 5; \n        <out>{ for $x as xs:integer allowing empty at $p in 1 to $n, \n                   $y as xs:integer allowing empty at $q in ($x+1) to $n \n               return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
outer-014,Error: XPST0003: Unable to parse XPath:          declare variable $n as xs:integer external := 5;          <out>{ for $x as xs:integer at $p in 1 to $n                 for $y as xs:integer? allowing empty at $q in ($x+1) to $n                 return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
outer-015,Error: XPST0003: Unable to parse XPath:          declare variable $n as xs:integer external := 5;          <out>{ for $x as xs:integer? allowing empty at $p in 1 to $n                 for $y as xs:integer at $q in (if (empty($x)) then 0 else (1 to $x))                 return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
outer-016,Error: XPST0003: Unable to parse XPath:          declare variable $n as xs:integer external := 0;          <out>{ for $x as xs:integer? allowing empty at $p in 1 to $n                 for $y as xs:integer at $q in (if (empty($x)) then 0 else (1 to $x))                 return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
outer-017,Error: XPST0003: Unable to parse XPath:          declare variable $n as xs:integer external := 5;          <out>{ for $x as xs:integer? allowing empty at $p in 1 to $n                 for $y as xs:integer? allowing empty at $q in (if (empty($x)) then () else (1 to $x))                 where deep-equal($x,$y)                 return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
outer-018,Error: XPST0003: Unable to parse XPath:          declare variable $n as xs:integer external := 0;          <out>{ for $x as xs:integer? allowing empty at $p in 1 to $n                 for $y as xs:integer? allowing empty at $q in (if (empty($x)) then () else (1 to $x))                 where deep-equal($x,$y) return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
outer-019,AssertionError: expected [Function] to throw error including 'FORG0005' but got 'XPST0003: Unable to parse XPath: for $c allowing empty in () return exactly-one($c). SyntaxError: Expected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.'
annotation-1,Error: XPST0003: Unable to parse XPath: (          declare namespace eg = "http://example.com";          declare %eg:sequential function local:foo() {             "bar"          };          local:foo()       ) = ("bar"). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
annotation-2,Error: XPST0003: Unable to parse XPath: (          declare namespace eg = "http://example.com";          declare %eg:sequential variable $foo := "bar";          $foo       ) = ("bar"). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
annotation-3,Error: XPST0003: Unable to parse XPath: (          declare namespace eg = "http://example.com";          %eg:sequential function () { "bar" } ()       ) = ("bar"). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
annotation-4,Error: XPST0003: Unable to parse XPath:           declare namespace java = "http://example.com";           declare %java:variable("java.lang.Integer.MAX_VALUE") variable $max := 0;           declare %java:method("java.lang.Math.sin") function local:sin($arg) { 0 };            local:sin($max)       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
annotation-5,Error: XPST0003: Unable to parse XPath:           declare namespace eg = "http://example.com";           declare %eg:integer(1234) variable $foo := 0;           declare %eg:integer(1234) function local:foo($arg) { $arg };            local:foo($foo)       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
annotation-6,Error: XPST0003: Unable to parse XPath:           declare namespace eg = "http://example.com";           declare %eg:integer(12.34) variable $foo := 0;           declare %eg:integer(12.34) function local:foo($arg) { $arg };            local:foo($foo)       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
annotation-7,Error: XPST0003: Unable to parse XPath:           declare namespace eg = "http://example.com";           declare %eg:integer(12e34) variable $foo := 0;           declare %eg:integer(12e34) function local:foo($arg) { $arg };            local:foo($foo)       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
annotation-9,Error: XPST0003: Unable to parse XPath:           declare namespace eg = "http://example.com";           declare %eg:many(12e34,"abc",1234) variable $foo := 0;           declare %eg:many("xyz", 987, 12.3) function local:foo($arg) { $arg };            local:foo($foo)       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
annotation-10,Error: XPST0003: Unable to parse XPath:           declare %Q{http://example.com}bar variable $foo := 0;           declare %Q{http://example.com}bar function local:foo($arg) { $arg };            local:foo($foo)       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "%" found.
annotation-11,Error: XPST0003: Unable to parse XPath:           declare namespace eg = "http://example.com";           declare %eg:one %eg:two %eg:three variable $foo := 0;           declare %eg:one %eg:two %eg:three function local:foo($arg) { $arg };            local:foo($foo)       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
annotation-12,Error: XPST0003: Unable to parse XPath:           declare namespace eg = "http://example.com";           declare %eg:one%eg:two%eg:three(1)%eg:four variable $foo := 0;           declare %eg:one%eg:two%eg:three(1)%eg:four function local:foo($arg) { $arg };            local:foo($foo)       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
annotation-13,Error: XPST0003: Unable to parse XPath:           declare namespace eg = "http://example.com";           declare              %eg:one             %eg:two             (: Lorem ipsum dolor sit amet. :)             %eg:three(1)             %Q{http://example.com}four             variable $foo := 0;           declare              %eg:one             %eg:two             (: Lorem ipsum dolor sit amet. :)             %eg:three(1)             %Q{http://example.com}four             function local:foo($arg) { $arg };            local:foo($foo)       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
annotation-14,Error: XPST0003: Unable to parse XPath:           declare namespace eg = "http://example.com";           declare %eg:one(1, 2, 3) %eg:two("a", "b") %eg:three(1.234) variable $foo := 0;           declare  %eg:one(1, 2, 3) %eg:two("a", "b") %eg:three(1.234) function local:foo($arg) { $arg };            local:foo($foo)       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
annotation-15,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: \n         declare %xml:x function local:foo() {\n            "bar"\n         };\n         local:foo()\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "%" found.'
annotation-16,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: \n         declare %Q{http://www.w3.org/XML/1998/namespace}x variable $foo := "bar";\n         $foo\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "%" found.'
annotation-17,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: \n         declare %xs:x function local:foo() {\n            "bar"\n         };\n         local:foo()\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "%" found.'
annotation-18,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: \n         declare %Q{http://www.w3.org/2001/XMLSchema}x variable $foo := "bar";\n         $foo\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "%" found.'
annotation-19,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: \n         declare %xsi:x function local:foo() {\n            "bar"\n         };\n         local:foo()\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "%" found.'
annotation-20,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: \n         declare %Q{http://www.w3.org/2001/XMLSchema-instance}x variable $foo := "bar";\n         $foo\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "%" found.'
annotation-21,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: \n         declare %fn:x function local:foo() {\n            "bar"\n         };\n         local:foo()\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "%" found.'
annotation-22,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: \n         declare %Q{http://www.w3.org/2005/xpath-functions}x variable $foo := "bar";\n         $foo\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "%" found.'
annotation-23,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: \n         declare %x variable $foo := "bar";\n         $foo\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "%" found.'
annotation-24,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: \n         declare namespace math = "http://www.w3.org/2005/xpath-functions/math";\n         declare %math:x function local:foo() {\n            "bar"\n         };\n         local:foo()\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
annotation-25,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: \n         declare %Q{http://www.w3.org/2005/xpath-functions/math}x variable $foo := "bar";\n         $foo\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "%" found.'
annotation-26,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: \n         declare namespace opts = "http://www.w3.org/2012/xquery";\n         declare %opts:x function local:foo() {\n            "bar"\n         };\n         local:foo()\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
annotation-27,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: \n         declare %Q{http://www.w3.org/2012/xquery}x variable $foo := "bar";\n         $foo\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "%" found.'
annotation-28,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: \n         declare default function namespace "http://example.com";\n         declare %x variable $foo := "bar";\n         $foo\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'
annotation-29,Error: XPST0003: Unable to parse XPath: (          declare %local:x variable $foo := "bar";          $foo       ) = ("bar"). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "%" found.
annotation-30,Error: XPST0003: Unable to parse XPath: (          declare namespace eg = "http://example.com";          %eg:sequential("abc", 3) function () { "bar" } ()       ) = ("bar"). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
annotation-31,Error: XPST0003: Unable to parse XPath: (          declare namespace eg = "http://example.com";          % Q{http://example.com}sequential("abc", 3) function () { "bar" } ()       ) = ("bar"). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
annotation-32,Error: XPST0003: Unable to parse XPath: (          declare namespace eg = "http://example.com";          %eg:sequential("abc", 3) %eg:memo-function function () { "bar" } ()       ) = ("bar"). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
annotation-34,Error: XPST0003: Unable to parse XPath: (          declare default function namespace "http://example.com";          declare %private function lt() as item()*{          ()          };          ()       ) => empty(). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found.
annotation-35,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: \n         declare namespace array = "http://www.w3.org/2005/xpath-functions/array";\n         declare %array:x function local:foo() {\n            "bar"\n         };\n         local:foo()\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
annotation-36,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: \n         declare namespace map = "http://www.w3.org/2005/xpath-functions/map";\n         declare %map:x function local:foo() {\n            "bar"\n         };\n         local:foo()\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
annotation-37,Error: XPST0003: Unable to parse XPath: (          declare namespace a = "http://www.example.org/annotation";          declare %a:translucent("true") %a:translucent("false") function local:foo() {             "bar"          };          local:foo()       ) = ("bar"). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
annotation-38,Error: XPST0003: Unable to parse XPath: (          declare namespace a = "http://www.example.org/annotation";          declare %a:translucent("true") %a:translucent("false") variable $foo := "bar";          $foo       ) = ("bar"). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
annotation-assertion-1,Error: XPST0003: Unable to parse XPath:           declare namespace eg = "http://example.com";          () instance of %eg:x function(*)       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
annotation-assertion-2,Error: XPST0003: Unable to parse XPath:           declare namespace eg = "http://example.com";          () instance of %eg:x("foo") function(*)       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
annotation-assertion-3,Error: XPST0003: Unable to parse XPath:           declare namespace eg = "http://example.com";          () instance of %eg:x(1234) function(*)       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
annotation-assertion-4,Error: XPST0003: Unable to parse XPath:           declare namespace eg = "http://example.com";          () instance of %eg:x(12.34) function(*)       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
annotation-assertion-5,Error: XPST0003: Unable to parse XPath:           declare namespace eg = "http://example.com";          () instance of %eg:x(12e34) function(*)       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
annotation-assertion-6,Error: XPST0003: Unable to parse XPath:           declare namespace eg = "http://example.com";          () instance of %eg:x("abc", 12e34, 567) function(*)       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
annotation-assertion-7,Error: XPST0003: Unable to parse XPath:           () instance of %Q{http://example.com}x function(*)       . SyntaxError: Expected " ", "(", "(:", "Q", "\n", "\r", "\t", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "empty-sequence()", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-z----------], or [-] but "%" found.
annotation-assertion-8,Error: XPST0003: Unable to parse XPath:           () instance of %Q{http://example.com}x function(*)       . SyntaxError: Expected " ", "(", "(:", "Q", "\n", "\r", "\t", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "empty-sequence()", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-z----------], or [-] but "%" found.
annotation-assertion-9,Error: XPST0003: Unable to parse XPath:           declare namespace eg = "http://example.com";          () instance of %eg:x %eg:y%eg:z %eg:w(1) function(*)       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
annotation-assertion-10,Error: XPST0003: Unable to parse XPath:           declare namespace eg = "http://example.com";          () instance of %eg:x function(xs:integer) as xs:string       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
annotation-assertion-11,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: \n         () instance of %xml:x function(*) \n      . SyntaxError: Expected " ", "(", "(:", "Q", "\\n", "\\r", "\\t", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "empty-sequence()", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-z----------], or [-] but "%" found.'
annotation-assertion-12,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: \n         () instance of %Q{http://www.w3.org/XML/1998/namespace}x function(*) \n      . SyntaxError: Expected " ", "(", "(:", "Q", "\\n", "\\r", "\\t", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "empty-sequence()", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-z----------], or [-] but "%" found.'
annotation-assertion-13,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: \n         () instance of %xs:x function(*) \n      . SyntaxError: Expected " ", "(", "(:", "Q", "\\n", "\\r", "\\t", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "empty-sequence()", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-z----------], or [-] but "%" found.'
annotation-assertion-14,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: \n         () instance of %Q{http://www.w3.org/2001/XMLSchema}x function(*) \n      . SyntaxError: Expected " ", "(", "(:", "Q", "\\n", "\\r", "\\t", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "empty-sequence()", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-z----------], or [-] but "%" found.'
annotation-assertion-15,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: \n         () instance of %xsi:x function(*) \n      . SyntaxError: Expected " ", "(", "(:", "Q", "\\n", "\\r", "\\t", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "empty-sequence()", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-z----------], or [-] but "%" found.'
annotation-assertion-16,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: \n         () instance of %fn:x function(*) \n      . SyntaxError: Expected " ", "(", "(:", "Q", "\\n", "\\r", "\\t", "array", "attribute(", "attribute()", "comment()", "document-node(", "document-node()", "element", "empty-sequence()", "function", "item()", "map", "namespace-node()", "node()", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "text()", [A-Z_a-z----------], or [-] but "%" found.'
annotation-assertion-17,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: \n         declare namespace math = "http://www.w3.org/2005/xpath-functions/math";\n         () instance of %math:x function(*) \n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
annotation-assertion-18,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: \n         declare namespace opts = "http://www.w3.org/2012/xquery";\n         () instance of %opts:x function(*) \n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
annotation-assertion-19,Error: XPST0003: Unable to parse XPath:           declare namespace eg = "http://example.com";          () instance of %eg:x(1) %eg:x(2) function(xs:integer) as xs:string       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
annotation-assertion-20,AssertionError: Expected executing the XPath "          declare namespace eg = "http://example.com";          declare %public function local:three() as xs:integer {3};          local:three#0 instance of %public %private function(xs:integer) as xs:integer       " to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath:           declare namespace eg = "http://example.com";          declare %public function local:three() as xs:integer {3};          local:three#0 instance of %public %private function(xs:integer) as xs:integer       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found., Error: XPST0003: Unable to parse XPath:           declare namespace eg = "http://example.com";          declare %public function local:three() as xs:integer {3};          local:three#0 instance of %public %private function(xs:integer) as xs:integer       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found..
Axes089,Error: XPST0003: Unable to parse XPath:  xquery version "1.0"; declare namespace saxon="http://saxon.sf.net/"; declare namespace tour="http://wrox.com/tour";  (:     XQuery program to perform a knight's tour of the chessboard.     Author: Michael H. Kay     Date: 26 June 2003          This version modified to use XQuery 1.0, with sequences and functions.      This query does not use a source document.     There is an optional parameter, start, which can be set to any square on the     chessboard, e.g. a3 or h5. XQuery does not allow parameters to be given a     default value, so the parameter is mandatory.          There is a second optional parameter, end, which indicates that the processing should stop     after a given number of steps. This can be used to animate the display of the tour. This     works especially well when the query is compiled into a Java servlet.      The output is an HTML display of the completed tour.      Internally, the following data representations are used:     * A square on the chessboard: represented as a number in the range 0 to 63     * A state of the chessboard: a sequence of 64 integers, each containing a move number.        A square that has not been visited yet is represented by a zero.     * A set of possible moves: represented as a sequence of integers,     * each integer representing the number of the destination square        :)  declare variable $start as xs:string := "a1";  declare variable $end as xs:string := "64"; declare variable $endd as xs:integer := xs:integer($end);   (: start-column is an integer in the range 0-7 :)  declare variable $start-column as xs:integer :=     xs:integer(translate(substring($start, 1, 1),             'abcdefgh', '01234567'));  (: start-row is an integer in the range 0-7, with zero at the top :)  declare variable $start-row as xs:integer :=     8 - xs:integer(substring($start, 2, 1));      declare function tour:main () as element() {      (: This function controls the processing. It does not access the source document. :)      (: Validate the input parameter :)      if (not(string-length($start)=2) or         not(translate(substring($start,1,1), 'abcdefgh', 'aaaaaaaa')='a') or         not(translate(substring($start,2,1), '12345678', '11111111')='1'))     then         error((), "Invalid start parameter: try say 'a1' or 'g6'")     else          if (not($endd = 1 to 64))      then         error((), "Invalid end parameter: must be in range 1 to 64")     else      (: Set up the empty board :)      let $empty-board as xs:integer* :=          for $i in (1 to 64) return 0          (: Place the knight on the board at the chosen starting position :)          let $initial-board as xs:integer* :=         tour:place-knight(1, $empty-board, $start-row * 8 + $start-column)          (: Evaluate the knight's tour :)      let $final-board as xs:integer* :=        tour:make-moves(2, $initial-board, $start-row * 8 + $start-column)      (: produce the HTML output :)          return tour:print-board($final-board) };  declare function tour:place-knight (                     $move as xs:integer,                     $board as xs:integer*,                     $square as xs:integer (: range 0 to 63 :)                   ) as xs:integer* {      (: This function places a knight on the board at a given square. The returned value is          the supplied board, modified to indicate that the knight reached a given square at a given          move :)      for $i in 1 to 64 return         if ($i = $square + 1) then $move else $board[$i]  };  declare function tour:make-moves (                     $move as xs:integer,                     $board as xs:integer*,                     $square as xs:integer (: range 0 to 63 :)                 ) as xs:integer* {      (: This function takes the board in a given state, decides on the next move to make,          and then calls itself recursively to make further moves, until the knight has completed          his tour of the board. It returns the board in its final state. :)      (: determine the possible moves that the knight can make :)      let $possible-move-list as xs:integer* :=          tour:list-possible-moves($board, $square)      (: try these moves in turn until one is found that works :)      return tour:try-possible-moves($move, $board, $square, $possible-move-list) };  declare function tour:try-possible-moves (                     $move as xs:integer,                     $board as xs:integer*,                     $square as xs:integer, (: range 0 to 63 :)                     $possible-moves as xs:integer* )                 as xs:integer* {      (:   This function tries a set of possible moves that the knight can make          from a given position. It determines the best move as the one to the square with          fewest exits. If this is unsuccessful then it can backtrack and          try another move; however this turns out rarely to be necessary.                     The function makes the selected move, and then calls make-moves() to make          subsequent moves, returning the final state of the board. :)           if (count($possible-moves)!=0)                 then tour:make-best-move($move, $board, $square, $possible-moves)                 else ()           (: if there is no possible move, we return the special value () as the final state              of the board, to indicate to the caller that we got stuck :) };  declare function tour:make-best-move (                     $move as xs:integer,                     $board as xs:integer*,                     $square as xs:integer, (: range 0 to 63 :)                     $possible-moves as xs:integer* )                 as xs:integer* {                      (: this function, given the state of the board and a set of possible moves,        determines which of the moves is the best one. It then makes this move,        and proceeds recursively to make further moves, eventually returning the        final state of the board. :)                          (:  if at least one move is possible, find the best one :)      let $best-move as xs:integer :=         tour:find-best-move($board, $possible-moves, 9, 999)      (: find the list of possible moves excluding the best one :)      let $other-possible-moves as xs:integer* :=         $possible-moves[. != $best-move]      (: update the board to make the move chosen as the best one :)      let $next-board as xs:integer* :=         tour:place-knight($move, $board, $best-move)          (: now make further moves using a recursive call, until the board is complete :)      let $final-board as xs:integer* :=         if ($move < $endd) (:count($next-board[.=0])!=0:)                      then tour:make-moves($move+1, $next-board, $best-move)                     else $next-board      (:   if the final board has the special value '()', we got stuck, and have to choose          the next best of the possible moves. This is done by a recursive call. I thought          that the knight never did get stuck, but it does: if the starting square is f1,          the wrong choice is made at move 58, and needs to be reversed. :)      return         if (empty($final-board))         then tour:try-possible-moves($move, $board, $square, $other-possible-moves)         else $final-board          };  declare function tour:find-best-move (                     $board as xs:integer*,                     $possible-moves as xs:integer*,                     $fewest-exits as xs:integer,                     $best-so-far as xs:integer )                 as xs:integer {      (:  This function finds from among the possible moves, the one with fewest exits.          It calls itself recursively. :)               (:  split the list of possible moves into the first move and the rest of the moves :)      let $trial-move as xs:integer :=          $possible-moves[1]          let $other-possible-moves as xs:integer* :=         $possible-moves[position() > 1]      (: try making the first move :)      let $trial-board as xs:integer* :=         tour:place-knight(99, $board, $trial-move)      (: see how many moves would be possible the next time :)      let $trial-move-exit-list as xs:integer* :=         tour:list-possible-moves($trial-board, $trial-move)      let $number-of-exits as xs:integer :=         count($trial-move-exit-list)      (:  determine whether this trial move has fewer exits than those considered up till now :)      let $minimum-exits as xs:integer :=         min(($number-of-exits, $fewest-exits))      (:  determine which is the best move (the one with fewest exits) so far :)      let $new-best-so-far as xs:integer :=         if ($number-of-exits < $fewest-exits)             then $trial-move             else $best-so-far        (:  if there are other possible moves, consider them too, using a recursive call.         Otherwise return the best move found. :)      return         if (count($other-possible-moves)!=0)             then tour:find-best-move($board, $other-possible-moves,                                              $minimum-exits, $new-best-so-far)             else $new-best-so-far  };  declare function tour:list-possible-moves (                 $board as xs:integer*,                 $square as xs:integer )             as xs:integer* {      (:   This function, given the knight's position on the board, returns the set of squares          he can move to. The squares will be ones that have not been visited before :)                  let $row as xs:integer := $square idiv 8     let $column as xs:integer := $square mod 8      return         (if ($row > 1 and $column > 0 and $board[($square - 17) + 1]=0)             then $square - 17 else (),          if ($row > 1 and $column < 7 and $board[($square - 15) + 1]=0)             then $square - 15 else (),          if ($row > 0 and $column > 1 and $board[($square - 10) + 1]=0)             then $square - 10 else (),          if ($row > 0 and $column < 6 and $board[($square - 6) + 1]=0)             then $square - 6 else (),          if ($row < 6 and $column > 0 and $board[($square + 15) + 1]=0)             then $square + 15 else (),          if ($row < 6 and $column < 7 and $board[($square + 17) + 1]=0)             then $square + 17 else (),          if ($row < 7 and $column > 1 and $board[($square + 6) + 1]=0)             then $square + 6 else (),          if ($row < 7 and $column < 6 and $board[($square + 10) + 1]=0)             then $square + 10 else () )  };  declare function tour:print-board (                 $board as xs:integer* )             as element() {     (: Output the board in HTML format :)      <html>     <head>         <title>Knight's tour</title>     </head>     <body>     <div align="center">     <h1>Knight's tour starting at {$start}</h1>     <table border="1" cellpadding="4">         {for $row in 0 to 7 return            <tr>               {for $column in 0 to 7                 let $color :=                           if ((($row + $column) mod 2)=1)                           then 'xffff44'                            else 'white' return                 <td align="center" bgcolor="{$color}" width="22">{                   let $n := $board[$row * 8 + $column + 1]                   return                        if ($endd != 64 and $n = $endd)                       then <b>{$n}</b>                       else if ($n = 0)                       then "&#xa0;"                       else $n                 }</td>               }            </tr>         }     </table>     <p>{         if ($endd != 64)          then           <a href="Tour?start={$start}&amp;end={$endd+1}">Step</a>         else ()     }</p>         </div>     </body>     </html> };  tour:main()  . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
Axes090,AssertionError: Expected executing the XPath "let $element as element(foo) := <foo/> return count($element/self::bar)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (let $element as element(foo) := <foo/> return count($element/self::bar)) = (0). SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: let $element as element(foo) := <foo/> return count($element/self::bar). SyntaxError: Expected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.'.
Axes091,AssertionError: Expected executing the XPath "let $element as element(foo) := <foo/> return count($element/self::*:bar)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (let $element as element(foo) := <foo/> return count($element/self::*:bar)) = (0). SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: let $element as element(foo) := <foo/> return count($element/self::*:bar). SyntaxError: Expected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.'.
Axes092,AssertionError: Expected executing the XPath "declare namespace ns1 = "http://www.example.org/ns1"; declare namespace ns2 = "http://www.example.org/ns2"; let $element as element(ns1:foo) := <ns1:foo/> return count($element/self::ns2:*)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare namespace ns1 = "http://www.example.org/ns1"; declare namespace ns2 = "http://www.example.org/ns2"; let $element as element(ns1:foo) := <ns1:foo/> return count($element/self::ns2:*)) = (0). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: declare namespace ns1 = "http://www.example.org/ns1"; declare namespace ns2 = "http://www.example.org/ns2"; let $element as element(ns1:foo) := <ns1:foo/> return count($element/self::ns2:*). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'.
Axes093,AssertionError: Expected executing the XPath "let $attribute as attribute(foo) := attribute foo { } return count($attribute/self::bar)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (let $attribute as attribute(foo) := attribute foo { } return count($attribute/self::bar)) = (0). SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: let $attribute as attribute(foo) := attribute foo { } return count($attribute/self::bar). SyntaxError: Expected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.'.
Axes094,AssertionError: Expected executing the XPath "let $attribute as attribute(foo) := attribute foo { }              return count($attribute/self::*:bar)       " to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (let $attribute as attribute(foo) := attribute foo { }              return count($attribute/self::*:bar)       ) = (0). SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: let $attribute as attribute(foo) := attribute foo { } \n            return count($attribute/self::*:bar)\n      . SyntaxError: Expected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.'.
Axes095,AssertionError: Expected executing the XPath "         declare namespace ns1 = "http://www.example.org/ns1";          declare namespace ns2 = "http://www.example.org/ns2";          let $attribute as attribute(ns1:foo) := attribute ns1:foo { }          return count($attribute/self::ns2:*)       " to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (         declare namespace ns1 = "http://www.example.org/ns1";          declare namespace ns2 = "http://www.example.org/ns2";          let $attribute as attribute(ns1:foo) := attribute ns1:foo { }          return count($attribute/self::ns2:*)       ) = (0). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: \n        declare namespace ns1 = "http://www.example.org/ns1"; \n        declare namespace ns2 = "http://www.example.org/ns2"; \n        let $attribute as attribute(ns1:foo) := attribute ns1:foo { } \n        return count($attribute/self::ns2:*)\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'.
Axes096,AssertionError: Expected executing the XPath "let $element as element(*) := <foo/> return count($element/self::bar)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (let $element as element(*) := <foo/> return count($element/self::bar)) = (0). SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: let $element as element(*) := <foo/> return count($element/self::bar). SyntaxError: Expected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.'.
Axes097,AssertionError: Expected executing the XPath "let $element as element(*) := <foo/> return count($element/self::*:bar)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (let $element as element(*) := <foo/> return count($element/self::*:bar)) = (0). SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: let $element as element(*) := <foo/> return count($element/self::*:bar). SyntaxError: Expected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.'.
Axes098,AssertionError: Expected executing the XPath "         declare namespace ns1 = "http://www.example.org/ns1";          declare namespace ns2 = "http://www.example.org/ns2";          let $element as element(*) := <ns1:foo/>          return count($element/self::ns2:*)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (         declare namespace ns1 = "http://www.example.org/ns1";          declare namespace ns2 = "http://www.example.org/ns2";          let $element as element(*) := <ns1:foo/>          return count($element/self::ns2:*)) = (0). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: \n        declare namespace ns1 = "http://www.example.org/ns1"; \n        declare namespace ns2 = "http://www.example.org/ns2"; \n        let $element as element(*) := <ns1:foo/> \n        return count($element/self::ns2:*). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'.
Axes099,AssertionError: Expected executing the XPath "let $attribute as attribute(*) := attribute foo { } return count($attribute/self::bar)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (let $attribute as attribute(*) := attribute foo { } return count($attribute/self::bar)) = (0). SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: let $attribute as attribute(*) := attribute foo { } return count($attribute/self::bar). SyntaxError: Expected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.'.
Axes100,AssertionError: Expected executing the XPath "let $attribute as attribute(*) := attribute foo { } return count($attribute/self::*:bar)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (let $attribute as attribute(*) := attribute foo { } return count($attribute/self::*:bar)) = (0). SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: let $attribute as attribute(*) := attribute foo { } return count($attribute/self::*:bar). SyntaxError: Expected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.'.
Axes101,AssertionError: Expected executing the XPath "         declare namespace ns1 = "http://www.example.org/ns1";          declare namespace ns2 = "http://www.example.org/ns2";          let $attribute as attribute(*) := attribute ns1:foo { }          return count($attribute/self::ns2:*)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (         declare namespace ns1 = "http://www.example.org/ns1";          declare namespace ns2 = "http://www.example.org/ns2";          let $attribute as attribute(*) := attribute ns1:foo { }          return count($attribute/self::ns2:*)) = (0). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: \n        declare namespace ns1 = "http://www.example.org/ns1"; \n        declare namespace ns2 = "http://www.example.org/ns2"; \n        let $attribute as attribute(*) := attribute ns1:foo { } \n        return count($attribute/self::ns2:*). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'.
Axes102,Error: XPST0003: Unable to parse XPath: (         declare namespace ns1 = "http://www.example.org/ns1";          declare namespace ns2 = "http://www.example.org/ns2";          declare construction strip;          let $element as element(*, xs:untyped) := <e>test</e>          let $element as element(*, xs:untyped) := $element/self::*          return count($element)       ) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
Axes103,AssertionError: Expected executing the XPath "let $comment as comment() := <!--comment--> return count($comment/self::*)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (let $comment as comment() := <!--comment--> return count($comment/self::*)) = (0). SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: let $comment as comment() := <!--comment--> return count($comment/self::*). SyntaxError: Expected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.'.
Axes104,AssertionError: Expected executing the XPath "let $comment as comment() := <!--comment--> return count($comment/self::foo)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (let $comment as comment() := <!--comment--> return count($comment/self::foo)) = (0). SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: let $comment as comment() := <!--comment--> return count($comment/self::foo). SyntaxError: Expected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.'.
Axes105,AssertionError: Expected executing the XPath "let $comment as comment() := <!--comment--> return count($comment/self::*:foo)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (let $comment as comment() := <!--comment--> return count($comment/self::*:foo)) = (0). SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: let $comment as comment() := <!--comment--> return count($comment/self::*:foo). SyntaxError: Expected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.'.
Axes106,AssertionError: Expected executing the XPath "         declare namespace ns1 = "http://www.example.org/ns1";          let $comment as comment() := <!--comment-->          return count($comment/self::ns1:*)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (         declare namespace ns1 = "http://www.example.org/ns1";          let $comment as comment() := <!--comment-->          return count($comment/self::ns1:*)) = (0). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: \n        declare namespace ns1 = "http://www.example.org/ns1"; \n        let $comment as comment() := <!--comment--> \n        return count($comment/self::ns1:*). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'.
Axes107,AssertionError: Expected executing the XPath "         let $processing-instruction as processing-instruction() := <?processing instruction?>          return count($processing-instruction/self::*)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (         let $processing-instruction as processing-instruction() := <?processing instruction?>          return count($processing-instruction/self::*)) = (0). SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: \n        let $processing-instruction as processing-instruction() := <?processing instruction?> \n        return count($processing-instruction/self::*). SyntaxError: Expected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.'.
Axes108,AssertionError: Expected executing the XPath "         let $processing-instruction as processing-instruction() := <?processing instruction?>          return count($processing-instruction/self::processing)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (         let $processing-instruction as processing-instruction() := <?processing instruction?>          return count($processing-instruction/self::processing)) = (0). SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: \n        let $processing-instruction as processing-instruction() := <?processing instruction?> \n        return count($processing-instruction/self::processing). SyntaxError: Expected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.'.
Axes109,AssertionError: Expected executing the XPath "         let $processing-instruction as processing-instruction() := <?processing instruction?>          return count($processing-instruction/self::*:processing)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (         let $processing-instruction as processing-instruction() := <?processing instruction?>          return count($processing-instruction/self::*:processing)) = (0). SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: \n        let $processing-instruction as processing-instruction() := <?processing instruction?> \n        return count($processing-instruction/self::*:processing). SyntaxError: Expected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.'.
Axes110,AssertionError: Expected executing the XPath "         declare namespace ns1 = "http://www.example.org/ns1";          let $processing-instruction as processing-instruction() := <?processing instruction?>          return count($processing-instruction/self::ns1:*)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (         declare namespace ns1 = "http://www.example.org/ns1";          let $processing-instruction as processing-instruction() := <?processing instruction?>          return count($processing-instruction/self::ns1:*)) = (0). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: \n        declare namespace ns1 = "http://www.example.org/ns1"; \n        let $processing-instruction as processing-instruction() := <?processing instruction?> \n        return count($processing-instruction/self::ns1:*). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'.
Axes111,Error: XPST0003: Unable to parse XPath: (         declare namespace ns1 = "http://www.example.org/ns1";          declare namespace ns2 = "http://www.example.org/ns2"; declare construction strip;          let $element as element(*, xs:untyped) := <e a="value" />          let $attribute as attribute(*, xs:untypedAtomic)* := $element/attribute::*          return count($attribute)) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
Axes112,AssertionError: expected [Function] to throw error including 'XQST0134' but got 'No selector counterpart for: u.'
Axes115,AssertionError: Expected executing the XPath "/*/attribute::namespace-node()" to resolve to one of the expected results, but got Error: No selector counterpart for: u., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'No selector counterpart for: u.'.
Axes117,Error: XPST0003: Unable to parse XPath: (namespace {"xsl"}{"http://www.w3.org/1999/XSL/Transform"} / self::namespace-node()) => count(). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
Axes127,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'No selector counterpart for: u.'
axis-err-1,AssertionError: expected [Function] to throw an error
K2-Axes-1,Error: XPST0003: Unable to parse XPath: declare variable $var := document{<e><f>f's value</f></e>}; $var/(/)/(/)//f. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-Axes-2,AssertionError: expected [Function] to throw error including 'XPDY0050' but got 'XPST0003: Unable to parse XPath: declare variable $var := <e><f>f\'s value</f></e>; $var/(/)/(/)//f. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-Axes-3,Error: XPST0003: Unable to parse XPath: declare variable $v := <a><b/><b/><b/></a>; deep-equal($v//45, (45, 45, 45, 45)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-Axes-4,Error: XPST0003: Unable to parse XPath: (declare variable $v := <a><b/><b/><b/></a>; $v//45)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
K2-Axes-18,Error: XPST0003: Unable to parse XPath: empty(text {"some text"}/..). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
K2-Axes-19,Error: XPST0003: Unable to parse XPath: empty(processing-instruction theName {"some text"}/..). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.
K2-Axes-20,Error: XPST0003: Unable to parse XPath: empty(attribute theName {"some text"}/..). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.
K2-Axes-21,Error: XPST0003: Unable to parse XPath: empty(element theName {"some text"}/..). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.
K2-Axes-22,Error: XPST0003: Unable to parse XPath: empty(comment {"some text"}/..). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
K2-Axes-30,AssertionError: Expected executing the XPath "empty(fn:root(<e/>)/..)" to resolve to one of the expected results, but got Error: XPST0017: Function fn:root with arity of 1 not registered. No similar functions found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0017: Function fn:root with arity of 1 not registered. No similar functions found.'.
K2-Axes-32,AssertionError: Expected executing the XPath "declare variable $myVar := <e/>; empty(fn:root($myVar/(/)/..))" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: declare variable $myVar := <e/>; empty(fn:root($myVar/(/)/..)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: declare variable $myVar := <e/>; empty(fn:root($myVar/(/)/..)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.', AssertionError: expected [Function] to throw error including 'XPDY0050' but got 'XPST0003: Unable to parse XPath: declare variable $myVar := <e/>; empty(fn:root($myVar/(/)/..)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
K2-Axes-33,AssertionError: Expected executing the XPath "declare variable $myVar := document { <e/>}; empty($myVar/(/)/..)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: declare variable $myVar := document { <e/>}; empty($myVar/(/)/..). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: declare variable $myVar := document { <e/>}; empty($myVar/(/)/..). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
K2-Axes-38,AssertionError: expected [Function] to throw an error
K2-Axes-39,AssertionError: expected [Function] to throw an error
K2-Axes-40,AssertionError: expected [Function] to throw an error
K2-Axes-41,AssertionError: expected [Function] to throw an error
K2-Axes-47,Error: XPST0003: Unable to parse XPath: declare variable $myVar := <e/>; empty($myVar/descendant-or-self::text()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-Axes-48,Error: XPST0003: Unable to parse XPath: (declare variable $myVar := <e/>; $myVar/(<a/>, <b/>, <?d ?>, <!-- e-->, attribute name {}, document {()})/3)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
K2-Axes-49,Error: XPST0003: Unable to parse XPath: (declare variable $myVar := <e/>; $myVar/(<a/>, <b/>, <?d ?>, <!-- e-->, attribute name {}, document {()})/number())!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
K2-Axes-52,AssertionError: Expected executing the XPath "         declare variable $myVar := <e/>;          empty($myVar/preceding-sibling::comment()/a/b/c/1/@*)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath:          declare variable $myVar := <e/>;          empty($myVar/preceding-sibling::comment()/a/b/c/1/@*). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: \n        declare variable $myVar := <e/>; \n        empty($myVar/preceding-sibling::comment()/a/b/c/1/@*). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.', AssertionError: expected [Function] to throw error including 'XPTY0019' but got 'XPST0003: Unable to parse XPath: \n        declare variable $myVar := <e/>; \n        empty($myVar/preceding-sibling::comment()/a/b/c/1/@*). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.', AssertionError: expected [Function] to throw error including 'XPTY0020' but got 'XPST0003: Unable to parse XPath: \n        declare variable $myVar := <e/>; \n        empty($myVar/preceding-sibling::comment()/a/b/c/1/@*). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
K2-Axes-57,Error: XPST0003: Unable to parse XPath: declare variable $var := <a> <b/> <c/> <d/> </a>; ($var/*, $var/*)/.. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-Axes-58,Error: XPST0003: Unable to parse XPath: declare variable $var := <a> <b/> <c/> <d/> </a>; ($var/*, $var/*). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-Axes-59,AssertionError: Expected executing the XPath "declare variable $i := <root> <child/> <child/> <child> <child2> <child3> <leaf/> </child3> </child2> </child> </root>; 1, root($i)//leaf/child::node(), 1" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare variable $i := <root> <child/> <child/> <child> <child2> <child3> <leaf/> </child3> </child2> </child> </root>; 1, root($i)//leaf/child::node(), 1)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: declare variable $i := <root> <child/> <child/> <child> <child2> <child3> <leaf/> </child3> </child2> </child> </root>; 1, root($i)//leaf/child::node(), 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
K2-Axes-84,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'No selector counterpart for: u.'
K2-Axes-86,AssertionError: Expected executing the XPath "         declare variable $root as document-node() := . treat as document-node();         <out>         <empty> { (: attribute axis, and all other axes that inference can assert might produce attributes.               These are placed first, so we don't raise XQTY0024. :)               $root/foo/child::attribute(foo),               $root//element()/self::attribute(),               $root//text()/self::attribute(),               $root/self::attribute(),               $root/foo/descendant::attribute(foo),               $root//processing-instruction()/self::attribute(),               $root/attribute(foo), $root/attribute(),               $root/attribute::attribute(),               $root//parent::attribute(),               $root//document-node()/self::attribute(),               $root/@*, $root/*/@*[self::*],               $root//comment()/descendant-or-self::attribute(),               $root//processing-instruction()/descendant-or-self::attribute(),               $root//text()/descendant-or-self::attribute(),               $root//document-node()/descendant-or-self::attribute(),               $root//parent::attribute(),               $root//ancestor::attribute(),               $root//ancestor-or-self::attribute(),               $root/self::attribute(),               $root//attribute()/child::node(),               $root//attribute::text(),               $root//attribute::comment(),               $root//attribute::processing-instruction(),               $root//attribute::document-node(),               $root//attribute::document-node(element(foo)),              $root//attribute()/self::text(),              $root//attribute()/self::processing-instruction(),               $root//attribute()/self::element(),               $root//attribute()/self::document-node(),               $root//attribute()/self::comment(),               $root//*/attribute()//node(),               $root//*/attribute()/descendant::node(),               $root//attribute::element(),               $root//comment()/child::node(),               $root//processing-instruction()/child::node(),               $root//text()/child::node(),              $root//attribute()/descendant::node(),               $root//comment()/descendant::node(),               $root//text()/descendant::node(),               $root//processing-instruction()/descendant::node(),               $root//comment()/descendant-or-self::text(),               $root//comment()/descendant-or-self::processing-instruction(),               $root//comment()/descendant-or-self::element(),               $root//comment()/descendant-or-self::document-node(),               $root//processing-instruction()/descendant-or-self::text(),               $root//processing-instruction()/descendant-or-self::comment(),               $root//processing-instruction()/descendant-or-self::element(),               $root//processing-instruction()/descendant-or-self::document-node(),               $root//text()/descendant-or-self::processing-instruction(),               $root//text()/descendant-or-self::comment(),               $root//text()/descendant-or-self::element(),               $root//text()/descendant-or-self::document-node(),               $root//attribute()/descendant-or-self::processing-instruction(),               $root//attribute()/descendant-or-self::text(),               $root//attribute()/descendant-or-self::comment(),               $root//attribute()/descendant-or-self::element(),               $root//attribute()/descendant-or-self::document-node(),               $root/.., $root//parent::comment(),               $root//parent::processing-instruction(),               $root//parent::text(),               $root//ancestor::comment(),               $root//ancestor::processing-instruction(),               $root//ancestor::text(),               $root/self::comment(),               $root/self::processing-instruction(),               $root/self::text(),               $root/self::element(),               $root//element()/self::text(),               $root//element()/self::processing-instruction(),               $root//element()/self::document-node(),               $root//element()/self::comment(),               $root//processing-instruction()/self::text(),               $root//processing-instruction()/self::element(),               $root//processing-instruction()/self::document-node(),               $root//processing-instruction()/self::comment(),               $root//text()/self::processing-instruction(),               $root//text()/self::element(),               $root//text()/self::document-node(),               $root//text()/self::comment(),               $root//document-node()/self::processing-instruction(),               $root//document-node()/self::element(),               $root//document-node()/self::text(),               $root//document-node()/self::comment() } </empty><ex>{exists($root//*/attribute()/descendant-or-self::node())}</ex></out>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath:          declare variable $root as document-node() := . treat as document-node();         <out>         <empty> { (: attribute axis, and all other axes that inference can assert might produce attributes.               These are placed first, so we don't raise XQTY0024. :)               $root/foo/child::attribute(foo),               $root//element()/self::attribute(),               $root//text()/self::attribute(),               $root/self::attribute(),               $root/foo/descendant::attribute(foo),               $root//processing-instruction()/self::attribute(),               $root/attribute(foo), $root/attribute(),               $root/attribute::attribute(),               $root//parent::attribute(),               $root//document-node()/self::attribute(),               $root/@*, $root/*/@*[self::*],               $root//comment()/descendant-or-self::attribute(),               $root//processing-instruction()/descendant-or-self::attribute(),               $root//text()/descendant-or-self::attribute(),               $root//document-node()/descendant-or-self::attribute(),               $root//parent::attribute(),               $root//ancestor::attribute(),               $root//ancestor-or-self::attribute(),               $root/self::attribute(),               $root//attribute()/child::node(),               $root//attribute::text(),               $root//attribute::comment(),               $root//attribute::processing-instruction(),               $root//attribute::document-node(),               $root//attribute::document-node(element(foo)),              $root//attribute()/self::text(),              $root//attribute()/self::processing-instruction(),               $root//attribute()/self::element(),               $root//attribute()/self::document-node(),               $root//attribute()/self::comment(),               $root//*/attribute()//node(),               $root//*/attribute()/descendant::node(),               $root//attribute::element(),               $root//comment()/child::node(),               $root//processing-instruction()/child::node(),               $root//text()/child::node(),              $root//attribute()/descendant::node(),               $root//comment()/descendant::node(),               $root//text()/descendant::node(),               $root//processing-instruction()/descendant::node(),               $root//comment()/descendant-or-self::text(),               $root//comment()/descendant-or-self::processing-instruction(),               $root//comment()/descendant-or-self::element(),               $root//comment()/descendant-or-self::document-node(),               $root//processing-instruction()/descendant-or-self::text(),               $root//processing-instruction()/descendant-or-self::comment(),               $root//processing-instruction()/descendant-or-self::element(),               $root//processing-instruction()/descendant-or-self::document-node(),               $root//text()/descendant-or-self::processing-instruction(),               $root//text()/descendant-or-self::comment(),               $root//text()/descendant-or-self::element(),               $root//text()/descendant-or-self::document-node(),               $root//attribute()/descendant-or-self::processing-instruction(),               $root//attribute()/descendant-or-self::text(),               $root//attribute()/descendant-or-self::comment(),               $root//attribute()/descendant-or-self::element(),               $root//attribute()/descendant-or-self::document-node(),               $root/.., $root//parent::comment(),               $root//parent::processing-instruction(),               $root//parent::text(),               $root//ancestor::comment(),               $root//ancestor::processing-instruction(),               $root//ancestor::text(),               $root/self::comment(),               $root/self::processing-instruction(),               $root/self::text(),               $root/self::element(),               $root//element()/self::text(),               $root//element()/self::processing-instruction(),               $root//element()/self::document-node(),               $root//element()/self::comment(),               $root//processing-instruction()/self::text(),               $root//processing-instruction()/self::element(),               $root//processing-instruction()/self::document-node(),               $root//processing-instruction()/self::comment(),               $root//text()/self::processing-instruction(),               $root//text()/self::element(),               $root//text()/self::document-node(),               $root//text()/self::comment(),               $root//document-node()/self::processing-instruction(),               $root//document-node()/self::element(),               $root//document-node()/self::text(),               $root//document-node()/self::comment() } </empty><ex>{exists($root//*/attribute()/descendant-or-self::node())}</ex></out>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: \n        declare variable $root as document-node() := . treat as document-node();\n        <out>\n        <empty> { (: attribute axis, and all other axes that inference can assert might produce attributes. \n             These are placed first, so we don\'t raise XQTY0024. :) \n             $root/foo/child::attribute(foo), \n             $root//element()/self::attribute(), \n             $root//text()/self::attribute(), \n             $root/self::attribute(), \n             $root/foo/descendant::attribute(foo), \n             $root//processing-instruction()/self::attribute(), \n             $root/attribute(foo), $root/attribute(), \n             $root/attribute::attribute(), \n             $root//parent::attribute(), \n             $root//document-node()/self::attribute(), \n             $root/@*, $root/*/@*[self::*], \n             $root//comment()/descendant-or-self::attribute(), \n             $root//processing-instruction()/descendant-or-self::attribute(), \n             $root//text()/descendant-or-self::attribute(), \n             $root//document-node()/descendant-or-self::attribute(), \n             $root//parent::attribute(), \n             $root//ancestor::attribute(), \n             $root//ancestor-or-self::attribute(), \n             $root/self::attribute(), \n             $root//attribute()/child::node(), \n             $root//attribute::text(), \n             $root//attribute::comment(), \n             $root//attribute::processing-instruction(), \n             $root//attribute::document-node(), \n             $root//attribute::document-node(element(foo)),\n             $root//attribute()/self::text(),\n             $root//attribute()/self::processing-instruction(), \n             $root//attribute()/self::element(), \n             $root//attribute()/self::document-node(), \n             $root//attribute()/self::comment(), \n             $root//*/attribute()//node(), \n             $root//*/attribute()/descendant::node(), \n             $root//attribute::element(), \n             $root//comment()/child::node(), \n             $root//processing-instruction()/child::node(), \n             $root//text()/child::node(),\n             $root//attribute()/descendant::node(), \n             $root//comment()/descendant::node(), \n             $root//text()/descendant::node(), \n             $root//processing-instruction()/descendant::node(), \n             $root//comment()/descendant-or-self::text(), \n             $root//comment()/descendant-or-self::processing-instruction(), \n             $root//comment()/descendant-or-self::element(), \n             $root//comment()/descendant-or-self::document-node(), \n             $root//processing-instruction()/descendant-or-self::text(), \n             $root//processing-instruction()/descendant-or-self::comment(), \n             $root//processing-instruction()/descendant-or-self::element(), \n             $root//processing-instruction()/descendant-or-self::document-node(), \n             $root//text()/descendant-or-self::processing-instruction(), \n             $root//text()/descendant-or-self::comment(), \n             $root//text()/descendant-or-self::element(), \n             $root//text()/descendant-or-self::document-node(), \n             $root//attribute()/descendant-or-self::processing-instruction(), \n             $root//attribute()/descendant-or-self::text(), \n             $root//attribute()/descendant-or-self::comment(), \n             $root//attribute()/descendant-or-self::element(), \n             $root//attribute()/descendant-or-self::document-node(), \n             $root/.., $root//parent::comment(), \n             $root//parent::processing-instruction(), \n             $root//parent::text(), \n             $root//ancestor::comment(), \n             $root//ancestor::processing-instruction(), \n             $root//ancestor::text(), \n             $root/self::comment(), \n             $root/self::processing-instruction(), \n             $root/self::text(), \n             $root/self::element(), \n             $root//element()/self::text(), \n             $root//element()/self::processing-instruction(), \n             $root//element()/self::document-node(), \n             $root//element()/self::comment(), \n             $root//processing-instruction()/self::text(), \n             $root//processing-instruction()/self::element(), \n             $root//processing-instruction()/self::document-node(), \n             $root//processing-instruction()/self::comment(), \n             $root//text()/self::processing-instruction(), \n             $root//text()/self::element(), \n             $root//text()/self::document-node(), \n             $root//text()/self::comment(), \n             $root//document-node()/self::processing-instruction(), \n             $root//document-node()/self::element(), \n             $root//document-node()/self::text(), \n             $root//document-node()/self::comment() } </empty><ex>{exists($root//*/attribute()/descendant-or-self::node())}</ex></out>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
K2-Axes-88,Error: XPST0003: Unable to parse XPath: declare variable $i := <e> <a>1</a> <b>2</b> </e>; <result> { ($i/b, $i/a)/. } </result>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-Axes-89,Error: XPST0003: Unable to parse XPath: declare default element namespace "http://typedecl"; <r> { <e attr="foo"/>/@attr } </r>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
K2-Axes-99,AssertionError: Expected executing the XPath "declare function foo() external; 1" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: declare function foo() external; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.', AssertionError: expected [Function] to throw error including 'XPST0017' but got 'XPST0003: Unable to parse XPath: declare function foo() external; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
K2-Axes-102,Error: XPST0003: Unable to parse XPath:          for $a in (/) return          for $b in $a/child::site return          for $c in $b/child::people return          for $d in $c/child::person return              if ((some $id in $d/attribute::id satisfies                      typeswitch ($id)                      case $n as node() return $id = "person0"                      default $d return ()))              then $d/child::name              else (),          for $b in /site/people/person where $b/@id="person0" return $b/name,          /site/people/person[@id eq "person0"]/name. SyntaxError: Expected "!", "!=", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "(" found.
K2-Axes-103,Error: XPST0003: Unable to parse XPath: (         declare function local:isComplexType($typeID) { string($typeID) };          "|", //*/local:isComplexType(@type), "|")!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-wild-001,Error: XPST0003: Unable to parse XPath: (         declare namespace foo="test";         let $x := <a><foo:b/><c/><d/></a> return count($x/foo:* | $x/foo:*))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
cbcl-wild-002,Error: XPST0003: Unable to parse XPath:          declare namespace foo="http://localhost/";         <a><foo:b/><foo:c/></a>/foo:b/self::foo:*. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
cbcl-path-nodes-and-atomics,AssertionError: Expected executing the XPath "         declare function local:f($x) { if ($x mod 2 = 1) then <a/> else "a" };         let $y := for $x in (1 to 10) return <e>{$x}</e> return $y/local:f(.)/a" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XPTY0018' but got 'XPST0003: Unable to parse XPath: \n        declare function local:f($x) { if ($x mod 2 = 1) then <a/> else "a" };\n        let $y := for $x in (1 to 10) return <e>{$x}</e> return $y/local:f(.)/a. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.', AssertionError: expected [Function] to throw error including 'XPTY0019' but got 'XPST0003: Unable to parse XPath: \n        declare function local:f($x) { if ($x mod 2 = 1) then <a/> else "a" };\n        let $y := for $x in (1 to 10) return <e>{$x}</e> return $y/local:f(.)/a. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
abbreviatedSyntax-2,AssertionError: for $h in (/works/employee[2]) return $h/text(): expected '\n    \n    \n    \n    Text data from Employee[2]\n  ' to equal 'Text data from Employee[2]'
abbreviatedSyntax-26,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
K2-AbbrAxes-1,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: declare function local:myFunc() { .. }; local:myFunc(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
ancestor-5,Error: XPST0003: Unable to parse XPath: exactly-one(/works/employee[1]/ancestor::works) << exactly-one(/works/employee[1]). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.
ancestor-6,Error: XPST0003: Unable to parse XPath: exactly-one(/works/employee[1]/ancestor::works) << exactly-one(/works/employee[1]/ancestor::works). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.
ancestor-7,Error: XPST0003: Unable to parse XPath: exactly-one(/works/employee[1]/ancestor::works) << exactly-one(/works/employee[1]). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.
ancestor-8,Error: XPST0003: Unable to parse XPath: exactly-one(/works/employee[1]) >> exactly-one(/works/employee[1]/ancestor::works). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.
ancestor-9,Error: XPST0003: Unable to parse XPath: exactly-one(/works/employee[1]/ancestor::works) >> exactly-one(/works/employee[1]/ancestor::works). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.
ancestor-10,Error: XPST0003: Unable to parse XPath: exactly-one(/works/employee[1]/ancestor::works) >> exactly-one(/works/employee[1]/hours). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.
K2-ancestorAxis-4,AssertionError: Expected executing the XPath "empty(attribute name {"content"}/ancestor::node())" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: empty(attribute name {"content"}/ancestor::node()). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: empty(attribute name {"content"}/ancestor::node()). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.'.
K2-ancestorAxis-5,AssertionError: Expected executing the XPath "empty(document {()}/ancestor::node())" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: empty(document {()}/ancestor::node()). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: empty(document {()}/ancestor::node()). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.'.
K2-ancestorAxis-6,AssertionError: Expected executing the XPath "empty(document {<e><f/><f/>text</e>}/ancestor::node())" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: empty(document {<e><f/><f/>text</e>}/ancestor::node()). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: empty(document {<e><f/><f/>text</e>}/ancestor::node()). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.'.
K2-ancestorAxis-9,AssertionError: Expected XPath <a> <b c=""> <c/> </b> <d/> </a>/b/c/(ancestor::*)[1] to resolve to the given XML. Expected <b c=""><c/></b> to equal <a><b c=""><c/></b><d/></a>
K2-ancestorAxis-12,AssertionError: Expected XPath <a> <b c=""> <c/> </b> <d/> </a>/b/c/(ancestor::*)[last()] to resolve to the given XML. Expected <a><b c=""><c/></b><d/></a> to equal <b c=""><c/></b>
K2-ancestorAxis-15,Error: XPST0003: Unable to parse XPath: (1, attribute name {"content"}/ancestor::node(), 1)!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
K2-ancestorAxis-17,AssertionError: Expected executing the XPath "document {()}/ancestor::node(), count(document {()}/ancestor::node()), 1" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (document {()}/ancestor::node(), count(document {()}/ancestor::node()), 1)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: document {()}/ancestor::node(), count(document {()}/ancestor::node()), 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'.
K2-ancestorAxis-18,Error: XPST0003: Unable to parse XPath: (1, text {""}/ancestor::node(), 1)!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
ancestorself-5,Error: XPST0003: Unable to parse XPath: exactly-one(/works/employee[1]/ancestor-or-self::works) << exactly-one(/works/employee[1]). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.
ancestorself-6,Error: XPST0003: Unable to parse XPath: exactly-one(/works/employee[1]/ancestor-or-self::works) << exactly-one(/works/employee[1]/ancestor-or-self::works). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.
ancestorself-7,Error: XPST0003: Unable to parse XPath: exactly-one(/works/employee[1]/ancestor-or-self::works) << exactly-one(/works/employee[1]). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.
ancestorself-8,Error: XPST0003: Unable to parse XPath: exactly-one(/works/employee[1]) >> exactly-one(/works/employee[1]/ancestor-or-self::works). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.
ancestorself-9,Error: XPST0003: Unable to parse XPath: exactly-one(/works/employee[1]/ancestor-or-self::works) >> exactly-one(/works/employee[1]/ancestor-or-self::works). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.
ancestorself-10,Error: XPST0003: Unable to parse XPath: exactly-one(/works/employee[1]/ancestor-or-self::works) >> exactly-one(/works/employee[1]/hours). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.
K2-ancestor-or-selfAxis-3,Error: XPST0003: Unable to parse XPath: deep-equal((1, (attribute name {"content"}/ancestor-or-self::node() instance of attribute(name)), 1), (1, true(), 1)). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
K2-ancestor-or-selfAxis-5,Error: XPST0003: Unable to parse XPath: let $result := (1, document {()}/ancestor-or-self::node(), 1) return $result[1] eq 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
K2-ancestor-or-selfAxis-6,Error: XPST0003: Unable to parse XPath: let $result := (1, text {""}/ancestor-or-self::node(), 1) return $result[1] eq 1. SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
followingsibling-5,Error: XPST0003: Unable to parse XPath: exactly-one(/works[1]/employee[12]/overtime/day[1]/following-sibling::day) << exactly-one(/works[1]/employee[13]). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.
followingsibling-6,Error: XPST0003: Unable to parse XPath: exactly-one(/works[1]/employee[12]/following-sibling::employee) << exactly-one(/works[1]/employee[12]/following-sibling::employee). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.
followingsibling-7,Error: XPST0003: Unable to parse XPath: exactly-one(/works[1]/employee[12]/following-sibling::employee) << exactly-one(/works[1]/employee[12]/overtime[1]). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.
followingsibling-8,Error: XPST0003: Unable to parse XPath: exactly-one(/works[1]/employee[13]) >> exactly-one(/works[1]/employee[12]/overtime[1]/day[1]/following-sibling::day). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.
followingsibling-9,Error: XPST0003: Unable to parse XPath: exactly-one(/works[1]/employee[12]/following-sibling::employee) >> exactly-one(/works[1]/employee[12]/following-sibling::employee). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.
followingsibling-10,Error: XPST0003: Unable to parse XPath: exactly-one(/works[1]/employee[12]) >> exactly-one(/works[1]/employee[12]/following-sibling::employee). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.
followingsibling-21,Error: No selector counterpart for: following.
K2-following-siblingAxis-4,Error: XPST0003: Unable to parse XPath: (         declare variable $i := <root> <child/> <child/> <child> <child2> <child3> <leaf/> </child3> </child2> </child> </root>;          root($i)//count(following-sibling::node())       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
K2-following-siblingAxis-5,Error: XPST0003: Unable to parse XPath:          declare variable $i := <root> <child/> <child/> <child> <child2> <child3> <leaf/> </child3> </child2> </child> </root>;          root($i)//following-sibling::node()       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-following-siblingAxis-6,AssertionError: expected [Function] to throw error including 'XPTY0018' but got 'XPST0003: Unable to parse XPath: \n        declare variable $i := <root> <child/> <child/> <child> <child2> <child3> <leaf/> </child3> </child2> </child> </root>; \n        root($i)//(following-sibling::node(), "BOO")\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-following-siblingAxis-10,Error: No selector counterpart for: following.
preceding-sibling-5,Error: XPST0003: Unable to parse XPath: exactly-one(/works[1]/employee[2]/preceding-sibling::employee) << exactly-one(/works[1]/employee[2]). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.
preceding-sibling-6,Error: XPST0003: Unable to parse XPath: exactly-one(/works[1]/employee[2]/preceding-sibling::employee) << exactly-one(/works[1]/employee[2]/preceding-sibling::employee). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.
preceding-sibling-7,Error: XPST0003: Unable to parse XPath: exactly-one(/works[1]/employee[2]/preceding-sibling::employee) << exactly-one(/works[1]). SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.
preceding-sibling-8,Error: XPST0003: Unable to parse XPath: exactly-one(/works[1]/employee[13]) >> exactly-one(/works[1]/employee[12]/preceding-sibling::employee[1]). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.
preceding-sibling-9,Error: XPST0003: Unable to parse XPath: exactly-one(/works[1]/employee[2]/preceding-sibling::employee) >> exactly-one(/works[1]/employee[2]/preceding-sibling::employee). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.
preceding-sibling-10,Error: XPST0003: Unable to parse XPath: exactly-one(/works[1]/employee[13]) >> exactly-one(/works[1]/employee[2]/preceding-sibling::employee). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.
K2-preceding-siblingAxis-1,Error: XPST0003: Unable to parse XPath: declare variable $i := <root> <child> <preceding2/> <child2> <preceding1/> <child3> <leaf/> </child3> <following/> </child2> <following/> </child> <following/> </root>; empty(root($i)/preceding-sibling::node()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-preceding-siblingAxis-2,Error: XPST0003: Unable to parse XPath: declare variable $i := <root> <child> <preceding2/> <child2> <preceding1/> <child3> <leaf/> </child3> <following/> </child2> <following/> </child> <following/> </root>; empty(root($i)/preceding::node()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-preceding-siblingAxis-3,Error: XPST0003: Unable to parse XPath: (declare variable $i := <root> <child> <preceding2/> <child2> <preceding1/> <child3> <leaf/> </child3> <following/> </child2> <following/> </child> <following/> </root>; count(root($i)/preceding::node())) = (0). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
K2-preceding-siblingAxis-4,Error: XPST0003: Unable to parse XPath: (declare variable $i := <root> <child> <preceding2/> <child2> <preceding1/> <child3> <leaf/> </child3> <following/> </child2> <following/> </child> <following/> </root>; count(root($i)//leaf/preceding::node())) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
K2-preceding-siblingAxis-5,Error: XPST0003: Unable to parse XPath: (declare variable $i := <root> <child> <preceding2/> <child2> <preceding1/> <child3> <leaf/> </child3> <following/> </child2> <following/> </child> <following/> </root>; root($i)//count(preceding-sibling::node()))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
unabbreviatedSyntax-3,AssertionError: for $h in (/works[1]/employee[2]) return $h/child::text(): expected '\n    \n    \n    \n    Text data from Employee[2]\n  ' to equal 'Text data from Employee[2]'
CastableAs647,Error: Casting to xs:QName is not implemented.
CastableAs648,Error: Casting to xs:QName is not implemented.
CastableAs648a,Error: Casting to xs:QName is not implemented.
K-SeqExprCastable-5,AssertionError: expected [Function] to throw error including 'XPST0051' but got 'XPST0080: Casting to xs:anyAtomicType, xs:anySimpleType or xs:NOTATION is not permitted.'
K-SeqExprCastable-6,AssertionError: expected [Function] to throw an error
K-SeqExprCastable-6a,AssertionError: expected [Function] to throw an error
K-SeqExprCastable-19,Error: Casting to xs:QName is not implemented.
K-SeqExprCastable-22,AssertionError: Expected executing the XPath "not(xs:untypedAtomic("ncname") castable as xs:QName)" to resolve to one of the expected results, but got Error: Casting to xs:QName is not implemented., Error: Casting to xs:QName is not implemented..
K2-SeqExprCastable-4,AssertionError: expected [Function] to throw an error
K2-SeqExprCastable-6,AssertionError: Expected XPath "%" castable as xs:anyURI to resolve to false: expected true to be false
K2-SeqExprCastable-7,AssertionError: Expected XPath xs:untypedAtomic("%") castable as xs:anyURI to resolve to false: expected true to be false
cbcl-castable-date-001,Error: FODT0001: Datetime year is out of bounds
cbcl-castable-date-002,Error: FODT0001: Datetime year is out of bounds
cbcl-castable-dateTime-001,Error: FODT0001: Datetime year is out of bounds
cbcl-castable-dateTime-002,Error: FODT0001: Datetime year is out of bounds
cbcl-castable-dayTimeDuration-001,AssertionError: Expected XPath "P11768614336404564651D" castable as xs:dayTimeDuration to resolve to false: expected true to be false
cbcl-castable-dayTimeDuration-002,AssertionError: Expected XPath "-P11768614336404564651D" castable as xs:duration to resolve to false: expected true to be false
cbcl-castable-duration-001,AssertionError: Expected XPath "-P768614336404564651Y" castable as xs:duration to resolve to false: expected true to be false
cbcl-castable-duration-002,AssertionError: Expected XPath "P768614336404564651Y" castable as xs:duration to resolve to false: expected true to be false
cbcl-castable-name-002,Error: XPST0017: Function fn:current-time with arity of 0 not registered. No similar functions found.
cbcl-castable-ncname-002,Error: XPST0017: Function fn:current-time with arity of 0 not registered. No similar functions found.
cbcl-castable-yearMonthDuration-001,AssertionError: Expected XPath "-P768614336404564651Y" castable as xs:yearMonthDuration to resolve to false: expected true to be false
cbcl-castable-yearMonthDuration-002,AssertionError: Expected XPath "P768614336404564651Y" castable as xs:yearMonthDuration to resolve to false: expected true to be false
cbcl-castable-gYear-001,Error: FODT0001: Datetime year is out of bounds
cbcl-castable-gYearMonth-001,Error: FODT0001: Datetime year is out of bounds
casthc12,AssertionError: xs:double(1267.43233E12) cast as xs:double: expected '1267432330000000' to equal '1.26743233E15'
casthc13,AssertionError: xs:double(1267.43233E12) cast as xs:string: expected '1267432330000000' to equal '1.26743233E15'
casthc17,AssertionError: xs:decimal(12678967.543233) cast as xs:float: expected '12678967.543233' to equal '1.2678968E7'
casthc18,AssertionError: xs:decimal(12678967.543233) cast as xs:double: expected '12678967.543233' to equal '1.2678967543233E7'
casthc24,AssertionError: xs:integer(12678967543233) cast as xs:double: expected '12678967543233' to equal '1.2678967543233E13'
CastAs010,AssertionError: xs:untypedAtomic("-10000000") cast as xs:float: expected '-10000000' to equal '-1.0E7'
CastAs015,AssertionError: xs:untypedAtomic("-10000000") cast as xs:double: expected '-10000000' to equal '-1.0E7'
CastAs051,AssertionError: xs:untypedAtomic("-0012-12-05:00") cast as xs:gYearMonth: expected '-0012-12-05' to equal '-0012-12-05:00'
CastAs055,AssertionError: xs:untypedAtomic("-0012-05:00") cast as xs:gYear: expected '-0012-05' to equal '-0012-05:00'
CastAs067,AssertionError: xs:untypedAtomic("--12-05:00") cast as xs:gMonth: expected '--12-05' to equal '--12-05:00'
CastAs092,AssertionError: xs:string("-10000000") cast as xs:float: expected '-10000000' to equal '-1.0E7'
CastAs097,AssertionError: xs:string("-10000000") cast as xs:double: expected '-10000000' to equal '-1.0E7'
CastAs133,AssertionError: xs:string("-0012-12-05:00") cast as xs:gYearMonth: expected '-0012-12-05' to equal '-0012-12-05:00'
CastAs137,AssertionError: xs:string("-0012-05:00") cast as xs:gYear: expected '-0012-05' to equal '-0012-05:00'
CastAs149,AssertionError: xs:string("--12-05:00") cast as xs:gMonth: expected '--12-05' to equal '--12-05:00'
CastAs169,AssertionError: Expected executing the XPath "xs:float("5.4321E-100") cast as xs:float" to resolve to one of the expected results, but got AssertionError: Expected XPath xs:float("5.4321E-100") cast as xs:float to resolve to 0: expected false to be true, AssertionError: expected [Function] to throw an error.
CastAs175,AssertionError: Expected XPath xs:float("5.4321E-100") cast as xs:decimal to resolve to 0: expected false to be true
CastAs201,AssertionError: xs:double("1e8") cast as xs:string: expected '100000000' to equal '1.0E8'
CastAs334,AssertionError: xs:dayTimeDuration("PT24H") cast as xs:duration: expected 'P1DT' to equal 'P1D'
CastAs338,AssertionError: xs:dayTimeDuration("P14D") cast as xs:dayTimeDuration: expected 'P14DT' to equal 'P14D'
CastAs369,AssertionError: xs:dateTime("-1999-05-31T13:20:00+14:00") cast as xs:gYearMonth: expected '1999-05+14:00' to equal '-1999-05+14:00'
CastAs371,AssertionError: xs:dateTime("-1999-05-31T13:20:00+14:00") cast as xs:gYear: expected '1999+14:00' to equal '-1999+14:00'
CastAs423,AssertionError: Expected executing the XPath "xs:date("-0012-12-03-05:00") cast as xs:gYear" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw an error, AssertionError: xs:date("-0012-12-03-05:00") cast as xs:gYear: expected '0012-05:00' to equal '-0012-05:00'.
CastAs449,AssertionError: xs:gYearMonth("-0012-12-05:00") cast as xs:gYearMonth: expected '-0012-12-05' to equal '-0012-12-05:00'
CastAs472,AssertionError: xs:gYear("-0012-05:00") cast as xs:gYear: expected '-0012-05' to equal '-0012-05:00'
CastAs544,AssertionError: xs:gMonth("--12-05:00") cast as xs:gMonth: expected '--12-05' to equal '--12-05:00'
CastAs600,AssertionError: xs:base64Binary("aA+zZ/09") cast as xs:hexBinary: expected '68FB367FD3D' to equal '680FB367FD3D'
CastAs647,AssertionError: Expected executing the XPath "xs:string(2.123456789123456789) cast as xs:decimal" to resolve to one of the expected results, but got AssertionError: xs:string(2.123456789123456789) cast as xs:decimal: expected '2.123456789123457' to equal '2.123456789123456789', AssertionError: expected [Function] to throw an error.
CastAs670,AssertionError: Expected executing the XPath "let $d1 := '2006-07-12' cast as xs:date let $oneky := xs:yearMonthDuration('P1000Y') let $d2 := $d1 + $oneky let $d3 := $d2 + $oneky let $d4 := $d3 + $oneky let $d5 := $d4 + $oneky let $d6 := $d5 + $oneky let $d7 := $d6 + $oneky let $d8 := $d7 + $oneky let $d9 := $d8 + $oneky let $d10 := $d9 + $oneky return $d10" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (let $d1 := '2006-07-12' cast as xs:date let $oneky := xs:yearMonthDuration('P1000Y') let $d2 := $d1 + $oneky let $d3 := $d2 + $oneky let $d4 := $d3 + $oneky let $d5 := $d4 + $oneky let $d6 := $d5 + $oneky let $d7 := $d6 + $oneky let $d8 := $d7 + $oneky let $d9 := $d8 + $oneky let $d10 := $d9 + $oneky return $d10)!string() => string-join(" "). SyntaxError: Expected " ", "!=", "(:", "*", "+", ",", "-", "<", "<<", "<=", "=", ">", ">=", ">>", "\n", "\r", "\t", "and", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found., AssertionError: expected [Function] to throw error including 'FODT0001' but got 'XPST0003: Unable to parse XPath: let $d1 := \'2006-07-12\' cast as xs:date let $oneky := xs:yearMonthDuration(\'P1000Y\') let $d2 := $d1 + $oneky let $d3 := $d2 + $oneky let $d4 := $d3 + $oneky let $d5 := $d4 + $oneky let $d6 := $d5 + $oneky let $d7 := $d6 + $oneky let $d8 := $d7 + $oneky let $d9 := $d8 + $oneky let $d10 := $d9 + $oneky return $d10. SyntaxError: Expected " ", "!=", "(:", "*", "+", ",", "-", "<", "<<", "<=", "=", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.'.
CastAs673a,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
CastAs673b,Error: Casting to xs:QName is not implemented.
CastAs674,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
CastAs674a,Error: Casting to xs:QName is not implemented.
CastAs675,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare function local:clarkname($q as xs:QName) as xs:string { \n          concat(\'{\', namespace-uri-from-QName($q), \'}\', local-name-from-QName($q)) \n        }; \n        let $var := <e>xml:space</e> \n        return (local:clarkname(node-name($var)), local:clarkname(xs:untypedAtomic($var)))\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
CastAs675a,AssertionError: expected [Function] to throw error including 'XPTY0117' but got 'XPST0003: Unable to parse XPath: \n        declare function local:clarkname($q as xs:QName) as xs:string { \n          concat(\'{\', namespace-uri-from-QName($q), \'}\', local-name-from-QName($q)) \n        }; \n        let $var := <e>xml:space</e> \n        return (local:clarkname(node-name($var)), local:clarkname(xs:untypedAtomic($var)))\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
CastAs677,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
CastAs678,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
CastAs682,AssertionError: xs:gYear('2017-00:30'): expected '2017-00' to equal '2017-00:30'
CastAs683,AssertionError: xs:gYearMonth('2017-07-00:30'): expected '2017-07-00' to equal '2017-07-00:30'
CastAs684,AssertionError: xs:gMonth('--07-00:30'): expected '--07-00' to equal '--07-00:30'
CastAsNamespaceSensitiveType-1,AssertionError: expected [Function] to throw error including 'XPTY0117' but got 'XPST0003: Unable to parse XPath: \n      declare function local:clarkname($q as xs:QName) as xs:string { \n      concat(\'{\', namespace-uri-from-QName($q), \'}\', local-name-from-QName($q)) \n      }; \n      local:clarkname(xs:untypedAtomic("xs:integer"))\n    \n    . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
CastAsNamespaceSensitiveType-2,AssertionError: expected [Function] to throw error including 'XPTY0117' but got 'XPST0003: Unable to parse XPath: \n      declare function local:clarkname($q as xs:QName) as xs:string { \n      concat(\'{\', namespace-uri-from-QName($q), \'}\', local-name-from-QName($q)) \n      }; \n      local:clarkname(<tag>xs:integer</tag>)\n    \n    . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
CastAsNamespaceSensitiveType-3,Error: XPST0003: Unable to parse XPath: (       declare function local:clarkname($q as xs:QName) as xs:string {        concat('{', namespace-uri-from-QName($q), '}', local-name-from-QName($q))        };        local:clarkname(xs:QName("xs:integer"))          )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
CastAsNamespaceSensitiveType-4,AssertionError: expected [Function] to throw error including 'XPTY0117' but got 'XPST0003: Unable to parse XPath: \n      declare function local:clarkname($q as xs:NOTATION) as xs:string { \n        $q cast as xs:string\n      }; \n      local:clarkname(xs:untypedAtomic("xs:integer"))\n    \n    . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
CastAsNamespaceSensitiveType-5,AssertionError: expected [Function] to throw error including 'XPTY0117' but got 'XPST0003: Unable to parse XPath: \n      declare function local:clarkname($q as xs:NOTATION) as xs:string { \n        $q cast as xs:string\n      }; \n      local:clarkname(<tag>xs:integer</tag>)\n    \n    . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
CastFOCA0003-1,AssertionError: Expected executing the XPath "xs:integer(99e100)" to resolve to one of the expected results, but got Error: FOAR0002: can not cast 9.9e+101 to xs:integer, it is out of bounds for JavaScript numbers., AssertionError: expected [Function] to throw error including 'FOCA0003' but got 'FOAR0002: can not cast 9.9e+101 to xs:integer, it is out of bounds for JavaScript numbers.'.
K-SeqExprCast-4,AssertionError: expected [Function] to throw error including 'XPST0051' but got 'XPST0080: Casting to xs:anyAtomicType, xs:anySimpleType or xs:NOTATION is not permitted.'
K-SeqExprCast-5,AssertionError: expected [Function] to throw error including 'XPST0051' but got 'XPST0081: Can not cast: type is unknown.'
K-SeqExprCast-5a,AssertionError: expected [Function] to throw error including 'XQST0052' but got 'XPST0081: Can not cast: type is unknown.'
K-SeqExprCast-7,AssertionError: expected [Function] to throw error including 'XPST0051' but got 'XPST0081: Can not cast: type is unknown.'
K-SeqExprCast-7a,AssertionError: expected [Function] to throw error including 'XQST0052' but got 'XPST0081: Can not cast: type is unknown.'
K-SeqExprCast-9,AssertionError: expected [Function] to throw error including 'XPST0051' but got 'XPST0081: Can not cast: type is unknown.'
K-SeqExprCast-9a,AssertionError: expected [Function] to throw error including 'XQST0052' but got 'XPST0081: Can not cast: type is unknown.'
K-SeqExprCast-68,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-71a,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-71b,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-127,AssertionError: Expected XPath xs:string(xs:base64Binary("aaa a")) eq "aaaa" to resolve to true: expected false to be true
K-SeqExprCast-143,Error: XPST0003: Unable to parse XPath: (xs:hexBinary(remove(("3B", 1.1), 2) treat as xs:string))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.
K-SeqExprCast-150,AssertionError: expected [Function] to throw an error
K-SeqExprCast-151,AssertionError: expected [Function] to throw an error
K-SeqExprCast-152,AssertionError: expected [Function] to throw an error
K-SeqExprCast-158,AssertionError: Expected XPath xs:string(xs:duration("-P2000Y11M5DT0H0M0.000S")) eq "-P2000Y11M5D" to resolve to true: expected false to be true
K-SeqExprCast-159,AssertionError: Expected XPath xs:string(xs:duration("P365D")) eq "P365D" to resolve to true: expected false to be true
K-SeqExprCast-161,AssertionError: Expected XPath xs:string(xs:duration("P31D")) eq "P31D" to resolve to true: expected false to be true
K-SeqExprCast-164,AssertionError: Expected XPath xs:string(xs:duration("-PT0S")) eq "PT0S" to resolve to true: expected false to be true
K-SeqExprCast-172,AssertionError: expected [Function] to throw an error
K-SeqExprCast-173,AssertionError: expected [Function] to throw an error
K-SeqExprCast-174,AssertionError: expected [Function] to throw an error
K-SeqExprCast-182,AssertionError: Expected XPath xs:string(xs:dayTimeDuration("-P5DT0H0M0.000S")) eq "-P5D" to resolve to true: expected false to be true
K-SeqExprCast-188,AssertionError: Expected XPath xs:string(xs:dayTimeDuration("-PT0S")) eq "PT0S" to resolve to true: expected false to be true
K-SeqExprCast-193,AssertionError: Expected XPath xs:string(xs:dayTimeDuration("P3D")) eq "P3D" to resolve to true: expected false to be true
K-SeqExprCast-197,AssertionError: expected [Function] to throw an error
K-SeqExprCast-198,AssertionError: expected [Function] to throw an error
K-SeqExprCast-199,AssertionError: expected [Function] to throw an error
K-SeqExprCast-200,AssertionError: expected [Function] to throw an error
K-SeqExprCast-207,AssertionError: Expected XPath xs:string(xs:yearMonthDuration("-P0M")) eq "P0M" to resolve to true: expected false to be true
K-SeqExprCast-231,AssertionError: Expected XPath xs:string(xs:gYear("1999-00:00")) eq "1999Z" to resolve to true: expected false to be true
K-SeqExprCast-268,AssertionError: Expected XPath xs:string(xs:gMonth("--01-00:00")) eq "--01Z" to resolve to true: expected false to be true
K-SeqExprCast-283,AssertionError: Expected XPath xs:string(xs:gYearMonth("1999-01-00:00")) eq "1999-01Z" to resolve to true: expected false to be true
K-SeqExprCast-295,AssertionError: expected [Function] to throw an error
K-SeqExprCast-297,AssertionError: expected [Function] to throw an error
K-SeqExprCast-298,AssertionError: expected [Function] to throw an error
K-SeqExprCast-299,AssertionError: expected [Function] to throw an error
K-SeqExprCast-307,AssertionError: Expected XPath xs:gMonthDay("--02-29+00:00") eq xs:gMonthDay("--02-29+00:00") to resolve to true: expected false to be true
K-SeqExprCast-312,AssertionError: expected [Function] to throw an error
K-SeqExprCast-326,AssertionError: Expected XPath xs:gYear(xs:dateTime("2002-11-23T23:12:23.867-00:00")) eq xs:gYear("2002Z") to resolve to true: expected false to be true
K-SeqExprCast-327,AssertionError: Expected XPath xs:gYear(xs:dateTime("2002-11-23T23:12:23.867-13:37")) eq xs:gYear("2002-13:37") to resolve to true: expected false to be true
K-SeqExprCast-328,AssertionError: Expected XPath xs:gYearMonth(xs:dateTime("2002-11-23T23:12:23.867-00:00")) eq xs:gYearMonth("2002-11Z") to resolve to true: expected false to be true
K-SeqExprCast-329,AssertionError: Expected XPath xs:gYearMonth(xs:dateTime("2002-11-23T23:12:23.867-13:37")) eq xs:gYearMonth("2002-11-13:37") to resolve to true: expected false to be true
K-SeqExprCast-330,AssertionError: Expected XPath xs:gMonth(xs:dateTime("2002-11-23T22:12:23.867-00:00")) eq xs:gMonth("--11Z") to resolve to true: expected false to be true
K-SeqExprCast-331,AssertionError: Expected XPath xs:gMonth(xs:dateTime("2002-11-23T22:12:23.867-13:37")) eq xs:gMonth("--11-13:37") to resolve to true: expected false to be true
K-SeqExprCast-332,AssertionError: Expected XPath xs:gMonthDay(xs:dateTime("2002-11-23T22:12:23.867-00:00")) eq xs:gMonthDay("--11-23Z") to resolve to true: expected false to be true
K-SeqExprCast-333,AssertionError: Expected XPath xs:gMonthDay(xs:dateTime("2002-11-23T22:12:23.867-13:37")) eq xs:gMonthDay("--11-23-13:37") to resolve to true: expected false to be true
K-SeqExprCast-334,AssertionError: Expected XPath xs:gDay(xs:dateTime("2002-11-23T22:12:23.867-00:00")) eq xs:gDay("---23Z") to resolve to true: expected false to be true
K-SeqExprCast-335,AssertionError: Expected XPath xs:gDay(xs:dateTime("2002-11-23T22:12:23.867-13:37")) eq xs:gDay("---23-13:37") to resolve to true: expected false to be true
K-SeqExprCast-336,AssertionError: Expected XPath xs:date(xs:dateTime("2002-11-23T22:12:23.867-00:00")) eq xs:date("2002-11-23Z") to resolve to true: expected false to be true
K-SeqExprCast-337,AssertionError: Expected XPath xs:date(xs:dateTime("2002-11-23T22:12:23.867-13:37")) eq xs:date("2002-11-23-13:37") to resolve to true: expected false to be true
K-SeqExprCast-338,AssertionError: Expected XPath xs:time(xs:dateTime("2002-11-23T22:12:23.867-00:00")) eq xs:time("22:12:23.867Z") to resolve to true: expected false to be true
K-SeqExprCast-339,AssertionError: Expected XPath xs:time(xs:dateTime("2002-11-23T22:12:23.867-13:37")) eq xs:time("22:12:23.867-13:37") to resolve to true: expected false to be true
K-SeqExprCast-350,AssertionError: Expected XPath string(xs:dateTime("2004-03-31T24:00:00")) eq "2004-04-01T00:00:00" to resolve to true: expected false to be true
K-SeqExprCast-374,AssertionError: Expected XPath string(xs:time("24:00:00")) eq "00:00:00" to resolve to true: expected false to be true
K-SeqExprCast-379,AssertionError: expected [Function] to throw an error
K-SeqExprCast-389,AssertionError: Expected XPath xs:gYear(xs:date("2002-11-23Z")) eq xs:gYear("2002Z") to resolve to true: expected false to be true
K-SeqExprCast-390,AssertionError: Expected XPath xs:gYear(xs:date("2002-11-23-13:37")) eq xs:gYear("2002-13:37") to resolve to true: expected false to be true
K-SeqExprCast-391,AssertionError: Expected XPath xs:gYearMonth(xs:date("2002-11-23Z")) eq xs:gYearMonth("2002-11Z") to resolve to true: expected false to be true
K-SeqExprCast-392,AssertionError: Expected XPath xs:gYearMonth(xs:date("2002-11-23-13:37")) eq xs:gYearMonth("2002-11-13:37") to resolve to true: expected false to be true
K-SeqExprCast-393,AssertionError: Expected XPath xs:gMonth(xs:date("2002-11-23-00:00")) eq xs:gMonth("--11Z") to resolve to true: expected false to be true
K-SeqExprCast-394,AssertionError: Expected XPath xs:gMonth(xs:date("2002-11-23-13:37")) eq xs:gMonth("--11-13:37") to resolve to true: expected false to be true
K-SeqExprCast-395,AssertionError: Expected XPath xs:gMonthDay(xs:date("2002-11-23-00:00")) eq xs:gMonthDay("--11-23Z") to resolve to true: expected false to be true
K-SeqExprCast-396,AssertionError: Expected XPath xs:gMonthDay(xs:date("2002-11-23-13:37")) eq xs:gMonthDay("--11-23-13:37") to resolve to true: expected false to be true
K-SeqExprCast-397,AssertionError: Expected XPath xs:gDay(xs:date("2002-11-23-00:00")) eq xs:gDay("---23Z") to resolve to true: expected false to be true
K-SeqExprCast-398,AssertionError: Expected XPath xs:gDay(xs:date("2002-11-23-13:37")) eq xs:gDay("---23-13:37") to resolve to true: expected false to be true
K-SeqExprCast-399,AssertionError: Expected XPath xs:dateTime(xs:date("2002-11-23-00:00")) eq xs:dateTime("2002-11-23T00:00:00.000Z") to resolve to true: expected false to be true
K-SeqExprCast-400,AssertionError: Expected XPath xs:dateTime(xs:date("2002-11-23-13:37")) eq xs:dateTime("2002-11-23T00:00:00.000-13:37") to resolve to true: expected false to be true
K-SeqExprCast-422,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-422a,AssertionError: expected [Function] to throw error including 'FORG0001' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-423,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-482,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-483,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-530,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-531,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-582,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-583,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-634,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-635,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-640,AssertionError: Expected XPath xs:duration(" P1Y2M3DT10H30M ") eq xs:duration(" P1Y2M3DT10H30M ") to resolve to true: expected false to be true
K-SeqExprCast-642,AssertionError: Expected XPath xs:duration(xs:untypedAtomic( "P1Y2M3DT10H30M" )) eq xs:duration("P1Y2M3DT10H30M") to resolve to true: expected false to be true
K-SeqExprCast-656,AssertionError: Expected XPath xs:duration("P1Y2M3DT10H30M") cast as xs:duration eq xs:duration("P1Y2M3DT10H30M") to resolve to true: expected false to be true
K-SeqExprCast-686,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-687,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-692,AssertionError: Expected XPath xs:yearMonthDuration(" P1Y12M ") eq xs:yearMonthDuration(" P1Y12M ") to resolve to true: expected false to be true
K-SeqExprCast-694,AssertionError: Expected XPath xs:yearMonthDuration(xs:untypedAtomic( "P1Y12M" )) eq xs:yearMonthDuration("P1Y12M") to resolve to true: expected false to be true
K-SeqExprCast-710,AssertionError: Expected XPath xs:yearMonthDuration("P1Y12M") cast as xs:yearMonthDuration eq xs:yearMonthDuration("P1Y12M") to resolve to true: expected false to be true
K-SeqExprCast-738,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-739,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-744,AssertionError: Expected XPath xs:dayTimeDuration(" P3DT2H ") eq xs:dayTimeDuration(" P3DT2H ") to resolve to true: expected false to be true
K-SeqExprCast-746,AssertionError: Expected XPath xs:dayTimeDuration(xs:untypedAtomic( "P3DT2H" )) eq xs:dayTimeDuration("P3DT2H") to resolve to true: expected false to be true
K-SeqExprCast-764,AssertionError: Expected XPath xs:dayTimeDuration("P3DT2H") cast as xs:dayTimeDuration eq xs:dayTimeDuration("P3DT2H") to resolve to true: expected false to be true
K-SeqExprCast-790,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-791,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-796,AssertionError: Expected XPath xs:dateTime(" 2002-10-10T12:00:00-05:00 ") eq xs:dateTime(" 2002-10-10T12:00:00-05:00 ") to resolve to true: expected false to be true
K-SeqExprCast-798,AssertionError: Expected XPath xs:dateTime(xs:untypedAtomic( "2002-10-10T12:00:00-05:00" )) eq xs:dateTime("2002-10-10T12:00:00-05:00") to resolve to true: expected false to be true
K-SeqExprCast-818,AssertionError: Expected XPath xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:dateTime eq xs:dateTime("2002-10-10T12:00:00-05:00") to resolve to true: expected false to be true
K-SeqExprCast-842,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-843,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-848,AssertionError: Expected XPath xs:time(" 03:20:00-05:00 ") eq xs:time(" 03:20:00-05:00 ") to resolve to true: expected false to be true
K-SeqExprCast-850,AssertionError: Expected XPath xs:time(xs:untypedAtomic( "03:20:00-05:00" )) eq xs:time("03:20:00-05:00") to resolve to true: expected false to be true
K-SeqExprCast-872,AssertionError: Expected XPath xs:time("03:20:00-05:00") cast as xs:time eq xs:time("03:20:00-05:00") to resolve to true: expected false to be true
K-SeqExprCast-894,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-895,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-900,AssertionError: Expected XPath xs:date(" 2004-10-13 ") eq xs:date(" 2004-10-13 ") to resolve to true: expected false to be true
K-SeqExprCast-902,AssertionError: Expected XPath xs:date(xs:untypedAtomic( "2004-10-13" )) eq xs:date("2004-10-13") to resolve to true: expected false to be true
K-SeqExprCast-926,AssertionError: Expected XPath xs:date("2004-10-13") cast as xs:date eq xs:date("2004-10-13") to resolve to true: expected false to be true
K-SeqExprCast-946,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-947,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-952,AssertionError: Expected XPath xs:gYearMonth(" 1999-11 ") eq xs:gYearMonth(" 1999-11 ") to resolve to true: expected false to be true
K-SeqExprCast-954,AssertionError: Expected XPath xs:gYearMonth(xs:untypedAtomic( "1999-11" )) eq xs:gYearMonth("1999-11") to resolve to true: expected false to be true
K-SeqExprCast-980,AssertionError: Expected XPath xs:gYearMonth("1999-11") cast as xs:gYearMonth eq xs:gYearMonth("1999-11") to resolve to true: expected false to be true
K-SeqExprCast-998,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-999,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-1004,AssertionError: Expected XPath xs:gYear(" 1999 ") eq xs:gYear(" 1999 ") to resolve to true: expected false to be true
K-SeqExprCast-1006,AssertionError: Expected XPath xs:gYear(xs:untypedAtomic( "1999" )) eq xs:gYear("1999") to resolve to true: expected false to be true
K-SeqExprCast-1034,AssertionError: Expected XPath xs:gYear("1999") cast as xs:gYear eq xs:gYear("1999") to resolve to true: expected false to be true
K-SeqExprCast-1050,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-1051,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-1056,AssertionError: Expected XPath xs:gMonthDay(" --11-13 ") eq xs:gMonthDay(" --11-13 ") to resolve to true: expected false to be true
K-SeqExprCast-1058,AssertionError: Expected XPath xs:gMonthDay(xs:untypedAtomic( "--11-13" )) eq xs:gMonthDay("--11-13") to resolve to true: expected false to be true
K-SeqExprCast-1088,AssertionError: Expected XPath xs:gMonthDay("--11-13") cast as xs:gMonthDay eq xs:gMonthDay("--11-13") to resolve to true: expected false to be true
K-SeqExprCast-1102,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-1103,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-1108,AssertionError: Expected XPath xs:gDay(" ---03 ") eq xs:gDay(" ---03 ") to resolve to true: expected false to be true
K-SeqExprCast-1110,AssertionError: Expected XPath xs:gDay(xs:untypedAtomic( "---03" )) eq xs:gDay("---03") to resolve to true: expected false to be true
K-SeqExprCast-1142,AssertionError: Expected XPath xs:gDay("---03") cast as xs:gDay eq xs:gDay("---03") to resolve to true: expected false to be true
K-SeqExprCast-1154,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-1155,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-1160,AssertionError: Expected XPath xs:gMonth(" --11 ") eq xs:gMonth(" --11 ") to resolve to true: expected false to be true
K-SeqExprCast-1162,AssertionError: Expected XPath xs:gMonth(xs:untypedAtomic( "--11" )) eq xs:gMonth("--11") to resolve to true: expected false to be true
K-SeqExprCast-1196,AssertionError: Expected XPath xs:gMonth("--11") cast as xs:gMonth eq xs:gMonth("--11") to resolve to true: expected false to be true
K-SeqExprCast-1206,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-1207,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-1258,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-1259,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-1310,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-1311,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-1362,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-1363,Error: Casting to xs:QName is not implemented.
K-SeqExprCast-1414,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.'
K-SeqExprCast-1415,Error: Casting to xs:QName is not implemented.
K2-SeqExprCast-1,Error: Casting to xs:QName is not implemented.
K2-SeqExprCast-5,Error: FOCA0003: can not cast 9223372036854775807 to xs:integer, it is out of bounds for JavaScript numbers.
K2-SeqExprCast-15,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K2-SeqExprCast-16,Error: FOCA0003: can not cast -999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K2-SeqExprCast-17,AssertionError: Expected executing the XPath "xs:long("-9223372036854775808")" to resolve to one of the expected results, but got Error: FOCA0003: can not cast -9223372036854775808 to xs:integer, it is out of bounds for JavaScript numbers., AssertionError: expected [Function] to throw error including 'FOAR0002' but got 'FOCA0003: can not cast -9223372036854775808 to xs:integer, it is out of bounds for JavaScript numbers.'.
K2-SeqExprCast-21,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K2-SeqExprCast-22,AssertionError: Expected executing the XPath "xs:unsignedLong("18446744073709551615")" to resolve to one of the expected results, but got Error: FOCA0003: can not cast 18446744073709551615 to xs:integer, it is out of bounds for JavaScript numbers., AssertionError: expected [Function] to throw error including 'FOAR0002' but got 'FOCA0003: can not cast 18446744073709551615 to xs:integer, it is out of bounds for JavaScript numbers.'.
K2-SeqExprCast-26,Error: FOCA0003: can not cast 999999999999999999 to xs:integer, it is out of bounds for JavaScript numbers.
K2-SeqExprCast-78,AssertionError: Expected executing the XPath "xs:long("-9223372036854775809")" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FORG0001' but got 'FOCA0003: can not cast -9223372036854775809 to xs:integer, it is out of bounds for JavaScript numbers.', AssertionError: expected [Function] to throw error including 'FOAR0002' but got 'FOCA0003: can not cast -9223372036854775809 to xs:integer, it is out of bounds for JavaScript numbers.'.
K2-SeqExprCast-90,AssertionError: Expected executing the XPath "xs:long("9223372036854775808")" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FORG0001' but got 'FOCA0003: can not cast 9223372036854775808 to xs:integer, it is out of bounds for JavaScript numbers.', AssertionError: expected [Function] to throw error including 'FOAR0002' but got 'FOCA0003: can not cast 9223372036854775808 to xs:integer, it is out of bounds for JavaScript numbers.'.
K2-SeqExprCast-177,AssertionError: expected [Function] to throw error including 'FORG0001' but got 'XPST0017: Function current-date with arity of 0 not registered. No similar functions found.'
K2-SeqExprCast-178,AssertionError: expected [Function] to throw error including 'FORG0001' but got 'XPST0017: Function current-time with arity of 0 not registered. No similar functions found.'
K2-SeqExprCast-179,AssertionError: expected [Function] to throw error including 'FORG0001' but got 'XPST0017: Function current-dateTime with arity of 0 not registered. No similar functions found.'
K2-SeqExprCast-210,AssertionError: expected [Function] to throw an error
K2-SeqExprCast-214,AssertionError: xs:double(xs:int("-1873914410")): expected '-1873914410' to equal '-1.87391441E9'
K2-SeqExprCast-231,AssertionError: expected [Function] to throw an error
K2-SeqExprCast-232,AssertionError: expected [Function] to throw an error
K2-SeqExprCast-422,AssertionError: expected [Function] to throw an error
K2-SeqExprCast-423,AssertionError: expected [Function] to throw an error
K2-SeqExprCast-424,AssertionError: expected [Function] to throw an error
K2-SeqExprCast-480,AssertionError: xs:untypedAtomic("xs:untypedAtomic"), xs:dateTime("2002-10-10T23:02:12Z"), xs:date("2002-10-10Z"), xs:time("23:02:12Z"),                 xs:duration("P12M"), xs:dayTimeDuration("PT1S"), xs:yearMonthDuration("P1M"), xs:float("3e3"), xs:double("4e4"),                 xs:decimal("2.0"), xs:integer("16"), xs:nonPositiveInteger("0"), xs:negativeInteger("-4"), xs:long("5"),                 xs:int("6"), xs:short("7"), xs:byte("8"), xs:nonNegativeInteger("9"), xs:unsignedLong("10"),                 xs:unsignedInt("11"), xs:unsignedShort("12"), xs:unsignedByte("13"), xs:positiveInteger("14"),                 xs:gYearMonth("1976-02Z"), xs:gYear("2005-12:00"), xs:gMonthDay("--12-25-14:00"),                 xs:gDay("---25-14:00"), xs:gMonth("--12-14:00"), xs:boolean("true"), xs:base64Binary("aaaa"),                 xs:hexBinary("FFFF"), xs:anyURI("http://example.com/"), xs:QName("localName"),                 xs:string("An xs:string"), xs:normalizedString("normalizedString"), xs:token("token"),                 xs:language("language"), xs:NMTOKEN("NMTOKEN"), xs:Name("Name"), xs:NCName("NCName"),                 xs:ID("ID"), xs:IDREF("IDREF"), xs:ENTITY("ENTITY"): expected 'xs:untypedAtomic 2002-10-10T23:02:12Z 2002-10-10Z 23:02:12Z P1Y PT1S P1M 3000 40000 2 16 0 -4 5 6 7 8 9 10 11 12 13 14 1976-02Z 2005-12 --12-25-14:00 ---25-14:00 --12-14 true aaaa FFFF http://example.com/ localName An xs:string normalizedString token language NMTOKEN Name NCName ID IDREF ENTITY' to equal '\n             xs:untypedAtomic 2002-10-10T23:02:12Z 2002-10-10Z 23:02:12Z P1Y PT1S P1M 3000 40000 2 16 0\n             -4 5 6 7 8 9 10 11 12 13 14 1976-02Z 2005-12:00 --12-25-14:00 ---25-14:00 --12-14:00 true\n             aaaa FFFF http://example.com/ localName An xs:string normalizedString token language\n             NMTOKEN Name NCName ID IDREF ENTITY'
K2-SeqExprCast-499,AssertionError: expected [Function] to throw error including 'FORG0001' but got 'XPST0017: Function current-time with arity of 0 not registered. No similar functions found.'
K2-SeqExprCast-500,AssertionError: expected [Function] to throw error including 'FORG0001' but got 'XPST0017: Function current-date with arity of 0 not registered. No similar functions found.'
K2-SeqExprCast-504,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
K2-SeqExprCast-505,AssertionError: expected [Function] to throw an error
cbcl-cast-dayTimeDuration-001,AssertionError: expected [Function] to throw an error
cbcl-cast-dayTimeDuration-002,AssertionError: expected [Function] to throw an error
cbcl-cast-decimal-001,AssertionError: Expected executing the XPath "1.7976931348623157E+308 cast as xs:decimal" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw an error, AssertionError: 1.7976931348623157E+308 cast as xs:decimal: expected false to be true.
cbcl-cast-decimal-002,AssertionError: Expected executing the XPath "-1.7976931348623157E+308 cast as xs:decimal" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw an error, AssertionError: -1.7976931348623157E+308 cast as xs:decimal: expected false to be true.
cbcl-cast-decimal-003,AssertionError: Expected executing the XPath "xs:float('3.402823e38') cast as xs:decimal" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw an error, AssertionError: xs:float('3.402823e38') cast as xs:decimal: expected false to be true.
cbcl-cast-decimal-004,AssertionError: Expected executing the XPath "xs:float('-3.402823e38') cast as xs:decimal" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw an error, AssertionError: xs:float('-3.402823e38') cast as xs:decimal: expected false to be true.
cbcl-cast-duration-001,AssertionError: expected [Function] to throw an error
cbcl-cast-duration-002,AssertionError: expected [Function] to throw an error
cbcl-cast-entity-002,AssertionError: expected [Function] to throw error including 'FORG0001' but got 'XPST0017: Function fn:current-time with arity of 0 not registered. No similar functions found.'
cbcl-cast-id-002,AssertionError: expected [Function] to throw error including 'FORG0001' but got 'XPST0017: Function fn:current-time with arity of 0 not registered. No similar functions found.'
cbcl-cast-idref-002,AssertionError: expected [Function] to throw error including 'FORG0001' but got 'XPST0017: Function fn:current-time with arity of 0 not registered. No similar functions found.'
cbcl-cast-integer-001,AssertionError: Expected executing the XPath "1.7976931348623157E+308 cast as xs:integer" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FOCA0003' but got 'FOAR0002: can not cast 1.7976931348623157e+308 to xs:integer, it is out of bounds for JavaScript numbers.', Error: FOAR0002: can not cast 1.7976931348623157e+308 to xs:integer, it is out of bounds for JavaScript numbers..
cbcl-cast-integer-002,AssertionError: Expected executing the XPath "-1.7976931348623157E+308 cast as xs:integer" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FOCA0003' but got 'FOAR0002: can not cast -1.7976931348623157e+308 to xs:integer, it is out of bounds for JavaScript numbers.', Error: FOAR0002: can not cast -1.7976931348623157e+308 to xs:integer, it is out of bounds for JavaScript numbers..
cbcl-cast-integer-003,AssertionError: Expected executing the XPath "xs:float('3.402823e38') cast as xs:integer" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FOCA0003' but got 'FOAR0002: can not cast 3.402823e+38 to xs:integer, it is out of bounds for JavaScript numbers.', Error: FOAR0002: can not cast 3.402823e+38 to xs:integer, it is out of bounds for JavaScript numbers..
cbcl-cast-integer-004,AssertionError: Expected executing the XPath "xs:float('-3.402823e38') cast as xs:integer" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FOCA0003' but got 'FOAR0002: can not cast -3.402823e+38 to xs:integer, it is out of bounds for JavaScript numbers.', Error: FOAR0002: can not cast -3.402823e+38 to xs:integer, it is out of bounds for JavaScript numbers..
cbcl-cast-long-003,AssertionError: expected [Function] to throw error including 'FORG0001' but got 'FOCA0003: can not cast 9223372036854775808 to xs:integer, it is out of bounds for JavaScript numbers.'
cbcl-cast-long-004,AssertionError: expected [Function] to throw error including 'FORG0001' but got 'FOCA0003: can not cast -9223372036854775809 to xs:integer, it is out of bounds for JavaScript numbers.'
cbcl-cast-name-002,AssertionError: expected [Function] to throw error including 'FORG0001' but got 'XPST0017: Function fn:current-time with arity of 0 not registered. No similar functions found.'
cbcl-cast-ncname-002,AssertionError: expected [Function] to throw error including 'FORG0001' but got 'XPST0017: Function fn:current-time with arity of 0 not registered. No similar functions found.'
cbcl-cast-unsignedLong-003,AssertionError: expected [Function] to throw error including 'FORG0001' but got 'FOCA0003: can not cast 18446744073709551616 to xs:integer, it is out of bounds for JavaScript numbers.'
cbcl-cast-yearMonthDuration-001,AssertionError: expected [Function] to throw an error
cbcl-cast-yearMonthDuration-002,AssertionError: expected [Function] to throw an error
cbcl-cast-gYear-002,AssertionError: expected [Function] to throw an error
cbcl-cast-gYear-003,AssertionError: expected [Function] to throw an error
cbcl-cast-gYear-003a,AssertionError: Expected executing the XPath ""-0000" cast as xs:gYear" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw an error, AssertionError: Expected XPath "-0000" cast as xs:gYear to (deep equally) resolve to xs:gYear('0000'): expected false to be true.
cbcl-cast-gYearMonth-003,AssertionError: expected [Function] to throw an error
cbcl-cast-gYearMonth-004,AssertionError: "-0000-05" cast as xs:gYearMonth: expected '-0000-05' to equal '0000-05'
XQueryComment014,Error: XPST0003: Unable to parse XPath: ((: Name: XQueryComment014 :) (: Description: Comments inside a cast expression :)   "10" cast as (: type comment :) xs:integer ?  ) = (10). SyntaxError: Expected " ", "!=", "(:", ")", "*", "+", ",", "-", "<", "<<", "<=", "=", ">", ">=", ">>", "\n", "\r", "\t", "and", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "?" found.
K2-XQueryComment-3,Error: XPST0003: Unable to parse XPath: (:*******************************************************:) (: Test: K2-XQueryComment-3                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:21+01:00                       :) (: Purpose: Have a computed comment constructor as a last step. :) (:*******************************************************:) let $i := <e>                                             <b/>                                             <b/>                                             <b/>                                         </e>                                         return $i/b/comment(: some : content (:some content:):){"content"}  . SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
Constr-compattr-name-1,Error: XPST0003: Unable to parse XPath: element elem {attribute attr {'text'}}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.
Constr-compattr-name-2,Error: XPST0003: Unable to parse XPath: declare namespace foo="http://www.example.com/foo"; element elem {attribute foo:attr {'text'}}. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
Constr-compattr-name-3,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPST0003: Unable to parse XPath: element elem {attribute foo:attr {\'text\'}}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.'
Constr-compattr-name-4,Error: XPST0003: Unable to parse XPath: let $result := (element x { attribute Q{http://example.com/x}y { } }) return $result[self::x/@*[local-name()='y' and namespace-uri()='http://example.com/x']]. SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "x" found.
Constr-compattr-compname-1,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: element elem {attribute {()} {\'text\'}}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.'
Constr-compattr-compname-2,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: element elem {attribute {\'one\', \'two\'} {\'text\'}}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.'
Constr-compattr-compname-3,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: element elem {attribute {xs:untypedAtomic(\'one\'), xs:untypedAtomic(\'two\')} {\'text\'}}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.'
Constr-compattr-compname-4,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: element elem {attribute {//a} {\'text\'}}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.'
Constr-compattr-compname-5,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: element elem {attribute {1,2} {\'text\'}}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.'
Constr-compattr-compname-6,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: element elem {attribute {123} {\'text\'}}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.'
Constr-compattr-compname-7,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: element elem {attribute {xs:dateTime("1999-05-31T13:20:00")} {\'text\'}}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.'
Constr-compattr-compname-8,Error: XPST0003: Unable to parse XPath: element elem {attribute {//*:NCName[1]} {'text'}}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.
Constr-compattr-compname-9,Error: XPST0003: Unable to parse XPath: element elem {attribute {xs:QName('aQname')} {'text'}}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.
Constr-compattr-compname-10,Error: XPST0003: Unable to parse XPath: element elem {attribute {'attr'} {'text'}}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.
Constr-compattr-compname-11,Error: XPST0003: Unable to parse XPath: element elem {attribute {'attr', ()} {'text'}}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.
Constr-compattr-compname-12,Error: XPST0003: Unable to parse XPath: element elem {attribute {(), 'attr'} {'text'}}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.
Constr-compattr-compname-13,Error: XPST0003: Unable to parse XPath: <elem xmlns:foo="http://www.example.com/foo">{element elem {attribute {'foo:attr'} {}}}</elem>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "e" found.
Constr-compattr-compname-14,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: element elem {attribute {\'foo:attr\'} {}}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.'
Constr-compattr-compname-15,Error: XPST0003: Unable to parse XPath: element elem {attribute {xs:untypedAtomic('attr')} {'text'}}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.
Constr-compattr-compname-16,Error: XPST0003: Unable to parse XPath: <elem xmlns:foo="http://www.example.com/foo">{attribute {xs:untypedAtomic('foo:attr')} {'text'}}</elem>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.
Constr-compattr-compname-17,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: element elem {attribute {xs:untypedAtomic(\'foo:elem\')} {\'text\'}}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.'
Constr-compattr-compname-18,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: element elem {attribute {\'el em\'} {\'text\'}}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.'
Constr-compattr-compname-19,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: element elem {attribute {xs:untypedAtomic(\'el em\')} {\'text\'}}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.'
Constr-compattr-doc-1,Error: XPST0003: Unable to parse XPath: element elem {attribute attr {., .}}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.
Constr-compattr-parent-1,Error: XPST0003: Unable to parse XPath: (count((attribute attr {})/..)) = (0). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "a" found.
Constr-compattr-string-1,Error: XPST0003: Unable to parse XPath: (fn:string(attribute attr {'a', element a {}, 'b'}))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "a" found.
Constr-compattr-data-1,Error: XPST0003: Unable to parse XPath: (fn:data(attribute attr {'a', element a {}, 'b'}))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "a" found.
Constr-compattr-enclexpr-1,Error: XPST0003: Unable to parse XPath: element elem {attribute attr {1,'string',3.14,xs:float('1.2345e-2'),xs:dateTime('2002-04-02T12:00:00-01:00')}}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.
Constr-compattr-enclexpr-2,Error: XPST0003: Unable to parse XPath: element elem {attribute attr {<elem>123</elem>, (<elem attr='456'/>)/@attr, (<elem>789</elem>)/text()}}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.
Constr-compattr-enclexpr-3,Error: XPST0003: Unable to parse XPath: element elem {attribute attr {1,'',2}}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.
Constr-compattr-enclexpr-4,Error: XPST0003: Unable to parse XPath: element elem {attribute attr {1,<a/>,2}}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.
Constr-compattr-id-1,Error: XPST0003: Unable to parse XPath: element elem {attribute xml:id {"ncname"}}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.
Constr-compattr-id-2,AssertionError: Expected executing the XPath "element elem {attribute xml:id {" ab c d "}}" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: element elem {attribute xml:id {" ab c d "}}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found., AssertionError: expected [Function] to throw error including 'XQDY0091' but got 'XPST0003: Unable to parse XPath: element elem {attribute xml:id {" ab c d "}}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.'.
constattrerr-1,AssertionError: expected [Function] to throw error including 'XQDY0044' but got 'XPST0003: Unable to parse XPath: attribute xmlns {}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "x" found.'
K2-ComputeConAttr-2,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: <elem> <?target content ?> {attribute name {"content"}} </elem>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.'
K2-ComputeConAttr-3,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: <elem> {"a string", attribute name {"content"}} </elem>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.'
K2-ComputeConAttr-4,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: <elem> {"a string", attribute name {"content"}} </elem>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.'
K2-ComputeConAttr-5,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: <elem> <![CDATA[]]> {attribute name {"content"}} </elem>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.'
K2-ComputeConAttr-6,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: <elem> <![CDATA[content]]> {attribute name {"content"}} </elem>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.'
K2-ComputeConAttr-7,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: <elem> <!-- content --> {attribute name {"content"}} </elem>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.'
K2-ComputeConAttr-8,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: <elem> <!-- comment --> { "a string", 999, attribute name {"content"}, xs:hexBinary("FF") } </elem>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.'
K2-ComputeConAttr-9,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: <elem> <!-- comment --> { "a string", 999, ("another string", attribute name {"content"}, 383), xs:hexBinary("FF") } </elem>. SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.'
K2-ComputeConAttr-10,Error: XPST0003: Unable to parse XPath: <a> <?target content?> {<b>{attribute name{"content"}}</b>} </a>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.
K2-ComputeConAttr-11,Error: XPST0003: Unable to parse XPath: <a>{(<?target content?>, attribute name{"content"})[2]} </a>. SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
K2-ComputeConAttr-12,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: <a> <!-- content --> {attribute name{"content"}} </a>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.'
K2-ComputeConAttr-13,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: <foo > <doo/> {attribute name {"content"}} </foo>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.'
K2-ComputeConAttr-14,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: declare function local:myFunc() { <a/> }; <b> {local:myFunc()} {attribute name {"content"}} </b>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K2-ComputeConAttr-15,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: declare function local:myFunc() { comment {"content"} }; <b> {local:myFunc()} {attribute name {"content"}} </b>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K2-ComputeConAttr-16,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: declare function local:myFunc() as element()+ { <a/> }; <b> {local:myFunc()} {attribute name {"content"}} </b>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K2-ComputeConAttr-17,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: declare function local:myFunc() as item() { <a/> }; <b> {local:myFunc()} {attribute name {"content"}} </b>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K2-ComputeConAttr-18,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: declare function local:myFunc() as item() { <a/> }; <b> {local:myFunc()} {attribute name {"content"}} </b>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K2-ComputeConAttr-19,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: declare function local:myFunc($recurse as xs:integer) { <nested> { if ($recurse = 0) then () else local:myFunc($recurse - 1) } </nested> }; <b> {local:myFunc(3)} {attribute name {"content"}} </b>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K2-ComputeConAttr-20,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: declare function local:myFunc($recurse as xs:integer) as item() { <nested> { if ($recurse = 0) then () else local:myFunc($recurse - 1) } </nested> }; <b> {local:myFunc(3)} {attribute name {"content"}} </b>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K2-ComputeConAttr-21,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: declare function local:myFunc() { <elem/>, attribute name {"content"} }; <b> {local:myFunc()} </b>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K2-ComputeConAttr-22,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: declare variable $myVar := (<elem/>, attribute name {"content"}); <b> {$myVar} </b>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-ComputeConAttr-23,Error: XPST0003: Unable to parse XPath: declare variable $myVar := (<elem/>, attribute name {"content"}); <b> {$myVar[2]} </b>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-ComputeConAttr-24,Error: XPST0003: Unable to parse XPath: declare variable $myVar := (attribute name {"content"}, <elem/>); <b> {$myVar[2]} </b>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-ComputeConAttr-25,Error: XPST0003: Unable to parse XPath: declare function local:myFunc($recurse as xs:integer) { attribute {concat("name", $recurse)} {"content"} , if ($recurse = 0) then () else local:myFunc($recurse - 1) }; <b> {local:myFunc(2)} {attribute name {"content"}} </b>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
K2-ComputeConAttr-26,Error: XPST0003: Unable to parse XPath: declare function local:myFunc() { attribute name {"content"}, <elem/> }; <b> {local:myFunc()} </b>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
K2-ComputeConAttr-27,Error: XPST0003: Unable to parse XPath: declare function local:myFunc() { <elem/>, attribute name {"content"} }; <b> {local:myFunc()[2]} </b>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
K2-ComputeConAttr-28,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: declare variable $local:myVar := <a/>; <b> {$local:myVar} {attribute name {"content"}} </b>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-ComputeConAttr-29,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: declare variable $local:myVar as item() := <a/>; <b> {$local:myVar} {attribute name {"content"}} </b>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-ComputeConAttr-30,Error: XPST0003: Unable to parse XPath: declare variable $local:myVar := attribute n2 {"content"}; <b> {$local:myVar} {attribute name {"content"}} </b>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-ComputeConAttr-31,Error: XPST0003: Unable to parse XPath: declare function local:myFunc() { attribute n2 {"content"} }; <b> {local:myFunc()} {attribute name {"content"}} </b>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
K2-ComputeConAttr-32,Error: XPST0003: Unable to parse XPath: <e> { attribute name {<anElement/>}, attribute name2 {"content"} } </e>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.
K2-ComputeConAttr-33,Error: XPST0003: Unable to parse XPath: <e> { attribute name {"content"}, attribute name2 {"content"} } </e>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.
K2-ComputeConAttr-34,Error: XPST0003: Unable to parse XPath: <e> { attribute name {xs:hexBinary("ff")}, attribute name2 {"content"} } </e>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.
K2-ComputeConAttr-35,Error: XPST0003: Unable to parse XPath: <elem><![CDATA[]]>{attribute name {"content"}}<alem/> </elem>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.
K2-ComputeConAttr-37,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPST0003: Unable to parse XPath: attribute xmlns:localName {"content"}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "x" found.'
K2-ComputeConAttr-38,AssertionError: Expected executing the XPath "attribute {"xmlns:localName"} {"content"}" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQDY0044' but got 'XPST0003: Unable to parse XPath: attribute {"xmlns:localName"} {"content"}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.', AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: attribute {"xmlns:localName"} {"content"}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'.
K2-ComputeConAttr-39,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPST0003: Unable to parse XPath: attribute aPrefix:localName {"content"}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "a" found.'
K2-ComputeConAttr-40,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: attribute {"aPrefix:localName"} {"content"}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
K2-ComputeConAttr-41,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: attribute {xs:untypedAtomic("aPrefix::localName")} {"content"}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
K2-ComputeConAttr-42,AssertionError: expected [Function] to throw error including 'XQST0070' but got 'XPST0003: Unable to parse XPath: \n        declare namespace prefix = "http://www.w3.org/2000/xmlns/"; \n        <e>{attribute prefix:localName {"content"}}</e>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
K2-ComputeConAttr-43,AssertionError: expected [Function] to throw error including 'XQST0070' but got 'XPST0003: Unable to parse XPath: declare namespace prefix = "http://www.w3.org/2000/xmlns/"; <e>{attribute {"prefix:localName"} {"content"}}</e>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
K2-ComputeConAttr-44,AssertionError: expected [Function] to throw error including 'XQDY0044' but got 'XPST0003: Unable to parse XPath: attribute {"xmlns"} {"content"}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
K2-ComputeConAttr-45,AssertionError: expected [Function] to throw error including 'XQDY0044' but got 'XPST0003: Unable to parse XPath: attribute xmlns {"content"}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "x" found.'
K2-ComputeConAttr-46,AssertionError: expected [Function] to throw error including 'XQDY0044' but got 'XPST0003: Unable to parse XPath: declare default element namespace "http://www.example.com/"; <e>{attribute xmlns {"content"}}</e>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'
K2-ComputeConAttr-47,Error: XPST0003: Unable to parse XPath: data(attribute foo {"content"}) instance of xs:untypedAtomic. SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-ComputeConAttr-48,AssertionError: Expected executing the XPath "string(attribute xml:id {" ab c d "})" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (string(attribute xml:id {" ab c d "}))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "x" found., AssertionError: expected [Function] to throw error including 'XQDY0091' but got 'XPST0003: Unable to parse XPath: string(attribute xml:id {" ab c d "}). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "x" found.'.
K2-ComputeConAttr-49,AssertionError: expected [Function] to throw error including 'XQDY0025' but got 'XPST0003: Unable to parse XPath: declare namespace a = "http://example.com/A"; declare namespace b = "http://example.com/A"; <e> { attribute a:localName {()}, attribute b:localName {()} } </e>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
K2-ComputeConAttr-50,AssertionError: expected [Function] to throw error including 'XQDY0025' but got 'XPST0003: Unable to parse XPath: <e> { attribute {QName("http://example.com/", "attr")} {()}, attribute {QName("http://example.com/", "attr")} {()} } </e>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.'
K2-ComputeConAttr-51,Error: XPST0003: Unable to parse XPath: (<e> { attribute {QName("http://example.com/", "attr")} {()} } </e>) instance of element(e). SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.
K2-ComputeConAttr-52,AssertionError: expected [Function] to throw error including 'XQDY0025' but got 'XPST0003: Unable to parse XPath: <e xmlns:p="http://example.com/" p:attr=""> { attribute {QName("http://example.com/", "p:attr")} {()} } </e>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.'
K2-ComputeConAttr-53,Error: XPST0003: Unable to parse XPath: (<e> { attribute {QName("http://example.com/", "attr")} {()} } </e>) instance of element(e). SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.
K2-ComputeConAttr-54,Error: XPST0003: Unable to parse XPath: string-length(xs:NCName(prefix-from-QName(node-name(attribute {QName("http://example.com/", "attr")} {()})))) > 0. SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
K2-ComputeConAttr-55,Error: XPST0003: Unable to parse XPath: (prefix-from-QName(node-name(attribute {QName("http://www.w3.org/XML/1998/namespace", "attr")} {()})))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
K2-ComputeConAttr-56,Error: XPST0003: Unable to parse XPath: <e> { attribute {QName("http://www.w3.org/XML/1998/namespace", "space")} {"default"} } </e>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.
K2-ComputeConAttr-57,AssertionError: expected [Function] to throw error including 'XQDY0044' but got 'XPST0003: Unable to parse XPath: <e> { attribute {QName("http://www.w3.org/2000/xmlns/", "space")} {"default"} } </e>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.'
K2-ComputeConAttr-58,Error: XPST0003: Unable to parse XPath: <e xmlns:p="http://example.com/" p:attr1="value"> { attribute {QName("http://example.com/", "attr2")} {()} } </e>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.
K2-ComputeConAttr-59,AssertionError: Expected executing the XPath "<a> { attribute xml:id {"1"} } </a>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: <a> { attribute xml:id {"1"} } </a>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "x" found., AssertionError: expected [Function] to throw error including 'XQDY0091' but got 'XPST0003: Unable to parse XPath: <a> { attribute xml:id {"1"} } </a>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "x" found.'.
K2-ComputeConAttr-60,AssertionError: Expected executing the XPath "<a> { attribute xml:space {"DEFAULT"} } </a>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: <a> { attribute xml:space {"DEFAULT"} } </a>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "x" found., AssertionError: expected [Function] to throw error including 'XQDY0092' but got 'XPST0003: Unable to parse XPath: <a> { attribute xml:space {"DEFAULT"} } </a>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "x" found.'.
K2-ComputeConAttr-61,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: let $x := ( attribute a { "a" }, element b { "b" }, attribute c { "c" } ) return <foo> { $x } </foo>. SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "a" found.'
cbcl-constr-compattr-001,AssertionError: expected [Function] to throw error including 'XQDY0044' but got 'XPST0003: Unable to parse XPath: for $a in attribute { fn:QName("http://www.w3.org/2000/xmlns/", "namespace:foo") } { "bar" } return name($a). SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found.'
cbcl-constr-compattr-002,AssertionError: expected [Function] to throw error including 'XQDY0044' but got 'XPST0003: Unable to parse XPath: for $a in attribute { fn:QName("http://www.example.com/", "xmlns:foo") } { "bar" } return name($a). SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found.'
cbcl-constr-compattr-003,AssertionError: expected [Function] to throw error including 'XQDY0044' but got 'XPST0003: Unable to parse XPath: for $a in attribute { "xmlns" } { "bar" } return name($a). SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found.'
cbcl-constr-compattr-005,AssertionError: expected [Function] to throw error including 'XQDY0044' but got 'XPST0003: Unable to parse XPath: \n      \tfor $a in attribute { fn:QName("http://www.example.com/", "xml:foo") } { "bar" } \n      \treturn name($a)\n      . SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found.'
cbcl-constr-compattr-006,AssertionError: expected [Function] to throw error including 'XQDY0044' but got 'XPST0003: Unable to parse XPath: \n      \tfor $a in attribute { fn:QName("http://www.w3.org/XML/1998/namespace", "sgml:foo") } { "bar" } \n      \treturn name($a)\n      . SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found.'
cbcl-constr-compattr-007,Error: XPST0003: Unable to parse XPath:        	<element xmlns:sgml="http://www.example.com/other"> {        		for $a in attribute { fn:QName("http://www.example.com/", "sgml:foo") } { }        		return concat(name($a), "=", namespace-uri($a)) }        	</element>       . SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found.
cbcl-constr-compattr-008,Error: XPST0003: Unable to parse XPath:        	declare function local:factorial($arg as xs:integer) as xs:integer {        		if ($arg le 1) then 1 else $arg * local:factorial($arg - 1)        	};        	<element> { attribute { fn:QName("http://www.example.com/", "sgml:foo") } { local:factorial(5) } } </element>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-constr-compattr-009,Error: XPST0003: Unable to parse XPath:        	declare function local:even-range($arg as xs:integer) as xs:integer* { (1 to $arg)[. mod 2 = 9] };        	<element> { attribute { 'attr' } { local:even-range(0) } } </element>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
Constr-docnode-adjtext-1,Error: XPST0003: Unable to parse XPath: (count((document {1, 'string', 1,2e3})/text())) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
Constr-docnode-adjtext-2,Error: XPST0003: Unable to parse XPath: (count((document {1, //text(), 'string'})/text())) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
Constr-docnode-adjtext-3,Error: XPST0003: Unable to parse XPath: (count((document {1, 2, <a/>, 3, 4, <b/>, 5, 6})/text())) = (3). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
Constr-docnode-nested-1,Error: XPST0003: Unable to parse XPath: (document {1, document {2, document {document {()}, document {3}}, 4}})!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
Constr-docnode-nested-2,Error: XPST0003: Unable to parse XPath: document {/root}. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
Constr-docnode-nested-3,Error: XPST0003: Unable to parse XPath: (count(document {1, document{2}, document { document {()}, document {3}}, 4}/text())) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
Constr-docnode-nested-4,Error: XPST0003: Unable to parse XPath: (count(document {"", document{""}, document { document {()}, document {""}}, ""}/text())) = (0). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
Constr-docnode-enclexpr-1,Error: XPST0003: Unable to parse XPath: (document {()})!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
Constr-docnode-enclexpr-2,Error: XPST0003: Unable to parse XPath: (document {1,'a',3.5,4e2})!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
Constr-docnode-enclexpr-3,Error: XPST0003: Unable to parse XPath: document {1,//a,2,3,//comment(),4,5,//processing-instruction(),6,7,//text(),8}. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
Constr-docnode-enclexpr-4,Error: XPST0003: Unable to parse XPath: (document {1, '', 2})!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
Constr-docnode-nodeid-1,Error: XPST0003: Unable to parse XPath: for $x in <a/>, $y in document {$x} return exactly-one($y/a) is $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found.
Constr-docnode-nodeid-3,Error: XPST0003: Unable to parse XPath: for $x in <!--comment-->, $y in document {$x} return exactly-one($y/comment()) is $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found.
Constr-docnode-nodeid-4,Error: XPST0003: Unable to parse XPath: for $x in <?pi content?>, $y in document {$x} return exactly-one($y/processing-instruction()) is $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found.
Constr-docnode-nodeid-5,Error: XPST0003: Unable to parse XPath: for $x in <a>text</a>, $y in document {$x/text()} return exactly-one($y/text()) is exactly-one($x/text()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found.
Constr-docnode-constrmod-1,Error: XPST0003: Unable to parse XPath: (declare construction strip; fn:count(fn:data((document {//*:idrefs})/*))) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "c" found.
Constr-docnode-constrmod-2,AssertionError: Expected executing the XPath "declare construction preserve; fn:count(fn:data((document {//*:idrefs})/*))" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare construction preserve; fn:count(fn:data((document {//*:idrefs})/*))) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "c" found., Error: XPST0003: Unable to parse XPath: (declare construction preserve; fn:count(fn:data((document {//*:idrefs})/*))) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "c" found..
Constr-docnode-constrmod-3,AssertionError: expected [Function] to throw error including 'FORG0001' but got 'XPST0003: Unable to parse XPath: declare construction strip; (document {//*:decimal})/* cast as xs:integer. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.'
Constr-docnode-constrmod-4,AssertionError: Expected executing the XPath "declare construction preserve; (document {//*:decimal})/* cast as xs:integer" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare construction preserve; (document {//*:decimal})/* cast as xs:integer) = (12678967). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "c" found., AssertionError: expected [Function] to throw error including 'FORG0001' but got 'XPST0003: Unable to parse XPath: declare construction preserve; (document {//*:decimal})/* cast as xs:integer. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.'.
Constr-docnode-doc-1,AssertionError: Expected executing the XPath "document {., .}" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: document {., .}. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: document {., .}. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'.
Constr-docnode-parent-1,AssertionError: Expected executing the XPath "count((document {()})/..)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (count((document {()})/..)) = (0). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: count((document {()})/..). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.'.
Constr-docnode-string-1,Error: XPST0003: Unable to parse XPath: (fn:string(document {'a', element a {}, 'b'}))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
Constr-docnode-data-1,Error: XPST0003: Unable to parse XPath: (fn:data(document {'a', element a {}, 'b'}))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
Constr-docnode-attr-1,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: document {//@mark}. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-docnode-attr-2,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: document {<a/>, //@mark}. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-docnode-attr-3,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: document {<a/>, //@mark, <b/>}. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
K2-ConDocNode-3,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: document{"some text", <e/>, attribute name {"content"}}. SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\\-.0-9-], [-], or end of input but "{" found.'
K2-ConDocNode-4,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: document{<e/>, attribute name {"content"}, "some text"}. SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\\-.0-9-], [-], or end of input but "{" found.'
K2-ConDocNode-5,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: document{attribute name {"content"}, <e/>, "some text"}. SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\\-.0-9-], [-], or end of input but "{" found.'
K2-ConDocNode-6,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: string(document{"some text", <e/>, attribute name {"content"}}). SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\\-.0-9-], or [-] but "{" found.'
K2-ConDocNode-7,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: string(document{<e/>, attribute name {"content"}, "some text"}). SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\\-.0-9-], or [-] but "{" found.'
K2-ConDocNode-8,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: string(document{attribute name {"content"}, <e/>, "some text"}). SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\\-.0-9-], or [-] but "{" found.'
K2-ConDocNode-9,Error: XPST0003: Unable to parse XPath: document{<a/>, <b/>, <c/>}. SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], [-], or end of input but "{" found.
K2-ConDocNode-10,Error: XPST0003: Unable to parse XPath: document{<a/>, <b/>, <c/>}. SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], [-], or end of input but "{" found.
K2-ConDocNode-11,Error: XPST0003: Unable to parse XPath: <a>{data(document{<a/>, <b/>, <c/>})}</a>. SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
K2-ConDocNode-12,Error: XPST0003: Unable to parse XPath: <a>{string(document{<a/>, <b/>, <c/>})}</a>. SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
K2-ConDocNode-13,Error: XPST0003: Unable to parse XPath: <a>{string(document{<a/>, <b/>, <c/>})}</a>. SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
K2-ConDocNode-14,Error: XPST0003: Unable to parse XPath: (string(document{"abc"}))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
K2-ConDocNode-15,Error: XPST0003: Unable to parse XPath: data(document {"content"}) instance of xs:untypedAtomic. SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
K2-ConDocNode-16,Error: XPST0003: Unable to parse XPath: document {"content"} is document{"content"}. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
K2-ConDocNode-17,Error: XPST0003: Unable to parse XPath: (string(document{"string", <e>more<a>even more</a><b attr="thisIsIgnored"/><![CDATA[ButNotThis]]><?target butThisIs?> content</e>}))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
K2-ConDocNode-18,Error: XPST0003: Unable to parse XPath: (string(document{ text {"data"}, processing-instruction name {"data"}, processing-instruction name {"data"}, text {"data"}, processing-instruction name {"data"}, processing-instruction name1 {"data"}, comment {"content"}, comment {"content"}, text {"data"}, processing-instruction name2 {"data"}, comment {"content"}, text {"data"} }))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
K2-ConDocNode-19,Error: XPST0003: Unable to parse XPath: (count(document{document{document{document{()}}}}/child::node())) = (0). SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
K2-ConDocNode-20,Error: XPST0003: Unable to parse XPath: (1, document{document{document{document{()}}}}/child::node(), 1)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
K2-ConDocNode-21,Error: XPST0003: Unable to parse XPath: document{document{document{document{<e/>}}}}/child::node(). SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], [-], or end of input but "{" found.
K2-ConDocNode-22,Error: XPST0003: Unable to parse XPath: document{document{document{document{<e/>, document{()}, <e>{document{()}}</e>}}}}//child::node(). SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], [-], or end of input but "{" found.
K2-ConDocNode-23,Error: XPST0003: Unable to parse XPath: (string(document{ text {"data"}, text {"data"}, text {"data"}, text {"data"} }))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
K2-ConDocNode-24,Error: XPST0003: Unable to parse XPath: (count(document{ text {"data"}, text {"data"}, <e/>, text {"data"}, text {"data"} }/child::node())) = (3). SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
K2-ConDocNode-25,Error: XPST0003: Unable to parse XPath: (count(document{ text {"data"}, text {"data"}, text {"data"}, text {"data"} }/child::node())) = (1). SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
K2-ConDocNode-26,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: <doo> { document { attribute name {"content"} } } </doo>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.'
K2-ConDocNode-27,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: <doo> { document { <e/>, attribute name {"content"} } } </doo>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.'
K2-ConDocNode-28,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: <doo> { document { <e> <b/> <b/> <b/> <c> <d/> </c> </e>, attribute name {"content"} } } </doo>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.'
K2-ConDocNode-29,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: <doo> { document { <e> { <?target data?>, attribute name {"content"} } </e> } } </doo>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.'
K2-ConDocNode-30,Error: XPST0003: Unable to parse XPath: (count(<a>{document {text{'a'}}}b</a>/node())) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.
K2-ConDocNode-31,Error: XPST0003: Unable to parse XPath: (string(document {1, document {2, document {document {()}, 3, document {4}}, 5}, 6}))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
K2-ConDocNode-32,Error: XPST0003: Unable to parse XPath: (document {1, document {2, document {document {()}, 3, document {4}}, 5}, 6})!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
Constr-compcomment-enclexpr-1,Error: XPST0003: Unable to parse XPath: comment {1,'string',3.14,xs:float('1.2345e-2'),xs:dateTime('2002-04-02T12:00:00-01:00')}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
Constr-compcomment-enclexpr-2,Error: XPST0003: Unable to parse XPath: comment {<elem>123</elem>, (<elem attr='456'/>)/@attr, (<elem>789</elem>)/text()}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
Constr-compcomment-enclexpr-3,Error: XPST0003: Unable to parse XPath: comment {1,'',2}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
Constr-compcomment-enclexpr-4,Error: XPST0003: Unable to parse XPath: comment {1,<a/>,2}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
Constr-compcomment-enclexpr-5,Error: XPST0003: Unable to parse XPath: comment {/root}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
Constr-compcomment-doc-1,Error: XPST0003: Unable to parse XPath: comment {., .}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
Constr-compcomment-parent-1,Error: XPST0003: Unable to parse XPath: (count((comment {'comment'})/..)) = (0). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
Constr-compcomment-string-1,Error: XPST0003: Unable to parse XPath: (fn:string(comment {'a', element a {}, 'b'}))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
Constr-compcomment-data-1,Error: XPST0003: Unable to parse XPath: (fn:data(comment {'a', element a {}, 'b'}))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
Constr-compcomment-nested-1,Error: XPST0003: Unable to parse XPath: comment {comment {'one', comment {'two'}}, 'three', comment {'four'}}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
Constr-compcomment-nested-2,Error: XPST0003: Unable to parse XPath: <elem>{comment {'one'}}<a>{comment {'two'}}</a>{comment {'three'}}</elem>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.
Constr-compcomment-nested-3,Error: XPST0003: Unable to parse XPath: document {comment {'one'}, <a/>, comment {'two'}, <b/>, comment {'three'}}. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
Constr-compcomment-dash-1,AssertionError: expected [Function] to throw error including 'XQDY0072' but got 'XPST0003: Unable to parse XPath: comment {\'-\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-compcomment-dash-2,AssertionError: expected [Function] to throw error including 'XQDY0072' but got 'XPST0003: Unable to parse XPath: comment {\'comment-\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-compcomment-dash-3,AssertionError: expected [Function] to throw error including 'XQDY0072' but got 'XPST0003: Unable to parse XPath: comment {\'comment&#x2D;\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-compcomment-dash-4,AssertionError: expected [Function] to throw error including 'XQDY0072' but got 'XPST0003: Unable to parse XPath: comment {//*:test-case[@name="Constr-compcomment-dash-4"]/*:description}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-compcomment-doubledash-1,AssertionError: expected [Function] to throw error including 'XQDY0072' but got 'XPST0003: Unable to parse XPath: comment {\'--\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-compcomment-doubledash-2,AssertionError: expected [Function] to throw error including 'XQDY0072' but got 'XPST0003: Unable to parse XPath: comment {\'com--ment\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-compcomment-doubledash-3,AssertionError: expected [Function] to throw error including 'XQDY0072' but got 'XPST0003: Unable to parse XPath: comment {\'com&#x2D;&#x2D;ment\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-compcomment-doubledash-4,AssertionError: expected [Function] to throw error including 'XQDY0072' but got 'XPST0003: Unable to parse XPath: comment {//*:test-case[@name="Constr-compcomment-doubledash-4"]/*:description}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-compcomment-doubledash-5,Error: XPST0003: Unable to parse XPath: comment {'com','-','-','ment'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
K2-ComputeConComment-3,Error: XPST0003: Unable to parse XPath: comment {()}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
K2-ComputeConComment-4a,Error: XPST0003: Unable to parse XPath: let $result := (comment{}) return count($result) = 1. SyntaxError: Expected "!", "!=", "#", "(", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
K2-ComputeConComment-5,Error: XPST0003: Unable to parse XPath: data(comment {"content"}) instance of xs:string. SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
cbcl-constr-compcomment-001,AssertionError: expected [Function] to throw error including 'XQDY0072' but got 'XPST0003: Unable to parse XPath: <element> { comment { \'-\', \'-\' } } </element>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.'
cbcl-constr-compcomment-002,AssertionError: expected [Function] to throw error including 'XQDY0072' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:tag($arg) as element() { element { \'tag\' } { $arg } }; \n      \t<element> { comment { \'comment\', local:tag(\'--\') } } </element>\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
Constr-compelem-name-1,Error: XPST0003: Unable to parse XPath: element elem {'text'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.
Constr-compelem-name-2,Error: XPST0003: Unable to parse XPath: declare namespace foo="http://www.example.com/foo"; element foo:elem {'text'}. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
Constr-compelem-name-3,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPST0003: Unable to parse XPath: element foo:elem {\'text\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
Constr-compelem-compname-1,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: element {()} {\'text\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-compelem-compname-2,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: element {\'one\', \'two\'} {\'text\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-compelem-compname-3,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: element {xs:untypedAtomic(\'one\'), xs:untypedAtomic(\'two\')} {\'text\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-compelem-compname-4,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: element {//a} {\'text\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-compelem-compname-5,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: element {1,2} {\'text\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-compelem-compname-6,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: element {123} {\'text\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-compelem-compname-7,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: element {xs:dateTime("1999-05-31T13:20:00")} {\'text\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-compelem-compname-8,Error: XPST0003: Unable to parse XPath: element {//*:NCName[1]} {'text'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
Constr-compelem-compname-9,Error: XPST0003: Unable to parse XPath: element {xs:QName('aQname')} {'text'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
Constr-compelem-compname-10,Error: XPST0003: Unable to parse XPath: element {'elem'} {'text'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
Constr-compelem-compname-11,Error: XPST0003: Unable to parse XPath: element {'elem', ()} {'text'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
Constr-compelem-compname-12,Error: XPST0003: Unable to parse XPath: element {(), 'elem'} {'text'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
Constr-compelem-compname-13,Error: XPST0003: Unable to parse XPath: <elem xmlns:foo="http://www.example.com/foo">{element {'foo:elem'} {'text'}}</elem>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.
Constr-compelem-compname-14,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: element {\'foo:elem\'} {}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-compelem-compname-15,Error: XPST0003: Unable to parse XPath: element {xs:untypedAtomic('elem')} {'text'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
Constr-compelem-compname-16,Error: XPST0003: Unable to parse XPath: <elem xmlns:foo="http://www.example.com/foo">{element {xs:untypedAtomic('foo:elem')} {'text'}}</elem>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.
Constr-compelem-compname-17,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: element {xs:untypedAtomic(\'foo:elem\')} {\'text\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-compelem-compname-18,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: element {\'el em\'} {\'text\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-compelem-compname-19,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: element {xs:untypedAtomic(\'el em\')} {\'text\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-compelem-adjtext-1,Error: XPST0003: Unable to parse XPath: (count((element elem {1, 'string', 1,2e3})/text())) = (1). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found.
Constr-compelem-adjtext-2,Error: XPST0003: Unable to parse XPath: (count((element elem {1, //text(), 'string'})/text())) = (1). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found.
Constr-compelem-adjtext-3,Error: XPST0003: Unable to parse XPath: (count((element elem {1, 2, <a/>, 3, 4, <b/>, 5, 6})/text())) = (3). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found.
Constr-compelem-nested-1,Error: XPST0003: Unable to parse XPath: element elem {1, element a {2, element b {element c {}, element d {3}}, 4}}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.
Constr-compelem-nested-2,Error: XPST0003: Unable to parse XPath: element elem {}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.
Constr-compelem-enclexpr-1,Error: XPST0003: Unable to parse XPath: element elem {}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.
Constr-compelem-enclexpr-2,Error: XPST0003: Unable to parse XPath: element elem {1,'a',3.5,4e2}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.
Constr-compelem-enclexpr-3,Error: XPST0003: Unable to parse XPath: element elem {1,//a,2,3,//comment(),4,5,//processing-instruction(),6,7,//text(),8}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.
Constr-compelem-enclexpr-4,Error: XPST0003: Unable to parse XPath: element elem {1, '', 2}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.
Constr-compelem-nodeid-1,Error: XPST0003: Unable to parse XPath: for $x in <a/>, $y in element elem {$x} return exactly-one($y/a) is $x. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "e" found.
Constr-compelem-nodeid-2,Error: XPST0003: Unable to parse XPath: for $x in <a b="b"/>, $y in element elem {$x/@b} return $y/@b is $x/@b. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "e" found.
Constr-compelem-nodeid-3,Error: XPST0003: Unable to parse XPath: for $x in <!--comment-->, $y in element elem {$x} return exactly-one($y/comment()) is $x. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "e" found.
Constr-compelem-nodeid-4,Error: XPST0003: Unable to parse XPath: for $x in <?pi content?>, $y in element elem {$x} return exactly-one($y/processing-instruction()) is $x. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "e" found.
Constr-compelem-nodeid-5,Error: XPST0003: Unable to parse XPath: for $x in <a>text</a>, $y in element elem {$x/text()} return exactly-one($y/text()) is exactly-one($x/text()). SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "e" found.
Constr-compelem-constrmod-3,AssertionError: expected [Function] to throw error including 'FORG0001' but got 'XPST0003: Unable to parse XPath: declare construction strip; (element elem {xs:decimal((//decimal[1]))}) cast as xs:integer. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.'
Constr-compelem-constrmod-4,AssertionError: Expected executing the XPath "declare construction preserve; (element elem {xs:decimal((//decimal[1]))}) cast as xs:integer" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare construction preserve; (element elem {xs:decimal((//decimal[1]))}) cast as xs:integer) = (12678967). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "c" found., AssertionError: expected [Function] to throw error including 'FORG0001' but got 'XPST0003: Unable to parse XPath: declare construction preserve; (element elem {xs:decimal((//decimal[1]))}) cast as xs:integer. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.'.
Constr-compelem-constrmod-7,AssertionError: expected [Function] to throw error including 'FORG0001' but got 'XPST0003: Unable to parse XPath: declare construction strip; (element elem {//*:decimal/@*:attr})/@*:attr cast as xs:integer. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.'
Constr-compelem-constrmod-8,AssertionError: Expected executing the XPath "declare construction preserve; (element elem {xs:decimal(//*:decimal[1]/@*:attr)}) cast as xs:integer" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare construction preserve; (element elem {xs:decimal(//*:decimal[1]/@*:attr)}) cast as xs:integer) = (12678967). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "c" found., AssertionError: expected [Function] to throw error including 'FORG0001' but got 'XPST0003: Unable to parse XPath: declare construction preserve; (element elem {xs:decimal(//*:decimal[1]/@*:attr)}) cast as xs:integer. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.', AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare construction preserve; (element elem {xs:decimal(//*:decimal[1]/@*:attr)}) cast as xs:integer. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.'.
Constr-compelem-baseuri-1,Error: XPST0003: Unable to parse XPath: (fn:base-uri(element elem {attribute xml:base {"http://www.example.com"}}))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found.
Constr-compelem-baseuri-2,Error: XPST0003: Unable to parse XPath: (fn:base-uri(exactly-one((<elem xml:base="http://www.example.com">{element a {}}</elem>)/a)))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "a" found.
Constr-compelem-baseuri-3,Error: XPST0003: Unable to parse XPath: (declare base-uri "http://www.example.com"; fn:base-uri(element elem {}))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "b" found.
Constr-compelem-doc-1,Error: XPST0003: Unable to parse XPath: element elem {., .}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.
Constr-compelem-parent-1,Error: XPST0003: Unable to parse XPath: (count((element elem {})/..)) = (0). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found.
Constr-compelem-string-1,Error: XPST0003: Unable to parse XPath: (fn:string(element elem {'a', element a {}, 'b'}))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found.
Constr-compelem-data-1,Error: XPST0003: Unable to parse XPath: (fn:data(element elem {'a', element a {}, 'b'}))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found.
Constr-compelem-attr-1,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: element elem {1, //west/@mark}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.'
Constr-compelem-attr-2,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: element elem {element a {}, //west/@mark}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.'
Constr-compelem-attr-3,Error: XPST0003: Unable to parse XPath: element elem {//west/@mark, //west/@west-attr-1}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.
Constr-compelem-attr-4,AssertionError: expected [Function] to throw error including 'XQDY0025' but got 'XPST0003: Unable to parse XPath: element elem {//west/@mark, //center/@mark}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.'
K2-ComputeConElem-4,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: element {"aPrefix:localName"} {"content"}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
K2-ComputeConElem-5,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: element {xs:untypedAtomic("aPrefix::localName")} {"content"}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
K2-ComputeConElem-6,Error: XPST0003: Unable to parse XPath: data(element foo {"dsa"}) instance of xs:untypedAtomic. SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-ComputeConElem-7,Error: XPST0003: Unable to parse XPath: (data(element foo {"dsa"}))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-ComputeConElem-8,Error: XPST0003: Unable to parse XPath: element e {"content"} instance of element(*, xs:anyType). SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.
K2-ComputeConElem-9,AssertionError: Expected executing the XPath "element e {"content"} instance of element(*, xs:untyped)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: element e {"content"} instance of element(*, xs:untyped). SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found., Error: XPST0003: Unable to parse XPath: element e {"content"} instance of element(*, xs:untyped). SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found..
K2-ComputeConElem-10,Error: XPST0003: Unable to parse XPath: declare construction strip; element e {"content"} instance of element(*, xs:untyped). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
K2-ComputeConElem-11,Error: XPST0003: Unable to parse XPath: element e {"content"} instance of element(a, xs:anyType). SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.
K2-ComputeConElem-12,Error: XPST0003: Unable to parse XPath: declare construction strip; element e {"content"} instance of element(b, xs:untyped). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
K2-ComputeConElem-13,Error: XPST0003: Unable to parse XPath: element e {element b{()}}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.
K2-ComputeConElem-14,Error: XPST0003: Unable to parse XPath:          declare function local:addNamespace($argElement as element(), $argPrefix as xs:string, $namespaceURI as xs:string) as element() {              element { QName($namespaceURI, concat($argPrefix, ":x")) }{$argElement}/*          };          local:addNamespace(<a><b/></a>, "prefix", "http://example.com/")       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
K2-ComputeConElem-15,Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://example.com/NS";          element {exactly-one((//*)[3])} {}. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
comp-elem-bad-name-1,AssertionError: Expected executing the XPath "element {"xmlns:error"} {}" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQDY0096' but got 'XPST0003: Unable to parse XPath: element {"xmlns:error"} {}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.', AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: element {"xmlns:error"} {}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'.
nscons-001,Error: XPST0003: Unable to parse XPath:          declare variable $s := "http://saxon.sf.net/";          declare variable $xsl := "http://www.w3.org/1999/XSL/Transform";          <e>{ namespace saxon {$s}, attribute a {23}, namespace xsl {$xsl} }</e>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
nscons-002,Error: XPST0003: Unable to parse XPath:          declare variable $s := "saxon";          declare variable $xsl := "xsl";          <e>{ namespace {$s} {"http://saxon.sf.net/"},               attribute a {23},               namespace {$xsl} {"http://www.w3.org/1999/XSL/Transform"} }</e>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
nscons-003,Error: XPST0003: Unable to parse XPath:          declare variable $s := "saxon";          declare variable $xsl := "xsl";          <out> <t:e xmlns:t="http://www.example.com/">{              namespace {""} {"http://saxon.sf.net/"},              attribute a {23},              namespace {$xsl} {"http://www.w3.org/1999/XSL/Transform"}, <f/> }</t:e> </out>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
nscons-004,Error: XPST0003: Unable to parse XPath:          declare variable $s := "saxon";          declare variable $xml := "http://www.w3.org/XML/1998/namespace";          <out> <t:e xmlns:t="http://www.example.com/" xml:space="preserve">{              namespace xml {"http://www.w3.org/XML/1998/namespace"},              attribute a {23}, <f/> }</t:e> </out>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
nscons-005,Error: XPST0003: Unable to parse XPath:          declare variable $s := "http://saxon.sf.net/";          declare variable $xsl := "http://www.w3.org/1999/XSL/Transform";          element {QName("http://saxon.sf.net/", "saxon:extension")} { namespace saxon {$s}, attribute a {23}, namespace xsl {$xsl}, element f {42} }       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
nscons-006,Error: XPST0003: Unable to parse XPath:          declare variable $s := "http://saxon.sf.net/";          declare variable $xsl := "http://www.w3.org/1999/XSL/Transform";          element {QName("http://saxon.sf.net/", "saxon:extension")}                  { namespace saxon {$s}, attribute a {23}, namespace xsl {$xsl}, namespace saxon {$s}, element f {42} }       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
nscons-007,AssertionError: expected [Function] to throw error including 'XQDY0101' but got 'XPST0003: Unable to parse XPath: \n        declare variable $s := "http://saxon.sf.net/"; \n        declare variable $xsl := "http://www.w3.org/1999/XSL/Transform"; \n        declare variable $xmlns := "xmlns"; \n        <e> { namespace saxon {$s}, attribute a {23}, namespace xsl {$xsl}, namespace xmlns {$s}, element f {42} }</e>\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
nscons-008,AssertionError: expected [Function] to throw error including 'XQDY0101' but got 'XPST0003: Unable to parse XPath: \n        declare variable $s := "http://saxon.sf.net/"; \n        declare variable $xsl := "http://www.w3.org/1999/XSL/Transform"; \n        declare variable $xmlns := "xml"; \n        <e> { namespace saxon {$s}, attribute a {23}, namespace xsl {$xsl}, namespace {$xmlns} {$s}, element f {42} }</e>\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
nscons-009,AssertionError: expected [Function] to throw error including 'XQDY0102' but got 'XPST0003: Unable to parse XPath: \n        declare variable $p1 := "http://example.com/one"; \n        declare variable $p2 := "http://example.com/two"; \n        <e> { namespace p {$p1}, namespace p {$p2}, element f {42} }</e>\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
nscons-010,Error: XPST0003: Unable to parse XPath:          declare variable $p1 := "http://example.com/one";          declare variable $p2 := "http://example.com/two";          declare variable $r := <e> { namespace p {$p1}, attribute {QName($p2, "p:att")} {93.7}, element f {42} }</e>;          <out> { exists($r/@*:att[prefix-from-QName(node-name(.))!='p']), exists(in-scope-prefixes($r)[.='p']) }</out>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
nscons-011,Error: XPST0003: Unable to parse XPath:          declare variable $p1 := "http://example.com/one";          declare variable $p2 := "http://example.com/two";          declare variable $r := element {QName($p2, 'p:e')} { namespace p {$p1}, element f {42} };          <out> { exists($r[prefix-from-QName(node-name(.))!='p']), exists(in-scope-prefixes($r)[.='p']) }</out>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
nscons-012,Error: XPST0003: Unable to parse XPath:          declare variable $p1 := "http://example.com/one";          declare variable $p2 := "http://example.com/two";          declare function local:f($ns as namespace-node()) as element() {              <namespace name="{name($ns)}" local-name="{local-name($ns)}"                  namespace-uri="{namespace-uri($ns)}" string-value="{string($ns)}" typed-value="{data($ns)}"                  is-untyped="{data($ns) instance of xs:untypedAtomic}" parent-exists="{exists($ns/..)}"                  is-namespace="{$ns instance of namespace-node()}"                  is-node="{$ns instance of node()}" is-item="{$ns instance of item()}"                  same-as-self="{$ns is $ns}"/>          };          <out>{              local:f(namespace p {"http://example.com/one"}),              local:f(namespace {""} {"http://example.com/two"}) }</out>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
nscons-013,Error: XPST0003: Unable to parse XPath:          let $pre := <prefix>z</prefix>,             $uri := "http://www.zorba-xquery.com/"         return           <e>{ namespace { $pre } { $uri } }</e>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.
nscons-014,Error: XPST0003: Unable to parse XPath:          let $pre := "z",             $uri := "http://www.zorba-xquery.com/"         return           <e>{ namespace { $pre } { $uri } }</e>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.
nscons-015,Error: XPST0003: Unable to parse XPath:          declare namespace z="http://www.zorba-xquery.com/";         <z:e>{ namespace { <a/>/* } { "http://www.w3.org/" } }</z:e>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
nscons-016,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: \n        let $pre := <prefix>z:z</prefix>,\n            $uri := "http://www.zorba-xquery.com/"\n        return\n          <e>{ namespace { $pre } { $uri } }</e>\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.'
nscons-017,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: \n        let $pre := "z z",\n            $uri := "http://www.zorba-xquery.com/"\n        return\n          <e>{ namespace { $pre } { $uri } }</e>\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.'
nscons-018,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        let $pre := 1,\n            $uri := "http://www.zorba-xquery.com/"\n        return\n          <e>{ namespace { $pre } { $uri } }</e>\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.'
nscons-019,AssertionError: expected [Function] to throw error including 'XQDY0101' but got 'XPST0003: Unable to parse XPath: \n        let $uri := "http://www.w3.org/XML/1998/namespace"\n        return\n          <e>{ namespace x { $uri } }</e>\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "x" found.'
nscons-020,AssertionError: expected [Function] to throw error including 'XQDY0101' but got 'XPST0003: Unable to parse XPath: \n        let $uri := "http://www.w3.org/2000/xmlns/"\n        return\n          <e>{ namespace x { $uri } }</e>\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "x" found.'
nscons-021,AssertionError: expected [Function] to throw error including 'XQDY0101' but got 'XPST0003: Unable to parse XPath: \n        <e>{ namespace x { "" } }</e>\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "x" found.'
nscons-022,Error: XPST0003: Unable to parse XPath:          let $elem := <e>{ namespace z { "http://www.zorba-xquery.com/" } }</e>         return           element { resolve-QName("z:f", $elem) } {}       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "z" found.
nscons-023,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPST0003: Unable to parse XPath: \n        <z:e>{ namespace z { "http://www.zorba-xquery.com/" } }</z:e>\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "z" found.'
nscons-024,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPST0003: Unable to parse XPath: \n        <e>{ namespace z { "http://www.zorba-xquery.com/" }, element z:e {} }</e>\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "z" found.'
nscons-025,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPST0003: Unable to parse XPath: \n        element e { attribute z:a {},  namespace z { "http://www.zorba-xquery.com/" } }\n      . SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.'
nscons-026,AssertionError: expected [Function] to throw error including 'FONS0004' but got 'XPST0003: Unable to parse XPath: \n        <e>{ namespace z { "http://www.zorba-xquery.com/" }, element { xs:QName("z:e") } { } }</e>\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "z" found.'
nscons-027,Error: XPST0003: Unable to parse XPath:          import module namespace mod1="http://www.w3.org/TestModules/cnc-module";         let $elem := <e>{ mod1:one() }</e>         return           element { resolve-QName("z:f", $elem) } {}       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", "||", or end of input but "m" found.
nscons-028,Error: XPST0003: Unable to parse XPath: (         import module namespace mod1="http://www.w3.org/TestModules/cnc-module";         let $ns := mod1:one()         return ($ns is $ns, $ns is mod1:one())       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", or "||" but "m" found.
nscons-029,AssertionError: expected [Function] to throw error including 'SENR0001' but got 'XPST0003: Unable to parse XPath: \n        serialize( namespace z { "http://www.zorba-xquery.com/" } )\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "z" found.'
nscons-030,Error: XPST0003: Unable to parse XPath: let $result := (         serialize( element e { namespace z { "http://www.zorba-xquery.com/" } } )       ) return contains($result,'xmlns:z'). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found.
nscons-031,Error: XPST0003: Unable to parse XPath:          declare copy-namespaces preserve, inherit;         let $nested :=              element outer {                namespace out { "http://out.zorba-xquery.com/" },               element inner {                 namespace in { "http://in.zorba-xquery.com/" }               }              },             $elem := element e { namespace new { "http://new.zorba-xquery.com/" }, $nested }         return           $elem/outer/inner       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
nscons-032,Error: XPST0003: Unable to parse XPath:          declare copy-namespaces preserve, no-inherit;         let $nested :=              element outer {                namespace out { "http://out.zorba-xquery.com/" },               element inner { namespace in { "http://in.zorba-xquery.com/" } }              },             $elem := element e { namespace new { "http://new.zorba-xquery.com/" }, $nested }         return           $elem/outer/inner       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
nscons-033,Error: XPST0003: Unable to parse XPath:          declare copy-namespaces no-preserve, inherit;         let $nested :=              element outer {                namespace out { "http://out.zorba-xquery.com/" },               element inner { namespace in { "http://in.zorba-xquery.com/" } }              },             $elem := element e { namespace new { "http://new.zorba-xquery.com/" }, $nested }         return           $elem/outer/inner       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
nscons-034,Error: XPST0003: Unable to parse XPath:          declare copy-namespaces no-preserve, no-inherit;         let $nested :=              element outer {                namespace out { "http://out.zorba-xquery.com/" },               element inner { namespace in { "http://in.zorba-xquery.com/" } }              },             $elem := element e { namespace new { "http://new.zorba-xquery.com/" }, $nested }         return           $elem/outer/inner       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
nscons-035,Error: XPST0003: Unable to parse XPath:          import module namespace mod1="http://www.w3.org/TestModules/cnc-module";         declare copy-namespaces preserve, inherit;         let $nested := mod1:nested(),             $elem := element e { namespace new { "http://new.zorba-xquery.com/" }, $nested }         return           $elem/outer/inner       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", "||", or end of input but "m" found.
nscons-036,Error: XPST0003: Unable to parse XPath:          import module namespace mod1="http://www.w3.org/TestModules/cnc-module";         declare copy-namespaces preserve, no-inherit;         let $nested := mod1:nested(),             $elem := element e { namespace new { "http://new.zorba-xquery.com/" }, $nested }         return           $elem/outer/inner       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", "||", or end of input but "m" found.
nscons-037,Error: XPST0003: Unable to parse XPath:          import module namespace mod1="http://www.w3.org/TestModules/cnc-module";         declare copy-namespaces no-preserve, inherit;         let $nested := mod1:nested(),             $elem := element e { namespace new { "http://new.zorba-xquery.com/" }, $nested }         return           $elem/outer/inner       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", "||", or end of input but "m" found.
nscons-038,Error: XPST0003: Unable to parse XPath:          import module namespace mod1="http://www.w3.org/TestModules/cnc-module";         declare copy-namespaces no-preserve, no-inherit;         let $nested := mod1:nested(),             $elem := element e { namespace new { "http://new.zorba-xquery.com/" }, $nested }         return           $elem/outer/inner       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", "||", or end of input but "m" found.
nscons-039,Error: XPST0003: Unable to parse XPath:          declare copy-namespaces preserve, inherit;                  declare function local:rec-add($level as xs:integer) as element() {           if ($level > 0) then             element { concat("e", $level) } {                namespace { concat("pre", $level) } { concat("uri", $level) },               local:rec-add($level - 1)             }           else             element e0 {}                };          local:rec-add(2)/e1/e0       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
nscons-042,AssertionError: expected [Function] to throw error including 'XQDY0102' but got 'XPST0003: Unable to parse XPath: \n        element e { namespace {\'\'} {\'http://example.com/uri\'} }\n      . SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.'
nscons-043,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        let $pre := xs:anyURI(\'ns\'),\n            $uri := "http://www.zorba-xquery.com/"\n        return\n          <e>{ namespace { $pre } { $uri } }</e>\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.'
nscons-044,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        let $pre := xs:duration(\'P1D\'),\n            $uri := "http://www.zorba-xquery.com/"\n        return\n          <e>{ namespace { $pre } { $uri } }</e>\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.'
Constr-comppi-name-1,Error: XPST0003: Unable to parse XPath: processing-instruction pi {'text'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "p" found.
Constr-comppi-compname-1,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: processing-instruction {()} {\'text\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-comppi-compname-2,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: processing-instruction {\'one\', \'two\'} {\'text\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-comppi-compname-3,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: processing-instruction {xs:untypedAtomic(\'one\'), xs:untypedAtomic(\'two\')} {\'text\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-comppi-compname-4,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: processing-instruction {//a} {\'text\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-comppi-compname-5,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: processing-instruction {1,2} {\'text\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-comppi-compname-6,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: processing-instruction {123} {\'text\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-comppi-compname-7,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: processing-instruction {xs:dateTime("1999-05-31T13:20:00")} {\'text\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-comppi-compname-8,Error: XPST0003: Unable to parse XPath: processing-instruction {//*:NCName[1]} {'text'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
Constr-comppi-compname-9,AssertionError: Expected executing the XPath "processing-instruction {//*:QName} {'text'}" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQDY0041' but got 'XPST0003: Unable to parse XPath: processing-instruction {//*:QName} {\'text\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.', AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: processing-instruction {//*:QName} {\'text\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'.
Constr-comppi-compname-10,Error: XPST0003: Unable to parse XPath: processing-instruction {'pi'} {'text'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
Constr-comppi-compname-11,Error: XPST0003: Unable to parse XPath: processing-instruction {'pi', ()} {'text'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
Constr-comppi-compname-12,Error: XPST0003: Unable to parse XPath: processing-instruction {(), 'pi'} {'text'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
Constr-comppi-compname-13,AssertionError: expected [Function] to throw error including 'XQDY0041' but got 'XPST0003: Unable to parse XPath: <elem xmlns:foo="http://www.example.com/foo">{processing-instruction {\'foo:attr\'} {}}</elem>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.'
Constr-comppi-compname-15,Error: XPST0003: Unable to parse XPath: processing-instruction {xs:untypedAtomic('pi')} {'text'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
Constr-comppi-compname-16,AssertionError: expected [Function] to throw error including 'XQDY0041' but got 'XPST0003: Unable to parse XPath: <elem xmlns:foo="http://www.example.com/foo">{processing-instruction {xs:untypedAtomic(\'foo:pi\')} {\'text\'}}</elem>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.'
Constr-comppi-compname-18,AssertionError: expected [Function] to throw error including 'XQDY0041' but got 'XPST0003: Unable to parse XPath: processing-instruction {\'p i\'} {\'text\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-comppi-compname-19,AssertionError: expected [Function] to throw error including 'XQDY0041' but got 'XPST0003: Unable to parse XPath: processing-instruction {xs:untypedAtomic(\'p i\')} {\'text\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-comppi-compname-20,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: processing-instruction {(\'pi\'[current-date() lt xs:date(\'1900-01-01\')], xs:anyURI(\'pi\'))} {\'text\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-comppi-compname-21,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: processing-instruction {(\'pi\'[current-date() lt xs:date(\'1900-01-01\')], xs:duration(\'P1D\'))} {\'text\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-comppi-compname-22,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: processing-instruction {\'pi\'[current-date() lt xs:date(\'1900-01-01\')]} {\'text\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-comppi-doc-1,Error: XPST0003: Unable to parse XPath: processing-instruction pi {., .}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "p" found.
Constr-comppi-parent-1,Error: XPST0003: Unable to parse XPath: (count((processing-instruction pi {()})/..)) = (0). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "p" found.
Constr-comppi-string-1,Error: XPST0003: Unable to parse XPath: (fn:string(processing-instruction pi {'a', element a {}, 'b'}))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "p" found.
Constr-comppi-data-1,Error: XPST0003: Unable to parse XPath: (fn:data(processing-instruction pi {'a', element a {}, 'b'}))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "p" found.
Constr-comppi-enclexpr-1,Error: XPST0003: Unable to parse XPath: processing-instruction pi {1,'string',3.14,xs:float('1.2345e-2'),xs:dateTime('2002-04-02T12:00:00-01:00')}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "p" found.
Constr-comppi-enclexpr-2,Error: XPST0003: Unable to parse XPath: processing-instruction pi {<elem>123</elem>, (<elem attr='456'/>)/@attr, (<elem>789</elem>)/text()}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "p" found.
Constr-comppi-enclexpr-3,Error: XPST0003: Unable to parse XPath: processing-instruction pi {1,'',2}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "p" found.
Constr-comppi-enclexpr-4,Error: XPST0003: Unable to parse XPath: processing-instruction pi {1,<a/>,2}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "p" found.
Constr-comppi-enclexpr-5,Error: XPST0003: Unable to parse XPath: processing-instruction pi {/root}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "p" found.
Constr-comppi-namexml-1,AssertionError: expected [Function] to throw error including 'XQDY0064' but got 'XPST0003: Unable to parse XPath: processing-instruction xml {\'pi\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "x" found.'
Constr-comppi-namexml-2,AssertionError: expected [Function] to throw error including 'XQDY0064' but got 'XPST0003: Unable to parse XPath: processing-instruction XmL {\'pi\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "X" found.'
Constr-comppi-namexml-3,AssertionError: expected [Function] to throw error including 'XQDY0064' but got 'XPST0003: Unable to parse XPath: processing-instruction {\'xml\'} {\'pi\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-comppi-namexml-4,AssertionError: expected [Function] to throw error including 'XQDY0064' but got 'XPST0003: Unable to parse XPath: processing-instruction {\'XmL\'} {\'pi\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
Constr-comppi-invalid-1,AssertionError: expected [Function] to throw error including 'XQDY0026' but got 'XPST0003: Unable to parse XPath: processing-instruction pi {\'?>\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "p" found.'
Constr-comppi-invalid-2,AssertionError: expected [Function] to throw error including 'XQDY0026' but got 'XPST0003: Unable to parse XPath: processing-instruction pi {\'?>text\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "p" found.'
Constr-comppi-invalid-3,AssertionError: expected [Function] to throw error including 'XQDY0026' but got 'XPST0003: Unable to parse XPath: processing-instruction pi {\'text?>text\'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "p" found.'
Constr-comppi-space-1,Error: XPST0003: Unable to parse XPath: processing-instruction pi {' text'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "p" found.
Constr-comppi-space-2,Error: XPST0003: Unable to parse XPath: processing-instruction pi {'&#x20;&#x0A;&#x0D;&#x09;text'}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "p" found.
Constr-comppi-space-3,Error: XPST0003: Unable to parse XPath: (string-to-codepoints(processing-instruction pi {' text'}))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "p" found.
Constr-comppi-space-4,Error: XPST0003: Unable to parse XPath: (string-to-codepoints(processing-instruction pi {'&#x20;&#x0A;&#x0D;&#x09;text'}))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "p" found.
Constr-comppi-empty-1,Error: XPST0003: Unable to parse XPath: processing-instruction pi {()}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "p" found.
Constr-comppi-empty-2,Error: XPST0003: Unable to parse XPath: processing-instruction pi {''}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "p" found.
K2-ComputeConPI-2,AssertionError: expected [Function] to throw error including 'XQDY0064' but got 'XPST0003: Unable to parse XPath: processing-instruction {"xml"} {"content"}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
K2-ComputeConPI-3,AssertionError: expected [Function] to throw error including 'XQDY0064' but got 'XPST0003: Unable to parse XPath: processing-instruction {" xmL "} {"content"}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
K2-ComputeConPI-4,Error: XPST0003: Unable to parse XPath: (local-name(processing-instruction {" name "} {"content"}))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
K2-ComputeConPI-5,Error: XPST0003: Unable to parse XPath: (local-name(processing-instruction {" XmLnaMe "} {"content"}))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
K2-ComputeConPI-6,AssertionError: expected [Function] to throw error including 'XQDY0041' but got 'XPST0003: Unable to parse XPath: processing-instruction {"1.das "} {"content"}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
K2-ComputeConPI-7,AssertionError: expected [Function] to throw error including 'XQDY0026' but got 'XPST0003: Unable to parse XPath: processing-instruction {"thename"} {"asdas?>"}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
K2-ComputeConPI-8,Error: XPST0003: Unable to parse XPath: (string(processing-instruction {"thename"} {"asdas? >"}))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
K2-ComputeConPI-9,Error: XPST0003: Unable to parse XPath: (string(processing-instruction {"thename"} {"content {1+ } {"}))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
K2-ComputeConPI-10,Error: XPST0003: Unable to parse XPath: processing-instruction name {" "} eq "". SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
K2-ComputeConPI-11,Error: XPST0003: Unable to parse XPath: data(processing-instruction name {"content"}) instance of xs:string. SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
cbcl-constr-comppi-001,AssertionError: expected [Function] to throw error including 'XQDY0026' but got 'XPST0003: Unable to parse XPath: \n      \t<element> { processing-instruction { \'pi\' } { <element>?&gt;</element> } } </element>\n      . SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.'
cbcl-constr-comppi-002,AssertionError: expected [Function] to throw error including 'XQDY0026' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:tag($arg) as element() { element { \'tag\' } { $arg } }; \n      \t<element> { processing-instruction { \'pi\' } { "content", local:tag(\'?&gt;\') } } </element>\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
Constr-text-enclexpr-1,Error: XPST0003: Unable to parse XPath: (text {1,'string',3.14,xs:float('1.2345e-2'),xs:dateTime('2002-04-02T12:00:00-01:00')})!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
Constr-text-enclexpr-2,Error: XPST0003: Unable to parse XPath: (text {<elem>123</elem>, (<elem attr='456'/>)/@attr, (<elem>789</elem>)/text()})!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
Constr-text-enclexpr-3,Error: XPST0003: Unable to parse XPath: (text {1,'',2})!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
Constr-text-enclexpr-4,Error: XPST0003: Unable to parse XPath: (text {1,<a/>,2})!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
Constr-text-enclexpr-5,Error: XPST0003: Unable to parse XPath: (text {/root})!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
Constr-text-doc-1,Error: XPST0003: Unable to parse XPath: (text {., .})!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
Constr-text-parent-1,Error: XPST0003: Unable to parse XPath: (count((text {'text'})/..)) = (0). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
Constr-text-string-1,Error: XPST0003: Unable to parse XPath: (fn:string(text {'a', element a {}, 'b'}))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
Constr-text-data-1,Error: XPST0003: Unable to parse XPath: (fn:data(text {'a', element a {}, 'b'}))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
Constr-text-count-1,Error: XPST0003: Unable to parse XPath: (count(text {''})) = (1). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
Constr-text-count-2,Error: XPST0003: Unable to parse XPath: (count(text {()})) = (0). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
Constr-text-count-3,Error: XPST0003: Unable to parse XPath: (count(element elem {text {''}}/text())) = (0). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found.
Constr-text-count-4,AssertionError: Expected executing the XPath "count(document {text {''}}/text())" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (count(document {text {''}}/text())) = (0). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: count(document {text {\'\'}}/text()). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.'.
Constr-text-count-5,Error: XPST0003: Unable to parse XPath: (count(<a>{text {''}}<b/>{text {''}}<b/>{text {''}}</a>/text())) = (0). SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.
Constr-text-count-6,AssertionError: Expected executing the XPath "count(document {text {''},<b/>,text {''},<b/>,text {''}}/text())" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (count(document {text {''},<b/>,text {''},<b/>,text {''}}/text())) = (0). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: count(document {text {\'\'},<b/>,text {\'\'},<b/>,text {\'\'}}/text()). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.'.
Constr-text-adjtext-1,Error: XPST0003: Unable to parse XPath: (count(<elem>{text {'te'}, text {'xt'}}</elem>/text())) = (1). SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.
Constr-text-adjtext-2,Error: XPST0003: Unable to parse XPath: (count(document {text {'te'}, text {'xt'}}/text())) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
Constr-text-nested-1,Error: XPST0003: Unable to parse XPath: (text {text {'one', text {'two'}}, 'three', text {'four'}})!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
Constr-text-nested-2,Error: XPST0003: Unable to parse XPath: <elem>{text {'one'}}<a>{text {'two'}}</a>{text {'three'}}</elem>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.
Constr-text-nested-3,Error: XPST0003: Unable to parse XPath: document {text {'one'}, <a/>, text {'two'}, <b/>, text {'three'}}. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
K2-ConText-3,Error: XPST0003: Unable to parse XPath: string(text {""}) eq "". SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
K2-ConText-4,Error: XPST0003: Unable to parse XPath: <a>{text{()}}</a>. SyntaxError: Expected "!", "!=", "#", "(", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", "}", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
K2-ConText-5a,Error: XPST0003: Unable to parse XPath: (text{}) => empty(). SyntaxError: Expected "!", "!=", "#", "(", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
K2-ConText-6,Error: XPST0003: Unable to parse XPath: data(text {"content"}) instance of xs:untypedAtomic. SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
K2-ConText-14,Error: XPST0003: Unable to parse XPath: <elem>{1}{text{""}}{2}</elem>. SyntaxError: Expected "!", "!=", "#", "(", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", "}", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
K2-ConText-15,Error: XPST0003: Unable to parse XPath: (string(<elem>{1}{text{""}}{2}</elem>))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "#", "(", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", "}", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
constprolog-1,AssertionError: expected [Function] to throw error including 'XQST0067' but got 'XPST0003: Unable to parse XPath: \n        declare construction strip; \n        declare construction strip; \n        "abc". SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.'
constprolog-2,Error: XPST0003: Unable to parse XPath:          declare construction strip;          let $anElement := <anElement>some content</anElement>          return $anElement instance of element(*,xs:untyped)       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
constprolog-3,Error: XPST0003: Unable to parse XPath:          declare construction strip;          let $anElement := element anElement {"someContent"}          return $anElement instance of element(*,xs:untyped)       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
constprolog-4,Error: XPST0003: Unable to parse XPath:          declare construction preserve;          let $anElement := <anElement>some content</anElement>          return $anElement instance of element(*,xs:anyType). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
constprolog-5,Error: XPST0003: Unable to parse XPath:          declare construction strip;          let $anElement := element anElement {"someContent"}          return $anElement instance of element(*,xs:anyType). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
constprolog-6,Error: XPST0003: Unable to parse XPath:          declare construction strip;          let $anElement := <anElement>some content</anElement>          return $anElement instance of element(*,xs:anyType)       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
constprolog-7,Error: XPST0003: Unable to parse XPath:          declare construction strip;          let $anElement := element anElement {"someContent"}          return $anElement instance of element(*,xs:anyType)       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
constprolog-8,Error: XPST0003: Unable to parse XPath:          declare construction strip;          let $anElement := <someElement>some content</someElement>          return fn:not($anElement instance of element(*,xs:untyped)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
constprolog-9,Error: XPST0003: Unable to parse XPath:          declare construction strip;          let $anElement := element someElement{"some content"}          return fn:not($anElement instance of element(*,xs:untyped)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
constprolog-10,Error: XPST0003: Unable to parse XPath:          declare construction preserve;          let $anElement := <someElement>some content</someElement>          return fn:not($anElement instance of element(*,xs:anyType))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
constprolog-11,Error: XPST0003: Unable to parse XPath:          declare construction preserve;          let $anElement := element someElement{"some content"}          return fn:not($anElement instance of element(*,xs:anyType))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
constprolog-12,Error: XPST0003: Unable to parse XPath:          declare construction strip;          fn:not(<someElement>some content</someElement> instance of element(*,xs:untyped))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
constprolog-13,Error: XPST0003: Unable to parse XPath:          declare construction preserve;          fn:not(element someElement{"some content"} instance of element(*,xs:anyType))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
constprolog-14,Error: XPST0003: Unable to parse XPath:          declare construction strip;          let $var := <anElement>Some content</anElement>          return ($var instance of element(*,xs:untyped)) and fn:true()       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
constprolog-15,Error: XPST0003: Unable to parse XPath:          declare construction strip;          let $anElement := element someElement{"some content"}          return ($anElement instance of element(*,xs:untyped)) and fn:true()       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
constprolog-16,Error: XPST0003: Unable to parse XPath:          declare construction preserve;          let $anElement := <someElement>content</someElement>          return ($anElement instance of element(*,xs:anyType)) and fn:true()       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
constprolog-17,Error: XPST0003: Unable to parse XPath:          declare construction preserve;          let $anElement := element someElement{"some content"}          return ($anElement instance of element(*,xs:anyType)) and fn:true()       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
constprolog-18,Error: XPST0003: Unable to parse XPath:          declare construction strip;          let $var := <anElement>Some content</anElement>          return ($var instance of element(*,xs:untyped)) or fn:false()       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
constprolog-19,Error: XPST0003: Unable to parse XPath:          declare construction strip;          let $anElement := element someElement{"some content"}          return ($anElement instance of element(*,xs:untyped)) or fn:false()       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
constprolog-20,Error: XPST0003: Unable to parse XPath:          declare construction preserve;          let $anElement := <someElement>content</someElement>          return ($anElement instance of element(*,xs:anyType)) or fn:false()       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
constprolog-21,Error: XPST0003: Unable to parse XPath:          declare construction preserve;          let $anElement := element someElement{"some content"}          return ($anElement instance of element(*,xs:anyType)) or fn:false()       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
K-ConstructionProlog-1,Error: XPST0003: Unable to parse XPath: (::)declare(::)construction(::)preserve(::);(::)1(::)eq(::)1(::). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
K-ConstructionProlog-3,Error: XPST0003: Unable to parse XPath: declare(::)construction(::)strip;(::)1(::)eq(::)1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
K-ConstructionProlog-4,AssertionError: expected [Function] to throw error including 'XQST0067' but got 'XPST0003: Unable to parse XPath: declare(::)construction(::)strip; declare(::)construction(::)strip;1(::)eq(::)1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.'
contextDecl-014,Error: XPST0003: Unable to parse XPath: (         declare variable $x := . + 5;         declare context item := 17;         $x       ) = (22). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
contextDecl-015,AssertionError: Expected executing the XPath "         declare variable $y := /works/employee;         declare context item := $y[9];         declare variable $x external := if (./*) then fn:position() else 0;         ($x, $y)       " to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: \n        declare variable $y := /works/employee;\n        declare context item := $y[9];\n        declare variable $x external := if (./*) then fn:position() else 0;\n        ($x, $y)\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.', AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'XPST0003: Unable to parse XPath: \n        declare variable $y := /works/employee;\n        declare context item := $y[9];\n        declare variable $x external := if (./*) then fn:position() else 0;\n        ($x, $y)\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
contextDecl-016,Error: XPST0003: Unable to parse XPath: (         declare variable $y := (<a>1</a>,<a>2</a>,<a>3</a>,<a>4</a>,<a>5</a>,<a>6</a>,<a>7</a>,<a>8</a>,<a>9</a>,<a>10</a>);         declare context item := $y[3];         declare variable $x external := fn:position();         $x       ) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
contextDecl-017,Error: XPST0003: Unable to parse XPath: (         declare variable $y := <root><a>1</a>,<a>2</a>,<a>3</a>,<a>4</a>,<a>5</a>,<a>6</a>,<a>7</a>,<a>8</a>,<a>9</a>,<a>10</a></root>;         declare context item := $y;         declare variable $x external := fn:last();         $x       ) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
contextDecl-018,AssertionError: Expected executing the XPath " declare context item := last() + 1; ." to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: ( declare context item := last() + 1; .) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "c" found., AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath:  declare context item := last() + 1; .. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.', AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'XPST0003: Unable to parse XPath:  declare context item := last() + 1; .. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.'.
contextDecl-019,AssertionError: Expected executing the XPath " declare context item := position() + 1; ." to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: ( declare context item := position() + 1; .) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "c" found., AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath:  declare context item := position() + 1; .. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.', AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'XPST0003: Unable to parse XPath:  declare context item := position() + 1; .. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.'.
contextDecl-020,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath:  declare context item as xs:integer external; . . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.'
contextDecl-021,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath:  declare context item as xs:integer := \'London\'; . . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.'
contextDecl-022,AssertionError: Expected executing the XPath " declare context item as xs:string := 2; . " to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath:  declare context item as xs:string := 2; . . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.'.
contextDecl-028,Error: XPST0003: Unable to parse XPath: ( declare context item := 3; . + 4 ) = (7). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "c" found.
contextDecl-029,Error: XPST0003: Unable to parse XPath: (         declare context item := <a>bananas</a>;         string-length()       ) = (7). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "c" found.
contextDecl-030,Error: XPST0003: Unable to parse XPath: (         declare context item := <a id="qwerty">bananas</a>;         string-length(@id)       ) = (6). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "c" found.
contextDecl-031,Error: XPST0003: Unable to parse XPath:          declare context item := contains(?, "e");         .("raspberry")       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
contextDecl-032,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare context item := (1 to 17)[20]; .. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.'
contextDecl-033,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare context item := (1 to 17)[position() gt 5]; .. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.'
contextDecl-034,Error: XPST0003: Unable to parse XPath: (declare context item as xs:integer := (1 to 17)[position() = 5]; .) = (5). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "c" found.
contextDecl-035,Error: XPST0003: Unable to parse XPath: (         declare context item as xs:integer := (1 to 17)[position() = 5];         .       ) = (5). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "c" found.
contextDecl-036,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare context item as xs:integer := current-date();\n        .\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.'
contextDecl-037,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare context item as xs:integer := <a>23</a>;\n        .\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.'
contextDecl-038,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare context item as xs:anyURI := "http://www.w3.org/";\n        .\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.'
contextDecl-039,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare context item as xs:double := 1.234;\n        .\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.'
contextDecl-040,Error: XPST0003: Unable to parse XPath:          declare context item external;         . instance of document-node()       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
contextDecl-041,Error: XPST0003: Unable to parse XPath: (         declare context item as document-node() external;         name(/*)       ) = ("works"). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "c" found.
contextDecl-042,Error: XPST0003: Unable to parse XPath:          declare context item external := 17;         . = 17       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
contextDecl-043,Error: XPST0003: Unable to parse XPath:          declare context item as xs:integer external := 17;         . = 17       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
contextDecl-044,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath:  declare context item as xs:double external := 17; . = 17. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.'
contextDecl-045,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath:  declare context item as xs:double external; . = 17. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.'
contextDecl-046,AssertionError: expected [Function] to throw error including 'XQST0099' but got 'XPST0003: Unable to parse XPath: \n        declare context item as xs:double external;\n        declare context item as xs:integer := 15;\n        . = 17\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.'
contextDecl-047,Error: XPST0003: Unable to parse XPath:        	import module namespace m="http://www.w3.org/TestModules/libmodule2";          . gt xs:date('1900-01-01')       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", "||", or end of input but "m" found.
contextDecl-048,AssertionError: expected [Function] to throw error including 'XQST0113' but got 'XPST0003: Unable to parse XPath: \n      \timport module namespace m="http://www.w3.org/TestModules/libmodule1"; \n      \t. = 17\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", "||", or end of input but "m" found.'
contextDecl-049,Error: XPST0003: Unable to parse XPath:          import module namespace m="http://www.w3.org/TestModules/libmodule2";          declare context item as xs:date := current-date();         . gt xs:date('1900-01-01')       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", "||", or end of input but "m" found.
contextDecl-050,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n      \timport module namespace m="http://www.w3.org/TestModules/libmodule2"; \n        declare context item as xs:integer := 23;\n        . eq 23\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", "||", or end of input but "m" found.'
contextDecl-051,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        import module namespace m="http://www.w3.org/TestModules/libmodule2"; \n        declare context item as node() external;\n        . instance of element()\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", "||", or end of input but "m" found.'
contextDecl-052,AssertionError: expected [Function] to throw error including 'XQST0113' but got 'XPST0003: Unable to parse XPath: \n        import module namespace m="http://www.w3.org/TestModules/libmodule3"; \n        . eq 23\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", "||", or end of input but "m" found.'
contextDecl-053,AssertionError: Expected executing the XPath "         declare variable $p := "base-uri";         declare variable $f := function-lookup(xs:QName("fn:"||$p), 0);         declare context item := $f();         .       " to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: \n        declare variable $p := "base-uri";\n        declare variable $f := function-lookup(xs:QName("fn:"||$p), 0);\n        declare context item := $f();\n        .\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.', AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'XPST0003: Unable to parse XPath: \n        declare variable $p := "base-uri";\n        declare variable $f := function-lookup(xs:QName("fn:"||$p), 0);\n        declare context item := $f();\n        .\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
contextDecl-054,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n      \timport module namespace m="http://www.w3.org/TestModules/libmodule2"; \n        xs:date(.) gt xs:date(\'1900-01-01\')\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", "||", or end of input but "m" found.'
contextDecl-055,Error: XPST0003: Unable to parse XPath: (       declare variable $f := function-lookup(xs:QName("fn:"||$p), 0);       declare context item := <e/>;       declare variable $p := "local-name";       $f()     ) = ("e"). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
contextDecl-056,Error: XPST0003: Unable to parse XPath:        import module namespace m="http://www.w3.org/TestModules/libmodule4";       declare context item as xs:numeric external;       $m:v eq 4     . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", "||", or end of input but "m" found.
contextDecl-057,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n      import module namespace m="http://www.w3.org/TestModules/libmodule4";\n      declare context item as xs:date external;\n      $m:v eq 4\n    . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", "||", or end of input but "m" found.'
contextDecl-058,Error: XPST0003: Unable to parse XPath:        import module namespace m="http://www.w3.org/TestModules/libmodule5";       declare context item as array(xs:string) external;       $m:v eq 'green'     . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", "||", or end of input but "m" found.
externalcontextitem-1,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: \n        declare namespace eg = "http://example.org"; \n        declare function eg:noContextFunction() { name }; \n        eg:noContextFunction(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
internalcontextitem-1,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: declare namespace eg = "http://example.org"; declare function eg:noContextFunction() { . }; eg:noContextFunction(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
decimal-format-01,Error: XPST0003: Unable to parse XPath: (         declare default decimal-format zero-digit="0" grouping-separator="," decimal-separator=".";       	format-number(2392.14*36.58,'000,000.000000'))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found.
decimal-format-02,Error: XPST0003: Unable to parse XPath: (         declare default decimal-format digit="#" grouping-separator="," decimal-separator=".";       	format-number(12792.14*96.58,'##,###,000.000###'))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found.
decimal-format-03,Error: XPST0003: Unable to parse XPath: (         declare default decimal-format minus-sign="-" grouping-separator="," decimal-separator=".";       	format-number(2792.14*(-36.58),'000,000.000###'))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found.
decimal-format-04,Error: XPST0003: Unable to parse XPath: (         declare default decimal-format minus-sign="-" pattern-separator=";" grouping-separator="," decimal-separator=".";       	format-number(2392.14*(-36.58),'000,000.000###;###,###.000###'))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found.
decimal-format-05,Error: XPST0003: Unable to parse XPath: (         declare decimal-format local:df minus-sign="-" percent="%" decimal-separator=".";       	format-number(0.4857,'###.###%', 'local:df'))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found.
decimal-format-06,Error: XPST0003: Unable to parse XPath: (         declare decimal-format local:df minus-sign="-" per-mille="" decimal-separator=".";       	format-number(0.4857,'###.###'))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found.
decimal-format-09,Error: XPST0003: Unable to parse XPath: (          declare default decimal-format decimal-separator="|" grouping-separator=".";           format-number(931.4857,'000.000|###'))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found.
decimal-format-11,Error: XPST0003: Unable to parse XPath: (         declare default decimal-format digit="!" pattern-separator="\";         format-number(26931.4,'+!!!,!!!.!!!\-!!,!!!.!!!'))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found.
decimal-format-12,Error: XPST0003: Unable to parse XPath: (         declare default decimal-format digit="!" pattern-separator="\";         format-number(-26931.4,'+!!,!!!.!!!\-!!!,!!!.!!!'))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found.
decimal-format-13,Error: XPST0003: Unable to parse XPath: (         declare default decimal-format digit="!" pattern-separator="\";         format-number(-26931.4,'!!!,!!!.!!!'))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found.
decimal-format-14,Error: XPST0003: Unable to parse XPath: (         declare decimal-format local:df2 infinity="off-the-scale";         format-number(1 div 0e0,'###############################', 'local:df2'))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found.
decimal-format-15,Error: XPST0003: Unable to parse XPath: (         declare decimal-format local:df2 NaN="non-numeric";         format-number(number('none'), '#############', 'local:df2'))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found.
decimal-format-16,Error: XPST0003: Unable to parse XPath: (         declare default decimal-format  per-mille="m";         format-number(0.4857,'###.###m'))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found.
decimal-format-17,Error: XPST0003: Unable to parse XPath: (         declare default decimal-format  minus-sign="_";         format-number(-26931.4,'+###,###.###;-###,###.###'))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found.
decimal-format-18,Error: XPST0003: Unable to parse XPath: (         declare default decimal-format minus-sign="_";         format-number(-26931.4,'###,###.###'))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found.
decimal-format-19,Error: XPST0003: Unable to parse XPath: (         declare decimal-format myminus minus-sign="_";          concat(format-number(-26931.4,'###,###.###','myminus'), '/',         format-number(-42857.1,'###,###.###')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found.
decimal-format-20,Error: XPST0003: Unable to parse XPath: (         declare namespace foo="http://foo.ns";         declare decimal-format foo:decimal1  decimal-separator="!" grouping-separator="*";         declare decimal-format decimal1  decimal-separator="*" grouping-separator="!";         format-number(1234.567,'#*###*###!###','foo:decimal1'))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
decimal-format-21,Error: XPST0003: Unable to parse XPath: (         import module namespace m="http://www.w3.org/TestModules/dfd-module-001";         declare decimal-format df001 grouping-separator="!";         format-number(123456.789,'#!###!###.###','df001')||'-'||m:do()       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", or "||" but "m" found.
decimal-format-31,AssertionError: expected [Function] to throw error including 'XQST0111' but got 'XPST0003: Unable to parse XPath: \n        declare default decimal-format decimal-separator = "^";\n        declare default decimal-format decimal-separator = "^";\n      \ttrue()\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'
decimal-format-32,AssertionError: expected [Function] to throw error including 'XQST0111' but got 'XPST0003: Unable to parse XPath: \n        declare decimal-format fmt1 decimal-separator = "^";\n        declare decimal-format fmt1 decimal-separator = "^";\n      \ttrue()\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'
decimal-format-33,Error: XPST0003: Unable to parse XPath: (         declare decimal-format fmt1 decimal-separator = "^";         declare decimal-format fmt2 decimal-separator = "~";       	concat (format-number(123.45, '9999^999', 'fmt1'), " and ",                 format-number(123.45, '9999~999', 'fmt2'))       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found.
decimal-format-34,AssertionError: expected [Function] to throw error including 'XQST0114' but got 'XPST0003: Unable to parse XPath: \n        declare default decimal-format decimal-separator = "^" grouping-separator = "\\" decimal-separator = "^";\n      \ttrue()\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'
decimal-format-35,AssertionError: expected [Function] to throw error including 'XQST0097' but got 'XPST0003: Unable to parse XPath: \n        declare default decimal-format zero-digit = "A";\n      \ttrue()\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'
decimal-format-36,AssertionError: expected [Function] to throw error including 'XQST0098' but got 'XPST0003: Unable to parse XPath: \n        declare default decimal-format decimal-separator = "~" grouping-separator = "~";\n      \ttrue()\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'
decimal-format-37,AssertionError: expected [Function] to throw error including 'XQST0098' but got 'XPST0003: Unable to parse XPath: \n        declare default decimal-format decimal-separator = ",";\n      \ttrue()\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'
decimal-format-39,Error: XPST0003: Unable to parse XPath: (         declare default decimal-format minus-sign="-";         format-number(-26931.4,'###,###.###'))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found.
decimal-format-40,Error: XPST0003: Unable to parse XPath: (       declare default decimal-format NaN = "0";       format-number(xs:double('NaN'),'###,###.###'))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found.
decimal-format-901err,AssertionError: expected [Function] to throw error including 'XQST0098' but got 'XPST0003: Unable to parse XPath: \n        declare default decimal-format decimal-separator="!" grouping-separator="!";\n        format-number(931.4857,\'###!###!###\'). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'
decimal-format-902err,AssertionError: expected [Function] to throw error including 'FODF1310' but got 'XPST0003: Unable to parse XPath: \n        declare default decimal-format digit=\'$\';\n        format-number(931.4857,\'000.$$0\'). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'
decimal-format-903err,AssertionError: expected [Function] to throw error including 'XQST0111' but got 'XPST0003: Unable to parse XPath: \n        declare default decimal-format digit=\'$\';\n        declare default decimal-format minus-sign=\'_\';\n        format-number(931.4857,\'000.$$0\'). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'
decimal-format-904err,AssertionError: expected [Function] to throw error including 'XQST0111' but got 'XPST0003: Unable to parse XPath: \n        declare namespace a="http://a.com/";\n        declare namespace b="http://a.com/";\n        declare decimal-format a:one digit=\'$\';\n        declare decimal-format two digit=\'$\';\n        declare decimal-format three digit=\'$\';\n        declare decimal-format four digit=\'$\';\n        declare decimal-format five digit=\'$\';\n        declare decimal-format b:one minus-sign="_";\n        declare default decimal-format minus-sign=\'_\';\n        format-number(931.4857,\'000.$$0\'). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
decimal-format-905err,AssertionError: expected [Function] to throw error including 'FODF1310' but got 'XPST0003: Unable to parse XPath: \n        declare decimal-format q decimal-separator="." grouping-separator=",";\n        format-number(931.4857,\'fred.ginger\', \'q\'). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'
decimal-format-906err,AssertionError: expected [Function] to throw error including 'FODF1280' but got 'XPST0017: Function format-number with arity of 3 not registered. No similar functions found.'
decimal-format-907err,AssertionError: expected [Function] to throw error including 'XQST0114' but got 'XPST0003: Unable to parse XPath: \n        declare namespace a="http://a.com/";\n        declare namespace b="http://a.com/";\n        declare decimal-format a:one digit=\'$\' zero-digit="0" minus-sign="_" digit="#";\n        format-number(931.4857,\'000.$$0\', \'a:one\'). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
decimal-format-908err,AssertionError: expected [Function] to throw error including 'XQST0097' but got 'XPST0003: Unable to parse XPath: \n        declare default decimal-format digit="one";\n        format-number(931.4857,\'000.$$0\'). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'
decimal-format-909err,AssertionError: expected [Function] to throw error including 'XQST0097' but got 'XPST0003: Unable to parse XPath: \n        declare default decimal-format zero-digit="1";\n        format-number(931.4857,\'000.$$0\'). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'
decimal-format-910err,AssertionError: expected [Function] to throw error including 'XQST0097' but got 'XPST0003: Unable to parse XPath: \n        declare default decimal-format zero-digit="a";\n        format-number(931.4857,\'aaa.$$a\'). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'
decimal-format-911err,AssertionError: expected [Function] to throw error including 'XQST0097' but got 'XPST0003: Unable to parse XPath: \n        declare default decimal-format minus-sign="--";\n        format-number(931.4857,\'000.$$0\'). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'
decimal-format-912err,AssertionError: expected [Function] to throw error including 'XQST0098' but got 'XPST0003: Unable to parse XPath: \n      declare default decimal-format decimal-separator = "6";\n      true()\n    . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'
Constr-attr-nspre-1,Error: XPST0003: Unable to parse XPath: declare namespace foo="http://www.w3.org/XQueryTest/Construct"; <elem foo:attr="value"/>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
Constr-attr-enclexpr-9,AssertionError: expected [Function] to throw an error
Constr-attr-id-2,AssertionError: Expected executing the XPath "<elem xml:id=" a{'b c d',' '}"/>" to resolve to one of the expected results, but got AssertionError: Expected XPath <elem xml:id=" a{'b c d',' '}"/> to resolve to the given XML. Expected <elem xml:id=" ab c d  "/> to equal <elem xml:id="ab c d"/>, AssertionError: expected [Function] to throw an error.
K2-DirectConElemAttr-34,Error: XPST0003: Unable to parse XPath: (string(<elem attr="{comment {" content "}}"/>/@attr))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.
K2-DirectConElemAttr-35,Error: XPST0003: Unable to parse XPath: (local-name(<elem attr="{comment {" content "}}"/>/@attr))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.
K2-DirectConElemAttr-36,Error: XPST0003: Unable to parse XPath: (string(<elem attr="{processing-instruction name {" content "}}"/>/@attr))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.
K2-DirectConElemAttr-37,Error: XPST0003: Unable to parse XPath: (local-name(<elem attr="{processing-instruction name {" content "}}"/>/@attr))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.
K2-DirectConElemAttr-38,Error: XPST0003: Unable to parse XPath: (local-name(<elem attr="{attribute name {" content "}}"/>/@attr))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.
K2-DirectConElemAttr-39,Error: XPST0003: Unable to parse XPath: (string(<elem attr="{attribute name {" content "}}"/>/@attr))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.
K2-DirectConElemAttr-44,Error: XPST0003: Unable to parse XPath: declare base-uri "http://example.com/level/file.ext"; <e xml:base="../">{ static-base-uri()}</e>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
K2-DirectConElemAttr-45,Error: XPST0003: Unable to parse XPath: declare base-uri "http://example.com/level/file.ext"; <e xml:base="http://example.com/2/2">{ static-base-uri()}</e>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
K2-DirectConElemAttr-47,Error: XPST0017: Function data with arity of 1 not registered. No similar functions found.
K2-DirectConElemAttr-70,Error: XPST0003: Unable to parse XPath: declare default element namespace "http://typedecl"; namespace-uri-from-QName(node-name(exactly-one(<e attr="foo"/>/@attr))) eq "". SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
K2-DirectConElemAttr-71,Error: XPST0003: Unable to parse XPath: declare default element namespace "http://typedecl"; namespace-uri-from-QName(node-name(exactly-one(<e>{attribute attr {()} }/</e>/@attr))) eq "". SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
K2-DirectConElemAttr-72,Error: XPST0003: Unable to parse XPath: namespace-uri-from-QName(node-name(exactly-one(<e xmlns="http://example.com/">{attribute attr {()} }/</e>/@attr))) eq "". SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "a" found.
K2-DirectConElemAttr-73,Error: XPST0003: Unable to parse XPath: declare default element namespace "http://example.com/"; namespace-uri-from-QName(node-name(attribute e {()})) eq "". SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
K2-DirectConElemAttr-75,Error: XPST0003: Unable to parse XPath: (:*******************************************************:) (: Test: K2-DirectConElemAttr-75                         :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:21+01:00                       :) (: Purpose: Mix several ways for creating text for various kinds of nodes. This test is useful if an implementation is performing normalization of such constructors. :) (:*******************************************************:) <e attribute="{ "abc", "def", "ghi", 1, 2, 3, xs:untypedAtomic("abc"), text {"a text node"}, text {"a text node"}, xs:untypedAtomic("def"), xs:untypedAtomic("ghi"), xs:hexBinary("FF"), xs:untypedAtomic("abc"), xs:string("def"), xs:untypedAtomic("ghi") } textNode {"xs:string"} textNode {"xs:string"} textNode {"xs:string"} text {"a text node"}, {"xs:string"} {"xs:string"}textnode"> {   attribute name { text {"a text node"}, text {"a text node"}, "abc", "def", text {"a text node"}, "ghi", 1, 2, text {"a text node"}, 3, xs:untypedAtomic("abc"), xs:untypedAtomic("def"), text {"a text node"}, xs:untypedAtomic("ghi"), xs:hexBinary("FF"), xs:untypedAtomic("abc"), xs:string("def"), xs:untypedAtomic("ghi"), "xs:string", xs:untypedAtomic("ghi"), "xs:string", "xs:string", "xs:string", xs:untypedAtomic("ghi") } } { text {"a text node"}, text {"a text node"}, "abc", "def", text {"a text node"}, "ghi", 1, 2, text {"a text node"}, 3, xs:untypedAtomic("abc"), text {"a text node"}, xs:untypedAtomic("def"), xs:untypedAtomic("ghi"), xs:hexBinary("FF"), xs:untypedAtomic("abc"), xs:string("def"), xs:untypedAtomic("ghi") } textNode {"xs:string"} textNode {"xs:string"} textNode {"xs:string"} {"xs:string"} {"xs:string"} text {"a text node"}, text {"a text node"}, text {"a text node"}, text {"a text node"},  { comment { "abc", "def", "ghi", 1, 2, 3, xs:untypedAtomic("abc"), xs:untypedAtomic("def"), xs:untypedAtomic("ghi"), xs:hexBinary("FF"), xs:untypedAtomic("abc"), xs:string("def"), xs:untypedAtomic("ghi"), "xs:string", "xs:string", xs:untypedAtomic("ghi"), "xs:string", text {"a text node"}, text {"a text node"}, "xs:string", xs:untypedAtomic("ghi"), "xs:string" }, processing-instruction target { "abc", "def", "ghi", 1, 2, 3, xs:untypedAtomic("abc"), xs:untypedAtomic("def"), xs:untypedAtomic("ghi"), text {"a text node"}, text {"a text node"}, xs:hexBinary("FF"), xs:untypedAtomic("abc"), xs:string("def"), xs:untypedAtomic("ghi"), "xs:string", "xs:string", xs:untypedAtomic("ghi"), "xs:string", "xs:string", xs:untypedAtomic("ghi"), text {"a text node"}, "xs:string" }, text { text {"a text node"}, text {"a text node"}, text {"a text node"}, text {"a text node"}, "abc", "def", "ghi", 1, 2, text {"a text node"}, 3, xs:untypedAtomic("abc"), text {"a text node"}, xs:untypedAtomic("def"), xs:untypedAtomic("ghi"), xs:hexBinary("FF"), xs:untypedAtomic("abc"), xs:string("def"), xs:untypedAtomic("ghi"), "xs:string", "xs:string", xs:untypedAtomic("ghi"), "xs:string", "xs:string", xs:untypedAtomic("ghi"), "xs:string", text {"a text node"} }  } </e>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.
K2-DirectConElemAttr-76,Error: XPST0003: Unable to parse XPath:          declare function local:t() { text{""}, text{"["}, text{"3"}, text{"]"}, text{""} };          declare variable $var := (text{""}, text{"["}, text{"3"}, text{"]"}, text{""});          <out fromFunction="{local:t()}" fromVariable="{$var}"/>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
Constr-pi-content-2,Error: XPST0017: Function fn:data with arity of 1 not registered. Did you mean "xs:date (xs:anyAtomicType?)"?
Constr-pi-content-4,Error: XPST0017: Function fn:data with arity of 1 not registered. Did you mean "xs:date (xs:anyAtomicType?)"?
Constr-pi-content-6,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
Constr-pi-content-7,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
Constr-comment-2,Error: XPST0017: Function fn:data with arity of 1 not registered. Did you mean "xs:date (xs:anyAtomicType?)"?
Constr-comment-4,Error: XPST0017: Function fn:data with arity of 1 not registered. Did you mean "xs:date (xs:anyAtomicType?)"?
K2-DirectConOther-22,AssertionError: expected [Function] to throw an error
K2-DirectConOther-29,Error: XPST0003: Unable to parse XPath: (local-name(<?xmlSUFFIX content?>))!string() => string-join(" "). SyntaxError: Expected [A-Z_a-z----------] or [-] but "?" found.
K2-DirectConOther-44,Error: XPST0017: Function data with arity of 1 not registered. No similar functions found.
K2-DirectConOther-45,Error: XPST0017: Function data with arity of 1 not registered. No similar functions found.
K2-DirectConOther-48,AssertionError: Expected executing the XPath "string(exactly-one(<e xml:id=" ab c d "/>/@*))" to resolve to one of the expected results, but got AssertionError: string(exactly-one(<e xml:id=" ab c d "/>/@*)): expected ' ab c d ' to equal 'ab c d', AssertionError: expected [Function] to throw an error.
K2-DirectConOther-66,Error: XPST0003: Unable to parse XPath: declare namespace a="http://example.com/NotThis"; declare namespace g="http://example.com/NotThis2"; <a xmlns:a="http://example.com/NotThis" xmlns:b="http://example.com"> <b xmlns:a="http://example.com/" xmlns:c="http://example.com/c"> <c xmlns:d="http://example.com/d"/> { for $i in in-scope-prefixes(<e/>) order by $i return $i, "|", for $i in in-scope-prefixes(element e {()}) order by $i return $i } <d xmlns:e="http://example.com/d"/> </b> </a>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
K2-DirectConOther-67,Error: XPST0003: Unable to parse XPath: <e xmlns="http://example.com/3">{namespace-uri-from-QName(node-name(<e/>)), namespace-uri-from-QName(node-name(element e2 {()}))}</e>. SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found.
K2-DirectConOther-70,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
K2-DirectConElem-34,Error: XPST0003: Unable to parse XPath: <foo > {attribute name {"content"}} <doo/> </foo>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.
K2-DirectConElem-35,AssertionError: expected [Function] to throw an error
K2-DirectConElem-36,AssertionError: expected [Function] to throw an error
K2-DirectConElem-37,AssertionError: expected [Function] to throw an error
K2-DirectConElem-39,AssertionError: expected [Function] to throw an error
K2-DirectConElem-40,AssertionError: expected [Function] to throw an error
K2-DirectConElem-41,AssertionError: expected [Function] to throw an error
K2-DirectConElem-42,Error: XPST0003: Unable to parse XPath: <e> { document{()}/(/) } </e>. SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", "}", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
K2-DirectConElem-43,Error: XPST0003: Unable to parse XPath: <e> { document{()} } </e>. SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", "}", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
K2-DirectConElem-45,Error: XPST0017: Function data with arity of 1 not registered. No similar functions found.
K2-DirectConElem-46,Error: XPST0003: Unable to parse XPath: declare namespace p = "http://www.example.com/"; <p:e/>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
K2-DirectConElem-51,AssertionError: Expected XPath <e xml:id=" fo"/> to resolve to the given XML. Expected <e xml:id=" fo"/> to equal <e xml:id="fo"/>
K2-DirectConElem-53a,Error: XPST0003: Unable to parse XPath: (namespace {"p"} {"abc"}) instance of namespace-node(). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
cbcl-directconelem-001,Error: XPST0003: Unable to parse XPath: (  declare default element namespace "http://example.com/0";  declare namespace a = "http://example.com/1";  declare namespace b = "http://example.com/2";  declare copy-namespaces preserve,no-inherit;  declare function local:in-scope-namespace-bindings($arg) {   for $i in in-scope-prefixes($arg)    order by $i    return    concat("xmlns",          if (string-length($i) = 0)          then ""          else ":",          $i,          '="', namespace-uri-for-prefix($i, $arg), '"') };  <a:outer b:outer="attr" xmlns:c="http://example.com/3" c:outer="attr">   <inner a="a:attr" b="b:attr" /> </a:outer>/(local:in-scope-namespace-bindings(.),             '|',              local:in-scope-namespace-bindings((./*)[1]))        )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found.
cbcl-directconelem-002,Error: XPST0003: Unable to parse XPath: (  declare default element namespace "http://example.com/0";  declare namespace a = "http://example.com/1";  declare namespace b = "http://example.com/2";  declare copy-namespaces preserve,inherit;  declare function local:in-scope-namespace-bindings($arg) {   for $i in in-scope-prefixes($arg)    order by $i    return    concat("xmlns",          if (string-length($i) = 0)          then ""          else ":",          $i,          '="', namespace-uri-for-prefix($i, $arg), '"') };  <a:outer b:outer="attr" xmlns:c="http://example.com/3" c:outer="attr">   <inner a="a:attr" b="b:attr" /> </a:outer>/(local:in-scope-namespace-bindings(.),             '|',              local:in-scope-namespace-bindings((./*)[1]))        )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found.
Constr-cont-eol-1,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
Constr-cont-eol-2,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
Constr-cont-eol-3,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
Constr-cont-eol-4,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
Constr-cont-entref-1,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
Constr-cont-entref-2,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
Constr-cont-entref-3,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
Constr-cont-entref-4,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
Constr-cont-entref-5,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
Constr-cont-constrmod-1,Error: XPST0003: Unable to parse XPath: (declare construction strip; fn:count(fn:data(<elem>{//*:idrefs}</elem>/*))) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "c" found.
Constr-cont-constrmod-2,AssertionError: Expected executing the XPath "declare construction preserve; fn:count(fn:data(<elem>{//*:idrefs}</elem>/*))" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare construction preserve; fn:count(fn:data(<elem>{//*:idrefs}</elem>/*))) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "c" found., Error: XPST0003: Unable to parse XPath: (declare construction preserve; fn:count(fn:data(<elem>{//*:idrefs}</elem>/*))) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "c" found..
Constr-cont-constrmod-3,AssertionError: expected [Function] to throw error including 'FORG0001' but got 'XPST0003: Unable to parse XPath: declare construction strip; <elem>{//*:decimal}</elem>/* cast as xs:integer. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.'
Constr-cont-constrmod-4,AssertionError: Expected executing the XPath "declare construction preserve; <elem>{//*:decimal}</elem>/* cast as xs:integer" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare construction preserve; <elem>{//*:decimal}</elem>/* cast as xs:integer) = (12678967). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "c" found., AssertionError: expected [Function] to throw error including 'FORG0001' but got 'XPST0003: Unable to parse XPath: declare construction preserve; <elem>{//*:decimal}</elem>/* cast as xs:integer. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.'.
Constr-cont-constrmod-5,Error: XPST0003: Unable to parse XPath: (declare construction strip; fn:count(fn:data((<elem>{//*:idrefs/@*:attr}</elem>)/@*:attr))) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "c" found.
Constr-cont-constrmod-6,AssertionError: Expected executing the XPath "declare construction preserve; fn:count(fn:data((<elem>{//*:idrefs/@*:attr}</elem>)/@*:attr))" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare construction preserve; fn:count(fn:data((<elem>{//*:idrefs/@*:attr}</elem>)/@*:attr))) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "c" found., Error: XPST0003: Unable to parse XPath: (declare construction preserve; fn:count(fn:data((<elem>{//*:idrefs/@*:attr}</elem>)/@*:attr))) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "c" found..
Constr-cont-constrmod-7,AssertionError: expected [Function] to throw error including 'FORG0001' but got 'XPST0003: Unable to parse XPath: declare construction strip; (<elem>{//*:decimal/@*:attr}</elem>)/@*:attr cast as xs:integer. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.'
Constr-cont-constrmod-8,AssertionError: Expected executing the XPath "declare construction preserve; (<elem>{//*:decimal/@*:attr}</elem>)/@*:attr cast as xs:integer" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare construction preserve; (<elem>{//*:decimal/@*:attr}</elem>)/@*:attr cast as xs:integer) = (12678967). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "c" found., AssertionError: expected [Function] to throw error including 'FORG0001' but got 'XPST0003: Unable to parse XPath: declare construction preserve; (<elem>{//*:decimal/@*:attr}</elem>)/@*:attr cast as xs:integer. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.'.
Constr-cont-nsmode-1,Error: XPST0003: Unable to parse XPath: declare copy-namespaces preserve, inherit; <y xmlns:inherit="http://www.example.com/inherit">{(/)}</y>/x/z. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
Constr-cont-nsmode-2,Error: XPST0003: Unable to parse XPath: declare copy-namespaces no-preserve, inherit; <y xmlns:inherit="http://www.example.com/inherit">{(/)}</y>/x/z. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
Constr-cont-nsmode-3,Error: XPST0003: Unable to parse XPath: declare copy-namespaces preserve, no-inherit; <y xmlns:inherit="http://www.example.com/inherit">{(/)}</y>/x/z. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
Constr-cont-nsmode-4,Error: XPST0003: Unable to parse XPath: declare copy-namespaces no-preserve, no-inherit; <y xmlns:inherit="http://www.example.com/inherit">{(/)}</y>/x/z. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
Constr-cont-nsmode-5,AssertionError: Expected executing the XPath "declare copy-namespaces no-preserve, inherit; declare construction preserve; <new>{ //*:QName }</new>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: declare copy-namespaces no-preserve, inherit; declare construction preserve; <new>{ //*:QName }</new>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found., AssertionError: expected [Function] to throw error including 'XQTY0086' but got 'XPST0003: Unable to parse XPath: declare copy-namespaces no-preserve, inherit; declare construction preserve; <new>{ //*:QName }</new>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.'.
Constr-cont-nsmode-6,AssertionError: Expected executing the XPath "declare copy-namespaces no-preserve, no-inherit; declare construction preserve; <new>{ //*:QName }</new>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: declare copy-namespaces no-preserve, no-inherit; declare construction preserve; <new>{ //*:QName }</new>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found., AssertionError: expected [Function] to throw error including 'XQTY0086' but got 'XPST0003: Unable to parse XPath: declare copy-namespaces no-preserve, no-inherit; declare construction preserve; <new>{ //*:QName }</new>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.'.
Constr-cont-nsmode-7,AssertionError: expected [Function] to throw error including 'XQTY0086' but got 'XPST0003: Unable to parse XPath: declare namespace atomic = "http://www.w3.org/XQueryTest"; declare copy-namespaces no-preserve, inherit; declare construction preserve; <new>{ (//atomic:QName/@atomic:attr)[1] }</new>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
Constr-cont-nsmode-8,AssertionError: expected [Function] to throw error including 'XQTY0086' but got 'XPST0003: Unable to parse XPath: \n        declare namespace atomic = "http://www.w3.org/XQueryTest"; \n        declare copy-namespaces preserve, inherit; \n        declare construction preserve; \n        <new>{ (//atomic:QName/@atomic:attr)[1] }</new>\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
Constr-cont-nsmode-9,Error: XPST0003: Unable to parse XPath:          declare namespace atomic = "http://www.w3.org/XQueryTest";          declare copy-namespaces preserve, inherit;          declare construction preserve;          <new>{ //atomic:QName }</new>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
Constr-cont-nsmode-10,AssertionError: expected [Function] to throw error including 'XQTY0086' but got 'XPST0003: Unable to parse XPath: declare construction preserve; element { "new" } { //*:QName/@* }. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.'
Constr-cont-uripres-1,Error: XPST0017: Function fn:base-uri with arity of 1 not registered. No similar functions found.
Constr-cont-doc-1,HierarchyRequestError: Node cannot be inserted at the specified point in the hierarchy
Constr-cont-attr-1,AssertionError: expected [Function] to throw an error
Constr-cont-attr-2,AssertionError: expected [Function] to throw an error
Constr-cont-attr-4,AssertionError: expected [Function] to throw an error
Constr-cont-baseuri-1,Error: XPST0017: Function fn:base-uri with arity of 1 not registered. No similar functions found.
Constr-cont-baseuri-2,Error: XPST0017: Function fn:base-uri with arity of 1 not registered. No similar functions found.
Constr-cont-baseuri-3,Error: XPST0003: Unable to parse XPath: (declare base-uri "http://www.example.com"; fn:base-uri(<elem/>))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "b" found.
Constr-cont-attr-7,AssertionError: expected [Function] to throw error including 'XQDY0025' but got 'XQST0040: The attribute mark is already present on a constructed element.'
Constr-cont-attr-8,AssertionError: expected [Function] to throw error including 'XQDY0025' but got 'XQST0040: The attribute mark is already present on a constructed element.'
Constr-cont-data-1,Error: XPST0017: Function fn:data with arity of 1 not registered. Did you mean "xs:date (xs:anyAtomicType?)"?
Constr-cont-document-1,Error: XPST0003: Unable to parse XPath: (count(<wrapper> {'abc', document {'def', <anode/>, 'ghi'}, 'jkl'} </wrapper>/node())) = (3). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.
Constr-cont-document-2,Error: XPST0003: Unable to parse XPath: (count(<wrapper> abc {document {'def', <anode/>, 'ghi'}} jkl </wrapper>/node())) = (3). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.
Constr-cont-document-3,Error: XPST0003: Unable to parse XPath: let $result := (         declare variable $codepoints as xs:integer+ := (9, 10, 13, 32 to 55295, 57344 to 65532, 65536 to 1114111 );          declare variable $count as xs:integer := count($codepoints);          declare variable $lineWidth as xs:integer := 70;         <allCodepoints><r>{codepoints-to-string($codepoints)}</r></allCodepoints>          (:<allCodepoints>{              for $i in (1 to $count idiv $lineWidth)              let $startOffset := (($i - 1) * $lineWidth) + 1              return (<r s="{$codepoints[$startOffset]}" e="{$codepoints[$startOffset] + $lineWidth}"> {                  codepoints-to-string(subsequence($codepoints, $startOffset, $lineWidth)) } </r>, "&#xA;")                  } </allCodepoints>:)         ) return sum($result//r/text()/string-length()) = count((9, 10, 13, 32 to 55295, 57344 to 65532, 65536 to 1114111 )). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
Constr-cont-document-4,Error: XPST0003: Unable to parse XPath: (count( document {'abc', 'def', document {'ghi', <anode/>, 'jkl'}, 'mno' } /node() )) = (3). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
Constr-cont-document-5,Error: XPST0003: Unable to parse XPath: (count( document {'abc', 'def', document {'ghi', 'jkl'}, 'mno' } /node() )) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
K2-DirectConElemContent-5,Error: XPST0017: Function data with arity of 1 not registered. No similar functions found.
K2-DirectConElemContent-6,Error: XPST0017: Function data with arity of 1 not registered. No similar functions found.
K2-DirectConElemContent-9,Error: XPST0017: Function data with arity of 1 not registered. No similar functions found.
K2-DirectConElemContent-10,Error: XPST0017: Function data with arity of 1 not registered. No similar functions found.
K2-DirectConElemContent-14,Error: XPST0017: Function data with arity of 1 not registered. No similar functions found.
K2-DirectConElemContent-15,Error: XPST0017: Function data with arity of 1 not registered. No similar functions found.
K2-DirectConElemContent-26,AssertionError: expected [Function] to throw an error
K2-DirectConElemContent-29,Error: XPST0003: Unable to parse XPath: data(text{"content"}) instance of xs:untypedAtomic. SyntaxError: Expected "!", "!=", "#", "(", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
K2-DirectConElemContent-32,Error: XPST0017: Function data with arity of 1 not registered. No similar functions found.
K2-DirectConElemContent-33,Error: XPST0017: Function data with arity of 1 not registered. No similar functions found.
K2-DirectConElemContent-34,Error: element() with more than 1 argument is not supported.
K2-DirectConElemContent-35,Error: element() with more than 1 argument is not supported.
K2-DirectConElemContent-35a,Error: element() with more than 1 argument is not supported.
K2-DirectConElemContent-35b,Error: element() with more than 1 argument is not supported.
K2-DirectConElemContent-36,Error: XPST0003: Unable to parse XPath: declare construction strip; <e/> instance of element(*, xs:untyped). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
K2-DirectConElemContent-37,Error: element() with more than 1 argument is not supported.
K2-DirectConElemContent-38,Error: XPST0003: Unable to parse XPath: declare construction strip; <e/> instance of element(b, xs:untyped). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.
K2-DirectConElemContent-46,Error: XPST0003: Unable to parse XPath: <e>{1}{text{()}}{2}</e>. SyntaxError: Expected "!", "!=", "#", "(", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", "}", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
K2-DirectConElemContent-47,Error: XPST0003: Unable to parse XPath: <e>{1}{text{""}}{2}</e>. SyntaxError: Expected "!", "!=", "#", "(", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", "}", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
K2-DirectConElemContent-48,Error: XPST0003: Unable to parse XPath: document{       	<e xmlns="http://www.example.com/"> <a xmlns=""/> </e>,        	<e xmlns="http://www.example.com/"> <a xmlns=""/> </e>/count(in-scope-prefixes(a)),        	<e xmlns="http://www.example.com/"> <a xmlns=""> <b xmlns=""/> </a> </e>       }. SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], [-], or end of input but "{" found.
cbcl-ns-fixup-1,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
ElemContentArray-001,Error: Atomizing array(*) is not implemented.
ElemContentArray-002,Error: Atomizing array(*) is not implemented.
Constr-namespace-1,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'An attempt was made to create or change an object in a way which is incorrect with regard to namespaces'
Constr-namespace-6,AssertionError: expected [Function] to throw an error
Constr-namespace-7,AssertionError: expected [Function] to throw an error
Constr-namespace-10,Error: XPST0003: Unable to parse XPath: declare namespace foo="http://www.example.com/prolog"; <foo:elem xmlns:foo="http://www.example.com/element"/>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
Constr-namespace-12,Error: XPST0003: Unable to parse XPath: declare namespace foo="http://www.example.com/prolog"; (<elem xmlns:foo="http://www.example.com/parent"><foo:child/></elem>)//*:child. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
Constr-namespace-14,AssertionError: Expected executing the XPath "<foo:elem xmlns:foo="http://www.example.com/parent"><child xmlns:foo=""><foo:grand-child/></child></foo:elem>" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XPST0081' but got 'An attempt was made to create or change an object in a way which is incorrect with regard to namespaces', AssertionError: expected [Function] to throw error including 'XQST0085' but got 'An attempt was made to create or change an object in a way which is incorrect with regard to namespaces'.
Constr-namespace-15,AssertionError: Expected executing the XPath "declare namespace foo="http://www.example.com/prolog"; <elem xmlns:foo=""><foo:child/></elem>" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPST0003: Unable to parse XPath: declare namespace foo="http://www.example.com/prolog"; <elem xmlns:foo=""><foo:child/></elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.', AssertionError: expected [Function] to throw error including 'XQST0085' but got 'XPST0003: Unable to parse XPath: declare namespace foo="http://www.example.com/prolog"; <elem xmlns:foo=""><foo:child/></elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'.
Constr-namespace-19,Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.example.com/prolog"; <elem xmlns="http://www.example.com/element"/>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
Constr-namespace-21,Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.example.com/prolog"; (<elem xmlns="http://www.example.com/element"><child/></elem>)/*:child. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
Constr-namespace-29,AssertionError: expected [Function] to throw an error
Constr-namespace-30,Error: XPST0017: Function p:count with arity of 1 not registered. Did you mean "count (item()*)"?
K2-DirectConElemNamespace-1,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPDY0002: context is absent, it needs to be present to use axes.'
K2-DirectConElemNamespace-4,AssertionError: Expected executing the XPath "declare namespace p = "http://example.com/QuiteWeirdNamespace"; empty(p:e[1])" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: declare namespace p = "http://example.com/QuiteWeirdNamespace"; empty(p:e[1]). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found., AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: declare namespace p = "http://example.com/QuiteWeirdNamespace"; empty(p:e[1]). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'.
K2-DirectConElemNamespace-5,Error: XPST0017: Function in-scope-prefixes with arity of 1 not registered. No similar functions found.
K2-DirectConElemNamespace-6,Error: XPST0003: Unable to parse XPath: (count(in-scope-prefixes(element e{})[. eq "xml"])) = (1). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "e" found.
K2-DirectConElemNamespace-7,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'XPST0003: Unable to parse XPath: declare default function namespace "http://example.com"; <e a="{count()}" xmlns="http://www.w3.org/2001/XMLSchema"/>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'
K2-DirectConElemNamespace-8,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'XPST0003: Unable to parse XPath: declare default function namespace "http://example.com"; <e a="{p:count()}" xmlns:p="http://www.w3.org/2001/XMLSchema"/>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'
K2-DirectConElemNamespace-9,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'XPST0003: Unable to parse XPath: declare default function namespace "http://example.com"; <e xmlns="http://www.w3.org/2001/XMLSchema" a="{count()}"/>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'
K2-DirectConElemNamespace-10,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'XPST0003: Unable to parse XPath: declare default function namespace "http://example.com"; <e xmlns:p="http://www.w3.org/2001/XMLSchema" a="{p:count()}"/>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'
K2-DirectConElemNamespace-11,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: declare default function namespace "http://example.com"; <e xmlns="http://www.w3.org/2001/XMLSchema" a="{nametest}"/>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'
K2-DirectConElemNamespace-12,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: declare default function namespace "http://example.com"; <e a="{nametest}" xmlns="http://www.w3.org/2001/XMLSchema"/>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'
K2-DirectConElemNamespace-13,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: declare default function namespace "http://example.com"; <e xmlns:p="http://www.w3.org/2001/XMLSchema" p:p="{p:nametest}"/>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'
K2-DirectConElemNamespace-14,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: declare default function namespace "http://example.com"; <e p:p="{p:nametest}" xmlns:p="http://www.w3.org/2001/XMLSchema"/>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'
K2-DirectConElemNamespace-19,Error: XPST0081: The type integer does not exist.
K2-DirectConElemNamespace-20,Error: XPST0003: Unable to parse XPath: <e a="{1 treat as integer}" xmlns="http://www.w3.org/2001/XMLSchema"/>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "t" found.
K2-DirectConElemNamespace-21,Error: XPST0081: Can not cast: type is unknown.
K2-DirectConElemNamespace-22,AssertionError: Expected XPath <e a="{1 castable as string}" xmlns="http://www.w3.org/2001/XMLSchema"/> to resolve to the given XML. Expected <e xmlns="http://www.w3.org/2001/XMLSchema" a="false"/> to equal <e xmlns="http://www.w3.org/2001/XMLSchema" a="true"/>
K2-DirectConElemNamespace-25,AssertionError: Expected executing the XPath "declare namespace b = "http://www.example.com/"; empty(<e xmlns="http://www.example.com/"><d xmlns=""><b/></d></e>/b:d/b:b)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: declare namespace b = "http://www.example.com/"; empty(<e xmlns="http://www.example.com/"><d xmlns=""><b/></d></e>/b:d/b:b). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: declare namespace b = "http://www.example.com/"; empty(<e xmlns="http://www.example.com/"><d xmlns=""><b/></d></e>/b:d/b:b). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'.
K2-DirectConElemNamespace-26,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPDY0002: context is absent, it needs to be present to use axes.'
K2-DirectConElemNamespace-27,Error: XPST0017: Function p:integer with arity of 1 not registered. Did you mean "xs:integer (xs:anyAtomicType?)"?
K2-DirectConElemNamespace-29,Error: XPST0081: The type p:integer does not exist.
K2-DirectConElemNamespace-30,Error: XPST0003: Unable to parse XPath: <e a="{1 treat as p:integer}" xmlns:p="http://www.w3.org/2001/XMLSchema"/>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "t" found.
K2-DirectConElemNamespace-31,Error: XPST0081: Can not cast: type is unknown.
K2-DirectConElemNamespace-32,AssertionError: Expected XPath <e a="{1 castable as p:string}" xmlns:p="http://www.w3.org/2001/XMLSchema"/> to resolve to the given XML. Expected <e a="false"/> to equal <e xmlns:p="http://www.w3.org/2001/XMLSchema" a="true"/>
K2-DirectConElemNamespace-33,Error: Not implemented: references to variables with a namespace URI or a prefix.
K2-DirectConElemNamespace-39,Error: XPST0003: Unable to parse XPath:           declare namespace p = "http://example.com/";           document{<p:e xmlns=""/>, count(in-scope-prefixes(<p:e xmlns=""/>))}       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
K2-DirectConElemNamespace-40,Error: XPST0003: Unable to parse XPath: declare namespace p = "http://www.example.com/A"; <e xmlns="http://www.example.com/A" xmlns:A="http://www.example.com/C"> <b xmlns:B="http://www.example.com/C"/> </e>/p:b. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
K2-DirectConElemNamespace-41,Error: XPST0003: Unable to parse XPath: (declare namespace p = "http://www.example.com/A"; "START", for $i in in-scope-prefixes(<e xmlns="http://www.example.com/A" xmlns:A="http://www.example.com/C"> <b xmlns:B="http://www.example.com/C" /> </e>/p:b) order by $i return $i, "END")!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
K2-DirectConElemNamespace-49,Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.example.com/A"; <anElement xmlns="http://www.example.com/B"/>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
K2-DirectConElemNamespace-51,Error: XPST0003: Unable to parse XPath: declare default element namespace "http://example.com"; <e xmlns=""/>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
K2-DirectConElemNamespace-52,Error: XPST0003: Unable to parse XPath: declare default element namespace "http://example.com/"; <a> <e xmlns=""/> </a>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
K2-DirectConElemNamespace-53,Error: XPST0017: Function in-scope-prefixes with arity of 1 not registered. No similar functions found.
K2-DirectConElemNamespace-55,Error: XPST0003: Unable to parse XPath: <e xmlns="http://example.com/"> <b xmlns=""> { attribute {QName("http://example.com/2", "p:attr")} {()} } </b> </e>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.
K2-DirectConElemNamespace-56,Error: XPST0003: Unable to parse XPath: declare default element namespace "http://example.com/"; <r xmlns:p="http://example.com/"> { <e p:att=""/>/(@att, attribute::att) } </r>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
K2-DirectConElemNamespace-57,Error: XPST0003: Unable to parse XPath: declare default element namespace "http://example.com/"; declare namespace p = "http://example.com/"; <r> { <e p:att=""/>/(@att) } </r>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
K2-DirectConElemNamespace-58,NamespaceError: An attempt was made to create or change an object in a way which is incorrect with regard to namespaces
K2-DirectConElemNamespace-65,AssertionError: Expected executing the XPath "namespace-uri-for-prefix("p", <e xmlns:p="http://example.com/{{}}{{{{}}}}"/>)" to resolve to one of the expected results, but got Error: XPST0017: Function namespace-uri-for-prefix with arity of 2 not registered. Did you mean "namespace-uri-from-QName (xs:QName?)", "namespace-uri (node())" or "namespace-uri ()"?, AssertionError: expected [Function] to throw error including 'XQST0046' but got 'XPST0017: Function namespace-uri-for-prefix with arity of 2 not registered. Did you mean "namespace-uri-from-QName (xs:QName?)", "namespace-uri (node())" or "namespace-uri ()"?'.
K2-DirectConElemNamespace-77,Error: XPST0003: Unable to parse XPath: declare namespace t = "http://example.com/2"; <p:a xmlns:p="http://example.com/"> <p:e xmlns:p="http://example.com/2"/> </p:a>//t:e. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
K2-DirectConElemNamespace-78,Error: XPST0003: Unable to parse XPath: let $e := document{(<X1:L xmlns:X1="http://example.com/URL1">1</X1:L>, <X2:L xmlns:X2="http://example.com/URL2">2</X2:L>)} return <outer xmlns:P="http://example.com/URL1"> { let $outer as element(P:L) := $e/element(P:L) return <inner xmlns:P="http://example.com/URL2"> { let $inner as element(P:L) := $e/element(P:L) return ($outer, $inner) } </inner> } </outer>. SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
K2-DirectConElemNamespace-79,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: let $e := document{(<X1:L xmlns:X1="http://ns.example.com/URL1">1</X1:L>, <X2:L xmlns:X2="http://ns.example.com/URL2">2</X2:L>)} return <outer xmlns:P="http://ns.example.com/URL1"> { let $outer as element(P:L) := $e/element(P:L) return <inner xmlns:P="http://ns.example.com/URL2"> { let $inner as element(P:L) := $outer return $inner } </inner> } </outer>. SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", "||", [A-Z_a-z----------], [\\-.0-9-], or [-] but "{" found.'
Constr-inscope-2,AssertionError: Expected XPath <new>{//@*:attr1, //@*:attr2}</new> to resolve to the given XML. Expected <new foo:attr1="attr1" xmlns:foo="http://www.example.com/parent1" a0:attr2="attr2" xmlns:a0="http://www.example.com/parent2"/> to equal <new xmlns:foo="http://www.example.com/parent1" xmlns:XXX="http://www.example.com/parent2" foo:attr1="attr1" XXX:attr2="attr2"/>
Constr-inscope-4,AssertionError: Expected XPath for $x in <inscope> <parent1 xmlns:foo="http://www.example.com/parent1" foo:attr1="attr1"/> <parent2 xmlns:foo="http://www.example.com/parent2" foo:attr2="attr2"/></inscope> return <new>{$x//@*:attr1, $x//@*:attr2}</new> to resolve to the given XML. Expected <new foo:attr1="attr1" xmlns:foo="http://www.example.com/parent1" a0:attr2="attr2" xmlns:a0="http://www.example.com/parent2"/> to equal <new xmlns:foo="http://www.example.com/parent1" xmlns:XXX="http://www.example.com/parent2" foo:attr1="attr1" XXX:attr2="attr2"/>
Constr-inscope-13,Error: XPST0003: Unable to parse XPath: declare namespace foo = "http://example.com"; <new/>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
Constr-inscope-14,Error: XPST0003: Unable to parse XPath: declare namespace foo = "http://example.com"; <foo:new/>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
Constr-inscope-21,Error: XPST0003: Unable to parse XPath:          declare namespace cat ='mycat';          <a t='cat:miau'>42</a>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
Constr-inscope-22,NamespaceError: An attempt was made to create or change an object in a way which is incorrect with regard to namespaces
K2-ConInScopeNamespace-1,Error: XPST0003: Unable to parse XPath: (let $i := document{<e1/>, <e2/>, <e3/>, <e4/>} return (in-scope-prefixes($i/e1), in-scope-prefixes($i/e2), in-scope-prefixes($i/e3), in-scope-prefixes($i/e4)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
Constr-ws-tag-1,Error: XPST0003: Unable to parse XPath: declare boundary-space strip; <elem> </elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-tag-2,Error: XPST0003: Unable to parse XPath: declare boundary-space strip; <elem> </elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-tag-3,Error: XPST0003: Unable to parse XPath: declare boundary-space strip; <elem> </elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-tag-4,Error: XPST0003: Unable to parse XPath: declare boundary-space strip; <elem> <a> </a> <a> </a> <a> <b> </b> </a> </elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-tag-5,Error: XPST0003: Unable to parse XPath: (declare boundary-space strip; fn:count((<elem> <a> </a> <a> </a> <a> <b> </b> </a> </elem>)//text())) = (0). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "b" found.
Constr-ws-tag-6,Error: XPST0003: Unable to parse XPath: declare boundary-space preserve; <elem>   </elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-tag-7,Error: XPST0003: Unable to parse XPath: declare boundary-space preserve; <elem>   </elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-tag-8,Error: XPST0003: Unable to parse XPath: declare boundary-space preserve; <elem>			</elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-tag-9,Error: XPST0003: Unable to parse XPath: declare boundary-space preserve; <elem>   	       	    <a>          	          		 	         </a>	 <a>        	     </a>             <a>	  <b>           	 </b>    </a>	  		       </elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-tag-10,Error: XPST0003: Unable to parse XPath: (declare boundary-space preserve; fn:count((<elem> <a> </a> <a> </a> <a> <b> </b> </a> </elem>)//text())) = (9). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "b" found.
Constr-ws-enclexpr-1,Error: XPST0003: Unable to parse XPath: declare boundary-space strip; <elem> {1}</elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-enclexpr-2,Error: XPST0003: Unable to parse XPath: declare boundary-space strip; <elem> {1}</elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-enclexpr-3,Error: XPST0003: Unable to parse XPath: declare boundary-space strip; <elem> {1}</elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-enclexpr-4,Error: XPST0003: Unable to parse XPath: declare boundary-space strip; <elem>{1} {2}</elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-enclexpr-5,Error: XPST0003: Unable to parse XPath: declare boundary-space strip; <elem>{1} {2}</elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-enclexpr-6,Error: XPST0003: Unable to parse XPath: declare boundary-space strip; <elem>{1} {2}</elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-enclexpr-7,Error: XPST0003: Unable to parse XPath: declare boundary-space strip; <elem>{1} </elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-enclexpr-8,Error: XPST0003: Unable to parse XPath: declare boundary-space strip; <elem>{1} </elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-enclexpr-9,Error: XPST0003: Unable to parse XPath: declare boundary-space strip; <elem>{1} </elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-enclexpr-10,Error: XPST0003: Unable to parse XPath: declare boundary-space strip; <elem> <a/> <b/> </elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-enclexpr-11,Error: XPST0003: Unable to parse XPath: declare boundary-space strip; <elem> <a/> <b/> </elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-enclexpr-12,Error: XPST0003: Unable to parse XPath: declare boundary-space strip; <elem> <a/> <b/> </elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-enclexpr-13,Error: XPST0003: Unable to parse XPath: declare boundary-space preserve; <elem>   {1}</elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-enclexpr-14,Error: XPST0003: Unable to parse XPath: declare boundary-space preserve; <elem>   {1}</elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-enclexpr-15,Error: XPST0003: Unable to parse XPath: (: Name: Constr-ws-enclexpr-15 :) (: Written by: Andreas Behm :) (: Description: preserve whitespace tab between open tag and enclosed expression :)  declare boundary-space preserve;  <elem>			{1}</elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-enclexpr-16,Error: XPST0003: Unable to parse XPath: (: Name: Constr-ws-enclexpr-16 :) (: Written by: Andreas Behm :) (: Description: preserve whitespace space between enclosed expressions :)  declare boundary-space preserve;  <elem>{1}   {2}</elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-enclexpr-17,Error: XPST0003: Unable to parse XPath: (: Name: Constr-ws-enclexpr-17 :) (: Written by: Andreas Behm :) (: Description: preserve whitespace line feed between enclosed expressions :)  declare boundary-space preserve;  <elem>{1}   {2}</elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-enclexpr-18,Error: XPST0003: Unable to parse XPath: (: Name: Constr-ws-enclexpr-18 :) (: Written by: Andreas Behm :) (: Description: preserve whitespace tab between enclosed expressions :)  declare boundary-space preserve;  <elem>{1}			{2}</elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-enclexpr-19,Error: XPST0003: Unable to parse XPath: (: Name: Constr-ws-enclexpr-19 :) (: Written by: Andreas Behm :) (: Description: preserve whitespace space between enclosed expression and close tag :)  declare boundary-space preserve;  <elem>{1}   </elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-enclexpr-20,Error: XPST0003: Unable to parse XPath: (: Name: Constr-ws-enclexpr-20 :) (: Written by: Andreas Behm :) (: Description: preserve whitespace line feed between enclosed expression and close tag :)  declare boundary-space preserve;  <elem>{1}   </elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-enclexpr-21,Error: XPST0003: Unable to parse XPath: (: Name: Constr-ws-enclexpr-21 :) (: Written by: Andreas Behm :) (: Description: preserve whitespace tab between enclosed expression and close tag :)  declare boundary-space preserve;  <elem>{1}			</elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-enclexpr-22,Error: XPST0003: Unable to parse XPath: (: Name: Constr-ws-enclexpr-22 :) (: Written by: Andreas Behm :) (: Description: preserve whitespace space between child elements :)  declare boundary-space preserve; <elem>   <a/>   <b/>   </elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-enclexpr-23,Error: XPST0003: Unable to parse XPath: (: Name: Constr-ws-enclexpr-23 :) (: Written by: Andreas Behm :) (: Description: preserve whitespace line feed between child elements :)  declare boundary-space preserve; <elem>   <a/>   <b/>   </elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-enclexpr-24,Error: XPST0003: Unable to parse XPath: (: Name: Constr-ws-enclexpr-24 :) (: Written by: Andreas Behm :) (: Description: preserve whitespace tab between child elements :)  declare boundary-space preserve; <elem>			<a/>			<b/>			</elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-nobound-1,Error: XPST0003: Unable to parse XPath: declare boundary-space strip; <elem> x</elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-nobound-2,Error: XPST0003: Unable to parse XPath: let $result := ((: Name: Constr-ws-nobound-2 :) (: Written by: Andreas Behm :) (: Description: preserve leading line feed :)  declare boundary-space strip; <elem> x</elem>) return string-to-codepoints(string($result))[1] = 10. SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "b" found.
Constr-ws-nobound-3,Error: XPST0003: Unable to parse XPath: let $result := ((: Name: Constr-ws-nobound-3 :) (: Written by: Andreas Behm :) (: Description: preserve leading tab :)  declare boundary-space strip; <elem>	x</elem>) return string-to-codepoints(string($result))[1] = 9. SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "b" found.
Constr-ws-nobound-4,Error: XPST0003: Unable to parse XPath: declare boundary-space strip; <elem>x </elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-nobound-5,Error: XPST0003: Unable to parse XPath: let $result := ((: Name: Constr-ws-nobound-5 :) (: Written by: Andreas Behm :) (: Description: preserve trailing line feed :)  declare boundary-space strip; <elem>x </elem>) return deep-equal(string-to-codepoints(string($result)), (120, 10)). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "b" found.
Constr-ws-nobound-6,Error: XPST0003: Unable to parse XPath: let $result := ((: Name: Constr-ws-nobound-6 :) (: Written by: Andreas Behm :) (: Description: preserve trailing tab :)  declare boundary-space strip; <elem>x	</elem>) return deep-equal(string-to-codepoints(string($result)), (120, 9)). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "b" found.
Constr-ws-genchref-1,Error: XPST0003: Unable to parse XPath: declare boundary-space strip; <elem>&#x20;</elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-genchref-2,Error: XPST0003: Unable to parse XPath: let $result := (declare boundary-space strip; <elem>&#xA;</elem>) return deep-equal(string-to-codepoints(string($result)), (10)). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "b" found.
Constr-ws-genchref-3,Error: XPST0003: Unable to parse XPath: declare boundary-space strip; <elem>&#xD;</elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-genchref-4,Error: XPST0003: Unable to parse XPath: declare boundary-space strip; <elem>&#x9;</elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-gencdata-1,Error: XPST0003: Unable to parse XPath: declare boundary-space strip; <elem><![CDATA[ ]]></elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-gencdata-3,Error: XPST0003: Unable to parse XPath: let $result := ((: Name: Constr-ws-gencdata-3 :) (: Written by: Andreas Behm :) (: Description: preserve cdata tab :)  declare boundary-space strip; <elem><![CDATA[	]]></elem>) return deep-equal(string-to-codepoints(string($result)), (9)). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "b" found.
Constr-ws-adjchref-1,Error: XPST0003: Unable to parse XPath: declare boundary-space strip; <elem> &#x30; </elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-adjchref-2,Error: XPST0003: Unable to parse XPath: let $result := ((: Name: Constr-ws-adjchref-2 :) (: Written by: Andreas Behm :) (: Description: preserve line feed adjacent to character reference :)  declare boundary-space strip; <elem> &#x30; </elem>) return deep-equal(string-to-codepoints(string($result)), (10, 48, 10)). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "b" found.
Constr-ws-adjchref-3,Error: XPST0003: Unable to parse XPath: let $result := ((: Name: Constr-ws-adjchref-3 :) (: Written by: Andreas Behm :) (: Description: preserve tab adjacent to character reference :)  declare boundary-space strip; <elem>	&#x30;	</elem>) return deep-equal(string-to-codepoints(string($result)), (9, 48, 9)). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "b" found.
Constr-ws-adjcdata-1,Error: XPST0003: Unable to parse XPath: (: Name: Constr-ws-adjcdata-1 :) (: Written by: Andreas Behm :) (: Description: preserve space adjacent to cdata section :)  declare boundary-space strip; <elem> <![CDATA[]]> </elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-adjcdata-2,Error: XPST0003: Unable to parse XPath: let $result := ((: Name: Constr-ws-adjcdata-2 :) (: Written by: Andreas Behm :) (: Description: preserve line feed adjacent to cdata section :)  declare boundary-space strip; <elem> <![CDATA[]]> </elem>) return deep-equal(string-to-codepoints(string($result)), (10, 10)). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "b" found.
Constr-ws-adjcdata-3,Error: XPST0003: Unable to parse XPath: let $result := ((: Name: Constr-ws-adjcdata-3 :) (: Written by: Andreas Behm :) (: Description: preserve tab adjacent to cdata section :)  declare boundary-space strip; <elem>	<![CDATA[]]>	</elem>) return deep-equal(string-to-codepoints(string($result)), (9, 9)). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "b" found.
Constr-ws-genenclexpr-1,Error: XPST0003: Unable to parse XPath: declare boundary-space strip; <elem>{" "}</elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-genenclexpr-2,Error: XPST0003: Unable to parse XPath: let $result := ((: Name: Constr-ws-genenclexpr-2 :) (: Written by: Andreas Behm :) (: Description: preserve enclosed exp line feed :)  declare boundary-space strip; <elem>{" "}</elem>) return deep-equal(string-to-codepoints(string($result)), (10)). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "b" found.
Constr-ws-genenclexpr-3,Error: XPST0003: Unable to parse XPath: let $result := ((: Name: Constr-ws-genenclexpr-3 :) (: Written by: Andreas Behm :) (: Description: preserve enclosed exp tab :)  declare boundary-space strip; <elem>{"	"}</elem>) return deep-equal(string-to-codepoints(string($result)), (9)). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "b" found.
Constr-ws-xmlspace-1,Error: XPST0003: Unable to parse XPath: declare boundary-space strip; <elem xml:space="preserve"> </elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
Constr-ws-xmlspace-2,AssertionError: Expected executing the XPath "declare boundary-space preserve; <elem xml:space="strip"> </elem>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: declare boundary-space preserve; <elem xml:space="strip"> </elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found., AssertionError: expected [Function] to throw error including 'XQDY0092' but got 'XPST0003: Unable to parse XPath: declare boundary-space preserve; <elem xml:space="strip"> </elem>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.'.
K2-DirectConElemWhitespace-1,Error: XPST0003: Unable to parse XPath: (declare boundary-space preserve; string(<e> <b/> </e>))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "b" found.
K2-DirectConElemWhitespace-4,Error: XPST0003: Unable to parse XPath: declare boundary-space preserve; <e> <b/>  </e>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
K2-DirectConElemWhitespace-5,Error: XPST0003: Unable to parse XPath: declare boundary-space strip; string(<e xml:space="preserve"> </e>) eq "". SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
K2-DirectConElemWhitespace-6,Error: XPST0003: Unable to parse XPath: declare boundary-space strip; <e xml:space="preserve"> </e>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
K2-DirectConElemWhitespace-7,Error: XPST0003: Unable to parse XPath: declare boundary-space preserve; string(<e xml:space="default"> </e>) eq " ". SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
K2-DirectConElemWhitespace-8,Error: XPST0003: Unable to parse XPath: declare boundary-space preserve; <e xml:space="preserve"> </e>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
eqname-002,Error: XPST0003: Unable to parse XPath:              declare variable $Q{http://www.example.com/ns/my}var := 12;              <out>{$Q{http://www.example.com/ns/my}var}</out>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
eqname-003,Error: XPST0003: Unable to parse XPath:          declare function Q{http://www.example.com/ns/my}fn ($a as xs:integer) as xs:integer { $a + 2 };          <out>{Q{http://www.example.com/ns/my}fn(12)}</out>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
eqname-004,Error: XPST0003: Unable to parse XPath: declare function local:fn ($a as Q{http://www.w3.org/2001/XMLSchema}integer) as element(Q{http://www.example.com/ns/my}e) { <e xmlns="http://www.example.com/ns/my">{$a}</e> }; <out>{local:fn(12)}</out>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
eqname-005,Error: XPST0003: Unable to parse XPath: declare option Q{http://www.example.com/ns}option "ignore me"; <a/>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "o" found.
eqname-006,Error: XPST0003: Unable to parse XPath: (# Q{http://www.example.com/ns}pragma ignore me #) {<a/>}. SyntaxError: Expected " ", "$", "'", "(", "(:", ")", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-z----------], or [-] but "#" found.
eqname-007,Error: XPST0003: Unable to parse XPath:          declare decimal-format Q{http://www.example.com/ns}format grouping-separator="'";          <a xmlns:ex="http://www.example.com/ns">{format-number(1e9, "#'###'###'##0.00", 'ex:format')}</a>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
eqname-008,AssertionError: Expected XPath <out>{ (<a xmlns:ex="http://www.example.com/ns"><ex:b>93.7</ex:b></a>) /Q{http://www&#x2e;example&#x2E;com/ns}b }</out> to resolve to the given XML. Expected <out/> to equal <out><ex:b xmlns:ex="http://www.example.com/ns">93.7</ex:b></out>
eqname-012,AssertionError: Expected XPath <out>{ (<my:a xmlns:my="http://www.example.com/ns/my"><my:b>42</my:b></my:a>) / Q{http://www.example.com/ns/my}* + 5 }</out> to resolve to the given XML. Expected <out/> to equal <out>47</out>
eqname-013,AssertionError: Expected XPath <out xmlns="http://www.example.com/one">{ (<my:a xmlns:my="http://www.example.com/ns/my"><my:b>42</my:b><b xmlns="">93</b></my:a>) / Q{}* + 5 }</out> to resolve to the given XML. Expected <out xmlns="http://www.example.com/one"/> to equal <out xmlns="http://www.example.com/one">98</out>
eqname-015,Error: Not implemented: references to variables with a namespace URI or a prefix.
eqname-016,AssertionError: Expected executing the XPath "string-join(<a foo="3" bar="5" xml:space="preserve"/> / @Q{}*, '.')" to resolve to one of the expected results, but got AssertionError: Expected XPath string-join(<a foo="3" bar="5" xml:space="preserve"/> / @Q{}*, '.') to resolve to "3.5": expected false to be true, AssertionError: Expected XPath string-join(<a foo="3" bar="5" xml:space="preserve"/> / @Q{}*, '.') to resolve to "5.3": expected false to be true.
eqname-017,AssertionError: Expected XPath string-join(<a foo="3" bar="5" xml:space="preserve"/> / @Q{http://www.w3.org/XML/1998/namespace}*, '.') to resolve to "preserve": expected false to be true
eqname-020,Error: Not implemented: function references with a namespace URI.
eqname-021,Error: Not implemented: function references with a namespace URI.
eqname-022,Error: Not implemented: function references with a namespace URI.
eqname-024,Error: Not implemented: references to variables with a namespace URI or a prefix.
eqname-029,Error: Not implemented: function references with a namespace URI.
eqname-029p,Error: Not implemented: function references with a namespace URI.
eqname-030,Error: Not implemented: references to variables with a namespace URI or a prefix.
eqname-031,Error: Not implemented: references to variables with a namespace URI or a prefix.
eqname-032,Error: Not implemented: references to variables with a namespace URI or a prefix.
eqname-033,Error: Not implemented: references to variables with a namespace URI or a prefix.
eqname-034,AssertionError: Expected executing the XPath "          let $Q{$Q}a := 12, $Q{//}a := 13, $Q{*}a := 14          return $Q{$Q}a + $Q{//}a + $Q{*}a       " to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0046' but got 'Not implemented: references to variables with a namespace URI or a prefix.', Error: Not implemented: references to variables with a namespace URI or a prefix..
eqname-908,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'Not implemented: function references with a namespace URI.'
eqname-909,AssertionError: Expected executing the XPath "Q{&#x7D;http://www.w3.org/2005/xpath-functions/math}pi()" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0046' but got 'Not implemented: function references with a namespace URI.', AssertionError: expected [Function] to throw error including 'XPST0017' but got 'Not implemented: function references with a namespace URI.'.
eqname-909p,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'Not implemented: function references with a namespace URI.'
eqname-910,AssertionError: expected [Function] to throw an error
eqname-913,AssertionError: expected [Function] to throw an error
ForExpr006,Error: XPST0017: Function data with arity of 1 not registered. No similar functions found.
ForExpr008,Error: XPST0003: Unable to parse XPath: for $AaBbCc.-_Dd in /MyComputer/Drive1/Folder where $AaBbCc.-_Dd/@creator = "Mani" return $AaBbCc.-_Dd/FolderName. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.
ForExpr010,Error: XPST0003: Unable to parse XPath: for $folder in //Folder for $file in $folder//File return <File folder="{$folder/FolderName}">{string($file/FileName[1])}</File>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found.
ForExpr022,Error: XPST0003: Unable to parse XPath: (for $file at $pos in (//Folder)[1]/File return (string($file/FileName[1]), $pos))!string() => string-join(" "). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
ForExpr023,Error: XPST0003: Unable to parse XPath: (for $file at $pos in (//Folder)[1]/File, $pos2 in $pos+1 return (string($file/FileName[1]), $pos, $pos2))!string() => string-join(" "). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
ForExpr024,AssertionError: expected [Function] to throw error including 'XQST0089' but got 'XPST0003: Unable to parse XPath: for $file at $file in (//Folder)[1]/File return (string($file/FileName[1]), $file). SyntaxError: Expected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.'
ForExpr029,Error: XPST0003: Unable to parse XPath: (for $var in (1,2) for $var in (2,2) return $var * $var)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found.
ForExpr031,AssertionError: expected [Function] to throw error including 'XQST0089' but got 'XPST0003: Unable to parse XPath: for $var at $var in (1, 2) return $var * $var. SyntaxError: Expected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.'
ForExpr032,Error: XPST0003: Unable to parse XPath: (          declare variable $j external := 1;          for $x at $i in (2, 3)          where $i = $j          return $x       ) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
K-ForExprWithout-18,AssertionError: Expected executing the XPath "empty(for $var in () return current-time())" to resolve to one of the expected results, but got Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0017: Function current-time with arity of 0 not registered. No similar functions found.'.
K-ForExprWithout-20,AssertionError: Expected executing the XPath "empty((for $var in () return current-time()))" to resolve to one of the expected results, but got Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0017: Function current-time with arity of 0 not registered. No similar functions found.'.
K-ForExprWithout-22,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ForExprWithout-23,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ForExprWithout-24,Error: Not implemented: references to variables with a namespace URI or a prefix.
K-ForExprWithout-25,Error: Not implemented: references to variables with a namespace URI or a prefix.
K-ForExprWithout-27,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'Not implemented: references to variables with a namespace URI or a prefix.'
K-ForExprWithout-28,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'Not implemented: references to variables with a namespace URI or a prefix.'
K-ForExprWithout-30,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'Not implemented: references to variables with a namespace URI or a prefix.'
K-ForExprWithout-31,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'Not implemented: references to variables with a namespace URI or a prefix.'
K-ForExprWithout-33,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'Not implemented: references to variables with a namespace URI or a prefix.'
K-ForExprWithout-34,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'Not implemented: references to variables with a namespace URI or a prefix.'
K-ForExprWithout-51,Error: Not implemented: references to variables with a namespace URI or a prefix.
K-ForExprWithout-52,Error: XPST0003: Unable to parse XPath:          declare variable $i := false();          declare variable $t := false();          deep-equal( for $i in (true(), true()), $t in (true(), true())                      return ($i, $t), (true(), true(), true(), true(), true(), true(), true(), true())). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K-ForExprWithout-53,Error: XPST0003: Unable to parse XPath: declare variable $my := 3; (for $i in 1 return $my) eq 3. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K-ForExprWithout-54,Error: XPST0003: Unable to parse XPath: declare variable $i := 3; (for $i in 1 return $i) eq 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K-ForExprWithout-55,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ForExprWithout-56,Error: XPST0017: Function timezone-from-time with arity of 1 not registered. No similar functions found.
K2-ForExprWithout-2,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: \n        declare function local:myFunc() { for $i in (1, 2, 3) return position() }; \n        local:myFunc(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K2-ForExprWithout-3,AssertionError: Expected executing the XPath "declare function local:myFunc() { for $i in (1, 2, 3) return position() }; 1" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare function local:myFunc() { for $i in (1, 2, 3) return position() }; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found., AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: declare function local:myFunc() { for $i in (1, 2, 3) return position() }; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
K2-ForExprWithout-4,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: declare function local:myFunc() { for $i at $p in (1, 2, 3) return position() }; local:myFunc(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K2-ForExprWithout-5,AssertionError: Expected executing the XPath "declare function local:myFunc() { for $i at $p in (1, 2, 3) return position() }; 1" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare function local:myFunc() { for $i at $p in (1, 2, 3) return position() }; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found., AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: declare function local:myFunc() { for $i at $p in (1, 2, 3) return position() }; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
K2-ForExprWithout-6,Error: XPST0017: Function fn:substring with arity of 3 not registered. Did you mean "xs:string (xs:anyAtomicType?)"?
K2-ForExprWithout-8,Error: XPST0003: Unable to parse XPath: (for $d in <people> <person id="person0"> <name>First</name> </person> <person> <name>Second</name> </person> </people>/person return if (some $id in 1 satisfies typeswitch ($d/@id) case $n as node() return $d/@id = "person0" default $d return ()) then $d/name else ()). SyntaxError: Expected "!", "!=", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "(" found.
K2-ForExprWithout-9,Error: XPST0003: Unable to parse XPath: (for $a at $pos1 in (1, 2, 3) return for $b at $pos2 in (4, 5, 6) return for $c at $pos3 in (7, 8, 9) return ($a, $pos1, $b, $pos2, $c, $pos2))!string() => string-join(" "). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
K2-ForExprWithout-10,AssertionError: Expected executing the XPath "         for $a in (3, 2, 1)          for $b in (6, 5, 4)          let $c := $a + $b          let $d := $a - $b          let $e := () stable order by $a ascending, $b descending, $d empty greatest, $e empty least, $c descending empty greatest, $d ascending empty greatest, $e descending empty least, $b ascending empty least          return $a" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (         for $a in (3, 2, 1)          for $b in (6, 5, 4)          let $c := $a + $b          let $d := $a - $b          let $e := () stable order by $a ascending, $b descending, $d empty greatest, $e empty least, $c descending empty greatest, $d ascending empty greatest, $e descending empty least, $b ascending empty least          return $a)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: \n        for $a in (3, 2, 1) \n        for $b in (6, 5, 4) \n        let $c := $a + $b \n        let $d := $a - $b \n        let $e := () stable order by $a ascending, $b descending, $d empty greatest, $e empty least, $c descending empty greatest, $d ascending empty greatest, $e descending empty least, $b ascending empty least \n        return $a. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found.'.
K2-ForExprWithout-11,Error: XPST0003: Unable to parse XPath: (for $a in (3, 2, 1, 1) stable order by $a return 5)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found.
K2-ForExprWithout-12,Error: XPST0003: Unable to parse XPath: (for $a in (3, 2, 1, 1) stable order by 1 return $a)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found.
K2-ForExprWithout-15,Error: XPST0003: Unable to parse XPath: (declare function local:func($arg as element()* ) as element()* { for $n in $arg/element return $n }; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-ForExprWithout-16,Error: XPST0003: Unable to parse XPath: (declare function local:func($arg as element()* ) as element()* { for $n in $arg/document return $n }; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-ForExprWithout-17,Error: XPST0003: Unable to parse XPath: (declare function local:func($arg as element()* ) as element()* { for $n in $arg/document-node return $n }; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-ForExprWithout-18,Error: XPST0003: Unable to parse XPath: (declare function local:func($arg as element()* ) as element()* { for $n in $arg/attribute return $n }; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-ForExprWithout-19,Error: XPST0003: Unable to parse XPath: (declare function local:func($arg as element()* ) as element()* { for $n in $arg/comment return $n }; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-ForExprWithout-20,Error: XPST0003: Unable to parse XPath: (declare function local:func($arg as element()* ) as element()* { for $n in $arg/processing-instruction return $n }; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-ForExprWithout-21,Error: XPST0003: Unable to parse XPath: (declare function local:func($arg as element()* ) as element()* { for $n in $arg/processing-instruction return $n }; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-ForExprWithout-22,Error: XPST0003: Unable to parse XPath: (declare function local:func($arg as element()* ) as element()* { for $n in $arg/text return $n }; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-ForExprWithout-23,Error: XPST0003: Unable to parse XPath: (declare function local:func($arg as element()* ) as element()* { for $n in $arg/typeswitch return $n }; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-ForExprWithout-24,Error: XPST0003: Unable to parse XPath: (declare function local:func($arg as element()* ) as element()* { for $n in $arg/if return $n }; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-ForExprWithout-25,Error: XPST0003: Unable to parse XPath: (declare function local:func($arg as element()* ) as element()* { for $n in $arg/for return $n }; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-ForExprWithout-26,Error: XPST0003: Unable to parse XPath: (declare function local:func($arg as element()* ) as element()* { for $n in $arg/let return $n }; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-ForExprWithout-27,Error: XPST0003: Unable to parse XPath: (declare function local:func($arg as element()* ) as element()* { for $n in $arg/declare return $n }; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-ForExprWithout-28,Error: XPST0003: Unable to parse XPath: (declare function local:func($arg as element()* ) as element()* { for $n in $arg/some return $n }; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-ForExprWithout-29,Error: XPST0003: Unable to parse XPath: (declare function local:func($arg as element()* ) as element()* { for $n in $arg/child return $n }; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-ForExprWithout-30,Error: XPST0003: Unable to parse XPath: (declare function local:func($arg as element()* ) as element()* { for $n in $arg/ordered return $n }; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-ForExprWithout-31,Error: XPST0003: Unable to parse XPath: (declare function local:func($arg as element()* ) as element()* { for $n in $arg/unordered return $n }; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-ForExprWithout-32,Error: XPST0003: Unable to parse XPath: (declare function local:func($arg as element()* ) as element()* { for $n in $arg/schema-attribute return $n }; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-ForExprWithout-33,Error: XPST0003: Unable to parse XPath: (declare function local:func($arg as element()* ) as element()* { for $n in $arg/schema-element return $n }; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-ForExprWithout-34,Error: XPST0003: Unable to parse XPath: (declare function local:func($arg as element()* ) as element()* { for $n in $arg/item return $n }; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-ForExprWithout-35,Error: XPST0003: Unable to parse XPath: (declare function local:func($arg as element()* ) as element()* { for $n in $arg/following-sibling return $n }; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-ForExprWithout-36,Error: XPST0003: Unable to parse XPath: (declare function local:func($arg as element()* ) as element()* { for $n in $arg/validate return $n }; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-ForExprWithout-37,Error: XPST0003: Unable to parse XPath: (declare function local:func($arg as element()* ) as element()* { for $n in $arg/instance return $n }; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-ForExprWithout-38,Error: XPST0003: Unable to parse XPath: (declare function local:func($arg as element()* ) as element()* { for $n in $arg/castable return $n }; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-ForExprWithout-39,Error: XPST0003: Unable to parse XPath: (declare function local:func($arg as element()* ) as element()* { for $n in $arg/import return $n }; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-ForExprWithout-42,Error: XPST0003: Unable to parse XPath: (for $n in attribute return {()} return 1) = (1). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-z----------], or [-] but "{" found.
K2-ForExprWithout-43,Error: XPST0003: Unable to parse XPath: (for $n in element return {()} return 1) = (1). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-z----------], or [-] but "{" found.
K2-ForExprWithout-44,Error: XPST0003: Unable to parse XPath: (for $n in processing-instruction return {()} return 1) = (1). SyntaxError: Expected " ", "$", "'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\"", "\n", "\r", "\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-z----------], or [-] but "{" found.
ForExprType001,Error: XPST0003: Unable to parse XPath: for $file as element(File,xs:untyped) in (//Folder)[1]/File return $file/FileName. SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
ForExprType002,Error: XPST0003: Unable to parse XPath: (for $fileName as attribute(name,xs:untypedAtomic) in (//Folder)[1]/File/@name return data($fileName))!string() => string-join(" "). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
ForExprType003,Error: XPST0003: Unable to parse XPath: for $PI as processing-instruction() in //processing-instruction() return $PI. SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
ForExprType004,Error: XPST0003: Unable to parse XPath: for $comment as comment() in //comment() return $comment. SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
ForExprType005,Error: XPST0003: Unable to parse XPath: (for $int as xs:int in (xs:int(1), xs:int(2)) return $int)!string() => string-join(" "). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
ForExprType006,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: for $int as xs:string in (xs:int(1), xs:int(2)) return $int. SyntaxError: Expected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.'
ForExprType009,AssertionError: Expected executing the XPath "         declare namespace xqt="http://www.w3.org/XQueryTestOrderBy";          for $num as element(xqt:NegativeNumbers) in /xqt:DataValues/xqt:NegativeNumbers return $num" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath:          declare namespace xqt="http://www.w3.org/XQueryTestOrderBy";          for $num as element(xqt:NegativeNumbers) in /xqt:DataValues/xqt:NegativeNumbers return $num. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found., Error: XPST0003: Unable to parse XPath:          declare namespace xqt="http://www.w3.org/XQueryTestOrderBy";          for $num as element(xqt:NegativeNumbers) in /xqt:DataValues/xqt:NegativeNumbers return $num. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found..
ForExprType011,AssertionError: expected [Function] to throw error including 'XPST0051' but got 'XPST0003: Unable to parse XPath: \n        declare namespace xqt="http://www.w3.org/XQueryTestOrderBy"; \n        for $num as xs:undefinedType in data( /xqt:DataValues/xqt:NegativeNumbers/xqt:orderData ) return $num. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
ForExprType014,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare namespace xqt="http://www.w3.org/XQueryTestOrderBy"; \n        for $num as empty-sequence() in data( /xqt:DataValues/xqt:NegativeNumbers/xqt:orderData ) return $num. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
ForExprType015,Error: XPST0003: Unable to parse XPath: (for $num as xs:decimal in (xs:integer(1), xs:integer(2), xs:integer(3)) return $num)!string() => string-join(" "). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
ForExprType016,Error: XPST0003: Unable to parse XPath: (for $num as xs:decimal in (xs:integer(1), xs:decimal(2), xs:integer(3)) return $num)!string() => string-join(" "). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
ForExprType017,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: for $num as xs:double in (xs:int("1"), xs:integer("2"), xs:string("3")) return $num. SyntaxError: Expected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.'
ForExprType018,Error: XPST0003: Unable to parse XPath: for $file as node() in (//Folder)[1]/File return $file/FileName. SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
ForExprType019,Error: XPST0003: Unable to parse XPath: (for $fileName as text() in (//Folder)[1]/File/FileName/text() return string( $fileName ))!string() => string-join(" "). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
ForExprType020,Error: XPST0003: Unable to parse XPath: (for $fileName as item() in data( (//Folder)[1]/File/FileName ) return $fileName)!string() => string-join(" "). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
ForExprType021,Error: XPST0003: Unable to parse XPath: (for $doc as document-node() in (/) return count( $doc )) = (1). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
ForExprType022,Error: XPST0003: Unable to parse XPath: (         declare default element namespace "http://www.example.com/typedecl";          for $test as attribute(*) in ( /root/InterleaveType2/@integer, /root/InterleaveType2/@decimal )          return data( $test )       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found.
ForExprType023,Error: XPST0003: Unable to parse XPath: (         declare default element namespace "http://www.example.com/typedecl";          for $test as attribute(integer) in ( /root/InterleaveType2/@integer ) return data( $test )       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found.
ForExprType024,Error: XPST0003: Unable to parse XPath: (         declare default element namespace "http://www.example.com/typedecl";          for $test as attribute(att, xs:anySimpleType) in /root/anyAtomicType/@att return data( $test )       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found.
ForExprType028,Error: XPST0003: Unable to parse XPath: (         for $test as xs:integer in ( xs:byte("1"), xs:long("10000"), xs:negativeInteger("-10"),                          xs:short("100"), xs:positiveInteger("100"), xs:nonNegativeInteger("100") )          return $test       )!string() => string-join(" "). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
ForExprType029,Error: XPST0003: Unable to parse XPath: (         for $test as xs:decimal in ( xs:integer("100"), xs:short("1"), xs:int("10000"),                  xs:nonPositiveInteger("-10"), xs:unsignedShort("100"), xs:positiveInteger("100"), xs:nonNegativeInteger("100") )          return $test       )!string() => string-join(" "). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
ForExprType030,Error: XPST0003: Unable to parse XPath: (         for $test as xs:normalizedString in ( xs:language("en-US"), xs:NCName("foobar"),              xs:NMTOKEN("token1"), xs:ENTITY("entity1") )          return $test       )!string() => string-join(" "). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
ForExprType031,Error: XPST0003: Unable to parse XPath: (         for $test as xs:anyAtomicType in ( xs:duration("P0Y1347M0D"), xs:dateTime("1999-05-31T13:20:00-05:00"),                      xs:time("13:00:00-05:00"), xs:date("1999-05-10Z"), xs:gYearMonth("2002-03"), xs:gYear("1999"),                      xs:gMonthDay("--05-10"), xs:gDay("---10"), xs:gMonth("--05") )          return $test       )!string() => string-join(" "). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
ForExprType032,Error: XPST0003: Unable to parse XPath: (         for $test as xs:anyAtomicType in ( xs:boolean("true"), xs:base64Binary("abcd"), xs:hexBinary("1234"),                      xs:float("5.7"), xs:double("7.5"), xs:anyURI("http://foo") )          return $test       )!string() => string-join(" "). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
ForExprType033,Error: XPST0003: Unable to parse XPath: (         for $test as xs:anyAtomicType in ( xs:unsignedByte("10"), xs:short("20"), xs:positiveInteger("30"),                  xs:nonPositiveInteger("-40"), xs:decimal("5.5"), xs:ENTITY("entity1"), xs:NCName("foobar"),                  xs:language("en-US"), xs:string("foobar"), xs:hexBinary("ffff"), xs:gYear("1999") )          return $test       )!string() => string-join(" "). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
ForExprType034,Error: XPST0003: Unable to parse XPath: (for $test as xs:decimal in ( 1, 0.3 ) return $test)!string() => string-join(" "). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
ForExprType035,Error: XPST0003: Unable to parse XPath: (for $test as xs:anyAtomicType in ( 1, "string", 1e2, 0.3 ) return $test)!string() => string-join(" "). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
ForExprType036,Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.example.com/typedecl";          for $test as element(*) in /root/InterleaveType/* return $test       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
ForExprType045,AssertionError: expected [Function] to throw error including 'XPST0051' but got 'XPST0003: Unable to parse XPath: for $test as xs:unknownType in ( 1, 2, 3) return $test. SyntaxError: Expected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.'
ForExprType046,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: for $test as xs:double in ( 1, 1e2, 0.3 ) return $test. SyntaxError: Expected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.'
ForExprType047,AssertionError: expected [Function] to throw error including 'XPST0051' but got 'XPST0003: Unable to parse XPath: for $test as xs:NMTOKENS in ( xs:NMTOKEN("ab"), xs:NMTOKEN("cd") ) return $test. SyntaxError: Expected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.'
ForExprType054,Error: XPST0003: Unable to parse XPath: (         declare namespace fs="http://www.example.com/filesystem";          for $test as item() in data( (//fs:Folder)[1]/fs:File/fs:FileName ) return $test       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
ForExprType055,Error: XPST0003: Unable to parse XPath:          declare namespace fs="http://www.example.com/filesystem";          for $test as node() in (//fs:Folder)[1]/fs:File return $test/fs:FileName       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
ForExprType056,Error: XPST0003: Unable to parse XPath:          declare namespace fs="http://www.example.com/filesystem";          for $test as document-node() in (/) return ($test//fs:Folder)[1]/fs:FolderName       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
ForExprType057,Error: XPST0003: Unable to parse XPath:          declare namespace fs="http://www.example.com/filesystem";          document{for $test as text() in (//fs:Folder)[1]/fs:File/fs:FileName/text() return $test}       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
ForExprType058,Error: XPST0003: Unable to parse XPath:          declare namespace fs="http://www.example.com/filesystem";          document{for $test as comment() in (//fs:Folder)[1]/comment() return $test}       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
ForExprType059,Error: XPST0003: Unable to parse XPath:          declare namespace fs="http://www.example.com/filesystem";          for $test as processing-instruction() in (//fs:Folder)[1]//processing-instruction() return $test       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
ForExprType060,Error: XPST0003: Unable to parse XPath: declare namespace fs="http://www.example.com/filesystem"; for $test as processing-instruction() in (//fs:Folder)[1]//processing-instruction() return $test. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
ForExprType061,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test as processing-instruction("unknown") in (//fs:Folder)[1]//processing-instruction() return $test\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
ForExprType062,Error: XPST0003: Unable to parse XPath:          declare namespace fs="http://www.example.com/filesystem";          for $test as item() in (//fs:Folder)[1]/fs:File/fs:FileName return $test       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
ForExprType063,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test as node() in data( (//fs:Folder)[1]/fs:File/fs:FileName ) return $test\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
ForExprType064,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test as text() in (//fs:Folder)[1]/fs:File/fs:FileName return $test\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
ForExprType065,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test as text() in data( (//fs:Folder)[1]/fs:File/fs:FileName ) return $test\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
ForExprType066,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test as comment() in (//fs:Folder)[1]/fs:File/fs:FileName return $test\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
ForExprType067,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test as comment() in data( (//fs:Folder)[1]/fs:File/fs:FileName ) return $test\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
ForExprType068,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test as processing-instruction() in (//fs:Folder)[1]/fs:File/fs:FileName return $test\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
ForExprType069,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test as processing-instruction() in data( (//fs:Folder)[1]/fs:File/fs:FileName ) return $test\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
ForExprType070,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test as processing-instruction("foo") in (//fs:Folder)[1]/fs:File/fs:FileName return $test\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
ForExprType071,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test as processing-instruction("foo") in data( (//fs:Folder)[1]/fs:File/fs:FileName ) return $test\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
ForExprType072,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test as document-node() in (//fs:Folder)[1]/fs:File/fs:FileName return $test\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
ForExprType073,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare namespace fs="http://www.example.com/filesystem"; \n        for $test as document-node() in data( (//fs:Folder)[1]/fs:File/fs:FileName ) return $test\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
K2-ForExprWith-1,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: for $i as xs:string in xs:untypedAtomic("input") return $i. SyntaxError: Expected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.'
FunctionCall-003,Error: XPST0003: Unable to parse XPath: (xs:integer(validate type xs:decimal {<a>93.7</a>})) instance of xs:integer. SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.
FunctionCall-004,Error: XPST0003: Unable to parse XPath:           declare function local:f($in as xs:boolean) as xs:boolean { $in };          local:f(<a>0</a>). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
FunctionCall-005,Error: XPST0003: Unable to parse XPath:           declare function local:f($in as xs:anyAtomicType) as xs:boolean { $in instance of xs:decimal };          local:f(validate type xs:integer {<a>12</a>}). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
FunctionCall-007,Error: XPST0003: Unable to parse XPath:           declare function local:f($in as xs:anyAtomicType) as xs:boolean { $in instance of xs:decimal };          let $f := function-lookup(xs:QName('local:f'), 1)          return $f(validate type xs:integer {<a>12</a>}). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
FunctionCall-008,Error: XPST0003: Unable to parse XPath: (         let $f := xs:integer#1         return $f(validate type xs:decimal {<a>93.7</a>})       ) instance of xs:integer. SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.
FunctionCall-009,Error: XPST0003: Unable to parse XPath: (         declare function local:f($in as xs:decimal*) as xs:decimal {sum($in, 0.0)};         local:f(xs:NMTOKENS('1 1.2 1.3 1.4')!xs:untypedAtomic(.))       ) instance of xs:decimal. SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
FunctionCall-010,Error: XPST0081: Can not cast: type is unknown.
FunctionCall-011,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
FunctionCall-012,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.'
FunctionCall-013,Error: XPST0003: Unable to parse XPath: (         declare function local:f($a as xs:integer, $b as xs:integer) as xs:integer {           data(<a>{$a}{$b}</a>)         };         local:f(12, 34)       ) instance of xs:integer. SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
FunctionCall-014,Error: XPST0017: Function data with arity of 1 not registered. No similar functions found.
FunctionCall-015,Error: XPST0003: Unable to parse XPath: (          declare function local:f($in as xs:integer) as xs:integer { $in + 1 };          let $f := function-lookup(xs:QName(<f>local:f</f>), 1)          return $f(12)) = (13). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
FunctionCall-016,AssertionError: expected [Function] to throw error including 'XPTY0117' but got 'XPST0003: Unable to parse XPath: \n         declare function local:f($in as xs:QName) as xs:integer { string-length(local-name-from-QName($in)) };\n         let $e := <a xsi:type=\'my:integer\' xmlns:my=\'http://my.example.com/\'>123</a>\n         return local:f($e/@xsi:type). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
FunctionCall-017,AssertionError: expected [Function] to throw error including 'XPTY0117' but got 'XPST0003: Unable to parse XPath: \n         let $f := function ($in as xs:QName) as xs:integer { string-length(local-name-from-QName($in)) }\n         let $e := <a xsi:type=\'my:integer\' xmlns:my=\'http://my.example.com/\'>123</a>\n         return $f($e/@xsi:type)\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.'
FunctionCall-018,AssertionError: expected [Function] to throw error including 'XPTY0117' but got 'An attempt was made to create or change an object in a way which is incorrect with regard to namespaces'
FunctionCall-019,AssertionError: expected [Function] to throw error including 'XPTY0117' but got 'XPST0003: Unable to parse XPath: \n         declare function local:q ($prefix as xs:string, $local as xs:string) as xs:QName {\n            <a>{$prefix}:{$local}</a>\n         };\n         local:q(\'fn\', \'abs\')\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
FunctionCall-020,AssertionError: expected [Function] to throw an error
FunctionCall-021,AssertionError: expected [Function] to throw error including 'XPTY0117' but got 'XPST0003: Unable to parse XPath: \n         declare function local:q ($prefix as xs:string, $local as xs:string) as xs:QName {\n            <a>{$prefix}:{$local}</a>\n         };\n         let $curried := local:q(\'fn\', ?)\n         return $curried(\'abs\')\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
FunctionCall-022,Error: XPST0003: Unable to parse XPath: deep-equal((          declare function local:unique($in as xs:integer*) as xs:boolean { count($in) = count(distinct-values($in)) };          (local:unique([1,2,3,4,5]), local:unique([1,2,3,4,4]))), (true(), false())). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
FunctionCall-027,AssertionError: expected [Function] to throw error including 'XPST0051' but got 'XPST0081: Can not cast: type is unknown.'
FunctionCall-044,AssertionError: expected [Function] to throw an error
FunctionCall-048,AssertionError: expected [Function] to throw an error
K-FunctionCallExpr-5,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPST0017: Function prefix-does-not-exist:func-does-not-exist with arity of 3 not registered. No similar functions found.'
K-FunctionCallExpr-15a,Error: XPST0017: Function format-number with arity of 2 not registered. No similar functions found.
K-FunctionCallExpr-16a,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
K-FunctionCallExpr-17a,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
K-FunctionCallExpr-25a,Error: XPST0017: Function generate-id with arity of 1 not registered. No similar functions found.
K2-FunctionCallExpr-1,Error: XPST0003: Unable to parse XPath: (         declare function local:bar($c, $d, $e, $f, $g, $h, $i, $j, $a, $b) { 1 };          declare function local:moo($k) { $k };          local:moo(1)) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-FunctionCallExpr-10,Error: XPST0003: Unable to parse XPath: (         declare variable $a := <a/>;          declare function local:testSingleNodeIdentity($node as node()) { $node is $node };          declare function local:testDoubleNodeIdentity($a as node(), $b as node()) { $a is $b };          local:testSingleNodeIdentity(<a/>), local:testDoubleNodeIdentity(<a/>, <b/>), local:testDoubleNodeIdentity($a, $a)       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
K2-FunctionCallExpr-11,Error: XPST0003: Unable to parse XPath: (         declare function local:compare($arg1 as xs:string, $arg2 as xs:string) {              let $cps1 := string-to-codepoints($arg1),              $cps2 := string-to-codepoints($arg2)              return abs(count($cps1) - count($cps2)) + sum(for $x in 1 to min((count($cps1), count($cps2)))                                                            return if ($cps1[$x] ne $cps2[$x]) then 1 else ()) };          local:compare("", ""),          local:compare("a", ""),          local:compare("", "a"),          local:compare("a", "a"),          local:compare("", "aa"),          local:compare("aa", "ab"),          local:compare("ba", "ba"),          local:compare("bab", "bbb"),          local:compare("aba", "bab")      )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-FunctionCallExpr-12,Error: XPST0003: Unable to parse XPath: (         declare function local:func1() { if(local:func2('b')) then 3 else local:func1() };          declare function local:func2($a) { if(matches("",$a)) then () else 4 };          local:func1()) = (3). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-FunctionCallExpr-13,Error: XPST0003: Unable to parse XPath: (declare function local:foo($arg) { local:foo(local:foo(1)) }; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-promotion-002,Error: XPST0003: Unable to parse XPath: (         declare function local:index-of($seq as xs:double*, $item as xs:double) { for $x at $p in $seq return if ($x eq $item) then $p else () };         declare function local:sequence($x as xs:integer) { ("string", 1, 2.0, xs:float(3))[$x] };         local:index-of(for $x in (2,3,4) return local:sequence($x), 2))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-promotion-003,Error: XPST0003: Unable to parse XPath: (         declare function local:index-of($seq as xs:integer*, $item as xs:integer?) as xs:float* {            if (empty($item))              then -1             else for $x at $p in $seq return if ($x eq $item) then $p else ()          };         local:index-of(1 to 10, 3))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-promotion-004,Error: XPST0003: Unable to parse XPath: (         declare function local:f() as xs:double* {            if (day-from-date(current-date()) < 32) then xs:integer(3) else -1         };         local:f() + 1)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-promotion-005,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare function local:index-of($seq, $item) as xs:double? { for $x at $p in $seq return if ($x eq $item) then $p else () };\n        local:index-of((1, 2.0, xs:float(3), 2), 2). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
cbcl-promotion-006,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare function local:f($arg as xs:anyAtomicType?) { $arg };\n        local:f(index-of((1,2,3,2),2)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
cbcl-promotion-007,Error: XPST0003: Unable to parse XPath: (         declare function local:f($v as xs:double*) as xs:double+ { if (empty($v)) then 0 else $v };         declare function local:g($v as xs:double*) as xs:double+ { local:f($v) };         local:g((1,2,3)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
function-call-reserved-function-names-014,Error: XPST0003: Unable to parse XPath:  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function local:function() { fn:true() }; 	function()       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
function-call-reserved-function-names-015,Error: XPST0003: Unable to parse XPath:  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function namespace-node($arg) { fn:true() }; 	namespace-node(1)       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
function-call-reserved-function-names-016,Error: XPST0003: Unable to parse XPath:  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function local:switch() { fn:true() }; 	switch()       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
function-call-reserved-function-names-033,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'XPST0003: Unable to parse XPath: \n\tfunction()\n      . SyntaxError: Expected " ", "(:", "\\n", "\\r", "\\t", "as", or "{" but end of input found.'
function-call-reserved-function-names-034,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'XPST0003: Unable to parse XPath: \n\tnamespace-node(1)\n      . SyntaxError: Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\\-.0-9-], [-], or end of input but "(" found.'
function-call-reserved-function-names-035,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'XPST0003: Unable to parse XPath: \n\tswitch()\n      . SyntaxError: Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\\-.0-9-], [-], or end of input but "(" found.'
function-call-reserved-function-names-039,Error: XPST0003: Unable to parse XPath:  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function local:array() { fn:true() }; 	array()       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
function-call-reserved-function-names-041,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'XPST0003: Unable to parse XPath: \n\tarray()\n      . SyntaxError: Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "{", "|", "||", [A-Z_a-z----------], [\\-.0-9-], [-], or end of input but "(" found.'
function-call-reserved-function-names-043,Error: XPST0003: Unable to parse XPath:  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function local:map() { fn:true() }; 	map()       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
function-call-reserved-function-names-045,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'XPST0003: Unable to parse XPath: \n\tmap()\n      . SyntaxError: Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "{", "|", "||", [A-Z_a-z----------], [\\-.0-9-], [-], or end of input but "(" found.'
function-declaration-001,Error: XPST0003: Unable to parse XPath: (         declare namespace foo = "http://www..oracle.com/xquery/test";         declare function foo:price ($b as element()) as element()* { $b/price };         1       ) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
function-declaration-002,Error: XPST0003: Unable to parse XPath:                  declare function local:foo($n as xs:integer) { <tr> {$n} </tr> };         local:foo(4)       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
function-declaration-003,Error: XPST0003: Unable to parse XPath:          declare function local:price ($i as element()) as element()? { $i/price };         for $j in /bib/book return local:price($j). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
function-declaration-004,Error: XPST0003: Unable to parse XPath:          declare function local:summary($emps as element(employee)*) as element(dept)* {              for $d in distinct-values($emps/deptno)              let $e := $emps[deptno = $d]              return <dept>                        <deptno>{$d}</deptno>                        <headcount> {count($e)} </headcount>                        <payroll> {sum($e/salary)} </payroll>                     </dept>          };         local:summary(//employee[location = "Denver"])       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
function-declaration-005,Error: XPST0003: Unable to parse XPath: (         declare function local:mysum($i as xs:integer, $j as xs:integer) { let $j := $i + $j return $j };         declare function local:invoke_mysum() { let $s := 1 for $d in (1,2,3,4,5) let $s := local:mysum($s, $d) return $s };         local:invoke_mysum())!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
function-declaration-006,Error: XPST0003: Unable to parse XPath: (         declare function local:mysum($i as xs:integer, $j as xs:integer) { let $j := $i + $j return $j };         declare function local:invoke_mysum($st as xs:integer) { for $d in (1,2,3,4,5) let $st := local:mysum($d, $st) return $st };         local:invoke_mysum(0))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
function-declaration-007,Error: XPST0003: Unable to parse XPath: (         declare variable $a := 1;         declare function local:foo($a as xs:integer) {              if ($a > 100) then $a else let $a := $a + 1 return local:foo($a) };         local:foo($a)) = (101). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
function-declaration-008,Error: XPST0003: Unable to parse XPath:          declare namespace my = "urn:foo";         declare function my:fact($n as xs:integer) as xs:integer { if ($n < 2) then 1 else $n * my:fact($n - 1) };         declare variable $my:ten := my:fact(10);         <table> { for $i in 1 to 10 return <tr> <td>10!/{$i}! = {$my:ten div my:fact($i)}</td> </tr> } </table>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
function-declaration-009,Error: XPST0003: Unable to parse XPath:                 declare function local:fact($n as xs:integer) as xs:integer { if ($n < 2) then 1 else $n * local:fact(($n)-1) };         <table> { for $i in 1 to 10 return <tr> <td>{$i}! = {local:fact($i)}</td> </tr> } </table>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
function-declaration-010,Error: XPST0003: Unable to parse XPath:                 declare function local:prnt($n as xs:integer,$n2 as xs:string, $n3 as xs:date, $n4 as xs:long, $n5 as xs:string, $n6 as xs:decimal) { if ($n < 2) then 1 else concat($n, " ",$n2," ",$n3," ",$n4," ",$n5," ",$n6) };         <table> { <td>Value is = {local:prnt(4,xs:string("hello"),xs:date("2005-02-22"), xs:long(5),xs:string("well"),xs:decimal(1.2))}</td> } </table>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
function-declaration-011,Error: XPST0003: Unable to parse XPath: (                declare function local:fn1 ($n as xs:integer) as xs:integer { local:fn2($n) };         declare function local:fn2 ($n as xs:integer) as xs:integer { if ($n = 1) then 1 else $n + local:fn1($n - 1) };         local:fn1(4)) = (10). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
function-declaration-012,Error: XPST0003: Unable to parse XPath: (                declare function local:fn1 ($n as xs:integer) as xs:integer { local:fn2($n) };         declare function local:fn2 ($n as xs:integer) as xs:integer { if ($n = 1) then 1 else $n + local:fn1($n - 1) };         local:fn1(4)) = (10). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
function-declaration-013,Error: XPST0003: Unable to parse XPath: (                declare function local:foo2($i as xs:string) as xs:string {local:foo($i)};         declare function local:foo($i as xs:string) as xs:string {$i};         local:foo2("abc"))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
function-declaration-014,Error: XPST0003: Unable to parse XPath:          declare function local:odd($x as xs:integer) as xs:boolean {if ($x = 0) then false() else local:even($x - 1)};         declare function local:even($x as xs:integer) as xs:boolean {if ($x = 0) then true() else local:odd($x - 1)};         local:even(4). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
function-declaration-015,Error: XPST0003: Unable to parse XPath:          declare function local:odd($x as xs:integer) as xs:boolean {if ($x = 0) then false() else local:even($x - 1)};         declare function local:even($x as xs:integer) as xs:boolean {if ($x = 0) then true() else local:odd($x - 1)};         local:even(3). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
function-declaration-016,Error: XPST0003: Unable to parse XPath:          declare function local:title($a_book as element()) { for $i in $a_book return $i/title };         /bib/book/(local:title(.)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
function-declaration-017,Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.example.com/filesystem";         declare variable $v as xs:integer := 100;         declare function local:udf1 ($CUSTNO as xs:integer) { <empty> {$CUSTNO*$v} </empty> };         local:udf1(10)       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
function-declaration-018,Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.example.com/filesystem";         declare function local:udf1 () { <empty> {10*10} </empty> };         local:udf1 ()       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
function-declaration-019,Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.example.com/def";         declare namespace test="http://www.example.com/test";         declare namespace test2="http://www.example.com/test2";         declare function test:udf1() { <empty> {10*10} </empty> };         declare function test2:udf1() { <empty/> };         <A> {test:udf1()} {test2:udf1()} </A>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
function-declaration-020,Error: XPST0003: Unable to parse XPath: (declare namespace foo = "http://www..oracle.com/xquery/test";         declare function foo:price () as xs:integer+ { 100 };         declare function foo:price ($z as xs:integer) as xs:integer+ { $z };         declare function foo:price ($x as xs:integer, $y as xs:integer) as xs:integer+ { $x, $y };         declare function foo:price ($x as xs:integer, $y as xs:integer, $z as xs:integer) as xs:integer+ { $x+$y+$z };         foo:price(), foo:price(1), foo:price(2,3), foo:price(4,5,6))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
function-declaration-021,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare function local:foo ($n as xs:integer) as xs:string { $n };\n        local:foo(4). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
function-declaration-022,AssertionError: expected [Function] to throw error including 'XQST0034' but got 'XPST0003: Unable to parse XPath: \n        declare function local:foo ($m as xs:integer) { $m };\n        declare function local:foo ($n as xs:integer) { $n };\n        local:foo(4). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
function-declaration-023,AssertionError: Expected executing the XPath "         declare function foo ($n as xs:integer) { $n };         foo(4)" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: \n        declare function foo ($n as xs:integer) { $n };\n        foo(4). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.', AssertionError: expected [Function] to throw error including 'XPST0017' but got 'XPST0003: Unable to parse XPath: \n        declare function foo ($n as xs:integer) { $n };\n        foo(4). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
function-declaration-024,AssertionError: expected [Function] to throw error including 'XQST0039' but got 'XPST0003: Unable to parse XPath: \n        declare function local:foo ($n as xs:integer, $n as xs:integer) { $n };\n        local:foo(4, 1). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
function-declaration-025,AssertionError: expected [Function] to throw error including 'XQST0060' but got 'XPST0003: Unable to parse XPath: declare default function namespace "";\n        declare function foo ($n as xs:integer, $m as xs:integer) { $n };\n        foo(4, 1). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'
function-declaration-026,Error: XPST0003: Unable to parse XPath:          declare variable $global := node();         declare function local:function() { exists($global) };         local:function(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
function-declaration-028,Error: XPST0003: Unable to parse XPath: (          declare function local:function() { };          local:function()) => empty(). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
function-declaration-029,Error: XPST0003: Unable to parse XPath: (          declare function local:function($x) { (:there is nothing here:) };          local:function(3)) => empty(). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
function-declaration-030,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n         declare function local:function($x as xs:integer) as xs:integer { (:there is nothing here:) };\n         local:function(3). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K-FunctionProlog-1,Error: XPST0003: Unable to parse XPath: declare namespace test = "http://www.w3.org/2005/xpath-datatypes";         declare function test:myFunction() { 1};         1 eq 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
K-FunctionProlog-2,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: \n        declare function wrongNS() { 1 };\n        1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K-FunctionProlog-3,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: \n        declare function xml:wrongNS() { 1 };\n        1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K-FunctionProlog-4,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: declare namespace my = "http://www.w3.org/2001/XMLSchema-instance";\n        declare function my:wrongNS() { 1 };\n        1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
K-FunctionProlog-5,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: declare namespace my = "http://www.w3.org/2001/XMLSchema";\n        declare function my:wrongNS() { 1 };\n        1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
K-FunctionProlog-10,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare function local:myFunction() as xs:double { "This is not a double, it\'s an xs:string." };\n        local:myFunction(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K-FunctionProlog-11,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare function local:myFunction() as item() { () };\n        local:myFunction(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K-FunctionProlog-12a,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'XPST0003: Unable to parse XPath: \n        declare function local:computeSum() { $myVariable };\n        declare variable $myVariable := 1;\n        1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K-FunctionProlog-12b,Error: XPST0003: Unable to parse XPath: (         declare function local:computeSum() { $myVariable };         declare variable $myVariable := 1;         1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K-FunctionProlog-14,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare function local:myFunction() as xs:integer { subsequence((1, 2, "a string"), 3 ,1) };\n        fn:boolean(local:myFunction()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K-FunctionProlog-15,AssertionError: Expected executing the XPath "         declare function local:myFunction() as xs:anyURI { 1 };         true()" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath:          declare function local:myFunction() as xs:anyURI { 1 };         true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare function local:myFunction() as xs:anyURI { 1 };\n        true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
K-FunctionProlog-18,Error: XPST0003: Unable to parse XPath: declare variable $var1 := 1;         declare function local:func1() as xs:integer { $var1 };         declare variable $var2 := 2;         declare function local:func2() as xs:integer { $var2 };         1 eq local:func1() and 2 eq local:func2(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K-FunctionProlog-19,Error: XPST0003: Unable to parse XPath: (         declare function local:func1($a1, $a2, $a3) { 1 };         local:func1(1, 2, 3)) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K-FunctionProlog-20,Error: XPST0003: Unable to parse XPath:          declare function local:func($choose, $whenTrue, $whenFalse) { if($choose) then $whenTrue else $whenFalse };         local:func(true(), current-time(), current-date()) instance of xs:time and local:func(false(), current-time(), current-date()) instance of xs:date. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
K-FunctionProlog-21,Error: XPST0003: Unable to parse XPath: (         declare function local:func($a as xs:integer, $unused, $c as xs:integer) { $a + $c };         local:func(1, 2, 3)) = (4). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K-FunctionProlog-22,Error: XPST0003: Unable to parse XPath: (         declare function local:func($unused, $b as xs:integer, $c as xs:integer) { $b + $c };         local:func(1, 2, 3)) = (5). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K-FunctionProlog-23,Error: XPST0003: Unable to parse XPath: (         declare function local:func($a as xs:integer, $b as xs:integer, $unused) { $a + $b };         local:func(1, 2, 3)) = (3). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K-FunctionProlog-24,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: \n        declare function wrongNS() { 1 };\n        1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K-FunctionProlog-25,Error: XPST0003: Unable to parse XPath: declare variable $local:myName := 1;         declare function local:myName() as xs:integer { 1 };         $local:myName eq local:myName(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K-FunctionProlog-26,AssertionError: expected [Function] to throw error including 'XQST0034' but got 'XPST0003: Unable to parse XPath: \n        declare function local:myName() { 1 };\n        declare function local:myName() { 1 };\n        1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K-FunctionProlog-27,AssertionError: expected [Function] to throw error including 'XQST0034' but got 'XPST0003: Unable to parse XPath: \n        declare function local:myName() as xs:integer { 1 };\n        declare function local:myName() as xs:nonPositiveInteger { 1 };\n        1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K-FunctionProlog-28,AssertionError: expected [Function] to throw error including 'XQST0034' but got 'XPST0003: Unable to parse XPath: \n        declare function local:myName($myvar as xs:integer) { 1 };\n        declare function local:myName($myvar as xs:nonPositiveInteger) { 1 };\n        1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K-FunctionProlog-29,AssertionError: expected [Function] to throw error including 'XQST0034' but got 'XPST0003: Unable to parse XPath: \n        declare function local:myName($myvar) { 1 };\n        declare function local:myName($myvar2) { 1 };\n        1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K-FunctionProlog-30,Error: XPST0003: Unable to parse XPath:          declare function local:myName($var as xs:integer) as xs:integer { $var };         declare function local:myName() as xs:integer { 1 };         (local:myName(4) - 3) eq local:myName(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
K-FunctionProlog-31,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: \n        declare function fn:count($var) { fn:count($var) };\n        1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K-FunctionProlog-32,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: \n        declare function xs:gYear($arg as xs:anyAtomicType?) as xs:gYear? { xs:gYear($arg) };\n        1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K-FunctionProlog-33,AssertionError: Expected executing the XPath "         declare function local:myFunction() { "a string" + 1 };         true()" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath:          declare function local:myFunction() { "a string" + 1 };         true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare function local:myFunction() { "a string" + 1 };\n        true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
K-FunctionProlog-34,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'XPST0003: Unable to parse XPath: \n        declare function local:MyFunction() { 1 };\n        local:myFunction(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K-FunctionProlog-35,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'XPST0003: Unable to parse XPath: \n        declare function local:MyFunction() { 1 };\n        local:myFunctionn(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K-FunctionProlog-36,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'XPST0003: Unable to parse XPath: \n        declare function local:MyFunction($myArg) { 0 };\n        $myArg. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K-FunctionProlog-37,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'XPST0003: Unable to parse XPath: \n        declare function local:MyFunction($myArg) { 0 };\n        declare function local:MyFunction2($myArg2) { $myArg };\n        1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K-FunctionProlog-38,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'XPST0003: Unable to parse XPath: \n        declare function local:MyFunction($myArg) { $myArg2 };\n        declare function local:MyFunction2($myArg2) { 0 };\n        1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K-FunctionProlog-39,Error: XPST0003: Unable to parse XPath: (declare variable $local:myVar := 1;         declare function local:myFunction($local:myVar) { $local:myVar };         $local:myVar, local:myFunction(2))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
K-FunctionProlog-40,Error: XPST0003: Unable to parse XPath:          declare function local:myFunction($local:myVar as xs:integer) { for $local:myVar in ($local:myVar, 3) return $local:myVar };         deep-equal(local:myFunction(1), (1, 3)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
K-FunctionProlog-41,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare function local:myFunction($local:myVar) { $local:myVar + 1 };\n        local:myFunction(1), local:myFunction("this will fail"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K-FunctionProlog-42,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare function local:myFunction($local:arg) as item() { 1, $local:arg };\n        local:myFunction(()), local:myFunction(1). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K-FunctionProlog-43,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare function local:myFunction($arg as item(), $arg2 as xs:integer) { $arg, $arg2 };\n        local:myFunction("3", "3"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K-FunctionProlog-44,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare function local:myFunction($arg as item(), $arg2 as xs:integer) { $arg, $arg2 };\n        local:myFunction("3", ()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K-FunctionProlog-45,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare function local:myFunction($arg as item()?, $arg2 as xs:integer) { $arg, $arg2 };\n        local:myFunction((), 4.1). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K-FunctionProlog-46,AssertionError: Expected executing the XPath "         declare function local:myFunction($arg as empty-sequence()) { $arg };         local:myFunction(1)" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare function local:myFunction($arg as empty-sequence()) { $arg };\n        local:myFunction(1). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.', AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: \n        declare function local:myFunction($arg as empty-sequence()) { $arg };\n        local:myFunction(1). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
K-FunctionProlog-49,AssertionError: Expected executing the XPath "         declare function local:myFunction($arg as empty-sequence()) { $arg };         empty(local:myFunction(()))" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath:          declare function local:myFunction($arg as empty-sequence()) { $arg };         empty(local:myFunction(())). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: \n        declare function local:myFunction($arg as empty-sequence()) { $arg };\n        empty(local:myFunction(())). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
K-FunctionProlog-50,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare function local:myFunction($arg) as empty-sequence() { $arg };\n        local:myFunction(1). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K-FunctionProlog-51,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'XPST0003: Unable to parse XPath: \n        declare function local:myFunction($arg) { $arg };\n        local:myFunction(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K-FunctionProlog-52,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0003: Unable to parse XPath: \n        declare function local:myFunction() as empty-sequence() { fn:error() };\n        local:myFunction(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K-FunctionProlog-53,AssertionError: Expected executing the XPath "declare namespace my = "http://example.com/MyNamespace/";         declare variable $my:error-qname := QName("http:example.org/", "prefix:ncname");         declare function my:error($choice, $msg as xs:string) as empty-sequence() { if($choice) then error($my:error-qname, concat('No luck: ', $msg)) else () };         empty((my:error(false(), "msg"), my:error(false(), "The message")))" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: declare namespace my = "http://example.com/MyNamespace/";         declare variable $my:error-qname := QName("http:example.org/", "prefix:ncname");         declare function my:error($choice, $msg as xs:string) as empty-sequence() { if($choice) then error($my:error-qname, concat('No luck: ', $msg)) else () };         empty((my:error(false(), "msg"), my:error(false(), "The message"))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: declare namespace my = "http://example.com/MyNamespace/";\n        declare variable $my:error-qname := QName("http:example.org/", "prefix:ncname");\n        declare function my:error($choice, $msg as xs:string) as empty-sequence() { if($choice) then error($my:error-qname, concat(\'No luck: \', $msg)) else () };\n        empty((my:error(false(), "msg"), my:error(false(), "The message"))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'.
K-FunctionProlog-56,AssertionError: Expected executing the XPath "declare namespace my = "http://example.com/MyNamespace/";         declare variable $my:error-qname := QName("http://example.com/MyErrorNS", "my:qName");         declare function my:error($choice, $msg as xs:string) as empty-sequence() { if($choice) then error($my:error-qname, concat('No luck: ', $msg)) else () };         empty((my:error(false(), "msg"), my:error(false(), "The message")))" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: declare namespace my = "http://example.com/MyNamespace/";         declare variable $my:error-qname := QName("http://example.com/MyErrorNS", "my:qName");         declare function my:error($choice, $msg as xs:string) as empty-sequence() { if($choice) then error($my:error-qname, concat('No luck: ', $msg)) else () };         empty((my:error(false(), "msg"), my:error(false(), "The message"))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: declare namespace my = "http://example.com/MyNamespace/";\n        declare variable $my:error-qname := QName("http://example.com/MyErrorNS", "my:qName");\n        declare function my:error($choice, $msg as xs:string) as empty-sequence() { if($choice) then error($my:error-qname, concat(\'No luck: \', $msg)) else () };\n        empty((my:error(false(), "msg"), my:error(false(), "The message"))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'.
K-FunctionProlog-57,AssertionError: expected [Function] to throw error including 'XPST0051' but got 'XPST0003: Unable to parse XPath: \n        declare function local:error() as none { 1 };\n        local:error(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K-FunctionProlog-59,AssertionError: Expected executing the XPath "         declare function local:myFunction($unusedArg) { true() };         local:myFunction(1 + "a string")" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath:          declare function local:myFunction($unusedArg) { true() };         local:myFunction(1 + "a string"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare function local:myFunction($unusedArg) { true() };\n        local:myFunction(1 + "a string"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
K-FunctionProlog-60,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'XPST0003: Unable to parse XPath: \n        declare function local:myFunction($arg) { 1 };\n        $arg. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K-FunctionProlog-61,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'XPST0003: Unable to parse XPath: \n        declare function local:myFunction($arg, $arg2, $arg3) { 1 };\n        $arg3. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K-FunctionProlog-62,Error: XPST0003: Unable to parse XPath: declare variable $my := 3;         declare function local:myFunction($my, $arg2, $arg4) { 1 };         $my eq 3. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K-FunctionProlog-64,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'XPST0003: Unable to parse XPath: declare namespace my = "http://example.com/ANamespace";\n        my:function(1). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
K-FunctionProlog-65,AssertionError: Expected executing the XPath "         declare function local:myFunction() as empty-sequence() { fn:error() };         QName("http://example.com/ANamespace", local:myFunction())" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare function local:myFunction() as empty-sequence() { fn:error() };\n        QName("http://example.com/ANamespace", local:myFunction()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.', AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0003: Unable to parse XPath: \n        declare function local:myFunction() as empty-sequence() { fn:error() };\n        QName("http://example.com/ANamespace", local:myFunction()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
K-FunctionProlog-66,AssertionError: Expected executing the XPath "         declare function local:myFunction() { fn:error() };         QName("http://example.com/ANamespace", local:myFunction())" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0003: Unable to parse XPath: \n        declare function local:myFunction() { fn:error() };\n        QName("http://example.com/ANamespace", local:myFunction()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.', AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare function local:myFunction() { fn:error() };\n        QName("http://example.com/ANamespace", local:myFunction()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
K-FunctionProlog-67,Error: XPST0003: Unable to parse XPath: declare default function namespace "http://www.w3.org/2005/xquery-local-functions";         declare function local:is() as xs:integer { 1 };         is() eq 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
K-FunctionProlog-68,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare function local:myFunction($usedArg) { $usedArg };\n        local:myFunction(1 + "a string"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K2-FunctionProlog-1,Error: XPST0003: Unable to parse XPath:          declare function local:myFunction($arg as xs:integer) as xs:integer { ((if($arg eq 1) then 1 else $arg - 1), current-time())[1] treat as xs:integer };         local:myFunction(1) eq local:myFunction(2). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
K2-FunctionProlog-2,Error: XPST0003: Unable to parse XPath:          declare function local:myFunction($arg as xs:integer) as xs:integer { ((if($arg eq 1) then 1 else $arg - 1), current-time())[1] treat as xs:integer };         not(local:myFunction(1) ne local:myFunction(2)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
K2-FunctionProlog-3,Error: XPST0003: Unable to parse XPath:          declare function local:myFunction($arg as xs:integer) as xs:integer { ((if($arg eq 1) then 1 else $arg - 1), current-time())[1] treat as xs:integer };         local:myFunction(1) = local:myFunction(2). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
K2-FunctionProlog-4,Error: XPST0003: Unable to parse XPath:          declare function local:myFunction($arg as xs:integer) as xs:integer { ((if($arg eq 1) then 1 else $arg - 1), current-time())[1] treat as xs:integer };         not(local:myFunction(1) != local:myFunction(2)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
K2-FunctionProlog-5,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare function local:myFunction($arg as xs:integer) { $arg };\n        local:myFunction(1.0). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K2-FunctionProlog-6,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare function local:myFunction() as xs:integer { 1.0 };\n        local:myFunction(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K2-FunctionProlog-7,Error: XPST0003: Unable to parse XPath:          declare function local:myFunction() as xs:float { 4.0 };         (current-time(), 1, 2, "a string", local:myFunction(), 4.0, xs:double("NaN"), current-date())[5] instance of xs:float       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
K2-FunctionProlog-8,Error: XPST0003: Unable to parse XPath:          declare function local:myFunction($arg as xs:integer) as xs:integer { if($arg eq 1) then $arg else local:myFunction3($arg - 1) };         declare function local:myFunction2($arg as xs:integer) as xs:integer { local:myFunction($arg) };         declare function local:myFunction3($arg as xs:integer) as xs:integer { local:myFunction2($arg) };         local:myFunction3(3) eq 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
K2-FunctionProlog-9,Error: XPST0003: Unable to parse XPath: (         declare function local:multiplySequence($input as xs:integer*) as xs:integer { if (empty($input)) then 1 else $input[1] * local:multiplySequence($input[position() != 1]) };         local:multiplySequence((1, 2, 3, 4, 5))) = (120). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-FunctionProlog-10,Error: XPST0003: Unable to parse XPath: (declare default function namespace "http://example.com";         declare function _() { 1 };         _()) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found.
K2-FunctionProlog-11,Error: XPST0003: Unable to parse XPath: (         declare function local:_() { 1 };         local:_()) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-FunctionProlog-12,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare function local:_($arg as node()) { $arg };\n        local:_(1). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K2-FunctionProlog-13,AssertionError: Expected executing the XPath "         declare function local:_($arg as attribute()?) { 1 };         local:_(1)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (         declare function local:_($arg as attribute()?) { 1 };         local:_(1)) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare function local:_($arg as attribute()?) { 1 };\n        local:_(1). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
K2-FunctionProlog-14,AssertionError: Expected executing the XPath "       declare function local:myFunc() { e };         <e/>/local:myFunc()/1" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath:        declare function local:myFunc() { e };\n        <e/>/local:myFunc()/1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.', AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath:        declare function local:myFunc() { e };\n        <e/>/local:myFunc()/1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
K2-FunctionProlog-15,Error: XPST0003: Unable to parse XPath: declare variable $var1 := let $var1 := 1 return 1;         $var1 eq 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-FunctionProlog-16,AssertionError: Expected executing the XPath "         declare function local:myFunction() as item()* {***};         1" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (         declare function local:myFunction() as item()* {***};         1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found., AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: \n        declare function local:myFunction() as item()* {***};\n        1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
K2-FunctionProlog-17,Error: XPST0003: Unable to parse XPath: (       declare function local:func() as xs:integer { <e>1</e> };         local:func()) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-FunctionProlog-18,Error: XPST0003: Unable to parse XPath: (         declare function local:func() as xs:integer { attribute name {"1"} };         local:func()) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-FunctionProlog-19,Error: XPST0003: Unable to parse XPath: (         declare function local:func() as xs:integer { document {"1"} };         local:func()) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-FunctionProlog-20,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath:        declare function local:func() as xs:integer { <!--1--> };\n        local:func(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K2-FunctionProlog-21,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath:        declare function local:func() as xs:integer { <?target 1?> };\n        local:func(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K2-FunctionProlog-22,Error: XPST0003: Unable to parse XPath: (         declare function local:func() as xs:integer? { text {"1"} };         local:func()) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-FunctionProlog-23,Error: XPST0003: Unable to parse XPath: (         declare function local:recursiveFunction($i as xs:integer) as xs:integer { if($i eq 5) then $i else local:recursiveFunction($i + 1) };         declare function local:proxy() as xs:integer { local:recursiveFunction(0) + 3 };         local:proxy()) = (8). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-FunctionProlog-24,AssertionError: expected [Function] to throw error including 'FORG0001' but got 'XPST0003: Unable to parse XPath:        declare function local:distinct-nodes-stable ($arg as node()*) as xs:boolean* { for $a in $arg return $a };\n        local:distinct-nodes-stable((<element1/>,<element2/>)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K2-FunctionProlog-25,Error: XPST0003: Unable to parse XPath:        declare function local:myFunc($recurse as xs:integer) { attribute {concat("name", $recurse)} {()} , if ($recurse = 0) then () else local:myFunc($recurse - 1) };         <e> { local:myFunc((2, current-time())[1] treat as xs:integer) } </e>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
K2-FunctionProlog-26,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath:        declare function local:myFunc() as element(foo) { <bar/> };\n        local:myFunc(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K2-FunctionProlog-27,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath:        declare function local:myFunc() as attribute(foo) { <foo/> };\n        local:myFunc(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K2-FunctionProlog-28,Error: XPST0003: Unable to parse XPath: (         declare function local:levenshtein($arg1 as xs:string, $arg2 as xs:string) as xs:decimal { if(string-length($arg1) = 0) then string-length($arg2) else if(string-length($arg2) = 0) then string-length($arg1) else min((local:levenshtein(substring($arg1, 2), $arg2) + 1, local:levenshtein($arg1, substring($arg2, 2)) + 1, local:levenshtein(substring($arg1, 2), substring($arg2, 2)) + (if(substring($arg1, 1, 1) = substring($arg2, 1, 1)) then 0 else 1))) };         local:levenshtein("a", "a"), local:levenshtein("aa", "aa"), local:levenshtein("aaa", "aaa"), local:levenshtein("aa a", "aa a"), local:levenshtein("a a a", "aaa"), local:levenshtein("aaa", "a a a"), local:levenshtein("aaa", "aaab"), local:levenshtein("978", "abc"))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-FunctionProlog-30,AssertionError: Expected executing the XPath "       declare function local:foo($arg) as xs:boolean { $arg };         local:foo(<e/>)" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FORG0001' but got 'XPST0003: Unable to parse XPath:        declare function local:foo($arg) as xs:boolean { $arg };\n        local:foo(<e/>). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.', AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath:        declare function local:foo($arg) as xs:boolean { $arg };\n        local:foo(<e/>). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
K2-FunctionProlog-31,Error: XPST0003: Unable to parse XPath: (       declare function local:foo($arg) as xs:boolean* { $arg };         local:foo((<e>true</e>, true(), xs:untypedAtomic("false"), false(), <e> true </e>)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-FunctionProlog-32,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare function local:foo($arg ) as xs:boolean* { $arg };\n        local:foo(current-date()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K2-FunctionProlog-33,Error: XPST0003: Unable to parse XPath: (       declare function local:foo($arg ) as xs:boolean* { $arg };         local:foo((<e>true</e>, true(), xs:untypedAtomic("false"), false(), <e> true </e>)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-FunctionProlog-34,Error: XPST0003: Unable to parse XPath: (         declare function local:foo($arg) as xs:boolean* { $arg };         local:foo((true(), xs:untypedAtomic("false"))), local:foo((false(), xs:untypedAtomic("false"))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-FunctionProlog-35,Error: XPST0003: Unable to parse XPath:          declare function local:foo($arg) as xs:boolean* { $arg };         local:foo(xs:untypedAtomic("false")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
K2-FunctionProlog-36,Error: XPST0003: Unable to parse XPath:          declare function local:foo($arg) as xs:boolean { $arg };         local:foo(xs:untypedAtomic("false")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
K2-FunctionProlog-37,Error: XPST0003: Unable to parse XPath: (       declare function local:foo($arg ) as xs:boolean* { $arg };         local:foo((<e>true</e>, true(), xs:untypedAtomic("false"), false(), <e> true </e>)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-FunctionProlog-38,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'XPST0003: Unable to parse XPath: \n        declare function local:foo() as xs:boolean { text {local:doesNotExist()} };\n        1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K2-FunctionProlog-39,Error: XPST0003: Unable to parse XPath: (         declare variable $A:=(<A>{local:functionA()}</A>);         declare function local:functionA() as element() { <input>testing ...</input> };         declare function local:functionB ( ) as xs:string { xs:string($A) };         local:functionB())!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
K2-FunctionProlog-40,Error: XPST0003: Unable to parse XPath: (         declare variable $A:=(<A>{local:functionA()}</A>);         declare function local:functionA() as element() { <input>testing ...</input> };         declare function local:functionB ( ) as xs:string { $A };         local:functionB())!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
cbcl-function-decl-001,Error: XPST0003: Unable to parse XPath: declare function local:nothing() as empty-sequence() { () }; empty(local:nothing()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-function-declaration-002,Error: XPST0003: Unable to parse XPath: (declare function local:count($x) { count($x) }; local:count((1 to 100000, 1 to 100000)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
function-decl-reserved-function-names-001,Error: XPST0003: Unable to parse XPath:  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function attribute() { fn:true() }; 	local:attribute()       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
function-decl-reserved-function-names-003,Error: XPST0003: Unable to parse XPath:  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function comment() { fn:true() }; 	local:comment()       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
function-decl-reserved-function-names-005,Error: XPST0003: Unable to parse XPath:  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function document-node() { fn:true() }; 	local:document-node()       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
function-decl-reserved-function-names-007,Error: XPST0003: Unable to parse XPath:  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function element() { fn:true() }; 	local:element()       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
function-decl-reserved-function-names-009,Error: XPST0003: Unable to parse XPath:  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function empty-sequence() { fn:true() }; 	local:empty-sequence()       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
function-decl-reserved-function-names-011,Error: XPST0003: Unable to parse XPath:  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function function() { fn:true() }; 	local:function()       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
function-decl-reserved-function-names-013,Error: XPST0003: Unable to parse XPath:  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function if() { fn:true() }; 	local:if()       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
function-decl-reserved-function-names-015,Error: XPST0003: Unable to parse XPath:  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function item() { fn:true() }; 	local:item()       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
function-decl-reserved-function-names-017,Error: XPST0003: Unable to parse XPath:  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function namespace-node() { fn:true() }; 	local:namespace-node()       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
function-decl-reserved-function-names-019,Error: XPST0003: Unable to parse XPath:  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function node() { fn:true() }; 	local:node()       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
function-decl-reserved-function-names-021,Error: XPST0003: Unable to parse XPath:  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function processing-instruction() { fn:true() }; 	local:processing-instruction()       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
function-decl-reserved-function-names-023,Error: XPST0003: Unable to parse XPath:  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function schema-attribute() { fn:true() }; 	local:schema-attribute()       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
function-decl-reserved-function-names-025,Error: XPST0003: Unable to parse XPath:  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function schema-element() { fn:true() }; 	local:schema-element()       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
function-decl-reserved-function-names-027,Error: XPST0003: Unable to parse XPath:  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function switch() { fn:true() }; 	local:switch()       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
function-decl-reserved-function-names-029,Error: XPST0003: Unable to parse XPath:  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function text() { fn:true() }; 	local:text()       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
function-decl-reserved-function-names-031,Error: XPST0003: Unable to parse XPath:  	declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; 	declare function typeswitch() { fn:true() }; 	local:typeswitch()       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
K-GenCompEq-16,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'
K-GenCompEq-17,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'
K-GenCompEq-18,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'
K-GenCompEq-19,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'
K-GenCompEq-20,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-GenCompEq-21,Error: XPST0017: Function timezone-from-time with arity of 1 not registered. No similar functions found.
K-GenCompEq-22,Error: XPST0017: Function timezone-from-time with arity of 1 not registered. No similar functions found.
K-GenCompEq-54,AssertionError: expected [Function] to throw an error
K2-GenCompEq-1,Error: XPST0003: Unable to parse XPath:           declare variable $vA as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string;           declare variable $vB as xs:string := ("b string", current-time(), string(<e>content</e>))[1] treat as xs:string;           (lower-case($vA) = lower-case($vB))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-GenCompEq-2,Error: XPST0003: Unable to parse XPath:           declare variable $vA as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string;           declare variable $vB as xs:string := ("b string", current-time(), string(<e>content</e>))[1] treat as xs:string;           (upper-case($vA) = upper-case($vB))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-GenCompEq-3,Error: XPST0003: Unable to parse XPath:           declare variable $vA as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string;           declare variable $vB as xs:string := ("no match", current-time(), string(<e>content</e>))[1] treat as xs:string;           (lower-case($vA) = lower-case($vB))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-GenCompEq-4,Error: XPST0003: Unable to parse XPath:           declare variable $vA as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string;           declare variable $vB as xs:string := ("no match", current-time(), string(<e>content</e>))[1] treat as xs:string;           (upper-case($vA) = upper-case($vB))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-GenCompEq-5,Error: XPST0003: Unable to parse XPath:           declare variable $vA as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string;           declare variable $vB as xs:string := ("b string", current-time(), string(<e>content</e>))[1] treat as xs:string;           (upper-case($vA) = lower-case($vB))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-GenCompEq-6,Error: XPST0003: Unable to parse XPath:           declare variable $vA as xs:string := ("B STRING", current-time(), string(<e>content</e>))[1] treat as xs:string;           declare variable $vB as xs:string := ("b string", current-time(), string(<e>content</e>))[1] treat as xs:string;           (lower-case($vA) = upper-case($vB))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-GenCompEq-7,AssertionError: Expected executing the XPath "let $x := codepoints-to-string(12) return ($x = $x)" to resolve to one of the expected results, but got Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found., AssertionError: expected [Function] to throw error including 'FOCH0001' but got 'XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.'.
K2-GenCompEq-8,AssertionError: Expected executing the XPath "empty(for $b in <e/> where $b/@id="person0" return ())" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: empty(for $b in <e/> where $b/@id="person0" return ()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: empty(for $b in <e/> where $b/@id="person0" return ()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.'.
GenCompEq-3,AssertionError: Expected XPath xs:dayTimeDuration("P3DT08H34M12.143S") = xs:untypedAtomic("P3DT08H34M12.143S") to resolve to true: expected false to be true
GenCompEq-5,AssertionError: Expected XPath xs:untypedAtomic("P1999Y10M") = xs:yearMonthDuration("P1999Y10M") to resolve to true: expected false to be true
GenCompEq-7,Error: Atomizing array(*) is not implemented.
GenCompEq-8,Error: Atomizing array(*) is not implemented.
GenCompEq-9,Error: Atomizing array(*) is not implemented.
GenCompEq-10,Error: XPST0003: Unable to parse XPath: declare variable $p external := 276; $p = (1 to 1000). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
GenCompEq-11,Error: XPST0003: Unable to parse XPath: declare variable $p external := -276; (1 to 1000) = $p. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
GenCompEq-12,Error: XPST0003: Unable to parse XPath: declare variable $p external := xs:untypedAtomic('000504e0'); $p = (1 to 1000). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
GenCompEq-13,Error: XPST0003: Unable to parse XPath: declare variable $p external := xs:untypedAtomic('4.5'); (1 to 1000) = $p. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
GenCompEq-14,Error: XPST0003: Unable to parse XPath: declare variable $p external := 17; $p = (1, 8, 13, 14, 98, -22, 0, 17, 34, 87, 99, 54, 22, 33, 44, 55, 66, 77). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
GenCompEq-15,Error: XPST0003: Unable to parse XPath: declare variable $p external := -101; (1, 8, 13, 14, 98, -22, 0, 17, 34, 87, 99, 54, 22, 33, 44, 55, 66, 77) = $p. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
GenCompEq-16,Error: XPST0003: Unable to parse XPath: declare variable $p external := xs:untypedAtomic('-840'); $p = (1, 8, 13, 14, 98, -22, 0, 17, 34, 87, 99, 54, 22, 33, 44, 55, 66, 77). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
GenCompEq-17,Error: XPST0003: Unable to parse XPath: declare variable $p external := xs:untypedAtomic('-022e0'); (1, 8, 13, 14, 98, -22, 0, 17, 34, 87, 99, 54, 22, 33, 44, 55, 66, 77) = $p. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
GenCompEq-18,Error: XPST0003: Unable to parse XPath: declare variable $p external := (105, 22e0); $p = (1, 8, 13, 14, 98, -22, 0, 17, 34, 87, 99, 54, 22, 33, 44, 55, 66, 77). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
GenCompEq-19,Error: XPST0003: Unable to parse XPath: declare variable $p external := (105, xs:untypedAtomic('22e0')); (1, 8, 13, 14, 98, -22, 0, 17, 34, 87, 99, 54, 22, 33, 44, 55, 66, 77) = $p. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
GenCompEq-20,Error: XPST0003: Unable to parse XPath: declare variable $p external := xs:untypedAtomic('000504e0'); $p = (1 to xs:integer(xs:double($p))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
GenCompEq-21,Error: XPST0003: Unable to parse XPath: declare variable $p external := xs:untypedAtomic('860302'); (1 to xs:integer($p)) = $p. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
GenCompEq-22,Error: XPST0003: Unable to parse XPath:          declare namespace z = "http://example.com/z";         declare variable $p external := xs:untypedAtomic('z:local');          $p = (<xs:element/>, <z:local/>, <fn:function/>)!node-name(.)        . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
GenCompEq-23,Error: XPST0003: Unable to parse XPath:          declare variable $p external := (1 to 10, xs:untypedAtomic('860302'), 83);          $p = (35 to 65, xs:untypedAtomic('082'), xs:untypedAtomic('0010')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K-GenCompGTEQ-5,Error: XPST0017: Function timezone-from-time with arity of 1 not registered. No similar functions found.
K-GenCompGTEQ-10,Error: XPST0017: Function timezone-from-time with arity of 1 not registered. No similar functions found.
K-GenCompGT-18,Error: XPST0017: Function timezone-from-time with arity of 1 not registered. No similar functions found.
K-GenCompGT-19,Error: XPST0017: Function timezone-from-time with arity of 1 not registered. No similar functions found.
K-GenCompLT-18,Error: XPST0017: Function timezone-from-time with arity of 1 not registered. No similar functions found.
K-GenCompLT-19,Error: XPST0017: Function timezone-from-time with arity of 1 not registered. No similar functions found.
GenCompLT-9,Error: Atomizing array(*) is not implemented.
GenCompLT-10,Error: Atomizing array(*) is not implemented.
GenCompLT-11,Error: Atomizing array(*) is not implemented.
K-GenCompNE-13,Error: XPST0017: Function timezone-from-time with arity of 1 not registered. No similar functions found.
K-GenCompNE-35,AssertionError: expected [Function] to throw an error
CondExpr017,Error: XPST0017: Function data with arity of 1 not registered. No similar functions found.
CondExpr018,Error: XPST0017: Function data with arity of 1 not registered. No similar functions found.
CondExpr20,Error: XPST0003: Unable to parse XPath: (if( false() ) then /Folder[1] cast as xs:double ? else 10 cast as xs:double ?) = (10). SyntaxError: Expected " ", "!=", "(:", "*", "+", "-", "<", "<<", "<=", "=", ">", ">=", ">>", "\n", "\r", "\t", "and", "castable", "div", "else", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "?" found.
CondExpr21,Error: XPST0003: Unable to parse XPath: (if( true() ) then 10 cast as xs:double ? else /Folder[1] cast as xs:double ?) = (10). SyntaxError: Expected " ", "!=", "(:", "*", "+", "-", "<", "<<", "<=", "=", ">", ">=", ">>", "\n", "\r", "\t", "and", "castable", "div", "else", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "?" found.
CondExpr022,Error: XPST0017: Function doc-available with arity of 1 not registered. No similar functions found.
K-CondExpr-3,Error: XPST0003: Unable to parse XPath: (if((1, current-time())[1] treat as xs:integer) then true() else false()) eq true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.
K-CondExpr-4,Error: XPST0003: Unable to parse XPath: (if(boolean((1, current-time())[1] treat as xs:integer)) then true() else false()) eq true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.
K-CondExpr-5,Error: XPST0017: Function hours-from-time with arity of 1 not registered. No similar functions found.
K-CondExpr-6,Error: XPST0003: Unable to parse XPath: string(if(boolean((1, current-time())[1] treat as xs:integer)) then true() else false()) eq "true". SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.
K-CondExpr-7,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'XPST0017: Function current-time with arity of 0 not registered. No similar functions found.'
K-CondExpr-10,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-CondExpr-11,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-CondExpr-12,Error: XPST0003: Unable to parse XPath: if(boolean((1, 2, 3, current-time())[1] treat as xs:integer)) then true() else 4. SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.
K2-CondExpr-1,AssertionError: Expected executing the XPath "empty(if(<e>{current-time()}</e>) then () else ())" to resolve to one of the expected results, but got Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0017: Function current-time with arity of 0 not registered. No similar functions found.'.
K2-CondExpr-2,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K2-CondExpr-3,Error: XPST0003: Unable to parse XPath: (declare default function namespace "http://www.example.com/"; declare function unordered() { 1 }; unordered()) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found.
instanceof111,AssertionError: expected [Function] to throw an error
instanceof121,Error: No selector counterpart for: anyFunctionTest.
instanceof122,Error: No selector counterpart for: functionTest.
instanceof123,Error: No selector counterpart for: functionTest.
instanceof124,Error: No selector counterpart for: functionTest.
instanceof125,Error: No selector counterpart for: functionTest.
instanceof126,Error: No selector counterpart for: functionTest.
instanceof127,Error: No selector counterpart for: functionTest.
instanceof128,Error: No selector counterpart for: functionTest.
instanceof129,Error: No selector counterpart for: functionTest.
instanceof130,Error: No selector counterpart for: functionTest.
instanceof131,Error: No selector counterpart for: functionTest.
instanceof132,Error: No selector counterpart for: functionTest.
instanceof133,Error: No selector counterpart for: functionTest.
instanceof134,Error: No selector counterpart for: functionTest.
K-SeqExprInstanceOf-37,Error: No selector counterpart for: e.
K-SeqExprInstanceOf-38,Error: No selector counterpart for: e.
K-SeqExprInstanceOf-39,Error: No selector counterpart for: e.
K-SeqExprInstanceOf-40,Error: No selector counterpart for: e.
K-SeqExprInstanceOf-41,Error: No selector counterpart for: e.
K-SeqExprInstanceOf-42,Error: No selector counterpart for: e.
K-SeqExprInstanceOf-52,AssertionError: expected [Function] to throw error including 'XPST0051' but got 'XPST0081: The type none does not exist.'
K-SeqExprInstanceOf-53,AssertionError: expected [Function] to throw error including 'XPST0051' but got 'XPST0081: The type void does not exist.'
K-SeqExprInstanceOf-56,AssertionError: Expected executing the XPath "error() instance of xs:integer" to resolve to one of the expected results, but got Error: XPST0017: Function error with arity of 0 not registered. No similar functions found., AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'.
K-SeqExprInstanceOf-57,AssertionError: Expected executing the XPath "error() instance of xs:integer*" to resolve to one of the expected results, but got Error: XPST0017: Function error with arity of 0 not registered. No similar functions found., AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'.
K-SeqExprInstanceOf-58,AssertionError: Expected executing the XPath "error() instance of empty-sequence()" to resolve to one of the expected results, but got Error: XPST0017: Function error with arity of 0 not registered. No similar functions found., AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'.
K-SeqExprInstanceOf-59,AssertionError: Expected executing the XPath "(error(), 1) instance of empty-sequence()" to resolve to one of the expected results, but got Error: XPST0017: Function error with arity of 0 not registered. No similar functions found., AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'.
K-SeqExprInstanceOf-60,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'
K-SeqExprInstanceOf-61,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'
K-SeqExprInstanceOf-62,AssertionError: Expected executing the XPath "(1, error()) instance of xs:integer*" to resolve to one of the expected results, but got Error: XPST0017: Function error with arity of 0 not registered. No similar functions found., AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'.
K-SeqExprInstanceOf-63,AssertionError: Expected executing the XPath "(error(), 1) instance of xs:integer*" to resolve to one of the expected results, but got Error: XPST0017: Function error with arity of 0 not registered. No similar functions found., AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'.
K-SeqExprInstanceOf-66,AssertionError: Expected XPath ((10)mod(3)) instance of xs:integer to resolve to true: expected false to be true
K2-SeqExprInstanceOf-8,Error: XPST0003: Unable to parse XPath: attribute e{"content"} instance of attribute(e). SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.
K2-SeqExprInstanceOf-9,Error: XPST0003: Unable to parse XPath: attribute e{"content"} instance of attribute(). SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.
K2-SeqExprInstanceOf-10,Error: XPST0003: Unable to parse XPath: attribute e{"content"} instance of attribute(*). SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.
K2-SeqExprInstanceOf-11,Error: XPST0003: Unable to parse XPath: attribute e{"content"} instance of element(e). SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.
K2-SeqExprInstanceOf-12,Error: XPST0003: Unable to parse XPath: attribute e{"content"} instance of element(). SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.
K2-SeqExprInstanceOf-13,Error: XPST0003: Unable to parse XPath: attribute e{"content"} instance of element(*). SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.
K2-SeqExprInstanceOf-14,Error: XPST0003: Unable to parse XPath: attribute e{"content"} instance of attribute(name). SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.
K2-SeqExprInstanceOf-98,Error: XPST0003: Unable to parse XPath: node-name(text {""}) instance of empty-sequence(). SyntaxError: Expected "!", "!=", "(", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
K2-SeqExprInstanceOf-99,AssertionError: <e attr=""/>/(@attr instance of attribute(), @* instance of attribute()): expected 'true' to equal 'true true'
K2-SeqExprInstanceOf-100,AssertionError: <a><b/></a>/(b instance of element(), * instance of element()): expected 'true' to equal 'true true'
cbcl-instance-of-001,AssertionError:          for $x in (xs:integer(1), xs:decimal(1)) return (((($x + 1) * 2) - 1) instance of xs:integer)       : expected 'false false' to equal 'true false'
letexprwith-1,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: let $salary as xs:decimal := "cat" return $salary * 2. SyntaxError: Expected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.'
letexprwith-2,Error: XPST0003: Unable to parse XPath: (let $var as xs:decimal := 100 return $var) = (100). SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.
letexprwith-3,Error: XPST0003: Unable to parse XPath: (let $var as xs:integer := 100 return $var) = (100). SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.
letexprwith-4,Error: XPST0003: Unable to parse XPath: (let $var as xs:double := 100E1 return $var) = (1000). SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.
letexprwith-5,Error: XPST0003: Unable to parse XPath: (let $var as xs:string := "A String" return $var)!string() => string-join(" "). SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.
letexprwith-6,Error: XPST0003: Unable to parse XPath: let $var as xs:boolean := fn:true() return $var. SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.
letexprwith-7,Error: XPST0003: Unable to parse XPath: let $var as xs:boolean := fn:false() return $var. SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.
letexprwith-8,Error: XPST0003: Unable to parse XPath: (let $var as xs:date := xs:date("1999-05-31Z") return $var)!string() => string-join(" "). SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.
letexprwith-9,Error: XPST0003: Unable to parse XPath: (let $var as xs:time := xs:time("21:23:00Z") return $var)!string() => string-join(" "). SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.
letexprwith-10,Error: XPST0003: Unable to parse XPath: (let $var as xs:dateTime := xs:dateTime("1999-05-31T13:20:00Z") return $var)!string() => string-join(" "). SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.
letexprwith-11,Error: XPST0003: Unable to parse XPath: (let $var as xs:float := xs:float(100) return $var) = (100). SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.
letexprwith-12,Error: XPST0003: Unable to parse XPath: (let $var as xs:integer := 100+200 return $var) = (300). SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.
letexprwith-13,Error: XPST0003: Unable to parse XPath: (let $var as xs:integer := fn:count((100,200)) return $var) = (2). SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.
letexprwith-14,Error: XPST0003: Unable to parse XPath: let $var as xs:boolean := fn:not(fn:true()) return $var. SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.
letexprwith-15,Error: XPST0003: Unable to parse XPath: let $var as xs:boolean := fn:true() and fn:true() return $var. SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.
letexprwith-16,Error: XPST0003: Unable to parse XPath: let $var as xs:boolean := fn:true() and fn:true() return $var. SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.
letexprwith-17,Error: XPST0003: Unable to parse XPath: (let $var as xs:integer := fn:string-length("A String") return $var) = (8). SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.
letexprwith-18,Error: XPST0003: Unable to parse XPath: (let $var as xs:string := xs:string((xs:integer(100))) return $var)!string() => string-join(" "). SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.
letexprwith-19,Error: XPST0003: Unable to parse XPath: (let $var as xs:string := xs:string((xs:decimal(100))) return $var)!string() => string-join(" "). SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.
letexprwith-20,Error: XPST0003: Unable to parse XPath: (let $var as xs:string := xs:string((xs:double(100E2))) return $var)!string() => string-join(" "). SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.
letexprwith-21,Error: XPST0003: Unable to parse XPath: (let $var as xs:string := xs:string(fn:true()) return $var)!string() => string-join(" "). SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.
letexprwith-22,Error: XPST0003: Unable to parse XPath: (let $var as xs:integer := 100 return $var + 1) = (101). SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.
letexprwith-23,Error: XPST0003: Unable to parse XPath: let $var as xs:boolean := if (fn:true()) then fn:true() else fn:false() return $var. SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.
letexprwith-24,Error: XPST0003: Unable to parse XPath: (let $var as xs:string := typeswitch(fn:true()) case $i as xs:boolean return "Test Passed" default return "Test failed" return $var)!string() => string-join(" "). SyntaxError: Expected " ", "(:", ":=", "\n", "\r", or "\t" but "a" found.
LetExpr004,Error: FOCA0003: can not cast 92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
LetExpr005,Error: FOCA0003: can not cast -92233720368547758 to xs:integer, it is out of bounds for JavaScript numbers.
LetExpr019,Error: XPST0003: Unable to parse XPath: let $a := <elem/> let $b := <elem2/> return ($a,$b). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
LetExpr020,Error: XPST0003: Unable to parse XPath: (let $a := 1 let $b := $a let $c := $a+$b return ($c)) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
K-LetExprWithout-4,Error: XPST0003: Unable to parse XPath:          declare variable $i := false();          declare variable $t := false();          deep-equal((let $i := true(), $t := true() return ($i, $t)), (true(), true())). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-LetExprWithout-1,Error: XPST0003: Unable to parse XPath: deep-equal((<b/>, <b/>, <b/>, <b/>), (for $v1 in (1, 2, 3, 4) let $v2 := <b/> return ($v2))/.). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
K2-LetExprWithout-2,Error: XPST0003: Unable to parse XPath: deep-equal((<b/>, <b/>, <b/>, <b/>), (for $v1 in (1, 2, 3, 4) let $v2 := <b/> return ($v2))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
K2-LetExprWithout-3,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: declare function local:myFunc() { let $v := . return $v }; local:myFunc(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K2-LetExprWithout-4,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: declare function local:myFunc($arg as node()) { let $v := . return $arg/$v }; local:myFunc(<e/>). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K2-LetExprWithout-5,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: declare function local:myFunc($arg as node()) { let $v := aNameTest return $arg/$v }; local:myFunc(<e/>). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K2-LetExprWithout-6,AssertionError: Expected executing the XPath "declare function local:myFunc($arg as node()) { let $v := aNameTest return $arg/$v }; 1" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare function local:myFunc($arg as node()) { let $v := aNameTest return $arg/$v }; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found., AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: declare function local:myFunc($arg as node()) { let $v := aNameTest return $arg/$v }; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
K2-LetExprWithout-7,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: let $i as xs:integer := xs:untypedAtomic("1") return $i. SyntaxError: Expected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.'
K2-LetExprWithout-9,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: let $i as xs:float := 1.1 return $i. SyntaxError: Expected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.'
K2-LetExprWithout-10,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: let $i as xs:double := 1.1 return $i. SyntaxError: Expected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.'
K2-LetExprWithout-11,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: let $i as xs:float := 1 return $i. SyntaxError: Expected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.'
K2-LetExprWithout-12,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: let $i as xs:double := 1 return $i. SyntaxError: Expected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.'
K2-LetExprWithout-13,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: let $i as xs:double := xs:float(3) return $i. SyntaxError: Expected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.'
K2-LetExprWithout-14,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: let $i as xs:string := xs:untypedAtomic("a string") return $i. SyntaxError: Expected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.'
K2-LetExprWithout-15,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: let $i as xs:string := xs:anyURI("http://www.example.com/") return $i. SyntaxError: Expected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.'
K2-LetExprWithout-16,Error: XPST0003: Unable to parse XPath: (declare variable $e := <e/>; for $i in (<a/>, $e, <c/>) return $i is $e)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
K2-LetExprWithout-17,AssertionError: Expected executing the XPath "declare function local:function() { let $b := (i/a) return () }; empty(local:function())" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: declare function local:function() { let $b := (i/a) return () }; empty(local:function()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found., AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: declare function local:function() { let $b := (i/a) return () }; empty(local:function()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.', AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: declare function local:function() { let $b := (i/a) return () }; empty(local:function()). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
K2-LetExprWithout-18,Error: XPST0003: Unable to parse XPath: (declare function local:foo($a as xs:integer) { if($a = 3) then $a else let $a := $a return local:foo($a + 1) }; local:foo(1)) = (3). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
K2-LetExprWithout-20,Error: XPST0003: Unable to parse XPath:          let $emps := //employee[location = "Denver"]          for $d in distinct-values($emps/deptno)          let $e := $emps[deptno = $d]          return <dept> <deptno>{$d}</deptno> <headcount> {count($e)} </headcount> <payroll> {sum($e/salary)} </payroll> </dept>       . SyntaxError: Expected " ", "!", "!=", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found.
K2-LetExprWithout-23,Error: XPST0017: Function data with arity of 1 not registered. No similar functions found.
K2-LetExprWithout-24,AssertionError: Expected executing the XPath "declare function local:function() { let $b := (i/a) return 1 }; local:function()" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare function local:function() { let $b := (i/a) return 1 }; local:function()) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found., AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: declare function local:function() { let $b := (i/a) return 1 }; local:function(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
K2-LetExprWithout-26,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: let $e := <element/>, $outer as element() := $e/element() return $outer. SyntaxError: Expected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.'
xquery10keywords,Error: XPST0003: Unable to parse XPath: (let $ancestor-or-self := 1        let $ancestor := 1        let $and := 1        let $as := 1        let $ascending := 1        let $at := 1        let $attribute := 1        let $base-uri := 1        let $boundary-space := 1        let $by := 1        let $case := 1        let $cast := 1        let $castable := 1        let $child := 1        let $collation := 1        let $comment := 1        let $construction := 1        let $copy-namespaces := 1        let $declare := 1        let $default := 1        let $descendant-or-self := 1        let $descendant := 1        let $descending := 1        let $div := 1        let $document-node := 1        let $document := 1        let $element := 1        let $else := 1        let $empty-sequence := 1        let $empty := 1        let $encoding := 1        let $eq := 1 let $every := 1 let $except := 1 let $external := 1 let $following-sibling := 1        let $following := 1 let $for := 1 let $function := 1 let $ge := 1 let $greatest := 1        let $gt := 1 let $idiv := 1 let $if := 1 let $import := 1 let $in := 1 let $inherit := 1        let $instance := 1 let $intersect := 1 let $is := 1 let $item := 1 let $lax := 1        let $le := 1 let $least := 1 let $let := 1 let $lt := 1 let $mod := 1 let $module := 1        let $module := 1 let $namespace := 1 let $ne := 1 let $no-inherit := 1        let $no-preserve := 1 let $node := 1 let $of := 1 let $option := 1 let $or := 1        let $order := 1 let $ordered := 1 let $ordering := 1 let $parent := 1 let $preceding-sibling := 1        let $preceding := 1 let $preserve := 1 let $processing-instruction := 1 let $return := 1        let $satisfies := 1 let $schema-attribute := 1 let $schema-element := 1 let $schema := 1        let $self := 1 let $some := 1 let $stable := 1 let $strict := 1 let $strip := 1        let $text := 1 let $then := 1 let $to := 1 let $treat := 1 let $typeswitch := 1        let $union := 1 let $unordered := 1 let $validate := 1 let $variable := 1 let $version := 1        let $where := 1 let $xquery := 1 return 2) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
xquery30keywords,Error: XPST0003: Unable to parse XPath: (         let $NaN := 1         let $allowing := 1         let $ancestor-or-self := 1         let $ancestor := 1         let $and := 1         let $as := 1         let $ascending := 1         let $at := 1         let $attribute := 1         let $base-uri := 1         let $boundary-space := 1         let $by := 1         let $case := 1         let $cast := 1         let $castable := 1         let $catch := 1         let $child := 1         let $collation := 1         let $comment := 1         let $construction := 1         let $context := 1         let $copy-namespaces := 1         let $count := 1         let $decimal-format := 1         let $decimal-separator := 1         let $declare := 1         let $default := 1         let $descendant-or-self := 1         let $descendant := 1         let $descending := 1         let $digit := 1         let $div := 1         let $document-node := 1         let $document := 1         let $element := 1         let $else := 1         let $empty-sequence := 1         let $empty := 1         let $encoding := 1         let $end := 1         let $eq := 1         let $every := 1         let $except := 1         let $external := 1         let $following-sibling := 1         let $following := 1         let $for := 1         let $function := 1         let $ge := 1         let $greatest := 1         let $group := 1         let $grouping-separator := 1         let $gt := 1         let $idiv := 1         let $if := 1         let $import := 1         let $in := 1         let $infinity := 1         let $inherit := 1         let $instance := 1         let $intersect := 1         let $is := 1         let $item := 1         let $lax := 1         let $le := 1         let $least := 1         let $let := 1         let $lt := 1         let $minus-sign := 1         let $mod := 1         let $module := 1         let $namespace-node := 1         let $namespace := 1         let $ne := 1         let $next := 1         let $no-inherit := 1         let $no-preserve := 1         let $node := 1         let $of := 1         let $only := 1         let $option := 1         let $or := 1         let $order := 1         let $ordered := 1         let $ordering := 1         let $parent := 1         let $pattern-separator := 1         let $per-mille := 1         let $percent := 1         let $preceding-sibling := 1         let $preceding := 1         let $preserve := 1         let $previous := 1         let $processing-instruction := 1         let $return := 1         let $satisfies := 1         let $schema-attribute := 1         let $schema-element := 1         let $schema := 1         let $self := 1         let $sliding := 1         let $some := 1         let $stable := 1         let $start := 1         let $strict := 1         let $strip := 1         let $switch := 1         let $text := 1         let $then := 1         let $to := 1         let $treat := 1         let $try := 1         let $tumbling := 1         let $type := 1         let $typeswitch := 1         let $union := 1         let $unordered := 1         let $validate := 1         let $variable := 1         let $version := 1         let $when := 1         let $where := 1         let $window := 1         let $xquery := 1         let $zero-digit := 1         return 2       ) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
xquery30keywords4,Error: XPST0003: Unable to parse XPath:           declare function local:NaN () {1};          declare function local:allowing () {2};          declare function local:ancestor-or-self () {3};          declare function local:ancestor () {4};          declare function local:and () {5};          declare function local:as () {6};          declare function local:ascending () {7};          declare function local:at () {8};          declare function local:attribute () {9};          declare function local:base-uri () {10};          declare function local:boundary-space () {11};          declare function local:by () {12};          declare function local:case () {13};          declare function local:cast () {14};          declare function local:castable () {15};          declare function local:catch () {16};          declare function local:child () {17};          declare function local:collation () {18};          declare function local:comment () {19};          declare function local:construction () {20};          declare function local:context () {21};          declare function local:copy-namespaces () {22};          declare function local:count () {23};          declare function local:decimal-format () {24};          declare function local:decimal-separator () {25};          declare function local:declare () {26};          declare function local:default () {27};          declare function local:descendant-or-self () {28};          declare function local:descendant () {29};          declare function local:descending () {30};          declare function local:digit () {31};          declare function local:div () {32};          declare function local:document-node () {33};          declare function local:document () {34};          declare function local:element () {35};          declare function local:else () {36};          declare function local:empty-sequence () {37};          declare function local:empty () {38};          declare function local:encoding () {39};          declare function local:end () {40};          declare function local:eq () {41};          declare function local:every () {42};          declare function local:except () {43};          declare function local:external () {44};          declare function local:following-sibling () {45};          declare function local:following () {46};          declare function local:for () {47};          declare function local:function () {48};          declare function local:ge () {49};          declare function local:greatest () {50};          declare function local:group () {51};          declare function local:grouping-separator () {52};          declare function local:gt () {53};          declare function local:idiv () {54};          declare function local:if () {55};          declare function local:import () {56};          declare function local:in () {57};          declare function local:infinity () {58};          declare function local:inherit () {59};          declare function local:instance () {60};          declare function local:intersect () {61};          declare function local:is () {62};          declare function local:item () {63};          declare function local:lax () {64};          declare function local:le () {65};          declare function local:least () {66};          declare function local:let () {67};          declare function local:lt () {68};          declare function local:minus-sign () {69};          declare function local:mod () {70};          declare function local:module () {71};          declare function local:namespace-node () {72};          declare function local:namespace () {73};          declare function local:ne () {74};          declare function local:next () {75};          declare function local:no-inherit () {76};          declare function local:no-preserve () {77};          declare function local:node () {78};          declare function local:of () {79};          declare function local:only () {80};          declare function local:option () {81};          declare function local:or () {82};          declare function local:order () {83};          declare function local:ordered () {84};          declare function local:ordering () {85};          declare function local:parent () {86};          declare function local:pattern-separator () {87};          declare function local:per-mille () {88};          declare function local:percent () {89};          declare function local:preceding-sibling () {90};          declare function local:preceding () {91};          declare function local:preserve () {92};          declare function local:previous () {93};          declare function local:processing-instruction () {94};          declare function local:return () {95};          declare function local:satisfies () {96};          declare function local:schema-attribute () {97};          declare function local:schema-element () {98};          declare function local:schema () {99};          declare function local:self () {100};          declare function local:sliding () {101};          declare function local:some () {102};          declare function local:stable () {103};          declare function local:start () {104};          declare function local:strict () {105};          declare function local:strip () {106};          declare function local:switch () {107};          declare function local:text () {108};          declare function local:then () {109};          declare function local:to () {110};          declare function local:treat () {111};          declare function local:try () {112};          declare function local:tumbling () {113};          declare function local:type () {114};          declare function local:typeswitch () {115};          declare function local:union () {116};          declare function local:unordered () {117};          declare function local:validate () {118};          declare function local:variable () {119};          declare function local:version () {120};          declare function local:when () {121};          declare function local:where () {122};          declare function local:window () {123};          declare function local:xquery () {124};          declare function local:zero-digit () {125};                    local:NaN() +          local:allowing() +          local:ancestor-or-self() +          local:ancestor() +          local:and() +          local:as() +          local:ascending() +          local:at() +          local:attribute() +          local:base-uri() +          local:boundary-space() +          local:by() +          local:case() +          local:cast() +          local:castable() +          local:catch() +          local:child() +          local:collation() +          local:comment() +          local:construction() +          local:context() +          local:copy-namespaces() +          local:count() +          local:decimal-format() +          local:decimal-separator() +          local:declare() +          local:default() +          local:descendant-or-self() +          local:descendant() +          local:descending() +          local:digit() +          local:div() +          local:document-node() +          local:document() +          local:element() +          local:else() +          local:empty-sequence() +          local:empty() +          local:encoding() +          local:end() +          local:eq() +          local:every() +          local:except() +          local:external() +          local:following-sibling() +          local:following() +          local:for() +          local:function() +          local:ge() +          local:greatest() +          local:group() +          local:grouping-separator() +          local:gt() +          local:idiv() +          local:if() +          local:import() +          local:in() +          local:infinity() +          local:inherit() +          local:instance() +          local:intersect() +          local:is() +          local:item() +          local:lax() +          local:le() +          local:least() +          local:let() +          local:lt() +          local:minus-sign() +          local:mod() +          local:module() +          local:namespace-node() +          local:namespace() +          local:ne() +          local:next() +          local:no-inherit() +          local:no-preserve() +          local:node() +          local:of() +          local:only() +          local:option() +          local:or() +          local:order() +          local:ordered() +          local:ordering() +          local:parent() +          local:pattern-separator() +          local:per-mille() +          local:percent() +          local:preceding-sibling() +          local:preceding() +          local:preserve() +          local:previous() +          local:processing-instruction() +          local:return() +          local:satisfies() +          local:schema-attribute() +          local:schema-element() +          local:schema() +          local:self() +          local:sliding() +          local:some() +          local:stable() +          local:start() +          local:strict() +          local:strip() +          local:switch() +          local:text() +          local:then() +          local:to() +          local:treat() +          local:try() +          local:tumbling() +          local:type() +          local:typeswitch() +          local:union() +          local:unordered() +          local:validate() +          local:variable() +          local:version() +          local:when() +          local:where() +          local:window() +          local:xquery() +          local:zero-digit()          eq (125 * (125 + 1)) div 2       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
xquery30keywords5,Error: XPST0003: Unable to parse XPath:           declare default function namespace "http://www.w3.org/2005/xquery-local-functions";                    declare function NaN () {1};          declare function allowing () {2};          declare function ancestor-or-self () {3};          declare function ancestor () {4};          declare function and () {5};          declare function as () {6};          declare function ascending () {7};          declare function at () {8};          declare function base-uri () {9};          declare function boundary-space () {10};          declare function by () {11};          declare function case () {12};          declare function cast () {13};          declare function castable () {14};          declare function catch () {15};          declare function child () {16};          declare function collation () {17};          declare function construction () {18};          declare function context () {19};          declare function copy-namespaces () {20};          declare function count () {21};          declare function decimal-format () {22};          declare function decimal-separator () {23};          declare function declare () {24};          declare function default () {25};          declare function descendant-or-self () {26};          declare function descendant () {27};          declare function descending () {28};          declare function digit () {29};          declare function div () {30};          declare function document () {31};          declare function else () {32};          declare function empty () {33};          declare function encoding () {34};          declare function end () {35};          declare function eq () {36};          declare function every () {37};          declare function except () {38};          declare function external () {39};          declare function following-sibling () {40};          declare function following () {41};          declare function for () {42};          declare function ge () {43};          declare function greatest () {44};          declare function group () {45};          declare function grouping-separator () {46};          declare function gt () {47};          declare function idiv () {48};          declare function import () {49};          declare function in () {50};          declare function infinity () {51};          declare function inherit () {52};          declare function instance () {53};          declare function intersect () {54};          declare function is () {55};          declare function lax () {56};          declare function le () {57};          declare function least () {58};          declare function let () {59};          declare function lt () {60};          declare function minus-sign () {61};          declare function mod () {62};          declare function module () {63};          declare function namespace () {64};          declare function ne () {65};          declare function next () {66};          declare function no-inherit () {67};          declare function no-preserve () {68};          declare function of () {69};          declare function only () {70};          declare function option () {71};          declare function or () {72};          declare function order () {73};          declare function ordered () {74};          declare function ordering () {75};          declare function parent () {76};          declare function pattern-separator () {77};          declare function per-mille () {78};          declare function percent () {79};          declare function preceding-sibling () {80};          declare function preceding () {81};          declare function preserve () {82};          declare function previous () {83};          declare function return () {84};          declare function satisfies () {85};          declare function schema () {86};          declare function self () {87};          declare function sliding () {88};          declare function some () {89};          declare function stable () {90};          declare function start () {91};          declare function strict () {92};          declare function strip () {93};          declare function then () {94};          declare function to () {95};          declare function treat () {96};          declare function try () {97};          declare function tumbling () {98};          declare function type () {99};          declare function union () {100};          declare function unordered () {101};          declare function validate () {102};          declare function variable () {103};          declare function version () {104};          declare function when () {105};          declare function where () {106};          declare function window () {107};          declare function xquery () {108};          declare function zero-digit () {109};                    NaN() +          allowing() +          ancestor-or-self() +          ancestor() +          and() +          as() +          ascending() +          at() +          base-uri() +          boundary-space() +          by() +          case() +          cast() +          castable() +          catch() +          child() +          collation() +          construction() +          context() +          copy-namespaces() +          count() +          decimal-format() +          decimal-separator() +          declare() +          default() +          descendant-or-self() +          descendant() +          descending() +          digit() +          div() +          document() +          else() +          empty() +          encoding() +          end() +          eq() +          every() +          except() +          external() +          following-sibling() +          following() +          for() +          ge() +          greatest() +          group() +          grouping-separator() +          gt() +          idiv() +          import() +          in() +          infinity() +          inherit() +          instance() +          intersect() +          is() +          lax() +          le() +          least() +          let() +          lt() +          minus-sign() +          mod() +          module() +          namespace() +          ne() +          next() +          no-inherit() +          no-preserve() +          of() +          only() +          option() +          or() +          order() +          ordered() +          ordering() +          parent() +          pattern-separator() +          per-mille() +          percent() +          preceding-sibling() +          preceding() +          preserve() +          previous() +          return() +          satisfies() +          schema() +          self() +          sliding() +          some() +          stable() +          start() +          strict() +          strip() +          then() +          to() +          treat() +          try() +          tumbling() +          type() +          union() +          unordered() +          validate() +          variable() +          version() +          when() +          where() +          window() +          xquery() +          zero-digit()          eq (109 * (109 + 1)) div 2       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
xquery31keywords4,Error: XPST0003: Unable to parse XPath:           declare function local:exponent-separator () {126};          local:exponent-separator()          eq 126       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
xquery31keywords5,Error: XPST0003: Unable to parse XPath:           declare default function namespace "http://www.w3.org/2005/xquery-local-functions";          declare function exponent-separator () {110};          exponent-separator()          eq 110       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
Literals016,AssertionError: 65535032e2: expected '6553503200' to equal '6.5535032E9'
Literals017,AssertionError: 65535.032e2: expected '6553503.2' to equal '6.5535032E6'
Literals025,AssertionError: -65535.032e2: expected '-6553503.2' to equal '-6.5535032E6'
Literals027,AssertionError: 65535032E2: expected '6553503200' to equal '6.5535032E9'
Literals028,AssertionError: 65535.032E2: expected '6553503.2' to equal '6.5535032E6'
Literals068,Error: XPST0003: Unable to parse XPath: (text{ 'He said, "I don''t like it."' })!string() => string-join(" "). SyntaxError: Expected "!", "!=", "#", "(", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
Literals069,Error: XPST0003: Unable to parse XPath: (text{ "He said, ""I don't like it.""" })!string() => string-join(" "). SyntaxError: Expected "!", "!=", "#", "(", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
K-Literals-29,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'Failed to execute \'evaluateXPath\': xpathSelector must be a string.'
K-Literals-31,AssertionError: expected [Function] to throw an error
K-Literals-32,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XQST0090: The character reference NaN (NaN) does not reference a valid codePoint.'
K-Literals-33,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XQST0090: The character reference NaN (NaN) does not reference a valid codePoint.'
K-Literals-34,AssertionError: expected [Function] to throw an error
K-Literals-35,AssertionError: expected [Function] to throw an error
K-Literals-36,AssertionError: expected [Function] to throw an error
K-Literals-38,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XQST0090: The character reference NaN (NaN) does not reference a valid codePoint.'
K-Literals-39,AssertionError: expected [Function] to throw an error
K-Literals-40,AssertionError: expected [Function] to throw an error
K-Literals-41,AssertionError: expected [Function] to throw an error
K-Literals-44,AssertionError: expected [Function] to throw an error
K-Literals-45,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XQST0090: The character reference NaN (NaN) does not reference a valid codePoint.'
K-Literals-48,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XQST0090: The character reference NaN (NaN) does not reference a valid codePoint.'
K2-Literals-2,AssertionError: expected [Function] to throw an error
K2-Literals-6,AssertionError: Expected executing the XPath "999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999.1" to resolve to one of the expected results, but got AssertionError: 999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999.1: expected '1E+123' to equal '999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999.1', AssertionError: Expected XPath 999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999.1 to resolve to 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000: expected false to be true, AssertionError: expected [Function] to throw an error.
K2-Literals-22,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XQST0090: The character reference -32 (-20) does not reference a valid codePoint.'
K2-Literals-23,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XQST0090: The character reference -20 (-14) does not reference a valid codePoint.'
K2-Literals-24,AssertionError: expected [Function] to throw an error
K2-Literals-25,AssertionError: expected [Function] to throw an error
K2-Literals-26,AssertionError: expected [Function] to throw an error
K2-Literals-27,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XQST0090: The character reference NaN (NaN) does not reference a valid codePoint.'
K2-Literals-28,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
K2-Literals-29,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XQST0090: The character reference 0 (0) does not reference a valid codePoint.'
cbcl-literals-001,AssertionError: expected [Function] to throw an error
cbcl-literals-002,AssertionError: expected [Function] to throw an error
cbcl-literals-003,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XQST0090: The character reference NaN (NaN) does not reference a valid codePoint.'
cbcl-literals-005,AssertionError: expected [Function] to throw an error
cbcl-literals-006,AssertionError: expected [Function] to throw an error
cbcl-literals-007,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XQST0090: The character reference NaN (NaN) does not reference a valid codePoint.'
function-literal-001,Error: Not implemented: function references with a namespace URI.
function-literal-002,Error: Not implemented: function references with a namespace URI.
function-literal-003,Error: Not implemented: function references with a namespace URI.
function-literal-004,Error: Not implemented: function references with a namespace URI.
function-literal-005,Error: Not implemented: function references with a namespace URI.
function-literal-006,Error: Not implemented: function references with a namespace URI.
function-literal-007,Error: Not implemented: function references with a namespace URI.
function-literal-008,Error: Not implemented: function references with a namespace URI.
function-literal-009,Error: Not implemented: function references with a namespace URI.
function-literal-010,Error: Not implemented: function references with a namespace URI.
function-literal-011,Error: Not implemented: function references with a namespace URI.
function-literal-012,Error: Not implemented: function references with a namespace URI.
function-literal-013,Error: Not implemented: function references with a namespace URI.
function-literal-014,Error: Not implemented: function references with a namespace URI.
function-literal-015,Error: Not implemented: function references with a namespace URI.
function-literal-016,Error: Not implemented: function references with a namespace URI.
function-literal-017,Error: Not implemented: function references with a namespace URI.
function-literal-018,Error: Not implemented: function references with a namespace URI.
function-literal-019,Error: Not implemented: function references with a namespace URI.
function-literal-020,Error: Not implemented: function references with a namespace URI.
function-literal-021,Error: Not implemented: function references with a namespace URI.
function-literal-022,Error: Not implemented: function references with a namespace URI.
function-literal-023,Error: Not implemented: function references with a namespace URI.
function-literal-024,Error: Not implemented: function references with a namespace URI.
function-literal-025,Error: Not implemented: function references with a namespace URI.
function-literal-026,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'Not implemented: function references with a namespace URI.'
function-literal-027,Error: Not implemented: function references with a namespace URI.
function-literal-028,AssertionError: expected [Function] to throw error including 'XXXX0000' but got 'Not implemented: function references with a namespace URI.'
function-literal-029,Error: Not implemented: function references with a namespace URI.
function-literal-030,AssertionError: expected [Function] to throw error including 'XXXX0000' but got 'Not implemented: function references with a namespace URI.'
function-literal-031,Error: Not implemented: function references with a namespace URI.
function-literal-032,AssertionError: expected [Function] to throw error including 'XXXX0000' but got 'Not implemented: function references with a namespace URI.'
function-literal-033,Error: Not implemented: function references with a namespace URI.
function-literal-033a,Error: Not implemented: function references with a namespace URI.
function-literal-034,Error: Not implemented: function references with a namespace URI.
function-literal-034a,Error: Not implemented: function references with a namespace URI.
function-literal-035,Error: Not implemented: function references with a namespace URI.
function-literal-036,Error: Not implemented: function references with a namespace URI.
function-literal-037,Error: Not implemented: function references with a namespace URI.
function-literal-038,Error: Not implemented: function references with a namespace URI.
function-literal-039,Error: Not implemented: function references with a namespace URI.
function-literal-040,Error: Not implemented: function references with a namespace URI.
function-literal-041,Error: Not implemented: function references with a namespace URI.
function-literal-042,Error: Not implemented: function references with a namespace URI.
function-literal-043,Error: Not implemented: function references with a namespace URI.
function-literal-044,Error: Not implemented: function references with a namespace URI.
function-literal-045,Error: Not implemented: function references with a namespace URI.
function-literal-046,Error: Not implemented: function references with a namespace URI.
function-literal-047,Error: Not implemented: function references with a namespace URI.
function-literal-048,Error: Not implemented: function references with a namespace URI.
function-literal-049,Error: Not implemented: function references with a namespace URI.
function-literal-050,Error: Not implemented: function references with a namespace URI.
function-literal-051,Error: Not implemented: function references with a namespace URI.
function-literal-052,Error: Not implemented: function references with a namespace URI.
function-literal-053,Error: Not implemented: function references with a namespace URI.
function-literal-054,Error: Not implemented: function references with a namespace URI.
function-literal-055,Error: Not implemented: function references with a namespace URI.
function-literal-056,Error: Not implemented: function references with a namespace URI.
function-literal-057,Error: Not implemented: function references with a namespace URI.
function-literal-058,Error: Not implemented: function references with a namespace URI.
function-literal-059,Error: Not implemented: function references with a namespace URI.
function-literal-060,Error: Not implemented: function references with a namespace URI.
function-literal-061,Error: Not implemented: function references with a namespace URI.
function-literal-062,Error: Not implemented: function references with a namespace URI.
function-literal-063,Error: Not implemented: function references with a namespace URI.
function-literal-064,Error: XPST0017: Function format-number with arity of 2 not registered. No similar functions found.
function-literal-065,Error: Not implemented: function references with a namespace URI.
function-literal-066,Error: Not implemented: function references with a namespace URI.
function-literal-067,Error: Not implemented: function references with a namespace URI.
function-literal-068,Error: Not implemented: function references with a namespace URI.
function-literal-069,Error: Not implemented: function references with a namespace URI.
function-literal-070,Error: Not implemented: function references with a namespace URI.
function-literal-071,Error: Not implemented: function references with a namespace URI.
function-literal-072,Error: Not implemented: function references with a namespace URI.
function-literal-073,Error: Not implemented: function references with a namespace URI.
function-literal-074,Error: Not implemented: function references with a namespace URI.
function-literal-075,Error: Not implemented: function references with a namespace URI.
function-literal-076,Error: Not implemented: function references with a namespace URI.
function-literal-077,Error: Not implemented: function references with a namespace URI.
function-literal-078,Error: Not implemented: function references with a namespace URI.
function-literal-079,Error: Not implemented: function references with a namespace URI.
function-literal-080,Error: Not implemented: function references with a namespace URI.
function-literal-081,Error: Not implemented: function references with a namespace URI.
function-literal-082,Error: Not implemented: function references with a namespace URI.
function-literal-083,Error: Not implemented: function references with a namespace URI.
function-literal-084,Error: Not implemented: function references with a namespace URI.
function-literal-085,Error: Not implemented: function references with a namespace URI.
function-literal-086,Error: Not implemented: function references with a namespace URI.
function-literal-087,Error: Not implemented: function references with a namespace URI.
function-literal-088,Error: Not implemented: function references with a namespace URI.
function-literal-089,Error: Not implemented: function references with a namespace URI.
function-literal-090,Error: Not implemented: function references with a namespace URI.
function-literal-091,Error: Not implemented: function references with a namespace URI.
function-literal-092,Error: Not implemented: function references with a namespace URI.
function-literal-093,Error: Not implemented: function references with a namespace URI.
function-literal-094,Error: Not implemented: function references with a namespace URI.
function-literal-095,Error: Not implemented: function references with a namespace URI.
function-literal-096,Error: Not implemented: function references with a namespace URI.
function-literal-097,Error: Not implemented: function references with a namespace URI.
function-literal-098,Error: Not implemented: function references with a namespace URI.
function-literal-099,Error: Not implemented: function references with a namespace URI.
function-literal-100,Error: Not implemented: function references with a namespace URI.
function-literal-101,Error: Not implemented: function references with a namespace URI.
function-literal-102,Error: Not implemented: function references with a namespace URI.
function-literal-103,Error: Not implemented: function references with a namespace URI.
function-literal-104,Error: Not implemented: function references with a namespace URI.
function-literal-105,Error: Not implemented: function references with a namespace URI.
function-literal-106,Error: Not implemented: function references with a namespace URI.
function-literal-107,Error: Not implemented: function references with a namespace URI.
function-literal-108,Error: Not implemented: function references with a namespace URI.
function-literal-109,Error: Not implemented: function references with a namespace URI.
function-literal-110,Error: Not implemented: function references with a namespace URI.
function-literal-111,Error: Not implemented: function references with a namespace URI.
function-literal-112,Error: Not implemented: function references with a namespace URI.
function-literal-113,Error: Not implemented: function references with a namespace URI.
function-literal-114,Error: Not implemented: function references with a namespace URI.
function-literal-115,Error: Not implemented: function references with a namespace URI.
function-literal-116,Error: Not implemented: function references with a namespace URI.
function-literal-117,Error: Not implemented: function references with a namespace URI.
function-literal-118,Error: Not implemented: function references with a namespace URI.
function-literal-119,Error: Not implemented: function references with a namespace URI.
function-literal-120,Error: Not implemented: function references with a namespace URI.
function-literal-121,Error: Not implemented: function references with a namespace URI.
function-literal-122,Error: Not implemented: function references with a namespace URI.
function-literal-123,Error: Not implemented: function references with a namespace URI.
function-literal-124,Error: Not implemented: function references with a namespace URI.
function-literal-125,Error: Not implemented: function references with a namespace URI.
function-literal-126,Error: Not implemented: function references with a namespace URI.
function-literal-127,Error: Not implemented: function references with a namespace URI.
function-literal-128,Error: Not implemented: function references with a namespace URI.
function-literal-129,Error: Not implemented: function references with a namespace URI.
function-literal-130,Error: Not implemented: function references with a namespace URI.
function-literal-131,Error: Not implemented: function references with a namespace URI.
function-literal-132,Error: Not implemented: function references with a namespace URI.
function-literal-133,Error: Not implemented: function references with a namespace URI.
function-literal-134,Error: Not implemented: function references with a namespace URI.
function-literal-135,Error: Not implemented: function references with a namespace URI.
function-literal-136,Error: Not implemented: function references with a namespace URI.
function-literal-137,Error: Not implemented: function references with a namespace URI.
function-literal-138,Error: Not implemented: function references with a namespace URI.
function-literal-139,Error: Not implemented: function references with a namespace URI.
function-literal-140,Error: Not implemented: function references with a namespace URI.
function-literal-141,Error: Not implemented: function references with a namespace URI.
function-literal-142,Error: Not implemented: function references with a namespace URI.
function-literal-143,Error: Not implemented: function references with a namespace URI.
function-literal-144,Error: Not implemented: function references with a namespace URI.
function-literal-145,Error: Not implemented: function references with a namespace URI.
function-literal-146,Error: Not implemented: function references with a namespace URI.
function-literal-147,Error: Not implemented: function references with a namespace URI.
function-literal-148,Error: Not implemented: function references with a namespace URI.
function-literal-149,Error: Not implemented: function references with a namespace URI.
function-literal-150,Error: Not implemented: function references with a namespace URI.
function-literal-151,Error: Not implemented: function references with a namespace URI.
function-literal-152,Error: Not implemented: function references with a namespace URI.
function-literal-153,Error: Not implemented: function references with a namespace URI.
function-literal-154,Error: Not implemented: function references with a namespace URI.
function-literal-155,Error: Not implemented: function references with a namespace URI.
function-literal-155a,Error: Not implemented: function references with a namespace URI.
function-literal-156,Error: Not implemented: function references with a namespace URI.
function-literal-156a,Error: Not implemented: function references with a namespace URI.
function-literal-157,Error: Not implemented: function references with a namespace URI.
function-literal-158,Error: Not implemented: function references with a namespace URI.
function-literal-159,Error: Not implemented: function references with a namespace URI.
function-literal-160,Error: Not implemented: function references with a namespace URI.
function-literal-161,Error: Not implemented: function references with a namespace URI.
function-literal-162,Error: Not implemented: function references with a namespace URI.
function-literal-163,Error: Not implemented: function references with a namespace URI.
function-literal-164,Error: Not implemented: function references with a namespace URI.
function-literal-165,Error: Not implemented: function references with a namespace URI.
function-literal-166,Error: Not implemented: function references with a namespace URI.
function-literal-167,Error: Not implemented: function references with a namespace URI.
function-literal-168,Error: Not implemented: function references with a namespace URI.
function-literal-169,Error: Not implemented: function references with a namespace URI.
function-literal-170,Error: Not implemented: function references with a namespace URI.
function-literal-171,Error: Not implemented: function references with a namespace URI.
function-literal-172,Error: Not implemented: function references with a namespace URI.
function-literal-173,Error: Not implemented: function references with a namespace URI.
function-literal-174,Error: Not implemented: function references with a namespace URI.
function-literal-175,Error: Not implemented: function references with a namespace URI.
function-literal-176,Error: Not implemented: function references with a namespace URI.
function-literal-177,Error: Not implemented: function references with a namespace URI.
function-literal-178,Error: Not implemented: function references with a namespace URI.
function-literal-179,Error: Not implemented: function references with a namespace URI.
function-literal-180,Error: Not implemented: function references with a namespace URI.
function-literal-181,Error: Not implemented: function references with a namespace URI.
function-literal-182,Error: Not implemented: function references with a namespace URI.
function-literal-183,Error: Not implemented: function references with a namespace URI.
function-literal-184,Error: Not implemented: function references with a namespace URI.
function-literal-185,Error: Not implemented: function references with a namespace URI.
function-literal-186,Error: Not implemented: function references with a namespace URI.
function-literal-187,Error: Not implemented: function references with a namespace URI.
function-literal-188,Error: Not implemented: function references with a namespace URI.
function-literal-189,Error: Not implemented: function references with a namespace URI.
function-literal-190,Error: Not implemented: function references with a namespace URI.
function-literal-191,Error: Not implemented: function references with a namespace URI.
function-literal-192,Error: Not implemented: function references with a namespace URI.
function-literal-193,Error: Not implemented: function references with a namespace URI.
function-literal-194,Error: Not implemented: function references with a namespace URI.
function-literal-195,Error: Not implemented: function references with a namespace URI.
function-literal-196,Error: Not implemented: function references with a namespace URI.
function-literal-197,Error: Not implemented: function references with a namespace URI.
function-literal-198,Error: Not implemented: function references with a namespace URI.
function-literal-199,Error: Not implemented: function references with a namespace URI.
function-literal-200,Error: Not implemented: function references with a namespace URI.
function-literal-201,Error: Not implemented: function references with a namespace URI.
function-literal-202,Error: Not implemented: function references with a namespace URI.
function-literal-203,Error: Not implemented: function references with a namespace URI.
function-literal-204,Error: Not implemented: function references with a namespace URI.
function-literal-205,Error: Not implemented: function references with a namespace URI.
function-literal-206,Error: Not implemented: function references with a namespace URI.
function-literal-207,Error: Not implemented: function references with a namespace URI.
function-literal-208,Error: Not implemented: function references with a namespace URI.
function-literal-209,Error: Not implemented: function references with a namespace URI.
function-literal-210,Error: Not implemented: function references with a namespace URI.
function-literal-211,Error: Not implemented: function references with a namespace URI.
function-literal-212,Error: Not implemented: function references with a namespace URI.
function-literal-213,Error: Not implemented: function references with a namespace URI.
function-literal-214,Error: Not implemented: function references with a namespace URI.
function-literal-215,Error: Not implemented: function references with a namespace URI.
function-literal-216,Error: Not implemented: function references with a namespace URI.
function-literal-217,Error: Not implemented: function references with a namespace URI.
function-literal-218,Error: Not implemented: function references with a namespace URI.
function-literal-219,Error: Not implemented: function references with a namespace URI.
function-literal-220,Error: Not implemented: function references with a namespace URI.
function-literal-221,Error: Not implemented: function references with a namespace URI.
function-literal-222,Error: Not implemented: function references with a namespace URI.
function-literal-223,Error: Not implemented: function references with a namespace URI.
function-literal-224,Error: Not implemented: function references with a namespace URI.
function-literal-225,Error: Not implemented: function references with a namespace URI.
function-literal-226,Error: Not implemented: function references with a namespace URI.
function-literal-227,Error: Not implemented: function references with a namespace URI.
function-literal-228,Error: Not implemented: function references with a namespace URI.
function-literal-229,Error: Not implemented: function references with a namespace URI.
function-literal-230,Error: Not implemented: function references with a namespace URI.
function-literal-231,Error: Not implemented: function references with a namespace URI.
function-literal-232,Error: Not implemented: function references with a namespace URI.
function-literal-233,Error: Not implemented: function references with a namespace URI.
function-literal-234,Error: Not implemented: function references with a namespace URI.
function-literal-235,Error: Not implemented: function references with a namespace URI.
function-literal-236,Error: Not implemented: function references with a namespace URI.
function-literal-237,Error: Not implemented: function references with a namespace URI.
function-literal-238,Error: Not implemented: function references with a namespace URI.
function-literal-239,Error: Not implemented: function references with a namespace URI.
function-literal-240,Error: Not implemented: function references with a namespace URI.
function-literal-241,Error: Not implemented: function references with a namespace URI.
function-literal-242,Error: Not implemented: function references with a namespace URI.
function-literal-243,Error: Not implemented: function references with a namespace URI.
function-literal-244,Error: Not implemented: function references with a namespace URI.
function-literal-245,Error: Not implemented: function references with a namespace URI.
function-literal-246,Error: Not implemented: function references with a namespace URI.
function-literal-247,Error: Not implemented: function references with a namespace URI.
function-literal-248,Error: Not implemented: function references with a namespace URI.
function-literal-249,Error: Not implemented: function references with a namespace URI.
function-literal-250,Error: Not implemented: function references with a namespace URI.
function-literal-251,Error: Not implemented: function references with a namespace URI.
function-literal-252,Error: Not implemented: function references with a namespace URI.
function-literal-253,Error: Not implemented: function references with a namespace URI.
function-literal-254,Error: Not implemented: function references with a namespace URI.
function-literal-255,Error: Not implemented: function references with a namespace URI.
function-literal-256,Error: Not implemented: function references with a namespace URI.
function-literal-257,Error: Not implemented: function references with a namespace URI.
function-literal-258,Error: Not implemented: function references with a namespace URI.
function-literal-259,Error: Not implemented: function references with a namespace URI.
function-literal-260,Error: Not implemented: function references with a namespace URI.
function-literal-261,Error: Not implemented: function references with a namespace URI.
function-literal-262,Error: Not implemented: function references with a namespace URI.
function-literal-263,Error: Not implemented: function references with a namespace URI.
function-literal-264,Error: Not implemented: function references with a namespace URI.
function-literal-265,Error: Not implemented: function references with a namespace URI.
function-literal-266,Error: Not implemented: function references with a namespace URI.
function-literal-267,Error: Not implemented: function references with a namespace URI.
function-literal-268,Error: Not implemented: function references with a namespace URI.
function-literal-269,Error: Not implemented: function references with a namespace URI.
function-literal-270,Error: Not implemented: function references with a namespace URI.
function-literal-271,Error: Not implemented: function references with a namespace URI.
function-literal-272,Error: Not implemented: function references with a namespace URI.
function-literal-273,Error: Not implemented: function references with a namespace URI.
function-literal-274,Error: Not implemented: function references with a namespace URI.
function-literal-275,Error: Not implemented: function references with a namespace URI.
function-literal-276,Error: Not implemented: function references with a namespace URI.
function-literal-277,Error: Not implemented: function references with a namespace URI.
function-literal-278,Error: Not implemented: function references with a namespace URI.
function-literal-279,Error: Not implemented: function references with a namespace URI.
function-literal-280,Error: Not implemented: function references with a namespace URI.
function-literal-281,Error: Not implemented: function references with a namespace URI.
function-literal-282,Error: Not implemented: function references with a namespace URI.
function-literal-283,Error: Not implemented: function references with a namespace URI.
function-literal-284,Error: Not implemented: function references with a namespace URI.
function-literal-285,Error: Not implemented: function references with a namespace URI.
function-literal-286,Error: Not implemented: function references with a namespace URI.
function-literal-287,Error: Not implemented: function references with a namespace URI.
function-literal-288,Error: Not implemented: function references with a namespace URI.
function-literal-289,Error: Not implemented: function references with a namespace URI.
function-literal-290,Error: Not implemented: function references with a namespace URI.
function-literal-291,Error: Not implemented: function references with a namespace URI.
function-literal-292,Error: Not implemented: function references with a namespace URI.
function-literal-293,Error: Not implemented: function references with a namespace URI.
function-literal-294,Error: Not implemented: function references with a namespace URI.
function-literal-295,Error: Not implemented: function references with a namespace URI.
function-literal-296,Error: Not implemented: function references with a namespace URI.
function-literal-297,Error: Not implemented: function references with a namespace URI.
function-literal-298,Error: Not implemented: function references with a namespace URI.
function-literal-299,Error: Not implemented: function references with a namespace URI.
function-literal-300,Error: Not implemented: function references with a namespace URI.
function-literal-301,Error: Not implemented: function references with a namespace URI.
function-literal-302,Error: Not implemented: function references with a namespace URI.
function-literal-303,Error: Not implemented: function references with a namespace URI.
function-literal-304,Error: Not implemented: function references with a namespace URI.
function-literal-305,Error: Not implemented: function references with a namespace URI.
function-literal-306,Error: Not implemented: function references with a namespace URI.
function-literal-307,Error: Not implemented: function references with a namespace URI.
function-literal-308,Error: Not implemented: function references with a namespace URI.
function-literal-309,Error: Not implemented: function references with a namespace URI.
function-literal-310,Error: Not implemented: function references with a namespace URI.
function-literal-311,Error: Not implemented: function references with a namespace URI.
function-literal-312,Error: Not implemented: function references with a namespace URI.
function-literal-313,Error: Not implemented: function references with a namespace URI.
function-literal-314,Error: Not implemented: function references with a namespace URI.
function-literal-315,Error: Not implemented: function references with a namespace URI.
function-literal-316,Error: Not implemented: function references with a namespace URI.
function-literal-317,Error: Not implemented: function references with a namespace URI.
function-literal-318,Error: Not implemented: function references with a namespace URI.
function-literal-319,Error: Not implemented: function references with a namespace URI.
function-literal-320,Error: Not implemented: function references with a namespace URI.
function-literal-321,Error: Not implemented: function references with a namespace URI.
function-literal-322,Error: Not implemented: function references with a namespace URI.
function-literal-323,Error: Not implemented: function references with a namespace URI.
function-literal-324,Error: Not implemented: function references with a namespace URI.
function-literal-325,Error: Not implemented: function references with a namespace URI.
function-literal-326,Error: Not implemented: function references with a namespace URI.
function-literal-327,Error: Not implemented: function references with a namespace URI.
function-literal-328,Error: Not implemented: function references with a namespace URI.
function-literal-329,Error: Not implemented: function references with a namespace URI.
function-literal-330,Error: Not implemented: function references with a namespace URI.
function-literal-331,Error: Not implemented: function references with a namespace URI.
function-literal-332,Error: Not implemented: function references with a namespace URI.
function-literal-333,Error: Not implemented: function references with a namespace URI.
function-literal-334,Error: Not implemented: function references with a namespace URI.
function-literal-335,Error: Not implemented: function references with a namespace URI.
function-literal-336,Error: Not implemented: function references with a namespace URI.
function-literal-337,Error: Not implemented: function references with a namespace URI.
function-literal-338,Error: Not implemented: function references with a namespace URI.
function-literal-339,Error: Not implemented: function references with a namespace URI.
function-literal-340,Error: Not implemented: function references with a namespace URI.
function-literal-341,Error: Not implemented: function references with a namespace URI.
function-literal-342,Error: Not implemented: function references with a namespace URI.
function-literal-343,Error: Not implemented: function references with a namespace URI.
function-literal-344,Error: Not implemented: function references with a namespace URI.
function-literal-345,Error: Not implemented: function references with a namespace URI.
function-literal-346,Error: Not implemented: function references with a namespace URI.
function-literal-347,Error: Not implemented: function references with a namespace URI.
function-literal-348,Error: Not implemented: function references with a namespace URI.
function-literal-349,Error: Not implemented: function references with a namespace URI.
function-literal-350,Error: Not implemented: function references with a namespace URI.
function-literal-351,Error: Not implemented: function references with a namespace URI.
function-literal-352,Error: Not implemented: function references with a namespace URI.
function-literal-353,Error: Not implemented: function references with a namespace URI.
function-literal-354,Error: Not implemented: function references with a namespace URI.
function-literal-355,Error: Not implemented: function references with a namespace URI.
function-literal-356,Error: Not implemented: function references with a namespace URI.
function-literal-357,Error: Not implemented: function references with a namespace URI.
function-literal-358,Error: Not implemented: function references with a namespace URI.
function-literal-359,Error: Not implemented: function references with a namespace URI.
function-literal-360,Error: Not implemented: function references with a namespace URI.
function-literal-361,Error: Not implemented: function references with a namespace URI.
function-literal-362,Error: Not implemented: function references with a namespace URI.
function-literal-363,Error: Not implemented: function references with a namespace URI.
function-literal-364,Error: Not implemented: function references with a namespace URI.
function-literal-365,Error: Not implemented: function references with a namespace URI.
function-literal-366,Error: Not implemented: function references with a namespace URI.
function-literal-367,Error: Not implemented: function references with a namespace URI.
function-literal-368,Error: Not implemented: function references with a namespace URI.
function-literal-369,Error: Not implemented: function references with a namespace URI.
function-literal-370,Error: Not implemented: function references with a namespace URI.
function-literal-371,Error: Not implemented: function references with a namespace URI.
function-literal-372,Error: Not implemented: function references with a namespace URI.
function-literal-373,Error: Not implemented: function references with a namespace URI.
function-literal-374,Error: Not implemented: function references with a namespace URI.
function-literal-375,Error: Not implemented: function references with a namespace URI.
function-literal-376,Error: Not implemented: function references with a namespace URI.
function-literal-377,Error: Not implemented: function references with a namespace URI.
function-literal-378,Error: Not implemented: function references with a namespace URI.
function-literal-379,Error: Not implemented: function references with a namespace URI.
function-literal-380,Error: Not implemented: function references with a namespace URI.
function-literal-381,Error: Not implemented: function references with a namespace URI.
function-literal-382,Error: Not implemented: function references with a namespace URI.
function-literal-383,Error: Not implemented: function references with a namespace URI.
function-literal-384,Error: Not implemented: function references with a namespace URI.
function-literal-385,Error: Not implemented: function references with a namespace URI.
function-literal-386,Error: Not implemented: function references with a namespace URI.
function-literal-387,Error: Not implemented: function references with a namespace URI.
function-literal-388,Error: Not implemented: function references with a namespace URI.
function-literal-389,Error: Not implemented: function references with a namespace URI.
function-literal-390,Error: Not implemented: function references with a namespace URI.
function-literal-391,Error: Not implemented: function references with a namespace URI.
function-literal-392,Error: Not implemented: function references with a namespace URI.
function-literal-393,Error: Not implemented: function references with a namespace URI.
function-literal-394,Error: Not implemented: function references with a namespace URI.
function-literal-395,Error: Not implemented: function references with a namespace URI.
function-literal-396,Error: Not implemented: function references with a namespace URI.
function-literal-397,Error: Not implemented: function references with a namespace URI.
function-literal-398,Error: Not implemented: function references with a namespace URI.
function-literal-399,Error: Not implemented: function references with a namespace URI.
function-literal-400,Error: Not implemented: function references with a namespace URI.
function-literal-401,Error: Not implemented: function references with a namespace URI.
function-literal-402,Error: Not implemented: function references with a namespace URI.
function-literal-403,Error: Not implemented: function references with a namespace URI.
function-literal-404,Error: Not implemented: function references with a namespace URI.
function-literal-405,Error: Not implemented: function references with a namespace URI.
function-literal-406,Error: Not implemented: function references with a namespace URI.
function-literal-407,Error: Not implemented: function references with a namespace URI.
function-literal-408,Error: Not implemented: function references with a namespace URI.
function-literal-409,Error: Not implemented: function references with a namespace URI.
function-literal-410,Error: Not implemented: function references with a namespace URI.
function-literal-411,Error: Not implemented: function references with a namespace URI.
function-literal-412,Error: Not implemented: function references with a namespace URI.
function-literal-413,Error: Not implemented: function references with a namespace URI.
function-literal-414,Error: Not implemented: function references with a namespace URI.
function-literal-415,Error: Not implemented: function references with a namespace URI.
function-literal-416,Error: Not implemented: function references with a namespace URI.
function-literal-417,Error: Not implemented: function references with a namespace URI.
function-literal-418,Error: Not implemented: function references with a namespace URI.
function-literal-419,Error: Not implemented: function references with a namespace URI.
function-literal-420,Error: Not implemented: function references with a namespace URI.
function-literal-421,Error: Not implemented: function references with a namespace URI.
function-literal-422,Error: Not implemented: function references with a namespace URI.
function-literal-423,Error: Not implemented: function references with a namespace URI.
function-literal-424,Error: Not implemented: function references with a namespace URI.
function-literal-425,Error: Not implemented: function references with a namespace URI.
function-literal-426,Error: Not implemented: function references with a namespace URI.
function-literal-427,Error: Not implemented: function references with a namespace URI.
function-literal-428,Error: Not implemented: function references with a namespace URI.
function-literal-429,Error: Not implemented: function references with a namespace URI.
function-literal-430,Error: Not implemented: function references with a namespace URI.
function-literal-431,Error: Not implemented: function references with a namespace URI.
function-literal-432,Error: Not implemented: function references with a namespace URI.
function-literal-433,Error: Not implemented: function references with a namespace URI.
function-literal-434,Error: Not implemented: function references with a namespace URI.
function-literal-435,Error: Not implemented: function references with a namespace URI.
function-literal-436,Error: Not implemented: function references with a namespace URI.
function-literal-437,Error: Not implemented: function references with a namespace URI.
function-literal-438,Error: Not implemented: function references with a namespace URI.
function-literal-439,Error: Not implemented: function references with a namespace URI.
function-literal-440,Error: Not implemented: function references with a namespace URI.
function-literal-441,Error: Not implemented: function references with a namespace URI.
function-literal-442,Error: Not implemented: function references with a namespace URI.
function-literal-443,Error: Not implemented: function references with a namespace URI.
function-literal-444,Error: Not implemented: function references with a namespace URI.
function-literal-445,Error: Not implemented: function references with a namespace URI.
function-literal-446,Error: Not implemented: function references with a namespace URI.
function-literal-447,Error: Not implemented: function references with a namespace URI.
function-literal-448,Error: Not implemented: function references with a namespace URI.
function-literal-449,Error: Not implemented: function references with a namespace URI.
function-literal-450,Error: Not implemented: function references with a namespace URI.
function-literal-451,Error: Not implemented: function references with a namespace URI.
function-literal-452,Error: Not implemented: function references with a namespace URI.
function-literal-453,Error: Not implemented: function references with a namespace URI.
function-literal-454,Error: Not implemented: function references with a namespace URI.
function-literal-455,Error: Not implemented: function references with a namespace URI.
function-literal-456,Error: Not implemented: function references with a namespace URI.
function-literal-457,Error: Not implemented: function references with a namespace URI.
function-literal-458,Error: Not implemented: function references with a namespace URI.
function-literal-459,Error: Not implemented: function references with a namespace URI.
function-literal-460,Error: Not implemented: function references with a namespace URI.
function-literal-461,Error: Not implemented: function references with a namespace URI.
function-literal-462,Error: Not implemented: function references with a namespace URI.
function-literal-463,Error: Not implemented: function references with a namespace URI.
function-literal-464,Error: Not implemented: function references with a namespace URI.
function-literal-465,Error: Not implemented: function references with a namespace URI.
function-literal-466,Error: Not implemented: function references with a namespace URI.
function-literal-467,Error: Not implemented: function references with a namespace URI.
function-literal-468,Error: Not implemented: function references with a namespace URI.
function-literal-469,Error: Not implemented: function references with a namespace URI.
function-literal-470,Error: Not implemented: function references with a namespace URI.
function-literal-471,Error: Not implemented: function references with a namespace URI.
function-literal-472,Error: Not implemented: function references with a namespace URI.
function-literal-473,Error: Not implemented: function references with a namespace URI.
function-literal-474,Error: Not implemented: function references with a namespace URI.
function-literal-475,Error: Not implemented: function references with a namespace URI.
function-literal-476,Error: Not implemented: function references with a namespace URI.
function-literal-477,Error: Not implemented: function references with a namespace URI.
function-literal-478,Error: Not implemented: function references with a namespace URI.
function-literal-479,Error: Not implemented: function references with a namespace URI.
function-literal-480,Error: Not implemented: function references with a namespace URI.
function-literal-481,Error: Not implemented: function references with a namespace URI.
function-literal-482,Error: Not implemented: function references with a namespace URI.
function-literal-483,Error: Not implemented: function references with a namespace URI.
function-literal-484,Error: Not implemented: function references with a namespace URI.
function-literal-485,Error: Not implemented: function references with a namespace URI.
function-literal-486,Error: Not implemented: function references with a namespace URI.
function-literal-487,Error: Not implemented: function references with a namespace URI.
function-literal-488,Error: Not implemented: function references with a namespace URI.
function-literal-489,Error: Not implemented: function references with a namespace URI.
function-literal-490,Error: Not implemented: function references with a namespace URI.
function-literal-491,Error: Not implemented: function references with a namespace URI.
function-literal-492,Error: Not implemented: function references with a namespace URI.
function-literal-493,Error: Not implemented: function references with a namespace URI.
function-literal-494,Error: Not implemented: function references with a namespace URI.
function-literal-495,Error: Not implemented: function references with a namespace URI.
function-literal-496,Error: Not implemented: function references with a namespace URI.
function-literal-497,Error: Not implemented: function references with a namespace URI.
function-literal-498,Error: Not implemented: function references with a namespace URI.
function-literal-499,Error: Not implemented: function references with a namespace URI.
function-literal-500,Error: Not implemented: function references with a namespace URI.
function-literal-501,Error: Not implemented: function references with a namespace URI.
function-literal-502,Error: Not implemented: function references with a namespace URI.
function-literal-503,Error: Not implemented: function references with a namespace URI.
function-literal-504,Error: Not implemented: function references with a namespace URI.
function-literal-505,Error: Not implemented: function references with a namespace URI.
function-literal-506,Error: Not implemented: function references with a namespace URI.
function-literal-507,Error: Not implemented: function references with a namespace URI.
function-literal-508,Error: Not implemented: function references with a namespace URI.
function-literal-509,Error: Not implemented: function references with a namespace URI.
function-literal-510,Error: Not implemented: function references with a namespace URI.
function-literal-511,Error: Not implemented: function references with a namespace URI.
function-literal-512,Error: Not implemented: function references with a namespace URI.
function-literal-513,Error: Not implemented: function references with a namespace URI.
function-literal-514,Error: Not implemented: function references with a namespace URI.
function-literal-515,Error: Not implemented: function references with a namespace URI.
function-literal-516,Error: Not implemented: function references with a namespace URI.
function-literal-517,Error: Not implemented: function references with a namespace URI.
function-literal-518,Error: Not implemented: function references with a namespace URI.
function-literal-519,Error: Not implemented: function references with a namespace URI.
function-literal-520,Error: Not implemented: function references with a namespace URI.
function-literal-523,Error: Not implemented: function references with a namespace URI.
function-literal-524,Error: Not implemented: function references with a namespace URI.
function-literal-525,Error: Not implemented: function references with a namespace URI.
function-literal-526,Error: Not implemented: function references with a namespace URI.
function-literal-527,Error: Not implemented: function references with a namespace URI.
function-literal-528,Error: Not implemented: function references with a namespace URI.
function-literal-701,Error: XPST0003: Unable to parse XPath: (         declare function local:plus($x, $y) {           $x + $y         };         function-name(local:plus#2)       ) = (QName("http://www.w3.org/2005/xquery-local-functions", "plus")). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
function-literal-702,Error: XPST0003: Unable to parse XPath: (         declare function local:plus($x, $y) {           $x + $y         };         function-arity(local:plus#2)       ) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
function-literal-703,Error: XPST0003: Unable to parse XPath: (         declare function local:plus($x, $y) {           $x + $y         };         let $f := (if (current-date() gt xs:date('1900-01-01')) then local:plus#2 else round#2)         return $f(5, 7)       ) = (12). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
function-literal-704,Error: XPST0003: Unable to parse XPath: (         declare variable $v := function-name(local:plus#2);         declare function local:plus($x, $y) {           $x + $y         };         $v      ) = (QName("http://www.w3.org/2005/xquery-local-functions", "plus")). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
function-literal-705,Error: XPST0003: Unable to parse XPath: (         declare variable $v := function-arity(local:plus#2);         declare function local:plus($x, $y) {           $x + $y         };         $v     ) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
function-literal-706,Error: XPST0003: Unable to parse XPath: (         declare variable $f := (if (current-date() gt xs:date('1900-01-01')) then local:plus#2 else round#2);         declare function local:plus($x, $y) {           $x + $y         };         $f(5, 7)       ) = (12). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
function-literal-707,Error: XPST0003: Unable to parse XPath: (         declare variable $f := (if (current-date() gt xs:date('1900-01-01')) then local:plus#2 else round#2);         declare function local:plus($x, $y) {           $x + $y + $a         };         declare variable $a := function-arity($f);         $f(3, 4)      ) = (9). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
function-literal-708,Error: XPST0003: Unable to parse XPath: (         declare default function namespace "http://example.com/functions";         declare variable $f := (if (fn:current-date() gt xs:date('1900-01-01')) then plus#2 else fn:round#2);         declare function plus($x, $y) {           $x + $y         };         $f(5, 7)       ) = (12). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found.
named-function-ref-reserved-function-names-001,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function attribute with arity of 0 not registered. No similar functions found.'
named-function-ref-reserved-function-names-002,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function comment with arity of 0 not registered. Did you mean "count (item()*)"?'
named-function-ref-reserved-function-names-003,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function document-node with arity of 0 not registered. No similar functions found.'
named-function-ref-reserved-function-names-004,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function element with arity of 0 not registered. No similar functions found.'
named-function-ref-reserved-function-names-005,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function empty-sequence with arity of 0 not registered. Did you mean "subsequence (item()*, xs:double)" or "subsequence (item()*, xs:double, xs:double)"?'
named-function-ref-reserved-function-names-006,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function function with arity of 0 not registered. No similar functions found.'
named-function-ref-reserved-function-names-007,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function if with arity of 0 not registered. No similar functions found.'
named-function-ref-reserved-function-names-008,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function item with arity of 0 not registered. No similar functions found.'
named-function-ref-reserved-function-names-009,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function namespace-node with arity of 0 not registered. Did you mean "namespace-uri (node())" or "namespace-uri ()"?'
named-function-ref-reserved-function-names-010,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function node with arity of 0 not registered. No similar functions found.'
named-function-ref-reserved-function-names-011,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function processing-instruction with arity of 0 not registered. No similar functions found.'
named-function-ref-reserved-function-names-012,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function schema-attribute with arity of 0 not registered. No similar functions found.'
named-function-ref-reserved-function-names-013,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function schema-element with arity of 0 not registered. No similar functions found.'
named-function-ref-reserved-function-names-014,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function switch with arity of 0 not registered. No similar functions found.'
named-function-ref-reserved-function-names-015,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function text with arity of 0 not registered. No similar functions found.'
named-function-ref-reserved-function-names-016,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function typeswitch with arity of 0 not registered. No similar functions found.'
named-function-ref-reserved-function-names-017,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function array with arity of 0 not registered. No similar functions found.'
named-function-ref-reserved-function-names-018,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'XPST0017: Function map with arity of 0 not registered. Did you mean "max (xs:anyAtomicType*)" or "max (xs:anyAtomicType*, xs:string)"?'
namespaceDecl-1,AssertionError: expected [Function] to throw error including 'XQST0033' but got 'XPST0003: Unable to parse XPath: declare namespace foo = "http://www.example.com/examples"; declare namespace foo = "http://www.example.com/examples"; a. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
namespaceDecl-2,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPST0003: Unable to parse XPath: element foo:anElement {"Element content"}. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
namespaceDecl-3,AssertionError: expected [Function] to throw error including 'XQST0070' but got 'XPST0003: Unable to parse XPath: declare namespace xml = "http://www.w3.org/XML/1998/namespace"; "a". SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
namespaceDecl-4,AssertionError: expected [Function] to throw error including 'XQST0070' but got 'XPST0003: Unable to parse XPath: declare namespace foo = "http://www.w3.org/XML/1998/namespace"; "a". SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
namespaceDecl-5,AssertionError: expected [Function] to throw error including 'XQST0070' but got 'XPST0003: Unable to parse XPath: declare namespace xmlns = "http://example.com/examples"; "a". SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
namespaceDecl-6,Error: XPST0003: Unable to parse XPath: declare namespace foo = "http://example.org"; <foo:bar> Lentils </foo:bar>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
namespaceDecl-7,Error: XPST0003: Unable to parse XPath: declare namespace xx = "http://example.org"; let $i := <foo:bar xmlns:foo = "http://example.org"> <foo:bing> Lentils </foo:bing> </foo:bar> return $i/xx:bing. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
namespaceDecl-9,Error: XPST0003: Unable to parse XPath: declare namespace xs = "http://www.example.com/examples"; let $var := <xs:someElement>some context</xs:someElement> return $var. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
namespaceDecl-10,Error: XPST0003: Unable to parse XPath: declare namespace xsi = "http://www.example.com/examples"; let $var := <xsi:someElement>some context</xsi:someElement> return $var. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
namespaceDecl-11,Error: XPST0003: Unable to parse XPath: declare namespace fn = "http://www.example.com/examples"; let $var := <fn:someElement>some context</fn:someElement> return $var. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
namespaceDecl-12,Error: XPST0003: Unable to parse XPath: declare namespace xdt = "http://www.example.com/examples"; let $var := <xdt:someElement>some context</xdt:someElement> return $var. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
namespaceDecl-13,Error: XPST0003: Unable to parse XPath: declare namespace local = "http://www.example.com/examples"; let $var := <local:someElement>some context</local:someElement> return $var. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
namespaceDecl-14,Error: XPST0003: Unable to parse XPath: declare namespace XML = "http://www.example.com/examples"; let $var := <XML:someElement>some context</XML:someElement> return $var. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
namespaceDecl-15,Error: XPST0003: Unable to parse XPath: declare namespace XMLNS = "http://www.example.com/examples"; let $var := <XMLNS:someElement>some context</XMLNS:someElement> return $var. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
namespaceDecl-16,Error: XPST0003: Unable to parse XPath: declare namespace px = "http://www.example.com/examples"; let $var := <px:someElement xmlns:px = "http://www.examples.com/localexamples">some context</px:someElement> return $var. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
namespaceDecl-17,Error: XPST0003: Unable to parse XPath: declare namespace px = "http://www.example.com/abc"; let $var := <px:someElement>some context</px:someElement> return namespace-uri-from-QName(node-name($var)) eq xs:anyURI("http://www.example.com/abc"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
namespaceDecl-18,Error: XPST0003: Unable to parse XPath: declare namespace px = "ftp://ftp.is.co.za/rfc/somefile.txt"; let $var := <px:someElement>some context</px:someElement> return $var. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
namespaceDecl-19,Error: XPST0003: Unable to parse XPath: declare namespace px1 = "http://www.example.com/examples"; declare namespace px2 = "http://www.example.com/examples"; let $var := <px1:someElement>some context</px1:someElement> return $var. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
namespaceDecl-20,Error: XPST0003: Unable to parse XPath: declare namespace xx = "http://www.example.com/abc123"; let $var := <xx:someElement>some content</xx:someElement> return namespace-uri-from-QName(node-name($var)) eq xs:anyURI("http://www.example.com/abc123"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
namespaceDecl-21,Error: XPST0003: Unable to parse XPath: declare namespace abc = "http://www.example.com/abc"; let $var := <abc:someElement>some content</abc:someElement> return namespace-uri-from-QName(node-name($var)) eq xs:anyURI("http://www.example.com/abc"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
namespaceDecl-22,Error: XPST0003: Unable to parse XPath: declare namespace abc = "gopher://spinaltap.micro.umn.edu/00/Weather/California/somefile"; <abc:someElement>some content</abc:someElement>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
namespaceDecl-23,Error: XPST0003: Unable to parse XPath: declare namespace abc = "http://www.example.com/abc&amp;"; let $var := <abc:someElement>some content</abc:someElement> return namespace-uri-from-QName(node-name($var)) eq xs:anyURI("http://www.example.com/abc&amp;"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
namespaceDecl-24,Error: XPST0003: Unable to parse XPath: declare namespace abc = "mailto:someuser@someserver.com"; <abc:someElement>some content</abc:someElement>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
K-NamespaceProlog-1,Error: XPST0003: Unable to parse XPath: (::)declare(::)namespace(::)ncname(::)=(::)'http://example.com/';(::)1(::)eq(::)1(::). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
K-NamespaceProlog-2,Error: XPST0003: Unable to parse XPath: (::)declare(::)namespace(::)ncname(::)=(::)"http://example.com/"(::);(::)1(::)eq(::)1(::). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
K2-NamespaceProlog-1,AssertionError: expected [Function] to throw error including 'XQST0033' but got 'XPST0003: Unable to parse XPath: declare namespace myPrefix = "http://example.com/"; declare namespace myPrefix = ""; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
K2-NamespaceProlog-2,AssertionError: expected [Function] to throw error including 'XQST0033' but got 'XPST0003: Unable to parse XPath: declare namespace myPrefix = ""; declare namespace myPrefix = "http://example.com/"; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
K2-NamespaceProlog-3,AssertionError: expected [Function] to throw error including 'XQST0033' but got 'XPST0003: Unable to parse XPath: declare namespace myPrefix = "http://example.com/"; declare namespace myPrefix = "http://example.com/TheSecondOne"; declare namespace myPrefix = ""; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
K2-NamespaceProlog-4,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPST0003: Unable to parse XPath: declare namespace xs = ""; xs:integer(1). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
K2-NamespaceProlog-5,Error: XPST0003: Unable to parse XPath: declare namespace thisPrefixIsNotBoundExampleCom = ""; true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
K2-NamespaceProlog-6,AssertionError: expected [Function] to throw error including 'XQST0070' but got 'XPST0003: Unable to parse XPath: declare namespace xml = ""; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
K2-NamespaceProlog-7,AssertionError: expected [Function] to throw error including 'XQST0070' but got 'XPST0003: Unable to parse XPath: declare namespace xmlns = ""; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
K2-NamespaceProlog-8,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPST0003: Unable to parse XPath: declare namespace xdt = ""; xdt:untypedAtomic("string"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
K2-NamespaceProlog-9,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPST0003: Unable to parse XPath: declare namespace xs = ""; xs:untypedAtomic("string"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
K2-NamespaceProlog-10,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPST0003: Unable to parse XPath: declare namespace local = ""; local:untypedAtomic("string"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
K2-NamespaceProlog-11,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPST0003: Unable to parse XPath: declare namespace fn = ""; fn:untypedAtomic("string"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
K2-NamespaceProlog-12,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPST0003: Unable to parse XPath: declare namespace xsi = ""; xsi:untypedAtomic("string"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
K2-NamespaceProlog-15,AssertionError: expected [Function] to throw error including 'XQST0070' but got 'XPST0003: Unable to parse XPath: declare namespace xml = "http://example.com/"; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
cbcl-declare-namespace-001,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare default element namespace "http://www.example.org"; \n      \tdeclare namespace test=""; \n      \t<test:a />\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'
nametest-6,Error: XPST0003: Unable to parse XPath: declare namespace ns1 = "http://example.org"; let $var := <a attr1 = "abc1"><ns1:b attr2 = "abc2">context2</ns1:b></a> return $var/child::ns1:b. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
nametest-10,Error: XPST0003: Unable to parse XPath: (declare default element namespace "http://www.example.org/examples"; let $var := <a attr1 = "abc1"><b attr2 = "abc2">context2</b></a> return fn:namespace-uri(exactly-one($var/child::b)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found.
nametest-18,Error: XPST0003: Unable to parse XPath: declare namespace ns1 = "http://example.org"; let $var := <a attr1 = "abc1"><ns1:b attr2 = "abc2">context2</ns1:b></a> return $var/child::*:b. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
nametest-21,AssertionError: Expected XPath        let $e := <a attr1 = "abc1" xmlns="http://example.org/nametest-19"/>        return exists($e/self::Q{http://example.org/nametest-19}*)        to resolve to true: expected false to be true
nametest-22,AssertionError: Expected XPath        let $e := <a attr1 = "abc1"/>        return exists($e/self::Q{}*)        to resolve to true: expected false to be true
K2-NameTest-5,AssertionError: Expected executing the XPath "declare namespace namespace = "http://example.com"; declare union <union>for gibberish { for $for in for return <for>***div div</for> }</union>, if(if) then then else else- +-++-**-* instance of element(*)* * * **---++div- div -div" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare namespace namespace = "http://example.com"; declare union <union>for gibberish { for $for in for return <for>***div div</for> }</union>, if(if) then then else else- +-++-**-* instance of element(*)* * * **---++div- div -div. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.', AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: declare namespace namespace = "http://example.com"; declare union <union>for gibberish { for $for in for return <for>***div div</for> }</union>, if(if) then then else else- +-++-**-* instance of element(*)* * * **---++div- div -div. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'.
K2-NameTest-11,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPDY0002: context is absent, it needs to be present to use axes.'
K2-NameTest-12,Error: XPST0003: Unable to parse XPath: declare variable $var := <elem xml:space="default"/>; $var/@xml:space eq "default". SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-NameTest-13,Error: XPST0003: Unable to parse XPath: (declare variable $var := <elem xml:space="preserve"/>; string(($var/@xml:*)[1]))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
K2-NameTest-14,Error: XPST0003: Unable to parse XPath: declare variable $var := <elem>text<a/><!-- a comment --><b/><?target data?><c/><![CDATA[more text]]></elem>; $var/child::*. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-NameTest-15,Error: XPST0003: Unable to parse XPath: declare variable $e := <a b ="content"><?b asd?><b/><c b="content"/></a>; $e/b. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-NameTest-16,Error: XPST0003: Unable to parse XPath: declare variable $e := <a b ="content"><?b asd?><b/></a>; $e/*. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-NameTest-17,Error: XPST0003: Unable to parse XPath: declare variable $e := <a b ="content"><?b asd?><b/></a>; <a>{$e/@b}</a>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-NameTest-18,Error: XPST0003: Unable to parse XPath: declare variable $e := <a b ="content"><?b asd?><b/></a>; <a>{$e/@*}</a>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-NameTest-19,Error: XPST0003: Unable to parse XPath: declare variable $e := <a b ="content"><?b asd?><b/></a>; $e/processing-instruction(b). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-NameTest-20,Error: XPST0003: Unable to parse XPath: declare variable $e := <a b ="content"><?b asd?><b/></a>; <a>{$e/processing-instruction()}</a>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-NameTest-21,AssertionError: expected [Function] to throw an error
K2-NameTest-22,AssertionError: Expected XPath empty(let $e := <a b ="content"><?b asd?><b/></a> return $e/processing-instruction("b ")) to resolve to false: expected true to be false
K2-NameTest-23,AssertionError: expected [Function] to throw an error
K2-NameTest-30,Error: XPST0003: Unable to parse XPath: let $result := (       	declare namespace a = "http://example.com/1";        	declare namespace b = "http://example.com/2";        	let $e := <e a:n1="content" b:n1="content">        	            <a:n1/>        	            <b:n1/>        	            <?n1 ?>        	            <n1/>        	          </e>        	return $e/*:n1) return count($result) = 3. SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
K2-NameTest-31,Error: XPST0003: Unable to parse XPath: let $result := (       	declare namespace a = "http://example.com/1";        	declare namespace b = "http://example.com/2";        	let $e := <e a:n1="content" b:n1="content">        				<a:n1/>        				<b:n1/>        				<?n1 ?>        				<n1/>        			  </e>        	return $e/a:*) return count($result) = 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
K2-NameTest-32,AssertionError: Expected XPath <a>{<e foo="content2" bar="content1"/>/attribute(foo)}</a> to resolve to the given XML. Expected <a/> to equal <a foo="content2"/>
K2-NameTest-35,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'No selector counterpart for: u.'
K2-NameTest-36,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'No selector counterpart for: u.'
K2-NameTest-37,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'No selector counterpart for: u.'
K2-NameTest-38,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'No selector counterpart for: u.'
K2-NameTest-39,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'XPST0003: Unable to parse XPath: declare namespace e = "http://www.example.com/"; schema-element(e:thisTypeDoesNotExistExample.Com). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
K2-NameTest-40,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'XPST0003: Unable to parse XPath: declare namespace e = "http://www.example.com/"; schema-attribute(e:thisTypeDoesNotExistExample.Com). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
K2-NameTest-41,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPDY0002: context is absent, it needs to be present to use axes.'
K2-NameTest-42,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPDY0002: context is absent, it needs to be present to use axes.'
K2-NameTest-43,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPDY0002: context is absent, it needs to be present to use axes.'
K2-NameTest-44,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPDY0002: context is absent, it needs to be present to use axes.'
K2-NameTest-45,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPDY0002: context is absent, it needs to be present to use axes.'
K2-NameTest-46,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPDY0002: context is absent, it needs to be present to use axes.'
K2-NameTest-47,Error: XPST0003: Unable to parse XPath: declare variable $i := <e > <xmlns/> <xmlns/> <xmlns/> <xmlns/> </e>; $i/xmlns. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-NameTest-48,Error: XPST0003: Unable to parse XPath: declare variable $i := <e xmlns="http://example.com/"/>; empty($i/@xmlns). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-NameTest-49,AssertionError: Expected executing the XPath "declare namespace p = "http://example.com/"; <a>{<e p:a="1" p:b="2" p:c="3"/>/attribute::*/p:*}</a>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: declare namespace p = "http://example.com/"; <a>{<e p:a="1" p:b="2" p:c="3"/>/attribute::*/p:*}</a>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: declare namespace p = "http://example.com/"; <a>{<e p:a="1" p:b="2" p:c="3"/>/attribute::*/p:*}</a>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'.
K2-NameTest-50,AssertionError: Expected executing the XPath "declare namespace p = "http://example.com/"; <a>{document {<p:e/>}/@p:*}</a>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: declare namespace p = "http://example.com/"; <a>{document {<p:e/>}/@p:*}</a>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: declare namespace p = "http://example.com/"; <a>{document {<p:e/>}/@p:*}</a>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'.
K2-NameTest-51,AssertionError: Expected executing the XPath "<a>{attribute name{"content"}/*}</a>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: <a>{attribute name{"content"}/*}</a>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: <a>{attribute name{"content"}/*}</a>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.'.
K2-NameTest-52,AssertionError: Expected executing the XPath "<a>{comment {"content"}/*}</a>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: <a>{comment {"content"}/*}</a>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: <a>{comment {"content"}/*}</a>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.'.
K2-NameTest-54,AssertionError: Expected executing the XPath "<a>{processing-instruction name {"content"}/*}</a>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: <a>{processing-instruction name {"content"}/*}</a>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: <a>{processing-instruction name {"content"}/*}</a>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "n" found.'.
K2-NameTest-56,AssertionError: Expected executing the XPath "declare variable $a := <e><a/><b/><c/></e>; <a>{$a/*:ncname eq 1}</a>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: declare variable $a := <e><a/><b/><c/></e>; <a>{$a/*:ncname eq 1}</a>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $a := <e><a/><b/><c/></e>; <a>{$a/*:ncname eq 1}</a>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
K2-NameTest-57,AssertionError: Expected executing the XPath "declare variable $a := <e><a/><b/><c/></e>; <a>{$a/*:ncname eq 1}</a>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: declare variable $a := <e><a/><b/><c/></e>; <a>{$a/*:ncname eq 1}</a>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $a := <e><a/><b/><c/></e>; <a>{$a/*:ncname eq 1}</a>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
K2-NameTest-58,AssertionError: Expected executing the XPath "declare namespace prefix = "http://example.com/"; declare variable $a := <e><a/><b/><c/></e>; <a>{$a/prefix:* eq 1}</a>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: declare namespace prefix = "http://example.com/"; declare variable $a := <e><a/><b/><c/></e>; <a>{$a/prefix:* eq 1}</a>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare namespace prefix = "http://example.com/"; declare variable $a := <e><a/><b/><c/></e>; <a>{$a/prefix:* eq 1}</a>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'.
K2-NameTest-59,AssertionError: Expected executing the XPath "declare namespace prefix = "http://example.com/"; declare variable $a := <e><a/><b/><c/></e>; <a>{$a/@prefix:* eq 1}</a>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: declare namespace prefix = "http://example.com/"; declare variable $a := <e><a/><b/><c/></e>; <a>{$a/@prefix:* eq 1}</a>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare namespace prefix = "http://example.com/"; declare variable $a := <e><a/><b/><c/></e>; <a>{$a/@prefix:* eq 1}</a>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'.
K2-NameTest-60,AssertionError: Expected executing the XPath "         declare variable $input := <e/>;          empty(for $PI as processing-instruction() in $input//processing-instruction() return $PI)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath:          declare variable $input := <e/>;          empty(for $PI as processing-instruction() in $input//processing-instruction() return $PI). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: \n        declare variable $input := <e/>; \n        empty(for $PI as processing-instruction() in $input//processing-instruction() return $PI). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
K2-NameTest-63,AssertionError: Expected XPath <x> <x> <y id="0"/> </x> <y id="1"/> </x>/descendant-or-self::x/child::y to resolve to the given XML. Expected <y id="1"/> <y id="0"/> to equal <y id="0"/><y id="1"/>
K2-NameTest-64,Error: attribute() with more than 1 argument is not supported.
K2-NameTest-65,Error: attribute() with more than 1 argument is not supported.
K2-NameTest-66,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'attribute() with more than 1 argument is not supported.'
K2-NameTest-67,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'attribute() with more than 1 argument is not supported.'
K2-NameTest-68,AssertionError: Expected executing the XPath "<e>{<e foo="1"/>/attribute(foo, xs:integer)}</e>" to resolve to one of the expected results, but got Error: attribute() with more than 1 argument is not supported., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'attribute() with more than 1 argument is not supported.'.
K2-NameTest-69,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'attribute() with more than 1 argument is not supported.'
K2-NameTest-70,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'attribute() with more than 1 argument is not supported.'
K2-NameTest-71,Error: attribute() with more than 1 argument is not supported.
K2-NameTest-72,AssertionError: expected [Function] to throw an error
K2-NameTest-73,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'element() with more than 1 argument is not supported.'
K2-NameTest-74,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'element() with more than 1 argument is not supported.'
K2-NameTest-75,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'element() with more than 1 argument is not supported.'
K2-NameTest-76,Error: element() with more than 1 argument is not supported.
K2-NameTest-77,Error: element() with more than 1 argument is not supported.
K2-NameTest-87,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'attribute() with more than 1 argument is not supported.'
K2-NameTest-88,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'attribute() with more than 1 argument is not supported.'
K2-NameTest-89,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'attribute() with more than 1 argument is not supported.'
K2-NameTest-90,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'attribute() with more than 1 argument is not supported.'
NodeTest013-2,AssertionError: Expected XPath <out>{fn:count(//center/processing-instruction('a&#x2d;pi'))}</out> to resolve to the given XML. Expected <out>0</out> to equal <out>1</out>
K2-NodeTest-19,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'XPDY0002: context is absent, it needs to be present to use axes.'
K2-NodeTest-20,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'XPST0003: Unable to parse XPath: \n         declare namespace ex = "http://www.example.com/"; \n         document-node(schema-element(ex:thisTypeIsNotRecognizedExample.Com)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
K2-NodeTest-21,AssertionError: Expected executing the XPath "          declare namespace ex = "http://www.example.com/";           declare function local:userFunction() { document-node(element(local:ncname)) }; 1" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (          declare namespace ex = "http://www.example.com/";           declare function local:userFunction() { document-node(element(local:ncname)) }; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found., AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: \n         declare namespace ex = "http://www.example.com/"; \n         declare function local:userFunction() { document-node(element(local:ncname)) }; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'.
K2-NodeTest-22,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPDY0002: context is absent, it needs to be present to use axes.'
K2-NodeTest-23,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPDY0002: context is absent, it needs to be present to use axes.'
K2-NodeTest-24,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPDY0002: context is absent, it needs to be present to use axes.'
K2-NodeTest-25,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPDY0002: context is absent, it needs to be present to use axes.'
K2-NodeTest-26,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'No selector counterpart for: u.'
K2-NodeTest-27,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'No selector counterpart for: u.'
K2-NodeTest-28,AssertionError: expected [Function] to throw an error
K2-NodeTest-31,AssertionError: expected [Function] to throw error including 'XPTY0018' but got 'XPST0003: Unable to parse XPath: declare function local:aFunction() { <e/>/(1, <e/>) }; 1, local:aFunction(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K2-NodeTest-33,AssertionError: expected [Function] to throw error including 'XPTY0018' but got 'XPST0003: Unable to parse XPath: declare variable $myVariable := <e/>/(1, <e/>); $myVariable. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-NodeTest-34,AssertionError: expected [Function] to throw error including 'XPTY0018' but got 'XPST0003: Unable to parse XPath: declare variable $myVariable := <e/>/(<e/>, 2); $myVariable. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-NodeTest-35,AssertionError: expected [Function] to throw error including 'XPTY0018' but got 'XPST0003: Unable to parse XPath: declare function local:aFunction() { <e/>/(<e/>, 2) }; 1, local:aFunction(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K2-NodeTest-36,AssertionError: expected [Function] to throw error including 'XPTY0018' but got 'XPST0003: Unable to parse XPath: declare function local:aFunction() { (1, 2, 3, (4, <e/>/(<e/>, 2))) }; 1, local:aFunction(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K2-NodeTest-37,AssertionError: expected [Function] to throw error including 'XPTY0018' but got 'XPST0003: Unable to parse XPath: declare function local:aFunction() { (<e/>/., <e/>/((<e/>, 2), 1, 2)) }; 1, local:aFunction(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K2-NodeTest-38,AssertionError: expected [Function] to throw error including 'XPTY0018' but got 'XPST0003: Unable to parse XPath: declare function local:aFunction() { (<e/>/(., 4, 5, <e/>/((<e/>, 2)))) }; 1, local:aFunction(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
op-logical-and-100,Error: FORG0001: Cannot cast "9223372036854776000" to xs:long, restriction validation failed.
op-logical-and-101,Error: FORG0001: Cannot cast "9223372036854776000" to xs:long, restriction validation failed.
op-logical-or-100,Error: FORG0001: Cannot cast "9223372036854776000" to xs:long, restriction validation failed.
op-logical-or-101,Error: FORG0001: Cannot cast "9223372036854776000" to xs:long, restriction validation failed.
K-LogicExpr-14,Error: XPST0003: Unable to parse XPath: true() or (0, current-time())[1] treat as xs:integer. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "t" found.
K-LogicExpr-15,Error: XPST0003: Unable to parse XPath: (0, current-time())[1] treat as xs:integer or true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "t" found.
K-LogicExpr-16,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'XPST0017: Function current-date with arity of 0 not registered. No similar functions found.'
K-LogicExpr-17,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'XPST0017: Function current-date with arity of 0 not registered. No similar functions found.'
K-LogicExpr-18,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'XPST0017: Function current-date with arity of 0 not registered. No similar functions found.'
K-LogicExpr-19,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'XPST0017: Function current-date with arity of 0 not registered. No similar functions found.'
K-LogicExpr-20,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'XPST0017: Function current-date with arity of 0 not registered. No similar functions found.'
K-LogicExpr-21,AssertionError: expected [Function] to throw error including 'FORG0006' but got 'XPST0017: Function current-date with arity of 0 not registered. No similar functions found.'
K-LogicExpr-22,Error: XPST0017: Function timezone-from-time with arity of 1 not registered. No similar functions found.
K-LogicExpr-23,Error: XPST0017: Function timezone-from-time with arity of 1 not registered. No similar functions found.
K-LogicExpr-24,Error: XPST0017: Function timezone-from-time with arity of 1 not registered. No similar functions found.
K-LogicExpr-25,Error: XPST0003: Unable to parse XPath: boolean((1, 2, 3, current-time())[1] treat as xs:integer) or boolean((1, 2, 3, current-time())[1] treat as xs:integer). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.
K-LogicExpr-26,Error: XPST0003: Unable to parse XPath: boolean((1, 2, 3, current-time())[1] treat as xs:integer) and true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.
K-LogicExpr-27,Error: XPST0003: Unable to parse XPath: true() or boolean((1, 2, 3, current-time())[1] treat as xs:integer). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.
K-LogicExpr-32,Error: XPST0003: Unable to parse XPath: not((1, current-time())[1] treat as xs:integer and false()). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.
K-LogicExpr-33,Error: XPST0003: Unable to parse XPath: not(false() and (1, current-time())[1] treat as xs:integer). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.
K-LogicExpr-39,Error: XPST0017: Function timezone-from-time with arity of 1 not registered. No similar functions found.
K-LogicExpr-40,Error: XPST0017: Function timezone-from-time with arity of 1 not registered. No similar functions found.
K-LogicExpr-41,Error: XPST0017: Function timezone-from-time with arity of 1 not registered. No similar functions found.
K-LogicExpr-42,Error: XPST0003: Unable to parse XPath: boolean((1, 2, 3, current-time())[1] treat as xs:integer) and boolean((1, 2, 3, current-time())[1] treat as xs:integer). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.
K-LogicExpr-43,Error: XPST0003: Unable to parse XPath: boolean((1, 2, 3, current-time())[1] treat as xs:integer) and true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.
K-LogicExpr-44,Error: XPST0003: Unable to parse XPath: true() and boolean((1, 2, 3, current-time())[1] treat as xs:integer). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.
cbcl-logical-and-002,Error: XPST0003: Unable to parse XPath: declare function local:times-table($n as xs:integer) as xs:integer* { for $x in 1 to 12 return $x * $n }; (every $x in local:times-table(15) satisfies ($x mod 3 eq 0)) and (every $y in local:times-table(15) satisfies ($y mod 5 eq 0)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-logical-and-003,Error: XPST0003: Unable to parse XPath: declare function local:factorial($n as xs:integer) as xs:integer { if ($n le 1) then 1 else $n * local:factorial($n - 1) }; declare function local:is-divisible($n as xs:integer, $d as xs:integer) { $n mod $d eq 0 }; not(local:is-divisible(local:factorial(5), 3)) and not(local:is-divisible(local:factorial(5), 2)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-logical-or-001,Error: XPST0003: Unable to parse XPath: declare function local:times-table($n as xs:integer) as xs:integer* { for $x in 1 to 12 return $x * $n }; (some $x in local:times-table(15) satisfies ($x mod 2 eq 0)) or (some $y in local:times-table(15) satisfies ($y mod 3 eq 0)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-logical-or-002,Error: XPST0003: Unable to parse XPath: declare function local:factorial($n as xs:integer) as xs:integer? { if ($n lt 1) then () else if ($n eq 1) then 1 else $n * local:factorial($n - 1) }; (every $x in local:factorial(5) satisfies ($x mod 3 eq 0)) or (every $y in local:factorial(5) satisfies ($y mod 5 eq 0)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-logical-or-003,Error: XPST0003: Unable to parse XPath: declare function local:factorial($n as xs:integer) as xs:integer { if ($n le 1) then 1 else $n * local:factorial($n - 1) }; declare function local:is-divisible($n as xs:integer, $d as xs:integer) { $n mod $d eq 0 }; not(local:is-divisible(local:factorial(5), 3)) or not(local:is-divisible(local:factorial(5), 2)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
orderBy1,Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by $x ascending return $x } </results>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy2,Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by $x descending return $x } </results>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy3,Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by concat($x,"()") ascending return concat($x,"()") } </results>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy4,Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by concat($x,"()") descending return concat($x,"()") } </results>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy5,Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> {              for $x in /DataValues/Strings/orderData              order by concat($x,"another String After") ascending              return concat($x,"another String After")          } </results>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy6,Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by concat($x,"another String After") descending              return concat($x,"another String After") } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy7,Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by concat($x,"another String Before") ascending              return concat($x,"another String Before") } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy8,Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by concat($x,"another String Before") descending              return concat($x,"another String Before") } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy9,Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by concat($x,"") descending return concat($x,"") } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy10,Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by concat($x,"") ascending              return concat($x,"") } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy11,Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by concat("",$x) descending return concat("",$x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy12,Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by concat("",$x) ascending return concat("",$x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy13,Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by concat("",$x) ascending return concat("",$x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy14,Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by $x is $x ascending return $x is $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy15,Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by $x is $x descending return $x is $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy16,Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by concat($x,$x) ascending return concat($x,$x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy17,Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by string-length($x) ascending return string-length($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy18,Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by count($x) ascending return count($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy19,Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData order by string-length($x) ascending return string-length($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy20,AssertionError: Expected executing the XPath "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by $x ascending return $x } </results>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by $x ascending return $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found., Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by $x ascending return $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found., Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by $x ascending return $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found., Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by $x ascending return $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found..
orderBy21,AssertionError: Expected executing the XPath "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by $x descending return $x } </results>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by $x descending return $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found., Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by $x descending return $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found., Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by $x descending return $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found., Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by $x descending return $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found..
orderBy22,AssertionError: Expected executing the XPath "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by ($x + $x) descending return $x + $x } </results>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by ($x + $x) descending return $x + $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found., Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by ($x + $x) descending return $x + $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found., Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by ($x + $x) descending return $x + $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found..
orderBy23,Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by $x is $x ascending return $x is $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy24,Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by $x is $x descending return $x is $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy25,AssertionError: Expected executing the XPath "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by xs:float($x) descending return xs:float($x) } </results>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by xs:float($x) descending return xs:float($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found., Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by xs:float($x) descending return xs:float($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found..
orderBy26,AssertionError: Expected executing the XPath "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by xs:decimal($x) descending return xs:decimal($x) } </results>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by xs:decimal($x) descending return xs:decimal($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found., Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by xs:decimal($x) descending return xs:decimal($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found..
orderBy27,AssertionError: Expected executing the XPath "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by xs:double($x) descending return xs:double($x) } </results>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by xs:double($x) descending return xs:double($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found., Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by xs:double($x) descending return xs:double($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found..
orderBy28,Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/NegativeNumbers/orderData order by xs:integer($x) descending return xs:integer($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy30,Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData order by $x ascending return $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy31,Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData order by $x descending return $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy32,AssertionError: Expected executing the XPath "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData order by ($x + $x) descending return $x + $x } </results>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData order by ($x + $x) descending return $x + $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found., Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData order by ($x + $x) descending return $x + $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found..
orderBy33,Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData order by $x is $x ascending return $x is $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy34,Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData order by $x is $x descending return $x is $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy35,Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData order by xs:float($x) descending return xs:float($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy36,Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData order by xs:decimal($x) descending return xs:decimal($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy37,Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData order by xs:double($x) descending return xs:double($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy38,Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData order by xs:integer($x) descending return xs:integer($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy39,Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/PositiveNumbers/orderData order by string($x) ascending return string($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy40,Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallPositiveNumbers/orderData order by $x ascending return $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy41,Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallPositiveNumbers/orderData order by $x descending return $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy42,AssertionError: Expected executing the XPath "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallPositiveNumbers/orderData order by ($x + $x) descending return $x + $x } </results>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallPositiveNumbers/orderData order by ($x + $x) descending return $x + $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found., Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallPositiveNumbers/orderData order by ($x + $x) descending return $x + $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found..
orderBy43,Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallPositiveNumbers/orderData order by $x is $x ascending return $x is $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy44,Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallPositiveNumbers/orderData order by $x is $x descending return $x is $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy45,Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallPositiveNumbers/orderData order by xs:float($x) descending return xs:float($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy46,Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallPositiveNumbers/orderData order by xs:decimal($x) descending return xs:decimal($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy47,Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallPositiveNumbers/orderData order by xs:double($x) descending return xs:double($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy49,Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallPositiveNumbers/orderData order by string($x) ascending return string($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy50,AssertionError: Expected executing the XPath "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData order by $x ascending return $x } </results>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData order by $x ascending return $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found., Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData order by $x ascending return $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found..
orderBy51,AssertionError: Expected executing the XPath "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData order by $x descending return $x } </results>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData order by $x descending return $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found., Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData order by $x descending return $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found..
orderBy53,Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData order by $x is $x ascending return $x is $x } </results>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy54,Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData order by $x is $x descending return $x is $x } </results>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy55,AssertionError: Expected executing the XPath "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData order by xs:float($x) descending return xs:float($x) } </results>       " to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData order by xs:float($x) descending return xs:float($x) } </results>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found., Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData order by xs:float($x) descending return xs:float($x) } </results>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found..
orderBy56,Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData order by xs:decimal($x) descending return xs:decimal($x) } </results>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy57,AssertionError: Expected executing the XPath "         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData order by xs:double($x) descending return xs:double($x) } </results>       " to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData order by xs:double($x) descending return xs:double($x) } </results>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found., Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData order by xs:double($x) descending return xs:double($x) } </results>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found..
orderBy59,Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/SmallNegativeNumbers/orderData order by string($x) ascending return string($x) } </results>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy60,Error: XPST0003: Unable to parse XPath:          declare base-uri "http://www.w3.org/2005/xpath-functions/";          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> { for $x in /DataValues/Strings/orderData                      order by concat($x,"()") ascending collation "collation/codepoint"                      return concat($x,"()") } </results>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.
orderBy61,Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results> {              for $x in /DataValues/Strings/orderData              order by concat($x,"()") ascending collation "http://www.w3.org/2005/xpath-functions/collation/codepoint"              return concat($x,"()") }          </results>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy62,Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results>{              for $x in /DataValues/NegativeNumbers/orderData/xs:decimal(.)              where $x > -1000              order by $x ascending collation "http://www.w3.org/2005/xpath-functions/collation/codepoint"              return $x }         </results>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy63,Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";           /DataValues/(          (            for $x in NegativeNumbers/*            order by (if (name(.) = 'orderData') then $x else -$x)            return $x          )[1]         )        . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy64,Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results>{              for $x in /DataValues/NegativeNumbers/orderData/xs:decimal(.)               order by $x ascending collation "http://www.w3.org/2005/xpath-functions/collation/codepoint"              where $x > -1000             return $x }         </results>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy65,Error: XPST0003: Unable to parse XPath:          declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          <results>{              for $x in /DataValues/NegativeNumbers/orderData/xs:decimal(.)              order by $x descending collation "http://www.w3.org/2005/xpath-functions/collation/codepoint"              order by $x ascending collation "http://www.w3.org/2005/xpath-functions/collation/codepoint"              where $x > -1000             return $x }         </results>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
orderBy66,Error: XPST0003: Unable to parse XPath: deep-equal((         declare default element namespace "http://www.w3.org/XQueryTestOrderBy";                for $i in 1 to 100             order by -$i             count $count             let $e := <e i="{$i}" pos="{$count}"/>             order by number($e/@i)             where $count gt 90             return $e!@pos!number()        ), (100, 99, 98, 97, 96, 95, 94, 93, 92, 91)). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found.
orderBy67,Error: XPST0003: Unable to parse XPath: deep-equal((          for $j in (text{'Az'}, text{'Bx'}, text{'Cy'})           order by $j/substring(., $j/string-length(.))           return $j/string()       ), ("Bx", "Cy", "Az")). SyntaxError: Expected "!", "!=", "#", "(", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
orderBy68,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n         declare variable $in := <in><e on="2017-09-18"/><e on="2016-04-15"/><e on="2012-07-09"/></in>;\n         for $j in ($in//e/@on, xs:date(\'1999-12-17\')) \n         order by $j \n         return $j\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
orderbylocal-1,Error: XPST0003: Unable to parse XPath: <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String",         "I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String",         "U String","V String","W String","X String","Y String","Z String") order by xs:string($x)          ascending return xs:string($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-2,Error: XPST0003: Unable to parse XPath: <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String",         "I String","J String","K String","L String","M String","N String","O String","P String","R String","S String",         "T String","U String","V String","W String","X String","Y String","Z String") order by xs:string($x)          descending return xs:string($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-3,Error: XPST0003: Unable to parse XPath: <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String",         "I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String",         "U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"()")          ascending return concat(xs:string($x),"()") } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-4,Error: XPST0003: Unable to parse XPath: <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"()") descending return concat(xs:string($x),"()") } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-5,Error: XPST0003: Unable to parse XPath: <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"another String After") ascending return concat(xs:string($x),"another String After") } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-6,Error: XPST0003: Unable to parse XPath: <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"another String After") descending return concat(xs:string($x),"another String After") } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-7,Error: XPST0003: Unable to parse XPath: <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat("another String Before",xs:string($x)) ascending return concat("another String Before",xs:string($x)) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-8,Error: XPST0003: Unable to parse XPath: <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat("another String Before",xs:string($x)) descending return concat("another String Before",xs:string($x)) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-9,Error: XPST0003: Unable to parse XPath: <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"") descending return concat(xs:string($x),"") } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-10,Error: XPST0003: Unable to parse XPath: <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"") ascending return concat(xs:string($x),"") } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-11,Error: XPST0003: Unable to parse XPath: <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat("",xs:string($x)) descending return concat("",xs:string($x)) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-12,Error: XPST0003: Unable to parse XPath: <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat("",xs:string($x)) ascending return concat("",xs:string($x)) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-16,Error: XPST0003: Unable to parse XPath: <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),xs:string($x)) ascending return concat(xs:string($x),xs:string($x)) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-17,Error: XPST0003: Unable to parse XPath: <results> { for $x in("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by string-length(xs:string($x)) ascending return string-length(xs:string($x)) } </results>. SyntaxError: Expected " ", "(:", "\n", "\r", or "\t" but "(" found.
orderbylocal-18,Error: XPST0003: Unable to parse XPath: <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by count(xs:string($x)) ascending return count(xs:string($x)) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-19,Error: XPST0003: Unable to parse XPath: <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by string-length(xs:string($x)) ascending return string-length(xs:string($x)) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-20,Error: XPST0003: Unable to parse XPath: <results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by xs:decimal($x) ascending return xs:decimal($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-21,Error: XPST0003: Unable to parse XPath: <results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by xs:decimal($x) descending return xs:decimal($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-22,Error: XPST0003: Unable to parse XPath: <results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by (xs:decimal($x) + xs:decimal($x)) descending return xs:decimal($x) + xs:decimal($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-25,Error: XPST0003: Unable to parse XPath: <results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by xs:float($x) descending return xs:float($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-26,Error: XPST0003: Unable to parse XPath: <results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by xs:decimal($x) descending return xs:decimal($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-27,Error: XPST0003: Unable to parse XPath: <results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by xs:double($x) descending return xs:double($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-28,Error: XPST0003: Unable to parse XPath: <results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by xs:integer($x) descending return xs:integer($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-29,Error: XPST0003: Unable to parse XPath: <results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by (xs:decimal($x) * -1) descending return (xs:decimal($x) * -1) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-30,Error: XPST0003: Unable to parse XPath: <results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by xs:decimal($x) ascending return xs:decimal($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-31,Error: XPST0003: Unable to parse XPath: <results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by xs:decimal($x) descending return xs:decimal($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-32,Error: XPST0003: Unable to parse XPath: <results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by (xs:decimal($x) + xs:decimal($x)) descending return xs:decimal($x) + xs:decimal($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-35,Error: XPST0003: Unable to parse XPath: <results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by xs:float($x) descending return xs:float($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-36,Error: XPST0003: Unable to parse XPath: <results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by xs:decimal($x) descending return xs:decimal($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-37,Error: XPST0003: Unable to parse XPath: <results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by xs:double($x) descending return xs:double($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-38,Error: XPST0003: Unable to parse XPath: <results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by xs:integer($x) descending return xs:integer($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-39,Error: XPST0003: Unable to parse XPath: <results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by string($x) ascending return string($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-40,Error: XPST0003: Unable to parse XPath: <results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) order by $x ascending return $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-41,Error: XPST0003: Unable to parse XPath: <results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) order by xs:decimal($x) descending return xs:decimal($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-42,Error: XPST0003: Unable to parse XPath: <results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) order by (xs:decimal($x) + xs:decimal($x)) descending return xs:decimal($x) + xs:decimal($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-43,Error: XPST0003: Unable to parse XPath: <results>{ for $x in (<a>0.000000000000000001</a>,<a>0.00000000000000001</a>,<a>0.0000000000000001</a>,<a>0.000000000000001</a>,<a>0.00000000000001</a>,<a>0.0000000000001</a>,<a>0.000000000001</a>,<a>0.00000000001</a>,<a>0.0000000001</a>,<a>0.000000001</a>,<a>0.00000001</a>,<a>0.0000001</a>,<a>0.000001</a>,<a>0.00001</a>,<a>0.0001</a>,<a>0.001</a>,<a>0.01</a>,<a>0.1</a>,<a>0.0</a>) order by $x is $x ascending return $x is $x}</results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-44,Error: XPST0003: Unable to parse XPath: <results>{ for $x in (<a>0.000000000000000001</a>,<a>0.00000000000000001</a>,<a>0.0000000000000001</a>,<a>0.000000000000001</a>,<a>0.00000000000001</a>,<a>0.0000000000001</a>,<a>0.000000000001</a>,<a>0.00000000001</a>,<a>0.0000000001</a>,<a>0.000000001</a>,<a>0.00000001</a>,<a>0.0000001</a>,<a>0.000001</a>,<a>0.00001</a>,<a>0.0001</a>,<a>0.001</a>,<a>0.01</a>,<a>0.1</a>,<a>0.0</a>) order by $x is $x descending return $x is $x }</results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-45,Error: XPST0003: Unable to parse XPath: <results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) order by xs:float($x) descending return xs:float($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-46,Error: XPST0003: Unable to parse XPath: <results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) order by xs:decimal($x) descending return xs:decimal($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-47,Error: XPST0003: Unable to parse XPath: <results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) order by xs:double($x) descending return xs:double($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-49,Error: XPST0003: Unable to parse XPath: <results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) order by string($x) ascending return string($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-50,Error: XPST0003: Unable to parse XPath: <results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) order by xs:decimal($x) ascending return xs:decimal($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-51,Error: XPST0003: Unable to parse XPath: <results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) order by xs:decimal($x) descending return xs:decimal($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-52,Error: XPST0003: Unable to parse XPath: <results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) order by (xs:decimal($x) + xs:decimal($x)) descending return xs:decimal($x) + xs:decimal($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-55,Error: XPST0003: Unable to parse XPath: <results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) order by xs:float($x) descending return xs:float($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-56,Error: XPST0003: Unable to parse XPath: <results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) order by xs:decimal($x) descending return xs:decimal($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-57,Error: XPST0003: Unable to parse XPath: <results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) order by xs:double($x) descending return xs:double($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-59,Error: XPST0003: Unable to parse XPath: <results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) order by string($x) ascending return string($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbylocal-60,AssertionError: expected [Function] to throw error including 'XQST0076' but got 'XPST0003: Unable to parse XPath: for $x in ("A","B","C") order by string($x) ascending collation "http://nonexistentcollition.org/ifsupportedwoooayouarethebestQueryimplementation/makeitharder" return string($x). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.'
orderbywithout-1,Error: XPST0003: Unable to parse XPath: <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by xs:string($x) return xs:string($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-2,Error: XPST0003: Unable to parse XPath: <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"()") return concat(xs:string($x),"()") } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-3,Error: XPST0003: Unable to parse XPath: <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"another String After") return concat(xs:string($x),"another String After") } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-4,Error: XPST0003: Unable to parse XPath: <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat("another String Before",xs:string($x)) return concat("another String Before",xs:string($x)) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-5,Error: XPST0003: Unable to parse XPath: <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"") return concat(xs:string($x),"") } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-6,Error: XPST0003: Unable to parse XPath: <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat("",xs:string($x)) return concat("",xs:string($x)) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-7,Error: XPST0003: Unable to parse XPath: <results> { for $x in (<a>A String</a>,<a>B String</a>,<a>C String</a>,<a>D String</a>,<a>E String</a>,<a>F String</a>,<a>G String</a>,<a>H String</a>,<a>I String</a>, <a>J String</a>,<a>K String</a>,<a>L String</a>,<a>M String</a>,<a>N String</a>,<a>O String</a>,<a>P String</a>,<a>R String</a>,<a>S String</a>,<a>T String</a>, <a>U String</a>,<a>V String</a>,<a>W String</a>,<a>X String</a>,<a>Y String</a>,<a>Z String</a>) order by $x is $x return $x is $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-8,Error: XPST0003: Unable to parse XPath: <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),xs:string($x)) return concat(xs:string($x),xs:string($x)) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-9,Error: XPST0003: Unable to parse XPath: <results> { for $x in (<a>A String</a>,<a>B String</a>,<a>C String</a>,<a>D String</a>,<a>E String</a>,<a>F String</a>,<a>G String</a>,<a>H String</a>,<a>I String</a>, <a>J String</a>,<a>K String</a>,<a>L String</a>,<a>M String</a>,<a>N String</a>,<a>O String</a>,<a>P String</a>,<a>R String</a>,<a>S String</a>,<a>T String</a>, <a>U String</a>,<a>V String</a>,<a>W String</a>,<a>X String</a>,<a>Y String</a>,<a>Z String</a>) order by string-length($x) return string-length($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-10,Error: XPST0003: Unable to parse XPath: <results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by count(xs:string($x)) return count(xs:string($x)) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-11,Error: XPST0003: Unable to parse XPath: <results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by xs:decimal($x) return xs:decimal($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-12,Error: XPST0003: Unable to parse XPath: <results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by (xs:decimal($x) + xs:decimal($x)) return xs:decimal($x) + xs:decimal($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-13,Error: XPST0003: Unable to parse XPath: <results> { for $x in (<orderData>-100000000000000000</orderData>,<orderData>-10000000000000000</orderData>,<orderData>-1000000000000000</orderData>,<orderData>-100000000000000</orderData>, <orderData>-10000000000000</orderData>,<orderData>-1000000000000</orderData>,<orderData>-100000000000</orderData>,<orderData>-10000000000</orderData>,<orderData>-1000000000</orderData>, <orderData>-100000000</orderData>,<orderData>-10000000</orderData>,<orderData>-1000000</orderData>,<orderData>-100000</orderData>,<orderData>-10000</orderData>,<orderData>-1000</orderData>, <orderData>-100</orderData>,<orderData>-10</orderData>,<orderData>-1</orderData>,<orderData>-0</orderData>) order by $x is $x return $x is $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-14,Error: XPST0003: Unable to parse XPath: <results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by xs:float($x) return xs:float($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-15,Error: XPST0003: Unable to parse XPath: <results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by xs:double($x) return xs:double($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-16,Error: XPST0003: Unable to parse XPath: <results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by xs:integer($x) return xs:integer($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-17,Error: XPST0003: Unable to parse XPath: <results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by (xs:decimal($x) * -1) return (xs:decimal($x) * -1) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-18,Error: XPST0003: Unable to parse XPath: <results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by xs:decimal($x) return xs:decimal($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-19,Error: XPST0003: Unable to parse XPath: <results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by (xs:decimal($x) + xs:decimal($x)) return xs:decimal($x) + xs:decimal($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-20,Error: XPST0003: Unable to parse XPath: <results> { for $x in (<orderData>100000000000000000</orderData>,<orderData>10000000000000000</orderData>,<orderData>1000000000000000</orderData>, <orderData>100000000000000</orderData>,<orderData>10000000000000</orderData>,<orderData>1000000000000</orderData>,<orderData>100000000000</orderData>, <orderData>10000000000</orderData>,<orderData>1000000000</orderData>,<orderData>100000000</orderData>,<orderData>10000000</orderData>, <orderData>1000000</orderData>,<orderData>100000</orderData>,<orderData>10000</orderData>,<orderData>1000</orderData>,<orderData>100</orderData>, <orderData>10</orderData>,<orderData>1</orderData>,<orderData>0</orderData>) order by $x is $x return $x is $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-21,Error: XPST0003: Unable to parse XPath: <results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by xs:float($x) return xs:float($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-22,Error: XPST0003: Unable to parse XPath: <results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by xs:decimal($x) return xs:decimal($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-23,Error: XPST0003: Unable to parse XPath: <results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by xs:double($x) return xs:double($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-24,Error: XPST0003: Unable to parse XPath: <results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by xs:integer($x) return xs:integer($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-25,Error: XPST0003: Unable to parse XPath: <results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by string($x) return string($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-26,Error: XPST0003: Unable to parse XPath: <results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) order by $x return $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-27,Error: XPST0003: Unable to parse XPath: <results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) order by xs:decimal($x) return xs:decimal($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-28,Error: XPST0003: Unable to parse XPath: <results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) order by (xs:decimal($x) + xs:decimal($x)) return xs:decimal($x) + xs:decimal($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-29,Error: XPST0003: Unable to parse XPath: <results> { for $x in (<orderData>0.000000000000000001</orderData>,<orderData>0.00000000000000001</orderData>,<orderData>0.0000000000000001</orderData>,<orderData>0.000000000000001</orderData>, <orderData>0.00000000000001</orderData>,<orderData>0.0000000000001</orderData>,<orderData>0.000000000001</orderData>,<orderData>0.00000000001</orderData>,<orderData>0.0000000001</orderData>, <orderData>0.000000001</orderData>,<orderData>0.00000001</orderData>,<orderData>0.0000001</orderData>,<orderData>0.000001</orderData>,<orderData>0.00001</orderData>, <orderData>0.0001</orderData>,<orderData>0.001</orderData>,<orderData>0.01</orderData>,<orderData>0.1</orderData>,<orderData>0.0</orderData>) order by $x is $x return $x is $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-30,Error: XPST0003: Unable to parse XPath: <results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) order by xs:float($x) return xs:float($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-31,Error: XPST0003: Unable to parse XPath: <results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) order by xs:decimal($x) return xs:decimal($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-32,Error: XPST0003: Unable to parse XPath: <results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) order by xs:double($x) return xs:double($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-33,Error: XPST0003: Unable to parse XPath: <results> { for $x in (0.000000000000000001,0.00000000000000001,0.0000000000000001,0.000000000000001,0.00000000000001,0.0000000000001,0.000000000001,0.00000000001,0.0000000001,0.000000001,0.00000001,0.0000001,0.000001,0.00001,0.0001,0.001,0.01,0.1,0.0) order by string($x) return string($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-34,Error: XPST0003: Unable to parse XPath: <results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) order by xs:decimal($x) return xs:decimal($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-35,Error: XPST0003: Unable to parse XPath: <results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) order by (xs:decimal($x) + xs:decimal($x)) return xs:decimal($x) + xs:decimal($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-36,Error: XPST0003: Unable to parse XPath: <results> { for $x in (<orderData>-0.000000000000000001</orderData>,<orderData>-0.00000000000000001</orderData>,<orderData>-0.0000000000000001</orderData>,<orderData>-0.000000000000001</orderData>,<orderData>-0.00000000000001</orderData>,<orderData>-0.0000000000001</orderData>, <orderData>-0.000000000001</orderData>,<orderData>-0.00000000001</orderData>,<orderData>-0.0000000001</orderData>,<orderData>-0.000000001</orderData>, <orderData>-0.00000001</orderData>,<orderData>-0.0000001</orderData>,<orderData>-0.000001</orderData>,<orderData>-0.00001</orderData>,<orderData>-0.0001</orderData>,<orderData>-0.001</orderData>,<orderData>-0.01</orderData>,<orderData>-0.0</orderData>, <orderData>-0.1</orderData>) order by $x is $x return $x is $x } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-37,Error: XPST0003: Unable to parse XPath: <results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) order by xs:float($x) return xs:float($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-38,Error: XPST0003: Unable to parse XPath: <results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) order by xs:decimal($x) return xs:decimal($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-39,Error: XPST0003: Unable to parse XPath: <results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) order by xs:double($x) return xs:double($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
orderbywithout-40,Error: XPST0003: Unable to parse XPath: <results> { for $x in (-0.000000000000000001,-0.00000000000000001,-0.0000000000000001,-0.000000000000001,-0.00000000000001,-0.0000000000001,-0.000000000001,-0.00000000001,-0.0000000001,-0.000000001,-0.00000001,-0.0000001,-0.000001,-0.00001,-0.0001,-0.001,-0.01,-0.0,-0.1) order by string($x) return string($x) } </results>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
K2-OrderbyExprWithout-1,Error: XPST0003: Unable to parse XPath: (declare base-uri "http://www.w3.org/2005/xpath-functions/"; let $i as xs:integer* := (1, 2, 3) order by 1 collation "collation/codepoint" return $i)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "b" found.
K2-OrderbyExprWithout-2,AssertionError: expected [Function] to throw error including 'XQST0076' but got 'XPST0003: Unable to parse XPath: declare base-uri "http://www.w3.org/2005/xpath-functions/"; let $i as xs:integer* := (1, 2, 3) order by 1 collation "collation/" return $i. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.'
K2-OrderbyExprWithout-3,AssertionError: expected [Function] to throw error including 'XQST0076' but got 'XPST0003: Unable to parse XPath: declare base-uri "http://www.w3.org/2005/xpath-functions/"; let $i as xs:integer* := (1, 2, 3) order by 1 collation "collation/" return $i. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.'
K2-OrderbyExprWithout-5,Error: XPST0003: Unable to parse XPath: (for $i in (1, 3, 2) order by $i return $i)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
K2-OrderbyExprWithout-6,Error: XPST0003: Unable to parse XPath: (for $i in (1, 3, 2) order by $i return ($i, 2))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
K2-OrderbyExprWithout-8,AssertionError: Expected executing the XPath "let $i := (1, 3, 2) order by $i return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (let $i := (1, 3, 2) order by $i return $i)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: let $i := (1, 3, 2) order by $i return $i. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.'.
K2-OrderbyExprWithout-9,AssertionError: Expected executing the XPath "let $i := (1, 3, 2), $b := (4, 6, 5) order by $b return $b" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (let $i := (1, 3, 2), $b := (4, 6, 5) order by $b return $b)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: let $i := (1, 3, 2), $b := (4, 6, 5) order by $b return $b. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.'.
K2-OrderbyExprWithout-10,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: for $a in (1, 4, 2) let $i := (1, $a, 2) order by $i return $i. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.'
K2-OrderbyExprWithout-11,Error: XPST0003: Unable to parse XPath: (for $a in (1, 4, 2) let $i := (1, 3, 2) order by $a return $i)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
K2-OrderbyExprWithout-12,Error: XPST0003: Unable to parse XPath: (for $a in (3, 2, 1), $b in (6, 5, 4) order by $a return $a)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
K2-OrderbyExprWithout-13,Error: XPST0003: Unable to parse XPath: (for $a in (3, 2, 1), $b in (6, 5, 4) stable order by $b return $a)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found.
K2-OrderbyExprWithout-14,Error: XPST0003: Unable to parse XPath: declare variable $e := <e> <a>3</a> <a>2</a> <a>1</a> </e>; <result> { avg(for $i in $e/a order by $i return $i) } </result>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-OrderbyExprWithout-15,AssertionError: expected [Function] to throw error including 'FORG0005' but got 'XPST0003: Unable to parse XPath: declare variable $e := <e> <a>3</a> <a>2</a> <a>1</a> </e>; exactly-one(for $i in $e/a order by $i return $i). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-OrderbyExprWithout-16,Error: XPST0003: Unable to parse XPath: (for $i in (false(), true(), true(), false(), true(), false()) order by $i return $i)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
K2-OrderbyExprWithout-17,Error: XPST0003: Unable to parse XPath: boolean((for $i in (false(), true(), true(), false(), true(), false()) order by $i return $i)[1]). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
K2-OrderbyExprWithout-18,Error: XPST0003: Unable to parse XPath: (for $i in current-time() order by $i return $i) eq current-time(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
K2-OrderbyExprWithout-19,AssertionError: Expected executing the XPath "let $i := (1, 3, 2) order by $i return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (let $i := (1, 3, 2) order by $i return $i)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: let $i := (1, 3, 2) order by $i return $i. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.'.
K2-OrderbyExprWithout-20,AssertionError: Expected executing the XPath "let $i := (<e>1</e>, <e>3</e>, <e>2</e>) order by $i return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: let $i := (<e>1</e>, <e>3</e>, <e>2</e>) order by $i return $i. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: let $i := (<e>1</e>, <e>3</e>, <e>2</e>) order by $i return $i. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.'.
K2-OrderbyExprWithout-21,Error: XPST0003: Unable to parse XPath: let $i := (<e>1</e>, <e>3</e>, <e>2</e>) order by 1 return $i. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
K2-OrderbyExprWithout-22,AssertionError: Expected executing the XPath "for $i in (1, 3, 2) let $c := 3 stable order by () return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (for $i in (1, 3, 2) let $c := 3 stable order by () return $i)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found., Error: XPST0003: Unable to parse XPath: (for $i in (1, 3, 2) let $c := 3 stable order by () return $i)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: for $i in (1, 3, 2) let $c := 3 stable order by () return $i. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.'.
K2-OrderbyExprWithout-23,AssertionError: Expected executing the XPath "let $i := (1, 3, 2) stable order by $i return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (let $i := (1, 3, 2) stable order by $i return $i)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: let $i := (1, 3, 2) stable order by $i return $i. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found.'.
K2-OrderbyExprWithout-24,AssertionError: Expected executing the XPath "let $i := (<e>1</e>, <e>3</e>, <e>2</e>) stable order by $i return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: let $i := (<e>1</e>, <e>3</e>, <e>2</e>) stable order by $i return $i. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: let $i := (<e>1</e>, <e>3</e>, <e>2</e>) stable order by $i return $i. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found.'.
K2-OrderbyExprWithout-25,AssertionError: Expected executing the XPath "let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) stable order by $i return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) stable order by $i return $i)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) stable order by $i return $i. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found.'.
K2-OrderbyExprWithout-26,AssertionError: Expected executing the XPath "let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) order by $i return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) order by $i return $i)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) order by $i return $i. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.'.
K2-OrderbyExprWithout-27,AssertionError: Expected executing the XPath "let $i := (xs:date("2001-02-03"), xs:time("01:02:03Z")) stable order by $i return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (let $i := (xs:date("2001-02-03"), xs:time("01:02:03Z")) stable order by $i return $i)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: let $i := (xs:date("2001-02-03"), xs:time("01:02:03Z")) stable order by $i return $i. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found.'.
K2-OrderbyExprWithout-28,AssertionError: Expected executing the XPath "let $i := (xs:date("2001-02-03"), xs:time("01:02:03Z")) order by $i return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (let $i := (xs:date("2001-02-03"), xs:time("01:02:03Z")) order by $i return $i)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: let $i := (xs:date("2001-02-03"), xs:time("01:02:03Z")) order by $i return $i. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.'.
K2-OrderbyExprWithout-29,AssertionError: Expected executing the XPath "<r> { for $i in attribute name {()} order by () return () } </r>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: <r> { for $i in attribute name {()} order by () return () } </r>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "n" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: <r> { for $i in attribute name {()} order by () return () } </r>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "n" found.'.
K2-OrderbyExprWithout-30,AssertionError: Expected executing the XPath "<r> { for $i in 1 order by () return () } </r>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: <r> { for $i in 1 order by () return () } </r>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: <r> { for $i in 1 order by () return () } </r>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.'.
K2-OrderbyExprWithout-31,AssertionError: Expected executing the XPath "let $i := (1, 2, 3) order by $i return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (let $i := (1, 2, 3) order by $i return $i)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: let $i := (1, 2, 3) order by $i return $i. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.'.
K2-OrderbyExprWithout-32,AssertionError: Expected executing the XPath "let $i := (1, 2, 3) stable order by $i return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (let $i := (1, 2, 3) stable order by $i return $i)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: let $i := (1, 2, 3) stable order by $i return $i. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found.'.
K2-OrderbyExprWithout-33,AssertionError: Expected executing the XPath "let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) stable order by $i[1] return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) stable order by $i[1] return $i)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) stable order by $i[1] return $i. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found.'.
K2-OrderbyExprWithout-34,AssertionError: Expected executing the XPath "let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) order by $i[1] return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) order by $i[1] return $i)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) order by $i[1] return $i. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.'.
K2-OrderbyExprWithout-35,AssertionError: Expected executing the XPath "let $i := (xs:hexBinary("FF"), xs:time("03:03:03Z"), xs:hexBinary("FF")) stable order by $i[1] return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (let $i := (xs:hexBinary("FF"), xs:time("03:03:03Z"), xs:hexBinary("FF")) stable order by $i[1] return $i)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: let $i := (xs:hexBinary("FF"), xs:time("03:03:03Z"), xs:hexBinary("FF")) stable order by $i[1] return $i. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found.'.
K2-OrderbyExprWithout-36,AssertionError: Expected executing the XPath "let $i := (xs:hexBinary("FF"), xs:time("03:03:03Z"), xs:hexBinary("FF")) order by $i[1] return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (let $i := (xs:hexBinary("FF"), xs:time("03:03:03Z"), xs:hexBinary("FF")) order by $i[1] return $i)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: let $i := (xs:hexBinary("FF"), xs:time("03:03:03Z"), xs:hexBinary("FF")) order by $i[1] return $i. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.'.
K2-OrderbyExprWithout-37,AssertionError: Expected executing the XPath "for $i in (1, 3, 2) stable order by () return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (for $i in (1, 3, 2) stable order by () return $i)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found., Error: XPST0003: Unable to parse XPath: (for $i in (1, 3, 2) stable order by () return $i)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: for $i in (1, 3, 2) stable order by () return $i. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found.'.
K2-OrderbyExprWithout-38,Error: XPST0003: Unable to parse XPath: (for $i in (1, 2, 3) stable order by 1 return reverse(($i, "FO")))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found.
K2-OrderbyExprWithout-39,AssertionError: Expected executing the XPath "for $a in (1, 4, 2) let $i := (1, 3, 2) order by $i return 1" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (for $a in (1, 4, 2) let $i := (1, 3, 2) order by $i return 1)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: for $a in (1, 4, 2) let $i := (1, 3, 2) order by $i return 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.'.
K2-OrderbyExprWithout-40,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: for $a in (3, 2, 1) let $a := ($a, 1), $b := (2, 1), $c := (2, 1), $d:= (2, 1) order by $a return $a. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.'
K2-OrderbyExprWithout-41,Error: XPST0003: Unable to parse XPath: (for $a in (3, 2, 1) let $b := (2, 1), $c := (2, 1), $d := (2, 1), $e := (2, 1) order by $a return $a)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
K2-OrderbyExprWithout-42,Error: XPST0003: Unable to parse XPath: (string(for $i in current-date() order by $i return $i)) => count(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
K2-OrderbyExprWithout-43,Error: XPST0003: Unable to parse XPath: (if(for $i in <e> <a id="3"/> <b id="2"/> <c id="1"/> </e>/* order by xs:integer($i/@id) return $i) then 4 else 9) = (4). SyntaxError: Expected " ", "!", "!=", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
K2-OrderbyExprWithout-44,Error: XPST0003: Unable to parse XPath: (for $a in (2, 1) let $b := 1 where true() order by $a return $a)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
K2-OrderbyExprWithout-45,Error: XPST0003: Unable to parse XPath: (for $a in (3, 2, 1), $b in (6) stable order by $b return $a)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found.
K2-OrderbyExprWithout-46,Error: XPST0003: Unable to parse XPath: (let $numbers := (1, 2, 1.3, 3e3, xs:double("NaN"), xs:double("-INF"), xs:double("INF")) return (for $i in $numbers order by $i empty least return $i, "SEP", for $i in $numbers order by $i empty greatest return $i))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
K2-OrderbyExprWithout-47,Error: XPST0003: Unable to parse XPath: (let $numbers := (1, 2, 1.3, 3e3, xs:double("NaN"), xs:double("-INF"), xs:double("INF")) return (for $i in $numbers stable order by $i empty least return $i, "SEP", for $i in $numbers order by $i empty greatest return $i))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "s" found.
K2-OrderbyExprWithout-48,Error: XPST0003: Unable to parse XPath: (let $numbers := (<e>NaN</e>, <e/>, <e/>, <e>NaN</e>, <e>NaN</e>, <e>INF</e>, <e>NaN</e>, <e/>, <e>3</e>, comment{"3"}) return (for $i in $numbers order by xs:double($i/text()) empty least return xs:double($i/text()), "SEP", for $i in $numbers order by xs:double($i/text()) empty greatest return xs:double($i/text())))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "#", "(", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
K2-OrderbyExprWithout-49,Error: XPST0003: Unable to parse XPath: (let $numbers := (<e>NaN</e>, <e/>, <e/>, <e>NaN</e>, <e>NaN</e>, <e>INF</e>, <e>NaN</e>, <e/>, <e>3</e>, comment{"3"}) return (for $i in $numbers stable order by xs:double($i/text()) empty least return xs:double($i/text()), "SEP", for $i in $numbers stable order by xs:double($i/text()) empty greatest return xs:double($i/text())))!string() => string-join(" "). SyntaxError: Expected "!", "!=", "#", "(", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
PathExprErr-2,AssertionError: expected [Function] to throw error including 'XPTY0018' but got 'XPST0017: Function data with arity of 1 not registered. No similar functions found.'
PathExpr-5,AssertionError: expected [Function] to throw an error
PathExpr-7,AssertionError: expected [Function] to throw an error
PathExpr-8,AssertionError: expected [Function] to throw an error
PathExpr-9,AssertionError: expected [Function] to throw an error
Parenexpr-11,Error: XPST0003: Unable to parse XPath: ((for $x in (1) where (fn:true()) order by ($x) return ($x))) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.
K-ForExprPositionalVar-1,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'XPST0003: Unable to parse XPath: for $a at $p in (1, 2) return 1, $p. SyntaxError: Expected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.'
K-ForExprPositionalVar-2,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'XPST0003: Unable to parse XPath: for $a at $p1 in (1, 2), $b at $p2 in (1, 2), $c at $p3 in (1, 2) return 1, $p1. SyntaxError: Expected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.'
K-ForExprPositionalVar-3,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'XPST0003: Unable to parse XPath: for $a at $p1 in (1, 2), $b at $p2 in (1, 2), $c at $p3 in (1, 2) return 1, $p2. SyntaxError: Expected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.'
K-ForExprPositionalVar-4,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'XPST0003: Unable to parse XPath: for $a at $p1 in (1, 2), $b at $p2 in (1, 2), $c at $p3 in (1, 2) return 1, $p3. SyntaxError: Expected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.'
K-ForExprPositionalVar-6,Error: XPST0003: Unable to parse XPath: deep-equal((1, 2, 3), for $i at $p in (1, 2, 3) return $p). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
K-ForExprPositionalVar-7,Error: XPST0003: Unable to parse XPath: deep-equal((true(), true()), for $i at $p in (1, 2) return boolean($p)). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
K-ForExprPositionalVar-8,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: for $i at $p in (1, 2, 3) return $p + "1". SyntaxError: Expected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.'
K-ForExprPositionalVar-9,Error: XPST0003: Unable to parse XPath: deep-equal((1, 2, 3), for $i at $p in string-to-codepoints("abc") return $p). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
K-ForExprPositionalVar-10,Error: XPST0003: Unable to parse XPath: deep-equal((1, 2, 3), for $i at $p in distinct-values((1, 2, 3, 1, 2)) return $p). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
K-ForExprPositionalVar-11,AssertionError: Expected executing the XPath "empty(for $i at $p in () return $p)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: empty(for $i at $p in () return $p). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: empty(for $i at $p in () return $p). SyntaxError: Expected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.'.
K-ForExprPositionalVar-12,Error: XPST0003: Unable to parse XPath: deep-equal((1, 2, 3, 4), for $i at $p in insert-before((1, current-time()), 13, (current-date(), 3)) return $p). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
K-ForExprPositionalVar-13,Error: XPST0003: Unable to parse XPath: deep-equal((1, 2, 3, 4), for $i at $p in insert-before((1, current-time()), 1, (current-date(), 3)) return $p). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
K-ForExprPositionalVar-14,Error: XPST0003: Unable to parse XPath: deep-equal((1, 2, 3, 4), for $i at $p in insert-before((1, current-time()), 2, (current-date(), 3)) return $p). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
K-ForExprPositionalVar-15,Error: XPST0003: Unable to parse XPath: deep-equal((1, 2, 3, 4), for $i at $p in 1 to 4 return $p). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
K-ForExprPositionalVar-16,Error: XPST0003: Unable to parse XPath: deep-equal((1, 2, 3, 4), for $i at $p in -10 to -7 return $p). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
K-ForExprPositionalVar-17,Error: XPST0003: Unable to parse XPath: deep-equal((1, 2, 3), for $i at $p in remove((1, 2, 3, current-time()), 2) return $p). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
K-ForExprPositionalVar-18,Error: XPST0003: Unable to parse XPath: deep-equal((1, 2, 3), for $i at $p in remove((1, 2, 3, current-time()), 4) return $p). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
K-ForExprPositionalVar-19,Error: XPST0003: Unable to parse XPath: deep-equal((1, 2, 3), for $i at $p in remove((1, 2, current-time()), 10) return $p). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
K-ForExprPositionalVar-20,Error: XPST0003: Unable to parse XPath: deep-equal((1, 2, 3), for $i at $p in remove((1, 2, current-time()), 0) return $p). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
K-ForExprPositionalVar-21,Error: XPST0003: Unable to parse XPath: deep-equal((1, 2, 3), for $i at $p in remove((1, 2, 3, current-time()), 1) return $p). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
K-ForExprPositionalVar-22,Error: XPST0003: Unable to parse XPath: deep-equal((1, 2, 3), for $i at $p in remove((1, 2, 3, current-time()), 3) return $p). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
K-ForExprPositionalVar-23,Error: XPST0003: Unable to parse XPath: 1 eq (for $i at $p in subsequence((1, 2, 3, current-time()), 1, 1) return $p). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
K-ForExprPositionalVar-24,AssertionError: Expected executing the XPath "empty(for $i at $p in subsequence((1, 2, 3, current-time()), 5) return $p)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: empty(for $i at $p in subsequence((1, 2, 3, current-time()), 5) return $p). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: empty(for $i at $p in subsequence((1, 2, 3, current-time()), 5) return $p). SyntaxError: Expected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.'.
K-ForExprPositionalVar-25,AssertionError: Expected executing the XPath "empty(for $i at $p in subsequence((1, 2, 3, current-time()), 5, 8) return $p)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: empty(for $i at $p in subsequence((1, 2, 3, current-time()), 5, 8) return $p). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: empty(for $i at $p in subsequence((1, 2, 3, current-time()), 5, 8) return $p). SyntaxError: Expected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.'.
K-ForExprPositionalVar-26,Error: XPST0003: Unable to parse XPath: deep-equal((1, 2), for $i at $p in subsequence((1, 2, 3, current-time()), 3, 2) return $p). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
K-ForExprPositionalVar-27,Error: XPST0003: Unable to parse XPath: deep-equal((1, 2), for $i at $p in subsequence((1, 2, 3, current-time()), 1, 2) return $p). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
K-ForExprPositionalVar-28,Error: XPST0003: Unable to parse XPath: deep-equal((1, 2), for $i at $p in subsequence((1, 2, 3, current-time()), 2, 2) return $p). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
K-ForExprPositionalVar-29,Error: XPST0003: Unable to parse XPath: 1 eq (for $i at $p in 0 return $p). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
K-ForExprPositionalVar-30,Error: XPST0003: Unable to parse XPath: deep-equal(for $i at $p in (1, 2, 3, 4) return ($i, $p), (1, 1, 2, 2, 3, 3, 4, 4)). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
K2-ForExprPositionalVar-1,Error: XPST0003: Unable to parse XPath: (for $i at $p in remove((1, 2, 3), 10) return $p)!string() => string-join(" "). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
K2-ForExprPositionalVar-2,AssertionError: Expected executing the XPath "let $tree := <e> <a id="1"/> <a id="2"/> <a id="3"/> </e> for $i at $pos in ("a", "b", "c") return ($tree/@id eq $pos, $pos)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (let $tree := <e> <a id="1"/> <a id="2"/> <a id="3"/> </e> for $i at $pos in ("a", "b", "c") return ($tree/@id eq $pos, $pos))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: let $tree := <e> <a id="1"/> <a id="2"/> <a id="3"/> </e> for $i at $pos in ("a", "b", "c") return ($tree/@id eq $pos, $pos). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found.'.
K2-ForExprPositionalVar-3,Error: XPST0003: Unable to parse XPath: (let $tree := <e> <a id="1"/> <a id="2"/> <a id="3"/> </e> for $i at $pos in ("a", "b", "c") return ($tree/a/@id = $pos, $pos))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found.
K2-ForExprPositionalVar-4,Error: XPST0003: Unable to parse XPath: (for $i at $pos in (3 to 6) let $let := $pos + 1 return ($let, $let - 1))!string() => string-join(" "). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
K-FilterExpr-4,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'Atomizing array(*) is not implemented.'
K-FilterExpr-5,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'Atomizing array(*) is not implemented.'
K-FilterExpr-36,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-FilterExpr-51,AssertionError: Expected executing the XPath "((0, 1, 2, "a", "b", "c")[. instance of xs:string][. treat as xs:string eq "c"] treat as xs:string) eq "c"" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: ((0, 1, 2, "a", "b", "c")[. instance of xs:string][. treat as xs:string eq "c"] treat as xs:string) eq "c". SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "]", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found., AssertionError: expected [Function] to throw error including 'XPDY0050' but got 'XPST0003: Unable to parse XPath: ((0, 1, 2, "a", "b", "c")[. instance of xs:string][. treat as xs:string eq "c"] treat as xs:string) eq "c". SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "]", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.'.
K-FilterExpr-52,AssertionError: Expected executing the XPath "((0, 1, 2, "a", "b", "c")[. instance of xs:integer][. treat as xs:integer eq 0] treat as xs:integer) eq 0" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: ((0, 1, 2, "a", "b", "c")[. instance of xs:integer][. treat as xs:integer eq 0] treat as xs:integer) eq 0. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "]", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found., AssertionError: expected [Function] to throw error including 'XPDY0050' but got 'XPST0003: Unable to parse XPath: ((0, 1, 2, "a", "b", "c")[. instance of xs:integer][. treat as xs:integer eq 0] treat as xs:integer) eq 0. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "]", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.'.
K-FilterExpr-59,AssertionError: Expected executing the XPath "empty(()[count(remove((current-time(), 1), 1)) eq 1])" to resolve to one of the expected results, but got Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0017: Function current-time with arity of 0 not registered. No similar functions found.'.
K-FilterExpr-86,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-FilterExpr-87,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-FilterExpr-88,AssertionError: Expected executing the XPath "empty(remove((1, 2, 3, current-time()), 4)[false()])" to resolve to one of the expected results, but got Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0017: Function current-time with arity of 0 not registered. No similar functions found.'.
K-FilterExpr-89,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-FilterExpr-92,AssertionError: expected [Function] to throw an error
K-FilterExpr-93,AssertionError: expected [Function] to throw an error
K-FilterExpr-96,Error: XPST0003: Unable to parse XPath: (          document{<works>{/tail(works/employee)}</works>}/works/employee[@name=/works/employee[2]/@name]/@name/string()          ) = ("Jane Doe 3"). SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
K2-FilterExpr-1,Error: XPST0003: Unable to parse XPath: declare variable $var := (for $i in 1 to 100 return <e>{$i}</e>); $var[last()]. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-FilterExpr-2,Error: XPST0003: Unable to parse XPath: declare variable $var := (for $i in 1 to 100 return <e>{$i}</e>); $var[5]. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-FilterExpr-5,AssertionError: Expected executing the XPath "          let $d := document {<root><child type=""/></root>}           return document{$d//*[let $i := @type return $d//*[$i]], (1, 2, 3)[true()], (4, 5, 6)[false()]}        " to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath:           let $d := document {<root><child type=""/></root>}           return document{$d//*[let $i := @type return $d//*[$i]], (1, 2, 3)[true()], (4, 5, 6)[false()]}        . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: \n         let $d := document {<root><child type=""/></root>} \n         return document{$d//*[let $i := @type return $d//*[$i]], (1, 2, 3)[true()], (4, 5, 6)[false()]}\n       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found.'.
K2-FilterExpr-6,Error: XPST0003: Unable to parse XPath: let $d := document { <root><child type=""/></root> } return $d//*[let $i := @type return $d//*[$i]]. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "{" found.
K2-FilterExpr-8,AssertionError: expected [Function] to throw error including 'XPDY0050' but got 'XPST0003: Unable to parse XPath: (<?z?>, <?y?>)[self::processing-instruction(y)] treat as empty-sequence(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "t" found.'
predicates-14,AssertionError: Expected XPath (/root/date[xs:date(.) = xs:date("2000-01-01+05:00")]) to resolve to the given XML. Expected  to equal <date>2000-01-01+05:00</date>
predicates-29,AssertionError: expected [Function] to throw an error
predicates-30,Error: XPST0017: Function fn:data with arity of 1 not registered. Did you mean "xs:date (xs:anyAtomicType?)"?
predicates-31,Error: XPST0017: Function fn:data with arity of 1 not registered. Did you mean "xs:date (xs:anyAtomicType?)"?
predicates-32,Error: XPST0003: Unable to parse XPath: (         declare variable $i := ("x", 1);         declare variable $j := $i[position() ne 1];         $i[$j]             ) = ("x"). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
predicatesns-14,AssertionError: Expected XPath (/root/date[xs:date(.) = xs:date("2000-01-01+05:00")]) to resolve to the given XML. Expected  to equal <date>2000-01-01+05:00</date>
K2-Predicates-1,Error: XPST0003: Unable to parse XPath: ("c"[. treat as xs:string])!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "]", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.
K2-Predicates-2,Error: XPST0003: Unable to parse XPath: declare variable $myvar := <elem> <a/> <b/> <c/></elem>; $myvar/*[last()]. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-Predicates-3,Error: XPST0003: Unable to parse XPath: declare variable $myvar := <elem> <a/> <b/> <c/></elem>; $myvar/*[last() - 1]. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-Predicates-4,Error: XPST0003: Unable to parse XPath: declare variable $myvar := <elem> <a/> <b/> <c/></elem>; $myvar/*[1]. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-Predicates-8,Error: XPST0003: Unable to parse XPath: declare function local:foo($arg as item()) { $arg[@arg] }; local:foo(<e arg="">result</e>). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
K2-Predicates-9,Error: XPST0003: Unable to parse XPath: (declare function local:foo($arg as item()) { string($arg/@arg) }; local:foo(<e arg="result"/>))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-filterexpr-001,Error: XPST0003: Unable to parse XPath: (       	declare function local:nan() { xs:float("NaN") };        	(1 to 10)[not(position() < xs:float("NaN"))]       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-first-in-sequence-001,Error: XPST0003: Unable to parse XPath: (declare function local:generate($arg as xs:integer?) { if ($arg = 0) then (1, 2, 3) else () }; ( local:generate(0), 1, local:generate(0) )[1])!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-first-in-sequence-002,Error: XPST0003: Unable to parse XPath: (declare function local:generate($arg as xs:integer?) as xs:integer* { if ($arg = 0) then (1, 2, 3) else $arg }; ( local:generate(()), for $x in local:generate(0) return $x + 2 )[1])!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-first-in-sequence-003,Error: XPST0003: Unable to parse XPath: (declare function local:generate($arg as xs:integer?) as xs:integer? { if ($arg = 0) then 0 else () }; ( local:generate(()), for $x in local:generate(0) return $x + 2 )[1])!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-first-in-sequence-004,Error: XPST0003: Unable to parse XPath: (declare function local:generate($arg as xs:integer?) as xs:integer* { if ($arg = 0) then ( 1, 2, 3 ) else ( $arg ) }; ( local:generate(()), for $x at $p in local:generate(0) return $p + $x)[1])!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-first-in-sequence-005,Error: XPST0003: Unable to parse XPath: (declare function local:generate($arg as xs:integer?) as xs:integer? { if ($arg = 0) then 1 else $arg }; ( local:generate(()), for $x at $p in local:generate(0) return $p + $x)[1])!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-first-in-sequence-006,Error: XPST0003: Unable to parse XPath: (declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then ('a', 'b', 'c') else ('d' ) }; ( if (local:generate(1) = 'd') then () else 1, for $x in local:generate(0) return fn:lower-case($x))[1])!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-first-in-sequence-007,Error: XPST0003: Unable to parse XPath: (declare function local:generate($arg as xs:integer?) as xs:integer? { $arg }; ( if (local:generate(0) = 0) then () else 1, for $x in local:generate(0) return -$x)[1])!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-first-in-sequence-009,Error: XPST0003: Unable to parse XPath: (declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then ('a', 'b', 'c') else () }; ( local:generate(()), for $x in local:generate(0) return 3)[1])!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
cbcl-first-in-sequence-010,Error: XPST0003: Unable to parse XPath: declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then ('a', 'b', 'c') else () }; boolean(local:generate(0)[1]). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-first-in-sequence-011,Error: XPST0003: Unable to parse XPath: declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then ('a', 'b', 'c') else () }; boolean(local:generate(1)[1]). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
cbcl-first-in-sequence-012,Error: XPST0003: Unable to parse XPath: (declare function local:generate($arg as xs:boolean) as xs:string+ { if ($arg) then ('a', 'b', 'c') else ('A', 'B', 'C') }; ( for $x in local:generate(true()) return 3)[1])!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
quantExpr-29,AssertionError: Expected XPath some $x in ("1980-05-05T13:13:13Z", "1980-05-05T13:13:13Z"), $y in ("1980-05-05T13:13:13Z","1980-05-05T13:13:13Z") satisfies xs:dateTime($x) = xs:dateTime($y) to resolve to true: expected false to be true
quantExpr-30,AssertionError: Expected XPath some $x in ("1985-07-05Z", "1985-07-05Z"), $y in ("1985-07-05Z","1985-07-05Z") satisfies xs:date($x) = xs:date($y) to resolve to true: expected false to be true
quantexpr-59,AssertionError: Expected XPath every $x in ("1980-05-05T13:13:13Z", "1980-05-05T13:13:13Z"), $y in ("1980-05-05T13:13:13Z","1980-05-05T13:13:13Z") satisfies xs:dateTime($x) = xs:dateTime($y) to resolve to true: expected false to be true
quantExpr-60,AssertionError: Expected XPath every $x in ("1985-07-05Z", "1985-07-05Z"), $y in ("1985-07-05Z","1985-07-05Z") satisfies xs:date($x) = xs:date($y) to resolve to true: expected false to be true
quantexpr-61,Error: XPST0003: Unable to parse XPath: some $x as xs:integer in (1, 2, 3) , $y as xs:integer in (2, 3, 4) satisfies $x + $y = 4. SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
quantexpr-62,Error: XPST0003: Unable to parse XPath: some $x as xs:string in ("cat","dog","rat") satisfies fn:string-length($x) = 3. SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
quantexpr-63,Error: XPST0003: Unable to parse XPath: every $x as xs:string in ("cat","dog","rat") satisfies fn:string-length($x) = 3. SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
quantexpr-64,Error: XPST0003: Unable to parse XPath: every $x as xs:string in ("cat","dog","rat"), $y as xs:integer in (3, 3, 3) satisfies fn:string-length($x) = $y. SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
quantexpr-65,Error: XPST0003: Unable to parse XPath: some $x as xs:integer in (1, 2, 3), $y as xs:float in (xs:float(2), xs:float(3)) satisfies $x + $y = 5. SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
quantexpr-66,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare function local:f($x, $y) {\n          let $a := $x\n          where empty($y)   (every $i in $x satisfies $i = $y)\n          return $a\n        };\n        local:f("x", ())\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
quantexpr-67,Error: XPST0003: Unable to parse XPath: (         declare function local:f($x, $y) {             let $a := $x             where (every $i in $x satisfies $i = $y) or empty($y)             return $a         };         local:f("x", ())       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
quantexpr-68,Error: XPST0003: Unable to parse XPath:          declare function local:f($x, $y) {             let $a := $x             where (every $i in $x satisfies $i = $y) or empty($y)             return true()         };         local:f((current-date(), current-date(), current-date()), (current-date()))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
K-QuantExprWithout-7,Error: XPST0003: Unable to parse XPath: some $i in subsequence((0, 1, 2, current-time()), 1, 3) satisfies boolean($i treat as xs:integer). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.
K-QuantExprWithout-8,Error: XPST0003: Unable to parse XPath: every $i in subsequence((1, 2, 3, current-time()), 1, 3) satisfies boolean($i treat as xs:integer). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "t" found.
K-QuantExprWithout-42,Error: XPST0003: Unable to parse XPath:          declare variable $i := false();          some $i in (true(), true(), true()) satisfies $i. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K-QuantExprWithout-43,Error: XPST0003: Unable to parse XPath:          declare variable $i := false();          declare variable $t := false();          some $i in (true(), true()), $t in (true(), true()) satisfies $i eq $t. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K-QuantExprWithout-44,Error: XPST0003: Unable to parse XPath:          declare variable $i := false();          declare variable $t := false();          some $i in (true(), true()), $t in (true(), true()) satisfies ($i eq $t). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K-QuantExprWithout-45,Error: XPST0003: Unable to parse XPath:          declare variable $i := false();          every $i in (true(), true()) satisfies $i. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K-QuantExprWithout-56,Error: Not implemented: references to variables with a namespace URI or a prefix.
K-QuantExprWithout-57,Error: Not implemented: references to variables with a namespace URI or a prefix.
K-QuantExprWithout-58,Error: Not implemented: references to variables with a namespace URI or a prefix.
K-QuantExprWithout-59,Error: Not implemented: references to variables with a namespace URI or a prefix.
K-QuantExprWithout-89,Error: XPST0008, The variable a is not in scope.
K-QuantExprWithout-90,Error: XPST0008, The variable a is not in scope.
K-QuantExprWithout-91,Error: XPST0008, The variable a is not in scope.
K-QuantExprWithout-92,Error: XPST0008, The variable a is not in scope.
K2-QuantExprWithout-9,Error: XPST0003: Unable to parse XPath: let $firstSeq := (<a/>, <b/>, <e><c/></e>) let $secondSeq := (<a attr=""/>, <b>text</b>, <e><c/></e>) return some $i in $firstSeq satisfies $secondSeq[deep-equal(.,$i)]. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
K-QuantExprWith-1,Error: XPST0003: Unable to parse XPath: every $a as item()* in (1, 2), $b as item()* in $a satisfies $b. SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
K-QuantExprWith-2,Error: XPST0003: Unable to parse XPath: some $a as item()* in (1, 2), $b as item()* in $a satisfies $b. SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
K-QuantExprWith-3,Error: XPST0003: Unable to parse XPath: every $a as item()? in (1, 2), $b as item()? in $a satisfies $b. SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
K-QuantExprWith-4,Error: XPST0003: Unable to parse XPath: some $a as item()? in (1, 2), $b as item()? in $a satisfies $b. SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
K-QuantExprWith-5,Error: XPST0003: Unable to parse XPath: every $a as item()+ in (1, 2), $b as item()+ in $a satisfies $b. SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
K-QuantExprWith-6,Error: XPST0003: Unable to parse XPath: some $a as item()+ in (1, 2), $b as item()+ in $a satisfies $b. SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
K-QuantExprWith-9,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: some $a as xs:anyURI in 1 satisfies count($a). SyntaxError: Expected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.'
K-QuantExprWith-10,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: every $a as xs:anyURI in 1 satisfies count($a). SyntaxError: Expected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.'
K-QuantExprWith-11,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: every $a as empty-sequence() in (1, 2), $b as xs:integer in $a satisfies $b. SyntaxError: Expected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.'
K-QuantExprWith-12,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: some $a as empty-sequence() in (1, 2), $b as xs:integer in $a satisfies $b. SyntaxError: Expected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.'
K-QuantExprWith-13,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: every $a as xs:integer+ in (1, 2), $b as xs:string* in $a satisfies $b. SyntaxError: Expected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.'
K-QuantExprWith-14,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: some $a as xs:integer+ in (1, 2), $b as xs:string* in $a satisfies $b. SyntaxError: Expected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.'
K-QuantExprWith-15,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: some $a as item()* in (1, 2), $b as xs:string in $a satisfies $b. SyntaxError: Expected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.'
K-QuantExprWith-16,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: every $a as item()* in (1, 2), $b as xs:string in $a satisfies $b. SyntaxError: Expected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.'
K-QuantExprWith-17,Error: XPST0003: Unable to parse XPath: every $a as xs:integer+ in (1, 2), $b as xs:integer in $a satisfies $b. SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
K-QuantExprWith-18,Error: XPST0003: Unable to parse XPath: every $a as item()* in (1, 2), $b as xs:integer in $a satisfies $b. SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
K-QuantExprWith-21,AssertionError: Expected executing the XPath "every $a as empty-sequence() in (), $b as xs:integer in $a satisfies $b" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: every $a as empty-sequence() in (), $b as xs:integer in $a satisfies $b. SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: every $a as empty-sequence() in (), $b as xs:integer in $a satisfies $b. SyntaxError: Expected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.'.
K-QuantExprWith-22,AssertionError: Expected executing the XPath "not(some $a as empty-sequence() in (), $b as xs:integer in $a satisfies $b)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: not(some $a as empty-sequence() in (), $b as xs:integer in $a satisfies $b). SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: not(some $a as empty-sequence() in (), $b as xs:integer in $a satisfies $b). SyntaxError: Expected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.'.
K-QuantExprWith-23,Error: XPST0003: Unable to parse XPath: every $a as xs:integer in (1, 2), $b as xs:integer in $a satisfies $b. SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
K-QuantExprWith-24,Error: XPST0003: Unable to parse XPath: some $a as xs:integer in (1, 2), $b as xs:integer in $a satisfies $b. SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
ReturnExpr003,Error: XPST0017: Function substring with arity of 2 not registered. Did you mean "xs:string (xs:anyAtomicType?)", "string (item()?)" or "string ()"?
ReturnExpr004,Error: XPST0003: Unable to parse XPath: (for $f in /MyComputer//File where $f/@creation_date="08/06/00" return $f/SecurityObject/Denies/Deny[security/right]/user/string())!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.
ReturnExpr006,Error: XPST0017: Function data with arity of 1 not registered. No similar functions found.
ReturnExpr016,Error: XPST0003: Unable to parse XPath: for $file at $offset in (//Folder)[1]/File return <File>{ $file/@name }{ attribute offset{ $offset }}</File>. SyntaxError: Expected " ", "(:", "\n", "\r", "\t", or "in" but "a" found.
ReturnExpr020,Error: XPST0017: Function data with arity of 1 not registered. No similar functions found.
K2-Steps-1,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: declare function local:myFunc() { e[1] }; local:myFunc(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K2-Steps-2,AssertionError: Expected executing the XPath "declare function local:myFunc() { e[928] }; local:myFunc()" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: declare function local:myFunc() { e[928] }; local:myFunc(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.', AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: declare function local:myFunc() { e[928] }; local:myFunc(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
K2-Steps-3,AssertionError: Expected executing the XPath "declare function local:myFunc() { e[true()] }; local:myFunc()" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: declare function local:myFunc() { e[true()] }; local:myFunc(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.', AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: declare function local:myFunc() { e[true()] }; local:myFunc(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'.
K2-Steps-4,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: declare function local:myFunc() { e[last()] }; local:myFunc(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
K2-Steps-10,AssertionError: expected [Function] to throw error including 'XPTY0018' but got 'XPST0003: Unable to parse XPath: declare variable $myVar := <e>text</e>; $myVar/text()/(<e/>, (), 1, <e/>). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-Steps-12,AssertionError: Expected executing the XPath "declare variable $e := ()/.; declare variable $b := <b/>/.; $e, <b/>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: declare variable $e := ()/.; declare variable $b := <b/>/.; $e, <b/>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: declare variable $e := ()/.; declare variable $b := <b/>/.; $e, <b/>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
K2-Steps-14,AssertionError: Expected executing the XPath "<r> { let $i := <e> <a/> <b/> </e> let $b := ($i/b, $i/a, $i/b, $i/a) return ()/$b } </r>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: <r> { let $i := <e> <a/> <b/> </e> let $b := ($i/b, $i/a, $i/b, $i/a) return ()/$b } </r>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found., AssertionError: expected [Function] to throw error including 'XPST0005' but got 'XPST0003: Unable to parse XPath: <r> { let $i := <e> <a/> <b/> </e> let $b := ($i/b, $i/a, $i/b, $i/a) return ()/$b } </r>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.'.
K2-Steps-15,Error: XPST0003: Unable to parse XPath: <r> { let $i := <e> <a/> <b/> </e> let $b := ($i/b, $i/a, $i/b, $i/a) return <e/>/$b } </r>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
K2-Steps-16,Error: XPST0003: Unable to parse XPath: <r> { let $i := <e> <a/> <b/> </e> let $b := ($i/b, $i/a, $i/b, $i/a) return <e/>/./$b } </r>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
K2-Steps-17,Error: XPST0003: Unable to parse XPath: <r> { let $i := <e> <a/> <b/> </e> let $b := ($i/b, $i/a, $i/b, $i/a) return $b/. } </r>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
K2-Steps-21,Error: XPST0003: Unable to parse XPath: declare variable $root := <a> <b e="B"/> <c e="B"/> </a>; declare function local:function($arg) { $root["B" eq $arg/@e] }; $root/local:function(c). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-Steps-22,Error: XPST0003: Unable to parse XPath: declare variable $root := <a> <b e="B"/> <c e="B"/> </a>; declare function local:function($arg) { $root[exactly-one($arg/@e)] }; $root/local:function(c). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-Steps-23,Error: XPST0003: Unable to parse XPath: declare variable $root := <a><c e=""/></a>; declare function local:function($arg) { $root[$arg/@e] }; $root/local:function(c). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-Steps-24,Error: XPST0003: Unable to parse XPath: declare variable $root := <root> <b d=""/> <c> <c d=""/> <c/> </c> </root>; declare function local:function($object) { $root/b[@d = $object/@d] }; $root/c/c/local:function(.). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-Steps-25,Error: XPST0003: Unable to parse XPath:          declare variable $root := <root> <b d=""/> <c> <c d=""/> <c/> </c> </root>;          declare function local:function($object) { $root/b[@d = $object/@d] };          $root//local:function(c). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-Steps-26,Error: XPST0003: Unable to parse XPath: declare variable $root := <root> <b d=""/> <c> <c d=""/> <c/> </c> </root>; declare function local:function($object) { $root/b[$object/@d] }; $root//local:function(c). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-Steps-27,Error: XPST0003: Unable to parse XPath: declare variable $root := <root> <b d=""/> <c> <c d=""/> <c/> </c> </root>; declare function local:function($object) { $root[$object/@d] }; $root//local:function(c). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-Steps-28,Error: XPST0003: Unable to parse XPath: declare variable $root := <root> <b d=""/> <c d=""/> </root>; declare function local:function($object) { $root[$object/@d] }; $root//local:function(c). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-Steps-29,Error: XPST0003: Unable to parse XPath: declare variable $root := <root> <c d=""/> </root>; declare function local:function($object) { $root[$object/@d] }; $root//local:function(c). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-Steps-30,Error: XPST0003: Unable to parse XPath: declare variable $root := <root> <c d=""/> </root>; declare function local:function($object) { $root[$object] }; $root//local:function(c). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-Steps-31,Error: XPST0003: Unable to parse XPath: declare variable $root := <root><c/></root>; declare function local:function($arg) { $root[$arg] }; $root//local:function(.). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-Steps-32,Error: XPST0003: Unable to parse XPath: declare variable $root := <root/>; declare function local:function($arg, $count as xs:integer) { $arg, $root, if($count eq 2) then $root else local:function($arg, $count + 1) }; $root/local:function(., 1). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-Steps-33,Error: XPST0003: Unable to parse XPath: declare variable $root := ( <b d=""/>, <c> <c d=""/> </c> ); declare function local:function($object) { $root[@d eq $object/@d] }; $root/local:function(c). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-Steps-34,Error: XPST0003: Unable to parse XPath:          declare variable $root := ( <b d=""/>, <c d=""> <c d=""/> </c> );          declare function local:function($object) { $root[@d eq $object/@d] };          $root!local:function(c)       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-Steps-35,Error: XPST0003: Unable to parse XPath: (<e/>[1]/text{string-join(., " ")}, 1) => count(). SyntaxError: Expected "!", "!=", "#", "(", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
Steps-leading-lone-slash-1a,Error: XPST0003: Unable to parse XPath: (         declare variable $var := document {<a>123</a>}; $var[(/)*5]         )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
Steps-leading-lone-slash-2a,Error: XPST0003: Unable to parse XPath: (         declare variable $var := document {<a>123</a>}; $var[(/)<a]         )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
Steps-leading-lone-slash-3a,Error: XPST0003: Unable to parse XPath: (         declare variable $var := document {<a>123</a>}; $var[(/)<5]         )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
Steps-leading-lone-slash-5a,Error: XPST0003: Unable to parse XPath: (         declare variable $var := document {<a>123</a>}; $var[(/)<a div 3]         )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
Steps-leading-lone-slash-7a,Error: XPST0003: Unable to parse XPath: (         declare variable $var := document {<a>123</a>};          declare variable $a := document {<a>123</a>}; $var[(/) is $a]         )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
Steps-leading-lone-slash-8a,Error: XPST0003: Unable to parse XPath: (         declare variable $var := document {<a>123</a>};          $var[(/) instance of document-node(element(x))]         )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
Steps-leading-lone-slash-10,Error: XPST0003: Unable to parse XPath:          declare variable $var := document {<a>123</a>};          $var[/*]         . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
Steps-leading-lone-slash-11,Error: XPST0003: Unable to parse XPath:          declare variable $var := document {<a>123</a>};          $var[/<a/>]         . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
Steps-leading-lone-slash-12,Error: XPST0003: Unable to parse XPath:          declare variable $var := document {<a>123</a>};          $var[/<a div="3"/>]         . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
Steps-leading-lone-slash-13,Error: XPST0003: Unable to parse XPath:          declare variable $var := document {<a>123</a>};          $var[/unordered{a}]         . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
Steps-leading-lone-slash-14,Error: XPST0003: Unable to parse XPath: (         declare variable $var := document {<a>123</a>};          $var[/max(a)]         )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
Steps-leading-lone-slash-15,Error: XPST0003: Unable to parse XPath: (         declare variable $var := document {<a>123</a>};          $var[/-5]         )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
Steps-leading-lone-slash-16,Error: XPST0003: Unable to parse XPath:          declare variable $var := document {<a>123</a>};          declare variable $a := document {<a>123</a>};          $var[/=$a]         . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
Steps-leading-lone-slash-17,Error: XPST0003: Unable to parse XPath: (         declare variable $var := document {<a>123</a>};          declare variable $a := document {<a>123</a>};          $var[5*/]         )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
Orderexpr-1,Error: XPST0003: Unable to parse XPath: ordered {//part[@partid < 2]}. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
Orderexpr-2,AssertionError: Expected executing the XPath "unordered {//part[@partid < 2]}" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: unordered {//part[@partid < 2]}. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found., Error: XPST0003: Unable to parse XPath: unordered {//part[@partid < 2]}. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found..
Orderexpr-5,Error: XPST0003: Unable to parse XPath: ordered {//part[@partid < 2][2]}. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
Orderexpr-6,AssertionError: Expected executing the XPath "unordered {//part[@partid < 2][2]}" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: unordered {//part[@partid < 2][2]}. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found., Error: XPST0003: Unable to parse XPath: unordered {//part[@partid < 2][2]}. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found..
Orderexpr-9,Error: XPST0003: Unable to parse XPath: ordered {//part[@partof = 1] union //part[@partid = 1] }. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
Orderexpr-10,AssertionError: Expected executing the XPath "unordered {//part[@partof = 1] union //part[@partid = 1] }" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: unordered {//part[@partof = 1] union //part[@partid = 1] }. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found., Error: XPST0003: Unable to parse XPath: unordered {//part[@partof = 1] union //part[@partid = 1] }. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found..
Orderexpr-11,Error: XPST0003: Unable to parse XPath: ordered {//part[@partof < 2] intersect //part[@partid = 1 or @partid > 2] }. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
Orderexpr-12,AssertionError: Expected executing the XPath "unordered {//part[@partof < 2] intersect //part[@partid = 1 or @partid > 2] }" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: unordered {//part[@partof < 2] intersect //part[@partid = 1 or @partid > 2] }. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found., Error: XPST0003: Unable to parse XPath: unordered {//part[@partof < 2] intersect //part[@partid = 1 or @partid > 2] }. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found..
Orderexpr-13,Error: XPST0003: Unable to parse XPath: ordered {//part[@partof < 2] except //part[@partid = 2] }. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.
Orderexpr-14,AssertionError: Expected executing the XPath "unordered {//part[@partof < 2] except //part[@partid = 2] }" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: unordered {//part[@partof < 2] except //part[@partid = 2] }. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found., Error: XPST0003: Unable to parse XPath: unordered {//part[@partof < 2] except //part[@partid = 2] }. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found..
Orderexpr-15,Error: XPST0003: Unable to parse XPath: (ordered {fn:subsequence((1,2,3,4),2,2)})!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
Orderexpr-16,AssertionError: Expected executing the XPath "unordered {fn:subsequence((1,2,3,4),2,2)}" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (unordered {fn:subsequence((1,2,3,4),2,2)})!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found., Error: XPST0003: Unable to parse XPath: (unordered {fn:subsequence((1,2,3,4),2,2)})!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found..
Orderexpr-17,Error: XPST0003: Unable to parse XPath: (ordered {fn:reverse((3,2))})!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
Orderexpr-18,AssertionError: Expected executing the XPath "unordered {fn:reverse((2,3))}" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (unordered {fn:reverse((2,3))})!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found., Error: XPST0003: Unable to parse XPath: (unordered {fn:reverse((2,3))})!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found..
Orderexpr-19,Error: XPST0003: Unable to parse XPath: (ordered { for $i in (//part[@partid = 1], //part[@partid = 2]), $j in (//part[@partof = $i/@partid]) where ($i/@partid + $j/@partid) < 7 return $i/@partid + $j/@partid })!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
Orderexpr-20,AssertionError: Expected executing the XPath "unordered { for $i in (//part[@partid = 1], //part[@partid = 2]), $j in (//part[@partof = $i/@partid]) where ($i/@partid + $j/@partid) < 7 return $i/@partid + $j/@partid }" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (unordered { for $i in (//part[@partid = 1], //part[@partid = 2]), $j in (//part[@partof = $i/@partid]) where ($i/@partid + $j/@partid) < 7 return $i/@partid + $j/@partid })!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found., Error: XPST0003: Unable to parse XPath: (unordered { for $i in (//part[@partid = 1], //part[@partid = 2]), $j in (//part[@partof = $i/@partid]) where ($i/@partid + $j/@partid) < 7 return $i/@partid + $j/@partid })!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found..
orderedunorderedexpr-1,Error: XPST0003: Unable to parse XPath: (ordered {if (fn:true()) then (0,1,2,3,4) else ("A","B","C")})!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
orderedunorderedexpr-2,Error: XPST0003: Unable to parse XPath: (ordered {if (1 eq 1 and 2 eq 2) then (0,1,2,3,4) else ("a","b")})!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
orderedunorderedexpr-3,Error: XPST0003: Unable to parse XPath: (ordered {if (1 eq 1 or 2 eq 3) then (0,1,2,3,4) else ("a","b")})!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
orderedunorderedexpr-4,Error: XPST0003: Unable to parse XPath: (ordered {if (some $x in (1, 2, 3), $y in (2, 3, 4) satisfies $x + $y = 4) then (0,1,2,3,4) else ("a","b")})!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
orderedunorderedexpr-5,Error: XPST0003: Unable to parse XPath: (ordered {if (every $x in (1, 2, 3) satisfies $x < 4) then (0,1,2,3,4) else ("a","b")})!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
orderedunorderedexpr-6,Error: XPST0003: Unable to parse XPath: (ordered {typeswitch(123) case $i as xs:string return ("a","b","c") case $i as xs:double return ("a","b","c") case $i as xs:integer return (1,2,3,4) default return ("a","b","c") })!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "{" found.
K-OrderExpr-1a,Error: XPST0003: Unable to parse XPath: (ordered{}) => empty(). SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
K-OrderExpr-2a,Error: XPST0003: Unable to parse XPath: (unordered{}) => empty(). SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
K-OrderExpr-3,Error: XPST0003: Unable to parse XPath: ordered{true()}. SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], [-], or end of input but "{" found.
K-OrderExpr-4,Error: XPST0003: Unable to parse XPath: unordered{true()}. SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], [-], or end of input but "{" found.
K-ValCompTypeChecking-16,AssertionError: expected [Function] to throw an error
K-ValCompTypeChecking-17,AssertionError: expected [Function] to throw an error
K-ValCompTypeChecking-18,AssertionError: expected [Function] to throw an error
K-ValCompTypeChecking-19,AssertionError: expected [Function] to throw an error
K-ValCompTypeChecking-20,AssertionError: expected [Function] to throw an error
K-ValCompTypeChecking-21,AssertionError: expected [Function] to throw an error
K-ValCompTypeChecking-22,AssertionError: expected [Function] to throw an error
K-ValCompTypeChecking-23,AssertionError: expected [Function] to throw an error
K-ValCompTypeChecking-24,AssertionError: expected [Function] to throw an error
K-ValCompTypeChecking-25,AssertionError: expected [Function] to throw an error
K-ValCompTypeChecking-26,AssertionError: expected [Function] to throw an error
K-ValCompTypeChecking-27,AssertionError: expected [Function] to throw an error
K-ValCompTypeChecking-28,AssertionError: expected [Function] to throw an error
K-ValCompTypeChecking-29,AssertionError: expected [Function] to throw an error
K-ValCompTypeChecking-32,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ValCompTypeChecking-33,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ValCompTypeChecking-34,Error: XPST0017: Function current-time with arity of 0 not registered. No similar functions found.
K-ValCompTypeChecking-35,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'
K-ValCompTypeChecking-36,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'
K-ValCompTypeChecking-37,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'
K-ValCompTypeChecking-38,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'
K-ValCompTypeChecking-39,AssertionError: Expected executing the XPath "3 eq (3, error())" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.', AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'.
K-ValCompTypeChecking-40,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'
K-ValCompTypeChecking-41,AssertionError: Expected executing the XPath "(3, error()) eq 3" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.', AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'.
value-comparison-5,Error: Atomizing array(*) is not implemented.
value-comparison-6,Error: Atomizing array(*) is not implemented.
value-comparison-7,Error: Atomizing array(*) is not implemented.
value-comparison-8,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Atomizing array(*) is not implemented.'
VarDecl001,Error: XPST0003: Unable to parse XPath: (declare variable $x := "" ; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl002,Error: XPST0003: Unable to parse XPath: (declare variable $x := '' ; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl003,Error: XPST0003: Unable to parse XPath: (declare variable $x := 'a string' ; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl004,Error: XPST0003: Unable to parse XPath: (declare variable $x := "a string" ; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl005,Error: XPST0003: Unable to parse XPath: (declare variable $x := "This is a string, isn't it?" ; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl006,Error: XPST0003: Unable to parse XPath: (declare variable $x := 'This is a "String"' ; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl007,Error: XPST0003: Unable to parse XPath: (declare variable $x := "a "" or a ' delimits a string literal" ; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl008,Error: XPST0003: Unable to parse XPath: (declare variable $x := 'a " or a '' delimits a string literal' ; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl009,Error: XPST0003: Unable to parse XPath: (declare variable $x := '&lt;bold&gt;A sample element.&lt;/bold&gt;' ; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl010,Error: XPST0003: Unable to parse XPath: (declare variable $x := 0 ; $x) = (0). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl011,Error: XPST0003: Unable to parse XPath: (declare variable $x := 1 ; $x) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl012,Error: XPST0003: Unable to parse XPath: (declare variable $x := -1 ; $x) = (-1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl013,Error: XPST0003: Unable to parse XPath: (declare variable $x := +1 ; $x) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl014,Error: XPST0003: Unable to parse XPath: (declare variable $x := 1.23 ; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl015,Error: XPST0003: Unable to parse XPath: (declare variable $x := -1.23 ; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl016,Error: XPST0003: Unable to parse XPath: (declare variable $x := 1.2e5 ; $x) = (120000). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl017,Error: XPST0003: Unable to parse XPath: (declare variable $x := -1.2E5 ; $x) = (-120000). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl018,Error: XPST0003: Unable to parse XPath: (declare variable $x := 0.0E0 ; $x) = (0). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl019,Error: XPST0003: Unable to parse XPath: (declare variable $x := 1e-5 ; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl020,Error: XPST0003: Unable to parse XPath: (declare variable $x := 9.999999999999999; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl021,Error: XPST0003: Unable to parse XPath: (declare variable $x := -10000000 ; $x) = (-10000000). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl022,Error: XPST0003: Unable to parse XPath: (declare variable $x := 1 to 10 ; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl023,Error: XPST0003: Unable to parse XPath: (declare variable $x := xs:double('NaN'); $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl024,Error: XPST0003: Unable to parse XPath: (declare variable $x := xs:double('INF'); $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl025,Error: XPST0003: Unable to parse XPath: (declare variable $x := xs:double('-INF'); $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl026,Error: XPST0003: Unable to parse XPath: declare variable $x := fn:false() ; $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
VarDecl027,Error: XPST0003: Unable to parse XPath: declare variable $x := false(); $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
VarDecl028,Error: XPST0003: Unable to parse XPath: declare variable $x := fn:true() ; $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
VarDecl029,Error: XPST0003: Unable to parse XPath: declare variable $x := true() ; $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
VarDecl030,Error: XPST0003: Unable to parse XPath: declare variable $x := true(); $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
VarDecl031,Error: XPST0003: Unable to parse XPath: (declare variable $x := 2+2 ; $x) = (4). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl032,Error: XPST0003: Unable to parse XPath: (declare variable $x := 2*2 ; $x) = (4). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl033,Error: XPST0003: Unable to parse XPath: (declare variable $x := 3-2 ; $x) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl034,Error: XPST0003: Unable to parse XPath: (declare variable $x := 3 div 2 ; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl035,Error: XPST0003: Unable to parse XPath: (declare variable $x := 3 mod 2 ; $x) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl036,Error: XPST0003: Unable to parse XPath: (declare variable $x := 3 idiv 2 ; $x) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl037,Error: XPST0003: Unable to parse XPath: (declare variable $x := -1.7976931348623157E308 ; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl038,Error: XPST0003: Unable to parse XPath: (declare variable $x := xs:double("-1.7976931348623157E308") ; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl039,Error: XPST0003: Unable to parse XPath: (declare variable $x := -999999999999999999 ; $x) = (-999999999999999999). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl040,Error: XPST0003: Unable to parse XPath: (declare variable $x := xs:decimal("-999999999999999999") ; $x) = (-999999999999999999). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl041,Error: XPST0003: Unable to parse XPath: (declare variable $x := 999999999999999999 ; $x) = (999999999999999999). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl042,Error: XPST0003: Unable to parse XPath: (declare variable $x := xs:decimal("999999999999999999") ; $x) = (999999999999999999). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl043,Error: XPST0003: Unable to parse XPath: (declare variable $x := -3.4028235E38 ; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl044,Error: XPST0003: Unable to parse XPath: (declare variable $x := xs:float("-3.4028235E38") ; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl045,Error: XPST0003: Unable to parse XPath: (declare variable $x := xs:date("1970-01-01Z") ; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl046,Error: XPST0003: Unable to parse XPath: (declare variable $x := xs:date("1970-01-01Z") + xs:dayTimeDuration("P31DT23H59M59S") ; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl047,Error: XPST0003: Unable to parse XPath: (declare variable $x := xs:time("08:03:35Z") ; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl048,Error: XPST0003: Unable to parse XPath: (declare variable $x := xs:time("08:03:35Z") + xs:dayTimeDuration("P0DT0H0M0S") ; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl049,Error: XPST0003: Unable to parse XPath: (declare variable $x := xs:dateTime("2030-12-31T23:59:59Z") ; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl050,Error: XPST0003: Unable to parse XPath: (declare variable $x := (1,2,3) ; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl051,Error: XPST0003: Unable to parse XPath: (declare variable $x := (xs:string("a") , (), "xyz") ; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl052,Error: XPST0003: Unable to parse XPath: (declare variable $x := (xs:string("a") , xs:anyURI("www.example.com")) ; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl053,Error: XPST0003: Unable to parse XPath: (declare variable $x := (xs:float("INF") , xs:double("NaN")) ; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl054,Error: XPST0003: Unable to parse XPath: (declare variable $x := (xs:boolean("true") , xs:boolean("0"), xs:integer("0")) ; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl055,Error: XPST0003: Unable to parse XPath: (declare variable $x := (xs:date("1993-03-31") , xs:boolean("true"), xs:string("abc")) ; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl056,Error: XPST0003: Unable to parse XPath: (declare variable $x := (xs:time("12:30:00") , xs:string(" ") , xs:decimal("2.000000000000002")) ; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl057,Error: XPST0003: Unable to parse XPath: (declare variable $x := ((1+1), (2-2)) ; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl058,Error: XPST0003: Unable to parse XPath: (declare variable $x := ((1,2,2),(1,2,3),(123,""),(),("")) ; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl059,Error: XPST0003: Unable to parse XPath: declare variable $x := (//book/price, (), (1)) ; document{$x}. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
VarDecl060,Error: XPST0003: Unable to parse XPath: (declare variable $x := //Price/text() ; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl061,Error: XPST0003: Unable to parse XPath: declare variable $x := /comment() ; $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
VarDecl062,Error: XPST0003: Unable to parse XPath: declare variable $x := /processing-instruction() ; $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
VarDecl063,Error: XPST0003: Unable to parse XPath: (         declare variable $x := $y + 3;         declare variable $y := 17;         $x + 5       ) = (25). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
VarDecl064,Error: XPST0003: Unable to parse XPath: (         declare function local:f1() {$a};         declare function local:f2() {$a};         declare variable $a := 19;               local:f1() + local:f2()       ) = (38). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
vardeclerr,AssertionError: expected [Function] to throw error including 'XQST0054' but got 'XPST0003: Unable to parse XPath: \n      declare namespace foo = "http://www..oracle.com/xquery/test"; \n      declare variable $var1 as xs:integer := foo:price(xs:integer(2)); \n      declare function foo:price ($b as xs:integer) as xs:integer { $var1 + 1 }; \n      $var1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
vardeclerr-1,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'XPST0003: Unable to parse XPath: \n      declare namespace foo = "http://www..oracle.com/xquery/test"; \n      declare variable $var1 as xs:integer := foo:price(xs:integer(2)); \n      declare function foo:price ($b as xs:integer) as xs:integer { $var1 + 1 }; \n      $var1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
internalvar-2,Error: XPST0003: Unable to parse XPath: (::)declare(::)variable(::)$var(::):=(::)1(::);(::) 1(::)eq(::)1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-InternalVariablesWithout-1,AssertionError: expected [Function] to throw error including 'XQST0054' but got 'XPST0003: Unable to parse XPath: \n        declare variable $local:myVar := local:myFunction(); \n        declare function local:myFunction() { local:myFunction(), 1, $local:myVar }; \n        $local:myVar\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-InternalVariablesWithout-1a,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'XPST0003: Unable to parse XPath: \n        declare variable $local:myVar := local:myFunction();\n        declare function local:myFunction() {\n            if (current-date() lt xs:date(\'1990-01-01\')) then local:myFunction() else (), 1, $local:myVar\n                                             };\n        $local:myVar\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-InternalVariablesWithout-1b,Error: XPST0003: Unable to parse XPath: (          declare variable $local:myVar := local:myFunction();          declare function local:myFunction() {            if (current-date() lt xs:date('1990-01-01')) then $local:myVar + 1 else 22          };          $local:myVar       ) = (22). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
K2-InternalVariablesWithout-1c,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'XPST0003: Unable to parse XPath: \n         declare variable $local:myVar := local:myFunction();\n         declare function local:myFunction() {\n         if (current-date() gt xs:date(\'1990-01-01\')) then $local:myVar + 1 else 22\n         };\n         $local:myVar\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-InternalVariablesWithout-2,AssertionError: expected [Function] to throw error including 'XQST0054' but got 'XPST0003: Unable to parse XPath: \n        declare variable $local:myVar := local:myFunction(); \n        declare function local:myFunction() { $local:myVar, 1, local:myFunction() }; \n        $local:myVar\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-InternalVariablesWithout-2a,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'XPST0003: Unable to parse XPath: \n        declare variable $local:myVar := local:myFunction();\n        declare function local:myFunction() { $local:myVar, 1, local:myFunction() };\n        $local:myVar\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-InternalVariablesWithout-3,AssertionError: expected [Function] to throw error including 'XQST0054' but got 'XPST0003: Unable to parse XPath: declare variable $local:myVar := local:myFunction(); declare function local:myFunction() { $local:myVar, 1, local:myFunction() }; $local:myVar. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-InternalVariablesWithout-3a,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'XPST0003: Unable to parse XPath: declare variable $local:myVar := local:myFunction(); declare function local:myFunction() { $local:myVar, 1, local:myFunction() }; $local:myVar. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-InternalVariablesWithout-4,AssertionError: expected [Function] to throw error including 'XQST0054' but got 'XPST0003: Unable to parse XPath: declare variable $local:myVar := local:myFunction(); declare function local:myFunction() { $local:myVar, 1, local:myFunction() }; $local:myVar. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-InternalVariablesWithout-4a,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'XPST0003: Unable to parse XPath: declare variable $local:myVar := local:myFunction(); declare function local:myFunction() { $local:myVar, 1, local:myFunction() }; $local:myVar. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-InternalVariablesWithout-5,AssertionError: expected [Function] to throw error including 'XQST0054' but got 'XPST0003: Unable to parse XPath: declare variable $local:myVar := local:myFunction(); declare function local:myFunction2() { $local:myVar, 1, local:myFunction() }; declare function local:myFunction() { local:myFunction2() }; $local:myVar. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-InternalVariablesWithout-5a,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'XPST0003: Unable to parse XPath: declare variable $local:myVar := local:myFunction(); declare function local:myFunction2() { $local:myVar, 1, local:myFunction() }; declare function local:myFunction() { local:myFunction2() }; $local:myVar. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-InternalVariablesWithout-6,AssertionError: expected [Function] to throw error including 'XQST0054' but got 'XPST0003: Unable to parse XPath: declare variable $local:myVar := local:myFunction(); declare function local:myFunction2() { local:myFunction(), $local:myVar }; declare function local:myFunction() { local:myFunction2() }; local:myFunction(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-InternalVariablesWithout-6a,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'XPST0003: Unable to parse XPath: declare variable $local:myVar := local:myFunction();\n\n         declare function local:myFunction2() {\n            if (current-date() lt xs:date(\'1990-01-01\')) then local:myFunction() else (), $local:myVar };\n\n         declare function local:myFunction() {\n         local:myFunction2() };\n\n         local:myFunction(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-InternalVariablesWithout-7,AssertionError: expected [Function] to throw error including 'XQST0054' but got 'XPST0003: Unable to parse XPath: declare variable $local:myVar := local:myFunction(); declare function local:myFunction2() { local:myFunction(), $local:myVar }; declare function local:myFunction4() { local:myFunction2() }; declare function local:myFunction3() { local:myFunction4() }; declare function local:myFunction() { local:myFunction3() }; local:myFunction(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-InternalVariablesWithout-7a,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'XPST0003: Unable to parse XPath: declare variable $local:myVar := local:myFunction();\n         declare function local:myFunction2() {\n         if (current-date() lt xs:date(\'1990-01-01\')) then local:myFunction() else (), $local:myVar };\n\n         declare function local:myFunction4() {\n            local:myFunction2() };\n\n         declare function local:myFunction3() {\n            local:myFunction4() };\n\n         declare function local:myFunction() {\n            local:myFunction3() };\n\n         local:myFunction(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-InternalVariablesWithout-8,AssertionError: expected [Function] to throw error including 'XQST0054' but got 'XPST0003: Unable to parse XPath: declare variable $local:myVar := local:myFunction(); declare function local:myFunction2() { local:myFunction4() }; declare function local:myFunction4() { local:myFunction2(), $local:myVar }; declare function local:myFunction3() { local:myFunction4() }; declare function local:myFunction() { local:myFunction3() }; local:myFunction(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-InternalVariablesWithout-8a,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'XPST0003: Unable to parse XPath: declare variable $local:myVar := local:myFunction();\n\n         declare function local:myFunction2() { local:myFunction4() };\n\n         declare function local:myFunction4() {\n         if (current-date() lt xs:date(\'1990-01-01\')) then local:myFunction2() else (), $local:myVar };\n\n         declare function local:myFunction3() { local:myFunction4() };\n\n         declare function local:myFunction() { local:myFunction3() };\n\n         local:myFunction(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-InternalVariablesWithout-9,AssertionError: expected [Function] to throw error including 'XQST0054' but got 'XPST0003: Unable to parse XPath: declare variable $local:myVar := local:myFunc(3); declare function local:myFunc($arg) { local:myFunc($local:myVar) }; $local:myVar. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-InternalVariablesWithout-9a,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'XPST0003: Unable to parse XPath: declare variable $local:myVar := local:myFunc(3); declare function local:myFunc($arg) { local:myFunc($local:myVar) }; $local:myVar. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-InternalVariablesWithout-10,Error: XPST0003: Unable to parse XPath: (declare variable $local:myVar := local:myFunc(3); declare function local:myFunc($local:myVar) { $local:myVar }; local:myFunc(6)) = (6). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
K2-InternalVariablesWithout-11,AssertionError: Expected executing the XPath "declare variable $local:myVar := local:thisFunctionDoesNotExist(); 1" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare variable $local:myVar := local:thisFunctionDoesNotExist(); 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found., AssertionError: expected [Function] to throw error including 'XPST0017' but got 'XPST0003: Unable to parse XPath: declare variable $local:myVar := local:thisFunctionDoesNotExist(); 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
K2-InternalVariablesWithout-12,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'XPST0003: Unable to parse XPath: declare variable $local:myVar := local:thisFunctionDoesNotExist(); $local:myVar. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-InternalVariablesWithout-13,Error: XPST0003: Unable to parse XPath: declare variable $local:var1 := 1; declare variable $local:var2 := 2; declare variable $local:var3 := 3; declare variable $local:var4 := 4; declare variable $local:var5 := 5; declare variable $local:var6 := 6; declare variable $local:var7 := 7; declare variable $local:var8 := 8; declare variable $local:var9 := 9; declare variable $local:var10 := 10; declare variable $local:var11 := 11; declare variable $local:var12 := 12; declare variable $local:var13 := 13; declare variable $local:var14 := 14; declare variable $local:var15 := 15; declare variable $local:var16 := 16; declare variable $local:var17 := 17; declare variable $local:var18 := 18; declare variable $local:var19 := 19; declare variable $local:var20 := 20; deep-equal((1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20), ($local:var1, $local:var2, $local:var3, $local:var4, $local:var5, $local:var6, $local:var7, $local:var8, $local:var9, $local:var10, $local:var11, $local:var12, $local:var13, $local:var14, $local:var15, $local:var16, $local:var17, $local:var18, $local:var19, $local:var20)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-InternalVariablesWithout-14,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: declare variable $myVar := <e>{nametest}</e>; <e/>/$myVar. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
vardeclwithtype-1,Error: XPST0003: Unable to parse XPath: (declare variable $var as xs:string := "abc"; $var)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
vardeclwithtype-2,Error: XPST0003: Unable to parse XPath: (declare variable $var as xs:integer := 100; $var) = (100). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
vardeclwithtype-3,Error: XPST0003: Unable to parse XPath: (declare variable $var as xs:decimal := 100; $var) = (100). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
vardeclwithtype-4,Error: XPST0003: Unable to parse XPath: declare variable $var as xs:boolean := fn:true(); $var. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
vardeclwithtype-5,Error: XPST0003: Unable to parse XPath: declare variable $var as xs:boolean := fn:false(); $var. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
vardeclwithtype-6,Error: XPST0003: Unable to parse XPath: (declare variable $var as xs:float := xs:float(12.5E10); $var)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
vardeclwithtype-7,Error: XPST0003: Unable to parse XPath: (declare variable $var as xs:double := xs:double(1267.43233E12); $var)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
vardeclwithtype-8,Error: XPST0003: Unable to parse XPath: (declare variable $var as xs:anyURI := xs:anyURI("http://example.com"); $var)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
vardeclwithtype-9,Error: XPST0003: Unable to parse XPath: (declare variable $var as xs:dateTime := xs:dateTime("1999-11-28T09:00:00Z"); $var)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
vardeclwithtype-10,Error: XPST0003: Unable to parse XPath: (declare variable $var as xs:time := xs:time("11:12:00Z"); $var)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
vardeclwithtype-11,Error: XPST0003: Unable to parse XPath: (declare variable $var as xs:date := xs:date("1999-11-28Z"); $var)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
vardeclwithtype-12,AssertionError: expected [Function] to throw error including 'XQST0049' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare variable $var as xs:date := xs:date("1999-11-28Z"); \n      \tdeclare variable $var as xs:date := xs:date("1999-11-28Z"); \n      \t$var\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
vardeclwithtype-13,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $var as xs:date := fn:true() and fn:true(); $var. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
vardeclwithtype-14,Error: XPST0003: Unable to parse XPath: (declare variable $x as xs:integer := 10; declare variable $var as xs:integer := $x +1; $var) = (11). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
vardeclwithtype-15a,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'XPST0003: Unable to parse XPath: \n        declare variable $var as xs:integer := $e +1; \n        declare variable $e as xs:integer := 10;  \n        $var\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
vardeclwithtype-15b,Error: XPST0003: Unable to parse XPath: (       declare variable $var as xs:integer := $e +1;        declare variable $e as xs:integer := 10;         $var) = (11). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
vardeclwithtype-16,Error: XPST0003: Unable to parse XPath: (       	declare namespace p1 = "http://www.example.com";        	declare variable $p1:var as xs:integer := 10;        	$p1:var       ) = (10). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
vardeclwithtype-17,Error: XPST0003: Unable to parse XPath: (       	declare namespace p1 = "http://www.example.com";        	declare namespace p2 = "http://www.example.com/examples";        	declare variable $p1:var as xs:integer := 10;        	declare variable $p2:var as xs:integer := 20;        	$p2:var       ) = (20). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
vardeclwithtype-18,AssertionError: expected [Function] to throw error including 'XQST0049' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare namespace p1 = "http://www.example.com"; \n      \tdeclare namespace p2 = "http://www.example.com"; \n      \tdeclare variable $p1:var as xs:integer := 10; \n      \tdeclare variable $p2:var as xs:integer := 20; \n      \t$p2:var\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
vardeclwithtype-19,Error: XPST0003: Unable to parse XPath: (declare variable $var as xs:integer := fn:count((10,2)); $var) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
vardeclwithtype-20,Error: XPST0003: Unable to parse XPath: (declare variable $var as xs:integer := fn:string-length("ABC"); $var) = (3). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
vardeclwithtype-21,Error: XPST0003: Unable to parse XPath: declare variable $var as xs:boolean := fn:not(fn:true()); $var. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
vardeclwithtype-22,Error: XPST0003: Unable to parse XPath: declare variable $var as xs:boolean := fn:empty((1,2,3)); $var. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
internalvar-1,Error: XPST0003: Unable to parse XPath: declare(::)variable(::)$var(::)as(::)item((: :))*(::):=(::)1(::);(::) 1(::)eq(::)1(::). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K-InternalVariablesWith-1,Error: XPST0003: Unable to parse XPath: declare(::)variable(::)$local:var(::)as(::)item((: :))* :=3(::);(::)1(::)eq(::)1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K-InternalVariablesWith-2,Error: XPST0003: Unable to parse XPath: (::)declare(::)variable(::)$local:var(::):=(::)3;(::)1(::)eq(::)1(::). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K-InternalVariablesWith-3,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $myVar as xs:integer := subsequence((1, 2, "a string"), 3, 1); $myVar eq 3. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K-InternalVariablesWith-4,AssertionError: Expected executing the XPath "declare variable $myVar as xs:gYear := 2006; true()" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: declare variable $myVar as xs:gYear := 2006; true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $myVar as xs:gYear := 2006; true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
K-InternalVariablesWith-5,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $myVar as xs:gYear := 2006; $myVar. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K-InternalVariablesWith-6a,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'XPST0003: Unable to parse XPath: declare variable $var1 := $var2; declare variable $var2 := 2; true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K-InternalVariablesWith-6b,Error: XPST0003: Unable to parse XPath: declare variable $var1 := $var2; declare variable $var2 := 2; true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K-InternalVariablesWith-9a,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'XPST0003: Unable to parse XPath: declare variable $var1 := $var2; declare variable $var2 := 2; $var1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K-InternalVariablesWith-9b,Error: XPST0003: Unable to parse XPath: (declare variable $var1 := $var2; declare variable $var2 := 2; $var1) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
K-InternalVariablesWith-11,Error: XPST0003: Unable to parse XPath: declare variable $var1 := 2; declare variable $var2 := $var1; $var2 eq 2. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K-InternalVariablesWith-12,Error: XPST0003: Unable to parse XPath: declare variable $var1 := local:myFunc(); declare function local:myFunc() { 1 }; $var1 eq 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K-InternalVariablesWith-13,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $var1 as xs:string := local:myFunc(); declare function local:myFunc() as xs:integer { 1 }; $var1 eq 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K-InternalVariablesWith-14,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $var1 as xs:string := local:myFunc(); declare function local:myFunc() { 1 }; $var1 eq 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K-InternalVariablesWith-15a,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'XPST0003: Unable to parse XPath: declare variable $var1 := $var1; true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K-InternalVariablesWith-15b,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'XPST0003: Unable to parse XPath: declare variable $var1 := $var1; true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K-InternalVariablesWith-16,AssertionError: expected [Function] to throw error including 'XQST0054' but got 'XPST0003: Unable to parse XPath: \n      declare variable $var := local:func1(); \n      declare function local:func1() { local:func2() }; \n      declare function local:func2() { local:func3() }; \n      declare function local:func3() { local:func4() }; \n      declare function local:func4() { $var }; \n      boolean($var). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K-InternalVariablesWith-16a,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'XPST0003: Unable to parse XPath: \n      declare variable $var := local:func1(); \n      declare function local:func1() { local:func2() }; \n      declare function local:func2() { local:func3() }; \n      declare function local:func3() { local:func4() }; \n      declare function local:func4() { $var }; \n      boolean($var). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K-InternalVariablesWith-17,AssertionError: expected [Function] to throw error including 'XQST0054' but got 'XPST0003: Unable to parse XPath: declare variable $var := local:func1(); declare function local:func1() { local:func2($var) }; declare function local:func2($arg2) { 1 }; true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K-InternalVariablesWith-17a,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'XPST0003: Unable to parse XPath: declare variable $var := local:func1(); declare function local:func1() { local:func2($var) }; declare function local:func2($arg2) { 1 }; true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K-InternalVariablesWith-18,AssertionError: expected [Function] to throw error including 'XQST0054' but got 'XPST0003: Unable to parse XPath: declare variable $var := local:func1(); declare function local:func1() { local:func2($var) }; declare function local:func2($arg2) { $arg2 }; $var. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K-InternalVariablesWith-18a,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'XPST0003: Unable to parse XPath: declare variable $var := local:func1(); declare function local:func1() { local:func2($var) }; declare function local:func2($arg2) { $arg2 }; $var. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K-InternalVariablesWith-19,AssertionError: expected [Function] to throw error including 'XQST0054' but got 'XPST0003: Unable to parse XPath: declare variable $var2 := local:func1(); declare variable $var := ($var2 treat as xs:integer) + 1; declare function local:func1() { local:func2() }; declare function local:func2() { local:func3() }; declare function local:func3() { local:func4() }; declare function local:func4() { $var }; boolean($var). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K-InternalVariablesWith-19a,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'XPST0003: Unable to parse XPath: declare variable $var2 := local:func1(); declare variable $var := ($var2 treat as xs:integer) + 1; declare function local:func1() { local:func2() }; declare function local:func2() { local:func3() }; declare function local:func3() { local:func4() }; declare function local:func4() { $var }; boolean($var). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K-InternalVariablesWith-20,AssertionError: expected [Function] to throw error including 'XQST0054' but got 'XPST0003: Unable to parse XPath: declare variable $var := local:func1(); declare function local:func1() { local:func2() }; declare function local:func2() { local:func3() }; declare variable $var2 := local:func2(); declare function local:func3() { $var2 }; boolean($var). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K-InternalVariablesWith-20a,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'XPST0003: Unable to parse XPath: declare variable $var := local:func1(); declare function local:func1() { local:func2() }; declare function local:func2() { local:func3() }; declare variable $var2 := local:func2(); declare function local:func3() { $var2 }; boolean($var). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K-InternalVariablesWith-21,Error: XPST0003: Unable to parse XPath: declare variable $local:var as item() *:=3; true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-InternalVariablesWith-1,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $var1 as xs:string := 1 treat as item(); $var1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
extvardeclwithouttype-1,AssertionError: Expected executing the XPath "declare variable $x external; fn:string($x)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare variable $x external; fn:string($x))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $x external; fn:string($x). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
extvardeclwithouttype-2,AssertionError: Expected executing the XPath "declare variable $x external; $x" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare variable $x external; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $x external; $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
extvardeclwithouttype-3,AssertionError: Expected executing the XPath "declare variable $x external; xs:integer($x)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare variable $x external; xs:integer($x)) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $x external; xs:integer($x). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
extvardeclwithouttype-4,AssertionError: Expected executing the XPath "declare variable $x external; $x" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare variable $x external; $x) = (120). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $x external; $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
extvardeclwithouttype-5,AssertionError: Expected executing the XPath "declare variable $x external; $x" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare variable $x external; $x) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $x external; $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
extvardeclwithouttype-6,AssertionError: Expected executing the XPath "declare variable $x external; xs:float($x)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare variable $x external; xs:float($x))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $x external; xs:float($x). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
extvardeclwithouttype-7,AssertionError: Expected executing the XPath "declare variable $x external; $x" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare variable $x external; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $x external; $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
extvardeclwithouttype-8,AssertionError: Expected executing the XPath "declare variable $x external; $x + $x" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare variable $x external; $x + $x) = (4). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $x external; $x + $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
extvardeclwithouttype-9,AssertionError: Expected executing the XPath "declare variable $x external; $x" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare variable $x external; $x) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $x external; $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
extvardeclwithouttype-10,AssertionError: Expected executing the XPath "declare variable $x external; $x + $x" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare variable $x external; $x + $x) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $x external; $x + $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
extvardeclwithouttype-11,AssertionError: Expected executing the XPath "declare variable $x external; $x * $x" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare variable $x external; $x * $x) = (16). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $x external; $x * $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
extvardeclwithouttype-12,AssertionError: Expected executing the XPath "declare variable $x external; $x - 1" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare variable $x external; $x - 1) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $x external; $x - 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
extvardeclwithouttype-13,AssertionError: Expected executing the XPath "declare variable $x external; $x idiv 2" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare variable $x external; $x idiv 2) = (5). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $x external; $x idiv 2. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
extvardeclwithouttype-14,AssertionError: Expected executing the XPath "declare variable $x external; $x div 10" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare variable $x external; $x div 10) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $x external; $x div 10. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
extvardeclwithouttype-15,AssertionError: Expected executing the XPath "declare variable $x external; $x mod 2" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare variable $x external; $x mod 2) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $x external; $x mod 2. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
extvardeclwithouttype-16,AssertionError: Expected executing the XPath "declare variable $x external; $x and fn:false()" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: declare variable $x external; $x and fn:false(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found., AssertionError: expected [Function] to throw error including 'FORG0006' but got 'XPST0003: Unable to parse XPath: declare variable $x external; $x and fn:false(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
extvardeclwithouttype-17,AssertionError: Expected executing the XPath "declare variable $x external; $x or fn:false()" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: declare variable $x external; $x or fn:false(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found., AssertionError: expected [Function] to throw error including 'FORG0006' but got 'XPST0003: Unable to parse XPath: declare variable $x external; $x or fn:false(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
extvardeclwithouttype-18,Error: XPST0003: Unable to parse XPath: let $result := (declare variable $x external; $x) return $result ge 2.33333333333333. SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
extvardeclwithouttype-19,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $x external; xs:dateTime($x). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
extvardeclwithouttype-20,AssertionError: Expected executing the XPath "declare variable $x external; fn:upper-case($x)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare variable $x external; fn:upper-case($x))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $x external; fn:upper-case($x). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
extvardeclwithouttype-21,AssertionError: Expected executing the XPath "declare variable $x external; fn:lower-case($x)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare variable $x external; fn:lower-case($x))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $x external; fn:lower-case($x). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
extvardeclwithouttype-22,AssertionError: Expected executing the XPath "declare variable $x external; fn:not($x)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: declare variable $x external; fn:not($x). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found., AssertionError: expected [Function] to throw error including 'FORG0006' but got 'XPST0003: Unable to parse XPath: declare variable $x external; fn:not($x). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
extvardeclwithouttype-23,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: declare variable $x external; $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
extvardeclwithouttype-24,Error: XPST0003: Unable to parse XPath: (declare namespace test = "http://www.w3.org/fots/example-test-namespace";          declare variable $test:x external; $test:x) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
K2-ExternalVariablesWithout-1,AssertionError: expected [Function] to throw error including 'XQST0049' but got 'XPST0003: Unable to parse XPath: declare variable $input-context external; declare variable $input-context external; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-ExternalVariablesWithout-2,AssertionError: expected [Function] to throw error including 'XQST0049' but got 'XPST0003: Unable to parse XPath: declare variable $input-context external; declare variable $input-context external; $input-context. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-ExternalVariablesWithout-3,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'XPST0003: Unable to parse XPath: \n        declare default element namespace ""; \n        declare namespace prefix = ""; \n        declare variable $prefix:input-context external; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'
K2-ExternalVariablesWithout-4,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: \n        \n        declare variable $exampleComThisVarIsNotRecognized external; $exampleComThisVarIsNotRecognized. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-ExternalVariablesWithout-5,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: \n        declare namespace e = "http://example.com/ANamespace"; \n        declare variable $e:exampleComThisVarIsNotRecognized external; \n        $e:exampleComThisVarIsNotRecognized. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
K2-ExternalVariablesWithout-6,AssertionError: Expected executing the XPath "declare variable $exampleComThisVarIsNotRecognized external; 1" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare variable $exampleComThisVarIsNotRecognized external; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found., AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: declare variable $exampleComThisVarIsNotRecognized external; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
K2-ExternalVariablesWithout-7,AssertionError: Expected executing the XPath "declare namespace e = "http://example.com/ANamespace"; declare variable $e:exampleComThisVarIsNotRecognized external; 1" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare namespace e = "http://example.com/ANamespace"; declare variable $e:exampleComThisVarIsNotRecognized external; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found., AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: declare namespace e = "http://example.com/ANamespace"; declare variable $e:exampleComThisVarIsNotRecognized external; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'.
K2-ExternalVariablesWithout-8,Error: XPST0003: Unable to parse XPath: (declare variable $ name := 3; $ name) = (3). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
K2-ExternalVariablesWithout-9,Error: XPST0003: Unable to parse XPath: declare variable $e := current-time(); let $i := ($e, 1 to 50000, $e) return $i[1] = $i[last()]. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-ExternalVariablesWithout-10,Error: XPST0003: Unable to parse XPath: declare variable $e := <e> <a/> </e>; declare variable $f := $e; <r> { $e is $e, $f is $e, $e, $f } </r>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-ExternalVariablesWithout-11,Error: XPST0003: Unable to parse XPath: (declare variable $a as attribute()* := (attribute name1 {()}, attribute name2 {()}, attribute name3 {()}); declare variable $b as attribute()* := (attribute name1 {()}, attribute name2 {()}, attribute name3 {()}); $a/(let $p := position() return . is $b[$p]))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
K2-ExternalVariablesWithout-12,Error: XPST0003: Unable to parse XPath: declare variable $a as attribute()* := (attribute name1 {()}, attribute name2 {()}, attribute name3 {()}); <r> <e> { $a } </e> <e> { $a } </e> </r>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-ExternalVariablesWithout-13,Error: XPST0003: Unable to parse XPath: (declare variable $e := <e>{current-time()}</e>/(string-length(.) > 0); $e, if($e) then "SUCCESS" else "FAILURE")!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
K2-ExternalVariablesWithout-18b,Error: XPST0003: Unable to parse XPath: (declare variable $var external := 1; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
K2-ExternalVariablesWithout-19,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: declare variable $global := count(*); <e/>/$global. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-ExternalVariablesWithout-20,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: \n        declare variable $global := count(*); \n        <e/>/($global, $global). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-ExternalVariablesWithout-21,Error: XPST0003: Unable to parse XPath: (declare variable $global := count(*); $global, <wrongFocus> <e1/> <e2/> </wrongFocus>/$global, $global)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
K2-ExternalVariablesWithout-22,Error: XPST0003: Unable to parse XPath: (declare variable $global := count(*); <wrongFocus> <e1/> <e2/> </wrongFocus>/$global) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
extvardeclwithtype-1,Error: XPST0003: Unable to parse XPath: (declare variable $x as xs:string external; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
extvardeclwithtype-2,Error: XPST0003: Unable to parse XPath: (declare variable $x as xs:date external; fn:string($x))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
extvardeclwithtype-3,Error: XPST0003: Unable to parse XPath: (declare variable $x as xs:integer external; $x) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
extvardeclwithtype-4,Error: XPST0003: Unable to parse XPath: (declare variable $x as xs:double external; $x) = (120). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
extvardeclwithtype-5,Error: XPST0003: Unable to parse XPath: (declare variable $x as xs:boolean external; fn:string($x))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
extvardeclwithtype-6,AssertionError: Expected executing the XPath "declare variable $x as xs:float external; $x" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare variable $x as xs:float external; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found., Error: XPST0003: Unable to parse XPath: (declare variable $x as xs:float external; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found..
extvardeclwithtype-7,Error: XPST0003: Unable to parse XPath: (declare variable $x as xs:decimal external; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
extvardeclwithtype-8,Error: XPST0003: Unable to parse XPath: (declare variable $x as xs:integer external; $x + $x) = (4). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
extvardeclwithtype-9,Error: XPST0003: Unable to parse XPath: (declare variable $x as xs:integer external; $x) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
extvardeclwithtype-10,Error: XPST0003: Unable to parse XPath: (declare variable $x as xs:integer external; $x + $x) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
extvardeclwithtype-11,Error: XPST0003: Unable to parse XPath: (declare variable $x as xs:integer external; $x * $x) = (16). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
extvardeclwithtype-12,Error: XPST0003: Unable to parse XPath: (declare variable $x as xs:integer external; $x - xs:integer(1)) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
extvardeclwithtype-13,Error: XPST0003: Unable to parse XPath: (declare variable $x as xs:integer external; $x idiv xs:integer(2)) = (5). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
extvardeclwithtype-14,Error: XPST0003: Unable to parse XPath: (declare variable $x as xs:integer external; $x div xs:integer(10)) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
extvardeclwithtype-15,Error: XPST0003: Unable to parse XPath: (declare variable $x as xs:integer external; $x mod xs:integer(2)) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
extvardeclwithtype-16,Error: XPST0003: Unable to parse XPath: declare variable $x as xs:boolean external; $x and fn:false(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
extvardeclwithtype-17,Error: XPST0003: Unable to parse XPath: declare variable $x as xs:boolean external; $x or fn:false(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
extvardeclwithtype-18,AssertionError: Expected executing the XPath "declare variable $x as xs:float external; $x" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare variable $x as xs:float external; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found., Error: XPST0003: Unable to parse XPath: (declare variable $x as xs:float external; $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found..
extvardeclwithtype-19,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $x as xs:dateTime external; $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
extvardeclwithtype-20,Error: XPST0003: Unable to parse XPath: (declare variable $x as xs:string external; fn:upper-case($x))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
extvardeclwithtype-21,Error: XPST0003: Unable to parse XPath: (declare variable $x as xs:string external; fn:lower-case($x))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
extvardeclwithtype-22,Error: XPST0003: Unable to parse XPath: declare variable $x as xs:boolean external; fn:not($x). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
extvardeclwithtype-23,Error: XPST0003: Unable to parse XPath: (:      This query opens a C++ GCC-XML output file, and outputs a report describing the use     of globals variables. :) declare variable $inputDocument := (/);  (: Determines whether the type by ID @p typeId is a complex type such as QString. :) declare function local:isComplexType($typeID as xs:string) as xs:boolean {     (: We're being a bit crude here and only checks whether it's a class. We        actually should check whether it has non-synthesized,         constructors, I believe. :)          exists($inputDocument/xml/Class[@id = $typeID])     or     (: We also want const-qualified variables. :)     exists($inputDocument/xml/Class[@id = $inputDocument/xml/CvQualifiedType[@id = $typeID]/@type]) };  declare function local:isPrimitive($typeId as xs:string) as xs:boolean {     exists($inputDocument/xml/FundamentalType[@id = $typeId]) };  (: Returns a string for human consumption that describes    the location of @p block. :) declare function local:location($block as element()) as xs:string {     concat($inputDocument/xml/File[@id = $block/@file]/@name, " at line ", $block/@line) };  declare function local:report() as element()+ {             let $complexVariables as element(Variable)* := $inputDocument/xml/Variable[local:isComplexType(@type)]             return if(exists($complexVariables)) (: Is the length larger than zero? :)                     then (<p xmlns="http://www.w3.org/1999/xhtml/">The following global, complex variables were found:</p>,                          <ol xmlns="http://www.w3.org/1999/xhtml/">                             {                                 (: For each Variable in $complexVariables... :)                                 for $v in $complexVariables                                 return $v/<li><span class="variableName">{string(@name)}</span> in {local:location(.)}</li>                             }                          </ol>)                     else <p xmlns="http://www.w3.org/1999/xhtml/">No global variables that are of complex types were found.</p>              ,              (: List primitive, mutable types. :)             let $primitiveVariables as element(Variable)+ := $inputDocument/xml/Variable[local:isPrimitive(@type)]             return if(exists($primitiveVariables))                     then (<p xmlns="http://www.w3.org/1999/xhtml/">The following mutable primitives were found:</p>,                          <ol xmlns="http://www.w3.org/1999/xhtml/">                             {                                 (: For each Variable in $complexVariables... :)                                 for $v in $primitiveVariables                                 return $v/<li><span class="variableName">{string(@name)}</span> in {local:location(.)}</li>                             }                          </ol>)                     else <p xmlns="http://www.w3.org/1999/xhtml/">No global variables that are of complex types were found.</p> };  <html xmlns="http://www.w3.org/1999/xhtml/" xml:lang="en" lang="en">     <head>         <title>Global variables report for {"Globals.cpp"}</title>     </head>     <style type="text/css">         .details         {{             text-align: center;             font-size: 80%;             color: gray         }}         .variableName         {{             font-family: courier         }}     </style>      <body>         {             (: We don't want simple types that are const, but all other types.                One could frown upon const integers and say enums should be used instead, but                let's be gentle. :)              local:report()         }          <p class="details">This report was generated on</p>     </body>  </html> . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
extvardeclwithtype-24,Error: XPST0003: Unable to parse XPath: (declare namespace test = "http://www.w3.org/fots/example-test-namespace";          declare variable $test:x as xs:integer external; $test:x) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
K2-ExternalVariablesWith-1,AssertionError: expected [Function] to throw error including 'XQST0049' but got 'XPST0003: Unable to parse XPath: declare variable $input-context as item()* external; declare variable $input-context external; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-ExternalVariablesWith-2,AssertionError: expected [Function] to throw error including 'XQST0049' but got 'XPST0003: Unable to parse XPath: declare variable $input-context external; declare variable $input-context as item()* external; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-ExternalVariablesWith-3,AssertionError: expected [Function] to throw error including 'XQST0049' but got 'XPST0003: Unable to parse XPath: declare variable $input-context as item()* external ; declare variable $input-context as item()*external ; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-ExternalVariablesWith-4,AssertionError: expected [Function] to throw error including 'XQST0049' but got 'XPST0003: Unable to parse XPath: declare variable $input-context as item()* external ; declare variable $input-context as item()*external ; $input-context. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-ExternalVariablesWith-5,AssertionError: expected [Function] to throw error including 'XQST0049' but got 'XPST0003: Unable to parse XPath: declare variable $input-context as item()* external; declare variable $input-context as item()*external; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-ExternalVariablesWith-6,AssertionError: expected [Function] to throw error including 'XQST0049' but got 'XPST0003: Unable to parse XPath: declare variable $input-context as xs:string* external; declare variable $input-context as item()*external; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-ExternalVariablesWith-7,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: declare variable $exampleComThisVarIsNotRecognized as xs:string *external; $exampleComThisVarIsNotRecognized. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-ExternalVariablesWith-8,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: declare namespace e = "http://example.com/ANamespace"; declare variable $e:exampleComThisVarIsNotRecognized as comment() *external; $e:exampleComThisVarIsNotRecognized. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
K2-ExternalVariablesWith-9,AssertionError: Expected executing the XPath "declare variable $exampleComThisVarIsNotRecognized as processing-instruction()? external; 1" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare variable $exampleComThisVarIsNotRecognized as processing-instruction()? external; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found., AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: declare variable $exampleComThisVarIsNotRecognized as processing-instruction()? external; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
K2-ExternalVariablesWith-10,AssertionError: Expected executing the XPath "declare namespace e = "http://example.com/ANamespace"; declare variable $e:exampleComThisVarIsNotRecognized as element(*) external; 1" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare namespace e = "http://example.com/ANamespace"; declare variable $e:exampleComThisVarIsNotRecognized as element(*) external; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found., AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: declare namespace e = "http://example.com/ANamespace"; declare variable $e:exampleComThisVarIsNotRecognized as element(*) external; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'.
K2-ExternalVariablesWith-12,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $i as xs:integer := xs:untypedAtomic("1"); $i. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-ExternalVariablesWith-13,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $i as xs:float := 1.1 ; $i. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-ExternalVariablesWith-14,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $i as xs:double := 1.1 ; $i. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-ExternalVariablesWith-15,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $i as xs:float := 1 ; $i. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-ExternalVariablesWith-16,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $i as xs:double := 1 ; $i. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-ExternalVariablesWith-17,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $i as xs:double := xs:float(3) ; $i. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-ExternalVariablesWith-18,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $i as xs:string := xs:untypedAtomic("a string") ; $i. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-ExternalVariablesWith-19,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $i as xs:string := xs:anyURI("http://www.example.com/") ; $i. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-ExternalVariablesWith-20,AssertionError: expected [Function] to throw error including 'XQST0049' but got 'XPST0003: Unable to parse XPath: declare variable $input-context1 external; declare variable $input-context1 := 1; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-ExternalVariablesWith-21,AssertionError: expected [Function] to throw error including 'XQST0049' but got 'XPST0003: Unable to parse XPath: declare variable $input-context1 external; declare variable $input-context1 := 1; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-ExternalVariablesWith-22,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $v as element(*, xs:untyped?)+ := <e/>; exists($v/*). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K2-ExternalVariablesWith-22a,Error: XPST0003: Unable to parse XPath: declare variable $v as element(*, xs:untyped?)+ := <e/>; exists($v/*). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-ExternalVariablesWith-23,Error: XPST0003: Unable to parse XPath: (declare variable $v as element(elementName, xs:anyType?)+ := <elementName/>; 1) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
extvardef-001,Error: XPST0003: Unable to parse XPath: declare variable $ext external := 0; <a>{$ext}</a>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
extvardef-001a,Error: XPST0003: Unable to parse XPath: (declare variable $ext external := 0; $ext) = (5). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
extvardef-002,Error: XPST0003: Unable to parse XPath: declare variable $ext as xs:integer external := 0; <a>{$ext}</a>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
extvardef-002a,Error: XPST0003: Unable to parse XPath: declare variable $ext as xs:integer external := 0; <a>{$ext}</a>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
extvardef-002b,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $ext as xs:integer external := 0; <a>{$ext}</a>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
extvardef-003,Error: XPST0003: Unable to parse XPath: declare variable $ext as xs:integer* external := (0,1,2); <a>{sum($ext)}</a>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
extvardef-003a,Error: XPST0003: Unable to parse XPath: declare variable $ext as xs:integer* external := (0,1,2); <a>{sum($ext)}</a>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
extvardef-003b,Error: XPST0003: Unable to parse XPath: declare variable $ext as xs:integer* external := (0,1,2); <a>{sum($ext)}</a>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
extvardef-006,Error: XPST0003: Unable to parse XPath:           declare variable $var as xs:integer := 17;           declare variable $ext as element(a) external := <a>{$var}</a>;           <out>{$ext}</out>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
extvardef-006a,Error: XPST0003: Unable to parse XPath:          declare variable $var as xs:integer := 17;          declare variable $ext as xs:integer external := $var;          <out>{$ext}</out>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
extvardef-006b,AssertionError: Expected executing the XPath "         declare variable $var as xs:integer := 17;          declare variable $ext as xs:integer external := <a>{$var}</a>;          <out>{$ext}</out>       " to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare variable $var as xs:integer := 17; \n        declare variable $ext as xs:integer external := <a>{$var}</a>; \n        <out>{$ext}</out>\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.', Error: XPST0003: Unable to parse XPath:          declare variable $var as xs:integer := 17;          declare variable $ext as xs:integer external := <a>{$var}</a>;          <out>{$ext}</out>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found..
extvardef-007,Error: XPST0003: Unable to parse XPath:          declare variable $ext as xs:date external := current-date() + xs:dayTimeDuration('P30D');          $ext gt xs:date('2008-12-30')       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
extvardef-008,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: declare variable $x external; $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
extvardef-009,AssertionError: Expected executing the XPath "declare variable $x external; "result"" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare variable $x external; "result")!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found., AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: declare variable $x external; "result". SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
extvardef-010,Error: XPST0003: Unable to parse XPath: (         declare variable $a := 1;         declare variable $x external := $a + $b;         declare variable $b external := 2;         $x       ) = (3). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
extvardef-010a,Error: XPST0003: Unable to parse XPath: (         declare variable $a external := 6 + local:foo();         declare variable $b external := 12;         declare function local:foo() { $b + 10 };         $a       ) = (28). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
extvardef-011,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'XPST0003: Unable to parse XPath: \n        declare variable $a := $x;\n        declare variable $x external := $a + 2;\n        $x\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
extvardef-011a,AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'XPST0003: Unable to parse XPath: \n        declare variable $x external := 3 + local:foo();\n        declare variable $b external := 2 + local:foo();\n\n        declare function local:foo()\n        {\n         $b\n         };\n\n         $x\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
extvardef-012,Error: XPST0003: Unable to parse XPath: (         declare function local:aaa() { 1 };         declare variable $x external := local:bbb() + local:aaa();         declare function local:bbb() { 2 };         $x        ) = (3). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
extvardef-013,Error: XPST0003: Unable to parse XPath: (         declare variable $y external;         declare variable $z external := 10;         declare function local:aaa() { $z };         declare variable $x external := local:bbb() + local:aaa() + 2;         declare function local:bbb() { $y };         $x        ) = (28). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
extvardef-014,Error: XPST0003: Unable to parse XPath: (         declare variable $x external := /works/employee[@name eq "Jane Doe 1"];         fn:count($x)       ) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
extvardef-015,AssertionError: Expected executing the XPath "         declare variable $y := /works/employee;         declare context item := $y[9];         declare variable $x external := fn:position();         $x       " to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: \n        declare variable $y := /works/employee;\n        declare context item := $y[9];\n        declare variable $x external := fn:position();\n        $x\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.', AssertionError: expected [Function] to throw error including 'XQDY0054' but got 'XPST0003: Unable to parse XPath: \n        declare variable $y := /works/employee;\n        declare context item := $y[9];\n        declare variable $x external := fn:position();\n        $x\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
extvardef-016a,Error: XPST0003: Unable to parse XPath: (         declare variable $y := (<a>1</a>,<a>2</a>,<a>3</a>,<a>4</a>,<a>5</a>,<a>6</a>,<a>7</a>,<a>8</a>,<a>9</a>,<a>10</a>);         declare context item := $y[3];         declare variable $x external := fn:position();         $x       ) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
extvardef-016b,Error: XPST0003: Unable to parse XPath: (         declare variable $y := <root><a>1</a>,<a>2</a>,<a>3</a>,<a>4</a>,<a>5</a>,<a>6</a>,<a>7</a>,<a>8</a>,<a>9</a>,<a>10</a></root>;         declare context item := $y;         declare variable $x external := fn:last();         $x       ) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
extvardef-017,Error: XPST0003: Unable to parse XPath: (         declare variable $x as xs:decimal external := xs:integer(10);         $x       ) = (10). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
extvardef-018,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'XPST0003: Unable to parse XPath: \n        declare variable $x external := $a + 10;\n        $x\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
extvardef-019,Error: XPST0003: Unable to parse XPath: (         declare variable $x external := 10;         declare variable $y external := 18 + $x;         $y       ) = (28). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
extvardef-020,Error: XPST0003: Unable to parse XPath: (         declare variable $x external := 5;         declare variable $a := $x + 2;         declare function local:foo() {$x +$a};         declare variable $y external := 11 + local:foo() + $x;         $y       ) = (28). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
extvardef-021,Error: XPST0003: Unable to parse XPath: (         declare variable $x as xs:integer external := xs:int(5);         declare variable $y as xs:decimal external := $x;         $y instance of xs:decimal       ) = (fn:true()). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
extvardef-022,Error: XPST0003: Unable to parse XPath: (         declare function local:foo() {           $x         };         declare variable $x external := 5;         local:foo()       ) = (5). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
version_declaration-007,AssertionError: expected [Function] to throw error including 'XQST0031' but got 'XPST0003: Unable to parse XPath: xquery version \'-1.0\'; 2 + 2. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
version_declaration-008,AssertionError: expected [Function] to throw error including 'XQST0031' but got 'XPST0003: Unable to parse XPath: xquery version "abc"; 1,2. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
version_declaration-021,AssertionError: Expected executing the XPath "xquery version "2.0"; 1.2" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (xquery version "2.0"; 1.2) = (1.2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found., AssertionError: expected [Function] to throw error including 'XQST0031' but got 'XPST0003: Unable to parse XPath: xquery version "2.0"; 1.2. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
VersionDecl-v1-processor-and-v3-query,AssertionError: expected [Function] to throw error including 'XQST0031' but got 'XPST0003: Unable to parse XPath: xquery version "3.0"; <bib/>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
VersionDecl-v3-processor-and-v1-query,AssertionError: Expected executing the XPath "xquery version "1.0"; <bib/>" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0031' but got 'XPST0003: Unable to parse XPath: xquery version "1.0"; <bib/>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.', Error: XPST0003: Unable to parse XPath: xquery version "1.0"; <bib/>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found..
version_declaration-010,AssertionError: expected [Function] to throw error including 'XQST0087' but got 'XPST0003: Unable to parse XPath: xquery version "1.0" encoding "999-UTF-8-*"; "ABC". SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
version_declaration-010-v3,AssertionError: expected [Function] to throw error including 'XQST0087' but got 'XPST0003: Unable to parse XPath: xquery version "3.0" encoding "999-UTF-8-*"; "ABC". SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K-VersionProlog-3,AssertionError: expected [Function] to throw error including 'XQST0087' but got 'XPST0003: Unable to parse XPath: xquery version "1.0" encoding "UTF-8 "; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K-VersionProlog-3-v3,AssertionError: expected [Function] to throw error including 'XQST0087' but got 'XPST0003: Unable to parse XPath: xquery version "3.0" encoding "UTF-8 "; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K-VersionProlog-4,AssertionError: expected [Function] to throw error including 'XQST0087' but got 'XPST0003: Unable to parse XPath: xquery version "1.0" encoding "ISO-8859-1|"; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K-VersionProlog-4-v3,AssertionError: expected [Function] to throw error including 'XQST0087' but got 'XPST0003: Unable to parse XPath: xquery version "3.0" encoding "ISO-8859-1|"; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
K-VersionProlog-2,Error: XPST0003: Unable to parse XPath: xquery version "1.0" ; 1 eq 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K-VersionProlog-2-v3,Error: XPST0003: Unable to parse XPath: xquery version "3.0" ; 1 eq 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K-VersionProlog-2-v31,Error: XPST0003: Unable to parse XPath: xquery version "3.1" ; 1 eq 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
prolog-version-4,Error: XPST0003: Unable to parse XPath: (xquery version "1.0"; 1,2)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
prolog-version-4-v3,Error: XPST0003: Unable to parse XPath: (xquery version "3.0"; 1,2)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
prolog-version-4-v31,Error: XPST0003: Unable to parse XPath: (xquery version "3.1"; 1,2)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
prolog-version-5,Error: XPST0003: Unable to parse XPath: xquery version "1.0"; <bib/>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
prolog-version-5-v3,Error: XPST0003: Unable to parse XPath: xquery version "3.0"; <bib/>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
prolog-version-5-v31,Error: XPST0003: Unable to parse XPath: xquery version "3.1"; <bib/>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
prolog-version-6,Error: XPST0003: Unable to parse XPath:          xquery version '1.0';          declare boundary-space preserve;          declare default order empty greatest;          declare namespace ns = "http://www.example.org/";          for $b in//book stable order by xs:decimal($b/price[1]) empty greatest          return $b/title. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
prolog-version-6-v3,Error: XPST0003: Unable to parse XPath:          xquery version '3.0';          declare boundary-space preserve;          declare default order empty greatest;          declare namespace ns = "http://www.example.org/";          for $b in//book stable order by xs:decimal($b/price[1]) empty greatest          return $b/title. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
prolog-version-6-v31,Error: XPST0003: Unable to parse XPath:           xquery version '3.1';           declare boundary-space preserve;           declare default order empty greatest;           declare namespace ns = "http://www.example.org/";           for $b in//book stable order by xs:decimal($b/price[1]) empty greatest           return $b/title. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
prolog-version-7,Error: XPST0003: Unable to parse XPath:          xquery version "1.0";          declare boundary-space preserve;          declare default order empty greatest;          declare namespace ns = "http://www.example.org/";          for $b in //book stable order by xs:decimal($b/price[1]) empty greatest          return $b/title. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
prolog-version-7-v3,Error: XPST0003: Unable to parse XPath:          xquery version "3.0";          declare boundary-space preserve;          declare default order empty greatest;          declare namespace ns = "http://www.example.org/";          for $b in //book stable order by xs:decimal($b/price[1]) empty greatest          return $b/title. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
prolog-version-7-v31,Error: XPST0003: Unable to parse XPath:           xquery version "3.1";           declare boundary-space preserve;           declare default order empty greatest;           declare namespace ns = "http://www.example.org/";           for $b in //book stable order by xs:decimal($b/price[1]) empty greatest           return $b/title. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
prolog-version-1,Error: XPST0003: Unable to parse XPath: (xquery version "1.0" encoding "utf-8"; 1,2)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
prolog-version-1-v3,Error: XPST0003: Unable to parse XPath: (xquery version "3.0" encoding "utf-8"; 1,2)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
prolog-version-3,Error: XPST0003: Unable to parse XPath: (xquery version "1.0" encoding "US-ASCII"; 1,2)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
prolog-version-3-v3,Error: XPST0003: Unable to parse XPath: (xquery version "3.0" encoding "US-ASCII"; 1,2)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
K-VersionProlog-5,Error: XPST0003: Unable to parse XPath:          xquery version "1.0" encoding "ISO-8859-1";          declare boundary-space preserve;          declare default collation "http://www.w3.org/2005/xpath-functions/collation/codepoint";          declare base-uri "http://example.com/";          declare construction strip;          declare ordering ordered;          declare default order empty greatest;          declare copy-namespaces no-preserve, no-inherit;          declare namespace ex = "http://example.com/a/Namespace";          declare default element namespace "http://example.com/";          declare default function namespace "http://example.com/";          declare option fn:x-notRecognized "option content";          1 eq 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K-VersionProlog-5-v3,Error: XPST0003: Unable to parse XPath:          xquery version "3.0" encoding "ISO-8859-1";          declare boundary-space preserve;          declare default collation "http://www.w3.org/2005/xpath-functions/collation/codepoint";          declare base-uri "http://example.com/";          declare construction strip;          declare ordering ordered;          declare default order empty greatest;          declare copy-namespaces no-preserve, no-inherit;          declare namespace ex = "http://example.com/a/Namespace";          declare default element namespace "http://example.com/";          declare default function namespace "http://example.com/";          declare option fn:x-notRecognized "option content";          1 eq 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
version_declaration-023-v3,Error: XPST0003: Unable to parse XPath: xquery encoding "utf-8"; 1 eq 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "e" found.
K2-VersionProlog-3-v4,Error: XPST0003: Unable to parse XPath: xquery version '1&#x2e;0' encoding 'UTF-8'; true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
K2-VersionProlog-6,Error: XPST0003: Unable to parse XPath: xquery version '1.0' encoding 'UTF&#x2d;8'; true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
combined-errors-1,AssertionError: Expected executing the XPath "import module namespace defs="http://www.w3.org/TestModules/defs"; "ABC"" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (import module namespace defs="http://www.w3.org/TestModules/defs"; "ABC")!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", or "||" but "m" found., AssertionError: expected [Function] to throw error including 'XQST0016' but got 'XPST0003: Unable to parse XPath: import module namespace defs="http://www.w3.org/TestModules/defs"; "ABC". SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", "||", or end of input but "m" found.'.
combined-errors-2,AssertionError: Expected executing the XPath "import schema namespace atomic="http://www.w3.org/XQueryTest"; "ABC"" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (import schema namespace atomic="http://www.w3.org/XQueryTest"; "ABC")!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "s" found., AssertionError: expected [Function] to throw error including 'XQST0009' but got 'XPST0003: Unable to parse XPath: import schema namespace atomic="http://www.w3.org/XQueryTest"; "ABC". SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "s" found.'.
combined-errors-3,AssertionError: Expected executing the XPath "declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          import schema "http://www.w3.org/XQueryTestOrderBy";          validate strict {<Strings><orderData>one string</orderData></Strings>}" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy";          import schema "http://www.w3.org/XQueryTestOrderBy";          validate strict {<Strings><orderData>one string</orderData></Strings>}. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found., AssertionError: expected [Function] to throw error including 'XQST0075' but got 'XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy"; \n        import schema "http://www.w3.org/XQueryTestOrderBy"; \n        validate strict {<Strings><orderData>one string</orderData></Strings>}. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.', AssertionError: expected [Function] to throw error including 'XQST0009' but got 'XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/XQueryTestOrderBy"; \n        import schema "http://www.w3.org/XQueryTestOrderBy"; \n        validate strict {<Strings><orderData>one string</orderData></Strings>}. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'.
combined-errors-4,AssertionError: Expected executing the XPath "/works[1]/employee[2]/preceding::employee" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: /works[1]/employee[2]/preceding::employee. SyntaxError: Expected [A-Z_a-z----------] or [-] but ":" found., AssertionError: expected [Function] to throw error including 'XPST0010' but got 'XPST0003: Unable to parse XPath: /works[1]/employee[2]/preceding::employee. SyntaxError: Expected [A-Z_a-z----------] or [-] but ":" found.'.
K-CombinedErrorCodes-1,AssertionError: Expected executing the XPath "import schema "http://example.com/NSNOTRECOGNIZED"; 1 eq 1" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0009' but got 'XPST0003: Unable to parse XPath: import schema "http://example.com/NSNOTRECOGNIZED"; 1 eq 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "s" found.', AssertionError: expected [Function] to throw error including 'XQST0059' but got 'XPST0003: Unable to parse XPath: import schema "http://example.com/NSNOTRECOGNIZED"; 1 eq 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "s" found.'.
K-CombinedErrorCodes-2,AssertionError: Expected executing the XPath "import schema "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST"; 1 eq 1" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0009' but got 'XPST0003: Unable to parse XPath: import schema "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST"; 1 eq 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "s" found.', AssertionError: expected [Function] to throw error including 'XQST0059' but got 'XPST0003: Unable to parse XPath: import schema "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST"; 1 eq 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "s" found.'.
K-CombinedErrorCodes-3,AssertionError: Expected executing the XPath "import schema "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST", "http://example.com/2", "http://example.com/3"; 1 eq 1" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0009' but got 'XPST0003: Unable to parse XPath: import schema "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST", "http://example.com/2", "http://example.com/3"; 1 eq 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "s" found.', AssertionError: expected [Function] to throw error including 'XQST0059' but got 'XPST0003: Unable to parse XPath: import schema "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST", "http://example.com/2", "http://example.com/3"; 1 eq 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "s" found.'.
K-CombinedErrorCodes-4,AssertionError: Expected executing the XPath "import schema "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST", "http://example.com/2", "http://example.com/3"; 1 eq 1" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0009' but got 'XPST0003: Unable to parse XPath: import schema "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST", "http://example.com/2", "http://example.com/3"; 1 eq 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "s" found.', AssertionError: expected [Function] to throw error including 'XQST0059' but got 'XPST0003: Unable to parse XPath: import schema "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST", "http://example.com/2", "http://example.com/3"; 1 eq 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "s" found.'.
K-CombinedErrorCodes-5,AssertionError: Expected executing the XPath "import schema namespace prefix = "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST", "http://example.com/2DOESNOTEXIST", "http://example.com/3DOESNOTEXIST"; 1 eq 1" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0009' but got 'XPST0003: Unable to parse XPath: import schema namespace prefix = "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST", "http://example.com/2DOESNOTEXIST", "http://example.com/3DOESNOTEXIST"; 1 eq 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "s" found.', AssertionError: expected [Function] to throw error including 'XQST0059' but got 'XPST0003: Unable to parse XPath: import schema namespace prefix = "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST", "http://example.com/2DOESNOTEXIST", "http://example.com/3DOESNOTEXIST"; 1 eq 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "s" found.'.
K-CombinedErrorCodes-6,AssertionError: Expected executing the XPath "import schema default element namespace "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST", "http://example.com/2DOESNOTEXIST", "http://example.com/3DOESNOTEXIST"; 1 eq 1" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0009' but got 'XPST0003: Unable to parse XPath: import schema default element namespace "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST", "http://example.com/2DOESNOTEXIST", "http://example.com/3DOESNOTEXIST"; 1 eq 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "s" found.', AssertionError: expected [Function] to throw error including 'XQST0059' but got 'XPST0003: Unable to parse XPath: import schema default element namespace "http://example.com/NSNOTRECOGNIZED" at "http://example.com/DOESNOTEXIST", "http://example.com/2DOESNOTEXIST", "http://example.com/3DOESNOTEXIST"; 1 eq 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "s" found.'.
K-CombinedErrorCodes-9,AssertionError: Expected executing the XPath "validate { 1 }" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQTY0030' but got 'XPST0003: Unable to parse XPath: validate { 1 }. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.', AssertionError: expected [Function] to throw error including 'XQST0075' but got 'XPST0003: Unable to parse XPath: validate { 1 }. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'.
K-CombinedErrorCodes-10,AssertionError: Expected executing the XPath "validate { () }" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQTY0030' but got 'XPST0003: Unable to parse XPath: validate { () }. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.', AssertionError: expected [Function] to throw error including 'XQST0075' but got 'XPST0003: Unable to parse XPath: validate { () }. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'.
K-CombinedErrorCodes-11,AssertionError: Expected executing the XPath "validate lax { 1 }" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQTY0030' but got 'XPST0003: Unable to parse XPath: validate lax { 1 }. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "l" found.', AssertionError: expected [Function] to throw error including 'XQST0075' but got 'XPST0003: Unable to parse XPath: validate lax { 1 }. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "l" found.'.
K-CombinedErrorCodes-12,AssertionError: Expected executing the XPath "validate strict { 1 }" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQTY0030' but got 'XPST0003: Unable to parse XPath: validate strict { 1 }. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "s" found.', AssertionError: expected [Function] to throw error including 'XQST0075' but got 'XPST0003: Unable to parse XPath: validate strict { 1 }. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "s" found.'.
FOAR0001_1,AssertionError: expected [Function] to throw an error
FOAR0001_2,AssertionError: expected [Function] to throw an error
FOAR0001_3,AssertionError: expected [Function] to throw an error
FOAR0001_4,AssertionError: expected [Function] to throw an error
FOAR0001_5,AssertionError: expected [Function] to throw an error
FOAR0001_6,AssertionError: expected [Function] to throw an error
FOAR0001_7,AssertionError: expected [Function] to throw an error
FOAR0001_8,AssertionError: expected [Function] to throw an error
FOAR0001_9,AssertionError: expected [Function] to throw error including 'FOAR0001' but got 'XPTY0004: the operands of the "div" operator should be of type xs:numeric?.'
FOAR0002_3,AssertionError: expected [Function] to throw an error
FOAR0002_4,AssertionError: expected [Function] to throw an error
FOAR0002-5,AssertionError: Expected executing the XPath "xs:dayTimeDuration('P5999999999999999999DT00H00M01S') div xs:dayTimeDuration('P0DT00H00M0.000001S')" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FOAR0002' but got 'XPTY0004: the operands of the "div" operator should be of type xs:numeric?.', AssertionError: expected [Function] to throw error including 'FODT0002' but got 'XPTY0004: the operands of the "div" operator should be of type xs:numeric?.'.
FOCA0001_1,AssertionError: Expected executing the XPath "xs:decimal(1e308)" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw an error, AssertionError: xs:decimal(1e308): expected false to be true.
FOCA0002_7,AssertionError: expected [Function] to throw error including 'FOCA0002' but got 'XPST0017: Function resolve-QName with arity of 2 not registered. No similar functions found.'
FOCA0002_8,AssertionError: expected [Function] to throw error including 'FOCA0002' but got 'XPST0017: Function resolve-QName with arity of 2 not registered. No similar functions found.'
FOCA0002_9,AssertionError: expected [Function] to throw error including 'FOCA0002' but got 'XPST0017: Function resolve-QName with arity of 2 not registered. No similar functions found.'
FOCA0003_1,AssertionError: Expected executing the XPath "xs:integer(xs:double(1e308))" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FOCA0003' but got 'FOAR0002: can not cast 1e+308 to xs:integer, it is out of bounds for JavaScript numbers.', Error: FOAR0002: can not cast 1e+308 to xs:integer, it is out of bounds for JavaScript numbers..
FOCA0005_1,AssertionError: expected [Function] to throw error including 'FOCA0005' but got 'XPTY0004: the operands of the "div" operator should be of type xs:numeric?.'
FOCA0005_2,AssertionError: expected [Function] to throw error including 'FOCA0005' but got 'XPTY0004: the operands of the "*" operator should be of type xs:numeric?.'
FOCA0005_3,AssertionError: expected [Function] to throw error including 'FOCA0005' but got 'XPTY0004: the operands of the "div" operator should be of type xs:numeric?.'
FOCA0005_4,AssertionError: expected [Function] to throw error including 'FOCA0005' but got 'XPTY0004: the operands of the "*" operator should be of type xs:numeric?.'
FOCH0001,AssertionError: expected [Function] to throw error including 'FOCH0001' but got 'XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.'
FOCH0002_10,AssertionError: expected [Function] to throw error including 'FOCH0002' but got 'XPST0017: Function substring-before with arity of 3 not registered. Did you mean "substring-before (xs:string?, xs:string?)"?'
FOCH0002_3,AssertionError: expected [Function] to throw error including 'FOCH0002' but got 'XPST0017: Function distinct-values with arity of 2 not registered. No similar functions found.'
FOCH0002_5,AssertionError: expected [Function] to throw error including 'FOCH0002' but got 'XPST0017: Function index-of with arity of 3 not registered. No similar functions found.'
FOCH0002_9,AssertionError: expected [Function] to throw error including 'FOCH0002' but got 'XPST0017: Function substring-after with arity of 3 not registered. Did you mean "substring-after (xs:string?, xs:string?)"?'
FODC0001_1,AssertionError: expected [Function] to throw an error
FODC0001_2,AssertionError: expected [Function] to throw an error
FODC0002_1,AssertionError: expected [Function] to throw error including 'FODC0002' but got 'XPST0017: Function doc with arity of 1 not registered. No similar functions found.'
FODC0002_2,AssertionError: expected [Function] to throw error including 'FODC0002' but got 'XPST0017: Function doc with arity of 1 not registered. No similar functions found.'
FODC0002_3,AssertionError: expected [Function] to throw error including 'FODC0002' but got 'XPST0017: Function doc with arity of 1 not registered. No similar functions found.'
FODC0002_4,AssertionError: expected [Function] to throw error including 'FODC0002' but got 'XPST0017: Function collection with arity of 0 not registered. No similar functions found.'
FODC0004,AssertionError: Expected executing the XPath "collection('%gg')" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FODC0004' but got 'XPST0017: Function collection with arity of 1 not registered. No similar functions found.', AssertionError: expected [Function] to throw error including 'FODC0002' but got 'XPST0017: Function collection with arity of 1 not registered. No similar functions found.'.
FODC0005-1,AssertionError: Expected executing the XPath "doc('%gg')" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FODC0005' but got 'XPST0017: Function doc with arity of 1 not registered. No similar functions found.', AssertionError: expected [Function] to throw error including 'FODC0002' but got 'XPST0017: Function doc with arity of 1 not registered. No similar functions found.'.
FODC0005-2,AssertionError: Expected executing the XPath "doc-available('%gg')" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'FODC0005' but got 'XPST0017: Function doc-available with arity of 1 not registered. No similar functions found.', Error: XPST0017: Function doc-available with arity of 1 not registered. No similar functions found..
FODT0001-1,AssertionError: expected [Function] to throw error including 'FODT0001' but got 'XPST0017: Function adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.'
FODT0001-2,AssertionError: expected [Function] to throw error including 'FODT0001' but got 'XPST0017: Function adjust-date-to-timezone with arity of 2 not registered. No similar functions found.'
FODT0002-1,AssertionError: expected [Function] to throw error including 'FODT0002' but got 'XPTY0004: the operands of the "+" operator should be of type xs:numeric?.'
FODT0002-2,AssertionError: expected [Function] to throw error including 'FODT0002' but got 'XPTY0004: the operands of the "*" operator should be of type xs:numeric?.'
FODT0002-3,AssertionError: expected [Function] to throw error including 'FODT0002' but got 'XPTY0004: the operands of the "div" operator should be of type xs:numeric?.'
FODT0002-4,AssertionError: expected [Function] to throw error including 'FODT0002' but got 'XPTY0004: the operands of the "-" operator should be of type xs:numeric?.'
FODT0002-6,AssertionError: expected [Function] to throw error including 'FODT0002' but got 'XPTY0004: the operands of the "+" operator should be of type xs:numeric?.'
FODT0002-7,AssertionError: expected [Function] to throw error including 'FODT0002' but got 'XPTY0004: the operands of the "*" operator should be of type xs:numeric?.'
FODT0002-8,AssertionError: expected [Function] to throw error including 'FODT0002' but got 'XPTY0004: the operands of the "div" operator should be of type xs:numeric?.'
FODT0002-9,AssertionError: expected [Function] to throw error including 'FODT0002' but got 'XPTY0004: the operands of the "-" operator should be of type xs:numeric?.'
FODT0003-1,AssertionError: expected [Function] to throw error including 'FODT0003' but got 'XPST0017: Function adjust-date-to-timezone with arity of 2 not registered. No similar functions found.'
FODT0003-2,AssertionError: expected [Function] to throw error including 'FODT0003' but got 'XPST0017: Function adjust-date-to-timezone with arity of 2 not registered. No similar functions found.'
FOER0000,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function error with arity of 0 not registered. No similar functions found.'
FONS0004-1,AssertionError: expected [Function] to throw error including 'FONS0004' but got 'XPST0017: Function resolve-QName with arity of 2 not registered. No similar functions found.'
FORG0002,AssertionError: expected [Function] to throw error including 'FORG0002' but got 'XPST0003: Unable to parse XPath: declare base-uri "http://www.w3.org/"; resolve-uri("%gg"). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.'
FORG0008,AssertionError: expected [Function] to throw error including 'FORG0008' but got 'XPST0017: Function dateTime with arity of 2 not registered. Did you mean "xs:dateTime (xs:anyAtomicType?)"?'
FORG0009,AssertionError: expected [Function] to throw error including 'FORG0002' but got 'XPST0017: Function resolve-uri with arity of 2 not registered. No similar functions found.'
XPDY0002_02,AssertionError: expected [Function] to throw error including 'XPDY0002' but got 'XPST0003: Unable to parse XPath: declare variable $variable external; $variable. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
XPDY0050,AssertionError: expected [Function] to throw error including 'XPDY0050' but got 'XPST0003: Unable to parse XPath: 1 treat as node(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "t" found.'
XPTY0004_01,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: attribute { 1 } { 1 }. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
XPTY0019_2,AssertionError: expected [Function] to throw error including 'XPTY0019' but got 'XPST0003: Unable to parse XPath: declare namespace foo = "http://www.example.org"; declare function foo:something() { (<a />, 1, <b/>, 2) }; foo:something()/a. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
XPTY0019_3,AssertionError: expected [Function] to throw error including 'XPTY0019' but got 'XPST0003: Unable to parse XPath: declare namespace foo = "http://www.example.org"; declare function foo:something($pos as xs:integer) { if ($pos eq 1) then 1 else <a /> }; let $x := <a><b><c/></b><b><c/></b></a> return $x/b/(foo:something(position()))/a. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
XPTY0004_02,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: element { 1 } { }. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
XPTY0004_05,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: let $x as node() := 1 return $x. SyntaxError: Expected " ", "(:", ":=", "\\n", "\\r", or "\\t" but "a" found.'
XPTY0004_06,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: for $x as node() in (1, 2, 3) return $x. SyntaxError: Expected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.'
XPTY0004_07,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: document { attribute {\'foo\'} {} }. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "{" found.'
XPTY0004_08,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare namespace foo = "http://www.example.org"; declare function foo:content($type as xs:integer) { if ($type eq 1) then attribute {\'foo\'} {} else <foo /> }; document { foo:content(1) }. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
XPTY0004_09,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: for $x in (1, \'hello\', xs:date(\'2007-11-28\')) order by $x return $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.'
XPTY0004_12,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function fn:error with arity of 1 not registered. Did you mean "xs:error (xs:anyAtomicType?)"?'
XPTY0004_12a,AssertionError: expected [Function] to throw error including 'FOER0000' but got 'XPST0017: Function fn:error with arity of 1 not registered. Did you mean "xs:error (xs:anyAtomicType?)"?'
XPTY0004_19,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "string" << 1. SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.'
XPTY0004_20,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: "string" >> 1. SyntaxError: Expected " ", "$", "\'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\\"", "\\n", "\\r", "\\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "following", "following-sibling", "function", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "text()", [0-9], [A-Z_a-z----------], or [-] but ">" found.'
XPTY0004_28,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare namespace foo = "http://www.example.org"; declare function foo:something($type as xs:integer) { if ($type eq 1) then xs:date(\'2007-11-28\') else 1.0 }; abs(foo:something(1)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
XPTY0004_29,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare namespace foo = "http://www.example.org"; declare function foo:something($type as xs:integer) { if ($type eq 1) then xs:date(\'2007-11-28\') else \'foo\' }; element { foo:something(1) } { }. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
XPTY0004_30,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare namespace foo = "http://www.example.org"; declare function foo:something($type as xs:integer) { if ($type eq 1) then xs:date(\'2007-11-28\') else \'foo\' }; processing-instruction { foo:something(1) } { }. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
XPTY0004_31,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare namespace foo = "http://www.example.org"; declare function foo:something($type as xs:integer) { if ($type eq 1) then xs:date(\'2007-11-28\') else \'foo\' }; <e> { attribute { foo:something(1) } { } } </e>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
XPTY0004_32,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare namespace foo = "http://www.example.org"; declare function foo:something($type as xs:integer) { if ($type eq 1) then (\'foo\', xs:date(\'2007-11-28\'), \'foo\') else \'foo\' }; let $x as xs:string* := foo:something(1) return $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
XPTY0004_33,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare namespace foo = "http://www.example.org"; declare function foo:something($type as xs:integer) { if ($type eq 1) then xs:date(\'2007-11-28\') else \'foo\' }; for $x as xs:string in foo:something(1) return $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
XPTY0004_34,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare namespace foo = "http://www.example.org"; declare function foo:something($type) as xs:integer { $type }; foo:something(\'foo\'). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
XPTY0004_35,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare namespace foo = "http://www.example.org"; declare function foo:something($type as xs:integer) as xs:integer { if ($type eq 1) then xs:date(\'2007-11-28\') else $type }; foo:something(1). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
XPTY0004_37,AssertionError: expected [Function] to throw an error
XPTY0004_38,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare namespace foo = "http://www.example.org"; declare function foo:something($pos as xs:integer) { if ($pos eq 1) then 1 else xs:date(\'2007-11-29\') }; -foo:something(2). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
XPTY0004_39,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare namespace foo = "http://www.example.org"; declare function foo:something($pos as xs:integer) { if ($pos eq 1) then 1 else xs:date(\'2007-11-29\') }; +foo:something(2). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
XPTY0004_40,AssertionError: expected [Function] to throw an error
XPTY0004_45,AssertionError: Expected executing the XPath "concat('prefix:', 'localname') cast as xs:QName" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'Casting to xs:QName is not implemented.', AssertionError: expected [Function] to throw error including 'FONS0004' but got 'Casting to xs:QName is not implemented.'.
XPTY0004_47,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare variable $a := <e><a/><b/><a/></e>; <a>{$a/a eq 1}</a>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
XPTY0004_48,AssertionError: Expected executing the XPath "let $i := (1, 3, 2) order by $i return $i" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (let $i := (1, 3, 2) order by $i return $i)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: let $i := (1, 3, 2) order by $i return $i. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.'.
XPTY0020,AssertionError: expected [Function] to throw an error
XQDY0025_1,AssertionError: expected [Function] to throw error including 'XQDY0025' but got 'XPST0003: Unable to parse XPath: let $attr1 := attribute attr { \'foo\' } return let $attr2 := attribute attr { \'bar\' } return <a>{$attr1, $attr2 }</a>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "a" found.'
XQDY0025_2,AssertionError: expected [Function] to throw error including 'XQDY0025' but got 'XPST0003: Unable to parse XPath: declare namespace prefix = "http://www/w3.org/"; let $attr1 := attribute prefix:attr { \'foo\' } return let $attr2 := attribute prefix:attr { \'bar\' } return <a>{$attr1, $attr2 }</a>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
XQDY0025_3,AssertionError: expected [Function] to throw error including 'XQDY0025' but got 'XPST0003: Unable to parse XPath: declare namespace prefix = "http://www/w3.org/"; let $attr1 := attribute attr { \'foo\' } return let $attr2 := attribute attr { \'bar\' } return <prefix:a>{$attr1, $attr2 }</prefix:a>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
XQDY0025_4,AssertionError: expected [Function] to throw error including 'XQDY0025' but got 'XPST0003: Unable to parse XPath: declare namespace prefix = "http://www/w3.org/"; let $attr1 := attribute prefix:attr { \'foo\' } return let $attr2 := attribute prefix:attr { \'bar\' } return <prefix:a>{$attr1, $attr2 }</prefix:a>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
XQDY0026,AssertionError: expected [Function] to throw error including 'XQDY0026' but got 'XPST0003: Unable to parse XPath: processing-instruction target { \'?>\' }. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "t" found.'
XQDY0041,AssertionError: expected [Function] to throw error including 'XQDY0041' but got 'XPST0003: Unable to parse XPath: <a> { processing-instruction { \'1BadName\' } { \'content\' } } </a>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.'
XQDY0044_1,AssertionError: expected [Function] to throw error including 'XQDY0044' but got 'XPST0003: Unable to parse XPath: <a> { attribute { \'xmlns\' } { \'http://www.w3.org/\' } } </a>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.'
XQDY0061,AssertionError: expected [Function] to throw error including 'XQDY0061' but got 'XPST0003: Unable to parse XPath: validate lax { document {\'hello\'} }. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "l" found.'
XQDY0064,AssertionError: expected [Function] to throw error including 'XQDY0064' but got 'XPST0003: Unable to parse XPath: <a> { processing-instruction { \'xml\' } { \'content\' } } </a>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.'
XQDY0072,AssertionError: expected [Function] to throw error including 'XQDY0072' but got 'XPST0003: Unable to parse XPath: <a> { comment { \' -- \' } } </a>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.'
XQDY0074_1,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: <a> { element { \'prefix:localName\' } { } } </a>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.'
XQDY0074_2,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: <a> { attribute { \'prefix:localName\' } { } } </a>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.'
XQDY0074_3,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: <a> { element { \'1localName\' } { } } </a>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.'
XQDY0074_4,AssertionError: expected [Function] to throw error including 'XQDY0074' but got 'XPST0003: Unable to parse XPath: <a> { attribute { \'1localName\' } { } } </a>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "{" found.'
XQDY0091,AssertionError: Expected executing the XPath "<e xml:id=" ab c d "/>" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw an error, AssertionError: Expected XPath <e xml:id=" ab c d "/> to resolve to the given XML. Expected <e xml:id=" ab c d "/> to equal <e xml:id="ab c d"/>.
XQST0031,AssertionError: expected [Function] to throw error including 'XQST0031' but got 'XPST0003: Unable to parse XPath: xquery version \'2.0\'; 1+2. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
XQST0032,AssertionError: expected [Function] to throw error including 'XQST0032' but got 'XPST0003: Unable to parse XPath: declare base-uri "http://www.example.org/A"; declare base-uri "http://www.example.org/B"; 1 + 2. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.'
XQST0033,AssertionError: expected [Function] to throw error including 'XQST0033' but got 'XPST0003: Unable to parse XPath: declare namespace cheddar = \'http://www.example.org/cheddar\'; declare namespace cheddar = \'http://www.example.org/cheddar\'; 1 + 2. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
XQST0034,AssertionError: expected [Function] to throw error including 'XQST0034' but got 'XPST0003: Unable to parse XPath: declare namespace prefix = "http://www.example.org/"; declare function prefix:foo() { 1 }; declare function prefix:foo() { 1 }; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
XQST0038_1,AssertionError: expected [Function] to throw error including 'XQST0038' but got 'XPST0003: Unable to parse XPath: declare default collation "http://www.w3.org/2005/xpath-functions/collation/codepoint"; declare default collation "http://www.w3.org/2005/xpath-functions/collation/codepoint"; 1 + 2. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'
XQST0038_3,AssertionError: expected [Function] to throw error including 'XQST0038' but got 'XPST0003: Unable to parse XPath: declare default collation "http://www.example.org/"; 1 + 2. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'
XQST0039,AssertionError: expected [Function] to throw error including 'XQST0039' but got 'XPST0003: Unable to parse XPath: declare namespace prefix = "http://www.w3.org/"; declare function prefix:foo($arg, $arg) { 1 }; 1 + 2. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
XQST0045-1,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: declare function foo() { 1 }; foo(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
XQST0045-2,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: declare function xml:foo() { 1 }; xml:foo(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
XQST0045-3,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: declare function xs:foo() { 1 }; xs:foo(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
XQST0045-4,AssertionError: expected [Function] to throw error including 'XQST0045' but got 'XPST0003: Unable to parse XPath: declare function xsi:foo() { 1 }; xsi:foo(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
XQST0046_01,AssertionError: Expected executing the XPath "base-uri(<a xml:base="%gg" />)" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0046' but got 'XPST0017: Function base-uri with arity of 1 not registered. No similar functions found.', AssertionError: expected [Function] to throw error including 'FORG0001' but got 'XPST0017: Function base-uri with arity of 1 not registered. No similar functions found.', Error: XPST0017: Function base-uri with arity of 1 not registered. No similar functions found..
XQST0046_03,AssertionError: Expected executing the XPath "declare namespace foo = "%gg"; true()" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0046' but got 'XPST0003: Unable to parse XPath: declare namespace foo = "%gg"; true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.', Error: XPST0003: Unable to parse XPath: declare namespace foo = "%gg"; true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found..
XQST0046_04,AssertionError: Expected executing the XPath "declare default element namespace "%gg"; true()" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0046' but got 'XPST0003: Unable to parse XPath: declare default element namespace "%gg"; true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.', Error: XPST0003: Unable to parse XPath: declare default element namespace "%gg"; true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found..
XQST0046_05,AssertionError: Expected executing the XPath "declare default function namespace "%gg"; fn:true()" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0046' but got 'XPST0003: Unable to parse XPath: declare default function namespace "%gg"; fn:true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.', Error: XPST0003: Unable to parse XPath: declare default function namespace "%gg"; fn:true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found..
XQST0046_06,AssertionError: Expected executing the XPath "declare default collation "%gg"; fn:true()" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0046' but got 'XPST0003: Unable to parse XPath: declare default collation "%gg"; fn:true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.', AssertionError: expected [Function] to throw error including 'XQST0038' but got 'XPST0003: Unable to parse XPath: declare default collation "%gg"; fn:true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.', Error: XPST0003: Unable to parse XPath: declare default collation "%gg"; fn:true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found..
XQST0046_07,AssertionError: Expected executing the XPath "declare base-uri "%gg"; true()" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0046' but got 'XPST0003: Unable to parse XPath: declare base-uri "%gg"; true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.', Error: XPST0003: Unable to parse XPath: declare base-uri "%gg"; true(). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found..
XQST0046_09,AssertionError: Expected executing the XPath "import schema "http://www.w3.org/" at "%gg"; 1" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0046' but got 'XPST0003: Unable to parse XPath: import schema "http://www.w3.org/" at "%gg"; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "s" found.', AssertionError: expected [Function] to throw error including 'XQST0059' but got 'XPST0003: Unable to parse XPath: import schema "http://www.w3.org/" at "%gg"; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "s" found.'.
XQST0046_12,AssertionError: Expected executing the XPath "for $x in ("a", "a", "a") order by $x collation "%gg" return $x" to resolve to one of the expected results, but got AssertionError: expected [Function] to throw error including 'XQST0046' but got 'XPST0003: Unable to parse XPath: for $x in ("a", "a", "a") order by $x collation "%gg" return $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.', AssertionError: expected [Function] to throw error including 'XQST0076' but got 'XPST0003: Unable to parse XPath: for $x in ("a", "a", "a") order by $x collation "%gg" return $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.', Error: XPST0003: Unable to parse XPath: (for $x in ("a", "a", "a") order by $x collation "%gg" return $x)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found..
XQST0049,AssertionError: expected [Function] to throw error including 'XQST0049' but got 'XPST0003: Unable to parse XPath: declare variable $foo external; declare variable $foo external; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
XQST0054,AssertionError: expected [Function] to throw error including 'XQST0054' but got 'XPST0003: Unable to parse XPath: declare namespace foo = "http://www.example.org/"; declare variable $a := foo:bar(); declare function foo:bar() { $a + 1 }; $a. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
XQST0055,AssertionError: expected [Function] to throw error including 'XQST0055' but got 'XPST0003: Unable to parse XPath: declare copy-namespaces preserve,inherit; declare copy-namespaces preserve,no-inherit; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.'
XQST0057,AssertionError: expected [Function] to throw error including 'XQST0057' but got 'XPST0003: Unable to parse XPath: import schema namespace foo = "" at "http://www.w3.org/"; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "s" found.'
XQST0060,AssertionError: expected [Function] to throw error including 'XQST0060' but got 'XPST0003: Unable to parse XPath: declare default function namespace ""; declare function foo() { 1 }; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'
XQST0065,AssertionError: expected [Function] to throw error including 'XQST0065' but got 'XPST0003: Unable to parse XPath: declare ordering unordered; declare ordering ordered; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "to", "union", "|", "||", or end of input but "o" found.'
XQST0066_1,AssertionError: expected [Function] to throw error including 'XQST0066' but got 'XPST0003: Unable to parse XPath: declare default element namespace "http://www.w3.org/a"; declare default element namespace "http://www.w3.org/b"; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'
XQST0066_3,AssertionError: expected [Function] to throw error including 'XQST0066' but got 'XPST0003: Unable to parse XPath: declare default function namespace "http://www.example.org/"; declare default function namespace "http://www.w3.org/2005/xpath-functions/collation/codepoint"; 1 + 2. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'
XQST0067,AssertionError: expected [Function] to throw error including 'XQST0067' but got 'XPST0003: Unable to parse XPath: declare construction strip; declare construction preserve; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.'
XQST0068,AssertionError: expected [Function] to throw error including 'XQST0068' but got 'XPST0003: Unable to parse XPath: declare boundary-space strip; declare boundary-space preserve; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "b" found.'
XQST0069,AssertionError: expected [Function] to throw error including 'XQST0069' but got 'XPST0003: Unable to parse XPath: declare default order empty least; declare default order empty greatest; 1. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.'
XQST0070_1,AssertionError: expected [Function] to throw error including 'XQST0070' but got 'XPST0003: Unable to parse XPath: import schema namespace xml = "http://www.example.org/"; 1 + 2. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "s" found.'
XQST0070_4,AssertionError: expected [Function] to throw error including 'XQST0070' but got 'XPST0003: Unable to parse XPath: declare namespace xml = "http://www.example.org/"; 1 + 2. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
XQST0076,AssertionError: expected [Function] to throw error including 'XQST0076' but got 'XPST0003: Unable to parse XPath: for $x in (\'a\', \'b\', \'c\') order by $x collation \'http://www.w3.org/\' return $x. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.'
XQST0079,AssertionError: expected [Function] to throw error including 'XQST0079' but got 'XPST0003: Unable to parse XPath: declare namespace prefix = "http://www.w3.org/"; (# prefix:pragma #) { }. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
XQST0085,AssertionError: expected [Function] to throw an error
XQST0085b,Error: XPST0017: Function in-scope-prefixes with arity of 1 not registered. No similar functions found.
XQST0085c,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'An attempt was made to create or change an object in a way which is incorrect with regard to namespaces'
XQST0087,AssertionError: expected [Function] to throw error including 'XQST0087' but got 'XPST0003: Unable to parse XPath: xquery version \'1.0\' encoding \'_utf\'; 1+2. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'
XQST0089,AssertionError: expected [Function] to throw error including 'XQST0089' but got 'XPST0003: Unable to parse XPath: for $x at $x in (1, 2, 3) return $x. SyntaxError: Expected " ", "(:", "\\n", "\\r", "\\t", or "in" but "a" found.'
XQTY0024_1,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: declare namespace prefix = "http://www.w3.org/"; <prefix:a> { <b />, attribute prefix:foo { \'bar\' } } </prefix:a>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
XQTY0024_2,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: declare namespace prefix = "http://www.w3.org/"; <prefix:a> { <b />, attribute foo { \'bar\' } } </prefix:a>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
XQTY0024_3,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: declare namespace prefix = "http://www.w3.org/"; <a> { <b />, attribute prefix:foo { \'bar\' } } </a>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
XQTY0024_4,AssertionError: expected [Function] to throw error including 'XQTY0024' but got 'XPST0003: Unable to parse XPath: <a> { <b />, attribute foo { \'bar\' } } </a>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or "}" but "f" found.'
XQTY0030,AssertionError: expected [Function] to throw error including 'XQTY0030' but got 'XPST0003: Unable to parse XPath: validate strict { () }. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "s" found.'
XQTY0086_1,AssertionError: expected [Function] to throw error including 'XQTY0086' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare construction preserve; \n      \tdeclare copy-namespaces no-preserve,inherit; \n      \tdeclare namespace ns="http://www.xqsharp.com/test/namespace-sensitive"; \n      \t<e>{.//ns:sensitive}</e>\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.'
XQTY0086_2,AssertionError: expected [Function] to throw error including 'XQTY0086' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare construction preserve; \n      \tdeclare namespace ns="http://www.xqsharp.com/test/namespace-sensitive"; \n      \t<e>{.//ns:sensitive-attribute/@sensitive}</e>\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.'
XQTY0086_3,AssertionError: expected [Function] to throw error including 'XQTY0086' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare construction preserve; \n      \tdeclare copy-namespaces no-preserve,inherit; \n      \tdeclare namespace ns="http://www.xqsharp.com/test/namespace-sensitive"; \n      \t<e>{.//ns:sensitive-attribute}</e>\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "c" found.'
XQST0125_1,AssertionError: expected [Function] to throw error including 'XQST0125' but got 'XPST0003: Unable to parse XPath: \n        let $f := %public function($arg as xs:integer) as xs:integer \n                          { $arg + 1 }\n        return $f(1)\n      . SyntaxError: Expected " ", "$", "\'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\\"", "\\n", "\\r", "\\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-z----------], or [-] but "%" found.'
XQST0125_2,AssertionError: expected [Function] to throw error including 'XQST0125' but got 'XPST0003: Unable to parse XPath: \n        let $f := %private function($arg as xs:integer) as xs:integer \n                           { $arg + 1 }\n        return $f(1)\n      . SyntaxError: Expected " ", "$", "\'", "(", "(:", "*", "*:", "+", "-", ".", "..", "/", "//", "<!--", "<", "<?", "@", "Q", "[", "\\"", "\\n", "\\r", "\\t", "ancestor", "ancestor-or-self", "array", "attribute", "attribute(", "attribute()", "child", "comment()", "decendant", "descendant", "descendant-or-self", "document-node(", "document-node()", "element", "every", "following", "following-sibling", "for", "function", "if", "let", "map", "namespace-node()", "node()", "parent", "preceding-sibling", "processing-instruction(", "processing-instruction()", "schema-attribute(", "schema-element(", "self", "some", "text()", [0-9], [A-Z_a-z----------], or [-] but "%" found.'
annex-1,Error: XPST0003: Unable to parse XPath: (declare namespace eg = "http://example.org"; declare function eg:if-empty ( $node as node()?, $value as xs:anyAtomicType) as xs:anyAtomicType* { if ($node and $node/child::node()) then fn:data($node) else $value }; let $arg1 := <element1>some data</element1> let $arg2 as xs:anyAtomicType := 1 return eg:if-empty($arg1,$arg2))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
annex-2,Error: XPST0003: Unable to parse XPath: (declare namespace eg = "http://example.org"; declare function eg:if-absent ( $node as node()?, $value as xs:anyAtomicType) as xs:anyAtomicType* { if ($node) then fn:data($node) else $value }; let $arg1 := <element1>some data</element1> let $arg2 as xs:anyAtomicType := 1 return eg:if-absent($arg1,$arg2))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
annex-3,Error: XPST0003: Unable to parse XPath: (declare namespace eg = "http://example.org"; declare function eg:value-union ( $arg1 as xs:anyAtomicType*, $arg2 as xs:anyAtomicType*) as xs:anyAtomicType* { fn:distinct-values(($arg1, $arg2)) }; let $arg1 as xs:anyAtomicType := 1 let $arg2 as xs:anyAtomicType := 2 return eg:value-union($arg1,$arg2))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
annex-4,AssertionError: Expected executing the XPath "declare namespace eg = "http://example.org"; declare function eg:value-intersect ( $arg1 as xs:anyAtomicType*, $arg2 as xs:anyAtomicType* ) as xs:anyAtomicType* { fn:distinct-values($arg1[.=$arg2]) }; let $arg1 as xs:anyAtomicType := 1 let $arg2 as xs:anyAtomicType := 1 return eg:value-intersect($arg1,$arg2)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare namespace eg = "http://example.org"; declare function eg:value-intersect ( $arg1 as xs:anyAtomicType*, $arg2 as xs:anyAtomicType* ) as xs:anyAtomicType* { fn:distinct-values($arg1[.=$arg2]) }; let $arg1 as xs:anyAtomicType := 1 let $arg2 as xs:anyAtomicType := 1 return eg:value-intersect($arg1,$arg2)) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare namespace eg = "http://example.org"; declare function eg:value-intersect ( $arg1 as xs:anyAtomicType*, $arg2 as xs:anyAtomicType* ) as xs:anyAtomicType* { fn:distinct-values($arg1[.=$arg2]) }; let $arg1 as xs:anyAtomicType := 1 let $arg2 as xs:anyAtomicType := 1 return eg:value-intersect($arg1,$arg2). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'.
annex-5,AssertionError: Expected executing the XPath "declare namespace eg = "http://example.org"; declare function eg:value-except ( $arg1 as xs:anyAtomicType*, $arg2 as xs:anyAtomicType*) as xs:anyAtomicType* { fn:distinct-values($arg1[not(.=$arg2)]) }; let $arg1 as xs:anyAtomicType := 1 let $arg2 as xs:anyAtomicType := 2 return eg:value-except($arg1,$arg2)" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: (declare namespace eg = "http://example.org"; declare function eg:value-except ( $arg1 as xs:anyAtomicType*, $arg2 as xs:anyAtomicType*) as xs:anyAtomicType* { fn:distinct-values($arg1[not(.=$arg2)]) }; let $arg1 as xs:anyAtomicType := 1 let $arg2 as xs:anyAtomicType := 2 return eg:value-except($arg1,$arg2)) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: declare namespace eg = "http://example.org"; declare function eg:value-except ( $arg1 as xs:anyAtomicType*, $arg2 as xs:anyAtomicType*) as xs:anyAtomicType* { fn:distinct-values($arg1[not(.=$arg2)]) }; let $arg1 as xs:anyAtomicType := 1 let $arg2 as xs:anyAtomicType := 2 return eg:value-except($arg1,$arg2). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'.
annex-6,Error: XPST0003: Unable to parse XPath: (declare namespace eg = "http://example.org"; declare function eg:index-of-node($sequence as node()*, $srch as node()) as xs:integer* { for $n at $i in $sequence where ($n is $srch) return $i }; let $arg1 := (<element1>some data 1</element1>,<element2>some data 2</element2>) let $arg2 := $arg1[2] return eg:index-of-node($arg1, exactly-one($arg2))) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
annex-7,Error: XPST0003: Unable to parse XPath: (declare namespace eg = "http://example.org"; declare function eg:string-pad ( $padString as xs:string?, $padCount as xs:integer) as xs:string { fn:string-join((for $i in 1 to $padCount return $padString), "") }; let $arg1 as xs:string := "A String" let $arg2 as xs:integer := 3 return eg:string-pad($arg1,$arg2))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
annex-8,Error: XPST0003: Unable to parse XPath: declare namespace eg = "http://example.org"; declare function eg:distinct-nodes-stable ($arg as node()*) as node()* { for $a at $apos in $arg let $before_a := fn:subsequence($arg, 1, $apos - 1) where every $ba in $before_a satisfies not($ba is $a) return $a }; let $arg1 := (<element1>some data 1</element1>,<element2>some data 2</element2>) return eg:distinct-nodes-stable($arg1). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
errors-and-optimization-1,Error: XPST0017: Function error with arity of 2 not registered. No similar functions found.
errors-and-optimization-2,AssertionError: expected [Function] to throw an error
errors-and-optimization-7,AssertionError: expected [Function] to throw error including 'XPST0081' but got 'Not implemented: references to variables with a namespace URI or a prefix.'
hof-001,Error: XPST0003: Unable to parse XPath: (         declare function local:f($x as xs:integer) as xs:integer { $x + 1 };          let $f := local:f#1 return $f(2)) = (3). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
hof-002,Error: XPST0003: Unable to parse XPath: (       	declare function local:f() as xs:integer { 42 };        	declare function local:f($x as xs:integer) as xs:integer { $x + 1 };        	let $f := local:f#0 return $f()       ) = (42). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
hof-003,Error: XPST0003: Unable to parse XPath: (         import module namespace m="http://example.com/hof-003";          let $f := m:f#1 return $f(17)) = (18). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", or "||" but "m" found.
hof-006,Error: XPST0003: Unable to parse XPath: (       declare default function namespace "http://example.com/hof-006";        declare function g($x as xs:integer) as xs:integer { $x + 1 };        let $f := g#1 return $f(21)       ) = (22). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found.
hof-007,Error: XPST0003: Unable to parse XPath: (       declare default function namespace "http://www.w3.org/2001/XMLSchema";        let $f := date#1 return $f('2008-01-31')       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "d" found.
hof-010,Error: XPST0003: Unable to parse XPath: (       declare function local:f($x as xs:integer) as xs:integer { $x + 1 };        let $f as function(*) := local:f#1 return $f(2)       ) = (3). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
hof-011,Error: XPST0003: Unable to parse XPath: (       declare function local:f($x as xs:integer) as xs:integer { $x + 3 };        let $f as function(xs:integer) as xs:integer := local:f#1        return $f(2)       ) = (5). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
hof-012,Error: XPST0003: Unable to parse XPath: (       declare function local:f($x as xs:integer, $y as xs:long) as xs:integer { $x + $y };        let $f as function(xs:integer, xs:long) as xs:integer := local:f#2        return $f(2, xs:long(5))       ) = (7). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
hof-013,Error: XPST0003: Unable to parse XPath: (       declare function local:f($x as xs:integer) as xs:integer { $x + 3 };        declare function local:g($x as xs:integer) as xs:integer { $x + 4 };        declare function local:h($x as xs:integer) as xs:integer { $x + 5 };        let $f as (function(xs:integer) as xs:integer)* := (local:f#1, local:g#1, local:h#1) return $f[3](2)[1]       ) = (7). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
hof-014,Error: XPST0003: Unable to parse XPath: (       declare function local:case($x as xs:boolean) as function(*)        	{ if ($x) then fn:upper-case#1 else fn:lower-case#1 };        local:case(true())("Mike"), local:case(false())("Mike")       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
hof-015,Error: XPST0003: Unable to parse XPath: (       declare function local:case($x as xs:boolean) as function(xs:string?) as xs:string        	{ if ($x) then fn:upper-case#1 else fn:lower-case#1 };        local:case(true())("Mike"), local:case(false())("Mike"))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
hof-016,Error: XPST0003: Unable to parse XPath: (       declare function local:case($x as function(*), $y as xs:string) as xs:string { $x($y) };        local:case(upper-case#1, "Mike"), local:case(lower-case#1, "Mike")       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
hof-017,Error: XPST0003: Unable to parse XPath: (       declare function local:case($x as function(xs:string?) as xs:string, $y as xs:string) as xs:string { $x($y) };        local:case(upper-case#1, "Mike"), local:case(lower-case#1, "Mike")       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
hof-018,Error: XPST0003: Unable to parse XPath: (       declare function local:scramble($x as function(xs:string) as xs:string, $y as xs:string) as xs:string        	{ $x($y) };        declare function local:rot13($x as xs:string) as xs:string        	{ translate($x, "abcdefghijklmnopqrstuvwxyz", "nopqrstuvwxyzabcdefghijklm") };        local:scramble(local:rot13#1, "mike")       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
hof-019,Error: XPST0003: Unable to parse XPath: (       declare function local:scramble($x as function(*), $y as xs:string) as xs:string { $x($y) };        declare function local:rot13($x as xs:string) as xs:string { translate($x, "abcdefghijklmnopqrstuvwxyz", "nopqrstuvwxyzabcdefghijklm") };        local:scramble(local:rot13#1, "mike")       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
hof-020,Error: XPST0003: Unable to parse XPath: (       declare function local:scramble($x as function(*), $y as xs:string) as xs:string { $x($y) };        local:scramble(function($x){translate($x, "abcdefghijklmnopqrstuvwxyz", "nopqrstuvwxyzabcdefghijklm")}, "john")       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
hof-021,Error: XPST0003: Unable to parse XPath: (       declare function local:scramble($x as function(xs:string) as xs:string, $y as xs:string) as xs:string { $x($y) };        local:scramble(function($x){translate($x, "abcdefghijklmnopqrstuvwxyz", "nopqrstuvwxyzabcdefghijklm")}, "john")       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
hof-022,Error: XPST0003: Unable to parse XPath: (       declare function local:scramble($x as function(xs:string) as xs:string, $y as xs:string) as xs:string { $x($y) };        let $n := function-name(local:scramble#2)        return (local-name-from-QName($n), namespace-uri-from-QName($n), function-arity(local:scramble#2))       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
hof-023,Error: XPST0017: Function fn:function-name with arity of 1 not registered. No similar functions found.
hof-024,Error: XPST0017: Function function-name with arity of 1 not registered. No similar functions found.
hof-025,Error: XPST0017: Function function-name with arity of 1 not registered. No similar functions found.
hof-026,Error: XPST0003: Unable to parse XPath:          let $f := function($x as xs:string) as xs:string { upper-case($x) }          let $n := function-name($f)          return <a loc="{local-name-from-QName($n)}" uri="{namespace-uri-from-QName($n)}"         			arity="{function-arity($f)}" eloc="{empty(local-name-from-QName($n))}" euri="{empty(namespace-uri-from-QName($n))}"/>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
hof-028,Error: XPST0003: Unable to parse XPath: (       declare function local:splitter() as (function(xs:string) as xs:string*) { function($x as xs:string) { tokenize($x, '\s') } };        string-join(local:splitter()("A nice cup of tea"), '|')       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
hof-029,Error: XPST0003: Unable to parse XPath: (       declare function local:splitter() as (function(xs:string) as xs:string+)?        { function($x as xs:string) { for $i in tokenize($x, '\s') return upper-case($i)} };        string-join(local:splitter()("A nice cup of tea"), '|')       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
hof-030,Error: XPST0003: Unable to parse XPath: (       declare variable $sep as xs:string := "\s";        declare function local:splitter() as (function(xs:string) as xs:string*)?        	{ function($x as xs:string) { for $i in tokenize($x, $sep) return upper-case($i)} };        string-join(local:splitter()("A nice cup of tea"), '|')       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
hof-031,Error: XPST0003: Unable to parse XPath: (       declare function local:splitter($sep as xs:string) as (function(xs:string) as xs:string*)        	{ function($x as xs:string) { for $i in tokenize($x, $sep) return upper-case($i)} };        string-join(local:splitter("\s")("A nice cup of tea"), '|')       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
hof-032,Error: XPST0017: Function current-date with arity of 0 not registered. No similar functions found.
hof-033,Error: XPST0017: Function function-name with arity of 1 not registered. No similar functions found.
hof-034,Error: XPST0003: Unable to parse XPath: (local-name-from-QName(function-name((upper-case#1, lower-case#1)[ordered{.}("Mike") = "MIKE"])))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "]", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
hof-035,Error: XPST0003: Unable to parse XPath: (local-name-from-QName(function-name((upper-case#1, lower-case#1)[ordered{.}("Mike") = "MIKE"])))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "]", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
hof-037,Error: XPST0003: Unable to parse XPath: (         declare function local:f($x as xs:long, $y as xs:NCName) as element(e) {              <e x="{$x}" y="{$y}"/>          };          local:f#2 instance of function(*),          local:f#2 instance of function(xs:long, xs:NCName) as element(e),          local:f#2 instance of function(xs:anyAtomicType?, xs:anyAtomicType?) as element(e),          local:f#2 instance of function(item()*, item()*) as element(e)       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
hof-038,Error: XPST0003: Unable to parse XPath: (         declare function local:f($x as xs:long?, $y as xs:NCName?) as element(e) {              <e x="{$x}" y="{$y}"/>          };          local:f#2 instance of function(xs:int?, xs:NCName?) as element(e),          local:f#2 instance of function(xs:long?) as element(e),          local:f#2 instance of function(xs:long?, xs:NCName?, item()*) as element(e),          local:f#2 instance of function(xs:long, xs:anyAtomicType?) as element(e),          local:f#2 instance of function(item()+, item()+) as element(e)       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
hof-039,Error: XPST0003: Unable to parse XPath: (       	declare function local:f($x as xs:long, $y as xs:NCName) as element(e)? { <e x="{$x}" y="{$y}"/> };        	local:f#2 instance of function(xs:long, xs:NCName) as element()?,        	local:f#2 instance of function(xs:long, xs:NCName) as element()*,        	local:f#2 instance of function(xs:long, xs:NCName) as element(e)*,        	local:f#2 instance of function(xs:long, xs:NCName) as element(e, xs:anyType?)*,        	local:f#2 instance of function(xs:long, xs:NCName) as element(*, xs:anyType?)?,        	local:f#2 instance of function(xs:long, xs:NCName) as element(*, xs:untyped)?       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
hof-040,Error: XPST0003: Unable to parse XPath: (       declare function local:apply($fns as (function(xs:string) as xs:string)*, $s as xs:string) as xs:string* { for $f in $fns return $f($s) };        let $ops := (upper-case#1, lower-case#1, function($x){translate($x, 'e', 'i')}, substring-before(?, ' '))        return string-join(local:apply($ops, 'Michael Kay'), '~')       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
hof-041,Error: XPST0003: Unable to parse XPath: (       declare function local:ops() as (function(xs:string) as xs:string)*       	{ (upper-case#1, lower-case#1, function($x){translate($x, 'e', 'i')}, substring-before(?, ' ')) };        string-join(for $f in local:ops() return $f('Michael Kay'), '~')       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
hof-042,Error: XPST0003: Unable to parse XPath: (         declare function local:lower-case($x as xs:string) as xs:string { concat("'", fn:lower-case($x), "'") };          declare function local:ops() as (function(xs:string) as xs:string)*          	{ (upper-case#1, local:lower-case#1, function($x){translate($x, 'e', 'i')}, substring-before(?, ' ')) };          string-join(for $f in local:ops() return $f(<a name="Michael Kay"/>/@name), '~')       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
hof-043,Error: XPST0003: Unable to parse XPath: (       declare function local:round($x as xs:double) as xs:double        	{ fn:floor($x) };        declare function local:ops() as (function(xs:double) as xs:double)*        	{ (abs#1, local:round#1, function($x){$x+1}, round-half-to-even(?, 2)) };        string-join(for $f in local:ops() return string($f(xs:untypedAtomic('123.456'))), '~')       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
hof-044,Error: XPST0003: Unable to parse XPath: (       declare function local:round($x as xs:double) as xs:double { fn:floor($x) };        declare function local:ops() as (function(xs:double) as xs:double)*        	{ (abs#1, local:round#1, function($x as xs:double){$x+1}, round-half-to-even(?, 2)) };        string-join(for $f in local:ops() return string(round-half-to-even($f(xs:decimal('123.456')), 4)), '~')       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
hof-045,Error: XPST0003: Unable to parse XPath: (       declare function local:round($x as xs:double, $algorithm as (function(xs:double) as xs:double)) as xs:double { $algorithm($x) };        declare variable $roundToCeiling := local:round(?, ceiling#1); $roundToCeiling(12.4)) = (13). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
hof-046,Error: XPST0003: Unable to parse XPath:          declare function local:splitter($x as xs:string) as (function() as xs:string*)* {              for $sep in ('\s', ',', '!')              return function() { for $i in tokenize($x, $sep) return upper-case($i) }          };          <out>{              for $f as function(*) in local:splitter("How nice! Thank you, I enjoyed that.")              return <tokens>{ for $t in $f()                               return <t>{$t}</t>                     }</tokens>         }</out>     . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
hof-047,Error: XPST0003: Unable to parse XPath:          declare function local:splitter($x as xs:string) as (function() as xs:string*)* {              for $sep in ('\s', ',', '!') return function() {                  for $i in tokenize($x, $sep) return                      let $f := function(){ concat($sep, ':', upper-case($i)) }                      return $f() }          };          <out>{              for $f as function(*) in local:splitter("How nice! Thank you, I enjoyed that.")              return <tokens>{ for $t in $f()                               return <t>{$t}</t> }</tokens>          }</out>      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
hof-048,Error: XPST0003: Unable to parse XPath: (         declare function local:do() as xs:integer { (local:f#1)(5) };          declare function local:f($x as xs:integer) as xs:integer { $x + 1 };          local:do()) = (6). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
hof-049,Error: XPST0003: Unable to parse XPath:          declare function local:tf($i as xs:integer) as function () as xs:boolean {              if ($i) then true#0 else false#0          };          <out>{(local:tf(0)(), local:tf(1)())}</out>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
hof-052,Error: XPST0003: Unable to parse XPath: let $f := fn:concat#3(?, '*', ?) let $g := $f('[', ?) return <out>{$g(']')}</out>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
hof-053,Error: XPST0003: Unable to parse XPath: (       	declare function local:f($x as xs:long, $y as xs:NCName) as element(e, xs:anyAtomicType) { <e x="{$x}" y="{$y}"/> };        	local:f#2 instance of function(xs:long, xs:NCName) as element(),        	local:f#2 instance of function(xs:long, xs:NCName) as element()+,        	local:f#2 instance of function(xs:long, xs:NCName) as element()?,        	local:f#2 instance of function(xs:long, xs:NCName) as element()*,        	local:f#2 instance of function(xs:long, xs:NCName) as element(e)*,        	local:f#2 instance of function(xs:long, xs:NCName) as element(e, xs:anyType?)*,        	local:f#2 instance of function(xs:long, xs:NCName) as element(*, xs:anyType?)?,        	local:f#2 instance of function(xs:long, xs:NCName) as element(e, xs:anyType)*,        	local:f#2 instance of function(xs:long, xs:NCName) as element(*, xs:anyType)?,        	local:f#2 instance of function(xs:long, xs:NCName) as element(*, xs:untyped)?       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
hof-901,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:f($x as xs:integer) as xs:integer { $x + 1 }; \n      \tlet $f := local:g#1 return $f(2). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
hof-902,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:f($x as xs:integer) as xs:integer { $x + 1 }; \n      \tlet $f := local:f#3 return $f(2)\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
hof-903,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:f($x as xs:integer) as xs:integer { $x + 1 }; \n      \tlet $f := xs:date#2 return $f(\'2008-03-01\')\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
hof-904,AssertionError: expected [Function] to throw error including 'XPST0017' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:f($x as xs:integer) as xs:integer { $x + 1 }; \n      \tlet $f := concat#1 return $f(\'2008-03-01\')\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
hof-905,AssertionError: expected [Function] to throw error including 'FOTY0014' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:f($x as xs:integer) as xs:integer { $x + 1 }; \n      \tstring(local:f#1)\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
hof-906,AssertionError: expected [Function] to throw error including 'FOTY0013' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:f($x as xs:integer) as xs:integer { $x + 1 }; \n      \texists(data(local:f#1))\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
hof-907,AssertionError: expected [Function] to throw error including 'FOTY0015' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:f($x as xs:integer) as xs:integer { $x + 1 }; \n      \tdeep-equal((1,2,3,4,local:f#1), (1,2,3,4,local:f#1))\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
hof-908,AssertionError: expected [Function] to throw error including 'FOTY0013' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:f($x as xs:integer) as xs:integer { $x + 1 }; \n      \tlocal:f#1 eq 3\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
hof-909,AssertionError: expected [Function] to throw error including 'FOTY0013' but got 'XPST0003: Unable to parse XPath: \n      \tdeclare function local:f($x as xs:integer) as xs:integer { $x + 1 }; \n      \tnumber(local:f#1)\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
hof-912,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare function local:apply($fns as (function(xs:string) as xs:string)*, $s as xs:string) as xs:string* \n        { for $f in $fns return $f($s) };\n        let $ops := (upper-case#1, lower-case#1, function($x){translate($x, \'e\', \'i\')}, \n            substring-before(?, \' \', ?)) \n        return string-join(local:apply($ops, \'Michael Kay\'), \'~\'). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
hof-913,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare function local:apply($fns as (function(xs:string) as xs:string)*, $s as xs:string) as xs:string* \n        { for $f in $fns return $f($s) }; \n        let $ops := (upper-case#1, lower-case#1, function($x){translate($x, \'e\', \'i\')}, \n            string-length#1) \n        return string-join(local:apply($ops, \'Michael Kay\'), \'~\'). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
hof-914,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare function local:apply($fns as (function(xs:string) as xs:string)*, $s as xs:string) as xs:string* \n        { for $f in $fns return $f($s) }; \n        let $ops := (upper-case#1, lower-case#1, function($x as xs:double){string($x)}) \n        return string-join(local:apply($ops, \'Michael Kay\'), \'~\'). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
hof-918,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare function local:round($x as xs:double, $algorithm as (function(xs:double) as xs:double)) as xs:double \n        { $algorithm($x) }; \n        declare variable $roundToCeiling := local:round(?, upper-case#1); \n        $roundToCeiling(12.4)\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
hof-919,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n      declare function local:round($x as xs:double) as xs:double { fn:floor($x) }; \n      declare function local:ops() as (function(xs:double) as xs:double)* \n      \t{ (abs#1, local:round#1, function($x as xs:float){$x+1}, round-half-to-even(?, 2)) }; \n      string-join(for $f in local:ops() return string(round-half-to-even($f(xs:decimal(\'123.456\')), 4)), \'~\')\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.'
function-item-1,Error: No selector counterpart for: anyFunctionTest.
function-item-5,AssertionError: expected [Function] to throw error including 'XQTY0105' but got 'XPST0003: Unable to parse XPath: element a { avg#1 }. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "a" found.'
function-item-6,AssertionError: expected [Function] to throw error including 'FOTY0013' but got 'XPST0003: Unable to parse XPath: attribute a { avg#1 }. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "a" found.'
function-item-8,Error: XPST0017: Function function-name with arity of 1 not registered. No similar functions found.
function-item-9,Error: XPST0017: Function function-name with arity of 1 not registered. No similar functions found.
function-item-10,Error: No selector counterpart for: functionTest.
function-item-11,Error: XPTY0004: Multiplicity of function argument of type item() for [object Object] is incorrect. Expected exactly one
function-item-12,Error: No selector counterpart for: anyFunctionTest.
function-item-13,Error: No selector counterpart for: functionTest.
function-item-14,Error: No selector counterpart for: functionTest.
function-item-15,Error: No selector counterpart for: functionTest.
function-item-16,Error: No selector counterpart for: functionTest.
function-item-17,Error: No selector counterpart for: functionTest.
inline-function-1,Error: No selector counterpart for: anyFunctionTest.
inline-function-2,Error: XPST0017: Function function-name with arity of 1 not registered. No similar functions found.
inline-function-6,Error: No selector counterpart for: functionTest.
inline-function-7,Error: No selector counterpart for: functionTest.
inline-function-8,Error: No selector counterpart for: functionTest.
inline-function-9,Error: No selector counterpart for: functionTest.
inline-function-12a,AssertionError: expected [Function] to throw an error
inline-function-13,AssertionError: expected [Function] to throw error including 'XQST0039' but got 'Not implemented: references to variables with a namespace URI or a prefix.'
inline-function-14,Error: Not implemented: references to variables with a namespace URI or a prefix.
inline-function-15,AssertionError: expected [Function] to throw error including 'XQST0039' but got 'Not implemented: references to variables with a namespace URI or a prefix.'
inline-function-16,Error: Not implemented: references to variables with a namespace URI or a prefix.
xqhof1,Error: XPST0003: Unable to parse XPath: ( declare namespace map = "http://snelson.org.uk/functions/map";  declare function map:key($pair as function() as item()+) as item() {   $pair()[1] };  declare function map:value($pair as function() as item()+) as item()* {   subsequence($pair(), 2) };  declare function map:contains($map as (function() as item()+)*, $key as item())   as xs:boolean {   map:process($map, $key, function($a) { true() }, false(),     function($a) { () }) };  declare function map:get($map as (function() as item()+)*, $key as item())   as item()* {   map:process($map, $key, map:value#1, (), function($a) { () }) };  declare function map:process(   $map as (function() as item()+)*,   $key as item(),   $found as function(function() as item()+) as item()*,   $notfound as item()*,   $unused as function((function() as item()+)*) as item()* ) as item()* {   if(empty($map)) then $notfound   else    let $length := count($map)   let $middle := $length idiv 2 + 1   let $pair := $map[$middle]   let $pair_key := $pair()[1]   return     if($pair_key eq $key) then (       $unused(subsequence($map, 1, $middle - 1)),       $found($pair),       $unused(subsequence($map, $middle + 1))     )     else if($pair_key gt $key) then (       map:process(subsequence($map, 1, $middle - 1), $key,         $found, $notfound, $unused),       $unused(subsequence($map, $middle))     )     else (       $unused(subsequence($map, 1, $middle)),       map:process(subsequence($map, $middle + 1), $key,         $found, $notfound, $unused)     ) };  declare function map:pair($key as item(), $value as item()*)   as function() as item()+ {   function() { $key, $value } };  declare function map:put(   $map as (function() as item()+)*,   $key as item(),   $value as item()* ) as (function() as item()+)+ {   let $pair := map:pair($key, $value)   return     map:process($map, $key, function($a) { $pair }, $pair,       function($a) { $a }) };  string-join(let $map := map:put(map:put(map:put(map:put(map:put(map:put((),   "a", "aardvark"),   "z", "zebra"),   "e", ("elephant", "eagle")),   "o", "osterich"),   "t", "terrapin"),   "a", "antelope") return (   map:get($map, "o"),    for $m in $map   return concat("key: ", map:key($m), ", value: (",     string-join(map:value($m), ", "), ")")) , " ") ) = ("osterich key: a, value: (antelope) key: e, value: (elephant, eagle) key: o, value: (osterich) key: t, value: (terrapin) key: z, value: (zebra)"). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
xqhof2,Error: XPST0003: Unable to parse XPath: (          import module namespace func = "http://snelson.org.uk/functions/functional";                    let $f := func:curry(concat#5)          return $f("foo")(" bar")(" baz")(" what's")(" next?")       ) = ("foo bar baz what's next?"). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", or "||" but "m" found.
xqhof3,Error: XPST0003: Unable to parse XPath: ( import module namespace func = "http://snelson.org.uk/functions/functional";  declare function local:fib2_aux($result as xs:integer, $next as xs:integer, $n) as xs:integer* {   if($n eq 0) then () else (   $result, local:fib2_aux($next, $next + $result, $n - 1)) };  declare function local:fib2($n) as xs:integer* {   local:fib2_aux(0, 1, $n) };  declare function local:map-pairs($f,$a,$b) {   for-each-pair($a,$b,$f) };  string-join( for $a in subsequence(  let $interleave := func:curry(local:map-pairs#3)(function($a, $b) { $a, $b }) let $enumerate := $interleave(0 to 49) return $enumerate(local:fib2(50))  , 1, 100) return string($a) , " ")       ) = ("0 0 1 1 2 1 3 2 4 3 5 5 6 8 7 13 8 21 9 34 10 55 11 89 12 144 13 233 14 377 15 610 16 987 17 1597 18 2584 19 4181 20 6765 21 10946 22 17711 23 28657 24 46368 25 75025 26 121393 27 196418 28 317811 29 514229 30 832040 31 1346269 32 2178309 33 3524578 34 5702887 35 9227465 36 14930352 37 24157817 38 39088169 39 63245986 40 102334155 41 165580141 42 267914296 43 433494437 44 701408733 45 1134903170 46 1836311903 47 2971215073 48 4807526976 49 7778742049"). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", or "||" but "m" found.
xqhof4,Error: XPST0003: Unable to parse XPath: (          declare function local:hof($s, $f as function(*)) {            $f($s[1], $s[2])          };                    local:hof(('1', '2'), concat#2)       ) = ("12"). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
xqhof6,Error: XPST0003: Unable to parse XPath: (          declare function local:curry($f as function(item()*, item()*) as item()*) as function(item()*) as function(item()*) as item()*          {            function($a) { $f($a, ?) }          };                    local:curry(substring-after#2)("foobar")("foo")       ) = ("bar"). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "f" found.
xqhof10,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
xqhof12,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0017: Function matches with arity of 2 not registered. No similar functions found.'
xqhof14,AssertionError: expected [Function] to throw an error
xqhof15,AssertionError: Expected XPath           let $f := <b/>/name#0          return <a/>/$f()               to resolve to "b": expected false to be true
xqhof16,Error: XPST0003: Unable to parse XPath: let $result := (          declare base-uri "main";          import module namespace lib = "lib";                    lib:getfun()(),          fn:static-base-uri#0(),          fn:static-base-uri()       ) return fn:ends-with($result[1], "lib"). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "b" found.
xqhof17,Error: XPST0003: Unable to parse XPath: deep-equal((          import module namespace lib = "lib";                    <main/>/lib:getfun2()(),          <main/>/name#0(),          <main/>/name()       ), ("lib", "main", "main")). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", or "||" but "m" found.
xqhof18,Error: XPST0003: Unable to parse XPath: let $result := (          declare base-uri "main";          import module namespace lib = "lib";                    lib:getfun3()(xs:QName("fn:static-base-uri"),0)(),          function-lookup#2(xs:QName("fn:static-base-uri"),0)(),          function-lookup(xs:QName("fn:static-base-uri"),0)()       ) return fn:ends-with($result[1], "lib"). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "b" found.
xqhof19,Error: XPST0003: Unable to parse XPath: deep-equal((          import module namespace lib = "lib";                    <main/>/lib:getfun3()(xs:QName("fn:name"),0)(),          <main/>/function-lookup#2(xs:QName("fn:name"),0)(),          <main/>/function-lookup(xs:QName("fn:name"),0)()       ), ("lib", "main", "main")). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", or "||" but "m" found.
xqhof20,Error: XPST0003: Unable to parse XPath: deep-equal((           let $m := map {                 "Tuesday" : true(),                 "Wednesday" : true(),                 "Thursday" : false(),                 "Friday" : true(),                 "Monday" : true(),                 "Sunday" : false(),                 "Saturday" : false() }           let $days := ("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")                return fn:filter($days,$m)               ), ("Monday", "Tuesday", "Wednesday", "Friday")). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
xqhof21,AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n          let $m := map {\n                "Tuesday" : true(),\n                "Wednesday" : true(),\n                "Friday" : true(),\n                "Monday" : true(),\n                "Sunday" : false(),\n                "Saturday" : false() }\n          let $days := ("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")     \n          return fn:filter($days,$m)        \n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.'
xqhof22,Error: XPST0003: Unable to parse XPath: deep-equal((           let $m := array {                 true(),                 true(),                 false(),                 true(),                 true(),                 false(),                 false() }           let $indices := (1 to 7)           return fn:filter($indices,$m)               ), (1, 2, 4, 5)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
static-context-1,AssertionError: expected [Function] to throw error including 'XPST0008' but got 'XPST0003: Unable to parse XPath: declare namespace test = \'http://www.example.com\'; \n        <a/> instance of element(*, test:unknownType). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.'
surrogates02,Error: XPST0017: Function substring with arity of 2 not registered. Did you mean "xs:string (xs:anyAtomicType?)", "string (item()?)" or "string ()"?
surrogates03,Error: XPST0017: Function substring with arity of 2 not registered. Did you mean "xs:string (xs:anyAtomicType?)", "string (item()?)" or "string ()"?
surrogates04,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
surrogates05,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
surrogates06,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
surrogates07,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
surrogates08,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
surrogates12,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
surrogates13,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
surrogates14,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
surrogates15,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
surrogates16,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
surrogates02a,Error: XPST0017: Function substring with arity of 2 not registered. Did you mean "xs:string (xs:anyAtomicType?)", "string (item()?)" or "string ()"?
surrogates03a,Error: XPST0017: Function substring with arity of 2 not registered. Did you mean "xs:string (xs:anyAtomicType?)", "string (item()?)" or "string ()"?
surrogates04a,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
surrogates05a,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
surrogates06a,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
surrogates07a,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
surrogates08a,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
surrogates12a,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
surrogates13a,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
surrogates14a,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
surrogates15a,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
surrogates16a,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
XML10-4ed-Excluded-char-1-new,AssertionError: Expected executing the XPath "xquery version "1.0" encoding "utf-8"; <node/>" to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath: xquery version "1.0" encoding "utf-8"; <node/>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found., AssertionError: Skipped test, it was a serialization-matches.
XML11-1ed-Included-char-1,AssertionError: expected [Function] to throw error including 'XPST0003' but got 'String contains an invalid character'
XML11-1ed-Included-char-1-new,AssertionError: Expected executing the XPath "<egg/>" to resolve to one of the expected results, but got InvalidCharacterError: String contains an invalid character, AssertionError: Skipped test, it was a serialization-matches.
line-ending-Q001,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
line-ending-Q002,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
line-ending-Q003,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
line-ending-Q004,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
line-ending-Q005,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
line-ending-Q006,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
line-ending-Q007,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
line-ending-Q008,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
line-ending-Q009,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
line-ending-P002,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
XML11-c0-001,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
Catalog001,Error: XPST0003: Unable to parse XPath: (         declare namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";         let $testsets := //fots:test-set/@file/doc(resolve-uri(., base-uri(..))),             $tests := $testsets//fots-test-case,             $environments := (//fots:environment | $testsets//fots:environment)[@name],             $refs := $testsets//fots:environment[@ref]             return $refs[not(@ref = $environments/@name)]       ) => empty(). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
Catalog003,Error: XPST0003: Unable to parse XPath: (         declare namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";         let $testsets := //fots:test-set/@file/doc(resolve-uri(., base-uri(..)))         for $test in $testsets//fots:test-case[contains(test, "import schema")]         where empty($test/(fots:dependency | ../fots:dependency)[@type='feature' and @value="schemaImport"])          return $test       ) => empty(). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
Catalog004,Error: XPST0003: Unable to parse XPath: (         declare namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";         let $testsets := //fots:test-set/@file/doc(resolve-uri(., base-uri(..)))         for $schema in (.|$testsets)//fots:environment/fots:schema         let $targetNamespace := doc(resolve-uri($schema/@file, base-uri($schema)))/*/@targetNamespace         where not($schema/@uri eq $targetNamespace or (empty($targetNamespace) and string(@uri)=''))         return ($schema, <file>{base-uri($schema)}</file>)       ) => empty(). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
Catalog005,Error: XPST0003: Unable to parse XPath: (         declare namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";         (: ask whether a test is XQuery-only :)         declare function local:needs-xq($t as element(fots:test-case)) as xs:boolean {             let $spec := $t/fots:dependency[@type='spec'][1]             return exists($spec) and contains($spec/@value, 'XQ') and not(contains($spec/@value, 'XP'))                and not(starts-with($t/@name, 'fo-test-' (: special exemption for generated tests :)))         };         let $testsets := //fots:test-set/@file/doc(resolve-uri(., base-uri(..)))         let $nsenvs :=             for $t in ($testsets|.)             for $e in $t//fots:environment[@name]             where exists($e/fots:namespace)              return concat($t/*/@name, '~', $e/@name/string())         let $xq-testcases := $testsets//fots:test-case [local:needs-xq(.)]         for $tc in $xq-testcases [concat(/*/@name, '~', fots:environment/@ref) = $nsenvs or fots:environment[fots:namespace]]         return $tc/@name/string()       ) => empty(). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
Catalog006,Error: XPST0003: Unable to parse XPath: (         declare namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";         (: ask whether a test is XQuery-only :)         declare function local:needs-xq($t as element(fots:test-case)) as xs:boolean {             let $spec := $t/fots:dependency[@type='spec'][1]             return exists($spec) and contains($spec/@value, 'XQ') and not(contains($spec/@value, 'XP'))                and not(starts-with($t/@name, 'fo-test-' (: special exemption for generated tests :)))         };         let $testsets := //fots:test-set/@file/doc(resolve-uri(., base-uri(..)))         let $nsenvs :=             for $t in ($testsets|.)             for $e in $t//fots:environment             where exists($e/fots:decimal-format)              return $e/@name/string()         let $xq-testcases := $testsets//fots:test-case [local:needs-xq(.)]         for $tc in $xq-testcases [fots:environment/@ref = $nsenvs or fots:environment[fots:decimal-format]]         return $tc/@name/string()       ) => empty(). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
Catalog007,Error: XPST0003: Unable to parse XPath: (         xquery version "3.0";         (: output the non-unique test names. There should be none :)         declare namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";         let $testsets := //fots:test-set/@file/doc(resolve-uri(., base-uri(..)))         for $xq-testcase in $testsets//fots:test-case         let $testname := $xq-testcase/@name         group by $testname         where count($xq-testcase) gt 1         return ($testname || "(" || count($xq-testcase) || ")")       ) => empty(). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
Catalog008,Error: XPST0003: Unable to parse XPath: (         declare namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";          for $xq-testcase in //fots:test-set         let $testname := $xq-testcase/@name         let $testfile := $xq-testcase/@file/doc(resolve-uri(., base-uri(..)))         let $file-testname := $testfile/fots:test-set/@name         where $testname != $file-testname         return <out catalog-name="{string($testname)}" test-name="{string($file-testname)}"/>       ) => empty(). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
Catalog009,Error: XPST0003: Unable to parse XPath: (         xquery version "3.0";         declare namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";         let $testsets := //fots:test-set/@file/doc(resolve-uri(., base-uri(..)))         for $dependencyTS in $testsets//fots:dependency         let $name := $dependencyTS/@type         let $value := $dependencyTS/@value         group by $name, $value         order by $name, $value          return <dependency type='{$name}' value='{$value}' />        ) instance of element()*. SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "v" found.
Catalog010,Error: XPST0003: Unable to parse XPath: (         declare namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";         let $changes := doc('../changes.xml')//change/@id/string()         for $xq-test in //fots:test-set         let $testfile := $xq-test/@file/doc(resolve-uri(., base-uri(..)))         let $testset := $testfile/fots:test-set         let $testcases := $testset/fots:test-case         for $token in distinct-values((tokenize($testset/@covers-30, ' '), $testcases/@covers-30/tokenize(., ' '), tokenize($testset/@covers, ' '), $testcases/@covers/tokenize(., ' ')))         where not($token = $changes)         return <out test-set="{string($testset/@name)}" bad-covers-value="{$token}"/>       ) => empty(). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
Catalog011,Error: XPST0003: Unable to parse XPath:      declare namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";     <r>{         let $changes := doc('../changes.xml')//spec[contains(@name, '31')]/change         let $changesid := $changes/@id/string()         let $testfiles := //fots:test-set/@file/doc(resolve-uri(., base-uri(..)))         let $testsets := $testfiles/fots:test-set         for $token in distinct-values($changesid)         let $relevant-testsets := $testsets[tokenize(@covers, ' ') = $token]         let $relevant-testcases := $testsets/fots:test-case[tokenize(@covers, ' ') = $token]         let $count := count($relevant-testsets/fots:test-case) + count($relevant-testcases)         where $count lt 5         return <out spec="{$changes[@id=$token]/../@name}" change="{$token}" tests="{$count}" names="{$relevant-testcases/@name}">         {$changes[@id=$token]/text()}         </out>      }</r>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
Catalog012,Error: XPST0003: Unable to parse XPath: (       declare namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";       let $testsets := //fots:test-set/@file/doc(resolve-uri(., base-uri(..)))       return $testsets//fots:test-case[.//fots:assert-xml[starts-with(., '<?xml')]]     ) => empty(). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
Catalog013,Error: XPST0003: Unable to parse XPath: (       declare namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";       let $testsets := //fots:test-set/@file/doc(resolve-uri(., base-uri(..)))       return $testsets//fots:dependency[@type='spec']              [tokenize(normalize-space(@value), ' ')[not (. =                           ('XP20', 'XP20+', 'XP30', 'XP30+', 'XP31', 'XP31+',                             'XQ10', 'XQ10+', 'XQ30', 'XQ30+', 'XQ31', 'XQ31+',                            'XT30', 'XT30+'))]]/                            concat(../@name, ' => ', @value)     ) => empty(). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
Catalog014,Error: XPST0003: Unable to parse XPath: (     declare namespace fots = "http://www.w3.org/2010/09/qt-fots-catalog";         let $testsets := //fots:test-set/@file/doc(resolve-uri(., base-uri(..)))         for $test in $testsets//fots:test-case         where not(exists($test/(@covers | ../@covers)))         where exists($test/((fots:dependency | ../fots:dependency)[@type='spec' and contains(@value, '31')]))         where not(starts-with($test/@name, 'fo-test-' (: special exemption for generated tests :)))         return <out test="{$test/@name}"/>       ) => empty(). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
sudoku,Error: XPST0003: Unable to parse XPath:          declare namespace fn = "sudoku";         declare variable $board as xs:integer+ :=          	( 1,0,0, 3,0,0, 6,0,0, 0,2,0, 5,0,0, 0,0,4, 0,0,9, 0,0,0,          	5,2,0, 0,0,0, 9,6,3, 0,0,0, 7,1,6, 0,0,0, 0,0,0, 0,0,0,          	0,8,0, 0,4,0, 9,0,0, 0,0,5, 3,0,7, 8,0,0, 4,0,6, 0,0,0,          	3,5,0, 0,0,0, 0,0,1);         declare variable $rowStarts as xs:integer+ := (1, 10, 19, 28, 37, 46, 55, 64,73);         declare variable $groups as xs:integer+ :=          	( 1,1,1, 2,2,2, 3,3,3, 1,1,1, 2,2,2, 3,3,3, 1,1,1, 2,2,2, 3,3,3, 4,4,4,          	5,5,5, 6,6,6, 4,4,4, 5,5,5, 6,6,6, 4,4,4, 5,5,5, 6,6,6, 7,7,7, 8,8,8,          	9,9,9, 7,7,7, 8,8,8, 9,9,9, 7,7,7, 8,8,8, 9,9,9 );         declare function fn:getRow ($board as xs:integer+, $index as xs:integer) as xs:integer+ {          	let $rowStart := floor(($index - 1) div 9) * 9          	return one-or-more($board[position() > $rowStart and position() <= $rowStart + 9])          };         declare function fn:getCol ($board as xs:integer+, $index as xs:integer) as xs:integer+ {          	let $gap := ($index - 1) mod 9,          	    $colIndexes := for $x in $rowStarts          	    		       return $x + $gap          	return one-or-more($board[position() = $colIndexes])          };         declare function fn:getGroup ($board as xs:integer+, $index as xs:integer) as xs:integer+ {          	let $group := $groups[$index]          	return one-or-more($board[for $x in position() return $groups[$x]= $group])          };         declare function fn:getAllowedValues ($board as xs:integer+, $index as xs:integer) as xs:integer* {          	let $existingValues := (fn:getRow($board, $index), fn:getCol($board, $index), fn:getGroup($board, $index))          	return for $x in (1 to 9) return if (not($x = $existingValues)) then $x else ()          };         declare function fn:tryValues($board as xs:integer+, $emptyCells as xs:integer+, $possibleValues as xs:integer+) as xs:integer* {          	let $index as xs:integer := $emptyCells[1],          	    $newBoard as xs:integer+ := ($board[position() <$index], $possibleValues[1], $board[position() > $index]),          	    $result as xs:integer* := fn:populateValues($newBoard, $emptyCells[position() != 1])          	return if (empty($result)) then if (count($possibleValues) > 1) then fn:tryValues($board, $emptyCells, one-or-more($possibleValues[position() != 1])) else () else $result          };         declare function fn:populateValues($board as xs:integer+, $emptyCells as xs:integer*) as xs:integer*{          	if (not(empty($emptyCells)))          	then let $index as xs:integer := exactly-one($emptyCells[1]),          			 $possibleValues as xs:integer* := distinct-values(fn:getAllowedValues($board, $index))          		 return if (count($possibleValues) > 1)          		        then fn:tryValues($board, one-or-more($emptyCells), one-or-more($possibleValues))          		        else if (count($possibleValues) = 1)          		        then let $newBoard as xs:integer+ :=($board[position() < $index],          		                   exactly-one($possibleValues[1]), $board[position() > $index])          		             return fn:populateValues($newBoard, $emptyCells[position() != 1])          		        else ()          	else $board          };         declare function fn:solveSudoku ($startBoard as xs:integer+) as xs:integer+{          	let $emptyCells as xs:integer* :=         			for $x in (1 to 81)          			return if ($startBoard[$x] = 0) then $x else (),          		$endBoard as xs:integer* :=fn:populateValues($startBoard,$emptyCells)          	return if (empty($endBoard)) then $startBoard else one-or-more($endBoard)         };         declare function fn:drawResult ($board as xs:integer+) as element(){          	<html><head><title>Sudoku - XSLT</title><style>table {{ border-collapse: collapse; border: 1px solid black; }} td {{ padding: 10px; }} .norm {{ border-left: 1px solid #CCC; border-top: 1px solid #CCC; }} .csep {{ border-left: 1px solid black; }} .rsep {{ border-top: 1px solid black; }}</style></head><body>{fn:drawBoard($board)}</body></html> };         declare function fn:drawBoard ($board as xs:integer+) as element(){          	<table>{for $i in 1 to 9 return          		<tr>{for $j at $p in 1 to 9          			  let $pos := (($i - 1) * 9) + $j          			  return <td class="{if ($p mod 3 = 1) then 'csep' else ('norm')} {if ($i mod 3 = 1) then 'rsep' else ('norm')}"> {$board[$pos]}</td>          			  }</tr> }</table>          };         fn:drawResult(fn:solveSudoku($board))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
currencysvg,Error: XPST0003: Unable to parse XPath: (: Name: currencysvg :) (: Description: Draw an SVG of currency exchange data :) (: Author: Nick Jones :) (: Date: 2008-10-30 :) (: Declare namespaces :) declare default element namespace "http://www.w3.org/2000/svg"; declare namespace msg="http://www.SDMX.org/resources/SDMXML/schemas/v1_0/message"; declare namespace frbny="http://www.newyorkfed.org/xml/schemas/FX/utility";  (: Currency to lookup :) declare variable $input-context := .;  (: A list of observations :) declare variable $obs := $input-context/msg:UtilityData/frbny:DataSet/frbny:Series/frbny:Obs;  (: Minimum/maximum/average exchange rates :) declare variable $values := $obs/frbny:OBS_VALUE/xs:decimal(.); declare variable $minValue := min($values); declare variable $maxValue := max($values); declare variable $avgValue := avg($values);   (: First/last dates :) declare variable $dates := $obs/frbny:TIME_PERIOD/xs:date(.); declare variable $firstDate := min($dates); declare variable $lastDate := max($dates);  (: Returns the change in exchange rate over a specified number of days :) declare function local:period-change($ob as element(frbny:Obs,xs:untyped),                                      $days as xs:positiveInteger) as xs:decimal {     let $previous := xs:decimal($ob/following-sibling::frbny:Obs[$days]/frbny:OBS_VALUE)     return xs:decimal($ob/frbny:OBS_VALUE - $previous) };   (: Converts an observation to an x,y coordinate pair :) declare function local:coordinate($ob as element(frbny:Obs,xs:untyped)) as xs:decimal+ {   (     xs:decimal((xs:date($ob/frbny:TIME_PERIOD) - $firstDate) div ($lastDate - $firstDate) * 1000)     ,     xs:decimal(1000 - ($ob/frbny:OBS_VALUE - $minValue) div ($maxValue - $minValue) * 1000)   ) };  (: Labels the largest falls and rises over a specified number of days :) declare function local:label-changes($days as xs:positiveInteger) as element(text,xs:anyType)+ {       let $sortedByChange:=            for $ob in $obs[position() <= last() - $days]           order by local:period-change($ob,$days) descending           return $ob       return         (           local:label-observation($sortedByChange[last()]/following-sibling::frbny:Obs[$days],concat('Largest ',$days,'-day rise'))           ,           local:label-observation($sortedByChange[1]/following-sibling::frbny:Obs[$days],concat('Largest ',$days,'-day fall'))         ) };  (: Labels an observation :) declare function local:label-observation($ob as element(frbny:Obs,xs:untyped),$label as xs:string) as element(text,xs:anyType) {       let $coord := local:coordinate($ob)       return         <text x="{round-half-to-even($coord[1], 4)}"                   y="{round-half-to-even($coord[2], 4)}"                   text-anchor="end"                   title="{concat($ob/frbny:TIME_PERIOD,' - ',$ob/frbny:OBS_VALUE)}">           {$label}         </text> };  <svg viewBox="-50,-50,1100,1100">    <!-- Border -->   <path stroke="black" fill="none" stroke-width="1" d="M0,0L1000,0L1000,1000L0,1000L0,0"/>    <!-- Title -->   <text x="500" y="-20" text-anchor="middle">{string($input-context/msg:UtilityData/msg:Header/msg:Name)}</text>    <!-- Generator -->   <text x="500" y="1040" text-anchor="middle">Generated by XQSharp</text>    <!-- Ranges -->   <text x="0" y="1020" text-anchor="middle">{$firstDate}</text>   <text x="1000" y="1020" text-anchor="middle">{$lastDate}</text>   <text x="0" y="0" text-anchor="end">{$maxValue}</text>   <text x="0" y="1000" text-anchor="end">{$minValue}</text>    <!-- Graph -->   <path stroke="red" fill="none" stroke-width="1">     {       attribute {"d"}       {         for $ob at $pos in $obs         let $coord := local:coordinate($ob)         return           concat(if($pos = 1) then "M" else "L",round-half-to-even($coord[1], 4),",",round-half-to-even($coord[2], 4))       }     }   </path>    <!-- Average -->   <path stroke="blue" fill="none" stroke-with="2" d="M0,{round-half-to-even(($maxValue - $avgValue) div ($maxValue - $minValue) * 1000, 4)}l1000,0"/>   <text x="0" y="{round-half-to-even(($maxValue - $avgValue) div ($maxValue - $minValue) * 1000, 4)}" text-anchor="end">Average</text>    {     (: Label largest changes over 1,5,90,365 days :)     for $days in (1,5,90,365)     return local:label-changes(xs:positiveInteger($days))   } </svg> . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "d" found.
raytracer,Error: XPST0003: Unable to parse XPath: let $result := (         import module namespace raytracer="http://www.xqsharp.com/raytracer";         import module namespace scene="http://www.xqsharp.com/raytracer/scene";         declare variable $width := 64;         declare variable $height := 64;         declare variable $input-context := .;         declare variable $scene := scene:prepare-scene($input-context/scene);         string-join( ( "P3", string-join((string($width), string($height)), " "), "255", (: : Now the pixel data. We take each pixel in the image, and recenter it, so that the : y co-ordinate ($y-recentered) ranges from -0.5 at the bottom of the image, to 0.5 : at the top of the image. : : The aspect ratio is used to "stretch" the range of x-coordinate values to stop the : image from being skewed. :)          let $aspect-ratio := $width div $height          for $y in 1 to $height          let $y-recentered := ((-$y div $height) + 0.5)          for $x in 1 to $width          let $x-recentered := (($x div $width) - 0.5) * $aspect-ratio          return (: plot-pixel returns us the rgb values of the color of this pixel.          		  We convert these to an integer value in the range [0, 255], and output them. :)          	string-join( for $channel in raytracer:plot-pixel($scene, $x-recentered, $y-recentered)          			     return string(floor($channel * 255)), " ") ), "&#xA;" )       ) return starts-with(normalize-space(string-join($result, ' ')), 'P3 64 64 255 0 0 0'). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "ne", "or", "to", "union", "|", or "||" but "m" found.
functx-fn-adjust-date-to-timezone-1,Error: XPST0017: Function adjust-date-to-timezone with arity of 2 not registered. No similar functions found.
functx-fn-adjust-date-to-timezone-2,Error: XPST0017: Function adjust-date-to-timezone with arity of 2 not registered. No similar functions found.
functx-fn-adjust-date-to-timezone-3,Error: XPST0017: Function adjust-date-to-timezone with arity of 2 not registered. No similar functions found.
functx-fn-adjust-date-to-timezone-4,Error: XPST0017: Function adjust-date-to-timezone with arity of 2 not registered. No similar functions found.
functx-fn-adjust-date-to-timezone-all,Error: XPST0017: Function adjust-date-to-timezone with arity of 2 not registered. No similar functions found.
functx-fn-adjust-dateTime-to-timezone-1,Error: XPST0017: Function adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
functx-fn-adjust-dateTime-to-timezone-2,Error: XPST0017: Function adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
functx-fn-adjust-dateTime-to-timezone-3,Error: XPST0017: Function adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
functx-fn-adjust-dateTime-to-timezone-4,Error: XPST0017: Function adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
functx-fn-adjust-dateTime-to-timezone-5,Error: XPST0017: Function adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
functx-fn-adjust-dateTime-to-timezone-all,Error: XPST0017: Function adjust-dateTime-to-timezone with arity of 2 not registered. No similar functions found.
functx-fn-adjust-time-to-timezone-1,Error: XPST0017: Function adjust-time-to-timezone with arity of 2 not registered. No similar functions found.
functx-fn-adjust-time-to-timezone-2,Error: XPST0017: Function adjust-time-to-timezone with arity of 2 not registered. No similar functions found.
functx-fn-adjust-time-to-timezone-3,Error: XPST0017: Function adjust-time-to-timezone with arity of 2 not registered. No similar functions found.
functx-fn-adjust-time-to-timezone-4,Error: XPST0017: Function adjust-time-to-timezone with arity of 2 not registered. No similar functions found.
functx-fn-adjust-time-to-timezone-all,Error: XPST0017: Function adjust-time-to-timezone with arity of 2 not registered. No similar functions found.
functx-fn-avg-3,Error: FORG0006: items passed to fn:avg are not all numeric.
functx-fn-avg-all,Error: FORG0006: items passed to fn:avg are not all numeric.
functx-fn-base-uri-1,Error: XPST0017: Function base-uri with arity of 1 not registered. No similar functions found.
functx-fn-base-uri-2,Error: XPST0017: Function base-uri with arity of 1 not registered. No similar functions found.
functx-fn-base-uri-3,Error: XPST0017: Function base-uri with arity of 1 not registered. No similar functions found.
functx-fn-base-uri-all,Error: XPST0017: Function base-uri with arity of 1 not registered. No similar functions found.
functx-fn-codepoint-equal-1,Error: XPST0017: Function codepoint-equal with arity of 2 not registered. Did you mean "deep-equal (item()*, item()*)" or "deep-equal (item()*, item()*, xs:string)"?
functx-fn-codepoint-equal-2,Error: XPST0017: Function codepoint-equal with arity of 2 not registered. Did you mean "deep-equal (item()*, item()*)" or "deep-equal (item()*, item()*, xs:string)"?
functx-fn-codepoint-equal-3,Error: XPST0017: Function codepoint-equal with arity of 2 not registered. Did you mean "deep-equal (item()*, item()*)" or "deep-equal (item()*, item()*, xs:string)"?
functx-fn-codepoint-equal-all,Error: XPST0017: Function codepoint-equal with arity of 2 not registered. Did you mean "deep-equal (item()*, item()*)" or "deep-equal (item()*, item()*, xs:string)"?
functx-fn-codepoints-to-string-1,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
functx-fn-codepoints-to-string-2,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
functx-fn-codepoints-to-string-3,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
functx-fn-codepoints-to-string-all,Error: XPST0017: Function codepoints-to-string with arity of 1 not registered. No similar functions found.
functx-fn-count-3,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-fn-count-all,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-fn-data-1,Error: XPST0017: Function data with arity of 1 not registered. No similar functions found.
functx-fn-data-2,Error: XPST0017: Function data with arity of 1 not registered. No similar functions found.
functx-fn-data-3,Error: XPST0017: Function data with arity of 1 not registered. No similar functions found.
functx-fn-data-4,Error: XPST0017: Function data with arity of 1 not registered. No similar functions found.
functx-fn-data-5,Error: XPST0017: Function data with arity of 1 not registered. No similar functions found.
functx-fn-data-6,Error: XPST0017: Function data with arity of 1 not registered. No similar functions found.
functx-fn-data-all,Error: XPST0017: Function data with arity of 1 not registered. No similar functions found.
functx-fn-dateTime-1,Error: XPST0017: Function dateTime with arity of 2 not registered. Did you mean "xs:dateTime (xs:anyAtomicType?)"?
functx-fn-day-from-date-1,Error: XPST0017: Function day-from-date with arity of 1 not registered. No similar functions found.
functx-fn-day-from-dateTime-1,Error: XPST0017: Function day-from-dateTime with arity of 1 not registered. No similar functions found.
functx-fn-days-from-duration-1,Error: XPST0017: Function days-from-duration with arity of 1 not registered. No similar functions found.
functx-fn-days-from-duration-2,Error: XPST0017: Function days-from-duration with arity of 1 not registered. No similar functions found.
functx-fn-days-from-duration-3,Error: XPST0017: Function days-from-duration with arity of 1 not registered. No similar functions found.
functx-fn-days-from-duration-4,Error: XPST0017: Function days-from-duration with arity of 1 not registered. No similar functions found.
functx-fn-days-from-duration-5,Error: XPST0017: Function days-from-duration with arity of 1 not registered. No similar functions found.
functx-fn-days-from-duration-all,Error: XPST0017: Function days-from-duration with arity of 1 not registered. No similar functions found.
functx-fn-default-collation-1,Error: XPST0017: Function default-collation with arity of 0 not registered. No similar functions found.
functx-fn-distinct-values-1,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-fn-distinct-values-2,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-fn-distinct-values-3,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-fn-distinct-values-4,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-fn-distinct-values-5,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-fn-distinct-values-6,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-fn-distinct-values-all,Error: XPST0017: Function distinct-values with arity of 1 not registered. No similar functions found.
functx-fn-doc-available-1,Error: XPST0017: Function doc-available with arity of 1 not registered. No similar functions found.
functx-fn-encode-for-uri-1,Error: XPST0017: Function encode-for-uri with arity of 1 not registered. No similar functions found.
functx-fn-encode-for-uri-2,Error: XPST0017: Function encode-for-uri with arity of 1 not registered. No similar functions found.
functx-fn-encode-for-uri-all,Error: XPST0017: Function encode-for-uri with arity of 1 not registered. No similar functions found.
functx-fn-escape-html-uri-1,Error: XPST0017: Function escape-html-uri with arity of 1 not registered. No similar functions found.
functx-fn-escape-html-uri-2,Error: XPST0017: Function escape-html-uri with arity of 1 not registered. No similar functions found.
functx-fn-escape-html-uri-all,Error: XPST0017: Function escape-html-uri with arity of 1 not registered. No similar functions found.
functx-fn-hours-from-dateTime-1,Error: XPST0017: Function hours-from-dateTime with arity of 1 not registered. No similar functions found.
functx-fn-hours-from-dateTime-2,Error: XPST0017: Function hours-from-dateTime with arity of 1 not registered. No similar functions found.
functx-fn-hours-from-dateTime-all,Error: XPST0017: Function hours-from-dateTime with arity of 1 not registered. No similar functions found.
functx-fn-hours-from-duration-1,Error: XPST0017: Function hours-from-duration with arity of 1 not registered. No similar functions found.
functx-fn-hours-from-duration-2,Error: XPST0017: Function hours-from-duration with arity of 1 not registered. No similar functions found.
functx-fn-hours-from-duration-3,Error: XPST0017: Function hours-from-duration with arity of 1 not registered. No similar functions found.
functx-fn-hours-from-duration-4,Error: XPST0017: Function hours-from-duration with arity of 1 not registered. No similar functions found.
functx-fn-hours-from-duration-5,Error: XPST0017: Function hours-from-duration with arity of 1 not registered. No similar functions found.
functx-fn-hours-from-duration-all,Error: XPST0017: Function hours-from-duration with arity of 1 not registered. No similar functions found.
functx-fn-hours-from-time-1,Error: XPST0017: Function hours-from-time with arity of 1 not registered. No similar functions found.
functx-fn-hours-from-time-2,Error: XPST0017: Function hours-from-time with arity of 1 not registered. No similar functions found.
functx-fn-hours-from-time-all,Error: XPST0017: Function hours-from-time with arity of 1 not registered. No similar functions found.
functx-fn-index-of-1,Error: XPST0017: Function index-of with arity of 2 not registered. No similar functions found.
functx-fn-index-of-2,Error: XPST0017: Function index-of with arity of 2 not registered. No similar functions found.
functx-fn-index-of-3,Error: XPST0017: Function index-of with arity of 2 not registered. No similar functions found.
functx-fn-index-of-4,Error: XPST0017: Function index-of with arity of 2 not registered. No similar functions found.
functx-fn-index-of-5,Error: XPST0017: Function index-of with arity of 2 not registered. No similar functions found.
functx-fn-index-of-6,Error: XPST0017: Function index-of with arity of 2 not registered. No similar functions found.
functx-fn-index-of-7,Error: XPST0017: Function index-of with arity of 2 not registered. No similar functions found.
functx-fn-index-of-all,Error: XPST0017: Function index-of with arity of 2 not registered. No similar functions found.
functx-fn-iri-to-uri-1,Error: XPST0017: Function iri-to-uri with arity of 1 not registered. No similar functions found.
functx-fn-lang-1,Error: XPST0017: Function lang with arity of 1 not registered. No similar functions found.
functx-fn-lang-2,Error: XPST0017: Function lang with arity of 1 not registered. No similar functions found.
functx-fn-lang-3,Error: XPST0017: Function lang with arity of 1 not registered. No similar functions found.
functx-fn-lang-4,Error: XPST0017: Function lang with arity of 1 not registered. No similar functions found.
functx-fn-lang-5,Error: XPST0017: Function lang with arity of 1 not registered. No similar functions found.
functx-fn-lang-6,Error: XPST0017: Function lang with arity of 1 not registered. No similar functions found.
functx-fn-lang-all,Error: XPST0017: Function lang with arity of 1 not registered. No similar functions found.
functx-fn-local-name-1,Error: XPST0003: Unable to parse XPath: (declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (local-name($in-xml)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-local-name-2,Error: XPST0003: Unable to parse XPath: (declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (local-name($in-xml//pre:prefixed)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-local-name-3,Error: XPST0003: Unable to parse XPath: (declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (local-name($in-xml//unpre:unprefixed)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-local-name-4,Error: XPST0003: Unable to parse XPath: (declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (local-name($in-xml//@pre:prefAttr)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-local-name-5,Error: XPST0003: Unable to parse XPath: (declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (local-name($in-xml//@noNSAttr)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-local-name-all,Error: XPST0003: Unable to parse XPath: (declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (local-name($in-xml), local-name($in-xml//pre:prefixed), local-name($in-xml//unpre:unprefixed), local-name($in-xml//@pre:prefAttr), local-name($in-xml//@noNSAttr)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-matches-1,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-fn-matches-2,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-fn-matches-3,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-fn-matches-4,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-fn-matches-5,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-fn-matches-6,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-fn-matches-7,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-fn-matches-8,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-fn-matches-9,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-fn-matches-10,Error: XPST0017: Function matches with arity of 3 not registered. No similar functions found.
functx-fn-matches-11,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-fn-matches-12,Error: XPST0017: Function matches with arity of 3 not registered. No similar functions found.
functx-fn-matches-13,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-fn-matches-14,Error: XPST0017: Function matches with arity of 3 not registered. No similar functions found.
functx-fn-matches-15,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-fn-matches-16,Error: XPST0017: Function matches with arity of 3 not registered. No similar functions found.
functx-fn-matches-17,Error: XPST0017: Function matches with arity of 3 not registered. No similar functions found.
functx-fn-matches-18,Error: XPST0017: Function matches with arity of 3 not registered. No similar functions found.
functx-fn-matches-all,Error: XPST0017: Function matches with arity of 2 not registered. No similar functions found.
functx-fn-minutes-from-dateTime-1,Error: XPST0017: Function minutes-from-dateTime with arity of 1 not registered. No similar functions found.
functx-fn-minutes-from-duration-1,Error: XPST0017: Function minutes-from-duration with arity of 1 not registered. No similar functions found.
functx-fn-minutes-from-duration-2,Error: XPST0017: Function minutes-from-duration with arity of 1 not registered. No similar functions found.
functx-fn-minutes-from-duration-3,Error: XPST0017: Function minutes-from-duration with arity of 1 not registered. No similar functions found.
functx-fn-minutes-from-duration-4,Error: XPST0017: Function minutes-from-duration with arity of 1 not registered. No similar functions found.
functx-fn-minutes-from-duration-5,Error: XPST0017: Function minutes-from-duration with arity of 1 not registered. No similar functions found.
functx-fn-minutes-from-duration-all,Error: XPST0017: Function minutes-from-duration with arity of 1 not registered. No similar functions found.
functx-fn-minutes-from-time-1,Error: XPST0017: Function minutes-from-time with arity of 1 not registered. No similar functions found.
functx-fn-month-from-date-1,Error: XPST0017: Function month-from-date with arity of 1 not registered. No similar functions found.
functx-fn-month-from-dateTime-1,Error: XPST0017: Function month-from-dateTime with arity of 1 not registered. No similar functions found.
functx-fn-months-from-duration-1,Error: XPST0017: Function months-from-duration with arity of 1 not registered. No similar functions found.
functx-fn-months-from-duration-2,Error: XPST0017: Function months-from-duration with arity of 1 not registered. No similar functions found.
functx-fn-months-from-duration-3,Error: XPST0017: Function months-from-duration with arity of 1 not registered. No similar functions found.
functx-fn-months-from-duration-4,Error: XPST0017: Function months-from-duration with arity of 1 not registered. No similar functions found.
functx-fn-months-from-duration-all,Error: XPST0017: Function months-from-duration with arity of 1 not registered. No similar functions found.
functx-fn-name-1,Error: XPST0003: Unable to parse XPath: (declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (name($in-xml)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-name-2,Error: XPST0003: Unable to parse XPath: (declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (name($in-xml//pre2:prefixed)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-name-3,Error: XPST0003: Unable to parse XPath: (declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (name($in-xml//unpre2:unprefixed)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-name-4,Error: XPST0003: Unable to parse XPath: (declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (name($in-xml//@pre2:prefAttr)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-name-5,Error: XPST0003: Unable to parse XPath: (declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (name($in-xml//@noNSAttr)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-name-all,Error: XPST0003: Unable to parse XPath: (declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (name($in-xml), name($in-xml//pre2:prefixed), name($in-xml//unpre2:unprefixed), name($in-xml//@pre2:prefAttr), name($in-xml//@noNSAttr)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-namespace-uri-for-prefix-1,Error: XPST0003: Unable to parse XPath: (declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (namespace-uri-for-prefix( '', $in-xml)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-namespace-uri-for-prefix-2,Error: XPST0003: Unable to parse XPath: (declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (namespace-uri-for-prefix( 'pre',$in-xml//pre:prefixed)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-namespace-uri-for-prefix-3,Error: XPST0003: Unable to parse XPath: (declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (namespace-uri-for-prefix( '',$in-xml//unpre:unprefixed)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-namespace-uri-for-prefix-4,Error: XPST0003: Unable to parse XPath: (declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (namespace-uri-for-prefix( 'pre',$in-xml//unpre:unprefixed)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-namespace-uri-for-prefix-all,Error: XPST0003: Unable to parse XPath: (declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml :=           <noNamespace>              <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre">                  <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed>              </pre:prefixed>          </noNamespace>          return (namespace-uri-for-prefix('', $in-xml),                 namespace-uri-for-prefix('pre',$in-xml//pre:prefixed),                 namespace-uri-for-prefix('',$in-xml//unpre:unprefixed),                 namespace-uri-for-prefix('pre',$in-xml//unpre:unprefixed))       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-namespace-uri-1,Error: XPST0003: Unable to parse XPath: (declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (namespace-uri($in-xml)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-namespace-uri-2,Error: XPST0003: Unable to parse XPath: (declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (namespace-uri($in-xml//pre:prefixed)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-namespace-uri-3,Error: XPST0003: Unable to parse XPath: (declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (namespace-uri($in-xml//unpre:unprefixed)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-namespace-uri-4,Error: XPST0003: Unable to parse XPath: (declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (namespace-uri($in-xml//@pre:prefAttr)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-namespace-uri-5,Error: XPST0003: Unable to parse XPath: (declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (namespace-uri($in-xml//@noNSAttr)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-namespace-uri-all,Error: XPST0003: Unable to parse XPath: (declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (namespace-uri($in-xml), namespace-uri($in-xml//pre:prefixed), namespace-uri($in-xml//unpre:unprefixed), namespace-uri($in-xml//@pre:prefAttr), namespace-uri($in-xml//@noNSAttr)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-nilled-1,Error: XPST0017: Function nilled with arity of 1 not registered. No similar functions found.
functx-fn-nilled-2,Error: XPST0017: Function nilled with arity of 1 not registered. No similar functions found.
functx-fn-nilled-3,Error: XPST0017: Function nilled with arity of 1 not registered. No similar functions found.
functx-fn-nilled-4,Error: XPST0017: Function nilled with arity of 1 not registered. No similar functions found.
functx-fn-nilled-all,Error: XPST0017: Function nilled with arity of 1 not registered. No similar functions found.
functx-fn-node-name-1,Error: XPST0003: Unable to parse XPath: (declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (node-name($in-xml)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-node-name-2,Error: XPST0003: Unable to parse XPath: (declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (node-name($in-xml/pre2:prefixed)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-node-name-3,Error: XPST0003: Unable to parse XPath: (declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (node-name($in-xml//unpre2:unprefixed)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-node-name-4,Error: XPST0003: Unable to parse XPath: (declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (node-name($in-xml//@pre2:prefAttr)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-node-name-5,Error: XPST0003: Unable to parse XPath: (declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (node-name($in-xml//@noNSAttr)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-node-name-all,Error: XPST0003: Unable to parse XPath: (declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (node-name($in-xml), node-name($in-xml/pre2:prefixed), node-name($in-xml//unpre2:unprefixed), node-name($in-xml//@pre2:prefAttr), node-name($in-xml//@noNSAttr)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-normalize-unicode-1,Error: XPST0017: Function normalize-unicode with arity of 1 not registered. Did you mean "normalize-space (xs:string?)" or "normalize-space ()"?
functx-fn-normalize-unicode-2,Error: XPST0017: Function normalize-unicode with arity of 2 not registered. Did you mean "normalize-space (xs:string?)" or "normalize-space ()"?
functx-fn-normalize-unicode-all,Error: XPST0017: Function normalize-unicode with arity of 1 not registered. Did you mean "normalize-space (xs:string?)" or "normalize-space ()"?
functx-fn-prefix-from-QName-1,Error: XPST0003: Unable to parse XPath: (declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (prefix-from-QName( node-name($in-xml))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-prefix-from-QName-2,Error: XPST0003: Unable to parse XPath: (declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (prefix-from-QName( node-name($in-xml//pre2:prefixed))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-prefix-from-QName-3,Error: XPST0003: Unable to parse XPath: (declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (prefix-from-QName( node-name($in-xml//unpre:unprefixed))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-prefix-from-QName-4,Error: XPST0003: Unable to parse XPath: (declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (prefix-from-QName( node-name($in-xml//@pre2:prefAttr))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-prefix-from-QName-5,Error: XPST0003: Unable to parse XPath: (declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (prefix-from-QName( node-name($in-xml//@noNSAttr))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-prefix-from-QName-6,Error: XPST0003: Unable to parse XPath: (declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (prefix-from-QName( node-name(<pre2:new>xyz</pre2:new>))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-prefix-from-QName-all,Error: XPST0003: Unable to parse XPath: (declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (prefix-from-QName( node-name($in-xml)), prefix-from-QName( node-name($in-xml//pre2:prefixed)), prefix-from-QName( node-name($in-xml//unpre:unprefixed)), prefix-from-QName( node-name($in-xml//@pre2:prefAttr)), prefix-from-QName( node-name($in-xml//@noNSAttr)), prefix-from-QName( node-name(<pre2:new>xyz</pre2:new>))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-replace-1,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-2,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-3,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-4,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-5,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-6,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-7,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-8,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-9,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-10,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-11,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-12,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-13,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-14,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-15,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-16,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-17,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-18,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-19,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-replace-all,Error: XPST0017: Function replace with arity of 3 not registered. No similar functions found.
functx-fn-resolve-QName-1,Error: XPST0003: Unable to parse XPath: (declare namespace ord = "http://datypic.com/ord";          declare namespace dty = "http://datypic.com";          declare namespace dty2 = "http://datypic.com/ns2";          let $root := <root> <order xmlns:ord="http://datypic.com/ord" xmlns="http://datypic.com"> <!-- ... --> </order> </root> return (resolve-QName('myName', $root)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-resolve-QName-2,Error: XPST0003: Unable to parse XPath: (declare namespace ord = "http://datypic.com/ord";          declare namespace dty = "http://datypic.com";          declare namespace dty2 = "http://datypic.com/ns2";          let $root := <root> <order xmlns:ord="http://datypic.com/ord" xmlns="http://datypic.com"> <!-- ... --> </order> </root> return (resolve-QName('myName', $root/dty:order)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-resolve-QName-3,Error: XPST0003: Unable to parse XPath: (declare namespace ord = "http://datypic.com/ord";          declare namespace dty = "http://datypic.com";          declare namespace dty2 = "http://datypic.com/ns2";          let $root := <root> <order xmlns:ord="http://datypic.com/ord" xmlns="http://datypic.com"> <!-- ... --> </order> </root> return (resolve-QName( 'ord:myName', $root/dty:order)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-resolve-QName-all,Error: XPST0003: Unable to parse XPath: (declare namespace ord = "http://datypic.com/ord";          declare namespace dty = "http://datypic.com";          declare namespace dty2 = "http://datypic.com/ns2";          let $root := <root> <order xmlns:ord="http://datypic.com/ord" xmlns="http://datypic.com"> <!-- ... --> </order> </root> return (resolve-QName('myName', $root), resolve-QName('myName', $root/dty:order), resolve-QName( 'ord:myName', $root/dty:order)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-fn-resolve-uri-1,Error: XPST0017: Function resolve-uri with arity of 2 not registered. No similar functions found.
functx-fn-resolve-uri-2,Error: XPST0017: Function resolve-uri with arity of 2 not registered. No similar functions found.
functx-fn-resolve-uri-3,Error: XPST0017: Function resolve-uri with arity of 2 not registered. No similar functions found.
functx-fn-resolve-uri-4,AssertionError: Expected executing the XPath "(resolve-uri( 'http://datypic.com', '../base'))" to resolve to one of the expected results, but got Error: XPST0017: Function resolve-uri with arity of 2 not registered. No similar functions found., AssertionError: expected [Function] to throw error including 'FORG0002' but got 'XPST0017: Function resolve-uri with arity of 2 not registered. No similar functions found.'.
functx-fn-resolve-uri-5,AssertionError: Expected executing the XPath "(resolve-uri( '', 'http://datypic.com'))" to resolve to one of the expected results, but got Error: XPST0017: Function resolve-uri with arity of 2 not registered. No similar functions found., Error: XPST0017: Function resolve-uri with arity of 2 not registered. No similar functions found..
functx-fn-resolve-uri-all,Error: XPST0017: Function resolve-uri with arity of 2 not registered. No similar functions found.
functx-fn-root-1,Error: XPST0017: Function root with arity of 1 not registered. No similar functions found.
functx-fn-root-2,Error: XPST0017: Function root with arity of 1 not registered. No similar functions found.
functx-fn-root-all,Error: XPST0003: Unable to parse XPath:           let $in-xml := <a><x>123</x></a>           return document{(root( (/) //item[1]), root($in-xml/x))}       . SyntaxError: Expected " ", "!", "!=", "#", "(", "(:", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], [-], or end of input but "{" found.
functx-fn-seconds-from-dateTime-1,Error: XPST0017: Function seconds-from-dateTime with arity of 1 not registered. No similar functions found.
functx-fn-seconds-from-duration-1,Error: XPST0017: Function seconds-from-duration with arity of 1 not registered. No similar functions found.
functx-fn-seconds-from-duration-2,Error: XPST0017: Function seconds-from-duration with arity of 1 not registered. No similar functions found.
functx-fn-seconds-from-duration-3,Error: XPST0017: Function seconds-from-duration with arity of 1 not registered. No similar functions found.
functx-fn-seconds-from-duration-4,Error: XPST0017: Function seconds-from-duration with arity of 1 not registered. No similar functions found.
functx-fn-seconds-from-duration-all,Error: XPST0017: Function seconds-from-duration with arity of 1 not registered. No similar functions found.
functx-fn-seconds-from-time-1,Error: XPST0017: Function seconds-from-time with arity of 1 not registered. No similar functions found.
functx-fn-string-to-codepoints-1,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
functx-fn-string-to-codepoints-2,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
functx-fn-string-to-codepoints-3,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
functx-fn-string-to-codepoints-all,Error: XPST0017: Function string-to-codepoints with arity of 1 not registered. No similar functions found.
functx-fn-substring-1,Error: XPST0017: Function substring with arity of 2 not registered. Did you mean "xs:string (xs:anyAtomicType?)", "string (item()?)" or "string ()"?
functx-fn-substring-2,Error: XPST0017: Function substring with arity of 2 not registered. Did you mean "xs:string (xs:anyAtomicType?)", "string (item()?)" or "string ()"?
functx-fn-substring-3,Error: XPST0017: Function substring with arity of 3 not registered. Did you mean "xs:string (xs:anyAtomicType?)", "string (item()?)" or "string ()"?
functx-fn-substring-4,Error: XPST0017: Function substring with arity of 3 not registered. Did you mean "xs:string (xs:anyAtomicType?)", "string (item()?)" or "string ()"?
functx-fn-substring-5,Error: XPST0017: Function substring with arity of 3 not registered. Did you mean "xs:string (xs:anyAtomicType?)", "string (item()?)" or "string ()"?
functx-fn-substring-6,Error: XPST0017: Function substring with arity of 3 not registered. Did you mean "xs:string (xs:anyAtomicType?)", "string (item()?)" or "string ()"?
functx-fn-substring-7,Error: XPST0017: Function substring with arity of 2 not registered. Did you mean "xs:string (xs:anyAtomicType?)", "string (item()?)" or "string ()"?
functx-fn-substring-8,Error: XPST0017: Function substring with arity of 3 not registered. Did you mean "xs:string (xs:anyAtomicType?)", "string (item()?)" or "string ()"?
functx-fn-substring-9,Error: XPST0017: Function substring with arity of 3 not registered. Did you mean "xs:string (xs:anyAtomicType?)", "string (item()?)" or "string ()"?
functx-fn-substring-10,Error: XPST0017: Function substring with arity of 2 not registered. Did you mean "xs:string (xs:anyAtomicType?)", "string (item()?)" or "string ()"?
functx-fn-substring-11,Error: XPST0017: Function substring with arity of 2 not registered. Did you mean "xs:string (xs:anyAtomicType?)", "string (item()?)" or "string ()"?
functx-fn-substring-all,Error: XPST0017: Function substring with arity of 2 not registered. Did you mean "xs:string (xs:anyAtomicType?)", "string (item()?)" or "string ()"?
functx-fn-sum-3,Error: FORG0006: items passed to fn:sum are not all numeric.
functx-fn-sum-all,Error: FORG0006: items passed to fn:sum are not all numeric.
functx-fn-timezone-from-date-1,Error: XPST0017: Function timezone-from-date with arity of 1 not registered. No similar functions found.
functx-fn-timezone-from-date-2,Error: XPST0017: Function timezone-from-date with arity of 1 not registered. No similar functions found.
functx-fn-timezone-from-date-all,Error: XPST0017: Function timezone-from-date with arity of 1 not registered. No similar functions found.
functx-fn-timezone-from-dateTime-1,Error: XPST0017: Function timezone-from-dateTime with arity of 1 not registered. No similar functions found.
functx-fn-timezone-from-dateTime-2,Error: XPST0017: Function timezone-from-dateTime with arity of 1 not registered. No similar functions found.
functx-fn-timezone-from-dateTime-all,Error: XPST0017: Function timezone-from-dateTime with arity of 1 not registered. No similar functions found.
functx-fn-timezone-from-time-1,Error: XPST0017: Function timezone-from-time with arity of 1 not registered. No similar functions found.
functx-fn-timezone-from-time-2,Error: XPST0017: Function timezone-from-time with arity of 1 not registered. No similar functions found.
functx-fn-timezone-from-time-3,Error: XPST0017: Function timezone-from-time with arity of 1 not registered. No similar functions found.
functx-fn-timezone-from-time-4,Error: XPST0017: Function timezone-from-time with arity of 1 not registered. No similar functions found.
functx-fn-timezone-from-time-all,Error: XPST0017: Function timezone-from-time with arity of 1 not registered. No similar functions found.
functx-fn-translate-1,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
functx-fn-translate-2,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
functx-fn-translate-3,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
functx-fn-translate-4,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
functx-fn-translate-5,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
functx-fn-translate-6,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
functx-fn-translate-7,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
functx-fn-translate-all,Error: XPST0017: Function translate with arity of 3 not registered. No similar functions found.
functx-fn-year-from-date-1,Error: XPST0017: Function year-from-date with arity of 1 not registered. No similar functions found.
functx-fn-year-from-dateTime-1,Error: XPST0017: Function year-from-dateTime with arity of 1 not registered. No similar functions found.
functx-fn-years-from-duration-1,Error: XPST0017: Function years-from-duration with arity of 1 not registered. No similar functions found.
functx-fn-years-from-duration-2,Error: XPST0017: Function years-from-duration with arity of 1 not registered. No similar functions found.
functx-fn-years-from-duration-3,Error: XPST0017: Function years-from-duration with arity of 1 not registered. No similar functions found.
functx-fn-years-from-duration-4,Error: XPST0017: Function years-from-duration with arity of 1 not registered. No similar functions found.
functx-fn-years-from-duration-5,Error: XPST0017: Function years-from-duration with arity of 1 not registered. No similar functions found.
functx-fn-years-from-duration-all,Error: XPST0017: Function years-from-duration with arity of 1 not registered. No similar functions found.
functx-functx-add-attributes-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";             declare namespace new = "http://new";             (:~                 : Adds attributes to XML elements :                 : @author Priscilla Walmsley, Datypic                 : @version 1.0                 : @see http://www.xqueryfunctions.com/xq/functx_add-attributes.html                 : @param $elements the element(s) to which you wish to add the attribute                 : @param $attrNames the name(s) of the attribute(s) to add                 : @param $attrValues the value(s) of the attribute(s) to add :)             declare function functx:add-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? {                 for $element in $elements return element { node-name($element)} {                    for $attrName at $seq in $attrNames return                                          if ($element/@*[node-name(.) = $attrName]) then () else attribute {$attrName} {$attrValues[$seq]}, $element/@*, $element/node() }              } ;             let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml>              return (functx:add-attributes( $in-xml/a, xs:QName('att1'), 1))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-add-attributes-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";          (:~              : Adds attributes to XML elements :              : @author Priscilla Walmsley, Datypic              : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-attributes.html              : @param $elements the element(s) to which you wish to add the attribute              : @param $attrNames the name(s) of the attribute(s) to add              : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? {              for $element in $elements              return element { node-name($element)} {                 for $attrName at $seq in $attrNames                 return if ($element/@*[node-name(.) = $attrName]) then () else attribute {$attrName} {$attrValues[$seq]}, $element/@*, $element/node() }           } ;          let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml>           return (functx:add-attributes( $in-xml/a, (xs:QName('att1'),xs:QName('att2')), (1,2)))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-add-attributes-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";          (:~              : Adds attributes to XML elements :              : @author Priscilla Walmsley, Datypic              : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-attributes.html              : @param $elements the element(s) to which you wish to add the attribute              : @param $attrNames the name(s) of the attribute(s) to add              : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? {              for $element in $elements              return element { node-name($element)} {                 for $attrName at $seq in $attrNames                 return if ($element/@*[node-name(.) = $attrName]) then () else attribute {$attrName} {$attrValues[$seq]}, $element/@*, $element/node() }           } ;          let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml>           return (functx:add-attributes( $in-xml/b, (xs:QName('att1'),xs:QName('att2')), (1,2)))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-add-attributes-4,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? {              for $element in $elements return element { node-name($element)} {                 for $attrName at $seq in $attrNames                 return if ($element/@*[node-name(.) = $attrName]) then () else attribute {$attrName} {$attrValues[$seq]}, $element/@*, $element/node() }           } ;          let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml>           return (functx:add-attributes( $in-xml/a, xs:QName('new:att1'), 1))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-add-attributes-5,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? {              for $element in $elements              return element { node-name($element)} {                 for $attrName at $seq in $attrNames                 return if ($element/@*[node-name(.) = $attrName]) then () else attribute {$attrName} {$attrValues[$seq]}, $element/@*, $element/node() }              } ;          let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml>           return (functx:add-attributes( $in-xml/a, QName('http://new','new:att1'), 1))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-add-attributes-all,Error: XPST0003: Unable to parse XPath:           declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";          (:~              : Adds attributes to XML elements :              : @author Priscilla Walmsley, Datypic              : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-attributes.html              : @param $elements the element(s) to which you wish to add the attribute              : @param $attrNames the name(s) of the attribute(s) to add              : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? {              for $element in $elements              return element { node-name($element)} {                 for $attrName at $seq in $attrNames                 return if ($element/@*[node-name(.) = $attrName]) then () else attribute {$attrName} {$attrValues[$seq]}, $element/@*, $element/node() }           } ;          let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml>           return (functx:add-attributes( $in-xml/a, xs:QName('att1'), 1),                    functx:add-attributes( $in-xml/a, (xs:QName('att1'),xs:QName('att2')), (1,2)),                    functx:add-attributes( $in-xml/b, (xs:QName('att1'),xs:QName('att2')), (1,2)),                    functx:add-attributes( $in-xml/a, xs:QName('new:att1'), 1),                    functx:add-attributes( $in-xml/a, QName('http://new','new:att1'), 1))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-add-months-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Adds months to a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-months.html : @param $date the date : @param $months the number of months to add :)          declare function functx:add-months ( $date as xs:anyAtomicType? , $months as xs:integer ) as xs:date? { xs:date($date) + functx:yearMonthDuration(0,$months) } ;                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (:~ : Construct a yearMonthDuration from a number of years and months : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_yearmonthduration.html : @param $years the number of years : @param $months the number of months :)          declare function functx:yearMonthDuration ( $years as xs:decimal? , $months as xs:integer? ) as xs:yearMonthDuration { (xs:yearMonthDuration('P1M') * functx:if-empty($months,0)) + (xs:yearMonthDuration('P1Y') * functx:if-empty($years,0)) } ;                     (functx:add-months(xs:date('2004-01-23'),1)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-add-months-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Adds months to a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-months.html : @param $date the date : @param $months the number of months to add :)          declare function functx:add-months ( $date as xs:anyAtomicType? , $months as xs:integer ) as xs:date? { xs:date($date) + functx:yearMonthDuration(0,$months) } ;                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (:~ : Construct a yearMonthDuration from a number of years and months : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_yearmonthduration.html : @param $years the number of years : @param $months the number of months :)          declare function functx:yearMonthDuration ( $years as xs:decimal? , $months as xs:integer? ) as xs:yearMonthDuration { (xs:yearMonthDuration('P1M') * functx:if-empty($months,0)) + (xs:yearMonthDuration('P1Y') * functx:if-empty($years,0)) } ;                     (functx:add-months( xs:dateTime('2005-12-31T12:00:13'),2)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-add-months-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Adds months to a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-months.html : @param $date the date : @param $months the number of months to add :)          declare function functx:add-months ( $date as xs:anyAtomicType? , $months as xs:integer ) as xs:date? { xs:date($date) + functx:yearMonthDuration(0,$months) } ;                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (:~ : Construct a yearMonthDuration from a number of years and months : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_yearmonthduration.html : @param $years the number of years : @param $months the number of months :)          declare function functx:yearMonthDuration ( $years as xs:decimal? , $months as xs:integer? ) as xs:yearMonthDuration { (xs:yearMonthDuration('P1M') * functx:if-empty($months,0)) + (xs:yearMonthDuration('P1Y') * functx:if-empty($years,0)) } ;                     (functx:add-months('2005-12-31',-3)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-add-months-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Adds months to a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-months.html : @param $date the date : @param $months the number of months to add :)          declare function functx:add-months ( $date as xs:anyAtomicType? , $months as xs:integer ) as xs:date? { xs:date($date) + functx:yearMonthDuration(0,$months) } ;                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (:~ : Construct a yearMonthDuration from a number of years and months : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_yearmonthduration.html : @param $years the number of years : @param $months the number of months :)          declare function functx:yearMonthDuration ( $years as xs:decimal? , $months as xs:integer? ) as xs:yearMonthDuration { (xs:yearMonthDuration('P1M') * functx:if-empty($months,0)) + (xs:yearMonthDuration('P1Y') * functx:if-empty($years,0)) } ;                     (functx:add-months(xs:date('2004-01-23'),1), functx:add-months( xs:dateTime('2005-12-31T12:00:13'),2), functx:add-months('2005-12-31',-3)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-add-or-update-attributes-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-or-update-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-or-update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return attribute {$attrName} {$attrValues[$seq]}, $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml> return (functx:add-or-update-attributes( $in-xml/a, xs:QName('att1'), 1)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-add-or-update-attributes-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-or-update-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-or-update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return attribute {$attrName} {$attrValues[$seq]}, $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml> return (functx:add-or-update-attributes( $in-xml/a, (xs:QName('att1'),xs:QName('att2')), (1,2))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-add-or-update-attributes-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-or-update-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-or-update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return attribute {$attrName} {$attrValues[$seq]}, $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml> return (functx:add-or-update-attributes( $in-xml/b, (xs:QName('att1'),xs:QName('att2')), (1,2))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-add-or-update-attributes-4,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-or-update-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-or-update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return attribute {$attrName} {$attrValues[$seq]}, $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml> return (functx:add-or-update-attributes( $in-xml/a, xs:QName('new:att1'), 1)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-add-or-update-attributes-5,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-or-update-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-or-update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return attribute {$attrName} {$attrValues[$seq]}, $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml> return (functx:add-or-update-attributes( $in-xml/a, QName('http://new','new:att1'), 1)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-add-or-update-attributes-all,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-or-update-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-or-update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return attribute {$attrName} {$attrValues[$seq]}, $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml> return (functx:add-or-update-attributes( $in-xml/a, xs:QName('att1'), 1), functx:add-or-update-attributes( $in-xml/a, (xs:QName('att1'),xs:QName('att2')), (1,2)), functx:add-or-update-attributes( $in-xml/b, (xs:QName('att1'),xs:QName('att2')), (1,2)), functx:add-or-update-attributes( $in-xml/a, xs:QName('new:att1'), 1), functx:add-or-update-attributes( $in-xml/a, QName('http://new','new:att1'), 1)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-all-whitespace-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is all whitespace or a zero-length string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_all-whitespace.html : @param $arg the string (or node) to test :)          declare function functx:all-whitespace ( $arg as xs:string? ) as xs:boolean { normalize-space($arg) = '' } ;                     let $in-xml := <in-xml> <a> </a> <b>x </b> <c> <x>x</x> </c> </in-xml> return (functx:all-whitespace(' ')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-all-whitespace-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is all whitespace or a zero-length string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_all-whitespace.html : @param $arg the string (or node) to test :)          declare function functx:all-whitespace ( $arg as xs:string? ) as xs:boolean { normalize-space($arg) = '' } ;                     let $in-xml := <in-xml> <a> </a> <b>x </b> <c> <x>x</x> </c> </in-xml> return (functx:all-whitespace(' x ')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-all-whitespace-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is all whitespace or a zero-length string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_all-whitespace.html : @param $arg the string (or node) to test :)          declare function functx:all-whitespace ( $arg as xs:string? ) as xs:boolean { normalize-space($arg) = '' } ;                     let $in-xml := <in-xml> <a> </a> <b>x </b> <c> <x>x</x> </c> </in-xml> return (functx:all-whitespace($in-xml/a)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-all-whitespace-4,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is all whitespace or a zero-length string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_all-whitespace.html : @param $arg the string (or node) to test :)          declare function functx:all-whitespace ( $arg as xs:string? ) as xs:boolean { normalize-space($arg) = '' } ;                     let $in-xml := <in-xml> <a> </a> <b>x </b> <c> <x>x</x> </c> </in-xml> return (functx:all-whitespace($in-xml/b)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-all-whitespace-5,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is all whitespace or a zero-length string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_all-whitespace.html : @param $arg the string (or node) to test :)          declare function functx:all-whitespace ( $arg as xs:string? ) as xs:boolean { normalize-space($arg) = '' } ;                     let $in-xml := <in-xml> <a> </a> <b>x </b> <c> <x>x</x> </c> </in-xml> return (functx:all-whitespace($in-xml/c)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-all-whitespace-6,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is all whitespace or a zero-length string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_all-whitespace.html : @param $arg the string (or node) to test :)          declare function functx:all-whitespace ( $arg as xs:string? ) as xs:boolean { normalize-space($arg) = '' } ;                     let $in-xml := <in-xml> <a> </a> <b>x </b> <c> <x>x</x> </c> </in-xml> return (functx:all-whitespace($in-xml/c/text()[1])). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-all-whitespace-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is all whitespace or a zero-length string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_all-whitespace.html : @param $arg the string (or node) to test :)          declare function functx:all-whitespace ( $arg as xs:string? ) as xs:boolean { normalize-space($arg) = '' } ;                     let $in-xml := <in-xml> <a> </a> <b>x </b> <c> <x>x</x> </c> </in-xml> return (functx:all-whitespace(' '), functx:all-whitespace(' x '), functx:all-whitespace($in-xml/a), functx:all-whitespace($in-xml/b), functx:all-whitespace($in-xml/c), functx:all-whitespace($in-xml/c/text()[1])))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-are-distinct-values-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether all the values in a sequence are distinct : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_are-distinct-values.html : @param $seq the sequence of values :)          declare function functx:are-distinct-values ( $seq as xs:anyAtomicType* ) as xs:boolean { count(distinct-values($seq)) = count($seq) } ;                     (functx:are-distinct-values( (1,2,1,3))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-are-distinct-values-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether all the values in a sequence are distinct : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_are-distinct-values.html : @param $seq the sequence of values :)          declare function functx:are-distinct-values ( $seq as xs:anyAtomicType* ) as xs:boolean { count(distinct-values($seq)) = count($seq) } ;                     (functx:are-distinct-values( (1,2,1,3,2.0))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-are-distinct-values-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether all the values in a sequence are distinct : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_are-distinct-values.html : @param $seq the sequence of values :)          declare function functx:are-distinct-values ( $seq as xs:anyAtomicType* ) as xs:boolean { count(distinct-values($seq)) = count($seq) } ;                     (functx:are-distinct-values( (1,2,3) )). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-are-distinct-values-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Whether all the values in a sequence are distinct : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_are-distinct-values.html : @param $seq the sequence of values :)          declare function functx:are-distinct-values ( $seq as xs:anyAtomicType* ) as xs:boolean { count(distinct-values($seq)) = count($seq) } ;                     (functx:are-distinct-values( (1,2,1,3)), functx:are-distinct-values( (1,2,1,3,2.0)), functx:are-distinct-values( (1,2,3) )))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-atomic-type-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The built-in type of an atomic value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_atomic-type.html : @param $values the value(s) whose type you want to determine :)          declare function functx:atomic-type ( $values as xs:anyAtomicType* ) as xs:string* { for $val in $values return (if ($val instance of xs:untypedAtomic) then 'xs:untypedAtomic' else if ($val instance of xs:anyURI) then 'xs:anyURI' else if ($val instance of xs:ENTITY) then 'xs:ENTITY' else if ($val instance of xs:ID) then 'xs:ID' else if ($val instance of xs:NMTOKEN) then 'xs:NMTOKEN' else if ($val instance of xs:language) then 'xs:language' else if ($val instance of xs:NCName) then 'xs:NCName' else if ($val instance of xs:Name) then 'xs:Name' else if ($val instance of xs:token) then 'xs:token' else if ($val instance of xs:normalizedString) then 'xs:normalizedString' else if ($val instance of xs:string) then 'xs:string' else if ($val instance of xs:QName) then 'xs:QName' else if ($val instance of xs:boolean) then 'xs:boolean' else if ($val instance of xs:base64Binary) then 'xs:base64Binary' else if ($val instance of xs:hexBinary) then 'xs:hexBinary' else if ($val instance of xs:byte) then 'xs:byte' else if ($val instance of xs:short) then 'xs:short' else if ($val instance of xs:int) then 'xs:int' else if ($val instance of xs:long) then 'xs:long' else if ($val instance of xs:unsignedByte) then 'xs:unsignedByte' else if ($val instance of xs:unsignedShort) then 'xs:unsignedShort' else if ($val instance of xs:unsignedInt) then 'xs:unsignedInt' else if ($val instance of xs:unsignedLong) then 'xs:unsignedLong' else if ($val instance of xs:positiveInteger) then 'xs:positiveInteger' else if ($val instance of xs:nonNegativeInteger) then 'xs:nonNegativeInteger' else if ($val instance of xs:negativeInteger) then 'xs:negativeInteger' else if ($val instance of xs:nonPositiveInteger) then 'xs:nonPositiveInteger' else if ($val instance of xs:integer) then 'xs:integer' else if ($val instance of xs:decimal) then 'xs:decimal' else if ($val instance of xs:float) then 'xs:float' else if ($val instance of xs:double) then 'xs:double' else if ($val instance of xs:date) then 'xs:date' else if ($val instance of xs:time) then 'xs:time' else if ($val instance of xs:dateTime) then 'xs:dateTime' else if ($val instance of xs:dayTimeDuration) then 'xs:dayTimeDuration' else if ($val instance of xs:yearMonthDuration) then 'xs:yearMonthDuration' else if ($val instance of xs:duration) then 'xs:duration' else if ($val instance of xs:gMonth) then 'xs:gMonth' else if ($val instance of xs:gYear) then 'xs:gYear' else if ($val instance of xs:gYearMonth) then 'xs:gYearMonth' else if ($val instance of xs:gDay) then 'xs:gDay' else if ($val instance of xs:gMonthDay) then 'xs:gMonthDay' else 'unknown') } ;                     (functx:atomic-type(2)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-atomic-type-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The built-in type of an atomic value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_atomic-type.html : @param $values the value(s) whose type you want to determine :)          declare function functx:atomic-type ( $values as xs:anyAtomicType* ) as xs:string* { for $val in $values return (if ($val instance of xs:untypedAtomic) then 'xs:untypedAtomic' else if ($val instance of xs:anyURI) then 'xs:anyURI' else if ($val instance of xs:ENTITY) then 'xs:ENTITY' else if ($val instance of xs:ID) then 'xs:ID' else if ($val instance of xs:NMTOKEN) then 'xs:NMTOKEN' else if ($val instance of xs:language) then 'xs:language' else if ($val instance of xs:NCName) then 'xs:NCName' else if ($val instance of xs:Name) then 'xs:Name' else if ($val instance of xs:token) then 'xs:token' else if ($val instance of xs:normalizedString) then 'xs:normalizedString' else if ($val instance of xs:string) then 'xs:string' else if ($val instance of xs:QName) then 'xs:QName' else if ($val instance of xs:boolean) then 'xs:boolean' else if ($val instance of xs:base64Binary) then 'xs:base64Binary' else if ($val instance of xs:hexBinary) then 'xs:hexBinary' else if ($val instance of xs:byte) then 'xs:byte' else if ($val instance of xs:short) then 'xs:short' else if ($val instance of xs:int) then 'xs:int' else if ($val instance of xs:long) then 'xs:long' else if ($val instance of xs:unsignedByte) then 'xs:unsignedByte' else if ($val instance of xs:unsignedShort) then 'xs:unsignedShort' else if ($val instance of xs:unsignedInt) then 'xs:unsignedInt' else if ($val instance of xs:unsignedLong) then 'xs:unsignedLong' else if ($val instance of xs:positiveInteger) then 'xs:positiveInteger' else if ($val instance of xs:nonNegativeInteger) then 'xs:nonNegativeInteger' else if ($val instance of xs:negativeInteger) then 'xs:negativeInteger' else if ($val instance of xs:nonPositiveInteger) then 'xs:nonPositiveInteger' else if ($val instance of xs:integer) then 'xs:integer' else if ($val instance of xs:decimal) then 'xs:decimal' else if ($val instance of xs:float) then 'xs:float' else if ($val instance of xs:double) then 'xs:double' else if ($val instance of xs:date) then 'xs:date' else if ($val instance of xs:time) then 'xs:time' else if ($val instance of xs:dateTime) then 'xs:dateTime' else if ($val instance of xs:dayTimeDuration) then 'xs:dayTimeDuration' else if ($val instance of xs:yearMonthDuration) then 'xs:yearMonthDuration' else if ($val instance of xs:duration) then 'xs:duration' else if ($val instance of xs:gMonth) then 'xs:gMonth' else if ($val instance of xs:gYear) then 'xs:gYear' else if ($val instance of xs:gYearMonth) then 'xs:gYearMonth' else if ($val instance of xs:gDay) then 'xs:gDay' else if ($val instance of xs:gMonthDay) then 'xs:gMonthDay' else 'unknown') } ;                     (functx:atomic-type('abc')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-atomic-type-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The built-in type of an atomic value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_atomic-type.html : @param $values the value(s) whose type you want to determine :)          declare function functx:atomic-type ( $values as xs:anyAtomicType* ) as xs:string* { for $val in $values return (if ($val instance of xs:untypedAtomic) then 'xs:untypedAtomic' else if ($val instance of xs:anyURI) then 'xs:anyURI' else if ($val instance of xs:ENTITY) then 'xs:ENTITY' else if ($val instance of xs:ID) then 'xs:ID' else if ($val instance of xs:NMTOKEN) then 'xs:NMTOKEN' else if ($val instance of xs:language) then 'xs:language' else if ($val instance of xs:NCName) then 'xs:NCName' else if ($val instance of xs:Name) then 'xs:Name' else if ($val instance of xs:token) then 'xs:token' else if ($val instance of xs:normalizedString) then 'xs:normalizedString' else if ($val instance of xs:string) then 'xs:string' else if ($val instance of xs:QName) then 'xs:QName' else if ($val instance of xs:boolean) then 'xs:boolean' else if ($val instance of xs:base64Binary) then 'xs:base64Binary' else if ($val instance of xs:hexBinary) then 'xs:hexBinary' else if ($val instance of xs:byte) then 'xs:byte' else if ($val instance of xs:short) then 'xs:short' else if ($val instance of xs:int) then 'xs:int' else if ($val instance of xs:long) then 'xs:long' else if ($val instance of xs:unsignedByte) then 'xs:unsignedByte' else if ($val instance of xs:unsignedShort) then 'xs:unsignedShort' else if ($val instance of xs:unsignedInt) then 'xs:unsignedInt' else if ($val instance of xs:unsignedLong) then 'xs:unsignedLong' else if ($val instance of xs:positiveInteger) then 'xs:positiveInteger' else if ($val instance of xs:nonNegativeInteger) then 'xs:nonNegativeInteger' else if ($val instance of xs:negativeInteger) then 'xs:negativeInteger' else if ($val instance of xs:nonPositiveInteger) then 'xs:nonPositiveInteger' else if ($val instance of xs:integer) then 'xs:integer' else if ($val instance of xs:decimal) then 'xs:decimal' else if ($val instance of xs:float) then 'xs:float' else if ($val instance of xs:double) then 'xs:double' else if ($val instance of xs:date) then 'xs:date' else if ($val instance of xs:time) then 'xs:time' else if ($val instance of xs:dateTime) then 'xs:dateTime' else if ($val instance of xs:dayTimeDuration) then 'xs:dayTimeDuration' else if ($val instance of xs:yearMonthDuration) then 'xs:yearMonthDuration' else if ($val instance of xs:duration) then 'xs:duration' else if ($val instance of xs:gMonth) then 'xs:gMonth' else if ($val instance of xs:gYear) then 'xs:gYear' else if ($val instance of xs:gYearMonth) then 'xs:gYearMonth' else if ($val instance of xs:gDay) then 'xs:gDay' else if ($val instance of xs:gMonthDay) then 'xs:gMonthDay' else 'unknown') } ;                     (functx:atomic-type(xs:date('2005-12-15'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-atomic-type-4,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The built-in type of an atomic value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_atomic-type.html : @param $values the value(s) whose type you want to determine :)          declare function functx:atomic-type ( $values as xs:anyAtomicType* ) as xs:string* { for $val in $values return (if ($val instance of xs:untypedAtomic) then 'xs:untypedAtomic' else if ($val instance of xs:anyURI) then 'xs:anyURI' else if ($val instance of xs:ENTITY) then 'xs:ENTITY' else if ($val instance of xs:ID) then 'xs:ID' else if ($val instance of xs:NMTOKEN) then 'xs:NMTOKEN' else if ($val instance of xs:language) then 'xs:language' else if ($val instance of xs:NCName) then 'xs:NCName' else if ($val instance of xs:Name) then 'xs:Name' else if ($val instance of xs:token) then 'xs:token' else if ($val instance of xs:normalizedString) then 'xs:normalizedString' else if ($val instance of xs:string) then 'xs:string' else if ($val instance of xs:QName) then 'xs:QName' else if ($val instance of xs:boolean) then 'xs:boolean' else if ($val instance of xs:base64Binary) then 'xs:base64Binary' else if ($val instance of xs:hexBinary) then 'xs:hexBinary' else if ($val instance of xs:byte) then 'xs:byte' else if ($val instance of xs:short) then 'xs:short' else if ($val instance of xs:int) then 'xs:int' else if ($val instance of xs:long) then 'xs:long' else if ($val instance of xs:unsignedByte) then 'xs:unsignedByte' else if ($val instance of xs:unsignedShort) then 'xs:unsignedShort' else if ($val instance of xs:unsignedInt) then 'xs:unsignedInt' else if ($val instance of xs:unsignedLong) then 'xs:unsignedLong' else if ($val instance of xs:positiveInteger) then 'xs:positiveInteger' else if ($val instance of xs:nonNegativeInteger) then 'xs:nonNegativeInteger' else if ($val instance of xs:negativeInteger) then 'xs:negativeInteger' else if ($val instance of xs:nonPositiveInteger) then 'xs:nonPositiveInteger' else if ($val instance of xs:integer) then 'xs:integer' else if ($val instance of xs:decimal) then 'xs:decimal' else if ($val instance of xs:float) then 'xs:float' else if ($val instance of xs:double) then 'xs:double' else if ($val instance of xs:date) then 'xs:date' else if ($val instance of xs:time) then 'xs:time' else if ($val instance of xs:dateTime) then 'xs:dateTime' else if ($val instance of xs:dayTimeDuration) then 'xs:dayTimeDuration' else if ($val instance of xs:yearMonthDuration) then 'xs:yearMonthDuration' else if ($val instance of xs:duration) then 'xs:duration' else if ($val instance of xs:gMonth) then 'xs:gMonth' else if ($val instance of xs:gYear) then 'xs:gYear' else if ($val instance of xs:gYearMonth) then 'xs:gYearMonth' else if ($val instance of xs:gDay) then 'xs:gDay' else if ($val instance of xs:gMonthDay) then 'xs:gMonthDay' else 'unknown') } ;                     (functx:atomic-type( (2,'abc',xs:date('2005-12-15')))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-atomic-type-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The built-in type of an atomic value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_atomic-type.html : @param $values the value(s) whose type you want to determine :)          declare function functx:atomic-type ( $values as xs:anyAtomicType* ) as xs:string* { for $val in $values return (if ($val instance of xs:untypedAtomic) then 'xs:untypedAtomic' else if ($val instance of xs:anyURI) then 'xs:anyURI' else if ($val instance of xs:ENTITY) then 'xs:ENTITY' else if ($val instance of xs:ID) then 'xs:ID' else if ($val instance of xs:NMTOKEN) then 'xs:NMTOKEN' else if ($val instance of xs:language) then 'xs:language' else if ($val instance of xs:NCName) then 'xs:NCName' else if ($val instance of xs:Name) then 'xs:Name' else if ($val instance of xs:token) then 'xs:token' else if ($val instance of xs:normalizedString) then 'xs:normalizedString' else if ($val instance of xs:string) then 'xs:string' else if ($val instance of xs:QName) then 'xs:QName' else if ($val instance of xs:boolean) then 'xs:boolean' else if ($val instance of xs:base64Binary) then 'xs:base64Binary' else if ($val instance of xs:hexBinary) then 'xs:hexBinary' else if ($val instance of xs:byte) then 'xs:byte' else if ($val instance of xs:short) then 'xs:short' else if ($val instance of xs:int) then 'xs:int' else if ($val instance of xs:long) then 'xs:long' else if ($val instance of xs:unsignedByte) then 'xs:unsignedByte' else if ($val instance of xs:unsignedShort) then 'xs:unsignedShort' else if ($val instance of xs:unsignedInt) then 'xs:unsignedInt' else if ($val instance of xs:unsignedLong) then 'xs:unsignedLong' else if ($val instance of xs:positiveInteger) then 'xs:positiveInteger' else if ($val instance of xs:nonNegativeInteger) then 'xs:nonNegativeInteger' else if ($val instance of xs:negativeInteger) then 'xs:negativeInteger' else if ($val instance of xs:nonPositiveInteger) then 'xs:nonPositiveInteger' else if ($val instance of xs:integer) then 'xs:integer' else if ($val instance of xs:decimal) then 'xs:decimal' else if ($val instance of xs:float) then 'xs:float' else if ($val instance of xs:double) then 'xs:double' else if ($val instance of xs:date) then 'xs:date' else if ($val instance of xs:time) then 'xs:time' else if ($val instance of xs:dateTime) then 'xs:dateTime' else if ($val instance of xs:dayTimeDuration) then 'xs:dayTimeDuration' else if ($val instance of xs:yearMonthDuration) then 'xs:yearMonthDuration' else if ($val instance of xs:duration) then 'xs:duration' else if ($val instance of xs:gMonth) then 'xs:gMonth' else if ($val instance of xs:gYear) then 'xs:gYear' else if ($val instance of xs:gYearMonth) then 'xs:gYearMonth' else if ($val instance of xs:gDay) then 'xs:gDay' else if ($val instance of xs:gMonthDay) then 'xs:gMonthDay' else 'unknown') } ;                     (functx:atomic-type(2), functx:atomic-type('abc'), functx:atomic-type(xs:date('2005-12-15')), functx:atomic-type( (2,'abc',xs:date('2005-12-15')))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-avg-empty-is-zero-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The average, counting "empty" values as zero : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_avg-empty-is-zero.html : @param $values the values to be averaged : @param $allNodes the sequence of all nodes to find the average over :)          declare function functx:avg-empty-is-zero ( $values as xs:anyAtomicType* , $allNodes as node()* ) as xs:double { if (empty($allNodes)) then 0 else sum($values[string(.) != '']) div count($allNodes) } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="69.99"/> <price value="49.99" discount=""/> </prices> return (functx:avg-empty-is-zero( $in-xml//price/@discount, $in-xml//price))) = (4). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-between-exclusive-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-exclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-exclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value > $minValue and $value < $maxValue } ;                     (functx:between-exclusive(55, 1, 1000)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-between-exclusive-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-exclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-exclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value > $minValue and $value < $maxValue } ;                     (functx:between-exclusive(1, 1, 1000)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-between-exclusive-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-exclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-exclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value > $minValue and $value < $maxValue } ;                     (functx:between-exclusive(1200, 1, 1000)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-between-exclusive-4,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-exclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-exclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value > $minValue and $value < $maxValue } ;                     (functx:between-exclusive('b', 'a', 'c')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-between-exclusive-5,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-exclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-exclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value > $minValue and $value < $maxValue } ;                     (functx:between-exclusive(xs:date('2004-10-31'), xs:date('2004-10-15'), xs:date('2004-11-01'))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-between-exclusive-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-exclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-exclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value > $minValue and $value < $maxValue } ;                     (functx:between-exclusive(55, 1, 1000), functx:between-exclusive(1, 1, 1000), functx:between-exclusive(1200, 1, 1000), functx:between-exclusive('b', 'a', 'c'), functx:between-exclusive(xs:date('2004-10-31'), xs:date('2004-10-15'), xs:date('2004-11-01'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-between-inclusive-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values, or equal to one of them : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-inclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-inclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value >= $minValue and $value <= $maxValue } ;                     (functx:between-inclusive(55, 1, 1000)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-between-inclusive-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values, or equal to one of them : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-inclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-inclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value >= $minValue and $value <= $maxValue } ;                     (functx:between-inclusive(1, 1, 1000)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-between-inclusive-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values, or equal to one of them : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-inclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-inclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value >= $minValue and $value <= $maxValue } ;                     (functx:between-inclusive(1200, 1, 1000)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-between-inclusive-4,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values, or equal to one of them : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-inclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-inclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value >= $minValue and $value <= $maxValue } ;                     (functx:between-inclusive('b', 'b', 'd')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-between-inclusive-5,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values, or equal to one of them : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-inclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-inclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value >= $minValue and $value <= $maxValue } ;                     (functx:between-inclusive(xs:date('2004-10-31'), xs:date('2004-10-15'), xs:date('2004-11-01'))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-between-inclusive-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values, or equal to one of them : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-inclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-inclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value >= $minValue and $value <= $maxValue } ;                     (functx:between-inclusive(55, 1, 1000), functx:between-inclusive(1, 1, 1000), functx:between-inclusive(1200, 1, 1000), functx:between-inclusive('b', 'b', 'd'), functx:between-inclusive(xs:date('2004-10-31'), xs:date('2004-10-15'), xs:date('2004-11-01'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-camel-case-to-words-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Turns a camelCase string into space-separated words : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_camel-case-to-words.html : @param $arg the string to modify : @param $delim the delimiter for the words (e.g. a space) :)          declare function functx:camel-case-to-words ( $arg as xs:string? , $delim as xs:string ) as xs:string { concat(substring($arg,1,1), replace(substring($arg,2),'(\p{Lu})', concat($delim, '$1'))) } ;                     (functx:camel-case-to-words( 'thisIsACamelCaseTerm',' ')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-camel-case-to-words-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Turns a camelCase string into space-separated words : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_camel-case-to-words.html : @param $arg the string to modify : @param $delim the delimiter for the words (e.g. a space) :)          declare function functx:camel-case-to-words ( $arg as xs:string? , $delim as xs:string ) as xs:string { concat(substring($arg,1,1), replace(substring($arg,2),'(\p{Lu})', concat($delim, '$1'))) } ;                     (functx:camel-case-to-words( 'thisIsACamelCaseTerm',',')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-camel-case-to-words-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Turns a camelCase string into space-separated words : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_camel-case-to-words.html : @param $arg the string to modify : @param $delim the delimiter for the words (e.g. a space) :)          declare function functx:camel-case-to-words ( $arg as xs:string? , $delim as xs:string ) as xs:string { concat(substring($arg,1,1), replace(substring($arg,2),'(\p{Lu})', concat($delim, '$1'))) } ;                     (functx:camel-case-to-words( 'thisIsACamelCaseTerm',' '), functx:camel-case-to-words( 'thisIsACamelCaseTerm',',')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-capitalize-first-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Capitalizes the first character of a string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_capitalize-first.html : @param $arg the word or phrase to capitalize :)          declare function functx:capitalize-first ( $arg as xs:string? ) as xs:string? { concat(upper-case(substring($arg,1,1)), substring($arg,2)) } ;                     (functx:capitalize-first('hello')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-capitalize-first-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Capitalizes the first character of a string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_capitalize-first.html : @param $arg the word or phrase to capitalize :)          declare function functx:capitalize-first ( $arg as xs:string? ) as xs:string? { concat(upper-case(substring($arg,1,1)), substring($arg,2)) } ;                     (functx:capitalize-first('hello world')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-capitalize-first-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Capitalizes the first character of a string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_capitalize-first.html : @param $arg the word or phrase to capitalize :)          declare function functx:capitalize-first ( $arg as xs:string? ) as xs:string? { concat(upper-case(substring($arg,1,1)), substring($arg,2)) } ;                     (functx:capitalize-first('Hello world')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-capitalize-first-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Capitalizes the first character of a string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_capitalize-first.html : @param $arg the word or phrase to capitalize :)          declare function functx:capitalize-first ( $arg as xs:string? ) as xs:string? { concat(upper-case(substring($arg,1,1)), substring($arg,2)) } ;                     (functx:capitalize-first('hello'), functx:capitalize-first('hello world'), functx:capitalize-first('Hello world')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-change-element-names-deep-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";          declare namespace dty = "http://datypic.com";                     (:~ : Changes the names of elements in an XML fragment : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-names-deep.html : @param $nodes the element(s) to change : @param $oldNames the sequence of names to change from : @param $newNames the sequence of names to change to :)          declare function functx:change-element-names-deep ( $nodes as node()* , $oldNames as xs:QName* , $newNames as xs:QName* ) as node()* { if (count($oldNames) != count($newNames)) then error(xs:QName('functx:Different_number_of_names')) else for $node in $nodes return if ($node instance of element()) then element {functx:if-empty ($newNames[index-of($oldNames, node-name($node))], node-name($node)) } {$node/@*, functx:change-element-names-deep($node/node(), $oldNames, $newNames)} else if ($node instance of document-node()) then functx:change-element-names-deep($node/node(), $oldNames, $newNames) else $node } ;                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     let $in-xml-1 := <in-xml> <a> <b>b</b> <c>c</c> </a> </in-xml> return let $in-xml-2 := <in-xml xmlns:dty="http://datypic.com"> <a> <dty:b>b</dty:b> <c>c</c> </a> </in-xml> return (functx:change-element-names-deep( $in-xml-1, xs:QName('b'), xs:QName('y'))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-change-element-names-deep-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";          declare namespace dty = "http://datypic.com";                     (:~ : Changes the names of elements in an XML fragment : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-names-deep.html : @param $nodes the element(s) to change : @param $oldNames the sequence of names to change from : @param $newNames the sequence of names to change to :)          declare function functx:change-element-names-deep ( $nodes as node()* , $oldNames as xs:QName* , $newNames as xs:QName* ) as node()* { if (count($oldNames) != count($newNames)) then error(xs:QName('functx:Different_number_of_names')) else for $node in $nodes return if ($node instance of element()) then element {functx:if-empty ($newNames[index-of($oldNames, node-name($node))], node-name($node)) } {$node/@*, functx:change-element-names-deep($node/node(), $oldNames, $newNames)} else if ($node instance of document-node()) then functx:change-element-names-deep($node/node(), $oldNames, $newNames) else $node } ;                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     let $in-xml-1 := <in-xml> <a> <b>b</b> <c>c</c> </a> </in-xml> return let $in-xml-2 := <in-xml xmlns:dty="http://datypic.com"> <a> <dty:b>b</dty:b> <c>c</c> </a> </in-xml> return (functx:change-element-names-deep( $in-xml-1, (xs:QName('a'), xs:QName('b'),xs:QName('c')), (xs:QName('x'), xs:QName('y'),xs:QName('z')))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-change-element-names-deep-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";          declare namespace dty = "http://datypic.com";                     (:~ : Changes the names of elements in an XML fragment : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-names-deep.html : @param $nodes the element(s) to change : @param $oldNames the sequence of names to change from : @param $newNames the sequence of names to change to :)          declare function functx:change-element-names-deep ( $nodes as node()* , $oldNames as xs:QName* , $newNames as xs:QName* ) as node()* { if (count($oldNames) != count($newNames)) then error(xs:QName('functx:Different_number_of_names')) else for $node in $nodes return if ($node instance of element()) then element {functx:if-empty ($newNames[index-of($oldNames, node-name($node))], node-name($node)) } {$node/@*, functx:change-element-names-deep($node/node(), $oldNames, $newNames)} else if ($node instance of document-node()) then functx:change-element-names-deep($node/node(), $oldNames, $newNames) else $node } ;                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     let $in-xml-1 := <in-xml> <a> <b>b</b> <c>c</c> </a> </in-xml> return let $in-xml-2 := <in-xml xmlns:dty="http://datypic.com"> <a> <dty:b>b</dty:b> <c>c</c> </a> </in-xml> return (functx:change-element-names-deep( $in-xml-2, (xs:QName('dty:b'),xs:QName('c')), (xs:QName('q'), QName('http://new','new:c')))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-change-element-names-deep-all,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";          declare namespace dty = "http://datypic.com";                     (:~ : Changes the names of elements in an XML fragment : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-names-deep.html : @param $nodes the element(s) to change : @param $oldNames the sequence of names to change from : @param $newNames the sequence of names to change to :)          declare function functx:change-element-names-deep ( $nodes as node()* , $oldNames as xs:QName* , $newNames as xs:QName* ) as node()* { if (count($oldNames) != count($newNames)) then error(xs:QName('functx:Different_number_of_names')) else for $node in $nodes return if ($node instance of element()) then element {functx:if-empty ($newNames[index-of($oldNames, node-name($node))], node-name($node)) } {$node/@*, functx:change-element-names-deep($node/node(), $oldNames, $newNames)} else if ($node instance of document-node()) then functx:change-element-names-deep($node/node(), $oldNames, $newNames) else $node } ;                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     let $in-xml-1 := <in-xml> <a> <b>b</b> <c>c</c> </a> </in-xml> return let $in-xml-2 := <in-xml xmlns:dty="http://datypic.com"> <a> <dty:b>b</dty:b> <c>c</c> </a> </in-xml> return (functx:change-element-names-deep( $in-xml-1, xs:QName('b'), xs:QName('y')), functx:change-element-names-deep( $in-xml-1, (xs:QName('a'), xs:QName('b'),xs:QName('c')), (xs:QName('x'), xs:QName('y'),xs:QName('z'))), functx:change-element-names-deep( $in-xml-2, (xs:QName('dty:b'),xs:QName('c')), (xs:QName('q'), QName('http://new','new:c')))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-change-element-ns-deep-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Changes the namespace of XML elements and its descendants : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-ns-deep.html : @param $nodes the nodes to change : @param $newns the new namespace : @param $prefix the prefix to use for the new namespace :)          declare function functx:change-element-ns-deep ( $nodes as node()* , $newns as xs:string , $prefix as xs:string ) as node()* { for $node in $nodes return if ($node instance of element()) then (element {QName ($newns, concat($prefix, if ($prefix = '') then '' else ':', local-name($node)))} {$node/@*, functx:change-element-ns-deep($node/node(), $newns, $prefix)}) else if ($node instance of document-node()) then functx:change-element-ns-deep($node/node(), $newns, $prefix) else $node } ;                     let $in-xml := <bar:a xmlns:bar="http://bar"> <bar:b>557</bar:b> <bar:c>xyz</bar:c> </bar:a> return (functx:change-element-ns-deep( $in-xml, 'http://foo','')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-change-element-ns-deep-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Changes the namespace of XML elements and its descendants : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-ns-deep.html : @param $nodes the nodes to change : @param $newns the new namespace : @param $prefix the prefix to use for the new namespace :)          declare function functx:change-element-ns-deep ( $nodes as node()* , $newns as xs:string , $prefix as xs:string ) as node()* { for $node in $nodes return if ($node instance of element()) then (element {QName ($newns, concat($prefix, if ($prefix = '') then '' else ':', local-name($node)))} {$node/@*, functx:change-element-ns-deep($node/node(), $newns, $prefix)}) else if ($node instance of document-node()) then functx:change-element-ns-deep($node/node(), $newns, $prefix) else $node } ;                     let $in-xml := <bar:a xmlns:bar="http://bar"> <bar:b>557</bar:b> <bar:c>xyz</bar:c> </bar:a> return (functx:change-element-ns-deep( $in-xml, 'http://foo','foo')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-change-element-ns-deep-all,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Changes the namespace of XML elements and its descendants : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-ns-deep.html : @param $nodes the nodes to change : @param $newns the new namespace : @param $prefix the prefix to use for the new namespace :)          declare function functx:change-element-ns-deep ( $nodes as node()* , $newns as xs:string , $prefix as xs:string ) as node()* { for $node in $nodes return if ($node instance of element()) then (element {QName ($newns, concat($prefix, if ($prefix = '') then '' else ':', local-name($node)))} {$node/@*, functx:change-element-ns-deep($node/node(), $newns, $prefix)}) else if ($node instance of document-node()) then functx:change-element-ns-deep($node/node(), $newns, $prefix) else $node } ;                     let $in-xml := <bar:a xmlns:bar="http://bar"> <bar:b>557</bar:b> <bar:c>xyz</bar:c> </bar:a> return (functx:change-element-ns-deep( $in-xml, 'http://foo',''), functx:change-element-ns-deep( $in-xml, 'http://foo','foo')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-change-element-ns-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Changes the namespace of XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-ns.html : @param $elements the elements to change : @param $newns the new namespace : @param $prefix the prefix to use for the new namespace :)          declare function functx:change-element-ns ( $elements as element()* , $newns as xs:string , $prefix as xs:string ) as element()? { for $element in $elements return element {QName ($newns, concat($prefix, if ($prefix = '') then '' else ':', local-name($element)))} {$element/@*, $element/node()} } ;                     let $in-xml := <bar:a xmlns:bar="http://bar"> <bar:b>557</bar:b> <bar:c>xyz</bar:c> </bar:a> return (functx:change-element-ns( $in-xml, 'http://foo','')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-change-element-ns-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Changes the namespace of XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-ns.html : @param $elements the elements to change : @param $newns the new namespace : @param $prefix the prefix to use for the new namespace :)          declare function functx:change-element-ns ( $elements as element()* , $newns as xs:string , $prefix as xs:string ) as element()? { for $element in $elements return element {QName ($newns, concat($prefix, if ($prefix = '') then '' else ':', local-name($element)))} {$element/@*, $element/node()} } ;                     let $in-xml := <bar:a xmlns:bar="http://bar"> <bar:b>557</bar:b> <bar:c>xyz</bar:c> </bar:a> return (functx:change-element-ns( $in-xml, 'http://foo','foo')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-change-element-ns-all,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Changes the namespace of XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-ns.html : @param $elements the elements to change : @param $newns the new namespace : @param $prefix the prefix to use for the new namespace :)          declare function functx:change-element-ns ( $elements as element()* , $newns as xs:string , $prefix as xs:string ) as element()? { for $element in $elements return element {QName ($newns, concat($prefix, if ($prefix = '') then '' else ':', local-name($element)))} {$element/@*, $element/node()} } ;                     let $in-xml := <bar:a xmlns:bar="http://bar"> <bar:b>557</bar:b> <bar:c>xyz</bar:c> </bar:a> return (functx:change-element-ns( $in-xml, 'http://foo',''), functx:change-element-ns( $in-xml, 'http://foo','foo')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-chars-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Converts a string to a sequence of characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_chars.html : @param $arg the string to split :)          declare function functx:chars ( $arg as xs:string? ) as xs:string* { for $ch in string-to-codepoints($arg) return codepoints-to-string($ch) } ;                     (functx:chars('abc')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-chars-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Converts a string to a sequence of characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_chars.html : @param $arg the string to split :)          declare function functx:chars ( $arg as xs:string? ) as xs:string* { for $ch in string-to-codepoints($arg) return codepoints-to-string($ch) } ;                     (functx:chars('a b c')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-chars-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Converts a string to a sequence of characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_chars.html : @param $arg the string to split :)          declare function functx:chars ( $arg as xs:string? ) as xs:string* { for $ch in string-to-codepoints($arg) return codepoints-to-string($ch) } ;                     (functx:chars('abc'), functx:chars('a b c')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-contains-any-of-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a string contains any of a sequence of strings : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_contains-any-of.html : @param $arg the string to test : @param $searchStrings the strings to look for :)          declare function functx:contains-any-of ( $arg as xs:string? , $searchStrings as xs:string* ) as xs:boolean { some $searchString in $searchStrings satisfies contains($arg,$searchString) } ;                     (functx:contains-any-of('abc',('bc','xy'))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-contains-any-of-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a string contains any of a sequence of strings : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_contains-any-of.html : @param $arg the string to test : @param $searchStrings the strings to look for :)          declare function functx:contains-any-of ( $arg as xs:string? , $searchStrings as xs:string* ) as xs:boolean { some $searchString in $searchStrings satisfies contains($arg,$searchString) } ;                     (functx:contains-any-of('abc',('de','xy'))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-contains-any-of-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Whether a string contains any of a sequence of strings : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_contains-any-of.html : @param $arg the string to test : @param $searchStrings the strings to look for :)          declare function functx:contains-any-of ( $arg as xs:string? , $searchStrings as xs:string* ) as xs:boolean { some $searchString in $searchStrings satisfies contains($arg,$searchString) } ;                     (functx:contains-any-of('abc',('bc','xy')), functx:contains-any-of('abc',('de','xy'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-contains-case-insensitive-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether one string contains another, without regard to case : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_contains-case-insensitive.html : @param $arg the string to search : @param $substring the substring to find :)          declare function functx:contains-case-insensitive ( $arg as xs:string? , $substring as xs:string ) as xs:boolean? { contains(upper-case($arg), upper-case($substring)) } ;                     (functx:contains-case-insensitive( 'abcdef', 'def')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-contains-case-insensitive-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether one string contains another, without regard to case : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_contains-case-insensitive.html : @param $arg the string to search : @param $substring the substring to find :)          declare function functx:contains-case-insensitive ( $arg as xs:string? , $substring as xs:string ) as xs:boolean? { contains(upper-case($arg), upper-case($substring)) } ;                     (functx:contains-case-insensitive( 'abcdEF', 'def')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-contains-case-insensitive-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Whether one string contains another, without regard to case : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_contains-case-insensitive.html : @param $arg the string to search : @param $substring the substring to find :)          declare function functx:contains-case-insensitive ( $arg as xs:string? , $substring as xs:string ) as xs:boolean? { contains(upper-case($arg), upper-case($substring)) } ;                     (functx:contains-case-insensitive( 'abcdef', 'def'), functx:contains-case-insensitive( 'abcdEF', 'def')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-contains-word-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether one string contains another, as a separate word : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_contains-word.html : @param $arg the string to search : @param $word the word to find :)          declare function functx:contains-word ( $arg as xs:string? , $word as xs:string ) as xs:boolean { matches(upper-case($arg), concat('^(.*\W)?', upper-case(functx:escape-for-regex($word)), '(\W.*)?$')) } ;                     (:~ : Escapes regex special characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_escape-for-regex.html : @param $arg the string to escape :)          declare function functx:escape-for-regex ( $arg as xs:string? ) as xs:string { replace($arg, '(\.|\[|\]|\\|\||\-|\^|\$|\?|\*|\+|\{|\}|\(|\))','\\$1') } ;                     (functx:contains-word('abc def ghi', 'def')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-contains-word-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether one string contains another, as a separate word : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_contains-word.html : @param $arg the string to search : @param $word the word to find :)          declare function functx:contains-word ( $arg as xs:string? , $word as xs:string ) as xs:boolean { matches(upper-case($arg), concat('^(.*\W)?', upper-case(functx:escape-for-regex($word)), '(\W.*)?$')) } ;                     (:~ : Escapes regex special characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_escape-for-regex.html : @param $arg the string to escape :)          declare function functx:escape-for-regex ( $arg as xs:string? ) as xs:string { replace($arg, '(\.|\[|\]|\\|\||\-|\^|\$|\?|\*|\+|\{|\}|\(|\))','\\$1') } ;                     (functx:contains-word('abc.def\ghi', 'def')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-contains-word-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether one string contains another, as a separate word : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_contains-word.html : @param $arg the string to search : @param $word the word to find :)          declare function functx:contains-word ( $arg as xs:string? , $word as xs:string ) as xs:boolean { matches(upper-case($arg), concat('^(.*\W)?', upper-case(functx:escape-for-regex($word)), '(\W.*)?$')) } ;                     (:~ : Escapes regex special characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_escape-for-regex.html : @param $arg the string to escape :)          declare function functx:escape-for-regex ( $arg as xs:string? ) as xs:string { replace($arg, '(\.|\[|\]|\\|\||\-|\^|\$|\?|\*|\+|\{|\}|\(|\))','\\$1') } ;                     (functx:contains-word('abc def ghi', 'abc')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-contains-word-4,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether one string contains another, as a separate word : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_contains-word.html : @param $arg the string to search : @param $word the word to find :)          declare function functx:contains-word ( $arg as xs:string? , $word as xs:string ) as xs:boolean { matches(upper-case($arg), concat('^(.*\W)?', upper-case(functx:escape-for-regex($word)), '(\W.*)?$')) } ;                     (:~ : Escapes regex special characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_escape-for-regex.html : @param $arg the string to escape :)          declare function functx:escape-for-regex ( $arg as xs:string? ) as xs:string { replace($arg, '(\.|\[|\]|\\|\||\-|\^|\$|\?|\*|\+|\{|\}|\(|\))','\\$1') } ;                     (functx:contains-word('abc', 'abc')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-contains-word-5,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether one string contains another, as a separate word : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_contains-word.html : @param $arg the string to search : @param $word the word to find :)          declare function functx:contains-word ( $arg as xs:string? , $word as xs:string ) as xs:boolean { matches(upper-case($arg), concat('^(.*\W)?', upper-case(functx:escape-for-regex($word)), '(\W.*)?$')) } ;                     (:~ : Escapes regex special characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_escape-for-regex.html : @param $arg the string to escape :)          declare function functx:escape-for-regex ( $arg as xs:string? ) as xs:string { replace($arg, '(\.|\[|\]|\\|\||\-|\^|\$|\?|\*|\+|\{|\}|\(|\))','\\$1') } ;                     (functx:contains-word('abcdef', 'abc')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-contains-word-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Whether one string contains another, as a separate word : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_contains-word.html : @param $arg the string to search : @param $word the word to find :)          declare function functx:contains-word ( $arg as xs:string? , $word as xs:string ) as xs:boolean { matches(upper-case($arg), concat('^(.*\W)?', upper-case(functx:escape-for-regex($word)), '(\W.*)?$')) } ;                     (:~ : Escapes regex special characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_escape-for-regex.html : @param $arg the string to escape :)          declare function functx:escape-for-regex ( $arg as xs:string? ) as xs:string { replace($arg, '(\.|\[|\]|\\|\||\-|\^|\$|\?|\*|\+|\{|\}|\(|\))','\\$1') } ;                     (functx:contains-word('abc def ghi', 'def'), functx:contains-word('abc.def\ghi', 'def'), functx:contains-word('abc def ghi', 'abc'), functx:contains-word('abc', 'abc'), functx:contains-word('abcdef', 'abc')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-copy-attributes-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Copies attributes from one element to another : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_copy-attributes.html : @param $copyTo the element to copy attributes to : @param $copyFrom the element to copy attributes from :)          declare function functx:copy-attributes ( $copyTo as element() , $copyFrom as element() ) as element() { element { node-name($copyTo)} { $copyTo/@*[not(node-name(.) = $copyFrom/@*/node-name(.))], $copyFrom/@*, $copyTo/node() } } ;                     let $in-xml := <in-xml> <a>123</a>> <b x="1" y="2">456</b> <c x="9">123</c> <d z="5">123</d> </in-xml> return (functx:copy-attributes( $in-xml/a, $in-xml/b)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-copy-attributes-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Copies attributes from one element to another : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_copy-attributes.html : @param $copyTo the element to copy attributes to : @param $copyFrom the element to copy attributes from :)          declare function functx:copy-attributes ( $copyTo as element() , $copyFrom as element() ) as element() { element { node-name($copyTo)} { $copyTo/@*[not(node-name(.) = $copyFrom/@*/node-name(.))], $copyFrom/@*, $copyTo/node() } } ;                     let $in-xml := <in-xml> <a>123</a>> <b x="1" y="2">456</b> <c x="9">123</c> <d z="5">123</d> </in-xml> return (functx:copy-attributes( $in-xml/b, $in-xml/c)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-copy-attributes-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Copies attributes from one element to another : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_copy-attributes.html : @param $copyTo the element to copy attributes to : @param $copyFrom the element to copy attributes from :)          declare function functx:copy-attributes ( $copyTo as element() , $copyFrom as element() ) as element() { element { node-name($copyTo)} { $copyTo/@*[not(node-name(.) = $copyFrom/@*/node-name(.))], $copyFrom/@*, $copyTo/node() } } ;                     let $in-xml := <in-xml> <a>123</a>> <b x="1" y="2">456</b> <c x="9">123</c> <d z="5">123</d> </in-xml> return (functx:copy-attributes( $in-xml/d, $in-xml/c)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-copy-attributes-all,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Copies attributes from one element to another : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_copy-attributes.html : @param $copyTo the element to copy attributes to : @param $copyFrom the element to copy attributes from :)          declare function functx:copy-attributes ( $copyTo as element() , $copyFrom as element() ) as element() { element { node-name($copyTo)} { $copyTo/@*[not(node-name(.) = $copyFrom/@*/node-name(.))], $copyFrom/@*, $copyTo/node() } } ;                     let $in-xml := <in-xml> <a>123</a>> <b x="1" y="2">456</b> <c x="9">123</c> <d z="5">123</d> </in-xml> return (functx:copy-attributes( $in-xml/a, $in-xml/b), functx:copy-attributes( $in-xml/b, $in-xml/c), functx:copy-attributes( $in-xml/d, $in-xml/c)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-date-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Construct a date from a year, month and day : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_date.html : @param $year the year : @param $month the month : @param $day the day :)          declare function functx:date ( $year as xs:anyAtomicType , $month as xs:anyAtomicType , $day as xs:anyAtomicType ) as xs:date { xs:date( concat( functx:pad-integer-to-length(xs:integer($year),4),'-', functx:pad-integer-to-length(xs:integer($month),2),'-', functx:pad-integer-to-length(xs:integer($day),2))) } ;                     (:~ : Pads an integer to a desired length by adding leading zeros : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-integer-to-length.html : @param $integerToPad the integer to pad : @param $length the desired length :)          declare function functx:pad-integer-to-length ( $integerToPad as xs:anyAtomicType? , $length as xs:integer ) as xs:string { if ($length < string-length(string($integerToPad))) then error(xs:QName('functx:Integer_Longer_Than_Length')) else concat (functx:repeat-string( '0',$length - string-length(string($integerToPad))), string($integerToPad)) } ;                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:date(2006,6,12)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-date-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Construct a date from a year, month and day : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_date.html : @param $year the year : @param $month the month : @param $day the day :)          declare function functx:date ( $year as xs:anyAtomicType , $month as xs:anyAtomicType , $day as xs:anyAtomicType ) as xs:date { xs:date( concat( functx:pad-integer-to-length(xs:integer($year),4),'-', functx:pad-integer-to-length(xs:integer($month),2),'-', functx:pad-integer-to-length(xs:integer($day),2))) } ;                     (:~ : Pads an integer to a desired length by adding leading zeros : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-integer-to-length.html : @param $integerToPad the integer to pad : @param $length the desired length :)          declare function functx:pad-integer-to-length ( $integerToPad as xs:anyAtomicType? , $length as xs:integer ) as xs:string { if ($length < string-length(string($integerToPad))) then error(xs:QName('functx:Integer_Longer_Than_Length')) else concat (functx:repeat-string( '0',$length - string-length(string($integerToPad))), string($integerToPad)) } ;                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:date('2006','06','12')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-date-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Construct a date from a year, month and day : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_date.html : @param $year the year : @param $month the month : @param $day the day :)          declare function functx:date ( $year as xs:anyAtomicType , $month as xs:anyAtomicType , $day as xs:anyAtomicType ) as xs:date { xs:date( concat( functx:pad-integer-to-length(xs:integer($year),4),'-', functx:pad-integer-to-length(xs:integer($month),2),'-', functx:pad-integer-to-length(xs:integer($day),2))) } ;                     (:~ : Pads an integer to a desired length by adding leading zeros : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-integer-to-length.html : @param $integerToPad the integer to pad : @param $length the desired length :)          declare function functx:pad-integer-to-length ( $integerToPad as xs:anyAtomicType? , $length as xs:integer ) as xs:string { if ($length < string-length(string($integerToPad))) then error(xs:QName('functx:Integer_Longer_Than_Length')) else concat (functx:repeat-string( '0',$length - string-length(string($integerToPad))), string($integerToPad)) } ;                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:date(2006,6,12), functx:date('2006','06','12')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-dateTime-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Construct a date/time from individual components : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_datetime.html : @param $year the year : @param $month the month : @param $day the day : @param $hour the hour : @param $minute the minute : @param $second the second :)          declare function functx:dateTime ( $year as xs:anyAtomicType , $month as xs:anyAtomicType , $day as xs:anyAtomicType , $hour as xs:anyAtomicType , $minute as xs:anyAtomicType , $second as xs:anyAtomicType ) as xs:dateTime { xs:dateTime( concat(functx:date($year,$month,$day),'T', functx:time($hour,$minute,$second))) } ;                     (:~ : Construct a date from a year, month and day : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_date.html : @param $year the year : @param $month the month : @param $day the day :)          declare function functx:date ( $year as xs:anyAtomicType , $month as xs:anyAtomicType , $day as xs:anyAtomicType ) as xs:date { xs:date( concat( functx:pad-integer-to-length(xs:integer($year),4),'-', functx:pad-integer-to-length(xs:integer($month),2),'-', functx:pad-integer-to-length(xs:integer($day),2))) } ;                     (:~ : Pads an integer to a desired length by adding leading zeros : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-integer-to-length.html : @param $integerToPad the integer to pad : @param $length the desired length :)          declare function functx:pad-integer-to-length ( $integerToPad as xs:anyAtomicType? , $length as xs:integer ) as xs:string { if ($length < string-length(string($integerToPad))) then error(xs:QName('functx:Integer_Longer_Than_Length')) else concat (functx:repeat-string( '0',$length - string-length(string($integerToPad))), string($integerToPad)) } ;                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (:~ : Construct a time from an hour, minute and second : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_time.html : @param $hour the hour : @param $minute the minute : @param $second the second :)          declare function functx:time ( $hour as xs:anyAtomicType , $minute as xs:anyAtomicType , $second as xs:anyAtomicType ) as xs:time { xs:time( concat( functx:pad-integer-to-length(xs:integer($hour),2),':', functx:pad-integer-to-length(xs:integer($minute),2),':', functx:pad-integer-to-length(xs:integer($second),2))) } ;                     (functx:dateTime(2006,6,12,20,6,12)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-dateTime-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Construct a date/time from individual components : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_datetime.html : @param $year the year : @param $month the month : @param $day the day : @param $hour the hour : @param $minute the minute : @param $second the second :)          declare function functx:dateTime ( $year as xs:anyAtomicType , $month as xs:anyAtomicType , $day as xs:anyAtomicType , $hour as xs:anyAtomicType , $minute as xs:anyAtomicType , $second as xs:anyAtomicType ) as xs:dateTime { xs:dateTime( concat(functx:date($year,$month,$day),'T', functx:time($hour,$minute,$second))) } ;                     (:~ : Construct a date from a year, month and day : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_date.html : @param $year the year : @param $month the month : @param $day the day :)          declare function functx:date ( $year as xs:anyAtomicType , $month as xs:anyAtomicType , $day as xs:anyAtomicType ) as xs:date { xs:date( concat( functx:pad-integer-to-length(xs:integer($year),4),'-', functx:pad-integer-to-length(xs:integer($month),2),'-', functx:pad-integer-to-length(xs:integer($day),2))) } ;                     (:~ : Pads an integer to a desired length by adding leading zeros : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-integer-to-length.html : @param $integerToPad the integer to pad : @param $length the desired length :)          declare function functx:pad-integer-to-length ( $integerToPad as xs:anyAtomicType? , $length as xs:integer ) as xs:string { if ($length < string-length(string($integerToPad))) then error(xs:QName('functx:Integer_Longer_Than_Length')) else concat (functx:repeat-string( '0',$length - string-length(string($integerToPad))), string($integerToPad)) } ;                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (:~ : Construct a time from an hour, minute and second : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_time.html : @param $hour the hour : @param $minute the minute : @param $second the second :)          declare function functx:time ( $hour as xs:anyAtomicType , $minute as xs:anyAtomicType , $second as xs:anyAtomicType ) as xs:time { xs:time( concat( functx:pad-integer-to-length(xs:integer($hour),2),':', functx:pad-integer-to-length(xs:integer($minute),2),':', functx:pad-integer-to-length(xs:integer($second),2))) } ;                     (functx:dateTime('2006','6','12','20','6','12')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-dateTime-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Construct a date/time from individual components : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_datetime.html : @param $year the year : @param $month the month : @param $day the day : @param $hour the hour : @param $minute the minute : @param $second the second :)          declare function functx:dateTime ( $year as xs:anyAtomicType , $month as xs:anyAtomicType , $day as xs:anyAtomicType , $hour as xs:anyAtomicType , $minute as xs:anyAtomicType , $second as xs:anyAtomicType ) as xs:dateTime { xs:dateTime( concat(functx:date($year,$month,$day),'T', functx:time($hour,$minute,$second))) } ;                     (:~ : Construct a date from a year, month and day : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_date.html : @param $year the year : @param $month the month : @param $day the day :)          declare function functx:date ( $year as xs:anyAtomicType , $month as xs:anyAtomicType , $day as xs:anyAtomicType ) as xs:date { xs:date( concat( functx:pad-integer-to-length(xs:integer($year),4),'-', functx:pad-integer-to-length(xs:integer($month),2),'-', functx:pad-integer-to-length(xs:integer($day),2))) } ;                     (:~ : Pads an integer to a desired length by adding leading zeros : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-integer-to-length.html : @param $integerToPad the integer to pad : @param $length the desired length :)          declare function functx:pad-integer-to-length ( $integerToPad as xs:anyAtomicType? , $length as xs:integer ) as xs:string { if ($length < string-length(string($integerToPad))) then error(xs:QName('functx:Integer_Longer_Than_Length')) else concat (functx:repeat-string( '0',$length - string-length(string($integerToPad))), string($integerToPad)) } ;                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (:~ : Construct a time from an hour, minute and second : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_time.html : @param $hour the hour : @param $minute the minute : @param $second the second :)          declare function functx:time ( $hour as xs:anyAtomicType , $minute as xs:anyAtomicType , $second as xs:anyAtomicType ) as xs:time { xs:time( concat( functx:pad-integer-to-length(xs:integer($hour),2),':', functx:pad-integer-to-length(xs:integer($minute),2),':', functx:pad-integer-to-length(xs:integer($second),2))) } ;                     (functx:dateTime(2006,6,12,20,6,12), functx:dateTime('2006','6','12','20','6','12')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-day-in-year-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Construct a date from a year, month and day : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_date.html : @param $year the year : @param $month the month : @param $day the day :)          declare function functx:date ( $year as xs:anyAtomicType , $month as xs:anyAtomicType , $day as xs:anyAtomicType ) as xs:date { xs:date( concat( functx:pad-integer-to-length(xs:integer($year),4),'-', functx:pad-integer-to-length(xs:integer($month),2),'-', functx:pad-integer-to-length(xs:integer($day),2))) } ;                     (:~ : The day of the year (a number between 1 and 366) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-in-year.html : @param $date the date :)          declare function functx:day-in-year ( $date as xs:anyAtomicType? ) as xs:integer? { days-from-duration( xs:date($date) - functx:first-day-of-year($date)) + 1 } ;                     (:~ : The first day of the year of a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_first-day-of-year.html : @param $date the date :)          declare function functx:first-day-of-year ( $date as xs:anyAtomicType? ) as xs:date? { functx:date(year-from-date(xs:date($date)), 1, 1) } ;                     (:~ : Pads an integer to a desired length by adding leading zeros : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-integer-to-length.html : @param $integerToPad the integer to pad : @param $length the desired length :)          declare function functx:pad-integer-to-length ( $integerToPad as xs:anyAtomicType? , $length as xs:integer ) as xs:string { if ($length < string-length(string($integerToPad))) then error(xs:QName('functx:Integer_Longer_Than_Length')) else concat (functx:repeat-string( '0',$length - string-length(string($integerToPad))), string($integerToPad)) } ;                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:day-in-year(xs:date('2004-01-01')))) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-day-in-year-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Construct a date from a year, month and day : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_date.html : @param $year the year : @param $month the month : @param $day the day :)          declare function functx:date ( $year as xs:anyAtomicType , $month as xs:anyAtomicType , $day as xs:anyAtomicType ) as xs:date { xs:date( concat( functx:pad-integer-to-length(xs:integer($year),4),'-', functx:pad-integer-to-length(xs:integer($month),2),'-', functx:pad-integer-to-length(xs:integer($day),2))) } ;                     (:~ : The day of the year (a number between 1 and 366) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-in-year.html : @param $date the date :)          declare function functx:day-in-year ( $date as xs:anyAtomicType? ) as xs:integer? { days-from-duration( xs:date($date) - functx:first-day-of-year($date)) + 1 } ;                     (:~ : The first day of the year of a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_first-day-of-year.html : @param $date the date :)          declare function functx:first-day-of-year ( $date as xs:anyAtomicType? ) as xs:date? { functx:date(year-from-date(xs:date($date)), 1, 1) } ;                     (:~ : Pads an integer to a desired length by adding leading zeros : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-integer-to-length.html : @param $integerToPad the integer to pad : @param $length the desired length :)          declare function functx:pad-integer-to-length ( $integerToPad as xs:anyAtomicType? , $length as xs:integer ) as xs:string { if ($length < string-length(string($integerToPad))) then error(xs:QName('functx:Integer_Longer_Than_Length')) else concat (functx:repeat-string( '0',$length - string-length(string($integerToPad))), string($integerToPad)) } ;                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:day-in-year( xs:dateTime('2004-02-01T12:00:13')))) = (32). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-day-in-year-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Construct a date from a year, month and day : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_date.html : @param $year the year : @param $month the month : @param $day the day :)          declare function functx:date ( $year as xs:anyAtomicType , $month as xs:anyAtomicType , $day as xs:anyAtomicType ) as xs:date { xs:date( concat( functx:pad-integer-to-length(xs:integer($year),4),'-', functx:pad-integer-to-length(xs:integer($month),2),'-', functx:pad-integer-to-length(xs:integer($day),2))) } ;                     (:~ : The day of the year (a number between 1 and 366) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-in-year.html : @param $date the date :)          declare function functx:day-in-year ( $date as xs:anyAtomicType? ) as xs:integer? { days-from-duration( xs:date($date) - functx:first-day-of-year($date)) + 1 } ;                     (:~ : The first day of the year of a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_first-day-of-year.html : @param $date the date :)          declare function functx:first-day-of-year ( $date as xs:anyAtomicType? ) as xs:date? { functx:date(year-from-date(xs:date($date)), 1, 1) } ;                     (:~ : Pads an integer to a desired length by adding leading zeros : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-integer-to-length.html : @param $integerToPad the integer to pad : @param $length the desired length :)          declare function functx:pad-integer-to-length ( $integerToPad as xs:anyAtomicType? , $length as xs:integer ) as xs:string { if ($length < string-length(string($integerToPad))) then error(xs:QName('functx:Integer_Longer_Than_Length')) else concat (functx:repeat-string( '0',$length - string-length(string($integerToPad))), string($integerToPad)) } ;                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:day-in-year('2004-02-05'))) = (36). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-day-in-year-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Construct a date from a year, month and day : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_date.html : @param $year the year : @param $month the month : @param $day the day :)          declare function functx:date ( $year as xs:anyAtomicType , $month as xs:anyAtomicType , $day as xs:anyAtomicType ) as xs:date { xs:date( concat( functx:pad-integer-to-length(xs:integer($year),4),'-', functx:pad-integer-to-length(xs:integer($month),2),'-', functx:pad-integer-to-length(xs:integer($day),2))) } ;                     (:~ : The day of the year (a number between 1 and 366) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-in-year.html : @param $date the date :)          declare function functx:day-in-year ( $date as xs:anyAtomicType? ) as xs:integer? { days-from-duration( xs:date($date) - functx:first-day-of-year($date)) + 1 } ;                     (:~ : The first day of the year of a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_first-day-of-year.html : @param $date the date :)          declare function functx:first-day-of-year ( $date as xs:anyAtomicType? ) as xs:date? { functx:date(year-from-date(xs:date($date)), 1, 1) } ;                     (:~ : Pads an integer to a desired length by adding leading zeros : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-integer-to-length.html : @param $integerToPad the integer to pad : @param $length the desired length :)          declare function functx:pad-integer-to-length ( $integerToPad as xs:anyAtomicType? , $length as xs:integer ) as xs:string { if ($length < string-length(string($integerToPad))) then error(xs:QName('functx:Integer_Longer_Than_Length')) else concat (functx:repeat-string( '0',$length - string-length(string($integerToPad))), string($integerToPad)) } ;                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:day-in-year(xs:date('2004-01-01')), functx:day-in-year( xs:dateTime('2004-02-01T12:00:13')), functx:day-in-year('2004-02-05')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-day-of-week-abbrev-en-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The abbreviated day of the week, from a date, in English : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week-abbrev-en.html : @param $date the date :)          declare function functx:day-of-week-abbrev-en ( $date as xs:anyAtomicType? ) as xs:string? { ('Sun', 'Mon', 'Tues', 'Wed', 'Thurs', 'Fri', 'Sat') [functx:day-of-week($date) + 1] } ;                     (:~ : The day of the week, from a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week.html : @param $date the date :)          declare function functx:day-of-week ( $date as xs:anyAtomicType? ) as xs:integer? { if (empty($date)) then () else xs:integer((xs:date($date) - xs:date('1901-01-06')) div xs:dayTimeDuration('P1D')) mod 7 } ;                     (functx:day-of-week-abbrev-en( xs:date('2004-11-04'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-day-of-week-abbrev-en-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The abbreviated day of the week, from a date, in English : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week-abbrev-en.html : @param $date the date :)          declare function functx:day-of-week-abbrev-en ( $date as xs:anyAtomicType? ) as xs:string? { ('Sun', 'Mon', 'Tues', 'Wed', 'Thurs', 'Fri', 'Sat') [functx:day-of-week($date) + 1] } ;                     (:~ : The day of the week, from a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week.html : @param $date the date :)          declare function functx:day-of-week ( $date as xs:anyAtomicType? ) as xs:integer? { if (empty($date)) then () else xs:integer((xs:date($date) - xs:date('1901-01-06')) div xs:dayTimeDuration('P1D')) mod 7 } ;                     (functx:day-of-week-abbrev-en('2004-11-04')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-day-of-week-abbrev-en-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The abbreviated day of the week, from a date, in English : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week-abbrev-en.html : @param $date the date :)          declare function functx:day-of-week-abbrev-en ( $date as xs:anyAtomicType? ) as xs:string? { ('Sun', 'Mon', 'Tues', 'Wed', 'Thurs', 'Fri', 'Sat') [functx:day-of-week($date) + 1] } ;                     (:~ : The day of the week, from a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week.html : @param $date the date :)          declare function functx:day-of-week ( $date as xs:anyAtomicType? ) as xs:integer? { if (empty($date)) then () else xs:integer((xs:date($date) - xs:date('1901-01-06')) div xs:dayTimeDuration('P1D')) mod 7 } ;                     (functx:day-of-week-abbrev-en( xs:date('2004-11-04')), functx:day-of-week-abbrev-en('2004-11-04')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-day-of-week-name-en-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The name of the day of the week, from a date, in English : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week-name-en.html : @param $date the date :)          declare function functx:day-of-week-name-en ( $date as xs:anyAtomicType? ) as xs:string? { ('Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday') [functx:day-of-week($date) + 1] } ;                     (:~ : The day of the week, from a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week.html : @param $date the date :)          declare function functx:day-of-week ( $date as xs:anyAtomicType? ) as xs:integer? { if (empty($date)) then () else xs:integer((xs:date($date) - xs:date('1901-01-06')) div xs:dayTimeDuration('P1D')) mod 7 } ;                     (functx:day-of-week-name-en( xs:date('2004-11-04'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-day-of-week-name-en-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The name of the day of the week, from a date, in English : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week-name-en.html : @param $date the date :)          declare function functx:day-of-week-name-en ( $date as xs:anyAtomicType? ) as xs:string? { ('Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday') [functx:day-of-week($date) + 1] } ;                     (:~ : The day of the week, from a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week.html : @param $date the date :)          declare function functx:day-of-week ( $date as xs:anyAtomicType? ) as xs:integer? { if (empty($date)) then () else xs:integer((xs:date($date) - xs:date('1901-01-06')) div xs:dayTimeDuration('P1D')) mod 7 } ;                     (functx:day-of-week-name-en('2004-11-04')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-day-of-week-name-en-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The name of the day of the week, from a date, in English : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week-name-en.html : @param $date the date :)          declare function functx:day-of-week-name-en ( $date as xs:anyAtomicType? ) as xs:string? { ('Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday') [functx:day-of-week($date) + 1] } ;                     (:~ : The day of the week, from a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week.html : @param $date the date :)          declare function functx:day-of-week ( $date as xs:anyAtomicType? ) as xs:integer? { if (empty($date)) then () else xs:integer((xs:date($date) - xs:date('1901-01-06')) div xs:dayTimeDuration('P1D')) mod 7 } ;                     (functx:day-of-week-name-en( xs:date('2004-11-04')), functx:day-of-week-name-en('2004-11-04')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-day-of-week-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The day of the week, from a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week.html : @param $date the date :)          declare function functx:day-of-week ( $date as xs:anyAtomicType? ) as xs:integer? { if (empty($date)) then () else xs:integer((xs:date($date) - xs:date('1901-01-06')) div xs:dayTimeDuration('P1D')) mod 7 } ;                     (functx:day-of-week( xs:date('2004-11-04')))) = (4). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-day-of-week-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The day of the week, from a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week.html : @param $date the date :)          declare function functx:day-of-week ( $date as xs:anyAtomicType? ) as xs:integer? { if (empty($date)) then () else xs:integer((xs:date($date) - xs:date('1901-01-06')) div xs:dayTimeDuration('P1D')) mod 7 } ;                     (functx:day-of-week( xs:dateTime('2004-11-04T12:00:13')))) = (4). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-day-of-week-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The day of the week, from a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week.html : @param $date the date :)          declare function functx:day-of-week ( $date as xs:anyAtomicType? ) as xs:integer? { if (empty($date)) then () else xs:integer((xs:date($date) - xs:date('1901-01-06')) div xs:dayTimeDuration('P1D')) mod 7 } ;                     (functx:day-of-week('2004-11-04'))) = (4). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-day-of-week-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The day of the week, from a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week.html : @param $date the date :)          declare function functx:day-of-week ( $date as xs:anyAtomicType? ) as xs:integer? { if (empty($date)) then () else xs:integer((xs:date($date) - xs:date('1901-01-06')) div xs:dayTimeDuration('P1D')) mod 7 } ;                     (functx:day-of-week( xs:date('2004-11-04')), functx:day-of-week( xs:dateTime('2004-11-04T12:00:13')), functx:day-of-week('2004-11-04')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-days-in-month-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Number of days in the month : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_days-in-month.html : @param $date the date :)          declare function functx:days-in-month ( $date as xs:anyAtomicType? ) as xs:integer? { if (month-from-date(xs:date($date)) = 2 and functx:is-leap-year($date)) then 29 else (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31) [month-from-date(xs:date($date))] } ;                     (:~ : Whether a date falls in a leap year : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-leap-year.html : @param $date the date or year :)          declare function functx:is-leap-year ( $date as xs:anyAtomicType? ) as xs:boolean { for $year in xs:integer(substring(string($date),1,4)) return ($year mod 4 = 0 and $year mod 100 != 0) or $year mod 400 = 0 } ;                     (functx:days-in-month(xs:date('2004-01-23')))) = (31). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-days-in-month-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Number of days in the month : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_days-in-month.html : @param $date the date :)          declare function functx:days-in-month ( $date as xs:anyAtomicType? ) as xs:integer? { if (month-from-date(xs:date($date)) = 2 and functx:is-leap-year($date)) then 29 else (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31) [month-from-date(xs:date($date))] } ;                     (:~ : Whether a date falls in a leap year : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-leap-year.html : @param $date the date or year :)          declare function functx:is-leap-year ( $date as xs:anyAtomicType? ) as xs:boolean { for $year in xs:integer(substring(string($date),1,4)) return ($year mod 4 = 0 and $year mod 100 != 0) or $year mod 400 = 0 } ;                     (functx:days-in-month( xs:dateTime('2004-02-15T12:00:13')))) = (29). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-days-in-month-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Number of days in the month : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_days-in-month.html : @param $date the date :)          declare function functx:days-in-month ( $date as xs:anyAtomicType? ) as xs:integer? { if (month-from-date(xs:date($date)) = 2 and functx:is-leap-year($date)) then 29 else (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31) [month-from-date(xs:date($date))] } ;                     (:~ : Whether a date falls in a leap year : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-leap-year.html : @param $date the date or year :)          declare function functx:is-leap-year ( $date as xs:anyAtomicType? ) as xs:boolean { for $year in xs:integer(substring(string($date),1,4)) return ($year mod 4 = 0 and $year mod 100 != 0) or $year mod 400 = 0 } ;                     (functx:days-in-month('2005-02-15'))) = (28). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-days-in-month-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Number of days in the month : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_days-in-month.html : @param $date the date :)          declare function functx:days-in-month ( $date as xs:anyAtomicType? ) as xs:integer? { if (month-from-date(xs:date($date)) = 2 and functx:is-leap-year($date)) then 29 else (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31) [month-from-date(xs:date($date))] } ;                     (:~ : Whether a date falls in a leap year : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-leap-year.html : @param $date the date or year :)          declare function functx:is-leap-year ( $date as xs:anyAtomicType? ) as xs:boolean { for $year in xs:integer(substring(string($date),1,4)) return ($year mod 4 = 0 and $year mod 100 != 0) or $year mod 400 = 0 } ;                     (functx:days-in-month(xs:date('2004-01-23')), functx:days-in-month( xs:dateTime('2004-02-15T12:00:13')), functx:days-in-month('2005-02-15')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-dayTimeDuration-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Construct a dayTimeDuration from a number of days, hours, etc. : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_daytimeduration.html : @param $days the number of days : @param $hours the number of hours : @param $minutes the number of minutes : @param $seconds the number of seconds :)          declare function functx:dayTimeDuration ( $days as xs:decimal? , $hours as xs:decimal? , $minutes as xs:decimal? , $seconds as xs:decimal? ) as xs:dayTimeDuration { (xs:dayTimeDuration('P1D') * functx:if-empty($days,0)) + (xs:dayTimeDuration('PT1H') * functx:if-empty($hours,0)) + (xs:dayTimeDuration('PT1M') * functx:if-empty($minutes,0)) + (xs:dayTimeDuration('PT1S') * functx:if-empty($seconds,0)) } ;                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (functx:dayTimeDuration(1,6,0,0)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-dayTimeDuration-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Construct a dayTimeDuration from a number of days, hours, etc. : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_daytimeduration.html : @param $days the number of days : @param $hours the number of hours : @param $minutes the number of minutes : @param $seconds the number of seconds :)          declare function functx:dayTimeDuration ( $days as xs:decimal? , $hours as xs:decimal? , $minutes as xs:decimal? , $seconds as xs:decimal? ) as xs:dayTimeDuration { (xs:dayTimeDuration('P1D') * functx:if-empty($days,0)) + (xs:dayTimeDuration('PT1H') * functx:if-empty($hours,0)) + (xs:dayTimeDuration('PT1M') * functx:if-empty($minutes,0)) + (xs:dayTimeDuration('PT1S') * functx:if-empty($seconds,0)) } ;                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (functx:dayTimeDuration(2.5,0,0,0)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-dayTimeDuration-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Construct a dayTimeDuration from a number of days, hours, etc. : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_daytimeduration.html : @param $days the number of days : @param $hours the number of hours : @param $minutes the number of minutes : @param $seconds the number of seconds :)          declare function functx:dayTimeDuration ( $days as xs:decimal? , $hours as xs:decimal? , $minutes as xs:decimal? , $seconds as xs:decimal? ) as xs:dayTimeDuration { (xs:dayTimeDuration('P1D') * functx:if-empty($days,0)) + (xs:dayTimeDuration('PT1H') * functx:if-empty($hours,0)) + (xs:dayTimeDuration('PT1M') * functx:if-empty($minutes,0)) + (xs:dayTimeDuration('PT1S') * functx:if-empty($seconds,0)) } ;                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (functx:dayTimeDuration(1,(),3,5.6)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-dayTimeDuration-4,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Construct a dayTimeDuration from a number of days, hours, etc. : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_daytimeduration.html : @param $days the number of days : @param $hours the number of hours : @param $minutes the number of minutes : @param $seconds the number of seconds :)          declare function functx:dayTimeDuration ( $days as xs:decimal? , $hours as xs:decimal? , $minutes as xs:decimal? , $seconds as xs:decimal? ) as xs:dayTimeDuration { (xs:dayTimeDuration('P1D') * functx:if-empty($days,0)) + (xs:dayTimeDuration('PT1H') * functx:if-empty($hours,0)) + (xs:dayTimeDuration('PT1M') * functx:if-empty($minutes,0)) + (xs:dayTimeDuration('PT1S') * functx:if-empty($seconds,0)) } ;                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (functx:dayTimeDuration(0,0,5,0)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-dayTimeDuration-5,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Construct a dayTimeDuration from a number of days, hours, etc. : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_daytimeduration.html : @param $days the number of days : @param $hours the number of hours : @param $minutes the number of minutes : @param $seconds the number of seconds :)          declare function functx:dayTimeDuration ( $days as xs:decimal? , $hours as xs:decimal? , $minutes as xs:decimal? , $seconds as xs:decimal? ) as xs:dayTimeDuration { (xs:dayTimeDuration('P1D') * functx:if-empty($days,0)) + (xs:dayTimeDuration('PT1H') * functx:if-empty($hours,0)) + (xs:dayTimeDuration('PT1M') * functx:if-empty($minutes,0)) + (xs:dayTimeDuration('PT1S') * functx:if-empty($seconds,0)) } ;                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (functx:dayTimeDuration(0,0,0,0)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-dayTimeDuration-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Construct a dayTimeDuration from a number of days, hours, etc. : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_daytimeduration.html : @param $days the number of days : @param $hours the number of hours : @param $minutes the number of minutes : @param $seconds the number of seconds :)          declare function functx:dayTimeDuration ( $days as xs:decimal? , $hours as xs:decimal? , $minutes as xs:decimal? , $seconds as xs:decimal? ) as xs:dayTimeDuration { (xs:dayTimeDuration('P1D') * functx:if-empty($days,0)) + (xs:dayTimeDuration('PT1H') * functx:if-empty($hours,0)) + (xs:dayTimeDuration('PT1M') * functx:if-empty($minutes,0)) + (xs:dayTimeDuration('PT1S') * functx:if-empty($seconds,0)) } ;                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (functx:dayTimeDuration(1,6,0,0), functx:dayTimeDuration(2.5,0,0,0), functx:dayTimeDuration(1,(),3,5.6), functx:dayTimeDuration(0,0,5,0), functx:dayTimeDuration(0,0,0,0)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-ddmmyyyy-to-date-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Converts a string with format DDMMYYYY (with any delimiters) to a date : : @author Priscilla Walmsley, Datypic : @version 1.1 : @see http://www.xqueryfunctions.com/xq/functx_ddmmyyyy-to-date.html : @param $dateString the DDMMYYYY string :)          declare function functx:ddmmyyyy-to-date ( $dateString as xs:string? ) as xs:date? { if (empty($dateString)) then () else if (not(matches($dateString, '^\D*(\d{2})\D*(\d{2})\D*(\d{4})\D*$'))) then error(xs:QName('functx:Invalid_Date_Format')) else xs:date(replace($dateString, '^\D*(\d{2})\D*(\d{2})\D*(\d{4})\D*$', '$3-$2-$1')) } ;                     (functx:ddmmyyyy-to-date('15-12-2004')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-ddmmyyyy-to-date-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Converts a string with format DDMMYYYY (with any delimiters) to a date : : @author Priscilla Walmsley, Datypic : @version 1.1 : @see http://www.xqueryfunctions.com/xq/functx_ddmmyyyy-to-date.html : @param $dateString the DDMMYYYY string :)          declare function functx:ddmmyyyy-to-date ( $dateString as xs:string? ) as xs:date? { if (empty($dateString)) then () else if (not(matches($dateString, '^\D*(\d{2})\D*(\d{2})\D*(\d{4})\D*$'))) then error(xs:QName('functx:Invalid_Date_Format')) else xs:date(replace($dateString, '^\D*(\d{2})\D*(\d{2})\D*(\d{4})\D*$', '$3-$2-$1')) } ;                     (functx:ddmmyyyy-to-date('15122004')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-ddmmyyyy-to-date-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Converts a string with format DDMMYYYY (with any delimiters) to a date : : @author Priscilla Walmsley, Datypic : @version 1.1 : @see http://www.xqueryfunctions.com/xq/functx_ddmmyyyy-to-date.html : @param $dateString the DDMMYYYY string :)          declare function functx:ddmmyyyy-to-date ( $dateString as xs:string? ) as xs:date? { if (empty($dateString)) then () else if (not(matches($dateString, '^\D*(\d{2})\D*(\d{2})\D*(\d{4})\D*$'))) then error(xs:QName('functx:Invalid_Date_Format')) else xs:date(replace($dateString, '^\D*(\d{2})\D*(\d{2})\D*(\d{4})\D*$', '$3-$2-$1')) } ;                     (functx:ddmmyyyy-to-date('15/12/2004')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-ddmmyyyy-to-date-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Converts a string with format DDMMYYYY (with any delimiters) to a date : : @author Priscilla Walmsley, Datypic : @version 1.1 : @see http://www.xqueryfunctions.com/xq/functx_ddmmyyyy-to-date.html : @param $dateString the DDMMYYYY string :)          declare function functx:ddmmyyyy-to-date ( $dateString as xs:string? ) as xs:date? { if (empty($dateString)) then () else if (not(matches($dateString, '^\D*(\d{2})\D*(\d{2})\D*(\d{4})\D*$'))) then error(xs:QName('functx:Invalid_Date_Format')) else xs:date(replace($dateString, '^\D*(\d{2})\D*(\d{2})\D*(\d{4})\D*$', '$3-$2-$1')) } ;                     (functx:ddmmyyyy-to-date('15-12-2004'), functx:ddmmyyyy-to-date('15122004'), functx:ddmmyyyy-to-date('15/12/2004')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-depth-of-node-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The depth (level) of a node in an XML tree : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_depth-of-node.html : @param $node the node to check :)          declare function functx:depth-of-node ( $node as node()? ) as xs:integer { count($node/ancestor-or-self::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:depth-of-node($in-xml))) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-depth-of-node-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The depth (level) of a node in an XML tree : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_depth-of-node.html : @param $node the node to check :)          declare function functx:depth-of-node ( $node as node()? ) as xs:integer { count($node/ancestor-or-self::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:depth-of-node($in-xml/author[1]))) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-depth-of-node-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The depth (level) of a node in an XML tree : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_depth-of-node.html : @param $node the node to check :)          declare function functx:depth-of-node ( $node as node()? ) as xs:integer { count($node/ancestor-or-self::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:depth-of-node( $in-xml/author[1]/fName/text()))) = (4). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-depth-of-node-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The depth (level) of a node in an XML tree : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_depth-of-node.html : @param $node the node to check :)          declare function functx:depth-of-node ( $node as node()? ) as xs:integer { count($node/ancestor-or-self::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:depth-of-node($in-xml), functx:depth-of-node($in-xml/author[1]), functx:depth-of-node( $in-xml/author[1]/fName/text())))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-distinct-attribute-names-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The distinct names of all attributes in an XML fragment : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_distinct-attribute-names.html : @param $nodes the root to start from :)          declare function functx:distinct-attribute-names ( $nodes as node()* ) as xs:string* { distinct-values($nodes//@*/name(.)) } ;                     let $in-xml := <authors a1="xyz"> <author a2="abc"> <fName a3="def">Kate</fName> <lName>Jones</lName> </author> <author> <fName a3="def">John</fName> <lName>Doe</lName> </author> </authors> return (functx:distinct-attribute-names($in-xml)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-distinct-deep-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : The XML nodes with distinct values, taking into account attributes and descendants : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_distinct-deep.html : @param $nodes the sequence of nodes to test :)          declare function functx:distinct-deep ( $nodes as node()* ) as node()* { for $seq in (1 to count($nodes)) return $nodes[$seq][not(functx:is-node-in-sequence-deep-equal( .,$nodes[position() < $seq]))] } ;                     (:~ : Whether an XML node is in a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>Kate</fName> <lName>Doe</lName> </author> </authors> return (functx:distinct-deep($in-xml//author)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-distinct-deep-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : The XML nodes with distinct values, taking into account attributes and descendants : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_distinct-deep.html : @param $nodes the sequence of nodes to test :)          declare function functx:distinct-deep ( $nodes as node()* ) as node()* { for $seq in (1 to count($nodes)) return $nodes[$seq][not(functx:is-node-in-sequence-deep-equal( .,$nodes[position() < $seq]))] } ;                     (:~ : Whether an XML node is in a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>Kate</fName> <lName>Doe</lName> </author> </authors> return (functx:distinct-deep($in-xml//lName)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-distinct-deep-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : The XML nodes with distinct values, taking into account attributes and descendants : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_distinct-deep.html : @param $nodes the sequence of nodes to test :)          declare function functx:distinct-deep ( $nodes as node()* ) as node()* { for $seq in (1 to count($nodes)) return $nodes[$seq][not(functx:is-node-in-sequence-deep-equal( .,$nodes[position() < $seq]))] } ;                     (:~ : Whether an XML node is in a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>Kate</fName> <lName>Doe</lName> </author> </authors> return (functx:distinct-deep($in-xml//fName)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-distinct-deep-all,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : The XML nodes with distinct values, taking into account attributes and descendants : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_distinct-deep.html : @param $nodes the sequence of nodes to test :)          declare function functx:distinct-deep ( $nodes as node()* ) as node()* { for $seq in (1 to count($nodes)) return $nodes[$seq][not(functx:is-node-in-sequence-deep-equal( .,$nodes[position() < $seq]))] } ;                     (:~ : Whether an XML node is in a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>Kate</fName> <lName>Doe</lName> </author> </authors> return (functx:distinct-deep($in-xml//author), functx:distinct-deep($in-xml//lName), functx:distinct-deep($in-xml//fName)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-distinct-element-names-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The distinct names of all elements in an XML fragment : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_distinct-element-names.html : @param $nodes the root(s) to start from :)          declare function functx:distinct-element-names ( $nodes as node()* ) as xs:string* { distinct-values($nodes/descendant-or-self::*/name(.)) } ;                     (:~ : A path to an XML node (or sequence of nodes) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_path-to-node.html : @param $nodes the node sequence :)          declare function functx:path-to-node ( $nodes as node()* ) as xs:string* { $nodes/string-join(ancestor-or-self::*/name(.), '/') } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:distinct-element-names($in-xml)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-distinct-element-names-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The distinct names of all elements in an XML fragment : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_distinct-element-names.html : @param $nodes the root(s) to start from :)          declare function functx:distinct-element-names ( $nodes as node()* ) as xs:string* { distinct-values($nodes/descendant-or-self::*/name(.)) } ;                     (:~ : A path to an XML node (or sequence of nodes) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_path-to-node.html : @param $nodes the node sequence :)          declare function functx:path-to-node ( $nodes as node()* ) as xs:string* { $nodes/string-join(ancestor-or-self::*/name(.), '/') } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:distinct-element-names( $in-xml/author[1])))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-distinct-element-names-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The distinct names of all elements in an XML fragment : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_distinct-element-names.html : @param $nodes the root(s) to start from :)          declare function functx:distinct-element-names ( $nodes as node()* ) as xs:string* { distinct-values($nodes/descendant-or-self::*/name(.)) } ;                     (:~ : A path to an XML node (or sequence of nodes) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_path-to-node.html : @param $nodes the node sequence :)          declare function functx:path-to-node ( $nodes as node()* ) as xs:string* { $nodes/string-join(ancestor-or-self::*/name(.), '/') } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:distinct-element-names($in-xml), functx:distinct-element-names( $in-xml/author[1])))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-distinct-element-paths-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The distinct paths of all descendant elements in an XML fragment : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_distinct-element-paths.html : @param $nodes the root(s) to start from :)          declare function functx:distinct-element-paths ( $nodes as node()* ) as xs:string* { distinct-values(functx:path-to-node($nodes/descendant-or-self::*)) } ;                     (:~ : A path to an XML node (or sequence of nodes) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_path-to-node.html : @param $nodes the node sequence :)          declare function functx:path-to-node ( $nodes as node()* ) as xs:string* { $nodes/string-join(ancestor-or-self::*/name(.), '/') } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:distinct-element-paths( $in-xml)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-distinct-element-paths-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The distinct paths of all descendant elements in an XML fragment : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_distinct-element-paths.html : @param $nodes the root(s) to start from :)          declare function functx:distinct-element-paths ( $nodes as node()* ) as xs:string* { distinct-values(functx:path-to-node($nodes/descendant-or-self::*)) } ;                     (:~ : A path to an XML node (or sequence of nodes) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_path-to-node.html : @param $nodes the node sequence :)          declare function functx:path-to-node ( $nodes as node()* ) as xs:string* { $nodes/string-join(ancestor-or-self::*/name(.), '/') } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:distinct-element-paths( $in-xml/author[1])))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-distinct-element-paths-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The distinct paths of all descendant elements in an XML fragment : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_distinct-element-paths.html : @param $nodes the root(s) to start from :)          declare function functx:distinct-element-paths ( $nodes as node()* ) as xs:string* { distinct-values(functx:path-to-node($nodes/descendant-or-self::*)) } ;                     (:~ : A path to an XML node (or sequence of nodes) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_path-to-node.html : @param $nodes the node sequence :)          declare function functx:path-to-node ( $nodes as node()* ) as xs:string* { $nodes/string-join(ancestor-or-self::*/name(.), '/') } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:distinct-element-paths( $in-xml), functx:distinct-element-paths( $in-xml/author[1])))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-distinct-nodes-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : The distinct XML nodes in a sequence (by node identity) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_distinct-nodes.html : @param $nodes the node sequence :)          declare function functx:distinct-nodes ( $nodes as node()* ) as node()* { for $seq in (1 to count($nodes)) return $nodes[$seq][not(functx:is-node-in-sequence( .,$nodes[position() < $seq]))] } ;                     (:~ : Whether an XML node is in a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies $nodeInSeq is $node } ;                     let $in-xml :=  <test> <child>1</child> <child>2</child> <child>3</child> <child>3</child> </test> return (functx:distinct-nodes( ($in-xml/child, $in-xml/*) )). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-distinct-nodes-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : The distinct XML nodes in a sequence (by node identity) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_distinct-nodes.html : @param $nodes the node sequence :)          declare function functx:distinct-nodes ( $nodes as node()* ) as node()* { for $seq in (1 to count($nodes)) return $nodes[$seq][not(functx:is-node-in-sequence( .,$nodes[position() < $seq]))] } ;                     (:~ : Whether an XML node is in a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies $nodeInSeq is $node } ;                     let $in-xml :=  <test> <child>1</child> <child>2</child> <child>3</child> <child>3</child> </test> return (functx:distinct-nodes( ($in-xml/child[3], $in-xml/*) )). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-distinct-nodes-all,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : The distinct XML nodes in a sequence (by node identity) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_distinct-nodes.html : @param $nodes the node sequence :)          declare function functx:distinct-nodes ( $nodes as node()* ) as node()* { for $seq in (1 to count($nodes)) return $nodes[$seq][not(functx:is-node-in-sequence( .,$nodes[position() < $seq]))] } ;                     (:~ : Whether an XML node is in a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies $nodeInSeq is $node } ;                     let $in-xml :=  <test> <child>1</child> <child>2</child> <child>3</child> <child>3</child> </test> return (functx:distinct-nodes( ($in-xml/child, $in-xml/*) ), functx:distinct-nodes( ($in-xml/child[3], $in-xml/*) )). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-duration-from-timezone-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Converts a timezone like "-05:00" or "Z" into xs:dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_duration-from-timezone.html : @param $timezone the time zone, in (+|-)HH:MM format :)          declare function functx:duration-from-timezone ( $timezone as xs:string ) as xs:dayTimeDuration { xs:dayTimeDuration( if (not(matches($timezone,'Z|[\+\-]\d{2}:\d{2}'))) then error(xs:QName('functx:Invalid_Timezone_Value')) else if ($timezone = 'Z') then 'PT0S' else replace($timezone,'\+?(\d{2}):\d{2}','PT$1H') ) } ;                     (functx:duration-from-timezone('Z')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-duration-from-timezone-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Converts a timezone like "-05:00" or "Z" into xs:dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_duration-from-timezone.html : @param $timezone the time zone, in (+|-)HH:MM format :)          declare function functx:duration-from-timezone ( $timezone as xs:string ) as xs:dayTimeDuration { xs:dayTimeDuration( if (not(matches($timezone,'Z|[\+\-]\d{2}:\d{2}'))) then error(xs:QName('functx:Invalid_Timezone_Value')) else if ($timezone = 'Z') then 'PT0S' else replace($timezone,'\+?(\d{2}):\d{2}','PT$1H') ) } ;                     (functx:duration-from-timezone('-05:00')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-duration-from-timezone-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Converts a timezone like "-05:00" or "Z" into xs:dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_duration-from-timezone.html : @param $timezone the time zone, in (+|-)HH:MM format :)          declare function functx:duration-from-timezone ( $timezone as xs:string ) as xs:dayTimeDuration { xs:dayTimeDuration( if (not(matches($timezone,'Z|[\+\-]\d{2}:\d{2}'))) then error(xs:QName('functx:Invalid_Timezone_Value')) else if ($timezone = 'Z') then 'PT0S' else replace($timezone,'\+?(\d{2}):\d{2}','PT$1H') ) } ;                     (functx:duration-from-timezone('+09:00')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-duration-from-timezone-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Converts a timezone like "-05:00" or "Z" into xs:dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_duration-from-timezone.html : @param $timezone the time zone, in (+|-)HH:MM format :)          declare function functx:duration-from-timezone ( $timezone as xs:string ) as xs:dayTimeDuration { xs:dayTimeDuration( if (not(matches($timezone,'Z|[\+\-]\d{2}:\d{2}'))) then error(xs:QName('functx:Invalid_Timezone_Value')) else if ($timezone = 'Z') then 'PT0S' else replace($timezone,'\+?(\d{2}):\d{2}','PT$1H') ) } ;                     (functx:duration-from-timezone('Z'), functx:duration-from-timezone('-05:00'), functx:duration-from-timezone('+09:00')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-dynamic-path-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Dynamically evaluates a simple XPath path : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_dynamic-path.html : @param $parent the root to start from : @param $path the path expression :)          declare function functx:dynamic-path ( $parent as node() , $path as xs:string ) as item()* { let $nextStep := functx:substring-before-if-contains($path,'/') let $restOfSteps := substring-after($path,'/') for $child in ($parent/*[functx:name-test(name(),$nextStep)], $parent/@*[functx:name-test(name(), substring-after($nextStep,'@'))]) return if ($restOfSteps) then functx:dynamic-path($child, $restOfSteps) else $child } ;                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     (:~ : Performs substring-before, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-before($arg,$delim) else $arg } ;                     let $in-xml := <authors> <author test="abc"> <first>Kate</first> <last>Jones</last> </author> <author> <first>John</first> <a:last xmlns:a="http://a">Doe</a:last> </author> </authors> return (functx:dynamic-path( $in-xml,'author/first')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-dynamic-path-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Dynamically evaluates a simple XPath path : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_dynamic-path.html : @param $parent the root to start from : @param $path the path expression :)          declare function functx:dynamic-path ( $parent as node() , $path as xs:string ) as item()* { let $nextStep := functx:substring-before-if-contains($path,'/') let $restOfSteps := substring-after($path,'/') for $child in ($parent/*[functx:name-test(name(),$nextStep)], $parent/@*[functx:name-test(name(), substring-after($nextStep,'@'))]) return if ($restOfSteps) then functx:dynamic-path($child, $restOfSteps) else $child } ;                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     (:~ : Performs substring-before, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-before($arg,$delim) else $arg } ;                     let $in-xml := <authors> <author test="abc"> <first>Kate</first> <last>Jones</last> </author> <author> <first>John</first> <a:last xmlns:a="http://a">Doe</a:last> </author> </authors> return (name(functx:dynamic-path( $in-xml,'author/@test'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-dynamic-path-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Dynamically evaluates a simple XPath path : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_dynamic-path.html : @param $parent the root to start from : @param $path the path expression :)          declare function functx:dynamic-path ( $parent as node() , $path as xs:string ) as item()* { let $nextStep := functx:substring-before-if-contains($path,'/') let $restOfSteps := substring-after($path,'/') for $child in ($parent/*[functx:name-test(name(),$nextStep)], $parent/@*[functx:name-test(name(), substring-after($nextStep,'@'))]) return if ($restOfSteps) then functx:dynamic-path($child, $restOfSteps) else $child } ;                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     (:~ : Performs substring-before, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-before($arg,$delim) else $arg } ;                     let $in-xml := <authors> <author test="abc"> <first>Kate</first> <last>Jones</last> </author> <author> <first>John</first> <a:last xmlns:a="http://a">Doe</a:last> </author> </authors> return (functx:dynamic-path( $in-xml,'author')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-dynamic-path-4,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Dynamically evaluates a simple XPath path : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_dynamic-path.html : @param $parent the root to start from : @param $path the path expression :)          declare function functx:dynamic-path ( $parent as node() , $path as xs:string ) as item()* { let $nextStep := functx:substring-before-if-contains($path,'/') let $restOfSteps := substring-after($path,'/') for $child in ($parent/*[functx:name-test(name(),$nextStep)], $parent/@*[functx:name-test(name(), substring-after($nextStep,'@'))]) return if ($restOfSteps) then functx:dynamic-path($child, $restOfSteps) else $child } ;                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     (:~ : Performs substring-before, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-before($arg,$delim) else $arg } ;                     let $in-xml := <authors> <author test="abc"> <first>Kate</first> <last>Jones</last> </author> <author> <first>John</first> <a:last xmlns:a="http://a">Doe</a:last> </author> </authors> return (functx:dynamic-path( $in-xml,'author/a:last')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-dynamic-path-all,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Dynamically evaluates a simple XPath path : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_dynamic-path.html : @param $parent the root to start from : @param $path the path expression :)          declare function functx:dynamic-path ( $parent as node() , $path as xs:string ) as item()* {              let $nextStep := functx:substring-before-if-contains($path,'/')              let $restOfSteps := substring-after($path,'/')              for $child in ($parent/*[functx:name-test(name(),$nextStep)], $parent/@*[functx:name-test(name(), substring-after($nextStep,'@'))])              return if ($restOfSteps) then functx:dynamic-path($child, $restOfSteps) else $child           } ;                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean {              $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (                for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')]                 return substring-before($name,':*'))           } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? {              if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg           } ;                     (:~ : Performs substring-before, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? {              if (contains($arg,$delim)) then substring-before($arg,$delim) else $arg           } ;          let $in-xml := <authors> <author test="abc"> <first>Kate</first> <last>Jones</last> </author> <author> <first>John</first> <a:last xmlns:a="http://a">Doe</a:last> </author> </authors>           return document{(functx:dynamic-path( $in-xml,'author/first'),                   name(functx:dynamic-path( $in-xml,'author/@test')),                   functx:dynamic-path( $in-xml,'author'),                   functx:dynamic-path( $in-xml,'author/a:last'))}       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-escape-for-regex-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Escapes regex special characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_escape-for-regex.html : @param $arg the string to escape :)          declare function functx:escape-for-regex ( $arg as xs:string? ) as xs:string { replace($arg, '(\.|\[|\]|\\|\||\-|\^|\$|\?|\*|\+|\{|\}|\(|\))','\\$1') } ;                     (functx:escape-for-regex('5.55')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-escape-for-regex-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Escapes regex special characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_escape-for-regex.html : @param $arg the string to escape :)          declare function functx:escape-for-regex ( $arg as xs:string? ) as xs:string { replace($arg, '(\.|\[|\]|\\|\||\-|\^|\$|\?|\*|\+|\{|\}|\(|\))','\\$1') } ;                     (functx:escape-for-regex('[abc]')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-escape-for-regex-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Escapes regex special characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_escape-for-regex.html : @param $arg the string to escape :)          declare function functx:escape-for-regex ( $arg as xs:string? ) as xs:string { replace($arg, '(\.|\[|\]|\\|\||\-|\^|\$|\?|\*|\+|\{|\}|\(|\))','\\$1') } ;                     (functx:escape-for-regex('5.55'), functx:escape-for-regex('[abc]')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-exclusive-or-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether one (and only one) of two boolean values is true : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_exclusive-or.html : @param $arg1 the first boolean value : @param $arg2 the second boolean value :)          declare function functx:exclusive-or ( $arg1 as xs:boolean? , $arg2 as xs:boolean? ) as xs:boolean? { $arg1 != $arg2 } ;                     (functx:exclusive-or(true(),false())). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-exclusive-or-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether one (and only one) of two boolean values is true : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_exclusive-or.html : @param $arg1 the first boolean value : @param $arg2 the second boolean value :)          declare function functx:exclusive-or ( $arg1 as xs:boolean? , $arg2 as xs:boolean? ) as xs:boolean? { $arg1 != $arg2 } ;                     (functx:exclusive-or(true(),true())). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-exclusive-or-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether one (and only one) of two boolean values is true : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_exclusive-or.html : @param $arg1 the first boolean value : @param $arg2 the second boolean value :)          declare function functx:exclusive-or ( $arg1 as xs:boolean? , $arg2 as xs:boolean? ) as xs:boolean? { $arg1 != $arg2 } ;                     (functx:exclusive-or(4 >                     3,1 >                     2)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-exclusive-or-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Whether one (and only one) of two boolean values is true : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_exclusive-or.html : @param $arg1 the first boolean value : @param $arg2 the second boolean value :)          declare function functx:exclusive-or ( $arg1 as xs:boolean? , $arg2 as xs:boolean? ) as xs:boolean? { $arg1 != $arg2 } ;                     (functx:exclusive-or(true(),false()), functx:exclusive-or(true(),true()), functx:exclusive-or(4 >                     3,1 >                     2)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-first-day-of-month-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Construct a date from a year, month and day : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_date.html : @param $year the year : @param $month the month : @param $day the day :)          declare function functx:date ( $year as xs:anyAtomicType , $month as xs:anyAtomicType , $day as xs:anyAtomicType ) as xs:date { xs:date( concat( functx:pad-integer-to-length(xs:integer($year),4),'-', functx:pad-integer-to-length(xs:integer($month),2),'-', functx:pad-integer-to-length(xs:integer($day),2))) } ;                     (:~ : The first day of the month of a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_first-day-of-month.html : @param $date the date :)          declare function functx:first-day-of-month ( $date as xs:anyAtomicType? ) as xs:date? { functx:date(year-from-date(xs:date($date)), month-from-date(xs:date($date)), 1) } ;                     (:~ : Pads an integer to a desired length by adding leading zeros : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-integer-to-length.html : @param $integerToPad the integer to pad : @param $length the desired length :)          declare function functx:pad-integer-to-length ( $integerToPad as xs:anyAtomicType? , $length as xs:integer ) as xs:string { if ($length < string-length(string($integerToPad))) then error(xs:QName('functx:Integer_Longer_Than_Length')) else concat (functx:repeat-string( '0',$length - string-length(string($integerToPad))), string($integerToPad)) } ;                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:first-day-of-month( xs:date('2004-01-23'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-first-day-of-month-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Construct a date from a year, month and day : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_date.html : @param $year the year : @param $month the month : @param $day the day :)          declare function functx:date ( $year as xs:anyAtomicType , $month as xs:anyAtomicType , $day as xs:anyAtomicType ) as xs:date { xs:date( concat( functx:pad-integer-to-length(xs:integer($year),4),'-', functx:pad-integer-to-length(xs:integer($month),2),'-', functx:pad-integer-to-length(xs:integer($day),2))) } ;                     (:~ : The first day of the month of a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_first-day-of-month.html : @param $date the date :)          declare function functx:first-day-of-month ( $date as xs:anyAtomicType? ) as xs:date? { functx:date(year-from-date(xs:date($date)), month-from-date(xs:date($date)), 1) } ;                     (:~ : Pads an integer to a desired length by adding leading zeros : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-integer-to-length.html : @param $integerToPad the integer to pad : @param $length the desired length :)          declare function functx:pad-integer-to-length ( $integerToPad as xs:anyAtomicType? , $length as xs:integer ) as xs:string { if ($length < string-length(string($integerToPad))) then error(xs:QName('functx:Integer_Longer_Than_Length')) else concat (functx:repeat-string( '0',$length - string-length(string($integerToPad))), string($integerToPad)) } ;                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:first-day-of-month( xs:dateTime('2004-01-23T12:00:13'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-first-day-of-month-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Construct a date from a year, month and day : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_date.html : @param $year the year : @param $month the month : @param $day the day :)          declare function functx:date ( $year as xs:anyAtomicType , $month as xs:anyAtomicType , $day as xs:anyAtomicType ) as xs:date { xs:date( concat( functx:pad-integer-to-length(xs:integer($year),4),'-', functx:pad-integer-to-length(xs:integer($month),2),'-', functx:pad-integer-to-length(xs:integer($day),2))) } ;                     (:~ : The first day of the month of a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_first-day-of-month.html : @param $date the date :)          declare function functx:first-day-of-month ( $date as xs:anyAtomicType? ) as xs:date? { functx:date(year-from-date(xs:date($date)), month-from-date(xs:date($date)), 1) } ;                     (:~ : Pads an integer to a desired length by adding leading zeros : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-integer-to-length.html : @param $integerToPad the integer to pad : @param $length the desired length :)          declare function functx:pad-integer-to-length ( $integerToPad as xs:anyAtomicType? , $length as xs:integer ) as xs:string { if ($length < string-length(string($integerToPad))) then error(xs:QName('functx:Integer_Longer_Than_Length')) else concat (functx:repeat-string( '0',$length - string-length(string($integerToPad))), string($integerToPad)) } ;                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:first-day-of-month('2004-03-23')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-first-day-of-month-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Construct a date from a year, month and day : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_date.html : @param $year the year : @param $month the month : @param $day the day :)          declare function functx:date ( $year as xs:anyAtomicType , $month as xs:anyAtomicType , $day as xs:anyAtomicType ) as xs:date { xs:date( concat( functx:pad-integer-to-length(xs:integer($year),4),'-', functx:pad-integer-to-length(xs:integer($month),2),'-', functx:pad-integer-to-length(xs:integer($day),2))) } ;                     (:~ : The first day of the month of a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_first-day-of-month.html : @param $date the date :)          declare function functx:first-day-of-month ( $date as xs:anyAtomicType? ) as xs:date? { functx:date(year-from-date(xs:date($date)), month-from-date(xs:date($date)), 1) } ;                     (:~ : Pads an integer to a desired length by adding leading zeros : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-integer-to-length.html : @param $integerToPad the integer to pad : @param $length the desired length :)          declare function functx:pad-integer-to-length ( $integerToPad as xs:anyAtomicType? , $length as xs:integer ) as xs:string { if ($length < string-length(string($integerToPad))) then error(xs:QName('functx:Integer_Longer_Than_Length')) else concat (functx:repeat-string( '0',$length - string-length(string($integerToPad))), string($integerToPad)) } ;                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:first-day-of-month( xs:date('2004-01-23')), functx:first-day-of-month( xs:dateTime('2004-01-23T12:00:13')), functx:first-day-of-month('2004-03-23')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-first-day-of-year-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Construct a date from a year, month and day : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_date.html : @param $year the year : @param $month the month : @param $day the day :)          declare function functx:date ( $year as xs:anyAtomicType , $month as xs:anyAtomicType , $day as xs:anyAtomicType ) as xs:date { xs:date( concat( functx:pad-integer-to-length(xs:integer($year),4),'-', functx:pad-integer-to-length(xs:integer($month),2),'-', functx:pad-integer-to-length(xs:integer($day),2))) } ;                     (:~ : The first day of the year of a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_first-day-of-year.html : @param $date the date :)          declare function functx:first-day-of-year ( $date as xs:anyAtomicType? ) as xs:date? { functx:date(year-from-date(xs:date($date)), 1, 1) } ;                     (:~ : Pads an integer to a desired length by adding leading zeros : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-integer-to-length.html : @param $integerToPad the integer to pad : @param $length the desired length :)          declare function functx:pad-integer-to-length ( $integerToPad as xs:anyAtomicType? , $length as xs:integer ) as xs:string { if ($length < string-length(string($integerToPad))) then error(xs:QName('functx:Integer_Longer_Than_Length')) else concat (functx:repeat-string( '0',$length - string-length(string($integerToPad))), string($integerToPad)) } ;                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:first-day-of-year(xs:date('2004-01-23'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-first-day-of-year-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Construct a date from a year, month and day : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_date.html : @param $year the year : @param $month the month : @param $day the day :)          declare function functx:date ( $year as xs:anyAtomicType , $month as xs:anyAtomicType , $day as xs:anyAtomicType ) as xs:date { xs:date( concat( functx:pad-integer-to-length(xs:integer($year),4),'-', functx:pad-integer-to-length(xs:integer($month),2),'-', functx:pad-integer-to-length(xs:integer($day),2))) } ;                     (:~ : The first day of the year of a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_first-day-of-year.html : @param $date the date :)          declare function functx:first-day-of-year ( $date as xs:anyAtomicType? ) as xs:date? { functx:date(year-from-date(xs:date($date)), 1, 1) } ;                     (:~ : Pads an integer to a desired length by adding leading zeros : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-integer-to-length.html : @param $integerToPad the integer to pad : @param $length the desired length :)          declare function functx:pad-integer-to-length ( $integerToPad as xs:anyAtomicType? , $length as xs:integer ) as xs:string { if ($length < string-length(string($integerToPad))) then error(xs:QName('functx:Integer_Longer_Than_Length')) else concat (functx:repeat-string( '0',$length - string-length(string($integerToPad))), string($integerToPad)) } ;                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:first-day-of-year( xs:dateTime('2004-01-23T12:00:13'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-first-day-of-year-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Construct a date from a year, month and day : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_date.html : @param $year the year : @param $month the month : @param $day the day :)          declare function functx:date ( $year as xs:anyAtomicType , $month as xs:anyAtomicType , $day as xs:anyAtomicType ) as xs:date { xs:date( concat( functx:pad-integer-to-length(xs:integer($year),4),'-', functx:pad-integer-to-length(xs:integer($month),2),'-', functx:pad-integer-to-length(xs:integer($day),2))) } ;                     (:~ : The first day of the year of a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_first-day-of-year.html : @param $date the date :)          declare function functx:first-day-of-year ( $date as xs:anyAtomicType? ) as xs:date? { functx:date(year-from-date(xs:date($date)), 1, 1) } ;                     (:~ : Pads an integer to a desired length by adding leading zeros : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-integer-to-length.html : @param $integerToPad the integer to pad : @param $length the desired length :)          declare function functx:pad-integer-to-length ( $integerToPad as xs:anyAtomicType? , $length as xs:integer ) as xs:string { if ($length < string-length(string($integerToPad))) then error(xs:QName('functx:Integer_Longer_Than_Length')) else concat (functx:repeat-string( '0',$length - string-length(string($integerToPad))), string($integerToPad)) } ;                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:first-day-of-year('2004-03-23')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-first-day-of-year-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Construct a date from a year, month and day : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_date.html : @param $year the year : @param $month the month : @param $day the day :)          declare function functx:date ( $year as xs:anyAtomicType , $month as xs:anyAtomicType , $day as xs:anyAtomicType ) as xs:date { xs:date( concat( functx:pad-integer-to-length(xs:integer($year),4),'-', functx:pad-integer-to-length(xs:integer($month),2),'-', functx:pad-integer-to-length(xs:integer($day),2))) } ;                     (:~ : The first day of the year of a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_first-day-of-year.html : @param $date the date :)          declare function functx:first-day-of-year ( $date as xs:anyAtomicType? ) as xs:date? { functx:date(year-from-date(xs:date($date)), 1, 1) } ;                     (:~ : Pads an integer to a desired length by adding leading zeros : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-integer-to-length.html : @param $integerToPad the integer to pad : @param $length the desired length :)          declare function functx:pad-integer-to-length ( $integerToPad as xs:anyAtomicType? , $length as xs:integer ) as xs:string { if ($length < string-length(string($integerToPad))) then error(xs:QName('functx:Integer_Longer_Than_Length')) else concat (functx:repeat-string( '0',$length - string-length(string($integerToPad))), string($integerToPad)) } ;                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:first-day-of-year(xs:date('2004-01-23')), functx:first-day-of-year( xs:dateTime('2004-01-23T12:00:13')), functx:first-day-of-year('2004-03-23')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-first-node-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : The XML node in a sequence that appears first in document order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_first-node.html : @param $nodes the sequence of nodes :)          declare function functx:first-node ( $nodes as node()* ) as node()? { ($nodes/.)[1] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:first-node($in-xml//fName)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-first-node-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : The XML node in a sequence that appears first in document order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_first-node.html : @param $nodes the sequence of nodes :)          declare function functx:first-node ( $nodes as node()* ) as node()? { ($nodes/.)[1] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:first-node( ($in-xml//lName, $in-xml//fName) )). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-first-node-all,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : The XML node in a sequence that appears first in document order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_first-node.html : @param $nodes the sequence of nodes :)          declare function functx:first-node ( $nodes as node()* ) as node()? { ($nodes/.)[1] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:first-node($in-xml//fName), functx:first-node( ($in-xml//lName, $in-xml//fName) )). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-follows-not-descendant-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node follows another without being its descendant : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_follows-not-descendant.html : @param $a the first node : @param $b the second node :)          declare function functx:follows-not-descendant ( $a as node()? , $b as node()? ) as xs:boolean { $a >> $b and empty($b intersect $a/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:follows-not-descendant( $in-xml//author[2],$in-xml//author[1])). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-follows-not-descendant-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node follows another without being its descendant : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_follows-not-descendant.html : @param $a the first node : @param $b the second node :)          declare function functx:follows-not-descendant ( $a as node()? , $b as node()? ) as xs:boolean { $a >> $b and empty($b intersect $a/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:follows-not-descendant( $in-xml//author[1]/fName, $in-xml//author[1])). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-follows-not-descendant-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node follows another without being its descendant : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_follows-not-descendant.html : @param $a the first node : @param $b the second node :)          declare function functx:follows-not-descendant ( $a as node()? , $b as node()? ) as xs:boolean { $a >> $b and empty($b intersect $a/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:follows-not-descendant( $in-xml//author[1],$in-xml//author[2])). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-follows-not-descendant-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node follows another without being its descendant : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_follows-not-descendant.html : @param $a the first node : @param $b the second node :)          declare function functx:follows-not-descendant ( $a as node()? , $b as node()? ) as xs:boolean { $a >> $b and empty($b intersect $a/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:follows-not-descendant( $in-xml//author[2],$in-xml//author[1]), functx:follows-not-descendant( $in-xml//author[1]/fName, $in-xml//author[1]), functx:follows-not-descendant( $in-xml//author[1],$in-xml//author[2])))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-format-as-title-en-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Moves title words like "the" and "a" to the end of strings : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_format-as-title-en.html : @param $titles the titles to format :)          declare function functx:format-as-title-en ( $titles as xs:string* ) as xs:string* { let $wordsToMoveToEnd := ('A', 'An', 'The') for $title in $titles let $firstWord := functx:substring-before-match($title,'\W') return if ($firstWord = $wordsToMoveToEnd) then replace($title,'(.*?)\W(.*)', '$2, $1') else $title } ;                     (:~ : The substring before the first text that matches a regex : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-match.html : @param $arg the string to substring : @param $regex the regular expression :)          declare function functx:substring-before-match ( $arg as xs:string? , $regex as xs:string ) as xs:string? { tokenize($arg,$regex)[1] } ;                     (functx:format-as-title-en( ('A Midsummer Night''s Dream', 'The Merchant of Venice', 'Hamlet'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-fragment-from-uri-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Returns the fragment from a URI : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_fragment-from-uri.html : @param $uri the URI :)          declare function functx:fragment-from-uri ( $uri as xs:string? ) as xs:string? { substring-after($uri,'#') } ;                     (functx:fragment-from-uri( 'http://datypic.com/index.htm#abc')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-fragment-from-uri-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Returns the fragment from a URI : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_fragment-from-uri.html : @param $uri the URI :)          declare function functx:fragment-from-uri ( $uri as xs:string? ) as xs:string? { substring-after($uri,'#') } ;                     (functx:fragment-from-uri( 'http://datypic.com/index.htm')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-fragment-from-uri-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Returns the fragment from a URI : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_fragment-from-uri.html : @param $uri the URI :)          declare function functx:fragment-from-uri ( $uri as xs:string? ) as xs:string? { substring-after($uri,'#') } ;                     (functx:fragment-from-uri( 'http://datypic.com/index.htm#abc'), functx:fragment-from-uri( 'http://datypic.com/index.htm')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-get-matches-and-non-matches-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Splits a string into matching and non-matching regions : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_get-matches-and-non-matches.html : @param $string the string to split : @param $regex the pattern :)          declare function functx:get-matches-and-non-matches ( $string as xs:string? , $regex as xs:string ) as element()* { let $iomf := functx:index-of-match-first($string, $regex) return if (empty($iomf)) then <non-match>{$string}</non-match> else if ($iomf > 1) then (<non-match>{substring($string,1,$iomf - 1)}</non-match>, functx:get-matches-and-non-matches( substring($string,$iomf),$regex)) else let $length := string-length($string) - string-length(functx:replace-first($string, $regex,'')) return (<match>{substring($string,1,$length)}</match>, if (string-length($string) > $length) then functx:get-matches-and-non-matches( substring($string,$length + 1),$regex) else ()) } ;                     (:~ : The first position of a matching substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-match-first.html : @param $arg the string : @param $pattern the pattern to match :)          declare function functx:index-of-match-first ( $arg as xs:string? , $pattern as xs:string ) as xs:integer? { if (matches($arg,$pattern)) then string-length(tokenize($arg, $pattern)[1]) + 1 else () } ;                     (:~ : Replaces the first match of a pattern : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-first.html : @param $arg the entire string to change : @param $pattern the pattern of characters to replace : @param $replacement the replacement string :)          declare function functx:replace-first ( $arg as xs:string? , $pattern as xs:string , $replacement as xs:string ) as xs:string { replace($arg, concat('(^.*?)', $pattern), concat('$1',$replacement)) } ;                     (functx:get-matches-and-non-matches( 'abc123def', '\d+')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-get-matches-and-non-matches-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Splits a string into matching and non-matching regions : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_get-matches-and-non-matches.html : @param $string the string to split : @param $regex the pattern :)          declare function functx:get-matches-and-non-matches ( $string as xs:string? , $regex as xs:string ) as element()* { let $iomf := functx:index-of-match-first($string, $regex) return if (empty($iomf)) then <non-match>{$string}</non-match> else if ($iomf > 1) then (<non-match>{substring($string,1,$iomf - 1)}</non-match>, functx:get-matches-and-non-matches( substring($string,$iomf),$regex)) else let $length := string-length($string) - string-length(functx:replace-first($string, $regex,'')) return (<match>{substring($string,1,$length)}</match>, if (string-length($string) > $length) then functx:get-matches-and-non-matches( substring($string,$length + 1),$regex) else ()) } ;                     (:~ : The first position of a matching substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-match-first.html : @param $arg the string : @param $pattern the pattern to match :)          declare function functx:index-of-match-first ( $arg as xs:string? , $pattern as xs:string ) as xs:integer? { if (matches($arg,$pattern)) then string-length(tokenize($arg, $pattern)[1]) + 1 else () } ;                     (:~ : Replaces the first match of a pattern : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-first.html : @param $arg the entire string to change : @param $pattern the pattern of characters to replace : @param $replacement the replacement string :)          declare function functx:replace-first ( $arg as xs:string? , $pattern as xs:string , $replacement as xs:string ) as xs:string { replace($arg, concat('(^.*?)', $pattern), concat('$1',$replacement)) } ;                     (functx:get-matches-and-non-matches( 'abc123def', '\d')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-get-matches-and-non-matches-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Splits a string into matching and non-matching regions : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_get-matches-and-non-matches.html : @param $string the string to split : @param $regex the pattern :)          declare function functx:get-matches-and-non-matches ( $string as xs:string? , $regex as xs:string ) as element()* { let $iomf := functx:index-of-match-first($string, $regex) return if (empty($iomf)) then <non-match>{$string}</non-match> else if ($iomf > 1) then (<non-match>{substring($string,1,$iomf - 1)}</non-match>, functx:get-matches-and-non-matches( substring($string,$iomf),$regex)) else let $length := string-length($string) - string-length(functx:replace-first($string, $regex,'')) return (<match>{substring($string,1,$length)}</match>, if (string-length($string) > $length) then functx:get-matches-and-non-matches( substring($string,$length + 1),$regex) else ()) } ;                     (:~ : The first position of a matching substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-match-first.html : @param $arg the string : @param $pattern the pattern to match :)          declare function functx:index-of-match-first ( $arg as xs:string? , $pattern as xs:string ) as xs:integer? { if (matches($arg,$pattern)) then string-length(tokenize($arg, $pattern)[1]) + 1 else () } ;                     (:~ : Replaces the first match of a pattern : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-first.html : @param $arg the entire string to change : @param $pattern the pattern of characters to replace : @param $replacement the replacement string :)          declare function functx:replace-first ( $arg as xs:string? , $pattern as xs:string , $replacement as xs:string ) as xs:string { replace($arg, concat('(^.*?)', $pattern), concat('$1',$replacement)) } ;                     (functx:get-matches-and-non-matches( 'abc123def', '[a-z]{2}')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-get-matches-and-non-matches-all,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Splits a string into matching and non-matching regions : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_get-matches-and-non-matches.html : @param $string the string to split : @param $regex the pattern :)          declare function functx:get-matches-and-non-matches ( $string as xs:string? , $regex as xs:string ) as element()* { let $iomf := functx:index-of-match-first($string, $regex) return if (empty($iomf)) then <non-match>{$string}</non-match> else if ($iomf > 1) then (<non-match>{substring($string,1,$iomf - 1)}</non-match>, functx:get-matches-and-non-matches( substring($string,$iomf),$regex)) else let $length := string-length($string) - string-length(functx:replace-first($string, $regex,'')) return (<match>{substring($string,1,$length)}</match>, if (string-length($string) > $length) then functx:get-matches-and-non-matches( substring($string,$length + 1),$regex) else ()) } ;                     (:~ : The first position of a matching substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-match-first.html : @param $arg the string : @param $pattern the pattern to match :)          declare function functx:index-of-match-first ( $arg as xs:string? , $pattern as xs:string ) as xs:integer? { if (matches($arg,$pattern)) then string-length(tokenize($arg, $pattern)[1]) + 1 else () } ;                     (:~ : Replaces the first match of a pattern : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-first.html : @param $arg the entire string to change : @param $pattern the pattern of characters to replace : @param $replacement the replacement string :)          declare function functx:replace-first ( $arg as xs:string? , $pattern as xs:string , $replacement as xs:string ) as xs:string { replace($arg, concat('(^.*?)', $pattern), concat('$1',$replacement)) } ;                     (functx:get-matches-and-non-matches( 'abc123def', '\d+'), functx:get-matches-and-non-matches( 'abc123def', '\d'), functx:get-matches-and-non-matches( 'abc123def', '[a-z]{2}')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-get-matches-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Splits a string into matching and non-matching regions : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_get-matches-and-non-matches.html : @param $string the string to split : @param $regex the pattern :)          declare function functx:get-matches-and-non-matches ( $string as xs:string? , $regex as xs:string ) as element()* { let $iomf := functx:index-of-match-first($string, $regex) return if (empty($iomf)) then <non-match>{$string}</non-match> else if ($iomf > 1) then (<non-match>{substring($string,1,$iomf - 1)}</non-match>, functx:get-matches-and-non-matches( substring($string,$iomf),$regex)) else let $length := string-length($string) - string-length(functx:replace-first($string, $regex,'')) return (<match>{substring($string,1,$length)}</match>, if (string-length($string) > $length) then functx:get-matches-and-non-matches( substring($string,$length + 1),$regex) else ()) } ;                     (:~ : Return the matching regions of a string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_get-matches.html : @param $string the string to split : @param $regex the pattern :)          declare function functx:get-matches ( $string as xs:string? , $regex as xs:string ) as xs:string* { functx:get-matches-and-non-matches($string,$regex)/ string(self::match) } ;                     (:~ : The first position of a matching substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-match-first.html : @param $arg the string : @param $pattern the pattern to match :)          declare function functx:index-of-match-first ( $arg as xs:string? , $pattern as xs:string ) as xs:integer? { if (matches($arg,$pattern)) then string-length(tokenize($arg, $pattern)[1]) + 1 else () } ;                     (:~ : Replaces the first match of a pattern : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-first.html : @param $arg the entire string to change : @param $pattern the pattern of characters to replace : @param $replacement the replacement string :)          declare function functx:replace-first ( $arg as xs:string? , $pattern as xs:string , $replacement as xs:string ) as xs:string { replace($arg, concat('(^.*?)', $pattern), concat('$1',$replacement)) } ;                     (functx:get-matches( 'abc123def', '\d+')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-get-matches-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Splits a string into matching and non-matching regions : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_get-matches-and-non-matches.html : @param $string the string to split : @param $regex the pattern :)          declare function functx:get-matches-and-non-matches ( $string as xs:string? , $regex as xs:string ) as element()* { let $iomf := functx:index-of-match-first($string, $regex) return if (empty($iomf)) then <non-match>{$string}</non-match> else if ($iomf > 1) then (<non-match>{substring($string,1,$iomf - 1)}</non-match>, functx:get-matches-and-non-matches( substring($string,$iomf),$regex)) else let $length := string-length($string) - string-length(functx:replace-first($string, $regex,'')) return (<match>{substring($string,1,$length)}</match>, if (string-length($string) > $length) then functx:get-matches-and-non-matches( substring($string,$length + 1),$regex) else ()) } ;                     (:~ : Return the matching regions of a string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_get-matches.html : @param $string the string to split : @param $regex the pattern :)          declare function functx:get-matches ( $string as xs:string? , $regex as xs:string ) as xs:string* { functx:get-matches-and-non-matches($string,$regex)/ string(self::match) } ;                     (:~ : The first position of a matching substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-match-first.html : @param $arg the string : @param $pattern the pattern to match :)          declare function functx:index-of-match-first ( $arg as xs:string? , $pattern as xs:string ) as xs:integer? { if (matches($arg,$pattern)) then string-length(tokenize($arg, $pattern)[1]) + 1 else () } ;                     (:~ : Replaces the first match of a pattern : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-first.html : @param $arg the entire string to change : @param $pattern the pattern of characters to replace : @param $replacement the replacement string :)          declare function functx:replace-first ( $arg as xs:string? , $pattern as xs:string , $replacement as xs:string ) as xs:string { replace($arg, concat('(^.*?)', $pattern), concat('$1',$replacement)) } ;                     (functx:get-matches( 'abc123def', '\d')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-get-matches-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Splits a string into matching and non-matching regions : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_get-matches-and-non-matches.html : @param $string the string to split : @param $regex the pattern :)          declare function functx:get-matches-and-non-matches ( $string as xs:string? , $regex as xs:string ) as element()* { let $iomf := functx:index-of-match-first($string, $regex) return if (empty($iomf)) then <non-match>{$string}</non-match> else if ($iomf > 1) then (<non-match>{substring($string,1,$iomf - 1)}</non-match>, functx:get-matches-and-non-matches( substring($string,$iomf),$regex)) else let $length := string-length($string) - string-length(functx:replace-first($string, $regex,'')) return (<match>{substring($string,1,$length)}</match>, if (string-length($string) > $length) then functx:get-matches-and-non-matches( substring($string,$length + 1),$regex) else ()) } ;                     (:~ : Return the matching regions of a string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_get-matches.html : @param $string the string to split : @param $regex the pattern :)          declare function functx:get-matches ( $string as xs:string? , $regex as xs:string ) as xs:string* { functx:get-matches-and-non-matches($string,$regex)/ string(self::match) } ;                     (:~ : The first position of a matching substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-match-first.html : @param $arg the string : @param $pattern the pattern to match :)          declare function functx:index-of-match-first ( $arg as xs:string? , $pattern as xs:string ) as xs:integer? { if (matches($arg,$pattern)) then string-length(tokenize($arg, $pattern)[1]) + 1 else () } ;                     (:~ : Replaces the first match of a pattern : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-first.html : @param $arg the entire string to change : @param $pattern the pattern of characters to replace : @param $replacement the replacement string :)          declare function functx:replace-first ( $arg as xs:string? , $pattern as xs:string , $replacement as xs:string ) as xs:string { replace($arg, concat('(^.*?)', $pattern), concat('$1',$replacement)) } ;                     (functx:get-matches( 'abc123def', '[a-z]{2}')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-get-matches-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Splits a string into matching and non-matching regions : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_get-matches-and-non-matches.html : @param $string the string to split : @param $regex the pattern :)          declare function functx:get-matches-and-non-matches ( $string as xs:string? , $regex as xs:string ) as element()* { let $iomf := functx:index-of-match-first($string, $regex) return if (empty($iomf)) then <non-match>{$string}</non-match> else if ($iomf > 1) then (<non-match>{substring($string,1,$iomf - 1)}</non-match>, functx:get-matches-and-non-matches( substring($string,$iomf),$regex)) else let $length := string-length($string) - string-length(functx:replace-first($string, $regex,'')) return (<match>{substring($string,1,$length)}</match>, if (string-length($string) > $length) then functx:get-matches-and-non-matches( substring($string,$length + 1),$regex) else ()) } ;                     (:~ : Return the matching regions of a string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_get-matches.html : @param $string the string to split : @param $regex the pattern :)          declare function functx:get-matches ( $string as xs:string? , $regex as xs:string ) as xs:string* { functx:get-matches-and-non-matches($string,$regex)/ string(self::match) } ;                     (:~ : The first position of a matching substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-match-first.html : @param $arg the string : @param $pattern the pattern to match :)          declare function functx:index-of-match-first ( $arg as xs:string? , $pattern as xs:string ) as xs:integer? { if (matches($arg,$pattern)) then string-length(tokenize($arg, $pattern)[1]) + 1 else () } ;                     (:~ : Replaces the first match of a pattern : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-first.html : @param $arg the entire string to change : @param $pattern the pattern of characters to replace : @param $replacement the replacement string :)          declare function functx:replace-first ( $arg as xs:string? , $pattern as xs:string , $replacement as xs:string ) as xs:string { replace($arg, concat('(^.*?)', $pattern), concat('$1',$replacement)) } ;                     (functx:get-matches( 'abc123def', '\d+'), functx:get-matches( 'abc123def', '\d'), functx:get-matches( 'abc123def', '[a-z]{2}')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-has-element-only-content-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has element-only content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-element-only-content.html : @param $element the XML element to test :)          declare function functx:has-element-only-content ( $element as element() ) as xs:boolean { not($element/text()[normalize-space(.) != '']) and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> <h><x>xml</x><y>xml</y></h> <i> <x>xml</x> <y>xml</y> </i> </in-xml> return (functx:has-element-only-content($in-xml/a)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-has-element-only-content-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has element-only content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-element-only-content.html : @param $element the XML element to test :)          declare function functx:has-element-only-content ( $element as element() ) as xs:boolean { not($element/text()[normalize-space(.) != '']) and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> <h><x>xml</x><y>xml</y></h> <i> <x>xml</x> <y>xml</y> </i> </in-xml> return (functx:has-element-only-content($in-xml/b)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-has-element-only-content-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has element-only content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-element-only-content.html : @param $element the XML element to test :)          declare function functx:has-element-only-content ( $element as element() ) as xs:boolean { not($element/text()[normalize-space(.) != '']) and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> <h><x>xml</x><y>xml</y></h> <i> <x>xml</x> <y>xml</y> </i> </in-xml> return (functx:has-element-only-content($in-xml/c)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-has-element-only-content-4,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has element-only content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-element-only-content.html : @param $element the XML element to test :)          declare function functx:has-element-only-content ( $element as element() ) as xs:boolean { not($element/text()[normalize-space(.) != '']) and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> <h><x>xml</x><y>xml</y></h> <i> <x>xml</x> <y>xml</y> </i> </in-xml> return (functx:has-element-only-content($in-xml/d)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-has-element-only-content-5,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has element-only content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-element-only-content.html : @param $element the XML element to test :)          declare function functx:has-element-only-content ( $element as element() ) as xs:boolean { not($element/text()[normalize-space(.) != '']) and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> <h><x>xml</x><y>xml</y></h> <i> <x>xml</x> <y>xml</y> </i> </in-xml> return (functx:has-element-only-content($in-xml/e)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-has-element-only-content-6,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has element-only content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-element-only-content.html : @param $element the XML element to test :)          declare function functx:has-element-only-content ( $element as element() ) as xs:boolean { not($element/text()[normalize-space(.) != '']) and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> <h><x>xml</x><y>xml</y></h> <i> <x>xml</x> <y>xml</y> </i> </in-xml> return (functx:has-element-only-content($in-xml/f)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-has-element-only-content-7,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has element-only content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-element-only-content.html : @param $element the XML element to test :)          declare function functx:has-element-only-content ( $element as element() ) as xs:boolean { not($element/text()[normalize-space(.) != '']) and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> <h><x>xml</x><y>xml</y></h> <i> <x>xml</x> <y>xml</y> </i> </in-xml> return (functx:has-element-only-content($in-xml/g)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-has-element-only-content-8,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has element-only content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-element-only-content.html : @param $element the XML element to test :)          declare function functx:has-element-only-content ( $element as element() ) as xs:boolean { not($element/text()[normalize-space(.) != '']) and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> <h><x>xml</x><y>xml</y></h> <i> <x>xml</x> <y>xml</y> </i> </in-xml> return (functx:has-element-only-content($in-xml/h)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-has-element-only-content-9,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has element-only content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-element-only-content.html : @param $element the XML element to test :)          declare function functx:has-element-only-content ( $element as element() ) as xs:boolean { not($element/text()[normalize-space(.) != '']) and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> <h><x>xml</x><y>xml</y></h> <i> <x>xml</x> <y>xml</y> </i> </in-xml> return (functx:has-element-only-content($in-xml/i)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-has-element-only-content-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has element-only content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-element-only-content.html : @param $element the XML element to test :)          declare function functx:has-element-only-content ( $element as element() ) as xs:boolean { not($element/text()[normalize-space(.) != '']) and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> <h><x>xml</x><y>xml</y></h> <i> <x>xml</x> <y>xml</y> </i> </in-xml> return (functx:has-element-only-content($in-xml/a), functx:has-element-only-content($in-xml/b), functx:has-element-only-content($in-xml/c), functx:has-element-only-content($in-xml/d), functx:has-element-only-content($in-xml/e), functx:has-element-only-content($in-xml/f), functx:has-element-only-content($in-xml/g), functx:has-element-only-content($in-xml/h), functx:has-element-only-content($in-xml/i)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-has-empty-content-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has empty content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-empty-content.html : @param $element the XML element to test :)          declare function functx:has-empty-content ( $element as element() ) as xs:boolean { not($element/node()) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-empty-content($in-xml/a)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-has-empty-content-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has empty content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-empty-content.html : @param $element the XML element to test :)          declare function functx:has-empty-content ( $element as element() ) as xs:boolean { not($element/node()) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-empty-content($in-xml/b)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-has-empty-content-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has empty content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-empty-content.html : @param $element the XML element to test :)          declare function functx:has-empty-content ( $element as element() ) as xs:boolean { not($element/node()) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-empty-content($in-xml/c)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-has-empty-content-4,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has empty content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-empty-content.html : @param $element the XML element to test :)          declare function functx:has-empty-content ( $element as element() ) as xs:boolean { not($element/node()) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-empty-content($in-xml/d)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-has-empty-content-5,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has empty content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-empty-content.html : @param $element the XML element to test :)          declare function functx:has-empty-content ( $element as element() ) as xs:boolean { not($element/node()) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-empty-content($in-xml/e)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-has-empty-content-6,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has empty content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-empty-content.html : @param $element the XML element to test :)          declare function functx:has-empty-content ( $element as element() ) as xs:boolean { not($element/node()) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-empty-content($in-xml/f)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-has-empty-content-7,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has empty content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-empty-content.html : @param $element the XML element to test :)          declare function functx:has-empty-content ( $element as element() ) as xs:boolean { not($element/node()) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-empty-content($in-xml/g)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-has-empty-content-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has empty content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-empty-content.html : @param $element the XML element to test :)          declare function functx:has-empty-content ( $element as element() ) as xs:boolean { not($element/node()) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-empty-content($in-xml/a), functx:has-empty-content($in-xml/b), functx:has-empty-content($in-xml/c), functx:has-empty-content($in-xml/d), functx:has-empty-content($in-xml/e), functx:has-empty-content($in-xml/f), functx:has-empty-content($in-xml/g)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-has-mixed-content-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has mixed content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-mixed-content.html : @param $element the XML element to test :)          declare function functx:has-mixed-content ( $element as element() ) as xs:boolean { $element/text()[normalize-space(.) != ''] and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-mixed-content($in-xml/a)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-has-mixed-content-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has mixed content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-mixed-content.html : @param $element the XML element to test :)          declare function functx:has-mixed-content ( $element as element() ) as xs:boolean { $element/text()[normalize-space(.) != ''] and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-mixed-content($in-xml/b)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-has-mixed-content-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has mixed content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-mixed-content.html : @param $element the XML element to test :)          declare function functx:has-mixed-content ( $element as element() ) as xs:boolean { $element/text()[normalize-space(.) != ''] and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-mixed-content($in-xml/c)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-has-mixed-content-4,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has mixed content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-mixed-content.html : @param $element the XML element to test :)          declare function functx:has-mixed-content ( $element as element() ) as xs:boolean { $element/text()[normalize-space(.) != ''] and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-mixed-content($in-xml/d)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-has-mixed-content-5,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has mixed content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-mixed-content.html : @param $element the XML element to test :)          declare function functx:has-mixed-content ( $element as element() ) as xs:boolean { $element/text()[normalize-space(.) != ''] and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-mixed-content($in-xml/e)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-has-mixed-content-6,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has mixed content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-mixed-content.html : @param $element the XML element to test :)          declare function functx:has-mixed-content ( $element as element() ) as xs:boolean { $element/text()[normalize-space(.) != ''] and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-mixed-content($in-xml/f)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-has-mixed-content-7,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has mixed content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-mixed-content.html : @param $element the XML element to test :)          declare function functx:has-mixed-content ( $element as element() ) as xs:boolean { $element/text()[normalize-space(.) != ''] and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-mixed-content($in-xml/g)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-has-mixed-content-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has mixed content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-mixed-content.html : @param $element the XML element to test :)          declare function functx:has-mixed-content ( $element as element() ) as xs:boolean { $element/text()[normalize-space(.) != ''] and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-mixed-content($in-xml/a), functx:has-mixed-content($in-xml/b), functx:has-mixed-content($in-xml/c), functx:has-mixed-content($in-xml/d), functx:has-mixed-content($in-xml/e), functx:has-mixed-content($in-xml/f), functx:has-mixed-content($in-xml/g)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-has-simple-content-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has simple content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-simple-content.html : @param $element the XML element to test :)          declare function functx:has-simple-content ( $element as element() ) as xs:boolean { $element/text() and not($element/*) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> </in-xml> return (functx:has-simple-content($in-xml/a)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-has-simple-content-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has simple content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-simple-content.html : @param $element the XML element to test :)          declare function functx:has-simple-content ( $element as element() ) as xs:boolean { $element/text() and not($element/*) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> </in-xml> return (functx:has-simple-content($in-xml/b)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-has-simple-content-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has simple content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-simple-content.html : @param $element the XML element to test :)          declare function functx:has-simple-content ( $element as element() ) as xs:boolean { $element/text() and not($element/*) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> </in-xml> return (functx:has-simple-content($in-xml/c)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-has-simple-content-4,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has simple content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-simple-content.html : @param $element the XML element to test :)          declare function functx:has-simple-content ( $element as element() ) as xs:boolean { $element/text() and not($element/*) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> </in-xml> return (functx:has-simple-content($in-xml/d)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-has-simple-content-5,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has simple content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-simple-content.html : @param $element the XML element to test :)          declare function functx:has-simple-content ( $element as element() ) as xs:boolean { $element/text() and not($element/*) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> </in-xml> return (functx:has-simple-content($in-xml/e)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-has-simple-content-6,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has simple content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-simple-content.html : @param $element the XML element to test :)          declare function functx:has-simple-content ( $element as element() ) as xs:boolean { $element/text() and not($element/*) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> </in-xml> return (functx:has-simple-content($in-xml/f)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-has-simple-content-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has simple content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-simple-content.html : @param $element the XML element to test :)          declare function functx:has-simple-content ( $element as element() ) as xs:boolean { $element/text() and not($element/*) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> </in-xml> return (functx:has-simple-content($in-xml/a), functx:has-simple-content($in-xml/b), functx:has-simple-content($in-xml/c), functx:has-simple-content($in-xml/d), functx:has-simple-content($in-xml/e), functx:has-simple-content($in-xml/f)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-id-untyped-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Gets XML element(s) that have an attribute with a particular value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_id-untyped.html : @param $node the root node(s) to start from : @param $id the "id" to find :)          declare function functx:id-untyped ( $node as node()* , $id as xs:anyAtomicType ) as element()* { $node//*[@* = $id] } ;                     let $in-xml := <in-xml> <a id="A001">abc</a> <b foo="A001">def</b> <c id="B001">ghi</c> </in-xml> return (functx:id-untyped($in-xml,'B001')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-id-untyped-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Gets XML element(s) that have an attribute with a particular value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_id-untyped.html : @param $node the root node(s) to start from : @param $id the "id" to find :)          declare function functx:id-untyped ( $node as node()* , $id as xs:anyAtomicType ) as element()* { $node//*[@* = $id] } ;                     let $in-xml := <in-xml> <a id="A001">abc</a> <b foo="A001">def</b> <c id="B001">ghi</c> </in-xml> return (functx:id-untyped($in-xml,'A001')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-id-untyped-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Gets XML element(s) that have an attribute with a particular value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_id-untyped.html : @param $node the root node(s) to start from : @param $id the "id" to find :)          declare function functx:id-untyped ( $node as node()* , $id as xs:anyAtomicType ) as element()* { $node//*[@* = $id] } ;                     let $in-xml := <in-xml> <a id="A001">abc</a> <b foo="A001">def</b> <c id="B001">ghi</c> </in-xml> return (functx:id-untyped($in-xml,'C001')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-id-untyped-all,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Gets XML element(s) that have an attribute with a particular value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_id-untyped.html : @param $node the root node(s) to start from : @param $id the "id" to find :)          declare function functx:id-untyped ( $node as node()* , $id as xs:anyAtomicType ) as element()* { $node//*[@* = $id] } ;                     let $in-xml := <in-xml> <a id="A001">abc</a> <b foo="A001">def</b> <c id="B001">ghi</c> </in-xml> return (functx:id-untyped($in-xml,'B001'), functx:id-untyped($in-xml,'A001'), functx:id-untyped($in-xml,'C001')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-if-absent-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not empty, otherwise the second argument : : @author W3C XML Query WG : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-absent.html : @param $arg the item(s) that may be absent : @param $value the item(s) to use if the item is absent :)          declare function functx:if-absent ( $arg as item()* , $value as item()* ) as item()* { if (exists($arg)) then $arg else $value } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="69.99"/> <price value="49.99" discount=""/> </prices> return (data(functx:if-absent( $in-xml//price[1]/@discount, 0))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-if-absent-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not empty, otherwise the second argument : : @author W3C XML Query WG : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-absent.html : @param $arg the item(s) that may be absent : @param $value the item(s) to use if the item is absent :)          declare function functx:if-absent ( $arg as item()* , $value as item()* ) as item()* { if (exists($arg)) then $arg else $value } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="69.99"/> <price value="49.99" discount=""/> </prices> return (data(functx:if-absent( $in-xml//price[3]/@discount, 0)))) = (0). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-if-absent-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not empty, otherwise the second argument : : @author W3C XML Query WG : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-absent.html : @param $arg the item(s) that may be absent : @param $value the item(s) to use if the item is absent :)          declare function functx:if-absent ( $arg as item()* , $value as item()* ) as item()* { if (exists($arg)) then $arg else $value } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="69.99"/> <price value="49.99" discount=""/> </prices> return (data(functx:if-absent( $in-xml//price[4]/@discount, 0))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-if-absent-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not empty, otherwise the second argument : : @author W3C XML Query WG : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-absent.html : @param $arg the item(s) that may be absent : @param $value the item(s) to use if the item is absent :)          declare function functx:if-absent ( $arg as item()* , $value as item()* ) as item()* { if (exists($arg)) then $arg else $value } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="69.99"/> <price value="49.99" discount=""/> </prices> return (data(functx:if-absent( $in-xml//price[1]/@discount, 0)), data(functx:if-absent( $in-xml//price[3]/@discount, 0)), data(functx:if-absent( $in-xml//price[4]/@discount, 0))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-if-empty-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     let $in-xml := <prices> <price discount="10.00">29.99</price> <price discount="6.00">39.99</price> <price></price> <price discount="">49.99</price> </prices> return (functx:if-empty($in-xml//price[1], 0)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-if-empty-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     let $in-xml := <prices> <price discount="10.00">29.99</price> <price discount="6.00">39.99</price> <price></price> <price discount="">49.99</price> </prices> return (functx:if-empty($in-xml//price[3], 0))) = (0). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-if-empty-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     let $in-xml := <prices> <price discount="10.00">29.99</price> <price discount="6.00">39.99</price> <price></price> <price discount="">49.99</price> </prices> return (functx:if-empty($in-xml//price[99], 0))) = (0). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-if-empty-4,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     let $in-xml := <prices> <price discount="10.00">29.99</price> <price discount="6.00">39.99</price> <price></price> <price discount="">49.99</price> </prices> return (functx:if-empty($in-xml//price[1]/@discount, 0)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-if-empty-5,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     let $in-xml := <prices> <price discount="10.00">29.99</price> <price discount="6.00">39.99</price> <price></price> <price discount="">49.99</price> </prices> return (functx:if-empty($in-xml//price[3]/@discount, 0))) = (0). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-if-empty-6,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     let $in-xml := <prices> <price discount="10.00">29.99</price> <price discount="6.00">39.99</price> <price></price> <price discount="">49.99</price> </prices> return (functx:if-empty($in-xml//price[4]/@discount, 0))) = (0). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-if-empty-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     let $in-xml := <prices> <price discount="10.00">29.99</price> <price discount="6.00">39.99</price> <price></price> <price discount="">49.99</price> </prices> return (functx:if-empty($in-xml//price[1], 0), functx:if-empty($in-xml//price[3], 0), functx:if-empty($in-xml//price[99], 0), functx:if-empty($in-xml//price[1]/@discount, 0), functx:if-empty($in-xml//price[3]/@discount, 0), functx:if-empty($in-xml//price[4]/@discount, 0)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-index-of-deep-equal-node-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-deep-equal-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-deep-equal-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[deep-equal($nodes[$seq],$nodeToFind)] } ;                     let $in-xml := <authors> <author> <fName/> <lName>Smith</lName> </author> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return let $anotherAuthor := <author> <fName>John</fName> <lName>Smith</lName> </author> return (functx:index-of-deep-equal-node( $in-xml/author,$anAuthor))) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-index-of-deep-equal-node-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-deep-equal-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-deep-equal-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[deep-equal($nodes[$seq],$nodeToFind)] } ;                     let $in-xml := <authors> <author> <fName/> <lName>Smith</lName> </author> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return let $anotherAuthor := <author> <fName>John</fName> <lName>Smith</lName> </author> return (functx:index-of-deep-equal-node( $in-xml/author,$anotherAuthor)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-index-of-deep-equal-node-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-deep-equal-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-deep-equal-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[deep-equal($nodes[$seq],$nodeToFind)] } ;                     let $in-xml := <authors> <author> <fName/> <lName>Smith</lName> </author> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return let $anotherAuthor := <author> <fName>John</fName> <lName>Smith</lName> </author> return (functx:index-of-deep-equal-node( $in-xml/author/lName,$anAuthor/lName))) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-index-of-deep-equal-node-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on contents and attributes :                         : @author Priscilla Walmsley, Datypic                         : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-deep-equal-node.html                         : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)                                   declare function functx:index-of-deep-equal-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* {              for $seq in (1 to count($nodes))              return $seq[deep-equal($nodes[$seq],$nodeToFind)]           } ;          let $in-xml := <authors> <author> <fName/> <lName>Smith</lName> </author> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors>           return               let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author>               return                   let $anotherAuthor := <author> <fName>John</fName> <lName>Smith</lName> </author>                   return (functx:index-of-deep-equal-node( $in-xml/author,$anAuthor),                           functx:index-of-deep-equal-node( $in-xml/author,$anotherAuthor),                           functx:index-of-deep-equal-node( $in-xml/author/lName,$anAuthor/lName))       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-index-of-match-first-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The first position of a matching substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-match-first.html : @param $arg the string : @param $pattern the pattern to match :)          declare function functx:index-of-match-first ( $arg as xs:string? , $pattern as xs:string ) as xs:integer? { if (matches($arg,$pattern)) then string-length(tokenize($arg, $pattern)[1]) + 1 else () } ;                     (functx:index-of-match-first( 'abcdabcdabcd','abc'))) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-index-of-match-first-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The first position of a matching substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-match-first.html : @param $arg the string : @param $pattern the pattern to match :)          declare function functx:index-of-match-first ( $arg as xs:string? , $pattern as xs:string ) as xs:integer? { if (matches($arg,$pattern)) then string-length(tokenize($arg, $pattern)[1]) + 1 else () } ;                     (functx:index-of-match-first( 'abcdabcdabcd','bcd'))) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-index-of-match-first-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The first position of a matching substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-match-first.html : @param $arg the string : @param $pattern the pattern to match :)          declare function functx:index-of-match-first ( $arg as xs:string? , $pattern as xs:string ) as xs:integer? { if (matches($arg,$pattern)) then string-length(tokenize($arg, $pattern)[1]) + 1 else () } ;                     (functx:index-of-match-first('a1234','\d'))) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-index-of-match-first-4,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The first position of a matching substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-match-first.html : @param $arg the string : @param $pattern the pattern to match :)          declare function functx:index-of-match-first ( $arg as xs:string? , $pattern as xs:string ) as xs:integer? { if (matches($arg,$pattern)) then string-length(tokenize($arg, $pattern)[1]) + 1 else () } ;                     (functx:index-of-match-first('abc abc','\s'))) = (4). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-index-of-match-first-5,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The first position of a matching substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-match-first.html : @param $arg the string : @param $pattern the pattern to match :)          declare function functx:index-of-match-first ( $arg as xs:string? , $pattern as xs:string ) as xs:integer? { if (matches($arg,$pattern)) then string-length(tokenize($arg, $pattern)[1]) + 1 else () } ;                     (functx:index-of-match-first('abc abc','z')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-index-of-match-first-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The first position of a matching substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-match-first.html : @param $arg the string : @param $pattern the pattern to match :)          declare function functx:index-of-match-first ( $arg as xs:string? , $pattern as xs:string ) as xs:integer? { if (matches($arg,$pattern)) then string-length(tokenize($arg, $pattern)[1]) + 1 else () } ;                     (functx:index-of-match-first( 'abcdabcdabcd','abc'), functx:index-of-match-first( 'abcdabcdabcd','bcd'), functx:index-of-match-first('a1234','\d'), functx:index-of-match-first('abc abc','\s'), functx:index-of-match-first('abc abc','z')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-index-of-node-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on node identity : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[$nodes[$seq] is $nodeToFind] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:index-of-node( $in-xml/author,$in-xml/author[1]))) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-index-of-node-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on node identity : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[$nodes[$seq] is $nodeToFind] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:index-of-node( $in-xml/author,$in-xml/author[2]))) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-index-of-node-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on node identity : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[$nodes[$seq] is $nodeToFind] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:index-of-node( $in-xml/author, $in-xml/author[lName='Doe']))) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-index-of-node-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on node identity : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[$nodes[$seq] is $nodeToFind] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:index-of-node( $in-xml/author,$in-xml/author[1]), functx:index-of-node( $in-xml/author,$in-xml/author[2]), functx:index-of-node( $in-xml/author, $in-xml/author[lName='Doe'])))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-index-of-string-first-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The first position of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string-first.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string-first ( $arg as xs:string? , $substring as xs:string ) as xs:integer? { if (contains($arg, $substring)) then string-length(substring-before($arg, $substring))+1 else () } ;                     (functx:index-of-string-first( 'abcdabcdabcd','abc'))) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-index-of-string-first-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The first position of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string-first.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string-first ( $arg as xs:string? , $substring as xs:string ) as xs:integer? { if (contains($arg, $substring)) then string-length(substring-before($arg, $substring))+1 else () } ;                     (functx:index-of-string-first( 'abcd','abc'))) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-index-of-string-first-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The first position of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string-first.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string-first ( $arg as xs:string? , $substring as xs:string ) as xs:integer? { if (contains($arg, $substring)) then string-length(substring-before($arg, $substring))+1 else () } ;                     (functx:index-of-string-first( 'xxx','abc')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-index-of-string-first-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The first position of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string-first.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string-first ( $arg as xs:string? , $substring as xs:string ) as xs:integer? { if (contains($arg, $substring)) then string-length(substring-before($arg, $substring))+1 else () } ;                     (functx:index-of-string-first( 'abcdabcdabcd','abc'), functx:index-of-string-first( 'abcd','abc'), functx:index-of-string-first( 'xxx','abc')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-index-of-string-last-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The last position of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string-last.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string-last ( $arg as xs:string? , $substring as xs:string ) as xs:integer? { functx:index-of-string($arg, $substring)[last()] } ;                     (:~ : The position(s) of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string ( $arg as xs:string? , $substring as xs:string ) as xs:integer* { if (contains($arg, $substring)) then (string-length(substring-before($arg, $substring))+1, for $other in functx:index-of-string(substring-after($arg, $substring), $substring) return $other + string-length(substring-before($arg, $substring)) + string-length($substring)) else () } ;                     (functx:index-of-string-last( 'abcdabcdabcd','abc'))) = (9). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-index-of-string-last-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The last position of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string-last.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string-last ( $arg as xs:string? , $substring as xs:string ) as xs:integer? { functx:index-of-string($arg, $substring)[last()] } ;                     (:~ : The position(s) of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string ( $arg as xs:string? , $substring as xs:string ) as xs:integer* { if (contains($arg, $substring)) then (string-length(substring-before($arg, $substring))+1, for $other in functx:index-of-string(substring-after($arg, $substring), $substring) return $other + string-length(substring-before($arg, $substring)) + string-length($substring)) else () } ;                     (functx:index-of-string-last( 'abcd','abc'))) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-index-of-string-last-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The last position of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string-last.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string-last ( $arg as xs:string? , $substring as xs:string ) as xs:integer? { functx:index-of-string($arg, $substring)[last()] } ;                     (:~ : The position(s) of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string ( $arg as xs:string? , $substring as xs:string ) as xs:integer* { if (contains($arg, $substring)) then (string-length(substring-before($arg, $substring))+1, for $other in functx:index-of-string(substring-after($arg, $substring), $substring) return $other + string-length(substring-before($arg, $substring)) + string-length($substring)) else () } ;                     (functx:index-of-string-last( 'xxx','abc')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-index-of-string-last-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The last position of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string-last.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string-last ( $arg as xs:string? , $substring as xs:string ) as xs:integer? { functx:index-of-string($arg, $substring)[last()] } ;                     (:~ : The position(s) of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string ( $arg as xs:string? , $substring as xs:string ) as xs:integer* { if (contains($arg, $substring)) then (string-length(substring-before($arg, $substring))+1, for $other in functx:index-of-string(substring-after($arg, $substring), $substring) return $other + string-length(substring-before($arg, $substring)) + string-length($substring)) else () } ;                     (functx:index-of-string-last( 'abcdabcdabcd','abc'), functx:index-of-string-last( 'abcd','abc'), functx:index-of-string-last( 'xxx','abc')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-index-of-string-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The position(s) of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string ( $arg as xs:string? , $substring as xs:string ) as xs:integer* { if (contains($arg, $substring)) then (string-length(substring-before($arg, $substring))+1, for $other in functx:index-of-string(substring-after($arg, $substring), $substring) return $other + string-length(substring-before($arg, $substring)) + string-length($substring)) else () } ;                     (functx:index-of-string('abcdabcdabcd','abc')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-index-of-string-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The position(s) of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string ( $arg as xs:string? , $substring as xs:string ) as xs:integer* { if (contains($arg, $substring)) then (string-length(substring-before($arg, $substring))+1, for $other in functx:index-of-string(substring-after($arg, $substring), $substring) return $other + string-length(substring-before($arg, $substring)) + string-length($substring)) else () } ;                     (functx:index-of-string('abcd','abc'))) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-index-of-string-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The position(s) of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string ( $arg as xs:string? , $substring as xs:string ) as xs:integer* { if (contains($arg, $substring)) then (string-length(substring-before($arg, $substring))+1, for $other in functx:index-of-string(substring-after($arg, $substring), $substring) return $other + string-length(substring-before($arg, $substring)) + string-length($substring)) else () } ;                     (functx:index-of-string('xxx','abc')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-index-of-string-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The position(s) of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string ( $arg as xs:string? , $substring as xs:string ) as xs:integer* { if (contains($arg, $substring)) then (string-length(substring-before($arg, $substring))+1, for $other in functx:index-of-string(substring-after($arg, $substring), $substring) return $other + string-length(substring-before($arg, $substring)) + string-length($substring)) else () } ;                     (functx:index-of-string('abcdabcdabcd','abc'), functx:index-of-string('abcd','abc'), functx:index-of-string('xxx','abc')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-insert-string-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Inserts a string at a specified position : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_insert-string.html : @param $originalString the original string to insert into : @param $stringToInsert the string to insert : @param $pos the position :)          declare function functx:insert-string ( $originalString as xs:string? , $stringToInsert as xs:string? , $pos as xs:integer ) as xs:string { concat(substring($originalString,1,$pos - 1), $stringToInsert, substring($originalString,$pos)) } ;                     (functx:insert-string('xyz','def',2)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-insert-string-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Inserts a string at a specified position : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_insert-string.html : @param $originalString the original string to insert into : @param $stringToInsert the string to insert : @param $pos the position :)          declare function functx:insert-string ( $originalString as xs:string? , $stringToInsert as xs:string? , $pos as xs:integer ) as xs:string { concat(substring($originalString,1,$pos - 1), $stringToInsert, substring($originalString,$pos)) } ;                     (functx:insert-string('xyz','def',5)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-insert-string-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Inserts a string at a specified position : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_insert-string.html : @param $originalString the original string to insert into : @param $stringToInsert the string to insert : @param $pos the position :)          declare function functx:insert-string ( $originalString as xs:string? , $stringToInsert as xs:string? , $pos as xs:integer ) as xs:string { concat(substring($originalString,1,$pos - 1), $stringToInsert, substring($originalString,$pos)) } ;                     (functx:insert-string('xyz','',2)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-insert-string-4,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Inserts a string at a specified position : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_insert-string.html : @param $originalString the original string to insert into : @param $stringToInsert the string to insert : @param $pos the position :)          declare function functx:insert-string ( $originalString as xs:string? , $stringToInsert as xs:string? , $pos as xs:integer ) as xs:string { concat(substring($originalString,1,$pos - 1), $stringToInsert, substring($originalString,$pos)) } ;                     (functx:insert-string('','def',2)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-insert-string-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Inserts a string at a specified position : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_insert-string.html : @param $originalString the original string to insert into : @param $stringToInsert the string to insert : @param $pos the position :)          declare function functx:insert-string ( $originalString as xs:string? , $stringToInsert as xs:string? , $pos as xs:integer ) as xs:string { concat(substring($originalString,1,$pos - 1), $stringToInsert, substring($originalString,$pos)) } ;                     (functx:insert-string('xyz','def',2), functx:insert-string('xyz','def',5), functx:insert-string('xyz','',2), functx:insert-string('','def',2)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-is-a-number-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is numeric : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-a-number.html : @param $value the value to test :)          declare function functx:is-a-number ( $value as xs:anyAtomicType? ) as xs:boolean { string(number($value)) != 'NaN' } ;                     let $in-xml := <in-xml> <a>123</a> <b>abc</b> </in-xml> return (functx:is-a-number('123')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-a-number-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is numeric : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-a-number.html : @param $value the value to test :)          declare function functx:is-a-number ( $value as xs:anyAtomicType? ) as xs:boolean { string(number($value)) != 'NaN' } ;                     let $in-xml := <in-xml> <a>123</a> <b>abc</b> </in-xml> return (functx:is-a-number(123)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-a-number-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is numeric : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-a-number.html : @param $value the value to test :)          declare function functx:is-a-number ( $value as xs:anyAtomicType? ) as xs:boolean { string(number($value)) != 'NaN' } ;                     let $in-xml := <in-xml> <a>123</a> <b>abc</b> </in-xml> return (functx:is-a-number(' 123 ')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-a-number-4,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is numeric : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-a-number.html : @param $value the value to test :)          declare function functx:is-a-number ( $value as xs:anyAtomicType? ) as xs:boolean { string(number($value)) != 'NaN' } ;                     let $in-xml := <in-xml> <a>123</a> <b>abc</b> </in-xml> return (functx:is-a-number('')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-a-number-5,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is numeric : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-a-number.html : @param $value the value to test :)          declare function functx:is-a-number ( $value as xs:anyAtomicType? ) as xs:boolean { string(number($value)) != 'NaN' } ;                     let $in-xml := <in-xml> <a>123</a> <b>abc</b> </in-xml> return (functx:is-a-number('123abc')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-a-number-6,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is numeric : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-a-number.html : @param $value the value to test :)          declare function functx:is-a-number ( $value as xs:anyAtomicType? ) as xs:boolean { string(number($value)) != 'NaN' } ;                     let $in-xml := <in-xml> <a>123</a> <b>abc</b> </in-xml> return (functx:is-a-number('NaN')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-a-number-7,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is numeric : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-a-number.html : @param $value the value to test :)          declare function functx:is-a-number ( $value as xs:anyAtomicType? ) as xs:boolean { string(number($value)) != 'NaN' } ;                     let $in-xml := <in-xml> <a>123</a> <b>abc</b> </in-xml> return (functx:is-a-number($in-xml/a)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-a-number-8,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is numeric : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-a-number.html : @param $value the value to test :)          declare function functx:is-a-number ( $value as xs:anyAtomicType? ) as xs:boolean { string(number($value)) != 'NaN' } ;                     let $in-xml := <in-xml> <a>123</a> <b>abc</b> </in-xml> return (functx:is-a-number($in-xml/b)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-a-number-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is numeric : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-a-number.html : @param $value the value to test :)          declare function functx:is-a-number ( $value as xs:anyAtomicType? ) as xs:boolean { string(number($value)) != 'NaN' } ;                     let $in-xml := <in-xml> <a>123</a> <b>abc</b> </in-xml> return (functx:is-a-number('123'), functx:is-a-number(123), functx:is-a-number(' 123 '), functx:is-a-number(''), functx:is-a-number('123abc'), functx:is-a-number('NaN'), functx:is-a-number($in-xml/a), functx:is-a-number($in-xml/b)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-is-absolute-uri-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a URI is absolute : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-absolute-uri.html : @param $uri the URI to test :)          declare function functx:is-absolute-uri ( $uri as xs:string? ) as xs:boolean { matches($uri,'^[a-z]+:') } ;                     (functx:is-absolute-uri( 'http://www.datypic.com')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-absolute-uri-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a URI is absolute : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-absolute-uri.html : @param $uri the URI to test :)          declare function functx:is-absolute-uri ( $uri as xs:string? ) as xs:boolean { matches($uri,'^[a-z]+:') } ;                     (functx:is-absolute-uri( 'ftp://ftp.datypic.com')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-absolute-uri-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a URI is absolute : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-absolute-uri.html : @param $uri the URI to test :)          declare function functx:is-absolute-uri ( $uri as xs:string? ) as xs:boolean { matches($uri,'^[a-z]+:') } ;                     (functx:is-absolute-uri('ftp.datypic.com')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-absolute-uri-4,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a URI is absolute : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-absolute-uri.html : @param $uri the URI to test :)          declare function functx:is-absolute-uri ( $uri as xs:string? ) as xs:boolean { matches($uri,'^[a-z]+:') } ;                     (functx:is-absolute-uri('www.datypic.com')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-absolute-uri-5,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a URI is absolute : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-absolute-uri.html : @param $uri the URI to test :)          declare function functx:is-absolute-uri ( $uri as xs:string? ) as xs:boolean { matches($uri,'^[a-z]+:') } ;                     (functx:is-absolute-uri('prod.html')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-absolute-uri-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Whether a URI is absolute : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-absolute-uri.html : @param $uri the URI to test :)          declare function functx:is-absolute-uri ( $uri as xs:string? ) as xs:boolean { matches($uri,'^[a-z]+:') } ;                     (functx:is-absolute-uri( 'http://www.datypic.com'), functx:is-absolute-uri( 'ftp://ftp.datypic.com'), functx:is-absolute-uri('ftp.datypic.com'), functx:is-absolute-uri('www.datypic.com'), functx:is-absolute-uri('prod.html')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-is-ancestor-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is an ancestor of another node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-ancestor.html : @param $node1 the first node : @param $node2 the second node :)          declare function functx:is-ancestor ( $node1 as node() , $node2 as node() ) as xs:boolean { exists($node1 intersect $node2/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:is-ancestor( $in-xml//author[1], $in-xml//author[1]/fName)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-ancestor-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is an ancestor of another node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-ancestor.html : @param $node1 the first node : @param $node2 the second node :)          declare function functx:is-ancestor ( $node1 as node() , $node2 as node() ) as xs:boolean { exists($node1 intersect $node2/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:is-ancestor( $in-xml//author[1]/fName, $in-xml//author[1])). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-ancestor-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is an ancestor of another node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-ancestor.html : @param $node1 the first node : @param $node2 the second node :)          declare function functx:is-ancestor ( $node1 as node() , $node2 as node() ) as xs:boolean { exists($node1 intersect $node2/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:is-ancestor( $in-xml//author[1]/fName, $in-xml//author[1]/fName/text())). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-ancestor-4,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is an ancestor of another node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-ancestor.html : @param $node1 the first node : @param $node2 the second node :)          declare function functx:is-ancestor ( $node1 as node() , $node2 as node() ) as xs:boolean { exists($node1 intersect $node2/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:is-ancestor( $in-xml//author[1], $in-xml//author[2])). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-ancestor-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is an ancestor of another node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-ancestor.html : @param $node1 the first node : @param $node2 the second node :)          declare function functx:is-ancestor ( $node1 as node() , $node2 as node() ) as xs:boolean { exists($node1 intersect $node2/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:is-ancestor( $in-xml//author[1], $in-xml//author[1]/fName), functx:is-ancestor( $in-xml//author[1]/fName, $in-xml//author[1]), functx:is-ancestor( $in-xml//author[1]/fName, $in-xml//author[1]/fName/text()), functx:is-ancestor( $in-xml//author[1], $in-xml//author[2])))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-is-descendant-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is a descendant of another node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-descendant.html : @param $node1 the first node : @param $node2 the second node :)          declare function functx:is-descendant ( $node1 as node() , $node2 as node() ) as xs:boolean { boolean($node2 intersect $node1/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:is-descendant( $in-xml//author[1]/fName, $in-xml//author[1])). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-descendant-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is a descendant of another node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-descendant.html : @param $node1 the first node : @param $node2 the second node :)          declare function functx:is-descendant ( $node1 as node() , $node2 as node() ) as xs:boolean { boolean($node2 intersect $node1/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:is-descendant( $in-xml//author[1], $in-xml//author[1]/fName)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-descendant-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is a descendant of another node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-descendant.html : @param $node1 the first node : @param $node2 the second node :)          declare function functx:is-descendant ( $node1 as node() , $node2 as node() ) as xs:boolean { boolean($node2 intersect $node1/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:is-descendant( $in-xml//author[1]/fName/text(), $in-xml//author[1]/fName)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-descendant-4,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is a descendant of another node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-descendant.html : @param $node1 the first node : @param $node2 the second node :)          declare function functx:is-descendant ( $node1 as node() , $node2 as node() ) as xs:boolean { boolean($node2 intersect $node1/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:is-descendant( $in-xml//author[1], $in-xml//author[2])). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-descendant-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is a descendant of another node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-descendant.html : @param $node1 the first node : @param $node2 the second node :)          declare function functx:is-descendant ( $node1 as node() , $node2 as node() ) as xs:boolean { boolean($node2 intersect $node1/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:is-descendant( $in-xml//author[1]/fName, $in-xml//author[1]), functx:is-descendant( $in-xml//author[1], $in-xml//author[1]/fName), functx:is-descendant( $in-xml//author[1]/fName/text(), $in-xml//author[1]/fName), functx:is-descendant( $in-xml//author[1], $in-xml//author[2])))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-is-leap-year-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a date falls in a leap year : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-leap-year.html : @param $date the date or year :)          declare function functx:is-leap-year ( $date as xs:anyAtomicType? ) as xs:boolean { for $year in xs:integer(substring(string($date),1,4)) return ($year mod 4 = 0 and $year mod 100 != 0) or $year mod 400 = 0 } ;                     (functx:is-leap-year(xs:date('2004-01-23'))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-leap-year-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a date falls in a leap year : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-leap-year.html : @param $date the date or year :)          declare function functx:is-leap-year ( $date as xs:anyAtomicType? ) as xs:boolean { for $year in xs:integer(substring(string($date),1,4)) return ($year mod 4 = 0 and $year mod 100 != 0) or $year mod 400 = 0 } ;                     (functx:is-leap-year(2004)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-leap-year-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a date falls in a leap year : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-leap-year.html : @param $date the date or year :)          declare function functx:is-leap-year ( $date as xs:anyAtomicType? ) as xs:boolean { for $year in xs:integer(substring(string($date),1,4)) return ($year mod 4 = 0 and $year mod 100 != 0) or $year mod 400 = 0 } ;                     (functx:is-leap-year('2005-02-15')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-leap-year-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Whether a date falls in a leap year : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-leap-year.html : @param $date the date or year :)          declare function functx:is-leap-year ( $date as xs:anyAtomicType? ) as xs:boolean { for $year in xs:integer(substring(string($date),1,4)) return ($year mod 4 = 0 and $year mod 100 != 0) or $year mod 400 = 0 } ;                     (functx:is-leap-year(xs:date('2004-01-23')), functx:is-leap-year(2004), functx:is-leap-year('2005-02-15')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-is-node-among-descendants-deep-equal-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is among the descendants of a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-among-descendants-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-among-descendants-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq/descendant-or-self::*/(.|@*) satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>John</fName> <lName>Doe</lName> </author> return let $anotherAuthor := <author> <lName>Doe</lName> <fName>John</fName> </author> return (functx:is-node-among-descendants-deep-equal( $in-xml/author[1],$in-xml)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-node-among-descendants-deep-equal-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is among the descendants of a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-among-descendants-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-among-descendants-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq/descendant-or-self::*/(.|@*) satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>John</fName> <lName>Doe</lName> </author> return let $anotherAuthor := <author> <lName>Doe</lName> <fName>John</fName> </author> return (functx:is-node-among-descendants-deep-equal( $anAuthor,$in-xml)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-node-among-descendants-deep-equal-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is among the descendants of a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-among-descendants-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-among-descendants-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq/descendant-or-self::*/(.|@*) satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>John</fName> <lName>Doe</lName> </author> return let $anotherAuthor := <author> <lName>Doe</lName> <fName>John</fName> </author> return (functx:is-node-among-descendants-deep-equal( $anotherAuthor,$in-xml)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-node-among-descendants-deep-equal-4,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is among the descendants of a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-among-descendants-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-among-descendants-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq/descendant-or-self::*/(.|@*) satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>John</fName> <lName>Doe</lName> </author> return let $anotherAuthor := <author> <lName>Doe</lName> <fName>John</fName> </author> return (functx:is-node-among-descendants-deep-equal( $anAuthor,$in-xml/author)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-node-among-descendants-deep-equal-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is among the descendants of a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-among-descendants-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-among-descendants-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq/descendant-or-self::*/(.|@*) satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>John</fName> <lName>Doe</lName> </author> return let $anotherAuthor := <author> <lName>Doe</lName> <fName>John</fName> </author> return (functx:is-node-among-descendants-deep-equal( $in-xml/author[1],$in-xml), functx:is-node-among-descendants-deep-equal( $anAuthor,$in-xml), functx:is-node-among-descendants-deep-equal( $anotherAuthor,$in-xml), functx:is-node-among-descendants-deep-equal( $anAuthor,$in-xml/author)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-is-node-among-descendants-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is among the descendants of a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-among-descendants.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-among-descendants ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq/descendant-or-self::*/(.|@*) satisfies $nodeInSeq is $node } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="49.99" discount=""/> </prices> return let $aPrice := <price value="49.99" discount=""/> return (functx:is-node-among-descendants( $in-xml/price[1],$in-xml)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-node-among-descendants-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is among the descendants of a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-among-descendants.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-among-descendants ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq/descendant-or-self::*/(.|@*) satisfies $nodeInSeq is $node } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="49.99" discount=""/> </prices> return let $aPrice := <price value="49.99" discount=""/> return (functx:is-node-among-descendants( $in-xml,$in-xml/price[1])). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-node-among-descendants-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is among the descendants of a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-among-descendants.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-among-descendants ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq/descendant-or-self::*/(.|@*) satisfies $nodeInSeq is $node } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="49.99" discount=""/> </prices> return let $aPrice := <price value="49.99" discount=""/> return (functx:is-node-among-descendants( $in-xml,$in-xml)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-node-among-descendants-4,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is among the descendants of a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-among-descendants.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-among-descendants ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq/descendant-or-self::*/(.|@*) satisfies $nodeInSeq is $node } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="49.99" discount=""/> </prices> return let $aPrice := <price value="49.99" discount=""/> return (functx:is-node-among-descendants( $aPrice,$in-xml)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-node-among-descendants-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is among the descendants of a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-among-descendants.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-among-descendants ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq/descendant-or-self::*/(.|@*) satisfies $nodeInSeq is $node } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="49.99" discount=""/> </prices> return let $aPrice := <price value="49.99" discount=""/> return (functx:is-node-among-descendants( $in-xml/price[1],$in-xml), functx:is-node-among-descendants( $in-xml,$in-xml/price[1]), functx:is-node-among-descendants( $in-xml,$in-xml), functx:is-node-among-descendants( $aPrice,$in-xml)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-is-node-in-sequence-deep-equal-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is in a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>John</fName> <lName>Doe</lName> </author> return (functx:is-node-in-sequence-deep-equal( $in-xml/author[1],$in-xml/author)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-node-in-sequence-deep-equal-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is in a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>John</fName> <lName>Doe</lName> </author> return (functx:is-node-in-sequence-deep-equal( $anAuthor,$in-xml/author)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-node-in-sequence-deep-equal-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is in a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>John</fName> <lName>Doe</lName> </author> return (functx:is-node-in-sequence-deep-equal( $in-xml/author[1],$in-xml)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-node-in-sequence-deep-equal-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is in a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>John</fName> <lName>Doe</lName> </author> return (functx:is-node-in-sequence-deep-equal( $in-xml/author[1],$in-xml/author), functx:is-node-in-sequence-deep-equal( $anAuthor,$in-xml/author), functx:is-node-in-sequence-deep-equal( $in-xml/author[1],$in-xml)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-is-node-in-sequence-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is in a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies $nodeInSeq is $node } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="49.99" discount=""/> </prices> return let $aPrice := <price value="49.99" discount=""/> return (functx:is-node-in-sequence( $in-xml/price[1],$in-xml/price)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-node-in-sequence-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is in a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies $nodeInSeq is $node } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="49.99" discount=""/> </prices> return let $aPrice := <price value="49.99" discount=""/> return (functx:is-node-in-sequence( $in-xml/price[1],$in-xml)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-node-in-sequence-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is in a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies $nodeInSeq is $node } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="49.99" discount=""/> </prices> return let $aPrice := <price value="49.99" discount=""/> return (functx:is-node-in-sequence( $aPrice,$in-xml/price)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-node-in-sequence-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is in a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies $nodeInSeq is $node } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="49.99" discount=""/> </prices> return let $aPrice := <price value="49.99" discount=""/> return (functx:is-node-in-sequence( $in-xml/price[1],$in-xml/price), functx:is-node-in-sequence( $in-xml/price[1],$in-xml), functx:is-node-in-sequence( $aPrice,$in-xml/price)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-is-value-in-sequence-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an atomic value appears in a sequence : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-value-in-sequence.html : @param $value the atomic value to test : @param $seq the sequence of values to search :)          declare function functx:is-value-in-sequence ( $value as xs:anyAtomicType? , $seq as xs:anyAtomicType* ) as xs:boolean { $value = $seq } ;                     (functx:is-value-in-sequence(1,(1,2,3))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-value-in-sequence-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an atomic value appears in a sequence : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-value-in-sequence.html : @param $value the atomic value to test : @param $seq the sequence of values to search :)          declare function functx:is-value-in-sequence ( $value as xs:anyAtomicType? , $seq as xs:anyAtomicType* ) as xs:boolean { $value = $seq } ;                     (functx:is-value-in-sequence(5,(1,2,3))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-value-in-sequence-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an atomic value appears in a sequence : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-value-in-sequence.html : @param $value the atomic value to test : @param $seq the sequence of values to search :)          declare function functx:is-value-in-sequence ( $value as xs:anyAtomicType? , $seq as xs:anyAtomicType* ) as xs:boolean { $value = $seq } ;                     (functx:is-value-in-sequence(1.0,(1,2,3))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-is-value-in-sequence-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Whether an atomic value appears in a sequence : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-value-in-sequence.html : @param $value the atomic value to test : @param $seq the sequence of values to search :)          declare function functx:is-value-in-sequence ( $value as xs:anyAtomicType? , $seq as xs:anyAtomicType* ) as xs:boolean { $value = $seq } ;                     (functx:is-value-in-sequence(1,(1,2,3)), functx:is-value-in-sequence(5,(1,2,3)), functx:is-value-in-sequence(1.0,(1,2,3))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-last-day-of-month-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Construct a date from a year, month and day : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_date.html : @param $year the year : @param $month the month : @param $day the day :)          declare function functx:date ( $year as xs:anyAtomicType , $month as xs:anyAtomicType , $day as xs:anyAtomicType ) as xs:date { xs:date( concat( functx:pad-integer-to-length(xs:integer($year),4),'-', functx:pad-integer-to-length(xs:integer($month),2),'-', functx:pad-integer-to-length(xs:integer($day),2))) } ;                     (:~ : Number of days in the month : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_days-in-month.html : @param $date the date :)          declare function functx:days-in-month ( $date as xs:anyAtomicType? ) as xs:integer? { if (month-from-date(xs:date($date)) = 2 and functx:is-leap-year($date)) then 29 else (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31) [month-from-date(xs:date($date))] } ;                     (:~ : Whether a date falls in a leap year : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-leap-year.html : @param $date the date or year :)          declare function functx:is-leap-year ( $date as xs:anyAtomicType? ) as xs:boolean { for $year in xs:integer(substring(string($date),1,4)) return ($year mod 4 = 0 and $year mod 100 != 0) or $year mod 400 = 0 } ;                     (:~ : The last day of the month of a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_last-day-of-month.html : @param $date the date :)          declare function functx:last-day-of-month ( $date as xs:anyAtomicType? ) as xs:date? { functx:date(year-from-date(xs:date($date)), month-from-date(xs:date($date)), functx:days-in-month($date)) } ;                     (:~ : Pads an integer to a desired length by adding leading zeros : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-integer-to-length.html : @param $integerToPad the integer to pad : @param $length the desired length :)          declare function functx:pad-integer-to-length ( $integerToPad as xs:anyAtomicType? , $length as xs:integer ) as xs:string { if ($length < string-length(string($integerToPad))) then error(xs:QName('functx:Integer_Longer_Than_Length')) else concat (functx:repeat-string( '0',$length - string-length(string($integerToPad))), string($integerToPad)) } ;                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:last-day-of-month(xs:date('2004-01-23'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-last-day-of-month-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Construct a date from a year, month and day : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_date.html : @param $year the year : @param $month the month : @param $day the day :)          declare function functx:date ( $year as xs:anyAtomicType , $month as xs:anyAtomicType , $day as xs:anyAtomicType ) as xs:date { xs:date( concat( functx:pad-integer-to-length(xs:integer($year),4),'-', functx:pad-integer-to-length(xs:integer($month),2),'-', functx:pad-integer-to-length(xs:integer($day),2))) } ;                     (:~ : Number of days in the month : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_days-in-month.html : @param $date the date :)          declare function functx:days-in-month ( $date as xs:anyAtomicType? ) as xs:integer? { if (month-from-date(xs:date($date)) = 2 and functx:is-leap-year($date)) then 29 else (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31) [month-from-date(xs:date($date))] } ;                     (:~ : Whether a date falls in a leap year : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-leap-year.html : @param $date the date or year :)          declare function functx:is-leap-year ( $date as xs:anyAtomicType? ) as xs:boolean { for $year in xs:integer(substring(string($date),1,4)) return ($year mod 4 = 0 and $year mod 100 != 0) or $year mod 400 = 0 } ;                     (:~ : The last day of the month of a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_last-day-of-month.html : @param $date the date :)          declare function functx:last-day-of-month ( $date as xs:anyAtomicType? ) as xs:date? { functx:date(year-from-date(xs:date($date)), month-from-date(xs:date($date)), functx:days-in-month($date)) } ;                     (:~ : Pads an integer to a desired length by adding leading zeros : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-integer-to-length.html : @param $integerToPad the integer to pad : @param $length the desired length :)          declare function functx:pad-integer-to-length ( $integerToPad as xs:anyAtomicType? , $length as xs:integer ) as xs:string { if ($length < string-length(string($integerToPad))) then error(xs:QName('functx:Integer_Longer_Than_Length')) else concat (functx:repeat-string( '0',$length - string-length(string($integerToPad))), string($integerToPad)) } ;                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:last-day-of-month( xs:dateTime('2004-09-23T12:00:13'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-last-day-of-month-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Construct a date from a year, month and day : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_date.html : @param $year the year : @param $month the month : @param $day the day :)          declare function functx:date ( $year as xs:anyAtomicType , $month as xs:anyAtomicType , $day as xs:anyAtomicType ) as xs:date { xs:date( concat( functx:pad-integer-to-length(xs:integer($year),4),'-', functx:pad-integer-to-length(xs:integer($month),2),'-', functx:pad-integer-to-length(xs:integer($day),2))) } ;                     (:~ : Number of days in the month : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_days-in-month.html : @param $date the date :)          declare function functx:days-in-month ( $date as xs:anyAtomicType? ) as xs:integer? { if (month-from-date(xs:date($date)) = 2 and functx:is-leap-year($date)) then 29 else (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31) [month-from-date(xs:date($date))] } ;                     (:~ : Whether a date falls in a leap year : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-leap-year.html : @param $date the date or year :)          declare function functx:is-leap-year ( $date as xs:anyAtomicType? ) as xs:boolean { for $year in xs:integer(substring(string($date),1,4)) return ($year mod 4 = 0 and $year mod 100 != 0) or $year mod 400 = 0 } ;                     (:~ : The last day of the month of a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_last-day-of-month.html : @param $date the date :)          declare function functx:last-day-of-month ( $date as xs:anyAtomicType? ) as xs:date? { functx:date(year-from-date(xs:date($date)), month-from-date(xs:date($date)), functx:days-in-month($date)) } ;                     (:~ : Pads an integer to a desired length by adding leading zeros : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-integer-to-length.html : @param $integerToPad the integer to pad : @param $length the desired length :)          declare function functx:pad-integer-to-length ( $integerToPad as xs:anyAtomicType? , $length as xs:integer ) as xs:string { if ($length < string-length(string($integerToPad))) then error(xs:QName('functx:Integer_Longer_Than_Length')) else concat (functx:repeat-string( '0',$length - string-length(string($integerToPad))), string($integerToPad)) } ;                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:last-day-of-month('2004-03-23')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-last-day-of-month-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Construct a date from a year, month and day : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_date.html : @param $year the year : @param $month the month : @param $day the day :)          declare function functx:date ( $year as xs:anyAtomicType , $month as xs:anyAtomicType , $day as xs:anyAtomicType ) as xs:date { xs:date( concat( functx:pad-integer-to-length(xs:integer($year),4),'-', functx:pad-integer-to-length(xs:integer($month),2),'-', functx:pad-integer-to-length(xs:integer($day),2))) } ;                     (:~ : Number of days in the month : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_days-in-month.html : @param $date the date :)          declare function functx:days-in-month ( $date as xs:anyAtomicType? ) as xs:integer? { if (month-from-date(xs:date($date)) = 2 and functx:is-leap-year($date)) then 29 else (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31) [month-from-date(xs:date($date))] } ;                     (:~ : Whether a date falls in a leap year : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-leap-year.html : @param $date the date or year :)          declare function functx:is-leap-year ( $date as xs:anyAtomicType? ) as xs:boolean { for $year in xs:integer(substring(string($date),1,4)) return ($year mod 4 = 0 and $year mod 100 != 0) or $year mod 400 = 0 } ;                     (:~ : The last day of the month of a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_last-day-of-month.html : @param $date the date :)          declare function functx:last-day-of-month ( $date as xs:anyAtomicType? ) as xs:date? { functx:date(year-from-date(xs:date($date)), month-from-date(xs:date($date)), functx:days-in-month($date)) } ;                     (:~ : Pads an integer to a desired length by adding leading zeros : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-integer-to-length.html : @param $integerToPad the integer to pad : @param $length the desired length :)          declare function functx:pad-integer-to-length ( $integerToPad as xs:anyAtomicType? , $length as xs:integer ) as xs:string { if ($length < string-length(string($integerToPad))) then error(xs:QName('functx:Integer_Longer_Than_Length')) else concat (functx:repeat-string( '0',$length - string-length(string($integerToPad))), string($integerToPad)) } ;                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:last-day-of-month(xs:date('2004-01-23')), functx:last-day-of-month( xs:dateTime('2004-09-23T12:00:13')), functx:last-day-of-month('2004-03-23')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-last-day-of-year-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Construct a date from a year, month and day : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_date.html : @param $year the year : @param $month the month : @param $day the day :)          declare function functx:date ( $year as xs:anyAtomicType , $month as xs:anyAtomicType , $day as xs:anyAtomicType ) as xs:date { xs:date( concat( functx:pad-integer-to-length(xs:integer($year),4),'-', functx:pad-integer-to-length(xs:integer($month),2),'-', functx:pad-integer-to-length(xs:integer($day),2))) } ;                     (:~ : Number of days in the month : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_days-in-month.html : @param $date the date :)          declare function functx:days-in-month ( $date as xs:anyAtomicType? ) as xs:integer? { if (month-from-date(xs:date($date)) = 2 and functx:is-leap-year($date)) then 29 else (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31) [month-from-date(xs:date($date))] } ;                     (:~ : Whether a date falls in a leap year : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-leap-year.html : @param $date the date or year :)          declare function functx:is-leap-year ( $date as xs:anyAtomicType? ) as xs:boolean { for $year in xs:integer(substring(string($date),1,4)) return ($year mod 4 = 0 and $year mod 100 != 0) or $year mod 400 = 0 } ;                     (:~ : The last day of the month of a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_last-day-of-year.html : @param $date the date :)          declare function functx:last-day-of-year ( $date as xs:anyAtomicType? ) as xs:date? { functx:date(year-from-date(xs:date($date)), 12, 31) } ;                     (:~ : Pads an integer to a desired length by adding leading zeros : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-integer-to-length.html : @param $integerToPad the integer to pad : @param $length the desired length :)          declare function functx:pad-integer-to-length ( $integerToPad as xs:anyAtomicType? , $length as xs:integer ) as xs:string { if ($length < string-length(string($integerToPad))) then error(xs:QName('functx:Integer_Longer_Than_Length')) else concat (functx:repeat-string( '0',$length - string-length(string($integerToPad))), string($integerToPad)) } ;                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:last-day-of-year(xs:date('2004-01-23'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-last-day-of-year-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Construct a date from a year, month and day : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_date.html : @param $year the year : @param $month the month : @param $day the day :)          declare function functx:date ( $year as xs:anyAtomicType , $month as xs:anyAtomicType , $day as xs:anyAtomicType ) as xs:date { xs:date( concat( functx:pad-integer-to-length(xs:integer($year),4),'-', functx:pad-integer-to-length(xs:integer($month),2),'-', functx:pad-integer-to-length(xs:integer($day),2))) } ;                     (:~ : Number of days in the month : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_days-in-month.html : @param $date the date :)          declare function functx:days-in-month ( $date as xs:anyAtomicType? ) as xs:integer? { if (month-from-date(xs:date($date)) = 2 and functx:is-leap-year($date)) then 29 else (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31) [month-from-date(xs:date($date))] } ;                     (:~ : Whether a date falls in a leap year : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-leap-year.html : @param $date the date or year :)          declare function functx:is-leap-year ( $date as xs:anyAtomicType? ) as xs:boolean { for $year in xs:integer(substring(string($date),1,4)) return ($year mod 4 = 0 and $year mod 100 != 0) or $year mod 400 = 0 } ;                     (:~ : The last day of the month of a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_last-day-of-year.html : @param $date the date :)          declare function functx:last-day-of-year ( $date as xs:anyAtomicType? ) as xs:date? { functx:date(year-from-date(xs:date($date)), 12, 31) } ;                     (:~ : Pads an integer to a desired length by adding leading zeros : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-integer-to-length.html : @param $integerToPad the integer to pad : @param $length the desired length :)          declare function functx:pad-integer-to-length ( $integerToPad as xs:anyAtomicType? , $length as xs:integer ) as xs:string { if ($length < string-length(string($integerToPad))) then error(xs:QName('functx:Integer_Longer_Than_Length')) else concat (functx:repeat-string( '0',$length - string-length(string($integerToPad))), string($integerToPad)) } ;                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:last-day-of-year( xs:dateTime('2004-12-23T12:00:13'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-last-day-of-year-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Construct a date from a year, month and day : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_date.html : @param $year the year : @param $month the month : @param $day the day :)          declare function functx:date ( $year as xs:anyAtomicType , $month as xs:anyAtomicType , $day as xs:anyAtomicType ) as xs:date { xs:date( concat( functx:pad-integer-to-length(xs:integer($year),4),'-', functx:pad-integer-to-length(xs:integer($month),2),'-', functx:pad-integer-to-length(xs:integer($day),2))) } ;                     (:~ : Number of days in the month : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_days-in-month.html : @param $date the date :)          declare function functx:days-in-month ( $date as xs:anyAtomicType? ) as xs:integer? { if (month-from-date(xs:date($date)) = 2 and functx:is-leap-year($date)) then 29 else (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31) [month-from-date(xs:date($date))] } ;                     (:~ : Whether a date falls in a leap year : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-leap-year.html : @param $date the date or year :)          declare function functx:is-leap-year ( $date as xs:anyAtomicType? ) as xs:boolean { for $year in xs:integer(substring(string($date),1,4)) return ($year mod 4 = 0 and $year mod 100 != 0) or $year mod 400 = 0 } ;                     (:~ : The last day of the month of a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_last-day-of-year.html : @param $date the date :)          declare function functx:last-day-of-year ( $date as xs:anyAtomicType? ) as xs:date? { functx:date(year-from-date(xs:date($date)), 12, 31) } ;                     (:~ : Pads an integer to a desired length by adding leading zeros : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-integer-to-length.html : @param $integerToPad the integer to pad : @param $length the desired length :)          declare function functx:pad-integer-to-length ( $integerToPad as xs:anyAtomicType? , $length as xs:integer ) as xs:string { if ($length < string-length(string($integerToPad))) then error(xs:QName('functx:Integer_Longer_Than_Length')) else concat (functx:repeat-string( '0',$length - string-length(string($integerToPad))), string($integerToPad)) } ;                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:last-day-of-year('2004-03-23')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-last-day-of-year-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Construct a date from a year, month and day : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_date.html : @param $year the year : @param $month the month : @param $day the day :)          declare function functx:date ( $year as xs:anyAtomicType , $month as xs:anyAtomicType , $day as xs:anyAtomicType ) as xs:date { xs:date( concat( functx:pad-integer-to-length(xs:integer($year),4),'-', functx:pad-integer-to-length(xs:integer($month),2),'-', functx:pad-integer-to-length(xs:integer($day),2))) } ;                     (:~ : Number of days in the month : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_days-in-month.html : @param $date the date :)          declare function functx:days-in-month ( $date as xs:anyAtomicType? ) as xs:integer? { if (month-from-date(xs:date($date)) = 2 and functx:is-leap-year($date)) then 29 else (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31) [month-from-date(xs:date($date))] } ;                     (:~ : Whether a date falls in a leap year : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-leap-year.html : @param $date the date or year :)          declare function functx:is-leap-year ( $date as xs:anyAtomicType? ) as xs:boolean { for $year in xs:integer(substring(string($date),1,4)) return ($year mod 4 = 0 and $year mod 100 != 0) or $year mod 400 = 0 } ;                     (:~ : The last day of the month of a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_last-day-of-year.html : @param $date the date :)          declare function functx:last-day-of-year ( $date as xs:anyAtomicType? ) as xs:date? { functx:date(year-from-date(xs:date($date)), 12, 31) } ;                     (:~ : Pads an integer to a desired length by adding leading zeros : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-integer-to-length.html : @param $integerToPad the integer to pad : @param $length the desired length :)          declare function functx:pad-integer-to-length ( $integerToPad as xs:anyAtomicType? , $length as xs:integer ) as xs:string { if ($length < string-length(string($integerToPad))) then error(xs:QName('functx:Integer_Longer_Than_Length')) else concat (functx:repeat-string( '0',$length - string-length(string($integerToPad))), string($integerToPad)) } ;                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:last-day-of-year(xs:date('2004-01-23')), functx:last-day-of-year( xs:dateTime('2004-12-23T12:00:13')), functx:last-day-of-year('2004-03-23')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-last-node-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : The XML node in a sequence that is last in document order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_last-node.html : @param $nodes the sequence of nodes :)          declare function functx:last-node ( $nodes as node()* ) as node()? { ($nodes/.)[last()] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:last-node($in-xml//fName)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-last-node-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : The XML node in a sequence that is last in document order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_last-node.html : @param $nodes the sequence of nodes :)          declare function functx:last-node ( $nodes as node()* ) as node()? { ($nodes/.)[last()] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:last-node( ($in-xml//lName, $in-xml//fName) )). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-last-node-all,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : The XML node in a sequence that is last in document order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_last-node.html : @param $nodes the sequence of nodes :)          declare function functx:last-node ( $nodes as node()* ) as node()? { ($nodes/.)[last()] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:last-node($in-xml//fName), functx:last-node( ($in-xml//lName, $in-xml//fName) )). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-leaf-elements-1,Error: XPST0003: Unable to parse XPath:        	declare namespace functx = "http://www.example.com/";       	declare function functx:leaf-elements ( $root as node()? ) as element()* { $root/descendant-or-self::*[not(*)] } ;         let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author>                                   <author> <fName>John</fName> <lName>Doe</lName> </author>                         </authors>          return (functx:leaf-elements($in-xml))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-leaf-elements-2,Error: XPST0003: Unable to parse XPath:        	declare namespace functx = "http://www.example.com/";         declare function functx:leaf-elements ( $root as node()? ) as element()* { $root/descendant-or-self::*[not(*)] } ;         let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author>                                   <author> <fName>John</fName> <lName>Doe</lName> </author>                         </authors>          return (functx:leaf-elements($in-xml/author[1]))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-leaf-elements-all,Error: XPST0003: Unable to parse XPath:        	declare namespace functx = "http://www.example.com/";         declare function functx:leaf-elements ( $root as node()? ) as element()* { $root/descendant-or-self::*[not(*)] } ;         let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author>                                   <author> <fName>John</fName> <lName>Doe</lName> </author>                         </authors>          return (functx:leaf-elements($in-xml), functx:leaf-elements($in-xml/author[1]))       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-left-trim-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Trims leading whitespace : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_left-trim.html : @param $arg the string to trim :)          declare function functx:left-trim ( $arg as xs:string? ) as xs:string { replace($arg,'^\s+','') } ;                     (functx:left-trim(' xyz')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-left-trim-2,Error: XPST0003: Unable to parse XPath: (          declare namespace functx = "http://www.example.com/";          declare function functx:left-trim ( $arg as xs:string? ) as xs:string { replace($arg,'^\s+','') } ;          (functx:left-trim(' xyz    x'))       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-left-trim-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Trims leading whitespace : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_left-trim.html : @param $arg the string to trim :)          declare function functx:left-trim ( $arg as xs:string? ) as xs:string { replace($arg,'^\s+','') } ;                     (functx:left-trim('xyz')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-left-trim-all,Error: XPST0003: Unable to parse XPath: (          declare namespace functx = "http://www.example.com/";          declare function functx:left-trim ( $arg as xs:string? ) as xs:string { replace($arg,'^\s+','') } ;                     (functx:left-trim(' xyz'), functx:left-trim(' xyz    x'), functx:left-trim('xyz')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-line-count-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The number of lines : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_line-count.html : @param $arg the string to test :)          declare function functx:line-count ( $arg as xs:string? ) as xs:integer { count(functx:lines($arg)) } ;                     (:~ : Split a string into separate lines : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_lines.html : @param $arg the string to split :)          declare function functx:lines ( $arg as xs:string? ) as xs:string* { tokenize($arg, '(\r\n?|\n\r?)') } ;                     let $lines := 'a value on many lines' return (functx:line-count('a value'))) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-line-count-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The number of lines : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_line-count.html : @param $arg the string to test :)          declare function functx:line-count ( $arg as xs:string? ) as xs:integer { count(functx:lines($arg)) } ;                     (:~ : Split a string into separate lines : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_lines.html : @param $arg the string to split :)          declare function functx:lines ( $arg as xs:string? ) as xs:string* { tokenize($arg, '(\r\n?|\n\r?)') } ;          let $lines := 'a              value              on              many              lines' return (functx:line-count($lines))       ) = (5). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-line-count-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The number of lines : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_line-count.html : @param $arg the string to test :)          declare function functx:line-count ( $arg as xs:string? ) as xs:integer { count(functx:lines($arg)) } ;                     (:~ : Split a string into separate lines : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_lines.html : @param $arg the string to split :)          declare function functx:lines ( $arg as xs:string? ) as xs:string* { tokenize($arg, '(\r\n?|\n\r?)') } ;          let $lines := 'a                      value                      on                      many                      lines'           return (functx:line-count('a value'), functx:line-count($lines)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-lines-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Split a string into separate lines : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_lines.html : @param $arg the string to split :)          declare function functx:lines ( $arg as xs:string? ) as xs:string* { tokenize($arg, '(\r\n?|\n\r?)') } ;                     let $in-xml := <in-xml>a value on many lines</in-xml> return (functx:lines('a value')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-lines-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Split a string into separate lines : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_lines.html : @param $arg the string to split :)          declare function functx:lines ( $arg as xs:string? ) as xs:string* { tokenize($arg, '(\r\n?|\n\r?)') } ;                     let $in-xml := <in-xml>a value on many lines</in-xml> return (functx:lines($in-xml)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-lines-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Split a string into separate lines : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_lines.html : @param $arg the string to split :)          declare function functx:lines ( $arg as xs:string? ) as xs:string* { tokenize($arg, '(\r\n?|\n\r?)') } ;                     let $in-xml := <in-xml>a value on many lines</in-xml> return (functx:lines('a value'), functx:lines($in-xml)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-max-depth-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The maximum depth of elements in an XML tree : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-depth.html : @param $root the root to start from :)          declare function functx:max-depth ( $root as node()? ) as xs:integer? { if ($root/*) then max($root/*/functx:max-depth(.)) + 1 else 1 } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:max-depth($in-xml))) = (3). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-max-depth-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The maximum depth of elements in an XML tree : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-depth.html : @param $root the root to start from :)          declare function functx:max-depth ( $root as node()? ) as xs:integer? { if ($root/*) then max($root/*/functx:max-depth(.)) + 1 else 1 } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:max-depth($in-xml/author[1]))) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-max-depth-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The maximum depth of elements in an XML tree : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-depth.html : @param $root the root to start from :)          declare function functx:max-depth ( $root as node()? ) as xs:integer? { if ($root/*) then max($root/*/functx:max-depth(.)) + 1 else 1 } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:max-depth($in-xml), functx:max-depth($in-xml/author[1])))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-max-determine-type-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The maximum value in a sequence, figuring out its type (numeric or string) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-determine-type.html : @param $seq the sequence of values to test :)          declare function functx:max-determine-type ( $seq as xs:anyAtomicType* ) as xs:anyAtomicType? { if (every $value in $seq satisfies ($value castable as xs:double)) then max(for $value in $seq return xs:double($value)) else max(for $value in $seq return xs:string($value)) } ;                     let $in-xml := <values> <nums> <num>12</num> <num>23</num> <num>115</num> <num>12.5</num> </nums> <strings> <string>def</string> <string>abc</string> </strings> </values> return (functx:max-determine-type($in-xml//num))) = (115). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-max-determine-type-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The maximum value in a sequence, figuring out its type (numeric or string) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-determine-type.html : @param $seq the sequence of values to test :)          declare function functx:max-determine-type ( $seq as xs:anyAtomicType* ) as xs:anyAtomicType? { if (every $value in $seq satisfies ($value castable as xs:double)) then max(for $value in $seq return xs:double($value)) else max(for $value in $seq return xs:string($value)) } ;                     let $in-xml := <values> <nums> <num>12</num> <num>23</num> <num>115</num> <num>12.5</num> </nums> <strings> <string>def</string> <string>abc</string> </strings> </values> return (functx:max-determine-type($in-xml//string)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-max-determine-type-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The maximum value in a sequence, figuring out its type (numeric or string) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-determine-type.html : @param $seq the sequence of values to test :)          declare function functx:max-determine-type ( $seq as xs:anyAtomicType* ) as xs:anyAtomicType? { if (every $value in $seq satisfies ($value castable as xs:double)) then max(for $value in $seq return xs:double($value)) else max(for $value in $seq return xs:string($value)) } ;                     let $in-xml := <values> <nums> <num>12</num> <num>23</num> <num>115</num> <num>12.5</num> </nums> <strings> <string>def</string> <string>abc</string> </strings> </values> return (functx:max-determine-type( $in-xml//(num|string))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-max-determine-type-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The maximum value in a sequence, figuring out its type (numeric or string) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-determine-type.html : @param $seq the sequence of values to test :)          declare function functx:max-determine-type ( $seq as xs:anyAtomicType* ) as xs:anyAtomicType? { if (every $value in $seq satisfies ($value castable as xs:double)) then max(for $value in $seq return xs:double($value)) else max(for $value in $seq return xs:string($value)) } ;                     let $in-xml := <values> <nums> <num>12</num> <num>23</num> <num>115</num> <num>12.5</num> </nums> <strings> <string>def</string> <string>abc</string> </strings> </values> return (functx:max-determine-type($in-xml//num), functx:max-determine-type($in-xml//string), functx:max-determine-type( $in-xml//(num|string))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-max-line-length-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Split a string into separate lines : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_lines.html : @param $arg the string to split :)          declare function functx:lines ( $arg as xs:string? ) as xs:string* { tokenize($arg, '(\r\n?|\n\r?)') } ;                     (:~ : The maximum line length : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-line-length.html : @param $arg the string to test :)          declare function functx:max-line-length ( $arg as xs:string? ) as xs:integer? { max( for $line in functx:lines($arg) return string-length($line)) } ;                     let $lines := 'a value on several lines' return (functx:max-line-length('a value'))) = (7). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-max-line-length-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Split a string into separate lines : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_lines.html : @param $arg the string to split :)          declare function functx:lines ( $arg as xs:string? ) as xs:string* { tokenize($arg, '(\r\n?|\n\r?)') } ;                     (:~ : The maximum line length : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-line-length.html : @param $arg the string to test :)          declare function functx:max-line-length ( $arg as xs:string? ) as xs:integer? { max( for $line in functx:lines($arg) return string-length($line)) } ;  let $lines := 'a       value       on       several      lines'           return (functx:max-line-length($lines))) = (12). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-max-line-length-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Split a string into separate lines : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_lines.html : @param $arg the string to split :)          declare function functx:lines ( $arg as xs:string? ) as xs:string* { tokenize($arg, '(\r\n?|\n\r?)') } ;                     (:~ : The maximum line length : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-line-length.html : @param $arg the string to test :)          declare function functx:max-line-length ( $arg as xs:string? ) as xs:integer? { max( for $line in functx:lines($arg) return string-length($line)) } ; let $lines := 'a       value       on       several      lines'           return (functx:max-line-length('a value'), functx:max-line-length($lines)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-max-node-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : The XML node whose typed value is the maximum : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-node.html : @param $nodes the sequence of nodes to test :)          declare function functx:max-node ( $nodes as node()* ) as node()* { $nodes[. = max($nodes)] } ;                     let $in-xml := <values> <int>1</int> <int>23</int> <int>115</int> </values> return (functx:max-node($in-xml//int)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-max-string-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The maximum of a sequence of values, treating them like strings : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-string.html : @param $strings the sequence of values :)          declare function functx:max-string ( $strings as xs:anyAtomicType* ) as xs:string? { max(for $string in $strings return string($string)) } ;                     let $in-xml := <in-xml> <x>a</x> <y>c</y> <z>b</z> </in-xml> return (functx:max-string( $in-xml/* )))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-max-string-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The maximum of a sequence of values, treating them like strings : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-string.html : @param $strings the sequence of values :)          declare function functx:max-string ( $strings as xs:anyAtomicType* ) as xs:string? { max(for $string in $strings return string($string)) } ;                     let $in-xml := <in-xml> <x>a</x> <y>c</y> <z>b</z> </in-xml> return (functx:max-string( (100,25,3) )))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-max-string-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The maximum of a sequence of values, treating them like strings : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-string.html : @param $strings the sequence of values :)          declare function functx:max-string ( $strings as xs:anyAtomicType* ) as xs:string? { max(for $string in $strings return string($string)) } ;                     let $in-xml := <in-xml> <x>a</x> <y>c</y> <z>b</z> </in-xml> return (functx:max-string( $in-xml/* ), functx:max-string( (100,25,3) )))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-min-determine-type-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The minimum value in a sequence, figuring out its type (numeric or string) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_min-determine-type.html : @param $seq the sequence of values to test :)          declare function functx:min-determine-type ( $seq as xs:anyAtomicType* ) as xs:anyAtomicType? { if (every $value in $seq satisfies ($value castable as xs:double)) then min(for $value in $seq return xs:double($value)) else min(for $value in $seq return xs:string($value)) } ;                     let $in-xml := <values> <nums> <num>12</num> <num>23</num> <num>115</num> <num>12.5</num> </nums> <strings> <str>def</str> <str>abc</str> </strings> </values> return (functx:min-determine-type($in-xml//num))) = (12). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-min-determine-type-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The minimum value in a sequence, figuring out its type (numeric or string) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_min-determine-type.html : @param $seq the sequence of values to test :)          declare function functx:min-determine-type ( $seq as xs:anyAtomicType* ) as xs:anyAtomicType? { if (every $value in $seq satisfies ($value castable as xs:double)) then min(for $value in $seq return xs:double($value)) else min(for $value in $seq return xs:string($value)) } ;                     let $in-xml := <values> <nums> <num>12</num> <num>23</num> <num>115</num> <num>12.5</num> </nums> <strings> <str>def</str> <str>abc</str> </strings> </values> return (functx:min-determine-type($in-xml//str)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-min-determine-type-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The minimum value in a sequence, figuring out its type (numeric or string) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_min-determine-type.html : @param $seq the sequence of values to test :)          declare function functx:min-determine-type ( $seq as xs:anyAtomicType* ) as xs:anyAtomicType? { if (every $value in $seq satisfies ($value castable as xs:double)) then min(for $value in $seq return xs:double($value)) else min(for $value in $seq return xs:string($value)) } ;                     let $in-xml := <values> <nums> <num>12</num> <num>23</num> <num>115</num> <num>12.5</num> </nums> <strings> <str>def</str> <str>abc</str> </strings> </values> return (functx:min-determine-type($in-xml//(num|str))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-min-determine-type-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The minimum value in a sequence, figuring out its type (numeric or string) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_min-determine-type.html : @param $seq the sequence of values to test :)          declare function functx:min-determine-type ( $seq as xs:anyAtomicType* ) as xs:anyAtomicType? { if (every $value in $seq satisfies ($value castable as xs:double)) then min(for $value in $seq return xs:double($value)) else min(for $value in $seq return xs:string($value)) } ;                     let $in-xml := <values> <nums> <num>12</num> <num>23</num> <num>115</num> <num>12.5</num> </nums> <strings> <str>def</str> <str>abc</str> </strings> </values> return (functx:min-determine-type($in-xml//num), functx:min-determine-type($in-xml//str), functx:min-determine-type($in-xml//(num|str))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-min-node-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : The XML node whose typed value is the minimum : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_min-node.html : @param $nodes the sequence of nodes to test :)          declare function functx:min-node ( $nodes as node()* ) as node()* { $nodes[. = min($nodes)] } ;                     let $in-xml := <values> <int>1</int> <int>23</int> <int>115</int> </values> return (functx:min-node($in-xml//int)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-min-non-empty-string-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The minimum of a sequence of strings, ignoring "empty" values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_min-non-empty-string.html : @param $strings the sequence of strings to search :)          declare function functx:min-non-empty-string ( $strings as xs:string* ) as xs:string? { min($strings[. != '']) } ;                     let $in-xml := <authors> <author> <fName/> <lName>Smith</lName> </author> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:min-non-empty-string( $in-xml//fName )))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-min-string-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The minimum of a sequence of values, treating them like strings : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_min-string.html : @param $strings the sequence of strings :)          declare function functx:min-string ( $strings as xs:anyAtomicType* ) as xs:string? { min(for $string in $strings return string($string)) } ;                     let $in-xml := <in-xml> <x>a</x> <y>c</y> <z>b</z> </in-xml> return (functx:min-string( $in-xml/* )))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-min-string-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The minimum of a sequence of values, treating them like strings : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_min-string.html : @param $strings the sequence of strings :)          declare function functx:min-string ( $strings as xs:anyAtomicType* ) as xs:string? { min(for $string in $strings return string($string)) } ;                     let $in-xml := <in-xml> <x>a</x> <y>c</y> <z>b</z> </in-xml> return (functx:min-string( (100,25,3) )))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-min-string-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The minimum of a sequence of values, treating them like strings : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_min-string.html : @param $strings the sequence of strings :)          declare function functx:min-string ( $strings as xs:anyAtomicType* ) as xs:string? { min(for $string in $strings return string($string)) } ;                     let $in-xml := <in-xml> <x>a</x> <y>c</y> <z>b</z> </in-xml> return (functx:min-string( $in-xml/* ), functx:min-string( (100,25,3) )))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-mmddyyyy-to-date-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Converts a string with format MMDDYYYY (with any delimiters) to a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_mmddyyyy-to-date.html : @param $dateString the MMDDYYYY string :)          declare function functx:mmddyyyy-to-date ( $dateString as xs:string? ) as xs:date? { if (empty($dateString)) then () else if (not(matches($dateString, '^\D*(\d{2})\D*(\d{2})\D*(\d{4})\D*$'))) then error(xs:QName('functx:Invalid_Date_Format')) else xs:date(replace($dateString, '^\D*(\d{2})\D*(\d{2})\D*(\d{4})\D*$', '$3-$1-$2')) } ;                     (functx:mmddyyyy-to-date('12-15-2004')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-mmddyyyy-to-date-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Converts a string with format MMDDYYYY (with any delimiters) to a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_mmddyyyy-to-date.html : @param $dateString the MMDDYYYY string :)          declare function functx:mmddyyyy-to-date ( $dateString as xs:string? ) as xs:date? { if (empty($dateString)) then () else if (not(matches($dateString, '^\D*(\d{2})\D*(\d{2})\D*(\d{4})\D*$'))) then error(xs:QName('functx:Invalid_Date_Format')) else xs:date(replace($dateString, '^\D*(\d{2})\D*(\d{2})\D*(\d{4})\D*$', '$3-$1-$2')) } ;                     (functx:mmddyyyy-to-date('12152004')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-mmddyyyy-to-date-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Converts a string with format MMDDYYYY (with any delimiters) to a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_mmddyyyy-to-date.html : @param $dateString the MMDDYYYY string :)          declare function functx:mmddyyyy-to-date ( $dateString as xs:string? ) as xs:date? { if (empty($dateString)) then () else if (not(matches($dateString, '^\D*(\d{2})\D*(\d{2})\D*(\d{4})\D*$'))) then error(xs:QName('functx:Invalid_Date_Format')) else xs:date(replace($dateString, '^\D*(\d{2})\D*(\d{2})\D*(\d{4})\D*$', '$3-$1-$2')) } ;                     (functx:mmddyyyy-to-date('12/15/2004')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-mmddyyyy-to-date-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Converts a string with format MMDDYYYY (with any delimiters) to a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_mmddyyyy-to-date.html : @param $dateString the MMDDYYYY string :)          declare function functx:mmddyyyy-to-date ( $dateString as xs:string? ) as xs:date? { if (empty($dateString)) then () else if (not(matches($dateString, '^\D*(\d{2})\D*(\d{2})\D*(\d{4})\D*$'))) then error(xs:QName('functx:Invalid_Date_Format')) else xs:date(replace($dateString, '^\D*(\d{2})\D*(\d{2})\D*(\d{4})\D*$', '$3-$1-$2')) } ;                     (functx:mmddyyyy-to-date('12-15-2004'), functx:mmddyyyy-to-date('12152004'), functx:mmddyyyy-to-date('12/15/2004')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-month-abbrev-en-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The month of a date as an abbreviated word (Jan, Feb, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_month-abbrev-en.html : @param $date the date :)          declare function functx:month-abbrev-en ( $date as xs:anyAtomicType? ) as xs:string? { ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec') [month-from-date(xs:date($date))] } ;                     (functx:month-abbrev-en(xs:date('2004-01-23'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-month-abbrev-en-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The month of a date as an abbreviated word (Jan, Feb, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_month-abbrev-en.html : @param $date the date :)          declare function functx:month-abbrev-en ( $date as xs:anyAtomicType? ) as xs:string? { ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec') [month-from-date(xs:date($date))] } ;                     (functx:month-abbrev-en( xs:dateTime('2004-01-23T12:00:13'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-month-abbrev-en-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The month of a date as an abbreviated word (Jan, Feb, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_month-abbrev-en.html : @param $date the date :)          declare function functx:month-abbrev-en ( $date as xs:anyAtomicType? ) as xs:string? { ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec') [month-from-date(xs:date($date))] } ;                     (functx:month-abbrev-en('2004-01-23')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-month-abbrev-en-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The month of a date as an abbreviated word (Jan, Feb, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_month-abbrev-en.html : @param $date the date :)          declare function functx:month-abbrev-en ( $date as xs:anyAtomicType? ) as xs:string? { ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec') [month-from-date(xs:date($date))] } ;                     (functx:month-abbrev-en(xs:date('2004-01-23')), functx:month-abbrev-en( xs:dateTime('2004-01-23T12:00:13')), functx:month-abbrev-en('2004-01-23')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-month-name-en-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The month of a date as a word (January, February, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_month-name-en.html : @param $date the date :)          declare function functx:month-name-en ( $date as xs:anyAtomicType? ) as xs:string? { ('January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December') [month-from-date(xs:date($date))] } ;                     (functx:month-name-en(xs:date('2004-01-23'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-month-name-en-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The month of a date as a word (January, February, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_month-name-en.html : @param $date the date :)          declare function functx:month-name-en ( $date as xs:anyAtomicType? ) as xs:string? { ('January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December') [month-from-date(xs:date($date))] } ;                     (functx:month-name-en( xs:dateTime('2004-01-23T12:00:13'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-month-name-en-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The month of a date as a word (January, February, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_month-name-en.html : @param $date the date :)          declare function functx:month-name-en ( $date as xs:anyAtomicType? ) as xs:string? { ('January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December') [month-from-date(xs:date($date))] } ;                     (functx:month-name-en('2004-01-23')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-month-name-en-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The month of a date as a word (January, February, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_month-name-en.html : @param $date the date :)          declare function functx:month-name-en ( $date as xs:anyAtomicType? ) as xs:string? { ('January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December') [month-from-date(xs:date($date))] } ;                     (functx:month-name-en(xs:date('2004-01-23')), functx:month-name-en( xs:dateTime('2004-01-23T12:00:13')), functx:month-name-en('2004-01-23')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-name-test-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml := <pre:a xmlns:pre="http://ns.example.com/ns1">abc</pre:a> return (functx:name-test(name($in-xml),('*'))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-name-test-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml := <pre:a xmlns:pre="http://ns.example.com/ns1">abc</pre:a> return (functx:name-test(name($in-xml),('pre:*'))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-name-test-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml := <pre:a xmlns:pre="http://ns.example.com/ns1">abc</pre:a> return (functx:name-test(name($in-xml),('*:a'))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-name-test-4,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml := <pre:a xmlns:pre="http://ns.example.com/ns1">abc</pre:a> return (functx:name-test( name($in-xml),('pre:a','pre:b'))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-name-test-5,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml := <pre:a xmlns:pre="http://ns.example.com/ns1">abc</pre:a> return (functx:name-test( name($in-xml),('a','b','c'))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-name-test-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml := <pre:a xmlns:pre="http://ns/example.com/ns1">abc</pre:a> return (functx:name-test(name($in-xml),('*')), functx:name-test(name($in-xml),('pre:*')), functx:name-test(name($in-xml),('*:a')), functx:name-test( name($in-xml),('pre:a','pre:b')), functx:name-test( name($in-xml),('a','b','c'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-namespaces-in-use-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : A list of namespaces used in element/attribute names in an XML fragment : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_namespaces-in-use.html : @param $root the root node to start from :)          declare function functx:namespaces-in-use ( $root as node()? ) as xs:anyURI* { distinct-values( $root/descendant-or-self::*/(.|@*)/namespace-uri(.)) } ;                     let $in-xml := <authors xmlns="http://ns.example.com/abc" xmlns:d="http://ns.example.com/def"> <author xmlns="http://ns.example.com/ghi"> <fName xmlns:x="http://ns.example.com/xyz" x:attr="123">Kate</fName> <lName>Jones</lName> </author> </authors> return (functx:namespaces-in-use($in-xml)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-next-day-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The next day : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_next-day.html : @param $date the date :)          declare function functx:next-day ( $date as xs:anyAtomicType? ) as xs:date? { xs:date($date) + xs:dayTimeDuration('P1D') } ;                     (functx:next-day(xs:date('2004-01-23'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-next-day-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The next day : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_next-day.html : @param $date the date :)          declare function functx:next-day ( $date as xs:anyAtomicType? ) as xs:date? { xs:date($date) + xs:dayTimeDuration('P1D') } ;                     (functx:next-day( xs:dateTime('2005-12-31T12:00:13'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-next-day-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The next day : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_next-day.html : @param $date the date :)          declare function functx:next-day ( $date as xs:anyAtomicType? ) as xs:date? { xs:date($date) + xs:dayTimeDuration('P1D') } ;                     (functx:next-day(xs:date('2004-01-23')), functx:next-day( xs:dateTime('2005-12-31T12:00:13'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-node-kind-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The XML node kind (element, attribute, text, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_node-kind.html : @param $nodes the node(s) whose kind you want to determine :)          declare function functx:node-kind ( $nodes as node()* ) as xs:string* { for $node in $nodes return if ($node instance of element()) then 'element' else if ($node instance of attribute()) then 'attribute' else if ($node instance of text()) then 'text' else if ($node instance of document-node()) then 'document-node' else if ($node instance of comment()) then 'comment' else if ($node instance of processing-instruction()) then 'processing-instruction' else 'unknown' } ;                     let $in-xml := <in-xml> <!-- this is in-xml --> <?test see?> <a z="2">xyz</a> </in-xml> return (functx:node-kind($in-xml/a)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-node-kind-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The XML node kind (element, attribute, text, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_node-kind.html : @param $nodes the node(s) whose kind you want to determine :)          declare function functx:node-kind ( $nodes as node()* ) as xs:string* { for $node in $nodes return if ($node instance of element()) then 'element' else if ($node instance of attribute()) then 'attribute' else if ($node instance of text()) then 'text' else if ($node instance of document-node()) then 'document-node' else if ($node instance of comment()) then 'comment' else if ($node instance of processing-instruction()) then 'processing-instruction' else 'unknown' } ;                     let $in-xml := <in-xml> <!-- this is in-xml --> <?test see?> <a z="2">xyz</a> </in-xml> return (functx:node-kind($in-xml/a/@z)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-node-kind-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The XML node kind (element, attribute, text, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_node-kind.html : @param $nodes the node(s) whose kind you want to determine :)          declare function functx:node-kind ( $nodes as node()* ) as xs:string* { for $node in $nodes return if ($node instance of element()) then 'element' else if ($node instance of attribute()) then 'attribute' else if ($node instance of text()) then 'text' else if ($node instance of document-node()) then 'document-node' else if ($node instance of comment()) then 'comment' else if ($node instance of processing-instruction()) then 'processing-instruction' else 'unknown' } ;                     let $in-xml := <in-xml> <!-- this is in-xml --> <?test see?> <a z="2">xyz</a> </in-xml> return (functx:node-kind($in-xml/comment())))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-node-kind-4,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The XML node kind (element, attribute, text, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_node-kind.html : @param $nodes the node(s) whose kind you want to determine :)          declare function functx:node-kind ( $nodes as node()* ) as xs:string* { for $node in $nodes return if ($node instance of element()) then 'element' else if ($node instance of attribute()) then 'attribute' else if ($node instance of text()) then 'text' else if ($node instance of document-node()) then 'document-node' else if ($node instance of comment()) then 'comment' else if ($node instance of processing-instruction()) then 'processing-instruction' else 'unknown' } ;                     let $in-xml := <in-xml> <!-- this is in-xml --> <?test see?> <a z="2">xyz</a> </in-xml> return (functx:node-kind( $in-xml/processing-instruction())))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-node-kind-5,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The XML node kind (element, attribute, text, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_node-kind.html : @param $nodes the node(s) whose kind you want to determine :)          declare function functx:node-kind ( $nodes as node()* ) as xs:string* { for $node in $nodes return if ($node instance of element()) then 'element' else if ($node instance of attribute()) then 'attribute' else if ($node instance of text()) then 'text' else if ($node instance of document-node()) then 'document-node' else if ($node instance of comment()) then 'comment' else if ($node instance of processing-instruction()) then 'processing-instruction' else 'unknown' } ;                     let $in-xml := <in-xml> <!-- this is in-xml --> <?test see?> <a z="2">xyz</a> </in-xml> return (functx:node-kind($in-xml/a/text())))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-node-kind-6,Error: XPST0003: Unable to parse XPath: (          declare namespace functx = "http://www.example.com/";                     (:~ : The XML node kind (element, attribute, text, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_node-kind.html : @param $nodes the node(s) whose kind you want to determine :)          declare function functx:node-kind ( $nodes as node()* ) as xs:string* { for $node in $nodes return if ($node instance of element()) then 'element' else if ($node instance of attribute()) then 'attribute' else if ($node instance of text()) then 'text' else if ($node instance of document-node()) then 'document-node' else if ($node instance of comment()) then 'comment' else if ($node instance of processing-instruction()) then 'processing-instruction' else 'unknown' } ;          let $in-xml := <in-xml> <!-- this is in-xml --> <?test see?> <a z="2">xyz</a> </in-xml>           return (functx:node-kind(/))       )!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-node-kind-all,Error: XPST0003: Unable to parse XPath: (       	declare namespace functx = "http://www.example.com/";                                         (:~ : The XML node kind (element, attribute, text, etc.) :                          : @author Priscilla Walmsley, Datypic : @version 1.0                         : @see http://www.xqueryfunctions.com/xq/functx_node-kind.html                         : @param $nodes the node(s) whose kind you want to determine :)          declare function functx:node-kind ( $nodes as node()* ) as xs:string* {           	for $node in $nodes return           		if ($node instance of element()) then 'element'           		else if ($node instance of attribute()) then 'attribute'           		else if ($node instance of text()) then 'text'           		else if ($node instance of document-node()) then 'document-node'           		else if ($node instance of comment()) then 'comment'           		else if ($node instance of processing-instruction()) then 'processing-instruction'           		else 'unknown' } ;          let $in-xml := <in-xml> <!-- this is in-xml --> <?test see?> <a z="2">xyz</a> </in-xml>           return (functx:node-kind($in-xml/a),                      functx:node-kind($in-xml/a/@z),                      functx:node-kind($in-xml/comment()),                      functx:node-kind( $in-xml/processing-instruction()),                      functx:node-kind($in-xml/a/text()),                      functx:node-kind(/)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-non-distinct-values-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Returns any values that appear more than once in a sequence : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_non-distinct-values.html : @param $seq the sequence of values :)          declare function functx:non-distinct-values ( $seq as xs:anyAtomicType* ) as xs:anyAtomicType* { for $val in distinct-values($seq) return $val[count($seq[. = $val]) >                     1] } ;                     (functx:non-distinct-values( (1,2,1,3)))) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-non-distinct-values-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Returns any values that appear more than once in a sequence : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_non-distinct-values.html : @param $seq the sequence of values :)          declare function functx:non-distinct-values ( $seq as xs:anyAtomicType* ) as xs:anyAtomicType* { for $val in distinct-values($seq) return $val[count($seq[. = $val]) >                     1] } ;                     (functx:non-distinct-values( (1,2,1,3,2.0))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-non-distinct-values-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Returns any values that appear more than once in a sequence : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_non-distinct-values.html : @param $seq the sequence of values :)          declare function functx:non-distinct-values ( $seq as xs:anyAtomicType* ) as xs:anyAtomicType* { for $val in distinct-values($seq) return $val[count($seq[. = $val]) >                     1] } ;                     (functx:non-distinct-values( (1,2,3) )))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-non-distinct-values-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Returns any values that appear more than once in a sequence : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_non-distinct-values.html : @param $seq the sequence of values :)          declare function functx:non-distinct-values ( $seq as xs:anyAtomicType* ) as xs:anyAtomicType* { for $val in distinct-values($seq) return $val[count($seq[. = $val]) >                     1] } ;                     (functx:non-distinct-values( (1,2,1,3)), functx:non-distinct-values( (1,2,1,3,2.0)), functx:non-distinct-values( (1,2,3) )))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-number-of-matches-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The number of regions that match a pattern : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_number-of-matches.html : @param $arg the string to test : @param $pattern the regular expression :)          declare function functx:number-of-matches ( $arg as xs:string? , $pattern as xs:string ) as xs:integer { count(tokenize($arg,$pattern)) - 1 } ;                     (functx:number-of-matches('abcabc','ab'))) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-number-of-matches-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The number of regions that match a pattern : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_number-of-matches.html : @param $arg the string to test : @param $pattern the regular expression :)          declare function functx:number-of-matches ( $arg as xs:string? , $pattern as xs:string ) as xs:integer { count(tokenize($arg,$pattern)) - 1 } ;                     (functx:number-of-matches('12345','\d'))) = (5). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-number-of-matches-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The number of regions that match a pattern : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_number-of-matches.html : @param $arg the string to test : @param $pattern the regular expression :)          declare function functx:number-of-matches ( $arg as xs:string? , $pattern as xs:string ) as xs:integer { count(tokenize($arg,$pattern)) - 1 } ;                     (functx:number-of-matches('aaaaaa','aaa'))) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-number-of-matches-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The number of regions that match a pattern : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_number-of-matches.html : @param $arg the string to test : @param $pattern the regular expression :)          declare function functx:number-of-matches ( $arg as xs:string? , $pattern as xs:string ) as xs:integer { count(tokenize($arg,$pattern)) - 1 } ;                     (functx:number-of-matches('abcabc','ab'), functx:number-of-matches('12345','\d'), functx:number-of-matches('aaaaaa','aaa')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-ordinal-number-en-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Reformats a number as an ordinal number, e.g. 1st, 2nd, 3rd. : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_ordinal-number-en.html : @param $num the number :)          declare function functx:ordinal-number-en ( $num as xs:integer? ) as xs:string { concat(xs:string($num), if (matches(xs:string($num),'[04-9]$|1[1-3]$')) then 'th' else if (ends-with(xs:string($num),'1')) then 'st' else if (ends-with(xs:string($num),'2')) then 'nd' else if (ends-with(xs:string($num),'3')) then 'rd' else '') } ;                     (functx:ordinal-number-en(1)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-ordinal-number-en-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Reformats a number as an ordinal number, e.g. 1st, 2nd, 3rd. : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_ordinal-number-en.html : @param $num the number :)          declare function functx:ordinal-number-en ( $num as xs:integer? ) as xs:string { concat(xs:string($num), if (matches(xs:string($num),'[04-9]$|1[1-3]$')) then 'th' else if (ends-with(xs:string($num),'1')) then 'st' else if (ends-with(xs:string($num),'2')) then 'nd' else if (ends-with(xs:string($num),'3')) then 'rd' else '') } ;                     (functx:ordinal-number-en(12)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-ordinal-number-en-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Reformats a number as an ordinal number, e.g. 1st, 2nd, 3rd. : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_ordinal-number-en.html : @param $num the number :)          declare function functx:ordinal-number-en ( $num as xs:integer? ) as xs:string { concat(xs:string($num), if (matches(xs:string($num),'[04-9]$|1[1-3]$')) then 'th' else if (ends-with(xs:string($num),'1')) then 'st' else if (ends-with(xs:string($num),'2')) then 'nd' else if (ends-with(xs:string($num),'3')) then 'rd' else '') } ;                     (functx:ordinal-number-en(1), functx:ordinal-number-en(12)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-pad-integer-to-length-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Pads an integer to a desired length by adding leading zeros : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-integer-to-length.html : @param $integerToPad the integer to pad : @param $length the desired length :)          declare function functx:pad-integer-to-length ( $integerToPad as xs:anyAtomicType? , $length as xs:integer ) as xs:string { if ($length < string-length(string($integerToPad))) then error(xs:QName('functx:Integer_Longer_Than_Length')) else concat (functx:repeat-string( '0',$length - string-length(string($integerToPad))), string($integerToPad)) } ;                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:pad-integer-to-length(12, 6)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-pad-integer-to-length-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Pads an integer to a desired length by adding leading zeros : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-integer-to-length.html : @param $integerToPad the integer to pad : @param $length the desired length :)          declare function functx:pad-integer-to-length ( $integerToPad as xs:anyAtomicType? , $length as xs:integer ) as xs:string { if ($length < string-length(string($integerToPad))) then error(xs:QName('functx:Integer_Longer_Than_Length')) else concat (functx:repeat-string( '0',$length - string-length(string($integerToPad))), string($integerToPad)) } ;                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:pad-integer-to-length(1, 6)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-pad-integer-to-length-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Pads an integer to a desired length by adding leading zeros : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-integer-to-length.html : @param $integerToPad the integer to pad : @param $length the desired length :)          declare function functx:pad-integer-to-length ( $integerToPad as xs:anyAtomicType? , $length as xs:integer ) as xs:string { if ($length < string-length(string($integerToPad))) then error(xs:QName('functx:Integer_Longer_Than_Length')) else concat (functx:repeat-string( '0',$length - string-length(string($integerToPad))), string($integerToPad)) } ;                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:pad-integer-to-length(12, 2)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-pad-integer-to-length-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Pads an integer to a desired length by adding leading zeros : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-integer-to-length.html : @param $integerToPad the integer to pad : @param $length the desired length :)          declare function functx:pad-integer-to-length ( $integerToPad as xs:anyAtomicType? , $length as xs:integer ) as xs:string { if ($length < string-length(string($integerToPad))) then error(xs:QName('functx:Integer_Longer_Than_Length')) else concat (functx:repeat-string( '0',$length - string-length(string($integerToPad))), string($integerToPad)) } ;                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:pad-integer-to-length(12, 6), functx:pad-integer-to-length(1, 6), functx:pad-integer-to-length(12, 2)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-pad-string-to-length-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Pads a string to a desired length : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-string-to-length.html : @param $stringToPad the string to pad : @param $padChar the character(s) to use as padding : @param $length the desired length :)          declare function functx:pad-string-to-length ( $stringToPad as xs:string? , $padChar as xs:string , $length as xs:integer ) as xs:string { substring( string-join ( ($stringToPad, for $i in (1 to $length) return $padChar) ,'') ,1,$length) } ;                     (functx:pad-string-to-length('abc', '*', 6)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-pad-string-to-length-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Pads a string to a desired length : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-string-to-length.html : @param $stringToPad the string to pad : @param $padChar the character(s) to use as padding : @param $length the desired length :)          declare function functx:pad-string-to-length ( $stringToPad as xs:string? , $padChar as xs:string , $length as xs:integer ) as xs:string { substring( string-join ( ($stringToPad, for $i in (1 to $length) return $padChar) ,'') ,1,$length) } ;                     (functx:pad-string-to-length('abcdef', '*', 4)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-pad-string-to-length-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Pads a string to a desired length : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-string-to-length.html : @param $stringToPad the string to pad : @param $padChar the character(s) to use as padding : @param $length the desired length :)          declare function functx:pad-string-to-length ( $stringToPad as xs:string? , $padChar as xs:string , $length as xs:integer ) as xs:string { substring( string-join ( ($stringToPad, for $i in (1 to $length) return $padChar) ,'') ,1,$length) } ;                     (functx:pad-string-to-length('', '*', 4)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-pad-string-to-length-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Pads a string to a desired length : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-string-to-length.html : @param $stringToPad the string to pad : @param $padChar the character(s) to use as padding : @param $length the desired length :)          declare function functx:pad-string-to-length ( $stringToPad as xs:string? , $padChar as xs:string , $length as xs:integer ) as xs:string { substring( string-join ( ($stringToPad, for $i in (1 to $length) return $padChar) ,'') ,1,$length) } ;                     (functx:pad-string-to-length('abc', '*', 6), functx:pad-string-to-length('abcdef', '*', 4), functx:pad-string-to-length('', '*', 4)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-path-to-node-with-pos-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on node identity : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[$nodes[$seq] is $nodeToFind] } ;                     (:~ : A unique path to an XML node (or sequence of nodes) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_path-to-node-with-pos.html : @param $node the node sequence :)          declare function functx:path-to-node-with-pos ( $node as node()? ) as xs:string { string-join( for $ancestor in $node/ancestor-or-self::* let $sibsOfSameName := $ancestor/../*[name() = name($ancestor)] return concat(name($ancestor), if (count($sibsOfSameName) <= 1) then '' else concat( '[',functx:index-of-node($sibsOfSameName,$ancestor),']')) , '/') } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:path-to-node-with-pos( $in-xml//lName[. = 'Doe'])))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-path-to-node-with-pos-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on node identity : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[$nodes[$seq] is $nodeToFind] } ;                     (:~ : A unique path to an XML node (or sequence of nodes) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_path-to-node-with-pos.html : @param $node the node sequence :)          declare function functx:path-to-node-with-pos ( $node as node()? ) as xs:string { string-join( for $ancestor in $node/ancestor-or-self::* let $sibsOfSameName := $ancestor/../*[name() = name($ancestor)] return concat(name($ancestor), if (count($sibsOfSameName) <= 1) then '' else concat( '[',functx:index-of-node($sibsOfSameName,$ancestor),']')) , '/') } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:path-to-node-with-pos($in-xml/*[1])))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-path-to-node-with-pos-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on node identity : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[$nodes[$seq] is $nodeToFind] } ;                     (:~ : A unique path to an XML node (or sequence of nodes) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_path-to-node-with-pos.html : @param $node the node sequence :)          declare function functx:path-to-node-with-pos ( $node as node()? ) as xs:string { string-join( for $ancestor in $node/ancestor-or-self::* let $sibsOfSameName := $ancestor/../*[name() = name($ancestor)] return concat(name($ancestor), if (count($sibsOfSameName) <= 1) then '' else concat( '[',functx:index-of-node($sibsOfSameName,$ancestor),']')) , '/') } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:path-to-node-with-pos( $in-xml//lName[. = 'Doe']), functx:path-to-node-with-pos($in-xml/*[1])))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-path-to-node-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : A path to an XML node (or sequence of nodes) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_path-to-node.html : @param $nodes the node sequence :)          declare function functx:path-to-node ( $nodes as node()* ) as xs:string* { $nodes/string-join(ancestor-or-self::*/name(.), '/') } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:path-to-node($in-xml//lName[. = 'Doe'])))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-path-to-node-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : A path to an XML node (or sequence of nodes) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_path-to-node.html : @param $nodes the node sequence :)          declare function functx:path-to-node ( $nodes as node()* ) as xs:string* { $nodes/string-join(ancestor-or-self::*/name(.), '/') } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:path-to-node($in-xml/*[1])))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-path-to-node-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : A path to an XML node (or sequence of nodes) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_path-to-node.html : @param $nodes the node sequence :)          declare function functx:path-to-node ( $nodes as node()* ) as xs:string* { $nodes/string-join(ancestor-or-self::*/name(.), '/') } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:path-to-node($in-xml//lName[. = 'Doe']), functx:path-to-node($in-xml/*[1])))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-precedes-not-ancestor-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node precedes another without being its ancestor : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_precedes-not-ancestor.html : @param $a the first node : @param $b the second node :)          declare function functx:precedes-not-ancestor ( $a as node()? , $b as node()? ) as xs:boolean { $a << $b and empty($a intersect $b/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:precedes-not-ancestor( $in-xml//author[1],$in-xml//author[2])). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-precedes-not-ancestor-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node precedes another without being its ancestor : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_precedes-not-ancestor.html : @param $a the first node : @param $b the second node :)          declare function functx:precedes-not-ancestor ( $a as node()? , $b as node()? ) as xs:boolean { $a << $b and empty($a intersect $b/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:precedes-not-ancestor( $in-xml//author[1], $in-xml//author[1]/fName)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-precedes-not-ancestor-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node precedes another without being its ancestor : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_precedes-not-ancestor.html : @param $a the first node : @param $b the second node :)          declare function functx:precedes-not-ancestor ( $a as node()? , $b as node()? ) as xs:boolean { $a << $b and empty($a intersect $b/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:precedes-not-ancestor( $in-xml//author[2],$in-xml//author[1])). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-precedes-not-ancestor-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node precedes another without being its ancestor : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_precedes-not-ancestor.html : @param $a the first node : @param $b the second node :)          declare function functx:precedes-not-ancestor ( $a as node()? , $b as node()? ) as xs:boolean { $a << $b and empty($a intersect $b/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:precedes-not-ancestor( $in-xml//author[1],$in-xml//author[2]), functx:precedes-not-ancestor( $in-xml//author[1], $in-xml//author[1]/fName), functx:precedes-not-ancestor( $in-xml//author[2],$in-xml//author[1])))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-previous-day-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The previous day : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_previous-day.html : @param $date the date :)          declare function functx:previous-day ( $date as xs:anyAtomicType? ) as xs:date? { xs:date($date) - xs:dayTimeDuration('P1D') } ;                     (functx:previous-day(xs:date('2004-01-23'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-previous-day-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The previous day : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_previous-day.html : @param $date the date :)          declare function functx:previous-day ( $date as xs:anyAtomicType? ) as xs:date? { xs:date($date) - xs:dayTimeDuration('P1D') } ;                     (functx:previous-day( xs:dateTime('2005-01-01T12:00:13'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-previous-day-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The previous day : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_previous-day.html : @param $date the date :)          declare function functx:previous-day ( $date as xs:anyAtomicType? ) as xs:date? { xs:date($date) - xs:dayTimeDuration('P1D') } ;                     (functx:previous-day(xs:date('2004-01-23')), functx:previous-day( xs:dateTime('2005-01-01T12:00:13'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-remove-attributes-deep-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML fragment, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes-deep.html : @param $nodes the root(s) to start from : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then element { node-name($node)} { $node/@*[not(functx:name-test(name(),$names))], functx:remove-attributes-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-attributes-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456"> <b attr1="xzy">abc</b> </a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456"> <b a:attr1="ghi" attr1="xzy">abc</b> </a> return (functx:remove-attributes-deep( $in-xml-1, ('attr1','attr2'))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-remove-attributes-deep-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML fragment, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes-deep.html : @param $nodes the root(s) to start from : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then element { node-name($node)} { $node/@*[not(functx:name-test(name(),$names))], functx:remove-attributes-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-attributes-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456"> <b attr1="xzy">abc</b> </a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456"> <b a:attr1="ghi" attr1="xzy">abc</b> </a> return (functx:remove-attributes-deep( $in-xml-1, ('attr1','attr3'))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-remove-attributes-deep-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML fragment, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes-deep.html : @param $nodes the root(s) to start from : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then element { node-name($node)} { $node/@*[not(functx:name-test(name(),$names))], functx:remove-attributes-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-attributes-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456"> <b attr1="xzy">abc</b> </a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456"> <b a:attr1="ghi" attr1="xzy">abc</b> </a> return (functx:remove-attributes-deep( $in-xml-2, 'a:attr1')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-remove-attributes-deep-all,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML fragment, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes-deep.html : @param $nodes the root(s) to start from : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then element { node-name($node)} { $node/@*[not(functx:name-test(name(),$names))], functx:remove-attributes-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-attributes-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456"> <b attr1="xzy">abc</b> </a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456"> <b a:attr1="ghi" attr1="xzy">abc</b> </a> return (functx:remove-attributes-deep( $in-xml-1, ('attr1','attr2')), functx:remove-attributes-deep( $in-xml-1, ('attr1','attr3')), functx:remove-attributes-deep( $in-xml-2, 'a:attr1')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-remove-attributes-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML element, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes.html : @param $elements the element(s) from which to remove the attributes : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes ( $elements as element()* , $names as xs:string* ) as element() { for $element in $elements return element {node-name($element)} {$element/@*[not(functx:name-test(name(),$names))], $element/node() } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456">abc</a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456">abc</a> return (functx:remove-attributes( $in-xml-1, ('attr1','attr2'))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-remove-attributes-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML element, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes.html : @param $elements the element(s) from which to remove the attributes : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes ( $elements as element()* , $names as xs:string* ) as element() { for $element in $elements return element {node-name($element)} {$element/@*[not(functx:name-test(name(),$names))], $element/node() } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456">abc</a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456">abc</a> return (functx:remove-attributes( $in-xml-1, ('attr1','attr3'))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-remove-attributes-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML element, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes.html : @param $elements the element(s) from which to remove the attributes : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes ( $elements as element()* , $names as xs:string* ) as element() { for $element in $elements return element {node-name($element)} {$element/@*[not(functx:name-test(name(),$names))], $element/node() } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456">abc</a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456">abc</a> return (functx:remove-attributes($in-xml-1, '*')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-remove-attributes-4,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML element, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes.html : @param $elements the element(s) from which to remove the attributes : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes ( $elements as element()* , $names as xs:string* ) as element() { for $element in $elements return element {node-name($element)} {$element/@*[not(functx:name-test(name(),$names))], $element/node() } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456">abc</a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456">abc</a> return (functx:remove-attributes( $in-xml-2, ('a:attr1'))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-remove-attributes-all,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML element, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes.html : @param $elements the element(s) from which to remove the attributes : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes ( $elements as element()* , $names as xs:string* ) as element() { for $element in $elements return element {node-name($element)} {$element/@*[not(functx:name-test(name(),$names))], $element/node() } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456">abc</a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456">abc</a> return (functx:remove-attributes( $in-xml-1, ('attr1','attr2')), functx:remove-attributes( $in-xml-1, ('attr1','attr3')), functx:remove-attributes($in-xml-1, '*'), functx:remove-attributes( $in-xml-2, ('a:attr1'))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-remove-elements-deep-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-deep.html : @param $nodes root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then () else element { node-name($node)} { $node/@*, functx:remove-elements-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-elements-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <x:b>b1</x:b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return (functx:remove-elements-deep( $in-xml-1, 'b')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-remove-elements-deep-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-deep.html : @param $nodes root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then () else element { node-name($node)} { $node/@*, functx:remove-elements-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-elements-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <x:b>b1</x:b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return (functx:remove-elements-deep( $in-xml-1, 'a')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-remove-elements-deep-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-deep.html : @param $nodes root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then () else element { node-name($node)} { $node/@*, functx:remove-elements-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-elements-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <x:b>b1</x:b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return (functx:remove-elements-deep( $in-xml-1, ('b','c'))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-remove-elements-deep-4,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-deep.html : @param $nodes root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then () else element { node-name($node)} { $node/@*, functx:remove-elements-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-elements-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <x:b>b1</x:b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return (functx:remove-elements-deep( $in-xml-2, 'x:b')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-remove-elements-deep-all,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-deep.html : @param $nodes root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then () else element { node-name($node)} { $node/@*, functx:remove-elements-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-elements-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <x:b>b1</x:b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return (functx:remove-elements-deep( $in-xml-1, 'b'), functx:remove-elements-deep( $in-xml-1, 'a'), functx:remove-elements-deep( $in-xml-1, ('b','c')), functx:remove-elements-deep( $in-xml-2, 'x:b')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-remove-elements-not-contents-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant XML elements but keeps their content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-not-contents.html : @param $nodes the root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-not-contents ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then functx:remove-elements-not-contents($node/node(), $names) else element {node-name($node)} {$node/@*, functx:remove-elements-not-contents($node/node(),$names)} else if ($node instance of document-node()) then functx:remove-elements-not-contents($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <x:b>content</x:b></c> </in-xml> return (functx:remove-elements-not-contents( $in-xml-1, 'b')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-remove-elements-not-contents-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant XML elements but keeps their content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-not-contents.html : @param $nodes the root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-not-contents ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then functx:remove-elements-not-contents($node/node(), $names) else element {node-name($node)} {$node/@*, functx:remove-elements-not-contents($node/node(),$names)} else if ($node instance of document-node()) then functx:remove-elements-not-contents($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <x:b>content</x:b></c> </in-xml> return (functx:remove-elements-not-contents( $in-xml-1, ('b','c'))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-remove-elements-not-contents-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant XML elements but keeps their content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-not-contents.html : @param $nodes the root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-not-contents ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then functx:remove-elements-not-contents($node/node(), $names) else element {node-name($node)} {$node/@*, functx:remove-elements-not-contents($node/node(),$names)} else if ($node instance of document-node()) then functx:remove-elements-not-contents($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <x:b>content</x:b></c> </in-xml> return (functx:remove-elements-not-contents( $in-xml-1, 'a')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-remove-elements-not-contents-4,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant XML elements but keeps their content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-not-contents.html : @param $nodes the root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-not-contents ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then functx:remove-elements-not-contents($node/node(), $names) else element {node-name($node)} {$node/@*, functx:remove-elements-not-contents($node/node(),$names)} else if ($node instance of document-node()) then functx:remove-elements-not-contents($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <x:b>content</x:b></c> </in-xml> return (functx:remove-elements-not-contents( $in-xml-2, 'x:b')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-remove-elements-not-contents-all,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant XML elements but keeps their content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-not-contents.html : @param $nodes the root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-not-contents ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then functx:remove-elements-not-contents($node/node(), $names) else element {node-name($node)} {$node/@*, functx:remove-elements-not-contents($node/node(),$names)} else if ($node instance of document-node()) then functx:remove-elements-not-contents($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <x:b>content</x:b></c> </in-xml> return (functx:remove-elements-not-contents( $in-xml-1, 'b'), functx:remove-elements-not-contents( $in-xml-1, ('b','c')), functx:remove-elements-not-contents( $in-xml-1, 'a'), functx:remove-elements-not-contents( $in-xml-2, 'x:b')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-remove-elements-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes child elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements.html : @param $elements the element(s) from which you wish to remove the children : @param $names the names of the child elements to remove :)          declare function functx:remove-elements ( $elements as element()* , $names as xs:string* ) as element()* { for $element in $elements return element {node-name($element)} {$element/@*, $element/node()[not(functx:name-test(name(),$names))] } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a>123</a> <a>456</a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a>123</a> <x:a>456</x:a> <c>Mixed <x:a>content</x:a></c> </in-xml> return (functx:remove-elements( $in-xml-1, 'c')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-remove-elements-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes child elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements.html : @param $elements the element(s) from which you wish to remove the children : @param $names the names of the child elements to remove :)          declare function functx:remove-elements ( $elements as element()* , $names as xs:string* ) as element()* { for $element in $elements return element {node-name($element)} {$element/@*, $element/node()[not(functx:name-test(name(),$names))] } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a>123</a> <a>456</a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a>123</a> <x:a>456</x:a> <c>Mixed <x:a>content</x:a></c> </in-xml> return (functx:remove-elements( $in-xml-1, ('a','b'))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-remove-elements-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes child elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements.html : @param $elements the element(s) from which you wish to remove the children : @param $names the names of the child elements to remove :)          declare function functx:remove-elements ( $elements as element()* , $names as xs:string* ) as element()* { for $element in $elements return element {node-name($element)} {$element/@*, $element/node()[not(functx:name-test(name(),$names))] } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a>123</a> <a>456</a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a>123</a> <x:a>456</x:a> <c>Mixed <x:a>content</x:a></c> </in-xml> return (functx:remove-elements( $in-xml-2, 'x:a')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-remove-elements-all,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes child elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements.html : @param $elements the element(s) from which you wish to remove the children : @param $names the names of the child elements to remove :)          declare function functx:remove-elements ( $elements as element()* , $names as xs:string* ) as element()* { for $element in $elements return element {node-name($element)} {$element/@*, $element/node()[not(functx:name-test(name(),$names))] } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a>123</a> <a>456</a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a>123</a> <x:a>456</x:a> <c>Mixed <x:a>content</x:a></c> </in-xml> return (functx:remove-elements( $in-xml-1, 'c'), functx:remove-elements( $in-xml-1, ('a','b')), functx:remove-elements( $in-xml-2, 'x:a')). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-repeat-string-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:repeat-string('*', 6)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-repeat-string-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:repeat-string('abc', 3)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-repeat-string-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:repeat-string('*', 6), functx:repeat-string('abc', 3)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-replace-beginning-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Replaces the beginning of a string, up to a matched pattern : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-beginning.html : @param $arg the entire string to change : @param $pattern the pattern of characters to replace up to : @param $replacement the replacement string :)          declare function functx:replace-beginning ( $arg as xs:string? , $pattern as xs:string , $replacement as xs:string ) as xs:string { replace($arg, concat('^.*?', $pattern), $replacement) } ;                     (functx:replace-beginning('abc-def', '-', 'xxx')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-replace-beginning-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Replaces the beginning of a string, up to a matched pattern : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-beginning.html : @param $arg the entire string to change : @param $pattern the pattern of characters to replace up to : @param $replacement the replacement string :)          declare function functx:replace-beginning ( $arg as xs:string? , $pattern as xs:string , $replacement as xs:string ) as xs:string { replace($arg, concat('^.*?', $pattern), $replacement) } ;                     (functx:replace-beginning('abc-def', '-', '')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-replace-beginning-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Replaces the beginning of a string, up to a matched pattern : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-beginning.html : @param $arg the entire string to change : @param $pattern the pattern of characters to replace up to : @param $replacement the replacement string :)          declare function functx:replace-beginning ( $arg as xs:string? , $pattern as xs:string , $replacement as xs:string ) as xs:string { replace($arg, concat('^.*?', $pattern), $replacement) } ;                     (functx:replace-beginning( '---abc', '[a-z]', 'x')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-replace-beginning-4,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Replaces the beginning of a string, up to a matched pattern : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-beginning.html : @param $arg the entire string to change : @param $pattern the pattern of characters to replace up to : @param $replacement the replacement string :)          declare function functx:replace-beginning ( $arg as xs:string? , $pattern as xs:string , $replacement as xs:string ) as xs:string { replace($arg, concat('^.*?', $pattern), $replacement) } ;                     (functx:replace-beginning( '2004-12-05', '-', '2005-')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-replace-beginning-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Replaces the beginning of a string, up to a matched pattern : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-beginning.html : @param $arg the entire string to change : @param $pattern the pattern of characters to replace up to : @param $replacement the replacement string :)          declare function functx:replace-beginning ( $arg as xs:string? , $pattern as xs:string , $replacement as xs:string ) as xs:string { replace($arg, concat('^.*?', $pattern), $replacement) } ;                     (functx:replace-beginning('abc-def', '-', 'xxx'), functx:replace-beginning('abc-def', '-', ''), functx:replace-beginning( '---abc', '[a-z]', 'x'), functx:replace-beginning( '2004-12-05', '-', '2005-')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-replace-element-values-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Updates the content of one or more elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-element-values.html : @param $elements the elements whose content you wish to replace : @param $values the replacement values :)          declare function functx:replace-element-values ( $elements as element()* , $values as xs:anyAtomicType* ) as element()* { for $element at $seq in $elements return element { node-name($element)} { $element/@*, $values[$seq] } } ;                     let $in-xml := <in-xml> <price num="1">12</price> <price num="2">20</price> <price num="3">5</price> </in-xml> return (functx:replace-element-values( $in-xml/price, for $p in $in-xml/price return $p * 2)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-replace-element-values-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Updates the content of one or more elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-element-values.html : @param $elements the elements whose content you wish to replace : @param $values the replacement values :)          declare function functx:replace-element-values ( $elements as element()* , $values as xs:anyAtomicType* ) as element()* { for $element at $seq in $elements return element { node-name($element)} { $element/@*, $values[$seq] } } ;                     let $in-xml := <in-xml> <price num="1">12</price> <price num="2">20</price> <price num="3">5</price> </in-xml> return (for $p in $in-xml/price return functx:replace-element-values( $p,concat($p,'.0'))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-replace-element-values-all,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Updates the content of one or more elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-element-values.html : @param $elements the elements whose content you wish to replace : @param $values the replacement values :)          declare function functx:replace-element-values ( $elements as element()* , $values as xs:anyAtomicType* ) as element()* { for $element at $seq in $elements return element { node-name($element)} { $element/@*, $values[$seq] } } ;                     let $in-xml := <in-xml> <price num="1">12</price> <price num="2">20</price> <price num="3">5</price> </in-xml> return (functx:replace-element-values( $in-xml/price, for $p in $in-xml/price return $p * 2), for $p in $in-xml/price return functx:replace-element-values( $p,concat($p,'.0'))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-replace-first-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Replaces the first match of a pattern : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-first.html : @param $arg the entire string to change : @param $pattern the pattern of characters to replace : @param $replacement the replacement string :)          declare function functx:replace-first ( $arg as xs:string? , $pattern as xs:string , $replacement as xs:string ) as xs:string { replace($arg, concat('(^.*?)', $pattern), concat('$1',$replacement)) } ;                     (functx:replace-first('abcabcabc', 'ab', 'x')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-replace-first-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Replaces the first match of a pattern : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-first.html : @param $arg the entire string to change : @param $pattern the pattern of characters to replace : @param $replacement the replacement string :)          declare function functx:replace-first ( $arg as xs:string? , $pattern as xs:string , $replacement as xs:string ) as xs:string { replace($arg, concat('(^.*?)', $pattern), concat('$1',$replacement)) } ;                     (functx:replace-first('elementary', 'e.*e', 'x')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-replace-first-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Replaces the first match of a pattern : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-first.html : @param $arg the entire string to change : @param $pattern the pattern of characters to replace : @param $replacement the replacement string :)          declare function functx:replace-first ( $arg as xs:string? , $pattern as xs:string , $replacement as xs:string ) as xs:string { replace($arg, concat('(^.*?)', $pattern), concat('$1',$replacement)) } ;                     (functx:replace-first( 'elementary', 'e.*?e', 'x')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-replace-first-4,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Replaces the first match of a pattern : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-first.html : @param $arg the entire string to change : @param $pattern the pattern of characters to replace : @param $replacement the replacement string :)          declare function functx:replace-first ( $arg as xs:string? , $pattern as xs:string , $replacement as xs:string ) as xs:string { replace($arg, concat('(^.*?)', $pattern), concat('$1',$replacement)) } ;                     (functx:replace-first('9999-9999', '\d+', 'X')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-replace-first-5,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Replaces the first match of a pattern : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-first.html : @param $arg the entire string to change : @param $pattern the pattern of characters to replace : @param $replacement the replacement string :)          declare function functx:replace-first ( $arg as xs:string? , $pattern as xs:string , $replacement as xs:string ) as xs:string { replace($arg, concat('(^.*?)', $pattern), concat('$1',$replacement)) } ;                     (functx:replace-first('9999-9999', '\d{3}', 'X')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-replace-first-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Replaces the first match of a pattern : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-first.html : @param $arg the entire string to change : @param $pattern the pattern of characters to replace : @param $replacement the replacement string :)          declare function functx:replace-first ( $arg as xs:string? , $pattern as xs:string , $replacement as xs:string ) as xs:string { replace($arg, concat('(^.*?)', $pattern), concat('$1',$replacement)) } ;                     (functx:replace-first('abcabcabc', 'ab', 'x'), functx:replace-first('elementary', 'e.*e', 'x'), functx:replace-first( 'elementary', 'e.*?e', 'x'), functx:replace-first('9999-9999', '\d+', 'X'), functx:replace-first('9999-9999', '\d{3}', 'X')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-replace-multi-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not empty, otherwise the second argument : : @author W3C XML Query WG : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-absent.html : @param $arg the item(s) that may be absent : @param $value the item(s) to use if the item is absent :)          declare function functx:if-absent            ( $arg as item()* , $value as item()* ) as item()* {            if (exists($arg)) then $arg else $value } ;                     (:~ : Performs multiple replacements, using pairs of replace parameters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-multi.html : @param $arg the string to manipulate : @param $changeFrom the sequence of strings or patterns to change from : @param $changeTo the sequence of strings to change to :)          declare function functx:replace-multi ( $arg as xs:string? , $changeFrom as xs:string* , $changeTo as xs:string* ) as xs:string? {            if (count($changeFrom) > 0)            then functx:replace-multi( replace($arg, $changeFrom[1], functx:if-absent($changeTo[1],'')), $changeFrom[position() > 1], $changeTo[position() > 1])            else $arg          } ;          let $fr := ('[a-c]', 'def', '\d+')          return let $to := ('x', 'y', '0')          return (functx:replace-multi('abcdef123',$fr,$to)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-reverse-string-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Reverses the order of characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_reverse-string.html : @param $arg the string to reverse :)          declare function functx:reverse-string ( $arg as xs:string? ) as xs:string { codepoints-to-string(reverse(string-to-codepoints($arg))) } ;                     (functx:reverse-string('abc')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-reverse-string-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Reverses the order of characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_reverse-string.html : @param $arg the string to reverse :)          declare function functx:reverse-string ( $arg as xs:string? ) as xs:string { codepoints-to-string(reverse(string-to-codepoints($arg))) } ;                     (functx:reverse-string('a')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-reverse-string-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Reverses the order of characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_reverse-string.html : @param $arg the string to reverse :)          declare function functx:reverse-string ( $arg as xs:string? ) as xs:string { codepoints-to-string(reverse(string-to-codepoints($arg))) } ;                     (functx:reverse-string('abc'), functx:reverse-string('a')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-right-trim-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Trims trailing whitespace : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_right-trim.html : @param $arg the string to trim :)          declare function functx:right-trim ( $arg as xs:string? ) as xs:string { replace($arg,'\s+$','') } ;                     (functx:right-trim('xyz ')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-right-trim-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Trims trailing whitespace : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_right-trim.html : @param $arg the string to trim :)          declare function functx:right-trim ( $arg as xs:string? ) as xs:string { replace($arg,'\s+$','') } ;          (functx:right-trim(' x   xyz ')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-right-trim-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Trims trailing whitespace : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_right-trim.html : @param $arg the string to trim :)          declare function functx:right-trim ( $arg as xs:string? ) as xs:string { replace($arg,'\s+$','') } ;                     (functx:right-trim('xyz')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-right-trim-all,Error: XPST0003: Unable to parse XPath: deep-equal((declare namespace functx = "http://www.example.com/";                     (:~ : Trims trailing whitespace : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_right-trim.html : @param $arg the string to trim :)          declare function functx:right-trim ( $arg as xs:string? ) as xs:string { replace($arg,'\s+$','') } ;                     (functx:right-trim('xyz '), functx:right-trim(' x   xyz '), functx:right-trim('xyz'))), ("xyz", " x   xyz", "xyz")). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-scheme-from-uri-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Returns the scheme from a URI : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_scheme-from-uri.html : @param $uri the URI :)          declare function functx:scheme-from-uri ( $uri as xs:string? ) as xs:string? { substring-before($uri,':') } ;                     (functx:scheme-from-uri( 'http://www.datypic.com')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-scheme-from-uri-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Returns the scheme from a URI : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_scheme-from-uri.html : @param $uri the URI :)          declare function functx:scheme-from-uri ( $uri as xs:string? ) as xs:string? { substring-before($uri,':') } ;                     (functx:scheme-from-uri( 'ftp://ftp.datypic.com')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-scheme-from-uri-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Returns the scheme from a URI : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_scheme-from-uri.html : @param $uri the URI :)          declare function functx:scheme-from-uri ( $uri as xs:string? ) as xs:string? { substring-before($uri,':') } ;                     (functx:scheme-from-uri('ftp.datypic.com')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-scheme-from-uri-4,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Returns the scheme from a URI : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_scheme-from-uri.html : @param $uri the URI :)          declare function functx:scheme-from-uri ( $uri as xs:string? ) as xs:string? { substring-before($uri,':') } ;                     (functx:scheme-from-uri('www.datypic.com')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-scheme-from-uri-5,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Returns the scheme from a URI : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_scheme-from-uri.html : @param $uri the URI :)          declare function functx:scheme-from-uri ( $uri as xs:string? ) as xs:string? { substring-before($uri,':') } ;                     (functx:scheme-from-uri('prod.html')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-scheme-from-uri-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Returns the scheme from a URI : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_scheme-from-uri.html : @param $uri the URI :)          declare function functx:scheme-from-uri ( $uri as xs:string? ) as xs:string? { substring-before($uri,':') } ;                     (functx:scheme-from-uri( 'http://www.datypic.com'), functx:scheme-from-uri( 'ftp://ftp.datypic.com'), functx:scheme-from-uri('ftp.datypic.com'), functx:scheme-from-uri('www.datypic.com'), functx:scheme-from-uri('prod.html')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-sequence-deep-equal-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences have the same XML node content and/or values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-deep-equal.html : @param $seq1 the first sequence : @param $seq2 the second sequence :)          declare function functx:sequence-deep-equal ( $seq1 as item()* , $seq2 as item()* ) as xs:boolean { every $i in 1 to max((count($seq1),count($seq2))) satisfies deep-equal($seq1[$i],$seq2[$i]) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-deep-equal( $in-xml/author/*, $in-xml/*/*)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-sequence-deep-equal-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences have the same XML node content and/or values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-deep-equal.html : @param $seq1 the first sequence : @param $seq2 the second sequence :)          declare function functx:sequence-deep-equal ( $seq1 as item()* , $seq2 as item()* ) as xs:boolean { every $i in 1 to max((count($seq1),count($seq2))) satisfies deep-equal($seq1[$i],$seq2[$i]) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-deep-equal( $in-xml/author[1], $anAuthor)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-sequence-deep-equal-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences have the same XML node content and/or values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-deep-equal.html : @param $seq1 the first sequence : @param $seq2 the second sequence :)          declare function functx:sequence-deep-equal ( $seq1 as item()* , $seq2 as item()* ) as xs:boolean { every $i in 1 to max((count($seq1),count($seq2))) satisfies deep-equal($seq1[$i],$seq2[$i]) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-deep-equal( (1,2,3), (1.0,2.0,3.0))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-sequence-deep-equal-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences have the same XML node content and/or values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-deep-equal.html : @param $seq1 the first sequence : @param $seq2 the second sequence :)          declare function functx:sequence-deep-equal ( $seq1 as item()* , $seq2 as item()* ) as xs:boolean { every $i in 1 to max((count($seq1),count($seq2))) satisfies deep-equal($seq1[$i],$seq2[$i]) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-deep-equal( $in-xml/author/*, $in-xml/*/*), functx:sequence-deep-equal( $in-xml/author[1], $anAuthor), functx:sequence-deep-equal( (1,2,3), (1.0,2.0,3.0))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-sequence-node-equal-any-order-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences contain the same XML nodes, regardless of order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-node-equal-any-order.html : @param $seq1 the first sequence of nodes : @param $seq2 the second sequence of nodes :)          declare function functx:sequence-node-equal-any-order ( $seq1 as node()* , $seq2 as node()* ) as xs:boolean { not( ($seq1 except $seq2, $seq2 except $seq1)) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-node-equal-any-order( $in-xml/author, $in-xml/*)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-sequence-node-equal-any-order-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences contain the same XML nodes, regardless of order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-node-equal-any-order.html : @param $seq1 the first sequence of nodes : @param $seq2 the second sequence of nodes :)          declare function functx:sequence-node-equal-any-order ( $seq1 as node()* , $seq2 as node()* ) as xs:boolean { not( ($seq1 except $seq2, $seq2 except $seq1)) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-node-equal-any-order( $in-xml/author, ($in-xml/author[2],$in-xml/author[1]))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-sequence-node-equal-any-order-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences contain the same XML nodes, regardless of order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-node-equal-any-order.html : @param $seq1 the first sequence of nodes : @param $seq2 the second sequence of nodes :)          declare function functx:sequence-node-equal-any-order ( $seq1 as node()* , $seq2 as node()* ) as xs:boolean { not( ($seq1 except $seq2, $seq2 except $seq1)) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-node-equal-any-order( $in-xml/author[1],$anAuthor)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-sequence-node-equal-any-order-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences contain the same XML nodes, regardless of order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-node-equal-any-order.html : @param $seq1 the first sequence of nodes : @param $seq2 the second sequence of nodes :)          declare function functx:sequence-node-equal-any-order ( $seq1 as node()* , $seq2 as node()* ) as xs:boolean { not( ($seq1 except $seq2, $seq2 except $seq1)) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-node-equal-any-order( $in-xml/author, $in-xml/*), functx:sequence-node-equal-any-order( $in-xml/author, ($in-xml/author[2],$in-xml/author[1])), functx:sequence-node-equal-any-order( $in-xml/author[1],$anAuthor)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-sequence-node-equal-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences contain the same XML nodes, in the same order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-node-equal.html : @param $seq1 the first sequence of nodes : @param $seq2 the second sequence of nodes :)          declare function functx:sequence-node-equal ( $seq1 as node()* , $seq2 as node()* ) as xs:boolean { every $i in 1 to max((count($seq1),count($seq2))) satisfies $seq1[$i] is $seq2[$i] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-node-equal( $in-xml/author/*, $in-xml/*/*)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-sequence-node-equal-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences contain the same XML nodes, in the same order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-node-equal.html : @param $seq1 the first sequence of nodes : @param $seq2 the second sequence of nodes :)          declare function functx:sequence-node-equal ( $seq1 as node()* , $seq2 as node()* ) as xs:boolean { every $i in 1 to max((count($seq1),count($seq2))) satisfies $seq1[$i] is $seq2[$i] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-node-equal( $in-xml/author, ($in-xml/author[2],$in-xml/author[1]))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-sequence-node-equal-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences contain the same XML nodes, in the same order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-node-equal.html : @param $seq1 the first sequence of nodes : @param $seq2 the second sequence of nodes :)          declare function functx:sequence-node-equal ( $seq1 as node()* , $seq2 as node()* ) as xs:boolean { every $i in 1 to max((count($seq1),count($seq2))) satisfies $seq1[$i] is $seq2[$i] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-node-equal( $in-xml/author[1],$anAuthor)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-sequence-node-equal-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences contain the same XML nodes, in the same order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-node-equal.html : @param $seq1 the first sequence of nodes : @param $seq2 the second sequence of nodes :)          declare function functx:sequence-node-equal ( $seq1 as node()* , $seq2 as node()* ) as xs:boolean { every $i in 1 to max((count($seq1),count($seq2))) satisfies $seq1[$i] is $seq2[$i] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-node-equal( $in-xml/author/*, $in-xml/*/*), functx:sequence-node-equal( $in-xml/author, ($in-xml/author[2],$in-xml/author[1])), functx:sequence-node-equal( $in-xml/author[1],$anAuthor)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-sequence-type-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The built-in type of an atomic value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_atomic-type.html : @param $values the value(s) whose type you want to determine :)          declare function functx:atomic-type ( $values as xs:anyAtomicType* ) as xs:string* { for $val in $values return (if ($val instance of xs:untypedAtomic) then 'xs:untypedAtomic' else if ($val instance of xs:anyURI) then 'xs:anyURI' else if ($val instance of xs:ENTITY) then 'xs:ENTITY' else if ($val instance of xs:ID) then 'xs:ID' else if ($val instance of xs:NMTOKEN) then 'xs:NMTOKEN' else if ($val instance of xs:language) then 'xs:language' else if ($val instance of xs:NCName) then 'xs:NCName' else if ($val instance of xs:Name) then 'xs:Name' else if ($val instance of xs:token) then 'xs:token' else if ($val instance of xs:normalizedString) then 'xs:normalizedString' else if ($val instance of xs:string) then 'xs:string' else if ($val instance of xs:QName) then 'xs:QName' else if ($val instance of xs:boolean) then 'xs:boolean' else if ($val instance of xs:base64Binary) then 'xs:base64Binary' else if ($val instance of xs:hexBinary) then 'xs:hexBinary' else if ($val instance of xs:byte) then 'xs:byte' else if ($val instance of xs:short) then 'xs:short' else if ($val instance of xs:int) then 'xs:int' else if ($val instance of xs:long) then 'xs:long' else if ($val instance of xs:unsignedByte) then 'xs:unsignedByte' else if ($val instance of xs:unsignedShort) then 'xs:unsignedShort' else if ($val instance of xs:unsignedInt) then 'xs:unsignedInt' else if ($val instance of xs:unsignedLong) then 'xs:unsignedLong' else if ($val instance of xs:positiveInteger) then 'xs:positiveInteger' else if ($val instance of xs:nonNegativeInteger) then 'xs:nonNegativeInteger' else if ($val instance of xs:negativeInteger) then 'xs:negativeInteger' else if ($val instance of xs:nonPositiveInteger) then 'xs:nonPositiveInteger' else if ($val instance of xs:integer) then 'xs:integer' else if ($val instance of xs:decimal) then 'xs:decimal' else if ($val instance of xs:float) then 'xs:float' else if ($val instance of xs:double) then 'xs:double' else if ($val instance of xs:date) then 'xs:date' else if ($val instance of xs:time) then 'xs:time' else if ($val instance of xs:dateTime) then 'xs:dateTime' else if ($val instance of xs:dayTimeDuration) then 'xs:dayTimeDuration' else if ($val instance of xs:yearMonthDuration) then 'xs:yearMonthDuration' else if ($val instance of xs:duration) then 'xs:duration' else if ($val instance of xs:gMonth) then 'xs:gMonth' else if ($val instance of xs:gYear) then 'xs:gYear' else if ($val instance of xs:gYearMonth) then 'xs:gYearMonth' else if ($val instance of xs:gDay) then 'xs:gDay' else if ($val instance of xs:gMonthDay) then 'xs:gMonthDay' else 'unknown') } ;                     (:~ : The XML node kind (element, attribute, text, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_node-kind.html : @param $nodes the node(s) whose kind you want to determine :)          declare function functx:node-kind ( $nodes as node()* ) as xs:string* { for $node in $nodes return if ($node instance of element()) then 'element' else if ($node instance of attribute()) then 'attribute' else if ($node instance of text()) then 'text' else if ($node instance of document-node()) then 'document-node' else if ($node instance of comment()) then 'comment' else if ($node instance of processing-instruction()) then 'processing-instruction' else 'unknown' } ;                     (:~ : The sequence type that represents a sequence of nodes or values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-type.html : @param $items the items whose sequence type you want to determine :)          declare function functx:sequence-type ( $items as item()* ) as xs:string { concat( if (empty($items)) then 'empty-sequence()' else if (every $val in $items satisfies $val instance of xs:anyAtomicType) then if (count(distinct-values(functx:atomic-type($items))) > 1) then 'xs:anyAtomicType' else functx:atomic-type($items[1]) else if (some $val in $items satisfies $val instance of xs:anyAtomicType) then 'item()' else if (count(distinct-values(functx:node-kind($items))) > 1) then 'node()' else concat(functx:node-kind($items[1]),'()') , if (count($items) > 1) then '+' else '') } ;                     let $in-xml := <in-xml> <a att1="y">x</a> <b att1="x">x</b> <!-- comment --> </in-xml> return (functx:sequence-type(2)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-sequence-type-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The built-in type of an atomic value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_atomic-type.html : @param $values the value(s) whose type you want to determine :)          declare function functx:atomic-type ( $values as xs:anyAtomicType* ) as xs:string* { for $val in $values return (if ($val instance of xs:untypedAtomic) then 'xs:untypedAtomic' else if ($val instance of xs:anyURI) then 'xs:anyURI' else if ($val instance of xs:ENTITY) then 'xs:ENTITY' else if ($val instance of xs:ID) then 'xs:ID' else if ($val instance of xs:NMTOKEN) then 'xs:NMTOKEN' else if ($val instance of xs:language) then 'xs:language' else if ($val instance of xs:NCName) then 'xs:NCName' else if ($val instance of xs:Name) then 'xs:Name' else if ($val instance of xs:token) then 'xs:token' else if ($val instance of xs:normalizedString) then 'xs:normalizedString' else if ($val instance of xs:string) then 'xs:string' else if ($val instance of xs:QName) then 'xs:QName' else if ($val instance of xs:boolean) then 'xs:boolean' else if ($val instance of xs:base64Binary) then 'xs:base64Binary' else if ($val instance of xs:hexBinary) then 'xs:hexBinary' else if ($val instance of xs:byte) then 'xs:byte' else if ($val instance of xs:short) then 'xs:short' else if ($val instance of xs:int) then 'xs:int' else if ($val instance of xs:long) then 'xs:long' else if ($val instance of xs:unsignedByte) then 'xs:unsignedByte' else if ($val instance of xs:unsignedShort) then 'xs:unsignedShort' else if ($val instance of xs:unsignedInt) then 'xs:unsignedInt' else if ($val instance of xs:unsignedLong) then 'xs:unsignedLong' else if ($val instance of xs:positiveInteger) then 'xs:positiveInteger' else if ($val instance of xs:nonNegativeInteger) then 'xs:nonNegativeInteger' else if ($val instance of xs:negativeInteger) then 'xs:negativeInteger' else if ($val instance of xs:nonPositiveInteger) then 'xs:nonPositiveInteger' else if ($val instance of xs:integer) then 'xs:integer' else if ($val instance of xs:decimal) then 'xs:decimal' else if ($val instance of xs:float) then 'xs:float' else if ($val instance of xs:double) then 'xs:double' else if ($val instance of xs:date) then 'xs:date' else if ($val instance of xs:time) then 'xs:time' else if ($val instance of xs:dateTime) then 'xs:dateTime' else if ($val instance of xs:dayTimeDuration) then 'xs:dayTimeDuration' else if ($val instance of xs:yearMonthDuration) then 'xs:yearMonthDuration' else if ($val instance of xs:duration) then 'xs:duration' else if ($val instance of xs:gMonth) then 'xs:gMonth' else if ($val instance of xs:gYear) then 'xs:gYear' else if ($val instance of xs:gYearMonth) then 'xs:gYearMonth' else if ($val instance of xs:gDay) then 'xs:gDay' else if ($val instance of xs:gMonthDay) then 'xs:gMonthDay' else 'unknown') } ;                     (:~ : The XML node kind (element, attribute, text, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_node-kind.html : @param $nodes the node(s) whose kind you want to determine :)          declare function functx:node-kind ( $nodes as node()* ) as xs:string* { for $node in $nodes return if ($node instance of element()) then 'element' else if ($node instance of attribute()) then 'attribute' else if ($node instance of text()) then 'text' else if ($node instance of document-node()) then 'document-node' else if ($node instance of comment()) then 'comment' else if ($node instance of processing-instruction()) then 'processing-instruction' else 'unknown' } ;                     (:~ : The sequence type that represents a sequence of nodes or values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-type.html : @param $items the items whose sequence type you want to determine :)          declare function functx:sequence-type ( $items as item()* ) as xs:string { concat( if (empty($items)) then 'empty-sequence()' else if (every $val in $items satisfies $val instance of xs:anyAtomicType) then if (count(distinct-values(functx:atomic-type($items))) > 1) then 'xs:anyAtomicType' else functx:atomic-type($items[1]) else if (some $val in $items satisfies $val instance of xs:anyAtomicType) then 'item()' else if (count(distinct-values(functx:node-kind($items))) > 1) then 'node()' else concat(functx:node-kind($items[1]),'()') , if (count($items) > 1) then '+' else '') } ;                     let $in-xml := <in-xml> <a att1="y">x</a> <b att1="x">x</b> <!-- comment --> </in-xml> return (functx:sequence-type(('abc','def'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-sequence-type-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The built-in type of an atomic value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_atomic-type.html : @param $values the value(s) whose type you want to determine :)          declare function functx:atomic-type ( $values as xs:anyAtomicType* ) as xs:string* { for $val in $values return (if ($val instance of xs:untypedAtomic) then 'xs:untypedAtomic' else if ($val instance of xs:anyURI) then 'xs:anyURI' else if ($val instance of xs:ENTITY) then 'xs:ENTITY' else if ($val instance of xs:ID) then 'xs:ID' else if ($val instance of xs:NMTOKEN) then 'xs:NMTOKEN' else if ($val instance of xs:language) then 'xs:language' else if ($val instance of xs:NCName) then 'xs:NCName' else if ($val instance of xs:Name) then 'xs:Name' else if ($val instance of xs:token) then 'xs:token' else if ($val instance of xs:normalizedString) then 'xs:normalizedString' else if ($val instance of xs:string) then 'xs:string' else if ($val instance of xs:QName) then 'xs:QName' else if ($val instance of xs:boolean) then 'xs:boolean' else if ($val instance of xs:base64Binary) then 'xs:base64Binary' else if ($val instance of xs:hexBinary) then 'xs:hexBinary' else if ($val instance of xs:byte) then 'xs:byte' else if ($val instance of xs:short) then 'xs:short' else if ($val instance of xs:int) then 'xs:int' else if ($val instance of xs:long) then 'xs:long' else if ($val instance of xs:unsignedByte) then 'xs:unsignedByte' else if ($val instance of xs:unsignedShort) then 'xs:unsignedShort' else if ($val instance of xs:unsignedInt) then 'xs:unsignedInt' else if ($val instance of xs:unsignedLong) then 'xs:unsignedLong' else if ($val instance of xs:positiveInteger) then 'xs:positiveInteger' else if ($val instance of xs:nonNegativeInteger) then 'xs:nonNegativeInteger' else if ($val instance of xs:negativeInteger) then 'xs:negativeInteger' else if ($val instance of xs:nonPositiveInteger) then 'xs:nonPositiveInteger' else if ($val instance of xs:integer) then 'xs:integer' else if ($val instance of xs:decimal) then 'xs:decimal' else if ($val instance of xs:float) then 'xs:float' else if ($val instance of xs:double) then 'xs:double' else if ($val instance of xs:date) then 'xs:date' else if ($val instance of xs:time) then 'xs:time' else if ($val instance of xs:dateTime) then 'xs:dateTime' else if ($val instance of xs:dayTimeDuration) then 'xs:dayTimeDuration' else if ($val instance of xs:yearMonthDuration) then 'xs:yearMonthDuration' else if ($val instance of xs:duration) then 'xs:duration' else if ($val instance of xs:gMonth) then 'xs:gMonth' else if ($val instance of xs:gYear) then 'xs:gYear' else if ($val instance of xs:gYearMonth) then 'xs:gYearMonth' else if ($val instance of xs:gDay) then 'xs:gDay' else if ($val instance of xs:gMonthDay) then 'xs:gMonthDay' else 'unknown') } ;                     (:~ : The XML node kind (element, attribute, text, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_node-kind.html : @param $nodes the node(s) whose kind you want to determine :)          declare function functx:node-kind ( $nodes as node()* ) as xs:string* { for $node in $nodes return if ($node instance of element()) then 'element' else if ($node instance of attribute()) then 'attribute' else if ($node instance of text()) then 'text' else if ($node instance of document-node()) then 'document-node' else if ($node instance of comment()) then 'comment' else if ($node instance of processing-instruction()) then 'processing-instruction' else 'unknown' } ;                     (:~ : The sequence type that represents a sequence of nodes or values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-type.html : @param $items the items whose sequence type you want to determine :)          declare function functx:sequence-type ( $items as item()* ) as xs:string { concat( if (empty($items)) then 'empty-sequence()' else if (every $val in $items satisfies $val instance of xs:anyAtomicType) then if (count(distinct-values(functx:atomic-type($items))) > 1) then 'xs:anyAtomicType' else functx:atomic-type($items[1]) else if (some $val in $items satisfies $val instance of xs:anyAtomicType) then 'item()' else if (count(distinct-values(functx:node-kind($items))) > 1) then 'node()' else concat(functx:node-kind($items[1]),'()') , if (count($items) > 1) then '+' else '') } ;                     let $in-xml := <in-xml> <a att1="y">x</a> <b att1="x">x</b> <!-- comment --> </in-xml> return (functx:sequence-type(('abc',2))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-sequence-type-4,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The built-in type of an atomic value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_atomic-type.html : @param $values the value(s) whose type you want to determine :)          declare function functx:atomic-type ( $values as xs:anyAtomicType* ) as xs:string* { for $val in $values return (if ($val instance of xs:untypedAtomic) then 'xs:untypedAtomic' else if ($val instance of xs:anyURI) then 'xs:anyURI' else if ($val instance of xs:ENTITY) then 'xs:ENTITY' else if ($val instance of xs:ID) then 'xs:ID' else if ($val instance of xs:NMTOKEN) then 'xs:NMTOKEN' else if ($val instance of xs:language) then 'xs:language' else if ($val instance of xs:NCName) then 'xs:NCName' else if ($val instance of xs:Name) then 'xs:Name' else if ($val instance of xs:token) then 'xs:token' else if ($val instance of xs:normalizedString) then 'xs:normalizedString' else if ($val instance of xs:string) then 'xs:string' else if ($val instance of xs:QName) then 'xs:QName' else if ($val instance of xs:boolean) then 'xs:boolean' else if ($val instance of xs:base64Binary) then 'xs:base64Binary' else if ($val instance of xs:hexBinary) then 'xs:hexBinary' else if ($val instance of xs:byte) then 'xs:byte' else if ($val instance of xs:short) then 'xs:short' else if ($val instance of xs:int) then 'xs:int' else if ($val instance of xs:long) then 'xs:long' else if ($val instance of xs:unsignedByte) then 'xs:unsignedByte' else if ($val instance of xs:unsignedShort) then 'xs:unsignedShort' else if ($val instance of xs:unsignedInt) then 'xs:unsignedInt' else if ($val instance of xs:unsignedLong) then 'xs:unsignedLong' else if ($val instance of xs:positiveInteger) then 'xs:positiveInteger' else if ($val instance of xs:nonNegativeInteger) then 'xs:nonNegativeInteger' else if ($val instance of xs:negativeInteger) then 'xs:negativeInteger' else if ($val instance of xs:nonPositiveInteger) then 'xs:nonPositiveInteger' else if ($val instance of xs:integer) then 'xs:integer' else if ($val instance of xs:decimal) then 'xs:decimal' else if ($val instance of xs:float) then 'xs:float' else if ($val instance of xs:double) then 'xs:double' else if ($val instance of xs:date) then 'xs:date' else if ($val instance of xs:time) then 'xs:time' else if ($val instance of xs:dateTime) then 'xs:dateTime' else if ($val instance of xs:dayTimeDuration) then 'xs:dayTimeDuration' else if ($val instance of xs:yearMonthDuration) then 'xs:yearMonthDuration' else if ($val instance of xs:duration) then 'xs:duration' else if ($val instance of xs:gMonth) then 'xs:gMonth' else if ($val instance of xs:gYear) then 'xs:gYear' else if ($val instance of xs:gYearMonth) then 'xs:gYearMonth' else if ($val instance of xs:gDay) then 'xs:gDay' else if ($val instance of xs:gMonthDay) then 'xs:gMonthDay' else 'unknown') } ;                     (:~ : The XML node kind (element, attribute, text, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_node-kind.html : @param $nodes the node(s) whose kind you want to determine :)          declare function functx:node-kind ( $nodes as node()* ) as xs:string* { for $node in $nodes return if ($node instance of element()) then 'element' else if ($node instance of attribute()) then 'attribute' else if ($node instance of text()) then 'text' else if ($node instance of document-node()) then 'document-node' else if ($node instance of comment()) then 'comment' else if ($node instance of processing-instruction()) then 'processing-instruction' else 'unknown' } ;                     (:~ : The sequence type that represents a sequence of nodes or values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-type.html : @param $items the items whose sequence type you want to determine :)          declare function functx:sequence-type ( $items as item()* ) as xs:string { concat( if (empty($items)) then 'empty-sequence()' else if (every $val in $items satisfies $val instance of xs:anyAtomicType) then if (count(distinct-values(functx:atomic-type($items))) > 1) then 'xs:anyAtomicType' else functx:atomic-type($items[1]) else if (some $val in $items satisfies $val instance of xs:anyAtomicType) then 'item()' else if (count(distinct-values(functx:node-kind($items))) > 1) then 'node()' else concat(functx:node-kind($items[1]),'()') , if (count($items) > 1) then '+' else '') } ;                     let $in-xml := <in-xml> <a att1="y">x</a> <b att1="x">x</b> <!-- comment --> </in-xml> return (functx:sequence-type( () )))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-sequence-type-5,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The built-in type of an atomic value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_atomic-type.html : @param $values the value(s) whose type you want to determine :)          declare function functx:atomic-type ( $values as xs:anyAtomicType* ) as xs:string* { for $val in $values return (if ($val instance of xs:untypedAtomic) then 'xs:untypedAtomic' else if ($val instance of xs:anyURI) then 'xs:anyURI' else if ($val instance of xs:ENTITY) then 'xs:ENTITY' else if ($val instance of xs:ID) then 'xs:ID' else if ($val instance of xs:NMTOKEN) then 'xs:NMTOKEN' else if ($val instance of xs:language) then 'xs:language' else if ($val instance of xs:NCName) then 'xs:NCName' else if ($val instance of xs:Name) then 'xs:Name' else if ($val instance of xs:token) then 'xs:token' else if ($val instance of xs:normalizedString) then 'xs:normalizedString' else if ($val instance of xs:string) then 'xs:string' else if ($val instance of xs:QName) then 'xs:QName' else if ($val instance of xs:boolean) then 'xs:boolean' else if ($val instance of xs:base64Binary) then 'xs:base64Binary' else if ($val instance of xs:hexBinary) then 'xs:hexBinary' else if ($val instance of xs:byte) then 'xs:byte' else if ($val instance of xs:short) then 'xs:short' else if ($val instance of xs:int) then 'xs:int' else if ($val instance of xs:long) then 'xs:long' else if ($val instance of xs:unsignedByte) then 'xs:unsignedByte' else if ($val instance of xs:unsignedShort) then 'xs:unsignedShort' else if ($val instance of xs:unsignedInt) then 'xs:unsignedInt' else if ($val instance of xs:unsignedLong) then 'xs:unsignedLong' else if ($val instance of xs:positiveInteger) then 'xs:positiveInteger' else if ($val instance of xs:nonNegativeInteger) then 'xs:nonNegativeInteger' else if ($val instance of xs:negativeInteger) then 'xs:negativeInteger' else if ($val instance of xs:nonPositiveInteger) then 'xs:nonPositiveInteger' else if ($val instance of xs:integer) then 'xs:integer' else if ($val instance of xs:decimal) then 'xs:decimal' else if ($val instance of xs:float) then 'xs:float' else if ($val instance of xs:double) then 'xs:double' else if ($val instance of xs:date) then 'xs:date' else if ($val instance of xs:time) then 'xs:time' else if ($val instance of xs:dateTime) then 'xs:dateTime' else if ($val instance of xs:dayTimeDuration) then 'xs:dayTimeDuration' else if ($val instance of xs:yearMonthDuration) then 'xs:yearMonthDuration' else if ($val instance of xs:duration) then 'xs:duration' else if ($val instance of xs:gMonth) then 'xs:gMonth' else if ($val instance of xs:gYear) then 'xs:gYear' else if ($val instance of xs:gYearMonth) then 'xs:gYearMonth' else if ($val instance of xs:gDay) then 'xs:gDay' else if ($val instance of xs:gMonthDay) then 'xs:gMonthDay' else 'unknown') } ;                     (:~ : The XML node kind (element, attribute, text, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_node-kind.html : @param $nodes the node(s) whose kind you want to determine :)          declare function functx:node-kind ( $nodes as node()* ) as xs:string* { for $node in $nodes return if ($node instance of element()) then 'element' else if ($node instance of attribute()) then 'attribute' else if ($node instance of text()) then 'text' else if ($node instance of document-node()) then 'document-node' else if ($node instance of comment()) then 'comment' else if ($node instance of processing-instruction()) then 'processing-instruction' else 'unknown' } ;                     (:~ : The sequence type that represents a sequence of nodes or values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-type.html : @param $items the items whose sequence type you want to determine :)          declare function functx:sequence-type ( $items as item()* ) as xs:string { concat( if (empty($items)) then 'empty-sequence()' else if (every $val in $items satisfies $val instance of xs:anyAtomicType) then if (count(distinct-values(functx:atomic-type($items))) > 1) then 'xs:anyAtomicType' else functx:atomic-type($items[1]) else if (some $val in $items satisfies $val instance of xs:anyAtomicType) then 'item()' else if (count(distinct-values(functx:node-kind($items))) > 1) then 'node()' else concat(functx:node-kind($items[1]),'()') , if (count($items) > 1) then '+' else '') } ;                     let $in-xml := <in-xml> <a att1="y">x</a> <b att1="x">x</b> <!-- comment --> </in-xml> return (functx:sequence-type($in-xml/*[1])))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-sequence-type-6,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The built-in type of an atomic value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_atomic-type.html : @param $values the value(s) whose type you want to determine :)          declare function functx:atomic-type ( $values as xs:anyAtomicType* ) as xs:string* { for $val in $values return (if ($val instance of xs:untypedAtomic) then 'xs:untypedAtomic' else if ($val instance of xs:anyURI) then 'xs:anyURI' else if ($val instance of xs:ENTITY) then 'xs:ENTITY' else if ($val instance of xs:ID) then 'xs:ID' else if ($val instance of xs:NMTOKEN) then 'xs:NMTOKEN' else if ($val instance of xs:language) then 'xs:language' else if ($val instance of xs:NCName) then 'xs:NCName' else if ($val instance of xs:Name) then 'xs:Name' else if ($val instance of xs:token) then 'xs:token' else if ($val instance of xs:normalizedString) then 'xs:normalizedString' else if ($val instance of xs:string) then 'xs:string' else if ($val instance of xs:QName) then 'xs:QName' else if ($val instance of xs:boolean) then 'xs:boolean' else if ($val instance of xs:base64Binary) then 'xs:base64Binary' else if ($val instance of xs:hexBinary) then 'xs:hexBinary' else if ($val instance of xs:byte) then 'xs:byte' else if ($val instance of xs:short) then 'xs:short' else if ($val instance of xs:int) then 'xs:int' else if ($val instance of xs:long) then 'xs:long' else if ($val instance of xs:unsignedByte) then 'xs:unsignedByte' else if ($val instance of xs:unsignedShort) then 'xs:unsignedShort' else if ($val instance of xs:unsignedInt) then 'xs:unsignedInt' else if ($val instance of xs:unsignedLong) then 'xs:unsignedLong' else if ($val instance of xs:positiveInteger) then 'xs:positiveInteger' else if ($val instance of xs:nonNegativeInteger) then 'xs:nonNegativeInteger' else if ($val instance of xs:negativeInteger) then 'xs:negativeInteger' else if ($val instance of xs:nonPositiveInteger) then 'xs:nonPositiveInteger' else if ($val instance of xs:integer) then 'xs:integer' else if ($val instance of xs:decimal) then 'xs:decimal' else if ($val instance of xs:float) then 'xs:float' else if ($val instance of xs:double) then 'xs:double' else if ($val instance of xs:date) then 'xs:date' else if ($val instance of xs:time) then 'xs:time' else if ($val instance of xs:dateTime) then 'xs:dateTime' else if ($val instance of xs:dayTimeDuration) then 'xs:dayTimeDuration' else if ($val instance of xs:yearMonthDuration) then 'xs:yearMonthDuration' else if ($val instance of xs:duration) then 'xs:duration' else if ($val instance of xs:gMonth) then 'xs:gMonth' else if ($val instance of xs:gYear) then 'xs:gYear' else if ($val instance of xs:gYearMonth) then 'xs:gYearMonth' else if ($val instance of xs:gDay) then 'xs:gDay' else if ($val instance of xs:gMonthDay) then 'xs:gMonthDay' else 'unknown') } ;                     (:~ : The XML node kind (element, attribute, text, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_node-kind.html : @param $nodes the node(s) whose kind you want to determine :)          declare function functx:node-kind ( $nodes as node()* ) as xs:string* { for $node in $nodes return if ($node instance of element()) then 'element' else if ($node instance of attribute()) then 'attribute' else if ($node instance of text()) then 'text' else if ($node instance of document-node()) then 'document-node' else if ($node instance of comment()) then 'comment' else if ($node instance of processing-instruction()) then 'processing-instruction' else 'unknown' } ;                     (:~ : The sequence type that represents a sequence of nodes or values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-type.html : @param $items the items whose sequence type you want to determine :)          declare function functx:sequence-type ( $items as item()* ) as xs:string { concat( if (empty($items)) then 'empty-sequence()' else if (every $val in $items satisfies $val instance of xs:anyAtomicType) then if (count(distinct-values(functx:atomic-type($items))) > 1) then 'xs:anyAtomicType' else functx:atomic-type($items[1]) else if (some $val in $items satisfies $val instance of xs:anyAtomicType) then 'item()' else if (count(distinct-values(functx:node-kind($items))) > 1) then 'node()' else concat(functx:node-kind($items[1]),'()') , if (count($items) > 1) then '+' else '') } ;                     let $in-xml := <in-xml> <a att1="y">x</a> <b att1="x">x</b> <!-- comment --> </in-xml> return (functx:sequence-type($in-xml/*)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-sequence-type-7,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The built-in type of an atomic value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_atomic-type.html : @param $values the value(s) whose type you want to determine :)          declare function functx:atomic-type ( $values as xs:anyAtomicType* ) as xs:string* { for $val in $values return (if ($val instance of xs:untypedAtomic) then 'xs:untypedAtomic' else if ($val instance of xs:anyURI) then 'xs:anyURI' else if ($val instance of xs:ENTITY) then 'xs:ENTITY' else if ($val instance of xs:ID) then 'xs:ID' else if ($val instance of xs:NMTOKEN) then 'xs:NMTOKEN' else if ($val instance of xs:language) then 'xs:language' else if ($val instance of xs:NCName) then 'xs:NCName' else if ($val instance of xs:Name) then 'xs:Name' else if ($val instance of xs:token) then 'xs:token' else if ($val instance of xs:normalizedString) then 'xs:normalizedString' else if ($val instance of xs:string) then 'xs:string' else if ($val instance of xs:QName) then 'xs:QName' else if ($val instance of xs:boolean) then 'xs:boolean' else if ($val instance of xs:base64Binary) then 'xs:base64Binary' else if ($val instance of xs:hexBinary) then 'xs:hexBinary' else if ($val instance of xs:byte) then 'xs:byte' else if ($val instance of xs:short) then 'xs:short' else if ($val instance of xs:int) then 'xs:int' else if ($val instance of xs:long) then 'xs:long' else if ($val instance of xs:unsignedByte) then 'xs:unsignedByte' else if ($val instance of xs:unsignedShort) then 'xs:unsignedShort' else if ($val instance of xs:unsignedInt) then 'xs:unsignedInt' else if ($val instance of xs:unsignedLong) then 'xs:unsignedLong' else if ($val instance of xs:positiveInteger) then 'xs:positiveInteger' else if ($val instance of xs:nonNegativeInteger) then 'xs:nonNegativeInteger' else if ($val instance of xs:negativeInteger) then 'xs:negativeInteger' else if ($val instance of xs:nonPositiveInteger) then 'xs:nonPositiveInteger' else if ($val instance of xs:integer) then 'xs:integer' else if ($val instance of xs:decimal) then 'xs:decimal' else if ($val instance of xs:float) then 'xs:float' else if ($val instance of xs:double) then 'xs:double' else if ($val instance of xs:date) then 'xs:date' else if ($val instance of xs:time) then 'xs:time' else if ($val instance of xs:dateTime) then 'xs:dateTime' else if ($val instance of xs:dayTimeDuration) then 'xs:dayTimeDuration' else if ($val instance of xs:yearMonthDuration) then 'xs:yearMonthDuration' else if ($val instance of xs:duration) then 'xs:duration' else if ($val instance of xs:gMonth) then 'xs:gMonth' else if ($val instance of xs:gYear) then 'xs:gYear' else if ($val instance of xs:gYearMonth) then 'xs:gYearMonth' else if ($val instance of xs:gDay) then 'xs:gDay' else if ($val instance of xs:gMonthDay) then 'xs:gMonthDay' else 'unknown') } ;                     (:~ : The XML node kind (element, attribute, text, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_node-kind.html : @param $nodes the node(s) whose kind you want to determine :)          declare function functx:node-kind ( $nodes as node()* ) as xs:string* { for $node in $nodes return if ($node instance of element()) then 'element' else if ($node instance of attribute()) then 'attribute' else if ($node instance of text()) then 'text' else if ($node instance of document-node()) then 'document-node' else if ($node instance of comment()) then 'comment' else if ($node instance of processing-instruction()) then 'processing-instruction' else 'unknown' } ;                     (:~ : The sequence type that represents a sequence of nodes or values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-type.html : @param $items the items whose sequence type you want to determine :)          declare function functx:sequence-type ( $items as item()* ) as xs:string { concat( if (empty($items)) then 'empty-sequence()' else if (every $val in $items satisfies $val instance of xs:anyAtomicType) then if (count(distinct-values(functx:atomic-type($items))) > 1) then 'xs:anyAtomicType' else functx:atomic-type($items[1]) else if (some $val in $items satisfies $val instance of xs:anyAtomicType) then 'item()' else if (count(distinct-values(functx:node-kind($items))) > 1) then 'node()' else concat(functx:node-kind($items[1]),'()') , if (count($items) > 1) then '+' else '') } ;                     let $in-xml := <in-xml> <a att1="y">x</a> <b att1="x">x</b> <!-- comment --> </in-xml> return (functx:sequence-type($in-xml/*/@*)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-sequence-type-8,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The built-in type of an atomic value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_atomic-type.html : @param $values the value(s) whose type you want to determine :)          declare function functx:atomic-type ( $values as xs:anyAtomicType* ) as xs:string* { for $val in $values return (if ($val instance of xs:untypedAtomic) then 'xs:untypedAtomic' else if ($val instance of xs:anyURI) then 'xs:anyURI' else if ($val instance of xs:ENTITY) then 'xs:ENTITY' else if ($val instance of xs:ID) then 'xs:ID' else if ($val instance of xs:NMTOKEN) then 'xs:NMTOKEN' else if ($val instance of xs:language) then 'xs:language' else if ($val instance of xs:NCName) then 'xs:NCName' else if ($val instance of xs:Name) then 'xs:Name' else if ($val instance of xs:token) then 'xs:token' else if ($val instance of xs:normalizedString) then 'xs:normalizedString' else if ($val instance of xs:string) then 'xs:string' else if ($val instance of xs:QName) then 'xs:QName' else if ($val instance of xs:boolean) then 'xs:boolean' else if ($val instance of xs:base64Binary) then 'xs:base64Binary' else if ($val instance of xs:hexBinary) then 'xs:hexBinary' else if ($val instance of xs:byte) then 'xs:byte' else if ($val instance of xs:short) then 'xs:short' else if ($val instance of xs:int) then 'xs:int' else if ($val instance of xs:long) then 'xs:long' else if ($val instance of xs:unsignedByte) then 'xs:unsignedByte' else if ($val instance of xs:unsignedShort) then 'xs:unsignedShort' else if ($val instance of xs:unsignedInt) then 'xs:unsignedInt' else if ($val instance of xs:unsignedLong) then 'xs:unsignedLong' else if ($val instance of xs:positiveInteger) then 'xs:positiveInteger' else if ($val instance of xs:nonNegativeInteger) then 'xs:nonNegativeInteger' else if ($val instance of xs:negativeInteger) then 'xs:negativeInteger' else if ($val instance of xs:nonPositiveInteger) then 'xs:nonPositiveInteger' else if ($val instance of xs:integer) then 'xs:integer' else if ($val instance of xs:decimal) then 'xs:decimal' else if ($val instance of xs:float) then 'xs:float' else if ($val instance of xs:double) then 'xs:double' else if ($val instance of xs:date) then 'xs:date' else if ($val instance of xs:time) then 'xs:time' else if ($val instance of xs:dateTime) then 'xs:dateTime' else if ($val instance of xs:dayTimeDuration) then 'xs:dayTimeDuration' else if ($val instance of xs:yearMonthDuration) then 'xs:yearMonthDuration' else if ($val instance of xs:duration) then 'xs:duration' else if ($val instance of xs:gMonth) then 'xs:gMonth' else if ($val instance of xs:gYear) then 'xs:gYear' else if ($val instance of xs:gYearMonth) then 'xs:gYearMonth' else if ($val instance of xs:gDay) then 'xs:gDay' else if ($val instance of xs:gMonthDay) then 'xs:gMonthDay' else 'unknown') } ;                     (:~ : The XML node kind (element, attribute, text, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_node-kind.html : @param $nodes the node(s) whose kind you want to determine :)          declare function functx:node-kind ( $nodes as node()* ) as xs:string* { for $node in $nodes return if ($node instance of element()) then 'element' else if ($node instance of attribute()) then 'attribute' else if ($node instance of text()) then 'text' else if ($node instance of document-node()) then 'document-node' else if ($node instance of comment()) then 'comment' else if ($node instance of processing-instruction()) then 'processing-instruction' else 'unknown' } ;                     (:~ : The sequence type that represents a sequence of nodes or values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-type.html : @param $items the items whose sequence type you want to determine :)          declare function functx:sequence-type ( $items as item()* ) as xs:string { concat( if (empty($items)) then 'empty-sequence()' else if (every $val in $items satisfies $val instance of xs:anyAtomicType) then if (count(distinct-values(functx:atomic-type($items))) > 1) then 'xs:anyAtomicType' else functx:atomic-type($items[1]) else if (some $val in $items satisfies $val instance of xs:anyAtomicType) then 'item()' else if (count(distinct-values(functx:node-kind($items))) > 1) then 'node()' else concat(functx:node-kind($items[1]),'()') , if (count($items) > 1) then '+' else '') } ;                     let $in-xml := <in-xml> <a att1="y">x</a> <b att1="x">x</b> <!-- comment --> </in-xml> return (functx:sequence-type($in-xml/*/text())))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-sequence-type-9,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The built-in type of an atomic value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_atomic-type.html : @param $values the value(s) whose type you want to determine :)          declare function functx:atomic-type ( $values as xs:anyAtomicType* ) as xs:string* { for $val in $values return (if ($val instance of xs:untypedAtomic) then 'xs:untypedAtomic' else if ($val instance of xs:anyURI) then 'xs:anyURI' else if ($val instance of xs:ENTITY) then 'xs:ENTITY' else if ($val instance of xs:ID) then 'xs:ID' else if ($val instance of xs:NMTOKEN) then 'xs:NMTOKEN' else if ($val instance of xs:language) then 'xs:language' else if ($val instance of xs:NCName) then 'xs:NCName' else if ($val instance of xs:Name) then 'xs:Name' else if ($val instance of xs:token) then 'xs:token' else if ($val instance of xs:normalizedString) then 'xs:normalizedString' else if ($val instance of xs:string) then 'xs:string' else if ($val instance of xs:QName) then 'xs:QName' else if ($val instance of xs:boolean) then 'xs:boolean' else if ($val instance of xs:base64Binary) then 'xs:base64Binary' else if ($val instance of xs:hexBinary) then 'xs:hexBinary' else if ($val instance of xs:byte) then 'xs:byte' else if ($val instance of xs:short) then 'xs:short' else if ($val instance of xs:int) then 'xs:int' else if ($val instance of xs:long) then 'xs:long' else if ($val instance of xs:unsignedByte) then 'xs:unsignedByte' else if ($val instance of xs:unsignedShort) then 'xs:unsignedShort' else if ($val instance of xs:unsignedInt) then 'xs:unsignedInt' else if ($val instance of xs:unsignedLong) then 'xs:unsignedLong' else if ($val instance of xs:positiveInteger) then 'xs:positiveInteger' else if ($val instance of xs:nonNegativeInteger) then 'xs:nonNegativeInteger' else if ($val instance of xs:negativeInteger) then 'xs:negativeInteger' else if ($val instance of xs:nonPositiveInteger) then 'xs:nonPositiveInteger' else if ($val instance of xs:integer) then 'xs:integer' else if ($val instance of xs:decimal) then 'xs:decimal' else if ($val instance of xs:float) then 'xs:float' else if ($val instance of xs:double) then 'xs:double' else if ($val instance of xs:date) then 'xs:date' else if ($val instance of xs:time) then 'xs:time' else if ($val instance of xs:dateTime) then 'xs:dateTime' else if ($val instance of xs:dayTimeDuration) then 'xs:dayTimeDuration' else if ($val instance of xs:yearMonthDuration) then 'xs:yearMonthDuration' else if ($val instance of xs:duration) then 'xs:duration' else if ($val instance of xs:gMonth) then 'xs:gMonth' else if ($val instance of xs:gYear) then 'xs:gYear' else if ($val instance of xs:gYearMonth) then 'xs:gYearMonth' else if ($val instance of xs:gDay) then 'xs:gDay' else if ($val instance of xs:gMonthDay) then 'xs:gMonthDay' else 'unknown') } ;                     (:~ : The XML node kind (element, attribute, text, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_node-kind.html : @param $nodes the node(s) whose kind you want to determine :)          declare function functx:node-kind ( $nodes as node()* ) as xs:string* { for $node in $nodes return if ($node instance of element()) then 'element' else if ($node instance of attribute()) then 'attribute' else if ($node instance of text()) then 'text' else if ($node instance of document-node()) then 'document-node' else if ($node instance of comment()) then 'comment' else if ($node instance of processing-instruction()) then 'processing-instruction' else 'unknown' } ;                     (:~ : The sequence type that represents a sequence of nodes or values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-type.html : @param $items the items whose sequence type you want to determine :)          declare function functx:sequence-type ( $items as item()* ) as xs:string { concat( if (empty($items)) then 'empty-sequence()' else if (every $val in $items satisfies $val instance of xs:anyAtomicType) then if (count(distinct-values(functx:atomic-type($items))) > 1) then 'xs:anyAtomicType' else functx:atomic-type($items[1]) else if (some $val in $items satisfies $val instance of xs:anyAtomicType) then 'item()' else if (count(distinct-values(functx:node-kind($items))) > 1) then 'node()' else concat(functx:node-kind($items[1]),'()') , if (count($items) > 1) then '+' else '') } ;                     let $in-xml := <in-xml> <a att1="y">x</a> <b att1="x">x</b> <!-- comment --> </in-xml> return (functx:sequence-type($in-xml/comment())))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-sequence-type-10,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The built-in type of an atomic value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_atomic-type.html : @param $values the value(s) whose type you want to determine :)          declare function functx:atomic-type ( $values as xs:anyAtomicType* ) as xs:string* { for $val in $values return (if ($val instance of xs:untypedAtomic) then 'xs:untypedAtomic' else if ($val instance of xs:anyURI) then 'xs:anyURI' else if ($val instance of xs:ENTITY) then 'xs:ENTITY' else if ($val instance of xs:ID) then 'xs:ID' else if ($val instance of xs:NMTOKEN) then 'xs:NMTOKEN' else if ($val instance of xs:language) then 'xs:language' else if ($val instance of xs:NCName) then 'xs:NCName' else if ($val instance of xs:Name) then 'xs:Name' else if ($val instance of xs:token) then 'xs:token' else if ($val instance of xs:normalizedString) then 'xs:normalizedString' else if ($val instance of xs:string) then 'xs:string' else if ($val instance of xs:QName) then 'xs:QName' else if ($val instance of xs:boolean) then 'xs:boolean' else if ($val instance of xs:base64Binary) then 'xs:base64Binary' else if ($val instance of xs:hexBinary) then 'xs:hexBinary' else if ($val instance of xs:byte) then 'xs:byte' else if ($val instance of xs:short) then 'xs:short' else if ($val instance of xs:int) then 'xs:int' else if ($val instance of xs:long) then 'xs:long' else if ($val instance of xs:unsignedByte) then 'xs:unsignedByte' else if ($val instance of xs:unsignedShort) then 'xs:unsignedShort' else if ($val instance of xs:unsignedInt) then 'xs:unsignedInt' else if ($val instance of xs:unsignedLong) then 'xs:unsignedLong' else if ($val instance of xs:positiveInteger) then 'xs:positiveInteger' else if ($val instance of xs:nonNegativeInteger) then 'xs:nonNegativeInteger' else if ($val instance of xs:negativeInteger) then 'xs:negativeInteger' else if ($val instance of xs:nonPositiveInteger) then 'xs:nonPositiveInteger' else if ($val instance of xs:integer) then 'xs:integer' else if ($val instance of xs:decimal) then 'xs:decimal' else if ($val instance of xs:float) then 'xs:float' else if ($val instance of xs:double) then 'xs:double' else if ($val instance of xs:date) then 'xs:date' else if ($val instance of xs:time) then 'xs:time' else if ($val instance of xs:dateTime) then 'xs:dateTime' else if ($val instance of xs:dayTimeDuration) then 'xs:dayTimeDuration' else if ($val instance of xs:yearMonthDuration) then 'xs:yearMonthDuration' else if ($val instance of xs:duration) then 'xs:duration' else if ($val instance of xs:gMonth) then 'xs:gMonth' else if ($val instance of xs:gYear) then 'xs:gYear' else if ($val instance of xs:gYearMonth) then 'xs:gYearMonth' else if ($val instance of xs:gDay) then 'xs:gDay' else if ($val instance of xs:gMonthDay) then 'xs:gMonthDay' else 'unknown') } ;                     (:~ : The XML node kind (element, attribute, text, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_node-kind.html : @param $nodes the node(s) whose kind you want to determine :)          declare function functx:node-kind ( $nodes as node()* ) as xs:string* { for $node in $nodes return if ($node instance of element()) then 'element' else if ($node instance of attribute()) then 'attribute' else if ($node instance of text()) then 'text' else if ($node instance of document-node()) then 'document-node' else if ($node instance of comment()) then 'comment' else if ($node instance of processing-instruction()) then 'processing-instruction' else 'unknown' } ;                     (:~ : The sequence type that represents a sequence of nodes or values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-type.html : @param $items the items whose sequence type you want to determine :)          declare function functx:sequence-type ( $items as item()* ) as xs:string { concat( if (empty($items)) then 'empty-sequence()' else if (every $val in $items satisfies $val instance of xs:anyAtomicType) then if (count(distinct-values(functx:atomic-type($items))) > 1) then 'xs:anyAtomicType' else functx:atomic-type($items[1]) else if (some $val in $items satisfies $val instance of xs:anyAtomicType) then 'item()' else if (count(distinct-values(functx:node-kind($items))) > 1) then 'node()' else concat(functx:node-kind($items[1]),'()') , if (count($items) > 1) then '+' else '') } ;                     let $in-xml := <in-xml> <a att1="y">x</a> <b att1="x">x</b> <!-- comment --> </in-xml> return (functx:sequence-type($in-xml/node())))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-sequence-type-11,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The built-in type of an atomic value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_atomic-type.html : @param $values the value(s) whose type you want to determine :)          declare function functx:atomic-type ( $values as xs:anyAtomicType* ) as xs:string* { for $val in $values return (if ($val instance of xs:untypedAtomic) then 'xs:untypedAtomic' else if ($val instance of xs:anyURI) then 'xs:anyURI' else if ($val instance of xs:ENTITY) then 'xs:ENTITY' else if ($val instance of xs:ID) then 'xs:ID' else if ($val instance of xs:NMTOKEN) then 'xs:NMTOKEN' else if ($val instance of xs:language) then 'xs:language' else if ($val instance of xs:NCName) then 'xs:NCName' else if ($val instance of xs:Name) then 'xs:Name' else if ($val instance of xs:token) then 'xs:token' else if ($val instance of xs:normalizedString) then 'xs:normalizedString' else if ($val instance of xs:string) then 'xs:string' else if ($val instance of xs:QName) then 'xs:QName' else if ($val instance of xs:boolean) then 'xs:boolean' else if ($val instance of xs:base64Binary) then 'xs:base64Binary' else if ($val instance of xs:hexBinary) then 'xs:hexBinary' else if ($val instance of xs:byte) then 'xs:byte' else if ($val instance of xs:short) then 'xs:short' else if ($val instance of xs:int) then 'xs:int' else if ($val instance of xs:long) then 'xs:long' else if ($val instance of xs:unsignedByte) then 'xs:unsignedByte' else if ($val instance of xs:unsignedShort) then 'xs:unsignedShort' else if ($val instance of xs:unsignedInt) then 'xs:unsignedInt' else if ($val instance of xs:unsignedLong) then 'xs:unsignedLong' else if ($val instance of xs:positiveInteger) then 'xs:positiveInteger' else if ($val instance of xs:nonNegativeInteger) then 'xs:nonNegativeInteger' else if ($val instance of xs:negativeInteger) then 'xs:negativeInteger' else if ($val instance of xs:nonPositiveInteger) then 'xs:nonPositiveInteger' else if ($val instance of xs:integer) then 'xs:integer' else if ($val instance of xs:decimal) then 'xs:decimal' else if ($val instance of xs:float) then 'xs:float' else if ($val instance of xs:double) then 'xs:double' else if ($val instance of xs:date) then 'xs:date' else if ($val instance of xs:time) then 'xs:time' else if ($val instance of xs:dateTime) then 'xs:dateTime' else if ($val instance of xs:dayTimeDuration) then 'xs:dayTimeDuration' else if ($val instance of xs:yearMonthDuration) then 'xs:yearMonthDuration' else if ($val instance of xs:duration) then 'xs:duration' else if ($val instance of xs:gMonth) then 'xs:gMonth' else if ($val instance of xs:gYear) then 'xs:gYear' else if ($val instance of xs:gYearMonth) then 'xs:gYearMonth' else if ($val instance of xs:gDay) then 'xs:gDay' else if ($val instance of xs:gMonthDay) then 'xs:gMonthDay' else 'unknown') } ;                     (:~ : The XML node kind (element, attribute, text, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_node-kind.html : @param $nodes the node(s) whose kind you want to determine :)          declare function functx:node-kind ( $nodes as node()* ) as xs:string* { for $node in $nodes return if ($node instance of element()) then 'element' else if ($node instance of attribute()) then 'attribute' else if ($node instance of text()) then 'text' else if ($node instance of document-node()) then 'document-node' else if ($node instance of comment()) then 'comment' else if ($node instance of processing-instruction()) then 'processing-instruction' else 'unknown' } ;                     (:~ : The sequence type that represents a sequence of nodes or values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-type.html : @param $items the items whose sequence type you want to determine :)          declare function functx:sequence-type ( $items as item()* ) as xs:string { concat( if (empty($items)) then 'empty-sequence()' else if (every $val in $items satisfies $val instance of xs:anyAtomicType) then if (count(distinct-values(functx:atomic-type($items))) > 1) then 'xs:anyAtomicType' else functx:atomic-type($items[1]) else if (some $val in $items satisfies $val instance of xs:anyAtomicType) then 'item()' else if (count(distinct-values(functx:node-kind($items))) > 1) then 'node()' else concat(functx:node-kind($items[1]),'()') , if (count($items) > 1) then '+' else '') } ;                     let $in-xml := <in-xml> <a att1="y">x</a> <b att1="x">x</b> <!-- comment --> </in-xml> return (functx:sequence-type(($in-xml/*,'2'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-sequence-type-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The built-in type of an atomic value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_atomic-type.html : @param $values the value(s) whose type you want to determine :)          declare function functx:atomic-type ( $values as xs:anyAtomicType* ) as xs:string* { for $val in $values return (if ($val instance of xs:untypedAtomic) then 'xs:untypedAtomic' else if ($val instance of xs:anyURI) then 'xs:anyURI' else if ($val instance of xs:ENTITY) then 'xs:ENTITY' else if ($val instance of xs:ID) then 'xs:ID' else if ($val instance of xs:NMTOKEN) then 'xs:NMTOKEN' else if ($val instance of xs:language) then 'xs:language' else if ($val instance of xs:NCName) then 'xs:NCName' else if ($val instance of xs:Name) then 'xs:Name' else if ($val instance of xs:token) then 'xs:token' else if ($val instance of xs:normalizedString) then 'xs:normalizedString' else if ($val instance of xs:string) then 'xs:string' else if ($val instance of xs:QName) then 'xs:QName' else if ($val instance of xs:boolean) then 'xs:boolean' else if ($val instance of xs:base64Binary) then 'xs:base64Binary' else if ($val instance of xs:hexBinary) then 'xs:hexBinary' else if ($val instance of xs:byte) then 'xs:byte' else if ($val instance of xs:short) then 'xs:short' else if ($val instance of xs:int) then 'xs:int' else if ($val instance of xs:long) then 'xs:long' else if ($val instance of xs:unsignedByte) then 'xs:unsignedByte' else if ($val instance of xs:unsignedShort) then 'xs:unsignedShort' else if ($val instance of xs:unsignedInt) then 'xs:unsignedInt' else if ($val instance of xs:unsignedLong) then 'xs:unsignedLong' else if ($val instance of xs:positiveInteger) then 'xs:positiveInteger' else if ($val instance of xs:nonNegativeInteger) then 'xs:nonNegativeInteger' else if ($val instance of xs:negativeInteger) then 'xs:negativeInteger' else if ($val instance of xs:nonPositiveInteger) then 'xs:nonPositiveInteger' else if ($val instance of xs:integer) then 'xs:integer' else if ($val instance of xs:decimal) then 'xs:decimal' else if ($val instance of xs:float) then 'xs:float' else if ($val instance of xs:double) then 'xs:double' else if ($val instance of xs:date) then 'xs:date' else if ($val instance of xs:time) then 'xs:time' else if ($val instance of xs:dateTime) then 'xs:dateTime' else if ($val instance of xs:dayTimeDuration) then 'xs:dayTimeDuration' else if ($val instance of xs:yearMonthDuration) then 'xs:yearMonthDuration' else if ($val instance of xs:duration) then 'xs:duration' else if ($val instance of xs:gMonth) then 'xs:gMonth' else if ($val instance of xs:gYear) then 'xs:gYear' else if ($val instance of xs:gYearMonth) then 'xs:gYearMonth' else if ($val instance of xs:gDay) then 'xs:gDay' else if ($val instance of xs:gMonthDay) then 'xs:gMonthDay' else 'unknown') } ;                     (:~ : The XML node kind (element, attribute, text, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_node-kind.html : @param $nodes the node(s) whose kind you want to determine :)          declare function functx:node-kind ( $nodes as node()* ) as xs:string* { for $node in $nodes return if ($node instance of element()) then 'element' else if ($node instance of attribute()) then 'attribute' else if ($node instance of text()) then 'text' else if ($node instance of document-node()) then 'document-node' else if ($node instance of comment()) then 'comment' else if ($node instance of processing-instruction()) then 'processing-instruction' else 'unknown' } ;                     (:~ : The sequence type that represents a sequence of nodes or values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-type.html : @param $items the items whose sequence type you want to determine :)          declare function functx:sequence-type ( $items as item()* ) as xs:string { concat( if (empty($items)) then 'empty-sequence()' else if (every $val in $items satisfies $val instance of xs:anyAtomicType) then if (count(distinct-values(functx:atomic-type($items))) > 1) then 'xs:anyAtomicType' else functx:atomic-type($items[1]) else if (some $val in $items satisfies $val instance of xs:anyAtomicType) then 'item()' else if (count(distinct-values(functx:node-kind($items))) > 1) then 'node()' else concat(functx:node-kind($items[1]),'()') , if (count($items) > 1) then '+' else '') } ;                     let $in-xml := <in-xml> <a att1="y">x</a> <b att1="x">x</b> <!-- comment --> </in-xml> return (functx:sequence-type(2), functx:sequence-type(('abc','def')), functx:sequence-type(('abc',2)), functx:sequence-type( () ), functx:sequence-type($in-xml/*[1]), functx:sequence-type($in-xml/*), functx:sequence-type($in-xml/*/@*), functx:sequence-type($in-xml/*/text()), functx:sequence-type($in-xml/comment()), functx:sequence-type($in-xml/node()), functx:sequence-type(($in-xml/*,'2'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-siblings-same-name-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : The siblings of an XML element that have the same name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_siblings-same-name.html : @param $element the node :)          declare function functx:siblings-same-name ( $element as element()? ) as element()* { $element/../*[node-name(.) = node-name($element)] except $element } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <fName>Jane</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:siblings-same-name( $in-xml/author[1])). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-siblings-same-name-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : The siblings of an XML element that have the same name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_siblings-same-name.html : @param $element the node :)          declare function functx:siblings-same-name ( $element as element()? ) as element()* { $element/../*[node-name(.) = node-name($element)] except $element } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <fName>Jane</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:siblings-same-name( $in-xml/author[1]/fName[2])). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-siblings-same-name-all,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : The siblings of an XML element that have the same name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_siblings-same-name.html : @param $element the node :)          declare function functx:siblings-same-name ( $element as element()? ) as element()* { $element/../*[node-name(.) = node-name($element)] except $element } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <fName>Jane</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:siblings-same-name( $in-xml/author[1]), functx:siblings-same-name( $in-xml/author[1]/fName[2])). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-siblings-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : The siblings of an XML node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_siblings.html : @param $node the node :)          declare function functx:siblings ( $node as node()? ) as node()* { $node/../node() except $node } ;                     let $in-xml := <authors a1='xyz'> <author a2='abc'> <fName a3='def'>Kate</fName> <fName a3='def'>Jane</fName> <lName>Jones</lName> </author> <author> <fName a3='def'>John</fName> <lName>Doe</lName> </author> </authors> return (functx:siblings( $in-xml/author[1])). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-siblings-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : The siblings of an XML node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_siblings.html : @param $node the node :)          declare function functx:siblings ( $node as node()? ) as node()* { $node/../node() except $node } ;                     let $in-xml := <authors a1='xyz'> <author a2='abc'> <fName a3='def'>Kate</fName> <fName a3='def'>Jane</fName> <lName>Jones</lName> </author> <author> <fName a3='def'>John</fName> <lName>Doe</lName> </author> </authors> return (functx:siblings( $in-xml/author[1]/fName[2])). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-siblings-all,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : The siblings of an XML node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_siblings.html : @param $node the node :)          declare function functx:siblings ( $node as node()? ) as node()* { $node/../node() except $node } ;                     let $in-xml := <authors a1='xyz'> <author a2='abc'> <fName a3='def'>Kate</fName> <fName a3='def'>Jane</fName> <lName>Jones</lName> </author> <author> <fName a3='def'>John</fName> <lName>Doe</lName> </author> </authors> return (functx:siblings( $in-xml/author[1]), functx:siblings( $in-xml/author[1]/fName[2])). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-sort-as-numeric-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of numeric values or nodes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort-as-numeric.html : @param $seq the sequence to sort :)          declare function functx:sort-as-numeric ( $seq as item()* ) as item()* { for $item in $seq order by number($item) return $item } ;                     let $in-xml := <in-xml> <f>1</f> <f>35</f> <e>4</e> </in-xml> return (functx:sort-as-numeric(('1','100','99'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-sort-as-numeric-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of numeric values or nodes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort-as-numeric.html : @param $seq the sequence to sort :)          declare function functx:sort-as-numeric ( $seq as item()* ) as item()* { for $item in $seq order by number($item) return $item } ;                     let $in-xml := <in-xml> <f>1</f> <f>35</f> <e>4</e> </in-xml> return (functx:sort-as-numeric($in-xml/*)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-sort-as-numeric-all,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of numeric values or nodes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort-as-numeric.html : @param $seq the sequence to sort :)          declare function functx:sort-as-numeric ( $seq as item()* ) as item()* { for $item in $seq order by number($item) return $item } ;          let $in-xml := <in-xml> <f>1</f> <f>35</f> <e>4</e> </in-xml>           return document{(functx:sort-as-numeric(('1','100','99')), functx:sort-as-numeric($in-xml/*))}       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-sort-case-insensitive-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of values or nodes regardless of capitalization : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort-case-insensitive.html : @param $seq the sequence to sort :)          declare function functx:sort-case-insensitive ( $seq as item()* ) as item()* { for $item in $seq order by upper-case(string($item)) return $item } ;                     let $in-xml := <in-xml> <f>a</f> <f>c</f> <e>B</e> </in-xml> return (functx:sort-case-insensitive(('a','c','B'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-sort-case-insensitive-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of values or nodes regardless of capitalization : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort-case-insensitive.html : @param $seq the sequence to sort :)          declare function functx:sort-case-insensitive ( $seq as item()* ) as item()* { for $item in $seq order by upper-case(string($item)) return $item } ;                     let $in-xml := <in-xml> <f>a</f> <f>c</f> <e>B</e> </in-xml> return (functx:sort-case-insensitive($in-xml/*)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-sort-case-insensitive-all,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of values or nodes regardless of capitalization : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort-case-insensitive.html : @param $seq the sequence to sort :)          declare function functx:sort-case-insensitive ( $seq as item()* ) as item()* {              for $item in $seq order by upper-case(string($item)) return $item           } ;          let $in-xml := <in-xml> <f>a</f> <f>c</f> <e>B</e> </in-xml>           return document{(functx:sort-case-insensitive(('a','c','B')), functx:sort-case-insensitive($in-xml/*))}       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-sort-document-order-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of nodes in document order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort-document-order.html : @param $seq the sequence to sort :)          declare function functx:sort-document-order ( $seq as node()* ) as node()* { $seq/. } ;                     let $in-xml := <in-xml> <a>123</a> <b>456</b> <c>789</c> </in-xml> return (functx:sort-document-order( ($in-xml/c,$in-xml/a))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-sort-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of values or nodes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort.html : @param $seq the sequence to sort :)          declare function functx:sort ( $seq as item()* ) as item()* { for $item in $seq order by $item return $item } ;                     let $in-xml := <in-xml> <f>c</f> <f>a</f> <e>b</e> </in-xml> return (functx:sort(('c','a','b'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-sort-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of values or nodes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort.html : @param $seq the sequence to sort :)          declare function functx:sort ( $seq as item()* ) as item()* { for $item in $seq order by $item return $item } ;                     let $in-xml := <in-xml> <f>c</f> <f>a</f> <e>b</e> </in-xml> return (functx:sort($in-xml/*)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-sort-all,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of values or nodes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort.html : @param $seq the sequence to sort :)          declare function functx:sort ( $seq as item()* ) as item()* {              for $item in $seq order by $item return $item           };          let $in-xml := <in-xml> <f>c</f> <f>a</f> <e>b</e> </in-xml>           return document{(functx:sort(('c','a','b')), functx:sort($in-xml/*))}        . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-substring-after-if-contains-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     (functx:substring-after-if-contains('abcd','b')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-substring-after-if-contains-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     (functx:substring-after-if-contains('abcd','x')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-substring-after-if-contains-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     (functx:substring-after-if-contains('abcd','b'), functx:substring-after-if-contains('abcd','x')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-substring-after-last-match-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The substring after the last text that matches a regex : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-last-match.html : @param $arg the string to substring : @param $regex the regular expression :)          declare function functx:substring-after-last-match ( $arg as xs:string? , $regex as xs:string ) as xs:string { replace($arg,concat('^.*',$regex),'') } ;                     (functx:substring-after-last-match( 'abc-def-ghi', '[ad]')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-substring-after-last-match-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The substring after the last text that matches a regex : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-last-match.html : @param $arg the string to substring : @param $regex the regular expression :)          declare function functx:substring-after-last-match ( $arg as xs:string? , $regex as xs:string ) as xs:string { replace($arg,concat('^.*',$regex),'') } ;                     (functx:substring-after-last-match( 'abcd-abcd', 'bc?')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-substring-after-last-match-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The substring after the last text that matches a regex : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-last-match.html : @param $arg the string to substring : @param $regex the regular expression :)          declare function functx:substring-after-last-match ( $arg as xs:string? , $regex as xs:string ) as xs:string { replace($arg,concat('^.*',$regex),'') } ;                     (functx:substring-after-last-match( 'abcd-abcd', 'x')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-substring-after-last-match-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The substring after the last text that matches a regex : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-last-match.html : @param $arg the string to substring : @param $regex the regular expression :)          declare function functx:substring-after-last-match ( $arg as xs:string? , $regex as xs:string ) as xs:string { replace($arg,concat('^.*',$regex),'') } ;                     (functx:substring-after-last-match( 'abc-def-ghi', '[ad]'), functx:substring-after-last-match( 'abcd-abcd', 'bc?'), functx:substring-after-last-match( 'abcd-abcd', 'x')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-substring-after-last-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Escapes regex special characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_escape-for-regex.html : @param $arg the string to escape :)          declare function functx:escape-for-regex ( $arg as xs:string? ) as xs:string { replace($arg, '(\.|\[|\]|\\|\||\-|\^|\$|\?|\*|\+|\{|\}|\(|\))','\\$1') } ;                     (:~ : The substring after the last occurrence of a delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-last.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-last ( $arg as xs:string? , $delim as xs:string ) as xs:string { replace ($arg,concat('^.*',functx:escape-for-regex($delim)),'') } ;                     (functx:substring-after-last('abc-def-ghi', '-')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-substring-after-last-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Escapes regex special characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_escape-for-regex.html : @param $arg the string to escape :)          declare function functx:escape-for-regex ( $arg as xs:string? ) as xs:string { replace($arg, '(\.|\[|\]|\\|\||\-|\^|\$|\?|\*|\+|\{|\}|\(|\))','\\$1') } ;                     (:~ : The substring after the last occurrence of a delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-last.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-last ( $arg as xs:string? , $delim as xs:string ) as xs:string { replace ($arg,concat('^.*',functx:escape-for-regex($delim)),'') } ;                     (functx:substring-after-last('abcd-abcd', 'ab')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-substring-after-last-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Escapes regex special characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_escape-for-regex.html : @param $arg the string to escape :)          declare function functx:escape-for-regex ( $arg as xs:string? ) as xs:string { replace($arg, '(\.|\[|\]|\\|\||\-|\^|\$|\?|\*|\+|\{|\}|\(|\))','\\$1') } ;                     (:~ : The substring after the last occurrence of a delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-last.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-last ( $arg as xs:string? , $delim as xs:string ) as xs:string { replace ($arg,concat('^.*',functx:escape-for-regex($delim)),'') } ;                     (functx:substring-after-last('abcd-abcd', 'x')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-substring-after-last-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Escapes regex special characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_escape-for-regex.html : @param $arg the string to escape :)          declare function functx:escape-for-regex ( $arg as xs:string? ) as xs:string { replace($arg, '(\.|\[|\]|\\|\||\-|\^|\$|\?|\*|\+|\{|\}|\(|\))','\\$1') } ;                     (:~ : The substring after the last occurrence of a delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-last.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-last ( $arg as xs:string? , $delim as xs:string ) as xs:string { replace ($arg,concat('^.*',functx:escape-for-regex($delim)),'') } ;                     (functx:substring-after-last('abc-def-ghi', '-'), functx:substring-after-last('abcd-abcd', 'ab'), functx:substring-after-last('abcd-abcd', 'x')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-substring-after-match-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The substring after the first text that matches a regex : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-match.html : @param $arg the string to substring : @param $regex the regular expression :)          declare function functx:substring-after-match ( $arg as xs:string? , $regex as xs:string ) as xs:string? { replace($arg,concat('^.*?',$regex),'') } ;                     (functx:substring-after-match( 'abc-def-ghi', '[ce]')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-substring-after-match-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The substring after the first text that matches a regex : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-match.html : @param $arg the string to substring : @param $regex the regular expression :)          declare function functx:substring-after-match ( $arg as xs:string? , $regex as xs:string ) as xs:string? { replace($arg,concat('^.*?',$regex),'') } ;                     (functx:substring-after-match( 'abcd-abcd', 'ab?')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-substring-after-match-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The substring after the first text that matches a regex : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-match.html : @param $arg the string to substring : @param $regex the regular expression :)          declare function functx:substring-after-match ( $arg as xs:string? , $regex as xs:string ) as xs:string? { replace($arg,concat('^.*?',$regex),'') } ;                     (functx:substring-after-match( 'abcd-abcd', 'x')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-substring-after-match-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The substring after the first text that matches a regex : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-match.html : @param $arg the string to substring : @param $regex the regular expression :)          declare function functx:substring-after-match ( $arg as xs:string? , $regex as xs:string ) as xs:string? { replace($arg,concat('^.*?',$regex),'') } ;                     (functx:substring-after-match( 'abc-def-ghi', '[ce]'), functx:substring-after-match( 'abcd-abcd', 'ab?'), functx:substring-after-match( 'abcd-abcd', 'x')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-substring-before-if-contains-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Performs substring-before, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-before($arg,$delim) else $arg } ;                     (functx:substring-before-if-contains('abcd','c')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-substring-before-if-contains-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Performs substring-before, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-before($arg,$delim) else $arg } ;                     (functx:substring-before-if-contains('abcd','x')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-substring-before-if-contains-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Performs substring-before, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-before($arg,$delim) else $arg } ;                     (functx:substring-before-if-contains('abcd','c'), functx:substring-before-if-contains('abcd','x')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-substring-before-last-match-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The substring before the last text that matches a regex : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-last-match.html : @param $arg the string to substring : @param $regex the regular expression :)          declare function functx:substring-before-last-match ( $arg as xs:string? , $regex as xs:string ) as xs:string? { replace($arg,concat('^(.*)',$regex,'.*'),'$1') } ;                     (functx:substring-before-last-match( 'abc-def-ghi', '[ce]')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-substring-before-last-match-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The substring before the last text that matches a regex : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-last-match.html : @param $arg the string to substring : @param $regex the regular expression :)          declare function functx:substring-before-last-match ( $arg as xs:string? , $regex as xs:string ) as xs:string? { replace($arg,concat('^(.*)',$regex,'.*'),'$1') } ;                     (functx:substring-before-last-match( 'abcd-abcd', 'ab?')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-substring-before-last-match-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The substring before the last text that matches a regex : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-last-match.html : @param $arg the string to substring : @param $regex the regular expression :)          declare function functx:substring-before-last-match ( $arg as xs:string? , $regex as xs:string ) as xs:string? { replace($arg,concat('^(.*)',$regex,'.*'),'$1') } ;                     (functx:substring-before-last-match( 'abcd-abcd', 'x')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-substring-before-last-match-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The substring before the last text that matches a regex : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-last-match.html : @param $arg the string to substring : @param $regex the regular expression :)          declare function functx:substring-before-last-match ( $arg as xs:string? , $regex as xs:string ) as xs:string? { replace($arg,concat('^(.*)',$regex,'.*'),'$1') } ;                     (functx:substring-before-last-match( 'abc-def-ghi', '[ce]'), functx:substring-before-last-match( 'abcd-abcd', 'ab?'), functx:substring-before-last-match( 'abcd-abcd', 'x')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-substring-before-last-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Escapes regex special characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_escape-for-regex.html : @param $arg the string to escape :)          declare function functx:escape-for-regex ( $arg as xs:string? ) as xs:string { replace($arg, '(\.|\[|\]|\\|\||\-|\^|\$|\?|\*|\+|\{|\}|\(|\))','\\$1') } ;                     (:~ : The substring before the last occurrence of a delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-last.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-last ( $arg as xs:string? , $delim as xs:string ) as xs:string { if (matches($arg, functx:escape-for-regex($delim))) then replace($arg, concat('^(.*)', functx:escape-for-regex($delim),'.*'), '$1') else '' } ;                     (functx:substring-before-last( 'abc-def-ghi', '-')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-substring-before-last-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Escapes regex special characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_escape-for-regex.html : @param $arg the string to escape :)          declare function functx:escape-for-regex ( $arg as xs:string? ) as xs:string { replace($arg, '(\.|\[|\]|\\|\||\-|\^|\$|\?|\*|\+|\{|\}|\(|\))','\\$1') } ;                     (:~ : The substring before the last occurrence of a delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-last.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-last ( $arg as xs:string? , $delim as xs:string ) as xs:string { if (matches($arg, functx:escape-for-regex($delim))) then replace($arg, concat('^(.*)', functx:escape-for-regex($delim),'.*'), '$1') else '' } ;                     (functx:substring-before-last('abcd-abcd', 'ab')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-substring-before-last-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Escapes regex special characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_escape-for-regex.html : @param $arg the string to escape :)          declare function functx:escape-for-regex ( $arg as xs:string? ) as xs:string { replace($arg, '(\.|\[|\]|\\|\||\-|\^|\$|\?|\*|\+|\{|\}|\(|\))','\\$1') } ;                     (:~ : The substring before the last occurrence of a delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-last.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-last ( $arg as xs:string? , $delim as xs:string ) as xs:string { if (matches($arg, functx:escape-for-regex($delim))) then replace($arg, concat('^(.*)', functx:escape-for-regex($delim),'.*'), '$1') else '' } ;                     (functx:substring-before-last('abcd-abcd', 'x')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-substring-before-last-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Escapes regex special characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_escape-for-regex.html : @param $arg the string to escape :)          declare function functx:escape-for-regex ( $arg as xs:string? ) as xs:string { replace($arg, '(\.|\[|\]|\\|\||\-|\^|\$|\?|\*|\+|\{|\}|\(|\))','\\$1') } ;                     (:~ : The substring before the last occurrence of a delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-last.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-last ( $arg as xs:string? , $delim as xs:string ) as xs:string { if (matches($arg, functx:escape-for-regex($delim))) then replace($arg, concat('^(.*)', functx:escape-for-regex($delim),'.*'), '$1') else '' } ;                     (functx:substring-before-last( 'abc-def-ghi', '-'), functx:substring-before-last('abcd-abcd', 'ab'), functx:substring-before-last('abcd-abcd', 'x')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-substring-before-match-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The substring before the first text that matches a regex : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-match.html : @param $arg the string to substring : @param $regex the regular expression :)          declare function functx:substring-before-match ( $arg as xs:string? , $regex as xs:string ) as xs:string? { tokenize($arg,$regex)[1] } ;                     (functx:substring-before-match( 'abc-def-ghi', '[dg]')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-substring-before-match-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The substring before the first text that matches a regex : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-match.html : @param $arg the string to substring : @param $regex the regular expression :)          declare function functx:substring-before-match ( $arg as xs:string? , $regex as xs:string ) as xs:string? { tokenize($arg,$regex)[1] } ;                     (functx:substring-before-match( 'abcd-abcd', 'bc?')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-substring-before-match-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The substring before the first text that matches a regex : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-match.html : @param $arg the string to substring : @param $regex the regular expression :)          declare function functx:substring-before-match ( $arg as xs:string? , $regex as xs:string ) as xs:string? { tokenize($arg,$regex)[1] } ;                     (functx:substring-before-match( 'abcd-abcd', 'x')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-substring-before-match-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The substring before the first text that matches a regex : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-match.html : @param $arg the string to substring : @param $regex the regular expression :)          declare function functx:substring-before-match ( $arg as xs:string? , $regex as xs:string ) as xs:string? { tokenize($arg,$regex)[1] } ;                     (functx:substring-before-match( 'abc-def-ghi', '[dg]'), functx:substring-before-match( 'abcd-abcd', 'bc?'), functx:substring-before-match( 'abcd-abcd', 'x')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-time-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Pads an integer to a desired length by adding leading zeros : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-integer-to-length.html : @param $integerToPad the integer to pad : @param $length the desired length :)          declare function functx:pad-integer-to-length ( $integerToPad as xs:anyAtomicType? , $length as xs:integer ) as xs:string { if ($length < string-length(string($integerToPad))) then error(xs:QName('functx:Integer_Longer_Than_Length')) else concat (functx:repeat-string( '0',$length - string-length(string($integerToPad))), string($integerToPad)) } ;                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (:~ : Construct a time from an hour, minute and second : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_time.html : @param $hour the hour : @param $minute the minute : @param $second the second :)          declare function functx:time ( $hour as xs:anyAtomicType , $minute as xs:anyAtomicType , $second as xs:anyAtomicType ) as xs:time { xs:time( concat( functx:pad-integer-to-length(xs:integer($hour),2),':', functx:pad-integer-to-length(xs:integer($minute),2),':', functx:pad-integer-to-length(xs:integer($second),2))) } ;                     (functx:time(20,6,12)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-time-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Pads an integer to a desired length by adding leading zeros : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-integer-to-length.html : @param $integerToPad the integer to pad : @param $length the desired length :)          declare function functx:pad-integer-to-length ( $integerToPad as xs:anyAtomicType? , $length as xs:integer ) as xs:string { if ($length < string-length(string($integerToPad))) then error(xs:QName('functx:Integer_Longer_Than_Length')) else concat (functx:repeat-string( '0',$length - string-length(string($integerToPad))), string($integerToPad)) } ;                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (:~ : Construct a time from an hour, minute and second : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_time.html : @param $hour the hour : @param $minute the minute : @param $second the second :)          declare function functx:time ( $hour as xs:anyAtomicType , $minute as xs:anyAtomicType , $second as xs:anyAtomicType ) as xs:time { xs:time( concat( functx:pad-integer-to-length(xs:integer($hour),2),':', functx:pad-integer-to-length(xs:integer($minute),2),':', functx:pad-integer-to-length(xs:integer($second),2))) } ;                     (functx:time('20','6','12')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-time-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Pads an integer to a desired length by adding leading zeros : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-integer-to-length.html : @param $integerToPad the integer to pad : @param $length the desired length :)          declare function functx:pad-integer-to-length ( $integerToPad as xs:anyAtomicType? , $length as xs:integer ) as xs:string { if ($length < string-length(string($integerToPad))) then error(xs:QName('functx:Integer_Longer_Than_Length')) else concat (functx:repeat-string( '0',$length - string-length(string($integerToPad))), string($integerToPad)) } ;                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (:~ : Construct a time from an hour, minute and second : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_time.html : @param $hour the hour : @param $minute the minute : @param $second the second :)          declare function functx:time ( $hour as xs:anyAtomicType , $minute as xs:anyAtomicType , $second as xs:anyAtomicType ) as xs:time { xs:time( concat( functx:pad-integer-to-length(xs:integer($hour),2),':', functx:pad-integer-to-length(xs:integer($minute),2),':', functx:pad-integer-to-length(xs:integer($second),2))) } ;                     (functx:time(20,6,12), functx:time('20','6','12')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-timezone-from-duration-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Converts an xs:dayTimeDuration into a timezone like "-05:00" or "Z" : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_timezone-from-duration.html : @param $duration the duration :)          declare function functx:timezone-from-duration ( $duration as xs:dayTimeDuration ) as xs:string { if (string($duration) = ('PT0S','-PT0S')) then 'Z' else if (matches(string($duration),'-PT[1-9]H')) then replace(string($duration),'PT([1-9])H','0$1:00') else if (matches(string($duration),'PT[1-9]H')) then replace(string($duration),'PT([1-9])H','+0$1:00') else if (matches(string($duration),'-PT1[0-4]H')) then replace(string($duration),'PT(1[0-4])H','$1:00') else if (matches(string($duration),'PT1[0-4]H')) then replace(string($duration),'PT(1[0-4])H','+$1:00') else error(xs:QName('functx:Invalid_Duration_Value')) } ;                     (functx:timezone-from-duration( xs:dayTimeDuration('PT0S'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-timezone-from-duration-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Converts an xs:dayTimeDuration into a timezone like "-05:00" or "Z" : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_timezone-from-duration.html : @param $duration the duration :)          declare function functx:timezone-from-duration ( $duration as xs:dayTimeDuration ) as xs:string { if (string($duration) = ('PT0S','-PT0S')) then 'Z' else if (matches(string($duration),'-PT[1-9]H')) then replace(string($duration),'PT([1-9])H','0$1:00') else if (matches(string($duration),'PT[1-9]H')) then replace(string($duration),'PT([1-9])H','+0$1:00') else if (matches(string($duration),'-PT1[0-4]H')) then replace(string($duration),'PT(1[0-4])H','$1:00') else if (matches(string($duration),'PT1[0-4]H')) then replace(string($duration),'PT(1[0-4])H','+$1:00') else error(xs:QName('functx:Invalid_Duration_Value')) } ;                     (functx:timezone-from-duration( xs:dayTimeDuration('-PT5H'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-timezone-from-duration-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Converts an xs:dayTimeDuration into a timezone like "-05:00" or "Z" : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_timezone-from-duration.html : @param $duration the duration :)          declare function functx:timezone-from-duration ( $duration as xs:dayTimeDuration ) as xs:string { if (string($duration) = ('PT0S','-PT0S')) then 'Z' else if (matches(string($duration),'-PT[1-9]H')) then replace(string($duration),'PT([1-9])H','0$1:00') else if (matches(string($duration),'PT[1-9]H')) then replace(string($duration),'PT([1-9])H','+0$1:00') else if (matches(string($duration),'-PT1[0-4]H')) then replace(string($duration),'PT(1[0-4])H','$1:00') else if (matches(string($duration),'PT1[0-4]H')) then replace(string($duration),'PT(1[0-4])H','+$1:00') else error(xs:QName('functx:Invalid_Duration_Value')) } ;                     (functx:timezone-from-duration( xs:dayTimeDuration('PT9H'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-timezone-from-duration-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Converts an xs:dayTimeDuration into a timezone like "-05:00" or "Z" : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_timezone-from-duration.html : @param $duration the duration :)          declare function functx:timezone-from-duration ( $duration as xs:dayTimeDuration ) as xs:string { if (string($duration) = ('PT0S','-PT0S')) then 'Z' else if (matches(string($duration),'-PT[1-9]H')) then replace(string($duration),'PT([1-9])H','0$1:00') else if (matches(string($duration),'PT[1-9]H')) then replace(string($duration),'PT([1-9])H','+0$1:00') else if (matches(string($duration),'-PT1[0-4]H')) then replace(string($duration),'PT(1[0-4])H','$1:00') else if (matches(string($duration),'PT1[0-4]H')) then replace(string($duration),'PT(1[0-4])H','+$1:00') else error(xs:QName('functx:Invalid_Duration_Value')) } ;                     (functx:timezone-from-duration( xs:dayTimeDuration('PT0S')), functx:timezone-from-duration( xs:dayTimeDuration('-PT5H')), functx:timezone-from-duration( xs:dayTimeDuration('PT9H'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-total-days-from-duration-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The total number of days in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-days-from-duration.html : @param $duration the duration :)          declare function functx:total-days-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('P1D') } ;                     (functx:total-days-from-duration( xs:dayTimeDuration('PT24H')))) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-total-days-from-duration-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The total number of days in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-days-from-duration.html : @param $duration the duration :)          declare function functx:total-days-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('P1D') } ;                     (functx:total-days-from-duration( xs:dayTimeDuration('P1D')))) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-total-days-from-duration-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The total number of days in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-days-from-duration.html : @param $duration the duration :)          declare function functx:total-days-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('P1D') } ;                     (functx:total-days-from-duration( xs:dayTimeDuration('PT36H'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-total-days-from-duration-4,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The total number of days in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-days-from-duration.html : @param $duration the duration :)          declare function functx:total-days-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('P1D') } ;                     (functx:total-days-from-duration( xs:dayTimeDuration('PT48H')))) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-total-days-from-duration-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The total number of days in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-days-from-duration.html : @param $duration the duration :)          declare function functx:total-days-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('P1D') } ;                     (functx:total-days-from-duration( xs:dayTimeDuration('PT24H')), functx:total-days-from-duration( xs:dayTimeDuration('P1D')), functx:total-days-from-duration( xs:dayTimeDuration('PT36H')), functx:total-days-from-duration( xs:dayTimeDuration('PT48H'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-total-hours-from-duration-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The total number of hours in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-hours-from-duration.html : @param $duration the duration :)          declare function functx:total-hours-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1H') } ;                     (functx:total-hours-from-duration( xs:dayTimeDuration('PT26H')))) = (26). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-total-hours-from-duration-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The total number of hours in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-hours-from-duration.html : @param $duration the duration :)          declare function functx:total-hours-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1H') } ;                     (functx:total-hours-from-duration( xs:dayTimeDuration('PT1H30M'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-total-hours-from-duration-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The total number of hours in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-hours-from-duration.html : @param $duration the duration :)          declare function functx:total-hours-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1H') } ;                     (functx:total-hours-from-duration( xs:dayTimeDuration('-PT3H')))) = (-3). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-total-hours-from-duration-4,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The total number of hours in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-hours-from-duration.html : @param $duration the duration :)          declare function functx:total-hours-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1H') } ;                     (functx:total-hours-from-duration( xs:dayTimeDuration('P1D')))) = (24). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-total-hours-from-duration-5,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The total number of hours in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-hours-from-duration.html : @param $duration the duration :)          declare function functx:total-hours-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1H') } ;                     (functx:total-hours-from-duration( xs:dayTimeDuration('P1DT2H')))) = (26). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-total-hours-from-duration-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The total number of hours in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-hours-from-duration.html : @param $duration the duration :)          declare function functx:total-hours-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1H') } ;                     (functx:total-hours-from-duration( xs:dayTimeDuration('PT26H')), functx:total-hours-from-duration( xs:dayTimeDuration('PT1H30M')), functx:total-hours-from-duration( xs:dayTimeDuration('-PT3H')), functx:total-hours-from-duration( xs:dayTimeDuration('P1D')), functx:total-hours-from-duration( xs:dayTimeDuration('P1DT2H'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-total-minutes-from-duration-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The total number of minutes in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-minutes-from-duration.html : @param $duration the duration :)          declare function functx:total-minutes-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1M') } ;                     (functx:total-minutes-from-duration( xs:dayTimeDuration('PT90M')))) = (90). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-total-minutes-from-duration-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The total number of minutes in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-minutes-from-duration.html : @param $duration the duration :)          declare function functx:total-minutes-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1M') } ;                     (functx:total-minutes-from-duration( xs:dayTimeDuration('PT1H90M')))) = (150). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-total-minutes-from-duration-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The total number of minutes in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-minutes-from-duration.html : @param $duration the duration :)          declare function functx:total-minutes-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1M') } ;                     (functx:total-minutes-from-duration( xs:dayTimeDuration('PT3H')))) = (180). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-total-minutes-from-duration-4,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The total number of minutes in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-minutes-from-duration.html : @param $duration the duration :)          declare function functx:total-minutes-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1M') } ;                     (functx:total-minutes-from-duration( xs:dayTimeDuration('PT1M30S'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-total-minutes-from-duration-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The total number of minutes in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-minutes-from-duration.html : @param $duration the duration :)          declare function functx:total-minutes-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1M') } ;                     (functx:total-minutes-from-duration( xs:dayTimeDuration('PT90M')), functx:total-minutes-from-duration( xs:dayTimeDuration('PT1H90M')), functx:total-minutes-from-duration( xs:dayTimeDuration('PT3H')), functx:total-minutes-from-duration( xs:dayTimeDuration('PT1M30S'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-total-months-from-duration-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The total number of months in a yearMonthDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-months-from-duration.html : @param $duration the duration :)          declare function functx:total-months-from-duration ( $duration as xs:yearMonthDuration? ) as xs:decimal? { $duration div xs:yearMonthDuration('P1M') } ;                     (functx:total-months-from-duration( xs:yearMonthDuration('P18M')))) = (18). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-total-months-from-duration-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The total number of months in a yearMonthDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-months-from-duration.html : @param $duration the duration :)          declare function functx:total-months-from-duration ( $duration as xs:yearMonthDuration? ) as xs:decimal? { $duration div xs:yearMonthDuration('P1M') } ;                     (functx:total-months-from-duration( xs:yearMonthDuration('P1Y')))) = (12). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-total-months-from-duration-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The total number of months in a yearMonthDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-months-from-duration.html : @param $duration the duration :)          declare function functx:total-months-from-duration ( $duration as xs:yearMonthDuration? ) as xs:decimal? { $duration div xs:yearMonthDuration('P1M') } ;                     (functx:total-months-from-duration( xs:yearMonthDuration('P1Y6M')))) = (18). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-total-months-from-duration-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The total number of months in a yearMonthDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-months-from-duration.html : @param $duration the duration :)          declare function functx:total-months-from-duration ( $duration as xs:yearMonthDuration? ) as xs:decimal? { $duration div xs:yearMonthDuration('P1M') } ;                     (functx:total-months-from-duration( xs:yearMonthDuration('P18M')), functx:total-months-from-duration( xs:yearMonthDuration('P1Y')), functx:total-months-from-duration( xs:yearMonthDuration('P1Y6M'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-total-seconds-from-duration-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The total number of seconds in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-seconds-from-duration.html : @param $duration the duration :)          declare function functx:total-seconds-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1S') } ;                     (functx:total-seconds-from-duration( xs:dayTimeDuration('PT90S')))) = (90). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-total-seconds-from-duration-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The total number of seconds in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-seconds-from-duration.html : @param $duration the duration :)          declare function functx:total-seconds-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1S') } ;                     (functx:total-seconds-from-duration( xs:dayTimeDuration('PT90.5S'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-total-seconds-from-duration-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The total number of seconds in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-seconds-from-duration.html : @param $duration the duration :)          declare function functx:total-seconds-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1S') } ;                     (functx:total-seconds-from-duration( xs:dayTimeDuration('PT1M30S')))) = (90). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-total-seconds-from-duration-4,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The total number of seconds in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-seconds-from-duration.html : @param $duration the duration :)          declare function functx:total-seconds-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1S') } ;                     (functx:total-seconds-from-duration( xs:dayTimeDuration('PT3M')))) = (180). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-total-seconds-from-duration-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The total number of seconds in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-seconds-from-duration.html : @param $duration the duration :)          declare function functx:total-seconds-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1S') } ;                     (functx:total-seconds-from-duration( xs:dayTimeDuration('PT90S')), functx:total-seconds-from-duration( xs:dayTimeDuration('PT90.5S')), functx:total-seconds-from-duration( xs:dayTimeDuration('PT1M30S')), functx:total-seconds-from-duration( xs:dayTimeDuration('PT3M'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-total-years-from-duration-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The total number of years in a yearMonthDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-years-from-duration.html : @param $duration the duration :)          declare function functx:total-years-from-duration ( $duration as xs:yearMonthDuration? ) as xs:decimal? { $duration div xs:yearMonthDuration('P1Y') } ;                     (functx:total-years-from-duration( xs:yearMonthDuration('P18M'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-total-years-from-duration-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The total number of years in a yearMonthDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-years-from-duration.html : @param $duration the duration :)          declare function functx:total-years-from-duration ( $duration as xs:yearMonthDuration? ) as xs:decimal? { $duration div xs:yearMonthDuration('P1Y') } ;                     (functx:total-years-from-duration( xs:yearMonthDuration('P1Y')))) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-total-years-from-duration-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The total number of years in a yearMonthDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-years-from-duration.html : @param $duration the duration :)          declare function functx:total-years-from-duration ( $duration as xs:yearMonthDuration? ) as xs:decimal? { $duration div xs:yearMonthDuration('P1Y') } ;                     (functx:total-years-from-duration( xs:yearMonthDuration('P1Y6M'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-total-years-from-duration-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The total number of years in a yearMonthDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-years-from-duration.html : @param $duration the duration :)          declare function functx:total-years-from-duration ( $duration as xs:yearMonthDuration? ) as xs:decimal? { $duration div xs:yearMonthDuration('P1Y') } ;                     (functx:total-years-from-duration( xs:yearMonthDuration('P18M')), functx:total-years-from-duration( xs:yearMonthDuration('P1Y')), functx:total-years-from-duration( xs:yearMonthDuration('P1Y6M'))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-trim-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Trims leading and trailing whitespace : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_trim.html : @param $arg the string to trim :)          declare function functx:trim ( $arg as xs:string? ) as xs:string { replace(replace($arg,'\s+$',''),'^\s+','') } ;                     (functx:trim(' xyz ')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-trim-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Trims leading and trailing whitespace : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_trim.html : @param $arg the string to trim :)          declare function functx:trim ( $arg as xs:string? ) as xs:string { replace(replace($arg,'\s+$',''),'^\s+','') } ;                     (functx:trim(' xyz')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-trim-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Trims leading and trailing whitespace : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_trim.html : @param $arg the string to trim :)          declare function functx:trim ( $arg as xs:string? ) as xs:string { replace(replace($arg,'\s+$',''),'^\s+','') } ;                     (functx:trim('x   xyz ')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-trim-all,Error: XPST0003: Unable to parse XPath: deep-equal((declare namespace functx = "http://www.example.com/";                     (:~ : Trims leading and trailing whitespace : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_trim.html : @param $arg the string to trim :)          declare function functx:trim ( $arg as xs:string? ) as xs:string { replace(replace($arg,'\s+$',''),'^\s+','') } ;                     (functx:trim(' xyz '), functx:trim(' xyz'), functx:trim('x   xyz '))), ("xyz", "xyz",  "x   xyz")). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-update-attributes-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Updates the attribute value of an XML element : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_update-attributes.html : @param $elements the element(s) for which you wish to update the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return if ($element/@*[node-name(.) = $attrName]) then attribute {$attrName} {$attrValues[$seq]} else (), $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml xmlns:new='http://new'> <a att1='def'>x</a> <b>x</b> <c new:att1='def'>x</c> </in-xml> return (functx:update-attributes( $in-xml/a, xs:QName('att1'), 123)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-update-attributes-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Updates the attribute value of an XML element : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_update-attributes.html : @param $elements the element(s) for which you wish to update the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return if ($element/@*[node-name(.) = $attrName]) then attribute {$attrName} {$attrValues[$seq]} else (), $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml xmlns:new='http://new'> <a att1='def'>x</a> <b>x</b> <c new:att1='def'>x</c> </in-xml> return (functx:update-attributes( $in-xml/a, (xs:QName('att1'),xs:QName('att2')), (1,2))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-update-attributes-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Updates the attribute value of an XML element : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_update-attributes.html : @param $elements the element(s) for which you wish to update the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return if ($element/@*[node-name(.) = $attrName]) then attribute {$attrName} {$attrValues[$seq]} else (), $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml xmlns:new='http://new'> <a att1='def'>x</a> <b>x</b> <c new:att1='def'>x</c> </in-xml> return (functx:update-attributes( $in-xml/b, xs:QName('att1'), 123)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-update-attributes-4,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Updates the attribute value of an XML element : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_update-attributes.html : @param $elements the element(s) for which you wish to update the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return if ($element/@*[node-name(.) = $attrName]) then attribute {$attrName} {$attrValues[$seq]} else (), $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml xmlns:new='http://new'> <a att1='def'>x</a> <b>x</b> <c new:att1='def'>x</c> </in-xml> return (functx:update-attributes( $in-xml/c, QName('http://new','prefix:att1'), 123)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-update-attributes-all,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";                     (:~ : Updates the attribute value of an XML element : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_update-attributes.html : @param $elements the element(s) for which you wish to update the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return if ($element/@*[node-name(.) = $attrName]) then attribute {$attrName} {$attrValues[$seq]} else (), $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml xmlns:new='http://new'> <a att1='def'>x</a> <b>x</b> <c new:att1='def'>x</c> </in-xml> return (functx:update-attributes( $in-xml/a, xs:QName('att1'), 123), functx:update-attributes( $in-xml/a, (xs:QName('att1'),xs:QName('att2')), (1,2)), functx:update-attributes( $in-xml/b, xs:QName('att1'), 123), functx:update-attributes( $in-xml/c, QName('http://new','prefix:att1'), 123)). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-value-except-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The values in one sequence that aren't in another sequence : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_value-except.html : @param $arg1 the first sequence : @param $arg2 the second sequence :)          declare function functx:value-except ( $arg1 as xs:anyAtomicType* , $arg2 as xs:anyAtomicType* ) as xs:anyAtomicType* { distinct-values($arg1[not(.=$arg2)]) } ;                     (functx:value-except((1,2,3),(3,4,5))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-value-except-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The values in one sequence that aren't in another sequence : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_value-except.html : @param $arg1 the first sequence : @param $arg2 the second sequence :)          declare function functx:value-except ( $arg1 as xs:anyAtomicType* , $arg2 as xs:anyAtomicType* ) as xs:anyAtomicType* { distinct-values($arg1[not(.=$arg2)]) } ;                     (functx:value-except((1,1,2,3),(2,3)))) = (1). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-value-except-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The values in one sequence that aren't in another sequence : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_value-except.html : @param $arg1 the first sequence : @param $arg2 the second sequence :)          declare function functx:value-except ( $arg1 as xs:anyAtomicType* , $arg2 as xs:anyAtomicType* ) as xs:anyAtomicType* { distinct-values($arg1[not(.=$arg2)]) } ;                     (functx:value-except((1,2),(3,4))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-value-except-4,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The values in one sequence that aren't in another sequence : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_value-except.html : @param $arg1 the first sequence : @param $arg2 the second sequence :)          declare function functx:value-except ( $arg1 as xs:anyAtomicType* , $arg2 as xs:anyAtomicType* ) as xs:anyAtomicType* { distinct-values($arg1[not(.=$arg2)]) } ;                     (functx:value-except((1,2,2,3),())))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-value-except-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The values in one sequence that aren't in another sequence : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_value-except.html : @param $arg1 the first sequence : @param $arg2 the second sequence :)          declare function functx:value-except ( $arg1 as xs:anyAtomicType* , $arg2 as xs:anyAtomicType* ) as xs:anyAtomicType* { distinct-values($arg1[not(.=$arg2)]) } ;                     (functx:value-except((1,2,3),(3,4,5)), functx:value-except((1,1,2,3),(2,3)), functx:value-except((1,2),(3,4)), functx:value-except((1,2,2,3),())))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-value-intersect-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The intersection of two sequences of values : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_value-intersect.html : @param $arg1 the first sequence : @param $arg2 the second sequence :)          declare function functx:value-intersect ( $arg1 as xs:anyAtomicType* , $arg2 as xs:anyAtomicType* ) as xs:anyAtomicType* { distinct-values($arg1[.=$arg2]) } ;                     (functx:value-intersect((1,2),(2,3)))) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-value-intersect-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The intersection of two sequences of values : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_value-intersect.html : @param $arg1 the first sequence : @param $arg2 the second sequence :)          declare function functx:value-intersect ( $arg1 as xs:anyAtomicType* , $arg2 as xs:anyAtomicType* ) as xs:anyAtomicType* { distinct-values($arg1[.=$arg2]) } ;                     (functx:value-intersect((1,2,3),(2,3,4))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-value-intersect-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The intersection of two sequences of values : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_value-intersect.html : @param $arg1 the first sequence : @param $arg2 the second sequence :)          declare function functx:value-intersect ( $arg1 as xs:anyAtomicType* , $arg2 as xs:anyAtomicType* ) as xs:anyAtomicType* { distinct-values($arg1[.=$arg2]) } ;                     (functx:value-intersect((1,2,2,3),(2,3))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-value-intersect-4,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The intersection of two sequences of values : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_value-intersect.html : @param $arg1 the first sequence : @param $arg2 the second sequence :)          declare function functx:value-intersect ( $arg1 as xs:anyAtomicType* , $arg2 as xs:anyAtomicType* ) as xs:anyAtomicType* { distinct-values($arg1[.=$arg2]) } ;                     (functx:value-intersect((1,2,2,3),())))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-value-intersect-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The intersection of two sequences of values : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_value-intersect.html : @param $arg1 the first sequence : @param $arg2 the second sequence :)          declare function functx:value-intersect ( $arg1 as xs:anyAtomicType* , $arg2 as xs:anyAtomicType* ) as xs:anyAtomicType* { distinct-values($arg1[.=$arg2]) } ;                     (functx:value-intersect((1,2),(2,3)), functx:value-intersect((1,2,3),(2,3,4)), functx:value-intersect((1,2,2,3),(2,3)), functx:value-intersect((1,2,2,3),())))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-value-union-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The union of two sequences of values : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_value-union.html : @param $arg1 the first sequence : @param $arg2 the second sequence :)          declare function functx:value-union ( $arg1 as xs:anyAtomicType* , $arg2 as xs:anyAtomicType* ) as xs:anyAtomicType* { distinct-values(($arg1, $arg2)) } ;                     (functx:value-union((1,2),(3,4))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-value-union-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The union of two sequences of values : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_value-union.html : @param $arg1 the first sequence : @param $arg2 the second sequence :)          declare function functx:value-union ( $arg1 as xs:anyAtomicType* , $arg2 as xs:anyAtomicType* ) as xs:anyAtomicType* { distinct-values(($arg1, $arg2)) } ;                     (functx:value-union((1,2,3),(2,3,4))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-value-union-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The union of two sequences of values : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_value-union.html : @param $arg1 the first sequence : @param $arg2 the second sequence :)          declare function functx:value-union ( $arg1 as xs:anyAtomicType* , $arg2 as xs:anyAtomicType* ) as xs:anyAtomicType* { distinct-values(($arg1, $arg2)) } ;                     (functx:value-union((1,2,2,3),(3,4))))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-value-union-4,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The union of two sequences of values : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_value-union.html : @param $arg1 the first sequence : @param $arg2 the second sequence :)          declare function functx:value-union ( $arg1 as xs:anyAtomicType* , $arg2 as xs:anyAtomicType* ) as xs:anyAtomicType* { distinct-values(($arg1, $arg2)) } ;                     (functx:value-union((1,2,2,3),())))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-value-union-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The union of two sequences of values : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_value-union.html : @param $arg1 the first sequence : @param $arg2 the second sequence :)          declare function functx:value-union ( $arg1 as xs:anyAtomicType* , $arg2 as xs:anyAtomicType* ) as xs:anyAtomicType* { distinct-values(($arg1, $arg2)) } ;                     (functx:value-union((1,2),(3,4)), functx:value-union((1,2,3),(2,3,4)), functx:value-union((1,2,2,3),(3,4)), functx:value-union((1,2,2,3),())))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-word-count-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The number of words : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_word-count.html : @param $arg the string to measure :)          declare function functx:word-count ( $arg as xs:string? ) as xs:integer { count(tokenize($arg, '\W+')[. != '']) } ;                     (functx:word-count('hello there world'))) = (3). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-word-count-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The number of words : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_word-count.html : @param $arg the string to measure :)          declare function functx:word-count ( $arg as xs:string? ) as xs:integer { count(tokenize($arg, '\W+')[. != '']) } ;                     (functx:word-count(' hello world '))) = (2). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-word-count-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The number of words : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_word-count.html : @param $arg the string to measure :)          declare function functx:word-count ( $arg as xs:string? ) as xs:integer { count(tokenize($arg, '\W+')[. != '']) } ;                     (functx:word-count('a.b.c'))) = (3). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-word-count-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The number of words : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_word-count.html : @param $arg the string to measure :)          declare function functx:word-count ( $arg as xs:string? ) as xs:integer { count(tokenize($arg, '\W+')[. != '']) } ;                     (functx:word-count('hello there world'), functx:word-count(' hello world '), functx:word-count('a.b.c')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-words-to-camel-case-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Capitalizes the first character of a string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_capitalize-first.html : @param $arg the word or phrase to capitalize :)          declare function functx:capitalize-first ( $arg as xs:string? ) as xs:string? { concat(upper-case(substring($arg,1,1)), substring($arg,2)) } ;                     (:~ : Turns a string of words into camelCase : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_words-to-camel-case.html : @param $arg the string to modify :)          declare function functx:words-to-camel-case ( $arg as xs:string? ) as xs:string { string-join((tokenize($arg,'\s+')[1], for $word in tokenize($arg,'\s+')[position() >                     1] return functx:capitalize-first($word)) ,'') } ;                     (functx:words-to-camel-case('this Is A Term')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-words-to-camel-case-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Capitalizes the first character of a string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_capitalize-first.html : @param $arg the word or phrase to capitalize :)          declare function functx:capitalize-first ( $arg as xs:string? ) as xs:string? { concat(upper-case(substring($arg,1,1)), substring($arg,2)) } ;                     (:~ : Turns a string of words into camelCase : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_words-to-camel-case.html : @param $arg the string to modify :)          declare function functx:words-to-camel-case ( $arg as xs:string? ) as xs:string { string-join((tokenize($arg,'\s+')[1], for $word in tokenize($arg,'\s+')[position() >                     1] return functx:capitalize-first($word)) ,'') } ;                     (functx:words-to-camel-case( 'This is a term')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-words-to-camel-case-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Capitalizes the first character of a string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_capitalize-first.html : @param $arg the word or phrase to capitalize :)          declare function functx:capitalize-first ( $arg as xs:string? ) as xs:string? { concat(upper-case(substring($arg,1,1)), substring($arg,2)) } ;                     (:~ : Turns a string of words into camelCase : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_words-to-camel-case.html : @param $arg the string to modify :)          declare function functx:words-to-camel-case ( $arg as xs:string? ) as xs:string { string-join((tokenize($arg,'\s+')[1], for $word in tokenize($arg,'\s+')[position() >                     1] return functx:capitalize-first($word)) ,'') } ;                     (functx:words-to-camel-case('this Is A Term'), functx:words-to-camel-case( 'This is a term')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-wrap-values-in-elements-1,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";          declare namespace new = "http://newns";                     (:~ : Wraps a sequence of atomic values in XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_wrap-values-in-elements.html : @param $values the values to wrap in elements : @param $elementName the name of the elements to construct :)          declare function functx:wrap-values-in-elements ( $values as xs:anyAtomicType* , $elementName as xs:QName ) as element()* { for $value in $values return element {$elementName} {$value} } ;                     (functx:wrap-values-in-elements( (1,2,3), xs:QName('num'))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-wrap-values-in-elements-2,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";          declare namespace new = "http://newns";                     (:~ : Wraps a sequence of atomic values in XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_wrap-values-in-elements.html : @param $values the values to wrap in elements : @param $elementName the name of the elements to construct :)          declare function functx:wrap-values-in-elements ( $values as xs:anyAtomicType* , $elementName as xs:QName ) as element()* { for $value in $values return element {$elementName} {$value} } ;                     (functx:wrap-values-in-elements( (1,2,3), xs:QName('new:num'))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-wrap-values-in-elements-3,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";          declare namespace new = "http://newns";                     (:~ : Wraps a sequence of atomic values in XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_wrap-values-in-elements.html : @param $values the values to wrap in elements : @param $elementName the name of the elements to construct :)          declare function functx:wrap-values-in-elements ( $values as xs:anyAtomicType* , $elementName as xs:QName ) as element()* { for $value in $values return element {$elementName} {$value} } ;                     (functx:wrap-values-in-elements( (1,2,3), QName('http://newns','num'))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-wrap-values-in-elements-4,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";          declare namespace new = "http://newns";                     (:~ : Wraps a sequence of atomic values in XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_wrap-values-in-elements.html : @param $values the values to wrap in elements : @param $elementName the name of the elements to construct :)          declare function functx:wrap-values-in-elements ( $values as xs:anyAtomicType* , $elementName as xs:QName ) as element()* { for $value in $values return element {$elementName} {$value} } ;                     (functx:wrap-values-in-elements( (1,2,3), QName('http://newns','new:num'))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-wrap-values-in-elements-all,Error: XPST0003: Unable to parse XPath: declare namespace functx = "http://www.example.com/";          declare namespace new = "http://newns";                     (:~ : Wraps a sequence of atomic values in XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_wrap-values-in-elements.html : @param $values the values to wrap in elements : @param $elementName the name of the elements to construct :)          declare function functx:wrap-values-in-elements ( $values as xs:anyAtomicType* , $elementName as xs:QName ) as element()* { for $value in $values return element {$elementName} {$value} } ;                     (functx:wrap-values-in-elements( (1,2,3), xs:QName('num')), functx:wrap-values-in-elements( (1,2,3), xs:QName('new:num')), functx:wrap-values-in-elements( (1,2,3), QName('http://newns','num')), functx:wrap-values-in-elements( (1,2,3), QName('http://newns','new:num'))). SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
functx-functx-yearMonthDuration-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (:~ : Construct a yearMonthDuration from a number of years and months : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_yearmonthduration.html : @param $years the number of years : @param $months the number of months :)          declare function functx:yearMonthDuration ( $years as xs:decimal? , $months as xs:integer? ) as xs:yearMonthDuration { (xs:yearMonthDuration('P1M') * functx:if-empty($months,0)) + (xs:yearMonthDuration('P1Y') * functx:if-empty($years,0)) } ;                     (functx:yearMonthDuration(1,6)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-yearMonthDuration-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (:~ : Construct a yearMonthDuration from a number of years and months : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_yearmonthduration.html : @param $years the number of years : @param $months the number of months :)          declare function functx:yearMonthDuration ( $years as xs:decimal? , $months as xs:integer? ) as xs:yearMonthDuration { (xs:yearMonthDuration('P1M') * functx:if-empty($months,0)) + (xs:yearMonthDuration('P1Y') * functx:if-empty($years,0)) } ;                     (functx:yearMonthDuration(1.5,0)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-yearMonthDuration-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (:~ : Construct a yearMonthDuration from a number of years and months : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_yearmonthduration.html : @param $years the number of years : @param $months the number of months :)          declare function functx:yearMonthDuration ( $years as xs:decimal? , $months as xs:integer? ) as xs:yearMonthDuration { (xs:yearMonthDuration('P1M') * functx:if-empty($months,0)) + (xs:yearMonthDuration('P1Y') * functx:if-empty($years,0)) } ;                     (functx:yearMonthDuration(1,())))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-yearMonthDuration-4,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (:~ : Construct a yearMonthDuration from a number of years and months : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_yearmonthduration.html : @param $years the number of years : @param $months the number of months :)          declare function functx:yearMonthDuration ( $years as xs:decimal? , $months as xs:integer? ) as xs:yearMonthDuration { (xs:yearMonthDuration('P1M') * functx:if-empty($months,0)) + (xs:yearMonthDuration('P1Y') * functx:if-empty($years,0)) } ;                     (functx:yearMonthDuration(1,0)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-yearMonthDuration-5,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (:~ : Construct a yearMonthDuration from a number of years and months : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_yearmonthduration.html : @param $years the number of years : @param $months the number of months :)          declare function functx:yearMonthDuration ( $years as xs:decimal? , $months as xs:integer? ) as xs:yearMonthDuration { (xs:yearMonthDuration('P1M') * functx:if-empty($months,0)) + (xs:yearMonthDuration('P1Y') * functx:if-empty($years,0)) } ;                     (functx:yearMonthDuration(-1,-3)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-yearMonthDuration-6,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (:~ : Construct a yearMonthDuration from a number of years and months : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_yearmonthduration.html : @param $years the number of years : @param $months the number of months :)          declare function functx:yearMonthDuration ( $years as xs:decimal? , $months as xs:integer? ) as xs:yearMonthDuration { (xs:yearMonthDuration('P1M') * functx:if-empty($months,0)) + (xs:yearMonthDuration('P1Y') * functx:if-empty($years,0)) } ;                     (functx:yearMonthDuration(-1,3)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-yearMonthDuration-7,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (:~ : Construct a yearMonthDuration from a number of years and months : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_yearmonthduration.html : @param $years the number of years : @param $months the number of months :)          declare function functx:yearMonthDuration ( $years as xs:decimal? , $months as xs:integer? ) as xs:yearMonthDuration { (xs:yearMonthDuration('P1M') * functx:if-empty($months,0)) + (xs:yearMonthDuration('P1Y') * functx:if-empty($years,0)) } ;                     (functx:yearMonthDuration(0,0)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-yearMonthDuration-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (:~ : Construct a yearMonthDuration from a number of years and months : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_yearmonthduration.html : @param $years the number of years : @param $months the number of months :)          declare function functx:yearMonthDuration ( $years as xs:decimal? , $months as xs:integer? ) as xs:yearMonthDuration { (xs:yearMonthDuration('P1M') * functx:if-empty($months,0)) + (xs:yearMonthDuration('P1Y') * functx:if-empty($years,0)) } ;                     (functx:yearMonthDuration(1,6), functx:yearMonthDuration(1.5,0), functx:yearMonthDuration(1,()), functx:yearMonthDuration(1,0), functx:yearMonthDuration(-1,-3), functx:yearMonthDuration(-1,3), functx:yearMonthDuration(0,0)))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-yyyyddmm-to-date-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Converts a string with format YYYYDDMM (with any delimiters) to a date : : @author Priscilla Walmsley, Datypic : @version 1.1 : @see http://www.xqueryfunctions.com/xq/functx_yyyyddmm-to-date.html : @param $dateString the YYYYDDMM string :)          declare function functx:yyyyddmm-to-date ( $dateString as xs:string? ) as xs:date? { if (empty($dateString)) then () else if (not(matches($dateString, '^\D*(\d{4})\D*(\d{2})\D*(\d{2})\D*$'))) then error(xs:QName('functx:Invalid_Date_Format')) else xs:date(replace($dateString, '^\D*(\d{4})\D*(\d{2})\D*(\d{2})\D*$', '$1-$3-$2')) } ;                     (functx:yyyyddmm-to-date('2004-15-12')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-yyyyddmm-to-date-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Converts a string with format YYYYDDMM (with any delimiters) to a date : : @author Priscilla Walmsley, Datypic : @version 1.1 : @see http://www.xqueryfunctions.com/xq/functx_yyyyddmm-to-date.html : @param $dateString the YYYYDDMM string :)          declare function functx:yyyyddmm-to-date ( $dateString as xs:string? ) as xs:date? { if (empty($dateString)) then () else if (not(matches($dateString, '^\D*(\d{4})\D*(\d{2})\D*(\d{2})\D*$'))) then error(xs:QName('functx:Invalid_Date_Format')) else xs:date(replace($dateString, '^\D*(\d{4})\D*(\d{2})\D*(\d{2})\D*$', '$1-$3-$2')) } ;                     (functx:yyyyddmm-to-date('20041512')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-yyyyddmm-to-date-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Converts a string with format YYYYDDMM (with any delimiters) to a date : : @author Priscilla Walmsley, Datypic : @version 1.1 : @see http://www.xqueryfunctions.com/xq/functx_yyyyddmm-to-date.html : @param $dateString the YYYYDDMM string :)          declare function functx:yyyyddmm-to-date ( $dateString as xs:string? ) as xs:date? { if (empty($dateString)) then () else if (not(matches($dateString, '^\D*(\d{4})\D*(\d{2})\D*(\d{2})\D*$'))) then error(xs:QName('functx:Invalid_Date_Format')) else xs:date(replace($dateString, '^\D*(\d{4})\D*(\d{2})\D*(\d{2})\D*$', '$1-$3-$2')) } ;                     (functx:yyyyddmm-to-date('2004/15/12')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-yyyyddmm-to-date-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Converts a string with format YYYYDDMM (with any delimiters) to a date : : @author Priscilla Walmsley, Datypic : @version 1.1 : @see http://www.xqueryfunctions.com/xq/functx_yyyyddmm-to-date.html : @param $dateString the YYYYDDMM string :)          declare function functx:yyyyddmm-to-date ( $dateString as xs:string? ) as xs:date? { if (empty($dateString)) then () else if (not(matches($dateString, '^\D*(\d{4})\D*(\d{2})\D*(\d{2})\D*$'))) then error(xs:QName('functx:Invalid_Date_Format')) else xs:date(replace($dateString, '^\D*(\d{4})\D*(\d{2})\D*(\d{2})\D*$', '$1-$3-$2')) } ;                     (functx:yyyyddmm-to-date('2004-15-12'), functx:yyyyddmm-to-date('20041512'), functx:yyyyddmm-to-date('2004/15/12')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-yyyymmdd-to-date-1,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Converts a string with format YYYYMMDD (with any delimiters) to a date : : @author Priscilla Walmsley, Datypic : @version 1.1 : @see http://www.xqueryfunctions.com/xq/functx_yyyymmdd-to-date.html : @param $dateString the YYYYMMDD string :)          declare function functx:yyyymmdd-to-date ( $dateString as xs:string? ) as xs:date? { if (empty($dateString)) then () else if (not(matches($dateString, '^\D*(\d{4})\D*(\d{2})\D*(\d{2})\D*$'))) then error(xs:QName('functx:Invalid_Date_Format')) else xs:date(replace($dateString, '^\D*(\d{4})\D*(\d{2})\D*(\d{2})\D*$', '$1-$2-$3')) } ;                     (functx:yyyymmdd-to-date('2004-12-15')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-yyyymmdd-to-date-2,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Converts a string with format YYYYMMDD (with any delimiters) to a date : : @author Priscilla Walmsley, Datypic : @version 1.1 : @see http://www.xqueryfunctions.com/xq/functx_yyyymmdd-to-date.html : @param $dateString the YYYYMMDD string :)          declare function functx:yyyymmdd-to-date ( $dateString as xs:string? ) as xs:date? { if (empty($dateString)) then () else if (not(matches($dateString, '^\D*(\d{4})\D*(\d{2})\D*(\d{2})\D*$'))) then error(xs:QName('functx:Invalid_Date_Format')) else xs:date(replace($dateString, '^\D*(\d{4})\D*(\d{2})\D*(\d{2})\D*$', '$1-$2-$3')) } ;                     (functx:yyyymmdd-to-date('20041215')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-yyyymmdd-to-date-3,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Converts a string with format YYYYMMDD (with any delimiters) to a date : : @author Priscilla Walmsley, Datypic : @version 1.1 : @see http://www.xqueryfunctions.com/xq/functx_yyyymmdd-to-date.html : @param $dateString the YYYYMMDD string :)          declare function functx:yyyymmdd-to-date ( $dateString as xs:string? ) as xs:date? { if (empty($dateString)) then () else if (not(matches($dateString, '^\D*(\d{4})\D*(\d{2})\D*(\d{2})\D*$'))) then error(xs:QName('functx:Invalid_Date_Format')) else xs:date(replace($dateString, '^\D*(\d{4})\D*(\d{2})\D*(\d{2})\D*$', '$1-$2-$3')) } ;                     (functx:yyyymmdd-to-date('2004/12/15')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
functx-functx-yyyymmdd-to-date-all,Error: XPST0003: Unable to parse XPath: (declare namespace functx = "http://www.example.com/";                     (:~ : Converts a string with format YYYYMMDD (with any delimiters) to a date : : @author Priscilla Walmsley, Datypic : @version 1.1 : @see http://www.xqueryfunctions.com/xq/functx_yyyymmdd-to-date.html : @param $dateString the YYYYMMDD string :)          declare function functx:yyyymmdd-to-date ( $dateString as xs:string? ) as xs:date? { if (empty($dateString)) then () else if (not(matches($dateString, '^\D*(\d{4})\D*(\d{2})\D*(\d{2})\D*$'))) then error(xs:QName('functx:Invalid_Date_Format')) else xs:date(replace($dateString, '^\D*(\d{4})\D*(\d{2})\D*(\d{2})\D*$', '$1-$2-$3')) } ;                     (functx:yyyymmdd-to-date('2004-12-15'), functx:yyyymmdd-to-date('20041215'), functx:yyyymmdd-to-date('2004/12/15')))!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", or "||" but "n" found.
ns-queries-results-q1,AssertionError: Skipped test, it was a assert-permutation
ns-queries-results-q2,Error: XPST0003: Unable to parse XPath:          declare namespace music = "http://www.example.org/music/records";          <Q2> { //music:title } </Q2>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
ns-queries-results-q3,Error: XPST0003: Unable to parse XPath:          declare namespace dt = "http://www.w3.org/2001/XMLSchema";          <Q3> { //*[@dt:*] } </Q3>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
ns-queries-results-q4,Error: XPST0003: Unable to parse XPath:          declare namespace xlink = "http://www.w3.org/1999/xlink";          <Q4 xmlns:xlink="http://www.w3.org/1999/xlink"> { for $hr in //@xlink:href return <ns>{ $hr }</ns> } </Q4>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
ns-queries-results-q5,Error: XPST0003: Unable to parse XPath:          declare namespace music = "http://www.example.org/music/records";          <Q5 xmlns:music="http://www.example.org/music/records"> { //music:record[music:remark/@xml:lang = "de"] } </Q5>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
ns-queries-results-q6,Error: XPST0003: Unable to parse XPath:          declare namespace ma = "http://www.example.com/AuctionWatch";          declare namespace anyzone = "http://www.example.com/auctioneers#anyzone";          <Q6 xmlns:ma="http://www.example.com/AuctionWatch"> { //ma:Auction[@anyzone:ID]/ma:Schedule/ma:Close } </Q6>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
ns-queries-results-q7,Error: XPST0003: Unable to parse XPath:          declare namespace ma = "http://www.example.com/AuctionWatch";          <Q7 xmlns:xlink="http://www.w3.org/1999/xlink"> {              for $a in //ma:Auction              let $seller_id := $a/ma:Trading_Partners/ma:Seller/*:ID,                  $buyer_id := $a/ma:Trading_Partners/ma:High_Bidder/*:ID              where namespace-uri(exactly-one($seller_id)) = namespace-uri($buyer_id)              return $a/ma:AuctionHomepage } </Q7>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
ns-queries-results-q8,Error: XPST0003: Unable to parse XPath:          declare namespace ma = "http://www.example.com/AuctionWatch";          <Q8 xmlns:ma="http://www.example.com/AuctionWatch"              xmlns:eachbay="http://www.example.com/auctioneers#eachbay"              xmlns:xlink="http://www.w3.org/1999/xlink"> {                  for $s in //ma:Trading_Partners/(ma:Seller | ma:High_Bidder)                  where $s/*:NegativeComments = 0                  return $s } </Q8>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
parts-queries-results-q1,AssertionError: Expected executing the XPath "         declare variable $input-context := .;         declare function local:one_level($p as element()) as element() {              <part partid="{ $p/@partid }" name="{ $p/@name }" > {                  for $s in ($input-context//part)                 where $s/@partof = $p/@partid                  return local:one_level($s) } </part> };          <parttree> { for $p in //part[empty(@partof)]                       return local:one_level($p) } </parttree>       " to resolve to one of the expected results, but got Error: XPST0003: Unable to parse XPath:          declare variable $input-context := .;         declare function local:one_level($p as element()) as element() {              <part partid="{ $p/@partid }" name="{ $p/@name }" > {                  for $s in ($input-context//part)                 where $s/@partof = $p/@partid                  return local:one_level($s) } </part> };          <parttree> { for $p in //part[empty(@partof)]                       return local:one_level($p) } </parttree>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found., AssertionError: expected [Function] to throw error including 'XPTY0004' but got 'XPST0003: Unable to parse XPath: \n        declare variable $input-context := .;\n        declare function local:one_level($p as element()) as element() { \n            <part partid="{ $p/@partid }" name="{ $p/@name }" > { \n                for $s in ($input-context//part)\n                where $s/@partof = $p/@partid \n                return local:one_level($s) } </part> }; \n        <parttree> { for $p in //part[empty(@partof)] \n                     return local:one_level($p) } </parttree>\n      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\\n", "\\r", "\\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.'.
rdb-queries-results-q1,Error: XPST0003: Unable to parse XPath:          <result> {              for $i in $items//item_tuple              where $i/start_date <= xs:date("1999-01-31")                  and $i/end_date >= xs:date("1999-01-31")                  and contains(exactly-one($i/description), "Bicycle")              order by $i/itemno              return <item_tuple> { $i/itemno } { $i/description } </item_tuple> }          </result>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.
rdb-queries-results-q2,Error: XPST0003: Unable to parse XPath:          <result> {              for $i in $items//item_tuple              let $b := $bids//bid_tuple[itemno = $i/itemno]              where contains(exactly-one($i/description), "Bicycle")              order by $i/itemno              return <item_tuple> { $i/itemno } { $i/description } <high_bid>{ max($b/bid) }</high_bid> </item_tuple> }          </result>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
rdb-queries-results-q3,Error: XPST0003: Unable to parse XPath:          <result> {              for $u in $users//user_tuple              for $i in $items//item_tuple              where $u/rating > "C" and $i/reserve_price > 1000 and $i/offered_by = $u/userid              return <warning> { $u/name } { $u/rating } { $i/description } { $i/reserve_price } </warning> }          </result>      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found.
rdb-queries-results-q4,Error: XPST0003: Unable to parse XPath:          <result> {              for $i in $items//item_tuple              where empty ($bids//bid_tuple[itemno = $i/itemno])              return <no_bid_item> { $i/itemno } { $i/description } </no_bid_item>          } </result>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.
rdb-queries-results-q5,Error: XPST0003: Unable to parse XPath:          <result> {              unordered (                  for $seller in $users//user_tuple,                      $buyer in $users//user_tuple,                      $item in $items//item_tuple,                      $highbid in $bids//bid_tuple                  where $seller/name = "Tom Jones"                    and $seller/userid = $item/offered_by                    and contains(exactly-one($item/description), "Bicycle")                    and $item/itemno = $highbid/itemno                    and $highbid/userid = $buyer/userid                    and $highbid/bid = max( $bids//bid_tuple [itemno = $item/itemno]/bid )                  return <jones_bike> { $item/itemno } { $item/description }                          <high_bid>{ $highbid/bid }</high_bid>                          <high_bidder>{ $buyer/name }</high_bidder>                         </jones_bike> )          } </result>      . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.
rdb-queries-results-q6,Error: XPST0003: Unable to parse XPath:          <result> {              for $item in $items//item_tuple              let $b := $bids//bid_tuple[itemno = $item/itemno]              let $z := max($b/bid)              where exactly-one($item/reserve_price) * 2 < $z              return <successful_item> { $item/itemno } { $item/description } { $item/reserve_price }                      <high_bid>{$z }</high_bid>                     </successful_item>          } </result>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
rdb-queries-results-q7,Error: XPST0003: Unable to parse XPath:          let $allbikes := $items//item_tuple [contains(exactly-one(description), "Bicycle") or contains(exactly-one(description), "Tricycle")]          let $bikebids := $bids//bid_tuple[itemno = $allbikes/itemno]          return <high_bid> { max($bikebids/bid) } </high_bid>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "[" found.
rdb-queries-results-q8,Error: XPST0003: Unable to parse XPath:          let $item := $items//item_tuple [end_date >= xs:date("1999-03-01") and end_date <= xs:date("1999-03-31")]              return <item_count> { count($item) } </item_count>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "[" found.
rdb-queries-results-q9,Error: XPST0003: Unable to parse XPath:          <result> {              let $end_dates := $items//item_tuple/end_date              for $m in distinct-values(                         for $e in $end_dates                          return month-from-date($e))              let $item := $items//item_tuple[year-from-date(exactly-one(end_date)) = 1999 and month-from-date(exactly-one(end_date)) = $m]              order by $m              return <monthly_result>                      <month>{ $m }</month>                      <item_count>{ count($item) }</item_count>                    </monthly_result>          } </result>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found.
rdb-queries-results-q10,Error: XPST0003: Unable to parse XPath:          <result> {              for $highbid in $bids//bid_tuple,                  $user in $users//user_tuple              where $user/userid = $highbid/userid and $highbid/bid = max($bids//bid_tuple[itemno=$highbid/itemno]/bid)              order by exactly-one($highbid/itemno)              return <high_bid> { $highbid/itemno } { $highbid/bid }                       <bidder>{ $user/name/text() }</bidder>                     </high_bid>          } </result>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.
rdb-queries-results-q11,Error: XPST0003: Unable to parse XPath:          let $highbid := max($bids//bid_tuple/bid)          return <result> { for $item in $items//item_tuple,                                $b in $bids//bid_tuple[itemno = $item/itemno]                            where $b/bid = $highbid                            return <expensive_item> { $item/itemno } { $item/description }                                      <high_bid>{ $highbid }</high_bid>                                   </expensive_item>                 } </result>       . SyntaxError: Expected " ", "!", "!=", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.
rdb-queries-results-q12,Error: XPST0003: Unable to parse XPath:          declare function local:bid_summary() as element()* {              for $i in distinct-values($bids//itemno)              let $b := $bids//bid_tuple[itemno = $i]              return <bid_count>                          <itemno>{ $i }</itemno>                          <nbids>{ count($b) }</nbids>                     </bid_count> };         <result> {              let $bid_counts := local:bid_summary(),                  $maxbids := max($bid_counts/nbids),                  $maxitemnos := $bid_counts[nbids = $maxbids]                  for $item in $items//item_tuple,                      $bc in $bid_counts                  where $bc/nbids = $maxbids and $item/itemno = $bc/itemno                  return <popular_item> { $item/itemno } { $item/description }                          <bid_count>{ $bc/nbids/text() }</bid_count>                         </popular_item>          } </result>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
rdb-queries-results-q13,Error: XPST0003: Unable to parse XPath:          <result> {              for $uid in distinct-values($bids//userid),                  $u in $users//user_tuple[userid = $uid]              let $b := $bids//bid_tuple[userid = $uid]              order by exactly-one($u/userid)              return <bidder> { $u/userid } { $u/name } <bidcount>{ count($b) }</bidcount> <avgbid>{ avg($b/bid) }</avgbid> </bidder>          } </result>       . SyntaxError: Expected " ", "!", "!=", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
rdb-queries-results-q14,Error: XPST0003: Unable to parse XPath:          <result> {              for $i in distinct-values($items//itemno)              let $b := $bids//bid_tuple[itemno = $i]              let $avgbid := avg($b/bid)              where count($b) >= 3              order by $avgbid descending              return <popular_item> <itemno>{ $i }</itemno> <avgbid>{ $avgbid }</avgbid> </popular_item>          } </result>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
rdb-queries-results-q15,Error: XPST0003: Unable to parse XPath:          <result> {              for $u in $users//user_tuple              let $b := $bids//bid_tuple[userid=$u/userid and bid>=100]              where count($b) > 1              return <big_spender>{ $u/name/text() }</big_spender>          } </result>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
rdb-queries-results-q16,Error: XPST0003: Unable to parse XPath:          <result> {              for $u in $users//user_tuple              let $b := $bids//bid_tuple[userid = $u/userid]              order by exactly-one($u/userid)              return <user> { $u/userid } { $u/name } {                  if (empty($b))                  then <status>inactive</status>                  else <status>active</status> } </user>          } </result>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
rdb-queries-results-q17,Error: XPST0003: Unable to parse XPath:          <frequent_bidder> {              for $u in $users//user_tuple              where every $item in $items//item_tuple                    satisfies some $b in $bids//bid_tuple                              satisfies ($item/itemno = $b/itemno and $u/userid = $b/userid)              return $u/name          } </frequent_bidder>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.
rdb-queries-results-q18,Error: XPST0003: Unable to parse XPath:          <result> {              for $u in $users//user_tuple              order by $u/name              return <user> { $u/name } {                  for $b in distinct-values($bids//bid_tuple [userid = $u/userid]/itemno)                  for $i in $items//item_tuple[itemno = $b]                  let $descr := $i/description/text()                  order by exactly-one($descr)                  return <bid_on_item>{ $descr }</bid_on_item> } </user>          } </result>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "return", "to", "union", "|", or "||" but "o" found.
seq-queries-results-q3,Error: XPST0003: Unable to parse XPath: let $i2 := (//incision)[2] for $a in (//action)[. >> $i2][position()<=2] return $a//instrument. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found.
seq-queries-results-q4,Error: XPST0003: Unable to parse XPath: (for $p in //section[section.title = "Procedure"] where not(some $a in $p//anesthesia satisfies $a << ($p//incision)[1] ) return $p)!string() => string-join(" "). SyntaxError: Expected " ", "!", "!=", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.
seq-queries-results-q5,Error: XPST0003: Unable to parse XPath: <critical_sequence> { let $proc := //section[section.title="Procedure"][1], $i1 := ($proc//incision)[1], $i2 := ($proc//incision)[2] for $n in $proc//node() except $i1//node() where $n >> $i1 and $n << $i2 return $n } </critical_sequence>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found.
sgml-queries-results-q3,Error: XPST0003: Unable to parse XPath: <result> { for $c in //chapter where empty($c/intro) return $c/section/intro/para } </result>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.
sgml-queries-results-q7,Error: XPST0017: Function substring with arity of 3 not registered. Did you mean "xs:string (xs:anyAtomicType?)", "string (item()?)" or "string ()"?
sgml-queries-results-q10,Error: XPST0003: Unable to parse XPath: <result> { let $x := //xref[@xrefid = "top4"], $t := //title[. << exactly-one($x)] return $t[last()] } </result>. SyntaxError: Expected [A-Z_a-z----------] or [-] but " " found.
string-queries-results-q2,Error: XPST0003: Unable to parse XPath:          declare variable $input-context1 := $string;         declare variable $input-context2 := $company-data;          declare function local:partners($company as xs:string) as element()*         {             let $c := $input-context2//company[name = $company]             return $c//partner         };          let $foobar_partners := local:partners("Foobar Corporation")          for $item in $input-context1//news_item         where           some $t in $item//title satisfies             (contains(exactly-one($t/text()), "Foobar Corporation")             and (some $partner in $foobar_partners satisfies               contains(exactly-one($t/text()), $partner/text())))           or (some $par in $item//par satisfies            (contains(string($par), "Foobar Corporation")              and (some $partner in $foobar_partners satisfies                 contains(string($par), $partner/text()))))         return             <news_item>                 { $item/title }                 { $item/date }             </news_item>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "v" found.
string-queries-results-q4,Error: XPST0003: Unable to parse XPath:          declare function local:partners($c as xs:string) as element()* {              let $c := $company-data//company[name = $c]              return $c//partner          };          for $item in $string//news_item,              $c in $company-data//company          let $partners := local:partners(exactly-one($c/name))          where contains(string($item), $c/name)            and (some $p in $partners satisfies contains(string($item), $p) and $item/news_agent != $c/name)          return $item. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
string-queries-results-q5,Error: XPST0003: Unable to parse XPath:          for $item in //news_item          where contains(string(exactly-one($item/content)), "Gorilla Corporation")          return <item_summary> { concat($item/title,". ") }                                { concat($item/date,". ") }                                { string(($item//par)[1]) }                 </item_summary>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.
tree-queries-results-q1,Error: XPST0003: Unable to parse XPath:          declare function local:toc($book-or-section as element()) as element()* {              for $section in $book-or-section/section              return <section> { $section/@* , $section/title , local:toc($section) } </section> };         <toc> { for $s in /book return local:toc($s) } </toc>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
tree-queries-results-q5,Error: XPST0003: Unable to parse XPath: <section_list> { for $s in //section let $f := $s/figure return <section title="{ $s/title/text() }" figcount="{ count($f) }"/> } </section_list>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
tree-queries-results-q6,Error: XPST0003: Unable to parse XPath:          declare function local:section-summary($book-or-section as element()*) as element()* {              for $section in $book-or-section              return <section> { $section/@* } { $section/title } <figcount> { count($section/figure) } </figcount> { local:section-summary($section/section) } </section>          };          <toc> {              for $s in /book/section              return local:section-summary($s)          } </toc>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "f" found.
xmp-queries-results-q1,Error: XPST0003: Unable to parse XPath:        	<bib> {        		for $b in /bib/book        		where $b/publisher = "Addison-Wesley" and $b/@year > 1991        		return <book year="{ $b/@year }">{ $b/title }</book> }        	</bib>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.
xmp-queries-results-q4,Error: XPST0003: Unable to parse XPath:        	<results> {        		let $a := //author        		for $last in distinct-values($a/last), $first in distinct-values($a[last=$last]/first)        		order by $last, $first        		return <result>        				<author> <last>{ $last }</last> <first>{ $first }</first> </author>        				{ for $b in /bib/book        					where some $ba in $b/author satisfies ($ba/last = $last and $ba/first=$first)        					return $b/title }        			   </result> }        	</results>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found.
xmp-queries-results-q5,Error: XPST0003: Unable to parse XPath: <books-with-prices> {          for $b in $bib//book, $a in $reviews//entry          where $b/title = $a/title          return <book-with-prices> { $b/title } <price-bstore2>{ $a/price/text() }</price-bstore2> <price-bstore1>{ $b/price/text() }</price-bstore1> </book-with-prices> } </books-with-prices>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.
xmp-queries-results-q6,Error: XPST0003: Unable to parse XPath:        	<bib> {        		for $b in //book        		where count($b/author) > 0        		return <book>        			{ $b/title }        			{ for $a in $b/author[position()<=2] return $a }        			{ if (count($b/author) > 2) then <et-al/> else () }        			</book> }        	</bib>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.
xmp-queries-results-q7,Error: XPST0003: Unable to parse XPath:        	<bib> {        		for $b in //book        		where $b/publisher = "Addison-Wesley" and $b/@year > 1991        		order by exactly-one($b/title)        		return <book> { $b/@year } { $b/title } </book> }        	</bib>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.
xmp-queries-results-q8,Error: XPST0003: Unable to parse XPath:        	for $b in //book        	let $e := $b/*[contains(string(.), "Suciu") and ends-with(local-name(.), "or")]        	where exists($e)        	return <book> { $b/title } { $e } </book>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
xmp-queries-results-q9,Error: XPST0003: Unable to parse XPath:        	<results> {        		for $t in //(chapter | section)/title        		where contains(exactly-one($t/text()), "XML")        		return $t }        	</results>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.
xmp-queries-results-q10,Error: XPST0003: Unable to parse XPath:        	<results> {        		let $doc := (/)        		for $t in distinct-values($doc//book/title)        		let $p := $doc//book[title = $t]/price        		return <minprice title="{ $t }"> <price>{ min($p) }</price> </minprice> }        	</results>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found.
xmp-queries-results-q12,Error: XPST0003: Unable to parse XPath:        	<bib> {        		for $book1 in //book, $book2 in //book        		let $aut1 :=        			for $a in $book1/author        			order by exactly-one($a/last), exactly-one($a/first)        			return $a        		let $aut2 :=        			for $a in $book2/author        			order by exactly-one($a/last), exactly-one($a/first)        			return $a        		where $book1 << $book2 and not($book1/title = $book2/title) and deep-equal($aut1, $aut2)        		return <book-pair> { $book1/title } { $book2/title } </book-pair> }        	</bib>       . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
XMark-Q3,Error: XPST0003: Unable to parse XPath: (: Purpose: Return the IDs of all open auctions whose current increase is at least twice as high as the initial increase. :)          <XMark-result-Q3> {              let $auction := (/)              return for $b in $auction/site/open_auctions/open_auction              where zero-or-one($b/bidder[1]/increase/text()) * 2.0 <= $b/bidder[last()]/increase/text()                  return <increase first="{$b/bidder[1]/increase/text()}" last="{$b/bidder[last()]/increase/text()}"/> }          </XMark-result-Q3>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.
XMark-Q4,Error: XPST0003: Unable to parse XPath: (: Purpose: List the reserves of those open auctions where a certain person issued a bid before another person. :)          <XMark-result-Q4> {              let $auction := (/) return              for $b in $auction/site/open_auctions/open_auction              where some $pr1 in $b/bidder/personref[@person = "person20"], $pr2 in $b/bidder/personref[@person = "person51"] satisfies $pr1 << $pr2              return <history>{$b/reserve/text()}</history> }          </XMark-result-Q4>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.
XMark-Q5,Error: XPST0003: Unable to parse XPath:          <XMark-result-Q5> {            let $auction := (/) return count(             for $i in $auction/site/closed_auctions/closed_auction              where $i/price/text() >= 40.0 return $i/price) }          </XMark-result-Q5>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.
XMark-Q8,Error: XPST0003: Unable to parse XPath: (: Purpose: List the names of persons and the number of items they bought. (joins person, closed\_auction). :)           <XMark-result-Q8> { let $auction := (/) return           for $p in $auction/site/people/person           let $a := for $t in $auction/site/closed_auctions/closed_auction           where $t/buyer/@person = $p/@id return $t           return <item person="{$p/name/text()}">{count($a)}</item> } </XMark-result-Q8>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
XMark-Q9,Error: XPST0003: Unable to parse XPath: (: Purpose: List the names of persons and the names of the items           they bought in Europe(joins person, closed auction, item). :)           <XMark-result-Q9> {              let $auction := (/)              return let $ca := $auction/site/closed_auctions/closed_auction              return let $ei := $auction/site/regions/europe/item              for $p in $auction/site/people/person              let $a := for $t in $ca where $p/@id = $t/buyer/@person              return let $n := for $t2 in $ei where $t/itemref/@item = $t2/@id              return $t2 return <item>{$n/name/text()}</item>              return <person name="{$p/name/text()}">{$a}</person> } </XMark-result-Q9>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "f" found.
XMark-Q10,Error: XPST0003: Unable to parse XPath: (: Purpose: List all persons according to their interest; use French markup in the result. :)           <XMark-result-Q10> { let $auction := (/)              return for $i in distinct-values($auction/site/people/person/profile/interest/@category)              let $p := for $t in $auction/site/people/person where $t/profile/interest/@category = $i              return <personne>                       <statistiques>                          <sexe>{$t/profile/gender/text()}</sexe>                          <age>{$t/profile/age/text()}</age>                          <education>{$t/profile/education/text()}</education>                          <revenu>{fn:data($t/profile/@income)}</revenu>                       </statistiques>                       <coordonnees>                          <nom>{$t/name/text()}</nom>                          <rue>{$t/address/street/text()}</rue>                          <ville>{$t/address/city/text()}</ville>                          <pays>{$t/address/country/text()}</pays>                          <reseau>                             <courrier>{$t/emailaddress/text()}</courrier>                             <pagePerso>{$t/homepage/text()}</pagePerso>                          </reseau>                       </coordonnees>                       <cartePaiement>{$t/creditcard/text()}</cartePaiement>                     </personne>              return <categorie>{<id>{$i}</id>, $p}</categorie> } </XMark-result-Q10>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
XMark-Q11,Error: XPST0003: Unable to parse XPath: (: Purpoose: For each person, list the number of items currently on sale           whose price does not exceed 0.02% of the person's income. :)           <XMark-result-Q11> {              let $auction := (/) return              for $p in $auction/site/people/person              let $l := for $i in $auction/site/open_auctions/open_auction/initial              where $p/profile/@income > 5000 * exactly-one($i/text())              return $i return <items name="{$p/name/text()}">{count($l)}</items> } </XMark-result-Q11>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
XMark-Q12,Error: XPST0003: Unable to parse XPath: (: Purpose: For each richer-than-average person, list the           number of items currently on sale whose price does not exceed 0.02% of the person's income. :)           <XMark-result-Q12> {              let $auction := (/) return              for $p in $auction/site/people/person              let $l := for $i in $auction/site/open_auctions/open_auction/initial              where $p/profile/@income > 5000.0 * exactly-one($i/text())              return $i where $p/profile/@income > 50000.0              return <items person="{$p/profile/@income}">{count($l)}</items> } </XMark-result-Q12>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
XMark-Q14,Error: XPST0003: Unable to parse XPath: (: Purpose: Return the names of all items whose description contains the word `gold'. :)           <XMark-result-Q14> {              let $auction := (/) return              for $i in $auction/site//item              where contains(string(exactly-one($i/description)), "gold")              return $i/name/text() } </XMark-result-Q14>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.
XMark-Q16,Error: XPST0003: Unable to parse XPath: (: Purpose: Return the IDs of those auctions that have one or more keywords in emphasis. (cf. Q15) :)           <XMark-result-Q16> {              let $auction := (/) return              for $a in $auction/site/closed_auctions/closed_auction              where not( empty( $a/annotation/description/parlist/listitem/parlist/listitem/text/emph/ keyword/ text() ) )              return <person id="{$a/seller/@person}"/> } </XMark-result-Q16>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.
XMark-Q17,Error: XPST0003: Unable to parse XPath: <XMark-result-Q17> {              let $auction := (/)              return for $p in $auction/site/people/person              where empty($p/homepage/text())              return <person name="{$p/name/text()}"/> } </XMark-result-Q17>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.
XMark-Q18,Error: XPST0003: Unable to parse XPath: (: Purpose: Convert the currency of the reserve of all open auctions to another currency. :)           declare namespace local = "http://www.example.com/";           declare function local:convert($v as xs:decimal?) as xs:decimal? { 2.20371 * $v };           <XMark-result-Q18> {              let $auction := (/) return              for $i in $auction/site/open_auctions/open_auction              return local:convert(zero-or-one($i/reserve)) } </XMark-result-Q18>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
XMark-Q19,Error: XPST0003: Unable to parse XPath: (: Purpose: Give an alphabetically ordered list of all items along with their location. :)           <XMark-result-Q19> {              let $auction := (/) return              for $b in $auction/site/regions//item              let $k := $b/name/text() stable order by zero-or-one($b/location) ascending empty greatest              return <item name="{$k}">{$b/location/text()}</item> } </XMark-result-Q19>. SyntaxError: Expected "!", "!=", "(", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
XMark-Q20,Error: XPST0003: Unable to parse XPath: <XMark-result-Q20> {              let $auction := (/) return                 <result>                    <preferred> {count($auction/site/people/person/profile[@income >= 100000.0])} </preferred>                   <standard> { count( $auction/site/people/person/ profile[@income < 100000.0 and @income >= 30000.0] ) } </standard>                   <challenge> {count($auction/site/people/person/profile[@income < 30000.0])} </challenge>                   <na> { count( for $p in $auction/site/people/person where empty($p/profile/@income) return $p ) } </na>                </result> } </XMark-result-Q20>. SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "w" found.
XMark-All,Error: XPST0003: Unable to parse XPath: (: Written By: Frans Englich(maintainer, not original author) :) (: Purpose: Return the name of the person with ID `person0'. :) (: Date: 2007-03-09 :)  declare namespace local = "http://www.example.com/";   declare function local:convert($v as xs:decimal?) as xs:decimal? {   2.20371 * $v (: convert Dfl to Euro :) };  <XMark-result-All>    <XMark-result-Q1>     {       let $auction := (/) return       for $b in $auction/site/people/person[@id = "person0"] return $b/name/text()     }   </XMark-result-Q1>    <XMark-result-Q2>     {       let $auction := (/) return       for $b in $auction/site/open_auctions/open_auction       return <increase>{$b/bidder[1]/increase/text()}</increase>     }   </XMark-result-Q2>      <XMark-result-Q3>     {       let $auction := (/) return       for $b in $auction/site/open_auctions/open_auction       where zero-or-one($b/bidder[1]/increase/text()) * 2.0 <= $b/bidder[last()]/increase/text()       return <increase first="{$b/bidder[1]/increase/text()}"                        last="{$b/bidder[last()]/increase/text()}"/>     }   </XMark-result-Q3>      <XMark-result-Q4>     {       let $auction := (/) return       for $b in $auction/site/open_auctions/open_auction       where         some $pr1 in $b/bidder/personref[@person = "person20"],              $pr2 in $b/bidder/personref[@person = "person51"]         satisfies $pr1 << $pr2       return <history>{$b/reserve/text()}</history>     }   </XMark-result-Q4>      <XMark-result-Q5>     {       let $auction := (/) return       count(for $i in $auction/site/closed_auctions/closed_auction             where $i/price/text() >= 40.0             return $i/price)     }   </XMark-result-Q5>      <XMark-result-Q6>     {       let $auction := (/) return       for $b in $auction//site/regions return count($b//item)     }   </XMark-result-Q6>      <XMark-result-Q7>     {       let $auction := (/) return       for $p in $auction/site       return count($p//description) + count($p//annotation) + count($p//emailaddress)     }   </XMark-result-Q7>      <XMark-result-Q8>     {       let $auction := (/) return       for $p in $auction/site/people/person       let $a := for $t in $auction/site/closed_auctions/closed_auction                 where $t/buyer/@person = $p/@id                 return $t       return <item person="{$p/name/text()}">{count($a)}</item>     }   </XMark-result-Q8>      <XMark-result-Q9>     {       let $auction := (/) return       let $ca := $auction/site/closed_auctions/closed_auction return       let $ei := $auction/site/regions/europe/item       for $p in $auction/site/people/person         let $a := for $t in $ca                   where $p/@id = $t/buyer/@person                   return let $n := for $t2 in $ei where $t/itemref/@item = $t2/@id return $t2                          return <item>{$n/name/text()}</item>       return <person name="{$p/name/text()}">{$a}</person>     }   </XMark-result-Q9>      <XMark-result-Q10>     {     let $auction := (/)     return       for $i in         distinct-values($auction/site/people/person/profile/interest/@category)       let $p :=         for $t in $auction/site/people/person         where $t/profile/interest/@category = $i         return           <personne>             <statistiques>               <sexe>{$t/profile/gender/text()}</sexe>               <age>{$t/profile/age/text()}</age>               <education>{$t/profile/education/text()}</education>               <revenu>{fn:data($t/profile/@income)}</revenu>             </statistiques>             <coordonnees>               <nom>{$t/name/text()}</nom>               <rue>{$t/address/street/text()}</rue>               <ville>{$t/address/city/text()}</ville>               <pays>{$t/address/country/text()}</pays>               <reseau>                 <courrier>{$t/emailaddress/text()}</courrier>                 <pagePerso>{$t/homepage/text()}</pagePerso>               </reseau>             </coordonnees>             <cartePaiement>{$t/creditcard/text()}</cartePaiement>           </personne>       return <categorie>{<id>{$i}</id>, $p}</categorie>     }   </XMark-result-Q10>      <XMark-result-Q11>     {       let $auction := (/) return       for $p in $auction/site/people/person       let $l := for $i in $auction/site/open_auctions/open_auction/initial                 where $p/profile/@income > 5000 * exactly-one($i/text())                 return $i       return <items name="{$p/name/text()}">{count($l)}</items>     }   </XMark-result-Q11>      <XMark-result-Q12>     {       let $auction := (/) return       for $p in $auction/site/people/person       let $l :=         for $i in $auction/site/open_auctions/open_auction/initial         where $p/profile/@income > 5000.0 * exactly-one($i/text())         return $i       where $p/profile/@income > 50000.0       return <items person="{$p/profile/@income}">{count($l)}</items>     }   </XMark-result-Q12>      <XMark-result-Q13>     {       let $auction := (/) return       for $i in $auction/site/regions/australia/item       return <item name="{$i/name/text()}">{$i/description}</item>     }   </XMark-result-Q13>      <XMark-result-Q14>     {       let $auction := (/) return       for $i in $auction/site//item       where contains(string(exactly-one($i/description)), "gold")       return $i/name/text()     }   </XMark-result-Q14>      <XMark-result-Q15>     {       let $auction := (/) return       for $a in         $auction/site/closed_auctions/closed_auction/annotation/description/parlist/          listitem/          parlist/          listitem/          text/          emph/          keyword/          text()       return <text>{$a}</text>     }   </XMark-result-Q15>      <XMark-result-Q16>     {       let $auction := (/) return       for $a in $auction/site/closed_auctions/closed_auction       where         not(           empty(             $a/annotation/description/parlist/listitem/parlist/listitem/text/emph/              keyword/              text()           )         )       return <person id="{$a/seller/@person}"/>     }   </XMark-result-Q16>      <XMark-result-Q17>     {       let $auction := (/) return       for $p in $auction/site/people/person       where empty($p/homepage/text())       return <person name="{$p/name/text()}"/>     }   </XMark-result-Q17>      <XMark-result-Q18>     {       let $auction := (/) return       for $i in $auction/site/open_auctions/open_auction       return local:convert(zero-or-one($i/reserve))     }   </XMark-result-Q18>      <XMark-result-Q19>     {       let $auction := (/) return       for $b in $auction/site/regions//item       let $k := $b/name/text()       stable order by zero-or-one($b/location) ascending empty greatest       return <item name="{$k}">{$b/location/text()}</item>     }   </XMark-result-Q19>      <XMark-result-Q20>     {       let $auction := (/) return       <result>         <preferred>           {count($auction/site/people/person/profile[@income >= 100000.0])}         </preferred>         <standard>           {             count(               $auction/site/people/person/                profile[@income < 100000.0 and @income >= 30000.0]             )           }         </standard>         <challenge>           {count($auction/site/people/person/profile[@income < 30000.0])}         </challenge>         <na>           {             count(               for $p in $auction/site/people/person               where empty($p/profile/@income)               return $p             )           }         </na>       </result>     }   </XMark-result-Q20>  </XMark-result-All> . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", or end of input but "n" found.
generate-id-020,Error: XPST0003: Unable to parse XPath:           let $nodes := (<a lang='de' xml:lang='de'>Insel</a>, <a lang='en' xml:lang='en'>Island</a>)          let $ids := for $n in $nodes return generate-id($n)          return count($nodes) = count(distinct-values($ids))        . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
generate-id-021,Error: XPST0003: Unable to parse XPath:           let $nodes := (<a lang='de' xml:lang='de'>Insel</a>, <a lang='en' xml:lang='en'>Island</a>)          let $ids := for $n in $nodes return generate-id($n)          return every $id in $ids satisfies matches($id, '^[A-Za-z][A-Za-z0-9]*$')        . SyntaxError: Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "?", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "idiv", "instance", "intersect", "is", "lt", "mod", "ne", "or", "return", "to", "union", "|", or "||" but "l" found.
generate-id-022,Error: XPST0003: Unable to parse XPath:           let $nodes := (text{''}, text{''}, text{''}, text{''})          let $ids := for $n in $nodes return generate-id($n)          return count($nodes) = count(distinct-values($ids))        . SyntaxError: Expected "!", "!=", "#", "(", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
generate-id-023,Error: XPST0003: Unable to parse XPath:           let $nodes := (text{''}, text{''}, text{''}, text{''})          let $ids := for $n in $nodes return generate-id($n)          return every $id in $ids satisfies matches($id, '^[A-Za-z][A-Za-z0-9]*$')        . SyntaxError: Expected "!", "!=", "#", "(", ")", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "union", "|", "||", [A-Z_a-z----------], [\-.0-9-], or [-] but "{" found.
