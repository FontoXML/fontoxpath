""""
"&"
'&#;'
''''
("**" || "***")
(())?(())
() != ()
() < ()
() <<
() <<< ()
() <= ()
() = ()
() > ()
() >= ()
() >>
() >>> ()
() | ()
(.)
*:
---..---
.
/*/
/*/.
/.
//
///
/>
<
<!
<!-
<!--
<!-- -- -->
<!---
<!----
<!----->
<!---->
<!-->
</>
<<
<< ()
<<<
<?
<??>
>
>>
>> ()
>>>
@
[]?*
[]?*?*
_
}
} }
("%$" || "#@!")
$a, function($a) { "lala", $a }
$NOTEXIST
$NOTEXIST + 1
($staff/staff[1]/employee[1]/empnum[1]) is $works/works[1]/employee[1]/empnum[1]
($works//empnum,$staff//empname)
$works/works[1]/employee[1]/empnum[1] << $staff/staff[1]/employee[1]/empnum[1]
$works/works[1]/employee[1]/empnum[1] >> ($staff/staff[1]/employee[1]/empnum[1])
(($works/works[1]/employee[1]/empnum[1] << $staff/staff[1]/employee[1]/empnum[1])           and ($works/works[1]/employee[1]/empnum[1] << $staff/staff[1]/employee[2]/empnum[1])           and ($works/works[1]/employee[1]/empnum[1] << $staff/staff[1]/employee[3]/empnum[1]))           or (($works/works[1]/employee[1]/empnum[1] >> $staff/staff[1]/employee[1]/empnum[1])           and ($works/works[1]/employee[1]/empnum[1] >> $staff/staff[1]/employee[2]/empnum[1])           and ($works/works[1]/employee[1]/empnum[1] >> $staff/staff[1]/employee[3]/empnum[1]))
(($works/works[1]/employee[1]/empnum[1] >> $staff/staff[1]/employee[1]/empnum[1])           and ($works/works[1]/employee[2]/empnum[1] >> $staff/staff[1]/employee[2]/empnum[1])           and ($works/works[1]/employee[3]/empnum[1] >> $staff/staff[1]/employee[3]/empnum[1]))           or (($works/works[1]/employee[1]/empnum[1] << $staff/staff[1]/employee[1]/empnum[1])           and ($works/works[1]/employee[2]/empnum[1] << $staff/staff[1]/employee[2]/empnum[1])           and ($works/works[1]/employee[3]/empnum[1] << $staff/staff[1]/employee[3]/empnum[1]))
$works/works[1]/employee[1]/empnum[1] is $staff/staff[1]/employee[1]/empnum[1]
() != ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
() < ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
() <= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
() = ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
() > ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
() >= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) != ()
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) < ()
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) <= ()
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) = ()
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) > ()
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) >= ()
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) != ($works/works/employee[1]/hours[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) < ($works/works/employee[1]/hours[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) <= ($works/works/employee[1]/hours[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) =          ($works/works/employee[1]/hours[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) > ($works/works/employee[1]/hours[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) >= ($works/works/employee[1]/hours[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) != ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) < ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) <= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) = ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) >= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) != ($works/works/employee[1]/hours[1],$works/works/employee[6]/hours[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) < ($works/works/employee[1]/hours[1],$works/works/employee[6]/hours[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) <= ($works/works/employee[1]/hours[1],$works/works/employee[6]/hours[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) = ($works/works/employee[1]/hours[1],$works/works/employee[6]/hours[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) > ($works/works/employee[1]/hours[1],$works/works/employee[6]/hours[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) >= ($works/works/employee[1]/hours[1],$works/works/employee[6]/hours[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) != 10000
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) < 10000
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) <= 10000
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) = 10000
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) > 10000
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) >= 10000
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) != (10000,50000)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) < (10000,50000)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) <= (10000,50000)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) = (10000,50000)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) > (10000,50000)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) >= (10000,50000)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) != (50000)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) < (50000)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) <= (50000)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) = (50000)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) > (50000)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) >= (50000)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) != (<a>10000</a>)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) != <a>10000</a>
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) < (<a>10000</a>)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) < <a>10000</a>
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) <= (<a>10000</a>)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) <= <a>10000</a>
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) = (<a>10000</a>)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) = <a>10000</a>
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) > (<a>10000</a>)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) > <a>10000</a>
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) >= (<a>10000</a>)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) >= <a>10000</a>
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) != (<a>10000</a>,<b>50000</b>)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) < (<a>10000</a>,<b>50000</b>)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) <= (<a>10000</a>,<b>50000</b>)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) = (<a>10000</a>,<b>50000</b>)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) > (<a>10000</a>,<b>50000</b>)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) >= (<a>10000</a>,<b>50000</b>)
($works/works/employee[1]/hours[1]) != ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
($works/works/employee[1]/hours[1]) < ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
($works/works/employee[1]/hours[1]) <= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
($works/works/employee[1]/hours[1]) = ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
($works/works/employee[1]/hours[1]) > ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
($works/works/employee[1]/hours[1]) >= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
($works/works/employee[1]/hours[1],$works/works/employee[6]/hours[1]) != ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
($works/works/employee[1]/hours[1],$works/works/employee[6]/hours[1]) < ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
($works/works/employee[1]/hours[1],$works/works/employee[6]/hours[1]) <= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
($works/works/employee[1]/hours[1],$works/works/employee[6]/hours[1]) =           ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
($works/works/employee[1]/hours[1],$works/works/employee[6]/hours[1]) > ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
($works/works/employee[1]/hours[1],$works/works/employee[6]/hours[1]) >= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
$xs:NOTEXIST
$xs:NOTEXIST + 1
-0
-0.0
0.0
0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001e10
0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
"&#0000045;"
"-0000-05" castable as xs:gYearMonth
"0000-05" castable as xs:gYearMonth
"-0000-05" cast as xs:gYearMonth
"-0000" castable as xs:gYear
"0000" castable as xs:gYear
"-0000" cast as xs:gYear
"-00" castable as xs:nonNegativeInteger
"+00" castable as xs:nonPositiveInteger
"-00" castable as xs:unsignedByte
"-00" castable as xs:unsignedInt
"-00" castable as xs:unsignedLong
"-00" castable as xs:unsignedShort
+.0.1
-.0.1
..01
.0.1
(0, 1)[1] eq 0
(0, 1, 2)[1] eq 0
(0, 1, 2)[1 eq position()]
(0, 1, 2)[2] eq 1
0 < (1, 2, 3)
(0, 1, 2)[3] eq 2
(0, 1, 2)[3 eq position()]
(0, 1, 2, "a", "b", "c")[. instance of xs:integer][. eq "c"] eq 0
(0, 1, 2)[. eq 0]
(0, 1, 2)[. eq 1]
(0, 1, 2)[. eq 2]
(0, 1, "2")[last()]
(0, 1, 2)[last()]
(0, 1, 2)[position() eq 3]
(0, 1, 2)[remove((1, "a string"), 2)]
(0, 1, 2)[true()][1] eq 0
(0)[1] eq 0
0[1] eq 0
(0, 2, 4, 5)[1][1][1][true()][1][true()][1] eq 0
0.3 eq .3
"0" and ''
(0) and ()
0 and 0
(0) and (0)
0 and -1
0 and 1
(0) and (1)
(0) and (/bib/book/price/text())
0 castable as xs:negativeInteger
"0" castable as xs:negativeInteger
0 castable as xs:positiveInteger
"0" castable as xs:positiveInteger
'0' cast as xs:boolean eq false()
0 < count((1, 2, 3, timezone-from-time(current-time()), 4))
0 != count((1, 2, timezone-from-time(current-time())))
0 = count(//node())
(0 div 0E0) idiv xs:integer(2)
-0e0
0e0
+0e0 div +0e0
+0e0 div -0e0
-0e0 div +0e0
-0e0 div -0e0
0 eq (if(xs:anyURI("")) then 1 else 0)
0 gt xs:double("-INF")
0 gt xs:float("-INF")
0 lt count((1, 2, 3, timezone-from-time(current-time()), 4))
0 lt xs:double("INF")
0 lt xs:float("INF")
0 ne count((1, 2, timezone-from-time(current-time())))
"0" or ''
(0) or ()
0 or 0
(0) or (0)
0 or -1
0 or 1
(0) or (1)
(0) or (/bib/book/price/text())
0 or current-date()
0 or xs:anyURI("example.com/")
0 or xs:untypedAtomic("a string")
0x20
"&#0xA;"
0 * xs:dayTimeDuration("P3DT4H3M3.100S") eq xs:dayTimeDuration("PT0S")
0 - xs:double(0)
0 - xs:float(0)
0 * xs:yearMonthDuration("P3Y36M") eq xs:yearMonthDuration("P0M")
(1)
<< 1
>> 1
{1}
1 * ()
1 + ()
1 - ()
1 <<
1 >>
1 + $NOTEXIST
1 + $xs:NOTEXIST
() != 10000
() < 10000
() <= 10000
() = 10000
() > 10000
() >= 10000
10000 != ()
10000 < ()
10000 <= ()
10000 = ()
10000 > ()
10000 >= ()
10000 != ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
10000 < ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
10000 <= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
10000 = ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
10000 > ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
10000 >= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
'&#100000000'
10000000000000000000000000000.0 div 0.1 gt 0
'&#100000000x'
10000 != (10000,50000)
10000 < (10000,50000)
10000 <= (10000,50000)
10000 = (10000,50000)
10000 > (10000,50000)
10000 >= (10000,50000)
() != (10000,50000)
() < (10000,50000)
() <= (10000,50000)
() = (10000,50000)
() > (10000,50000)
() >= (10000,50000)
(10000,50000) != ()
(10000,50000) < ()
(10000,50000) <= ()
(10000,50000) = ()
(10000,50000) > ()
(10000,50000) >= ()
10000 != (50000)
10000 < (50000)
10000 <= (50000)
10000 > (50000)
10000 >= (50000)
(10000,50000) != ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(10000,50000) < ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(10000,50000) <= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(10000,50000) = ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(10000,50000) > ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(10000,50000) >= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(10000,50000) != 10000
(10000,50000) < 10000
(10000,50000) <= 10000
(10000,50000) = 10000
(10000,50000) > 10000
(10000,50000) >= 10000
(10000,50000) != (10000,50000)
(10000,50000) < (10000,50000)
(10000,50000) <= (10000,50000)
(10000,50000) = (10000,50000)
(10000,50000) > (10000,50000)
(10000,50000) >= (10000,50000)
(10000,50000) != (50000)
(10000,50000) < (50000)
(10000,50000) <= (50000)
(10000,50000) = (50000)
(10000,50000) > (50000)
(10000,50000) >= (50000)
(10000,50000) != (<a>10000</a>)
(10000,50000) != <a>10000</a>
(10000,50000) < (<a>10000</a>)
(10000,50000) < <a>10000</a>
(10000,50000) <= (<a>10000</a>)
(10000,50000) <= <a>10000</a>
(10000,50000) = (<a>10000</a>)
(10000,50000) = <a>10000</a>
(10000,50000) > (<a>10000</a>)
(10000,50000) > <a>10000</a>
(10000,50000) >= (<a>10000</a>)
(10000,50000) >= <a>10000</a>
(10000,50000) != (<a>10000</a>,<b>50000</b>)
(10000,50000) < (<a>10000</a>,<b>50000</b>)
(10000,50000) <= (<a>10000</a>,<b>50000</b>)
(10000,50000) = (<a>10000</a>,<b>50000</b>)
(10000,50000) > (<a>10000</a>,<b>50000</b>)
(10000,50000) >= (<a>10000</a>,<b>50000</b>)
(10000,50000) != (/works/employee[1]/hours[1])
(10000,50000) < (/works/employee[1]/hours[1])
(10000,50000) <= (/works/employee[1]/hours[1])
(10000,50000) = (/works/employee[1]/hours[1])
(10000,50000) > (/works/employee[1]/hours[1])
(10000,50000) >= (/works/employee[1]/hours[1])
(10000,50000) != (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(10000,50000) < (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(10000,50000) <= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(10000,50000) = (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(10000,50000) > (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(10000,50000) >= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
10000 != (<a>10000</a>)
10000 != <a>10000</a>
10000 < (<a>10000</a>)
10000 < <a>10000</a>
10000 <= (<a>10000</a>)
10000 <= <a>10000</a>
10000 = (<a>10000</a>)
10000 = <a>10000</a>
10000 > (<a>10000</a>)
10000 > <a>10000</a>
10000 >= (<a>10000</a>)
10000 >= <a>10000</a>
10000 != (<a>10000</a>,<b>50000</b>)
10000 < (<a>10000</a>,<b>50000</b>)
10000 <= (<a>10000</a>,<b>50000</b>)
10000 = (<a>10000</a>,<b>50000</b>)
10000 > (<a>10000</a>,<b>50000</b>)
10000 >= (<a>10000</a>,<b>50000</b>)
10000 != (/works/employee[1]/hours[1])
10000 < (/works/employee[1]/hours[1])
10000 <= (/works/employee[1]/hours[1])
10000 = (/works/employee[1]/hours[1])
10000 > (/works/employee[1]/hours[1])
10000 >= (/works/employee[1]/hours[1])
10000 != (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
10000 < (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
10000 <= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
10000 = (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
10000 > (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
10000 >= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
1000 = 1 to year-from-date(current-date())[. gt 3000]
(10, 1 to 4)
10.3 and "non-zero length string"
10 || '/' || 6
(10)/attribute::*
1.0 castable as xs:language
(10)/child::*
(10)/descendant::*
(10)/descendant-or-self::*
10 div3
10div 3
10div3
1.0e0 idiv 0.0e0
-1.0e0 mod -1.0e0
-1.0e0 mod xs:double(-9223372036854775808)
-1.0e0 mod xs:float(-1.0e0)
1.0 idiv 0.0
10 idiv3
10idiv 3
10idiv3
10 idiv 3 eq 3
((10)idiv(3)) instance of xs:integer
-1.0 mod -1.0
10 mod3
10mod 3
10mod3
10 mod 3 eq 1
((10)mod(3)) instance of xs:integer
-1.0 mod -9223372036854775808.0
(10)/parent::*
(10)/self::*
10 to 10
"1" = 1
(1, /)[1]
1 !! 1
1 != "1"
1 * '1'
1 + '1'
1 - '1'
1 ; 1
1 << 1
1 <= 1
1 = "1"
1 = 1
1 =< 1
1 == 1
1 =>; 1
1 >= 1
1 >> 1
(1, 1 + 1, 3, 4, 5)
1.1.1.E2
1.1.1e2
(1.1, (), 1) instance of xs:decimal+
1 + 1.1 to 5
1 + (1, 2)
(1+1), (2-2)
1 != (1, 2, 3)
1 < (1, 2, 3)
1 = (1, 2, 3)
(1.1,3.2,4.5) instance of xs:decimal*
1+1 eq 2
(1.1 idiv 1) instance of xs:integer
1.1 instance of xs:decimal
1.1 instance of xs:decimal and not(1.1 instance of xs:integer)
11 to 11 to 12
1.1 to 3
1.1 to 3.3
(1.1 - xs:untypedAtomic("3")) instance of xs:double
()?12
(/, 1)[2]
(1) , (2)
1 != "2"
1 != 2
1 < 2
(1, 2) + 1
(1, 2) + (1, 2)
(1, 2 * 1, 3, 4, 5)
(1, 2, 2)
(1,2,2),(1,2,3),(123,""),(),("")
(1.2,2.1) castable as xs:decimal?
(1, 2) != (2, 3)
(1, 2) = (2, 3)
(1 + 2) * 3
(1, 2, 3)[
(1, 2, 3)[]
(1, 2, 3)]
1 + (2 * 3)
1|2|3
123[..]
(1, 2, 3) > 0
[1, 2, 3]?0
(1, 2, 3) != 1
(1, 2, 3) = 1
(1, 2, 3) > 1
[1, 2, 3](-1)
(1, 2, 3)[1.0e0] eq 1
(1, 2, 3)[1.0] eq 1
[1, 2, 3](1.1)
-1231.123e3 instance of xs:double
1231.123e3 instance of xs:double
(1, 2, 3)[1]/(1, 2)[last()]/"a string"
'12312' cast as xs:boolean eq false()
(1, 2, 3)[1] eq 1
(1, 2, 3) != 2
(1, 2, 3) < 2
(1, 2, 3) = 2
(1, 2, 3) > 2
([1, [2], [3]], [[2], 2, [4]])[ .?1 = .?2 ]
([1, [2], [3]], [[2], 2, [4]])[ ?1 = ?2 ]
([1, [2], [3]], [[2], 2, [4]])?3 = 3
(1, 2, 3) != 3
(1, 2, 3) < 3
(1, 2, 3) = 3
(1, 2, 3)[3.0e0] eq 3
(1, 2, 3)[3.0] eq 3
(1, 2, 3)[3] eq 3
(1, 2, (), 3, 4)
(1, 2, 3) < 4
[1, 2, 3]?4
(1, (2, (3, 4)), (5))
(1,(2,3),4,5)
(1,2,3,4,5)
12 || 34 - 50
1 => ([2,3],[4,5][6])()
((1,2,3,4,5,6,7,8,9,10,11)[fn:true()])
((1,2,3,4,5,6,7,8,9,10,11)[(. gt 1) and (. gt 2)][(. gt 5) and (. gt 6)])
((1,2,3,4,5,6,7,8,9,10,11)[. gt 1][. gt 5])
((1,2,3,4,5,6,7,8,9,10,11)[(xs:string(.) eq "3")])
(1, 2, 3, 4, 5) instance of item()+
(1, 2, 3, 4, 5) instance of xs:integer*
(1, 2, 3, 4, 5) instance of xs:integer+
"1234" eq 12 || 34
(1, 2, 3, 4) => Q{http://www.w3.org/2005/xpath-functions}sum()
(1, 2, 3, 4) => (Q{http://www.w3.org/2005/xpath-functions}sum#1)()
(1, 2, 3, 4) => (Q{http://www.w3.org/2005/xpath-functions}sum#2(?, 'foo'))()
(1, 2, 3)["a string", 1]
1.23E2 mod 0.6E1 eq 3.0E0
(1 ||  "2" ||  3) eq "123"
(1 ||  2 ||  3) eq "123"
(1, 2, 3) eq 3
(1, 2, 3) except (1, 2, 3)
(1,2,3)[fn:avg((.,2,3)) gt 2]
(1,2,3)[fn:min((.,2)) eq 2]
(1,2,3)[fn:min((.,3)) eq 3]
(1, 2, 3) ge 3
(1,2,3)[(. + .) gt 1]
(1, 2, 3) gt 3
(1, 2, 3)[id("ncname")]
(1, 2, 3)[id("ncname", .)]
(1, 2, 3)[idref("ncname")]
(1, 2, 3)[idref("ncname", .)]
(1, 2, 3)[if(1) then 1 else last()]
(1, 2, 3)[if(1) then 1 else position()]
(1,2,3) instance of xs:integer*
(1, 2, 3) intersect (1, 2, 3)
(1, 2, 3)[(last(), last())[2]]
(1, 2, 3) le 3
(1, 2, 3) lt 3
[[1, 2, 3], map:entry(3, 5)]?*?3
(1, 2, 3) ne 3
(1, 2, 3)[position() eq 2 or position() eq 3][2] eq 3
(1, 2, 3)[root()]
(1, 2, 3) union (1, 2, 3)
(1, 2, 3)[(xs:anyURI("example.com/"), xs:anyURI("example.com/"))]
(1,2,3)[xs:decimal(.)]
(1,2,3)[xs:double(.)]
(1,2,3)[xs:float(.)]
(1, 2, 3)[xs:hexBinary("FF")]
(1,2,3)[xs:integer(.)]
(1, 2, 3)[(xs:untypedAtomic("content"), xs:untypedAtomic("content"))]
1 + 2 * 4 + (1 + 2 + 3 * 4) eq 24
((1,2,4,5,6,7,8,9,10,11)[(. * 2 eq 10)])
((1,2,4,5,6,7,8,9,10,11)[(. + 2 eq 10)])
((1,2,4,5,6,7,8,9,10,11)[(. - 2 eq 6)])
((1,2,4,5,6,7,8,9,10,11)[(. div 2 eq 5)])
((1,2,4,5,6,7,8,9,10,11)[(. idiv 2 eq 3)])
1267.43233E12 instance of xs:anyURI
1267.43233E12 instance of xs:boolean
1267.43233E12 instance of xs:date
1267.43233E12 instance of xs:dateTime
1267.43233E12 instance of xs:decimal
1267.43233E12 instance of xs:double
1267.43233E12 instance of xs:float
1267.43233E12 instance of xs:int
1267.43233E12 instance of xs:integer
1267.43233E12 instance of xs:string
1267.43233E12 instance of xs:time
12678967.543233 instance of xs:anyURI
12678967543233 instance of xs:anyURI
12678967.543233 instance of xs:boolean
12678967543233 instance of xs:boolean
12678967.543233 instance of xs:date
12678967543233 instance of xs:date
12678967.543233 instance of xs:dateTime
12678967543233 instance of xs:dateTime
12678967.543233 instance of xs:decimal
12678967543233 instance of xs:decimal
12678967.543233 instance of xs:double
12678967543233 instance of xs:double
12678967.543233 instance of xs:float
12678967543233 instance of xs:float
12678967.543233 instance of xs:int
12678967543233 instance of xs:int
12678967.543233 instance of xs:integer
12678967543233 instance of xs:integer
12678967.543233 instance of xs:string
12678967543233 instance of xs:string
12678967.543233 instance of xs:time
12678967543233 instance of xs:time
128 castable as xs:byte
"128" castable as xs:byte
-129 castable as xs:byte
"-129" castable as xs:byte
(1, 2, "a string", 4, 5) instance of xs:anyAtomicType*
(1.2) castable as xs:decimal?
(1,2) castable as xs:integer?
(1, 2) cast as xs:integer
(1, 2, count("one"), 4, 5) instance of xs:integer+
(1,2) instance of xs:integer+
(1,2) instance of xs:integer?
((1+2) to (2+2))
((1*2) to (3*2))
(1, 2 to 5)
1 * "3"
1 := 3
1/3
(1, 3 - 1, 3, 4, 5)
13e0 eq 12e0+1
13e0 eq /works/@id
1.3e-3 instance of xs:double
13 eq 12+1
13 eq /works/@id
-1.3!floor(.)
[1](4294967297)
(1, 4 div 2, 3, 4, 5)
(1, 4 idiv 2, 3, 4, 5)
(1, 5 * /)[1]
-1.7976931348623157E+308 castable as xs:decimal
1.7976931348623157E+308 castable as xs:decimal
-1.7976931348623157E+308 castable as xs:integer
1.7976931348623157E+308 castable as xs:integer
"18446744073709551616-05-15" cast as xs:date
"18446744073709551616-05-15T16:15:00" cast as xs:dateTime
18446744073709551616 castable as xs:unsignedLong
"18446744073709551616" castable as xs:unsignedLong
"18446744073709551616-QQ-15" cast as xs:date
"18446744073709551616-QQ-15T16:15:00" cast as xs:dateTime
1 * <a/>
1 + <a/>
1 - <a/>
1 * <a> 2 </a>
1 + <a> 2 </a>
1 * <a> <b> 2 </b> </a>
1+<a> <b> 2 </b> </a>
1 * <a> <b> 2</b> <c> 2</c> </a>
1 + <a> <b> 2</b> <c> 2</c> </a>
(-1)=>abs()
-1=>abs()
(1) and ()
1 and 0
1 AND 0
(1) and (0)
-1 and 1
1 and 1
(1) and (1)
1 and 5
1 and current-date()
1, attribute name {"content"}/ancestor::node(), 1
1, (attribute name {"content"}/ancestor-or-self::node() instance of attribute(name)), 1
1 * <a> x </a>
1 + <a> x </a>
1 - <a> x </a>
1, <b attr="fo"/>/child::node(), 1
1 castable as xs:error
(1) castable as xs:integer?
-1 castable as xs:nonNegativeInteger
"-1" castable as xs:nonNegativeInteger
1 castable as xs:nonPositiveInteger
"1" castable as xs:nonPositiveInteger
-1 castable as xs:unsignedByte
"-1" castable as xs:unsignedByte
-1 castable as xs:unsignedInt
"-1" castable as xs:unsignedInt
-1 castable as xs:unsignedLong
"-1" castable as xs:unsignedLong
-1 castable as xs:unsignedShort
"-1" castable as xs:unsignedShort
('1' cast as xs:boolean) cast as xs:string eq 'true'
'1' cast as xs:boolean eq true()
1 cast as xs:date
1 cast as xs:error
1, <!-- content -->/ancestor::node(), 1
1 <= count((1, 2, 3, timezone-from-time(current-time()), 4))
(1, current-time())[1]
1!data()
(1, data#0)[data()]
(1)[deep-equal(1, subsequence((1, 2, current-time()), 1, 1))] eq 1
(1 div 0) castable as xs:string
-1 div 0e0
1 div 0e0
1 div '1'
1 div <a/>
1 div <a> 2 </a>
1 div <a> <b> 2 </b> </a>
1 div <a> <b> 2</b> <c> 2</c> </a>
1 div <a> x </a>
1 div math:tan(-math:pi() div 2)
1 div math:tan(math:pi() div 2)
1 div xs:double("-0") ne 1 div xs:double("0")
-1 div xs:float(0)
1 div xs:float(0)
1 div xs:float("-0") ne 1 div xs:float("0")
1 div xs:integer('1')
(1, <e/>)[..]
1 e 2
1 e2
1 E 2
1 E2
1e 2
1E 2
1e-2.1.1
1e2.1.1
1E2.1.1
1e2e3
(1E3,2E3,3E3) instance of xs:double*
(1E3,2E3) castable as xs:double?
(1E3) castable as xs:double?
1.e+3 instance of xs:double
1.e3 instance of xs:double
1.E3 instance of xs:double
1e3 to 3
1, <e attr=""/>/descendant::node(), 1
1, <e/>/descendant::node(), 1
1ee2
1eE2
1EE2
1[element()]
1, <element/>/ancestor::node(), 1
1 eq (0 + remove((current-time(), 1), 1))
1 eq <!--1-->
<!--1--> eq 1
1 eq "a string"
1 eq (for $a in 1 return $a)
1 eq (for $foo in 1 return $foo)
1 eq (for $i at $p in 0 return $p)
1 eq (for $i at $p in subsequence((1, 2, 3, current-time()), 1, 1) return $p)
1 eq (for $xs:a in 1 return $xs:a)
1 eq (if(xs:anyURI("example.com/")) then 1 else 0)
1 eq (remove((current-time(), 1), 1) + 0)
1 eq (remove((current-time(), 1), 1) - 0)
1 eq subsequence(("1", 2, 3.1, "four"), 1, 1)
1 eq <?target 1?>
1 except 2 except 3
1fd()
(1, fn:count((1, 2)), 3, 4, 5)
(., 1) ! fn:has-children(.)
(1, fn:string-length("AB"), 3, 4, 5)
1 + "foo"
-1[. gt 0]
1 idiv 0
1 idiv +0.0
1 idiv -0.0
1 idiv 0.0
-1 idiv 0e0
1 idiv 0e0
1 idiv '1'
1 idiv <a/>
1 idiv <a> <b> 2 </b> </a>
1 idiv <a> x </a>
1 idiv xs:double("NaN")
-1 idiv xs:float(0)
1 idiv xs:float(0)
1 idiv xs:float("NaN")
1 idiv xs:integer('1')
1 instance of document()
1 instance of document(*)
1 instance of item()
1 instance of xs:decimal
1 instance of xs:integer
1 instance of xs:integer*
1 instance of xs:integer+
1 instance of xs:integer?
(1) instance of xs:integer?
1 intersect 2 intersect 3
1 is 1
1 le count((1, 2, 3, timezone-from-time(current-time()), 4))
1 &lt;= 3
-1 mod -1
1 mod '1'
-1 mod -9223372036854775808
1 mod <a/>
1 mod <a> 2 </a>
1 mod <a> <b> 2 </b> </a>
1 mod <a> <b> 2</b> <c> 2</c> </a>
1 mod <a> x </a>
1 mod xs:integer('1')
/*/*[1]/name()
(1)[number()] eq 1
(1) or ()
1 or 0
1 OR 0
(1) or (0)
-1 or 1
1 or 1
(1) or (1)
1 or 5
1 => Q{http://www.w3.org/2005/xpath-functions}sum()
(1 + remove((5, 1e0), 2)) eq 6
1 + remove(("foo", 2), 2)asdasdad
1, <root> <child/> </root>/following-sibling::node(), 1
1, <root/>/following-sibling::node(), 1
1 + subsequence("a string", 1, 1)
1, <?target data?>/ancestor::node(), 1
1, text {""}/ancestor::node(), 1
1, text {""}/ancestor-or-self::node(), 1
(1 to 10)!(.*.)
(1 to 100)[fn:root()]
(1 to 100)[string-length() = 3]
(1 to 100)[string-length(.) = 3]
(1 to 10)?1
(1 to 10)[.?1 = 3]
(1 to 10)[?1 = 3]
(1 to 10)/count()
(1 to 10)[fn:idref("argument1")]
(1 to (10 idiv 2))
((1 to 11)[(. eq 10) and (. mod 5 eq 0)])
((1 to 11)[(. eq 10) or (. eq 5)])
((1 to 11)[. ne 10])
1 to 1 eq 1
(1 to 20)[. = filter(1 to position(), function($x){$x idiv 2 * 2 = $x})]
(1 to 20)[fn:last() - 1]
((1 to 25)[25])
((1 to 25)[. eq 10])
((1 to 25)[. ge 10])
((1 to 25)[. le 10])
((1 to 25)[. lt 10])
((1 to 25)[. mod 2 eq 0])
(1 to (3 - 2))
(1 to (3*2))
(1 to 4) !          (let $add := function($x){$x + .} return $add(4))
(1 to 5000)[position() = 2001 to 2020]
1 to 5000 = year-from-date(current-date())[. gt 3000]
(1 to 5) ! (1 to .)
(1 to 5) ! ((1 to .) ! position())
(1 to 5) ! (1 to .) ! position()
(1 to 5)[ fn:id("argument1",.)]
(1 to 5)[fn:id("argument1")]
(1 to 6)[last()] eq 6
1 to <value>5</value>, 5 to <value>5</value>, <value>1</value> to 5, <value>1</value> to <value>5</value>, let $i := <e>5</e> return $i to $i, count(5 to 10), count(1000 to 2000), count(<e>5</e> to 10), count(3 to <e>10</e>), count(<e>3</e> to <e>10</e>), count(<e>5</e> to 10), count(3 to <e>10</e>), count(<e>3</e> to <e>10</e>), count(4294967295 to 4294967298)
(1 to xs:integer(5))
1[true()] eq 1
1 union 2 union 3
1 < xs:anyURI("0")
1 > xs:anyURI("2")
1 * xs:integer('1')
1 + xs:integer('1')
1 - xs:integer('1')
1 = xs:untypedAtomic("1")
[]?2
"&#+20;"
"&#-20;"
(200)/ancestor::*
(200)/ancestor-or-self::*
(200)/following::*
(200)/following-sibling::*
(200)/preceding::*
(200)/preceding-sibling::*
(-20 to -5)[last() - 3]
"2" != 1
-2!(.+1)
2 > 1
2 != (1, 2, 3)
2 < (1, 2, 3)
2 = (1, 2, 3)
2 > (1, 2, 3)
2147483648 castable as xs:int
"2147483648" castable as xs:int
-2147483649 castable as xs:int
"-2147483649" castable as xs:int
((2 - 1) to (7 - 1))
2 + 3!#
(2, 3) = (3, 4)
2 < 3 < 4
2 + 4 * 5 eq 22
(2 + 4) * 5 eq 30
(2, 4, 6)!function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'last'), 0)()
(2, 4, 6)!function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'position'), 0)()
(2, 4, 6)!Q{http://www.w3.org/2005/xpath-functions}last#0()
(2, 4, 6)!Q{http://www.w3.org/2005/xpath-functions}position#0()
2 + (4 idiv 2)
(2 + 4) idiv 2
(-2) + 5
-(2 + 5)
"-25252734927766555-06-06" cast as xs:date
"-25252734927766555-06-06T00:00:00Z" cast as xs:dateTime
"25252734927766555-07-29" cast as xs:date
"25252734927766555-07-29T00:00:00Z" cast as xs:dateTime
256 castable as xs:unsignedByte
"256" castable as xs:unsignedByte
2 * (5 mod 3)
(2 * 5) mod 3
"&#2A0;"
(2) castable as xs:integer?
2e308
2 eq (0, 1, "2")[last()]
2 eq 1+1
2 eq (1 + remove((1, "two"), 2))
2 eq (1 + remove((xs:untypedAtomic("1"), "two"), 2))
2 eq (for $foo in 1 return $foo + 1)
2 eq (xs:untypedAtomic("1") + remove((1, "two"), 2))
2=>(map{1:2, 2:4, 3:6})()
2*math:pi()
2 + (/ works ! employee[2] ! hours[2]) ! number() ! (-.)
2 != xs:untypedAtomic("1")
3}
3.0 idiv 4 eq 0
3 + 10 div 2
3 != (1, 2, 3)
3 = (1, 2, 3)
3 > (1, 2, 3)
3.1E1 idiv 6 eq 5
3.1E1 idiv 7 eq 4
3+1 to 4+1
32768 castable as xs:short
-32769 castable as xs:short
"-32769" castable as xs:short
"32769" castable as xs:short
((3 - 2) to 10)
((3*2) to 10)
"3" * "3"
"3" + "3"
"3" - "3"
33"
3.3e1 instance of xs:double
3.3 instance of xs:decimal
[3, 4, 5] < []
[3, 4, 5] = []
[3, 4, 5] < 4
[3, 4, 5] = 4
[[3, 4], 5] < [4, [5, 6]]
[[3, 4], 5] = [4, [5, 6]]
(3,4,5)[(xs:integer(5) - xs:integer(.)) gt 1]
(3,4,5)[(xs:integer(.) * xs:integer(.)) gt 2]
[3,4] eq 3
-3 + 5 * 3
3 - 5 * 3
-3.5 idiv 3 eq -1
(: 3.7.3.1 Computed Element Constructor per XQ.E19 XQDY0096 if namespace prefix is not 'xml' and its namespace URI is 'http://www.w3.org/XML/1998/namespace' Mary Holstege :) element { fn:QName("http://www.w3.org/XML/1998/namespace","foo:error") } {}
(: 3.7.3.1 Computed Element Constructor per XQ.E19 XQDY0096 if namespace prefix is 'xml' and namespace URI is not 'http://www.w3.org/XML/1998/namespace' Mary Holstege :) element { fn:QName("http://example.com/not-XML-uri","xml:error") } {}
(: 3.7.3.1 Computed Element Constructor per XQ.E19 XQDY0096 if namespace prefix is 'xmlns' Mary Holstege :) element { fn:QName("http://example.com/some-uri","xmlns:error") } {}
(: 3.7.3.1 Computed Element Constructor per XQ.E19 XQDY0096 if namespace URI is 'http://www.w3.org/2000/xmlns/' Mary Holstege :) element { fn:QName("http://www.w3.org/2000/xmlns/","error")} {}
(: 3.7.3.1 Computed Element Constructor per XQ.E19 XQDY0096 if namespace URI is 'http://www.w3.org/2000/xmlns/' Mary Holstege :) element { fn:QName("http://www.w3.org/2000/xmlns/","foo:error")} {}
(: 3.7.3.2 Computed Attribute Constructor per XQ.E19 XQDY0044 if namespace prefix is not 'xml' and namespace URI is 'http://www.w3.org/XML/1998/namespace' Mary Holstege :) <result>{ attribute { fn:QName("http://www.w3.org/XML/1998/namespace","foo:error")} {} }</result>
(: 3.7.3.2 Computed Attribute Constructor per XQ.E19 XQDY0044 if namespace prefix is 'xml' and namespace URI is not 'http://www.w3.org/XML/1998/namespace' Mary Holstege :) <result>{ attribute { fn:QName("http://example.com/not-XML-uri","xml:error") } {} }</result>
(: 3.7.3.2 Computed Attribute Constructor per XQ.E19 XQDY0044 if namespace prefix is 'xmlns' Mary Holstege :) <result>{attribute {fn:QName("http://example.com/some-uri","xmlns:error")} {}}</result>
(: 3.7.3.2 Computed Attribute Constructor per XQ.E19 XQDY0044 if namespace prefix is 'xmlns' Mary Holstege :) <result>{attribute {"xmlns:error"} {}}</result>
(: 3.7.3.2 Computed Attribute Constructor per XQ.E19 XQDY0044 if namespace URI is 'http://www.w3.org/2000/xmlns/' Mary Holstege :) <result>{ attribute { fn:QName("http://www.w3.org/2000/xmlns/","error")} {} }</result>
(: 3.7.3.2 Computed Attribute Constructor per XQ.E19 XQDY0044 if namespace URI is 'http://www.w3.org/2000/xmlns/' Mary Holstege :) <result>{ attribute { fn:QName("http://www.w3.org/2000/xmlns/","foo:error")} {} }</result>
(: 3.7.3.2 Computed Attribute Constructor per XQ.E19 XQDY0044 if no namespace prefix and local name is 'xmlns' Mary Holstege :) <result>{attribute {"xmlns"} {}}</result>
3 - <a> 2 </a>
3 - <a> <b> 2 </b> </a>
3 - <a> <b> 2</b> <c> 2</c> </a>
3=>(['a','b','c','d','e'])()
3 cast as prefixDoesNotExist:integer
+3 div +0e0
+3 div -0e0
-3 div +0e0
-3 div -0e0
"3" div "3"
3 div xs:dayTimeDuration("P3D")
3 div xs:duration("P1Y3M")
3 div xs:yearMonthDuration("P1Y3M")
3 < <e>1.1</e>
3. < <e>1.1</e>
3 >E 2
3e3 < <e>1.1</e>
3 eq (1, 2, 3)
+++++++++++3 eq 3
+++3 eq ++3
+-+-+-+-+-+-+-+3 eq -3
-+-+-+-+-+-++-+-++-+-+-+-+++3 eq 3
-+-+-+-+-+-+-+-3 eq 3
----+-+-++-+-+-+-+++-+--+--3 eq -3
----------3 eq 3
---------3 eq -3
---3 eq -3
-3 eq -3
.3 eq .3
(+3) eq +(3)
(+3) eq +3
(+3) eq 3
(-3) eq -3
+(-3) eq -3
+(3) eq +3
+(3) eq 3
-(+3) eq -3
-(3) eq -3
[3] eq 3
3. eq 3.
3 eq (for $foo in 1, $foo in 3 return $foo)
3 eq (for $foo in 1 return 3)
3 eq (for $foo in 1 return for $bar in 2 return $bar + $foo)
3 eq (for $foo in 1 return for $foo in 3 return $foo)
3 ge (1, 2, 3)
3 gt (1, 2, 3)
3 idiv 1.1 eq 2
-3 idiv -2 eq 1
-3 idiv 2 eq -1
3 idiv -2 eq -1
"3" idiv "3"
3 idiv <a> 2 </a>
3 idiv <a> <b> 2</b> <c> 2</c> </a>
"3" idiv xs:float(3)
3 instance of none
3 instance of none()
3 instance of prefixDoesNotExist:integer
3 instance of void
3 instance of void()
3 instance of xs:doesNotExist
3 instance of xs:integer
3 instance of xs:qname
3 le (1, 2, 3)
[3] le [3]
3 lt (1, 2, 3)
"3" mod 1.1
"3" mod "3"
3 mod xs:double("-0")
3 mod xs:double("0")
3 mod xs:double("-INF")
3 mod xs:double("INF")
3 mod xs:double("NaN")
3 mod xs:float("-0")
3 mod xs:float("0")
3 mod xs:float("-INF")
3 mod xs:float("INF")
3 mod xs:float("NaN")
3 ne (1, 2, 3)
(+3) ne -3
-(3) ne 3
3 to 1.1
3 to 1e3
3 * xs:duration("P1Y3M")
"3" + xs:untypedAtomic("3")
(3 - xs:untypedAtomic("3")) eq 0
(3 + xs:untypedAtomic("3")) eq 6
(3 * xs:untypedAtomic(3)) eq 9
3 != xs:untypedAtomic("three")
3 = xs:untypedAtomic("three")
3 * xs:yearMonthDuration("P3Y36M") eq xs:yearMonthDuration("P18Y")
40e0 eq number(/works/employee[1]/hours)
40e0 eq xs:double(/works/employee[1]/hours)
40e0 eq xs:double(/works/employee[830]/hours)
40e0 eq xs:integer(/works/employee[830]/hours)
40 eq number(/works/employee[1]/hours)
40 eq xs:double(/works/employee[1]/hours)
40 eq xs:double(/works/employee[830]/hours)
40 eq xs:integer(/works/employee[1]/hours)
40 eq xs:integer(/works/employee[830]/hours)
40 gt count(//node())
4 > (1, 2, 3)
4294967296 castable as xs:unsignedInt
"4294967296" castable as xs:unsignedInt
432f542
(-4, -3 to -1)
(-4,-3 to 2)
4 + / * 5
"4.54"=>ceiling()
4.54=>ceiling()
4.54=>((ceiling#1, floor#1, round#1, abs#1) => head())()
4.54=>(head((ceiling#1, floor#1, round#1, abs#1)))
4.54=>(head((ceiling#1, floor#1, round#1, abs#1)))()
(4, 5)[position() = 2][last() = 1]
(4, 5)[position() = 2][last() = 1][last() = 1][last()]
465.
4 eq (for $foo in 1, $bar in 2, $moo in 3 return 4)
. 5
.5
/ * 5
/*5
() != (50000)
() < (50000)
() <= (50000)
() = (50000)
() > (50000)
() >= (50000)
(50000) != ()
(50000) < ()
(50000) <= ()
(50000) = ()
(50000) > ()
(50000) >= ()
(50000) != ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(50000) < ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(50000) <= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(50000) = ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(50000) > ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(50000) >= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(50000) != 10000
(50000) < 10000
(50000) <= 10000
(50000) = 10000
(50000) > 10000
(50000) >= 10000
(50000) != (10000,50000)
(50000) < (10000,50000)
(50000) <= (10000,50000)
(50000) = (10000,50000)
(50000) > (10000,50000)
(50000) >= (10000,50000)
(50000) != (50000)
(50000) < (50000)
(50000) <= (50000)
(50000) = (50000)
(50000) > (50000)
(50000) >= (50000)
(50000) != (<a>10000</a>)
(50000) != <a>10000</a>
(50000) < (<a>10000</a>)
(50000) < <a>10000</a>
(50000) <= (<a>10000</a>)
(50000) <= <a>10000</a>
(50000) = (<a>10000</a>)
(50000) = <a>10000</a>
(50000) > (<a>10000</a>)
(50000) > <a>10000</a>
(50000) >= (<a>10000</a>)
(50000) >= <a>10000</a>
(50000) != (<a>10000</a>,<b>50000</b>)
(50000) < (<a>10000</a>,<b>50000</b>)
(50000) <= (<a>10000</a>,<b>50000</b>)
(50000) = (<a>10000</a>,<b>50000</b>)
(50000) > (<a>10000</a>,<b>50000</b>)
(50000) >= (<a>10000</a>,<b>50000</b>)
(50000) != (/works/employee[1]/hours[1])
(50000) < (/works/employee[1]/hours[1])
(50000) <= (/works/employee[1]/hours[1])
(50000) = (/works/employee[1]/hours[1])
(50000) > (/works/employee[1]/hours[1])
(50000) >= (/works/employee[1]/hours[1])
(50000) != (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(50000) < (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(50000) <= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(50000) = (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(50000) > (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(50000) >= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
5.0 div 2.0 eq 2.5
5.0 div 2.0 ne 2.6
5.0 idiv 2.0 eq 2
5 - 10 div 2
5 + 10 idiv 4
5 - 10 idiv 4
5 + 10 mod 4
5 - 10 mod 4
.54.45
5.4=>ceil()
(5 + 5) cast as xs:boolean
(5 + 5) cast as xs:decimal
(5 + 5) cast as xs:double
(5 + 5) cast as xs:float
(5 + 5) cast as xs:integer
(5 + 5) cast as xs:string
5 castable as xs:normalizedString
5 castable as xs:token
5 div 2 ne 2.6
5 eq remove((5, 1e0), 2)
5 = false()
((5 idiv 5) to (8 idiv 2))
60 * (math:pi() div 180)
(6,10,14)[(xs:integer(.) div xs:integer(3)) gt 2]
(6,10,14)[(xs:integer(.) idiv xs:integer(3)) gt 2]
(6,10,14)[(xs:integer(.) mod xs:integer(3)) gt 1]
+.65535032
-.65535032
-65535032
.65535032
65535032
65535032.001.01
65535032.0023
+.65535032e-2
+.65535032e2
-.65535032e-2
-.65535032e2
-65535.032e-2
.65535032e-2
.65535032e2
65535.032e-2
+.65535032E-2
+.65535032E2
-.65535032E-2
-.65535032E2
.65535032E-2
.65535032E2
65535.032E-2
65536 castable as xs:unsignedShort
"65536" castable as xs:unsignedShort
6 eq (for $foo in 1, $foo in 3 return $foo + $foo)
((6 idiv 2) to 10)
6 mod -2 eq 0
6 = remove(("a string", 6), 2)
6 = (remove(("a string", xs:untypedAtomic("6")), 1))
-+7
-79228162514264337593543950335.0 - 1.0 lt 0.0
-79228162514264337593543950335 - 1 lt 0
(7 eq 7) eq xs:boolean("false")
((7 eq 7) eq xs:boolean("true")) and (xs:boolean("false") eq xs:boolean("true"))
((7 eq 7) eq xs:boolean("true")) or (xs:boolean("false") eq xs:boolean("true"))
(7 eq 7) ge xs:boolean("false")
(7 eq 7) ge xs:boolean("true")
(7 eq 7) gt xs:boolean("false")
(7 eq 7) gt xs:boolean("true")
(7 eq 7) le xs:boolean("false")
(7 eq 7) le xs:boolean("true")
(7 eq 7) lt xs:boolean("false")
(7 eq 7) lt xs:boolean("true")
(7 lt 7) eq xs:boolean("true")
"&#8364;"
8 eq (for $foo in 1, $foo in 3, $moo in 5 return $moo + $foo)
9.0 idiv 3 eq 3
9223372036854775808 castable as xs:long
"9223372036854775808" castable as xs:long
-9223372036854775809 castable as xs:long
"-9223372036854775809" castable as xs:long
"99999999999999999999999999999-01" cast as xs:gYearMonth
-999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999
999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999
999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999.1
-999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999E100000000000000000000000000000000000000000000000000000000
999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999E100000000000000000000000000000000000000000000000000000000
"99999999999999999999999999999" cast as xs:gYear
"99999999999999999999999999999-XX" castable as xs:gYearMonth
"99999999999999999999999999999-XX" cast as xs:gYearMonth
<a/>/.
(<a>0</a>,<a>1</a>) except (<a>3</a>,<a>4</a>)
(<a>0</a>,<a>1</a>) except (<a>3</a>,<a>4</a>,<a>0</a>)
() != (<a>10000</a>)
() != <a>10000</a>
() < (<a>10000</a>)
() < <a>10000</a>
() <= (<a>10000</a>)
() <= <a>10000</a>
() = (<a>10000</a>)
() = <a>10000</a>
() > (<a>10000</a>)
() > <a>10000</a>
() >= (<a>10000</a>)
() >= <a>10000</a>
(<a>10000</a>) != ()
(<a>10000</a>) < ()
(<a>10000</a>) <= ()
(<a>10000</a>) = ()
(<a>10000</a>) > ()
(<a>10000</a>) >= ()
<a>10000</a> != ()
<a>10000</a> < ()
<a>10000</a> <= ()
<a>10000</a> = ()
<a>10000</a> > ()
<a>10000</a> >= ()
(<a>10000</a>) != ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(<a>10000</a>) < ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(<a>10000</a>) <= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(<a>10000</a>) = ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(<a>10000</a>) > ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(<a>10000</a>) >= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
<a>10000</a> != ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
<a>10000</a> < ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
<a>10000</a> <= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
<a>10000</a> = ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
<a>10000</a> > ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
<a>10000</a> >= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(<a>10000</a>) != 10000
(<a>10000</a>) < 10000
(<a>10000</a>) <= 10000
(<a>10000</a>) = 10000
(<a>10000</a>) > 10000
(<a>10000</a>) >= 10000
<a>10000</a> != 10000
<a>10000</a> < 10000
<a>10000</a> <= 10000
<a>10000</a> = 10000
<a>10000</a> > 10000
<a>10000</a> >= 10000
(<a>10000</a>) != (10000,50000)
(<a>10000</a>) < (10000,50000)
(<a>10000</a>) <= (10000,50000)
(<a>10000</a>) = (10000,50000)
(<a>10000</a>) > (10000,50000)
(<a>10000</a>) >= (10000,50000)
<a>10000</a> != (10000,50000)
<a>10000</a> < (10000,50000)
<a>10000</a> <= (10000,50000)
<a>10000</a> = (10000,50000)
<a>10000</a> > (10000,50000)
<a>10000</a> >= (10000,50000)
(<a>10000</a>) != (50000)
(<a>10000</a>) < (50000)
(<a>10000</a>) <= (50000)
(<a>10000</a>) = (50000)
(<a>10000</a>) > (50000)
(<a>10000</a>) >= (50000)
<a>10000</a> != (50000)
<a>10000</a> < (50000)
<a>10000</a> <= (50000)
<a>10000</a> = (50000)
<a>10000</a> > (50000)
<a>10000</a> >= (50000)
(<a>10000</a>) != (<a>10000</a>)
(<a>10000</a>) != <a>10000</a>
(<a>10000</a>) < (<a>10000</a>)
(<a>10000</a>) < <a>10000</a>
(<a>10000</a>) <= (<a>10000</a>)
(<a>10000</a>) <= <a>10000</a>
(<a>10000</a>) = (<a>10000</a>)
(<a>10000</a>) = <a>10000</a>
(<a>10000</a>) > (<a>10000</a>)
(<a>10000</a>) > <a>10000</a>
(<a>10000</a>) >= (<a>10000</a>)
(<a>10000</a>) >= <a>10000</a>
<a>10000</a> != (<a>10000</a>)
<a>10000</a> != <a>10000</a>
<a>10000</a> < (<a>10000</a>)
<a>10000</a> < <a>10000</a>
<a>10000</a> <= (<a>10000</a>)
<a>10000</a> <= <a>10000</a>
<a>10000</a> = (<a>10000</a>)
<a>10000</a> = <a>10000</a>
<a>10000</a> > (<a>10000</a>)
<a>10000</a> > <a>10000</a>
<a>10000</a> >= (<a>10000</a>)
<a>10000</a> >= <a>10000</a>
(<a>10000</a>) != (<a>10000</a>,<b>50000</b>)
(<a>10000</a>) < (<a>10000</a>,<b>50000</b>)
(<a>10000</a>) <= (<a>10000</a>,<b>50000</b>)
(<a>10000</a>) = (<a>10000</a>,<b>50000</b>)
(<a>10000</a>) > (<a>10000</a>,<b>50000</b>)
(<a>10000</a>) >= (<a>10000</a>,<b>50000</b>)
<a>10000</a> != (<a>10000</a>,<b>50000</b>)
<a>10000</a> < (<a>10000</a>,<b>50000</b>)
<a>10000</a> <= (<a>10000</a>,<b>50000</b>)
<a>10000</a> = (<a>10000</a>,<b>50000</b>)
<a>10000</a> > (<a>10000</a>,<b>50000</b>)
<a>10000</a> >= (<a>10000</a>,<b>50000</b>)
() != (<a>10000</a>,<b>50000</b>)
() < (<a>10000</a>,<b>50000</b>)
() <= (<a>10000</a>,<b>50000</b>)
() = (<a>10000</a>,<b>50000</b>)
() > (<a>10000</a>,<b>50000</b>)
() >= (<a>10000</a>,<b>50000</b>)
(<a>10000</a>,<b>50000</b>) != ()
(<a>10000</a>,<b>50000</b>) < ()
(<a>10000</a>,<b>50000</b>) <= ()
(<a>10000</a>,<b>50000</b>) = ()
(<a>10000</a>,<b>50000</b>) > ()
(<a>10000</a>,<b>50000</b>) >= ()
(          <a>10000</a>,<b>50000</b>) < ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(<a>10000</a>,<b>50000</b>) != ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(<a>10000</a>,<b>50000</b>) <= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(<a>10000</a>,<b>50000</b>) = ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(<a>10000</a>,<b>50000</b>) > ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(<a>10000</a>,<b>50000</b>) >= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(<a>10000</a>,<b>50000</b>) != 10000
(<a>10000</a>,<b>50000</b>) < 10000
(<a>10000</a>,<b>50000</b>) <= 10000
(<a>10000</a>,<b>50000</b>) = 10000
(<a>10000</a>,<b>50000</b>) > 10000
(<a>10000</a>,<b>50000</b>) >= 10000
(<a>10000</a>,<b>50000</b>) != (10000,50000)
(<a>10000</a>,<b>50000</b>) < (10000,50000)
(<a>10000</a>,<b>50000</b>) <= (10000,50000)
(<a>10000</a>,<b>50000</b>) = (10000,50000)
(<a>10000</a>,<b>50000</b>) > (10000,50000)
(<a>10000</a>,<b>50000</b>) >= (10000,50000)
(<a>10000</a>,<b>50000</b>) != (50000)
(<a>10000</a>,<b>50000</b>) < (50000)
(<a>10000</a>,<b>50000</b>) <= (50000)
(<a>10000</a>,<b>50000</b>) = (50000)
(<a>10000</a>,<b>50000</b>) > (50000)
(<a>10000</a>,<b>50000</b>) >= (50000)
(<a>10000</a>,<b>50000</b>) != (<a>10000</a>)
(<a>10000</a>,<b>50000</b>) != <a>10000</a>
(<a>10000</a>,<b>50000</b>) < (<a>10000</a>)
(<a>10000</a>,<b>50000</b>) < <a>10000</a>
(<a>10000</a>,<b>50000</b>) <= (<a>10000</a>)
(<a>10000</a>,<b>50000</b>) <= <a>10000</a>
(<a>10000</a>,<b>50000</b>) = (<a>10000</a>)
(<a>10000</a>,<b>50000</b>) = <a>10000</a>
(<a>10000</a>,<b>50000</b>) > (<a>10000</a>)
(<a>10000</a>,<b>50000</b>) > <a>10000</a>
(<a>10000</a>,<b>50000</b>) >= (<a>10000</a>)
(<a>10000</a>,<b>50000</b>) >= <a>10000</a>
(<a>10000</a>,<b>50000</b>) != (<a>10000</a>,<b>50000</b>)
(<a>10000</a>,<b>50000</b>) < (<a>10000</a>,<b>50000</b>)
(<a>10000</a>,<b>50000</b>) <= (<a>10000</a>,<b>50000</b>)
(<a>10000</a>,<b>50000</b>) = (<a>10000</a>,<b>50000</b>)
(<a>10000</a>,<b>50000</b>) > (<a>10000</a>,<b>50000</b>)
(<a>10000</a>,<b>50000</b>) >= (<a>10000</a>,<b>50000</b>)
(<a>10000</a>,<b>50000</b>) != (/works/employee[1]/hours[1])
(<a>10000</a>,<b>50000</b>) < (/works/employee[1]/hours[1])
(<a>10000</a>,<b>50000</b>) <= (/works/employee[1]/hours[1])
(<a>10000</a>,<b>50000</b>) = (/works/employee[1]/hours[1])
(<a>10000</a>,<b>50000</b>) > (/works/employee[1]/hours[1])
(<a>10000</a>,<b>50000</b>) >= (/works/employee[1]/hours[1])
(<a>10000</a>,<b>50000</b>) != (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(<a>10000</a>,<b>50000</b>) < (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(<a>10000</a>,<b>50000</b>) <= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(<a>10000</a>,<b>50000</b>) = (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(<a>10000</a>,<b>50000</b>) > (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(<a>10000</a>,<b>50000</b>) >= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(<a>10000</a>) != (/works/employee[1]/hours[1])
(<a>10000</a>) < (/works/employee[1]/hours[1])
(<a>10000</a>) <= (/works/employee[1]/hours[1])
(<a>10000</a>) = (/works/employee[1]/hours[1])
(<a>10000</a>) > (/works/employee[1]/hours[1])
(<a>10000</a>) >= (/works/employee[1]/hours[1])
<a>10000</a> != (/works/employee[1]/hours[1])
<a>10000</a> < (/works/employee[1]/hours[1])
<a>10000</a> <= (/works/employee[1]/hours[1])
<a>10000</a> = (/works/employee[1]/hours[1])
<a>10000</a> > (/works/employee[1]/hours[1])
<a>10000</a> >= (/works/employee[1]/hours[1])
(<a>10000</a>) != (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(<a>10000</a>) < (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(<a>10000</a>) <= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(<a>10000</a>) = (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(<a>10000</a>) > (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(<a>10000</a>) >= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
<a>10000</a> != (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
<a>10000</a> < (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
<a>10000</a> <= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
<a>10000</a> = (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
<a>10000</a> > (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
<a>10000</a> >= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
<a> 1 </a> * <b> 2 </b>
<a> 1 </a> + <b> 2 </b>
<a>1</a> + <b>2</b>
(<a>1</a>,<b>2</b>)/(if(position() eq 1) then . else data(.))
<a> 1 </a> div <b> 2 </b>
<a> 1 </a> idiv <b> 2 </b>
<a> 1 </a> mod <b> 2 </b>
<a/>/1/node()
<a/>/20[text()]
'a'[2147483649]
<a>&#223;</a>
<a> 2 </a> - <b> 1 </b>
'a'[4294967296]
'a'[4294967297]
<a>50000</a> << <a>50000</a>
<a>50000</a> >> <a>50000</a>
<a>50000</a> is <a>50000</a>
<a>50000</a> is (/staff[1]/employee[1]/empnum[1])
<a>50000</a> is /works[1]/employee[1]/empnum[1]
<a>50000</a> << (/staff[1]/employee[1]/empnum[1])
<a>50000</a> >> (/staff[1]/employee[1]/empnum[1])
<a>50000</a> << /works[1]/employee[1]/empnum[1]
<a>50000</a> >> /works[1]/employee[1]/empnum[1]
<a></a>
<a> { <a b="blah"/>/@*/self::attribute(b) } </a>
<a>abc</a>/text()/node-name()
<a>{<!-- a comment -->/*}</a>
"a" and '0'
<a attr
<a attr=
<a attr="a" attr="a" />
<a attr="con
<a attr='con
<a attr="content"
<a attr='content'
<a>{attribute name{"content"}/*}</a>
<a> { attribute { 'prefix:localName' } { } } </a>
<a> { attribute xml:id {"1"} } </a>
<a> { attribute { 'xmlns' } { 'http://www.w3.org/' } } </a>
<a> { attribute xml:space {"DEFAULT"} } </a>
<?a?><?b ?>
<a b='1'/
<a b="1"/a="1"/>
<a b="1">a="1"/>
<a b='1'/a='1'/>
<a b='1'>a='1'/>
<a b="1" c="1"/>
<a b='1' c='1'/>
<a b="3"/>/(@b, upper-case#1)
(<a b="3"/>/(string(@b), upper-case#1, 17))[. instance of xs:anyAtomicType]
<a><b/></a>/(b instance of element(), * instance of element())
<a> { <b />, attribute foo { 'bar' } } </a>
<a/>/<b>{.}</b>
<a b=``[c]``/>
[ "a", "b", "c" ]
['A', 'B', 'C']?*
(<a/>, <b/>, <c/>)[1][1]
['A', 'B', 'C']?(2 to 3)
("abc" || "abc") and ("abc" || "abc")
("abc" || "abc" ||  fn:concat#3)
["a", "b", "c"] => array:get(2)
["a", ["b", "c"]] => array:get(2)
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])?()
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])?*
[['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b']]?*?*
[['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b']]!.?*!.?1
[['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b']]!?*!?1
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])?(1.0)
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])?1.0
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[.?(1.0) = 'a']
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[.?1.0 = 'a']
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[?(1.0) = 'a']
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[?1.0 = 'a']
[['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b']]?*[.?1 = 'a']
[['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b']]?*[?1 = 'a']
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])?(1 to 2)
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[ .?(1 to 2) = 'b']
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[ ?(1 to 2) = 'b']
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[ .?* = 'c']
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[ ?* = 'c']
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[contains(.?1, ?)('a')]
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[contains(?1, ?)('a')]
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[exists(.?())]
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[exists(?())]
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b']) ?first
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[ .?first = 'b']
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[ ?first = 'b']
<a><b><c/><b/><d/>
("abc") castable as xs:integer?
("abc") castable as xs:string?
<a> <b c=""> <c/> </b> <d/> </a>/b/c/ancestor::*
<a> <b c=""> <c/> </b> <d/> </a>/b/c/(ancestor::*)[1]
<a> <b c=""> <c/> </b> <d/> </a>/b/c/ancestor::*[1]
<a> <b c=""> <c/> </b> <d/> </a>/b/c/ancestor::*[fn:last()]
<a> <b c=""> <c/> </b> <d/> </a>/b/c/(ancestor::*)[last()]
<a> <b c=""> <c/> </b> <d/> </a>//count(ancestor::*)
<a> <b c=""> <c/> </b> <d/> </a>//count(ancestor-or-self::*)
( ["a", "b", "c"], "d" )
[ ("a", "b", "c"), "d" ]
[["a", "b", "c"], "d" ]
("AB" || "CD")
(['a', 'b'], ['c', 'd'])?0
(['a', 'b'], ['c', 'd'])? 001
(['a', 'b'], ['c', 'd'])[ .? 001 eq 'c']
(['a', 'b'], ['c', 'd'])[ ? 001 eq 'c']
(['a', 'b'], ['c', 'd'])[ .?0 eq 'c']
(['a', 'b'], ['c', 'd'])[ ?0 eq 'c']
(['a', 'b'], ['c', 'd'])? -1
(['a', 'b'], ['c', 'd'])?1
(['a', 'b'], ['c', 'd'])[ .? -1 eq 'c']
(['a', 'b'], ['c', 'd'])[ ? -1 eq 'c']
(['a', 'b'], ['c', 'd'])[.?1 eq 'c']
(['a', 'b'], ['c', 'd'])[?1 eq 'c']
<a><b><c/><d/><a/>
<a> <b c=""/> <d/> </a>/descendant-or-self::node()[last()]
<a> <b c=""/> <d/> </a>/descendant-or-self::node()[last()]/ancestor::*
<a> <b c=""/> <d/> </a>//node()/../count(.)
("abc" || "de")
[['A', 'B', 'C'], ['D', 'E'], []]?1?2
(['a', 'b'], ['c', 'd'], ['e'])?2
(['A', 'B', 'C'], ['D', 'E'])?2
(['A', 'B', 'C'], ['D', 'E'], [])?2
(['a', 'b'], ['c', 'd'], ['e'])[ .?2 eq 'b']
(['a', 'b'], ['c', 'd'], ['e'])[ ?2 eq 'b']
("ABCDE" || "abcde")
("ABC", "DEF","A")[fn:string-length(.) gt 2]
("abc","def") castable as xs:integer?
("abc","def") castable as xs:string?
('a' ||  'b' ||  'c' ||  () ||  'd' ||  'e' ||  'f' ||  'g' ||  'h' ||  ' ' ||  'i' ||  'j' ||  'k l') eq "abcdefgh ijk l"
("ab","cde","fgh") instance of xs:integer*
("ab","cde","fgh") instance of xs:string*
("ab" ||  "c") eq "abc"
"abc" eq concat("a", "bc")
"abc" eq string(/works/@id)
"abc" eq /works/@id
"abc" eq xs:string(/works/@id)
'abc' ge 'a'
'abc' ge 'abc'
'abc' gt 'a'
( (<a><b>cheese</b></a>)/b )[1]
( (<a><b>cheese</b></a>)/b )[last()]
("ab" ||  "c") instance of xs:string
'abc' le 'abc'
"abc" ne concat("a", "bc")
"abc" ne string(/works/@id)
"abc" ne /works/@id
"abc" ne xs:string(/works/@id)
'abc'=>substring(1,2)
['a', 'b', 'c'] treat as array(*) ? 1
['a', 'b', 'c'] treat as array(*)??1
'abc'=>upper-case()
("A","B","C")[xs:string(.)]
<a> <b id="person0"> <c/> </b> </a>/*[attribute::id eq "person0"]/c
<a> <b id="person0"> <c/> </b> </a>/*[@id eq "person0"]/c
(<a/>, <b/>)/(if (position() mod 2 = 1) then position() else .)
<a><b name="C"/><b name= "D"/></a>//b[@name="D"][last() = 1]
abs()
abs(-10.5) eq 10.5
abs(10.5) eq 10.5
abs(1, 2)
(abs(3.5))
(abs(3.5), abs(-4), abs(xs:float('-INF')))
(abs(-4))
abs("a string")
abs(xs:byte(.)) instance of xs:byte
(abs(xs:float('-INF')))
abs(xs:int(.)) instance of xs:int
abs(xs:long(.)) instance of xs:long
abs(xs:negativeInteger(.)) instance of xs:negativeInteger
abs(xs:nonNegativeInteger(.)) instance of          xs:nonNegativeInteger
abs(xs:nonPositiveInteger(.)) instance of          xs:nonPositiveInteger
abs(xs:positiveInteger(.)) instance of xs:positiveInteger
abs(xs:short(.)) instance of xs:short
abs(xs:unsignedByte(.)) instance of xs:unsignedByte
abs(xs:unsignedInt(.)) instance of xs:unsignedInt
abs(xs:unsignedLong(.)) instance of xs:unsignedLong
abs(xs:unsignedShort(.)) instance of xs:unsignedShort
<a> <![CDATA[ ]]> {"abc"}</a>
<a>{comment {"content"}/*}</a>
<!-- a comment --> instance of comment()
<a> <!-- content --> {attribute name{"content"}} </a>
<a>{<e foo="content2" bar="content1"/>/attribute(foo)}</a>
<a> { element { 'prefix:localName' } { } } </a>
<a:elem xmlns:a="http://example.com/NS" xmlns:b="http://example.com/NS"></b:elem>
<a/> except <b/>
<a />/fn:idref('id')
<a foo="1"fb="1"/>
<a foo='1'fb='1'/>
<a foo="1"/>/@foo + <b foo="2"/>/@foo
'a' le 'abc'
(//*:all-of)[1] ! fn:path()
(<?alpha?>, <?beta?>, <?gamma?>)/processing-instruction(Q{}alpha)
'a' lt 'abc'
<(:a misplaced comment:)ncname/>
"&amp;"
"" and ''
() and ()
() and (0)
() and (1)
"" and 'a'
"a" or '0'
"&apos;"
<a>{processing-instruction name {"content"}/*}</a>
<a> { processing-instruction { 'xml' } { 'content' } } </a>
array()
array { "a", "b", "c" }
array {["a", "b", "c"], "d" }
array:append([], [])
array:append([],"3")
array:append(["a","b"],())
array:append(["a","b"],"3")
array:append(["a",["b"]],[3])
array:append(["a", "b", "c"], "d")
array:append(["a","b"],("c","d"))
array:append(["a", "b", "c"], ("d", "e"))
array:append(["a", "b", "c"], ["d", "e"])
array:append(array:append(["a","b"],"c"),"d")
array:filter([10, 20, 30, 0], function($x){ 20 idiv $x eq 5})
array:filter([[2,3],[],[4,5,6,7],[6,7],[3]], function($a){array:size($a) gt 1})
array:filter([4,5,6],function($n) {$n > 4})
array:filter([4,5,6],function($n) {$n > 6})
array:filter(["A", "B", "", 0, 1], boolean#1)
array:filter(["A", "B", 1, 2], function($x) {$x instance of xs:integer})
array:filter(["A", "B", 1, 2], function($z) {$z instance of xs:integer})
array:filter(["ab","aa","xy"],starts-with#2(?,"a"))
array:filter(['apple', 'banana', 'cherry', 17], substring-after(?, "e"))
array:filter(['apple', 'banana', 'cherry'], contains(?, "e"))
array:filter(['apple', 'banana', 'cherry'], substring-after#2)
array:filter([], contains(?, ""))
array:filter(["the cat", "sat", "on the mat"], function($s){count(tokenize($s, " ")) gt 1})
array:filter(["the cat", "sat", "on the mat"], function($s){fn:count(fn:tokenize($s)) gt 1})
array:flatten(())
array:flatten([])
array:flatten([(1,0), (1,1), (0,1), (0,0)])
array:flatten(([1, 2, 5], [[10, 11], 12], [], 13))
array:flatten([1, 4, 6, 5, 3])
array:flatten(([1, [4, [6, 9]]]))
array:flatten((1, 4, 6, 9))
array:flatten( ("a", "b", "c") )
array:flatten(["a", "b", "c"])
array:flatten( (["a", "b"],["c", "d"]) )
array:flatten( (["a", "b"],["c", ["d"],["e"]]) )
array:flatten((map{}, map{1:[2,3]}, map{1:[2], 2:[3]}))
array:flatten((map{}, map{1:2}, map{1:2, 2:3}))
array:fold-left([], 0, function($a, $b) { $a + $b })
array:fold-left([1,2,3], 0, function($a, $b) { $a + $b })
array:fold-left([1,2,3,4,5,6], 0, function($a, $b) { $a + $b })
array:fold-left([1,2,3,4,5,6], 0, function($z,$a){$z + $a})
array:fold-left([1,2,3], [], function($x, $y){[$x, $y]})
array:fold-left(["+2", "*3"], "10", function($z,$a){concat("(", $z, $a, ")")})
array:fold-left([[2,3],[],[4,5,6,7],[6,7],[3]], 0, function($z,$a){$z + array:size($a)})
array:fold-left( ["a","b","c"], "", concat(?,?) )
array:fold-left(["a","b","c"], "", function($a, $b) { concat($a,$b) })
array:fold-left(["a","b","c"], "", function($a, $b) { concat($b,$a) })
array:fold-left(["a","b","c"], "x", function($a, $b) { concat($a,',',$b) })
array:fold-left([function($x){$x+2}, function($x){$x*3}], 10, function($z,$a){$a($z)})
array:fold-left(["the cat", "sat", "on the mat"], "", function($z,$a){concat($z, " ", $a)})
array:fold-left([true(), true(), false()], false(), function($x, $y){$x or $y})
array:fold-left([true(), true(), false()], true(), function($x, $y){$x and $y})
array:fold-right([], 0, function($a, $b) { $a + $b })
array:fold-right([1,2,3], 0, function($a, $b) { $a + $b })
array:fold-right([1,2,3,4,5,6], 0, function($a, $b) { $a + $b })
array:fold-right([1,2,3,4,5,6], 0, function($a,$z){$a + $z})
array:fold-right([true(), true(), false()], false(), function($x, $y){$x or $y})
array:fold-right([true(), true(), false()], true(), function($x, $y){$x and $y})
array:for-each([10,20,30,40], remove#2)
array:for-each([10,20,30,40], upper-case#1)
array:for-each([[2,3],[4,5,6,7],[6,7],[],[3]], array:insert-before(?,1,1))
array:for-each([[2,3],[4,5,6,7],[6,7],[],[3]], array:size(?))
array:for-each(["A", "B", 1, 2], function($z) {$z instance of xs:integer})
array:for-each( ["a","b","c"], function($x) {$x,"x"} )
array:for-each( ["a","b","c"], function($x) {concat($x,"x")} )
array:for-each( ["a","b","c"], string-to-codepoints(?) )
array:for-each-pair([1,2,3,4,5], [1,2,3,4,5], function($a, $b){$a * $b})
array:for-each-pair([1,2,3,4,5], [2,4,6,8,10,12,14], function($a,$b){$a + $b})
array:for-each-pair([], [1, 2], contains#2)
array:for-each-pair(['a', 'b'], [1, 2], contains#2)
array:for-each-pair(['a', 'b'], [1, 2], true#0)
array:for-each-pair(["A", "B", "C"], [1, 2, 3], function($x, $y) {[$x, $y]})
array:for-each-pair(["A", "B", "C"], [1, 2, 3], function($x, $y) { array {$x, $y}})
array:for-each-pair([["a","b","c"],["d","e","f"],["g","h","i"]], [1,2,3], array:remove#2)
array:for-each-pair(["a", "b", "c", "d", "e"], ["x", "y", "z"], concat#2)
array:for-each-pair(["a", "b", "c"], ["x", "y", "z"], concat#2)
array:for-each-pair(["a", "b", "c"], ["x", "y", "z"], function($a, $b){$a, $b})
array:for-each-pair([], [], contains#2)
array:for-each-pair([function($x){$x+2},function($x){$x*2},function($x){$x*$x}], [3,4,5], function($a,$b){$a($b)})
array:for-each(["the cat", "sat", "on the mat"], fn:tokenize#1)
array:for-each(["the cat", "sat", "on the mat"], tokenize(?, " "))
array:for-each([], tokenize(?, " "))
array:get((), 1)
array:get([], 1)
array:get([1,2,3], ())
array:get([1,2,3], 1.2)
array:get([1,2,3], 1 to 2)
array:get([1], 4294967297)
array:get([5,6,7], 0)
array:get([5,6,7], -1)
array:get([5,6,7], 1)
array:get([5,[6,7]], 2)
array:head([])
array:head([(), 1])
array:head([[1,[2],3], [4,5,6]])
array:head([(1, [<e><f>g</f></e>, "b"], 2)])
array:head([5, 6, 7, 8])
array:head([5,6,7,8])
array:head(["abc"])
array:head([("a", "b"), ("c", "d")])
array:head([["a", "b"], ["c", "d"]])
array:head(["abc","def","ghi"])
array:head(array { (1 to 100) [. eq year-from-date(current-date())] })
array:head(array { (), (27, 17, 0) })
array:insert-before([], 1, ())
array:insert-before([1], 4294967297, 22)
array:insert-before([], 2, ())
array:insert-before([4,5,[6]], 0, "a")
array:insert-before(["a", "b", "c", "d"], 1, ([],[]))
array:insert-before(["a", "b", "c", "d"], 3, ("x", "y"))
array:insert-before(["a", "b", "c", "d"], 3, ["x", "y"])
array:insert-before(["a", "b", "c", "d"], 5, ("x", "y"))
array:join(())
array:join(([()], [()], [()]))
array:join(([], [], []))
array:join([()])
array:join([])
array:join(([],[1,2],[]))
array:join([1,2])
array:join([1, 2, 3])
array:join(([1,2],[3,4]))
array:join((               [[(1,2)]],               [[(3,4)],(5,6)],               [7],            []            ))
array:join(([], [()], [], [4], [], [<e>f</e>, <!-- 234 -->], [], [] ))
array:join((["a", "b"], ["c", "d"]))
array:join((["a", "b"], ["c", "d"], [ ]))
array:join((["a", "b"], ["c", "d"], [["e", "f"]]))
array:join((["a","b","c"], ["d"], [["e","f"]]))
array { //product,( "a", "b", "c"),"d"}
array:put([1], 1, ())
array:put([1], 4294967297, 2)
array:put([], 2, ())
array:put([4,5,[6]], 0, "a")
array:put([4,5,[6]], 4, "a")
array:put([4,5,[6]], -842, "a")
array:put(["a"], 1, ["d", "e"])
array:put(["a", "b", "c"], 2, "d")
array:put(["a", "b", "c"], 2, ("d", "e"))
array:put(["a", "b", "c", "d"], 1, ([],[]))
array:put(["a", "b", "c", "d"], 3, ("x", "y"))
array:put(["a", "b", "c", "d"], 3, ["x", "y"])
array:put(["a", "b", "c", "d"], 4, ("x", "y"))
array:remove([], 1)
array:remove([[(1,2)]], 1)
array:remove([[(1,2)],[(1,2)]], 1)
array:remove([[(1,2)],[(1,2)]], 3)
array:remove([[(1,2)]], -3)
array:remove([1], 4294967297)
array:remove([4,5,6], 0)
array:remove([4,5,6], 4)
array:remove(["a"], 1)
array:remove(["a", "b", "c", "d"], ())
array:remove(["a", "b", "c", "d"], 1)
array:remove(["a", "b", "c", "d"], (1 to 3))
array:remove(["a", "b", "c", "d"], 1 to 3)
array:remove(["a", "b", "c", "d"], 2)
array:remove(["a", "b", "c", "d"], (3, 2, 1, 2))
array:remove(["a", "b", "c", "d"], (4 to 5))
array:remove(["a", ["b", ()], ["d"]], 2)
array:reverse([ ])
array:reverse([])
array:reverse([(1 to 5)])
array:reverse(["abc"])
array:reverse([("a","b","c")])
array:reverse(["a", "b", "c", "d"])
array:reverse([("a", "b"), ("c", "d")])
array:reverse(["abc","def","ghi"])
array:size([ ])
array:size([[ ]])
array:size([[],[]])
array:size([])
array:size([1, 2, 3])
array:size([(),(2,3), ()])
array:size([2,[3,4]])
array:size([2,3,4])
array:size(["a", "b", "c"])
array:size(["a", ["b", "c"]])
array:size(["a","b","c","d"])
array:size([(), ('A', 'B', 'C'), 'D'])
array:size(["abc", ["def", "ghi"]])
array:size(["a","","c",""])
array:size(array{(), ('A', 'B', 'C'), 'D'})
array:sort([(1,0), (1,1), (0,1), (0,0)])
array:sort([1, 4, 6, 5, 3])
array:sort([6,2,4])
array:sort([("a","c","b"), ("a","b","f")])
array:subarray([1, (2,[2]), 3], 2, 20)
array:subarray([1, (2,2), 3], 3, 0)
array:subarray([[[1]],(2,2),3], 3, 1)
array:subarray([1, (2,[2]), 3], 4, 1)
array:subarray([1,2,3], 0)
array:subarray([1,2,3], 2, -1)
array:subarray([1,2,3], 2, 3)
array:subarray([1,2,3,4,5], 1, 4294967297)
array:subarray([1,2,3,4,5], 4294967297, 2)
array:subarray(["a", (1,2,3,4), [(),0], "d", (), ""], 2, 4)
array:subarray(["a", "b", "c", "d"], 2)
array:subarray(["a", "b", "c", "d"], 2, 0)
array:subarray(["a", "b", "c", "d"], 2, 1)
array:subarray(["a", "b", "c", "d"], 2, 2)
array:subarray(["a", "b", "c", "d"], 2, 3)
array:tail([()])
array:tail([])
array:tail([          [1,[[2]]],          <e/>,             (<f/>,<g/>)           ])
array:tail([5])
array:tail([5, 6, 7, 8])
array:tail([5,6,7,8])
array:tail(["abc"])
array:tail([["a", "b"], ["c", "d"]])
array:tail(["abc","def","ghi"])
as
< asd />
"a string &"
"a string &#;"
"a string &;"
"a string" }
"a string &#1233 98;"
"a string &#1233.98;"
"a string &#1233a98;"
"a string" = "a string"
"a string" != "a stringDIFF"
"A String" cast as xs:string
"a string" eq xs:untypedAtomic("a string")
"A String Function" instance of xs:anyURI
"A String Function" instance of xs:boolean
"A String Function" instance of xs:date
"A String Function" instance of xs:dateTime
"A String Function" instance of xs:decimal
"A String Function" instance of xs:double
"A String Function" instance of xs:float
"A String Function" instance of xs:int
"A String Function" instance of xs:integer
"A String Function" instance of xs:string
"A String Function" instance of xs:time
"a string" instance of xs:string
"a string is ok" and QName("", "local")
"a string is ok" or QName("", "local")
"a string &LT;"
"a string &lte;"
"a string &#x;"
"a string &#x543 3;"
"a string &#x543.3;"
"a string &#x543g3;"
"a string" = xs:untypedAtomic("a string")
"a string" != xs:untypedAtomic("a stringDIFF")
<a>{(<?target content?>, attribute name{"content"})[2]} </a>
<a> <?target content?> {<b>{attribute name{"content"}}</b>} </a>
<a>{<?target data?>/*}</a>
<a>{text{()}}</a>
(/atomic:root/atomic:base64Binary/text()) | (/atomic:root/atomic:base64Binary/text())
(/atomic:root/atomic:base64Binary/text()) except (/atomic:root/atomic:base64Binary/text())
(/atomic:root/atomic:base64Binary/text()) intersect (/atomic:root/atomic:base64Binary/text())
(/atomic:root/atomic:date/text()) | (/atomic:root/atomic:date/text())
(/atomic:root/atomic:date/text()) except (/atomic:root/atomic:date/text())
(/atomic:root/atomic:date/text()) intersect (/atomic:root/atomic:date/text())
(/atomic:root/atomic:duration/text()) | (/atomic:root/atomic:duration/text())
(/atomic:root/atomic:duration/text()) except (/atomic:root/atomic:duration/text())
(/atomic:root/atomic:duration/text()) intersect (/atomic:root/atomic:duration/text())
(/atomic:root/atomic:idrefs/text()) | (/atomic:root/atomic:idrefs/text())
(/atomic:root/atomic:idrefs/text()) intersect (/atomic:root/atomic:idrefs/text())
(/atomic:root/atomic:integer) | (/atomic:root/atomic:string)
(/atomic:root/atomic:integer) except (/atomic:root/atomic:integer)
(/atomic:root/atomic:integer) intersect (/atomic:root/atomic:integer)
(/atomic:root/atomic:integer) intersect (/atomic:root/atomic:string)
(/atomic:root/atomic:integer) union (/atomic:root/atomic:integer)
(/atomic:root/atomic:QName/text()) | (/atomic:root/atomic:QName/text())
(/atomic:root/atomic:QName/text()) except (/atomic:root/atomic:QName/text())
(/atomic:root/atomic:QName/text()) intersect (/atomic:root/atomic:QName/text())
attribute(1)
attribute { 1 } { 1 }
attribute a { avg#1 }
attribute {"aPrefix:localName"} {"content"}
attribute aPrefix:localName {"content"}
attribute e{"content"} instance of attribute()
attribute e{"content"} instance of attribute(*)
attribute e{"content"} instance of attribute(e)
attribute e{"content"} instance of attribute(name)
attribute e{"content"} instance of element()
attribute e{"content"} instance of element(*)
attribute e{"content"} instance of element(e)
attribute "name" {"content"}
attribute(notBound:ncname)
attribute xmlns {}
attribute {"xmlns"} {"content"}
attribute xmlns {"content"}
attribute {"xmlns:localName"} {"content"}
attribute xmlns:localName {"content"}
attribute {xs:untypedAtomic("aPrefix::localName")} {"content"}
//author | ()
//author except ()
//author except //nonexisting
//author intersect ()
//author intersect //nonexisting
//author union //nonexisting
avg()
avg((1, 1))
(avg( (1, 2, 3, (), 4, 5) ))
(avg( (1, 2, 3, 4, 5) ))
avg((1, 2, 3, xs:anyURI("a string"), xs:double("NaN")))
avg((1, 2, xs:untypedAtomic("3"))) eq 2
avg((1, 2, xs:untypedAtomic("3"))) instance of xs:double
avg(1, "wrong param")
avg((-3, -3, -3)) eq -3
avg((3, 3, 3)) eq 3
avg((3, 4, 5)) eq 4.0
avg((-5, -0, -3, -6)) eq -3.5
avg("a string")
avg(xs:anyURI("a string"))
avg((xs:double("NaN"), current-date() - xs:date("1997-01-01") ))
avg((xs:double("NaN"), day-from-date(current-date())))
avg(xs:duration("P1Y1M1D"))
avg((xs:float(1), 2, xs:untypedAtomic("3"))) eq 2
avg((xs:float(1), 2, xs:untypedAtomic("3"))) instance of xs:double
avg((xs:float(1), xs:integer(0), xs:float(5))) eq 2.0
avg((xs:float(1), xs:integer(0), xs:untypedAtomic(3))) instance of xs:double
avg((xs:float(1), xs:integer(0), xs:untypedAtomic(-4))) eq -1
avg((xs:float(1), xs:integer(3), xs:decimal(3))) instance of xs:float
avg((xs:float(1), xs:integer(3), xs:double(3))) instance of xs:double
avg((xs:float(1), xs:integer(3), xs:float(3))) instance of xs:float
avg((xs:float(2), xs:integer(3), "a string", xs:double(2)))
avg((xs:float('NaN'), 2, 3.3, 4, xs:double('NaN'))) instance of xs:double
avg((xs:float('NaN'), 2, 3, 4, xs:double('NaN'))) instance of xs:double
avg((xs:float("NaN"), day-from-date(current-date())))
avg((xs:integer(1), xs:integer(3), xs:decimal(3))) instance of xs:decimal
avg((xs:string(1), xs:integer(3), xs:untypedAtomic(3)))
avg(xs:untypedAtomic("3")) instance of xs:double
avg((xs:untypedAtomic(3), xs:integer(0), xs:decimal(1))) instance of xs:double
avg((xs:untypedAtomic(3), xs:integer(3), xs:string(1)))
avg((xs:yearMonthDuration("P1Y"), xs:dayTimeDuration("P1D")))
avg((xs:yearMonthDuration("P20Y"), (3, 4, 5)))
<a xml:id="1"/>
<a xmlns="{1}" />
<a xmlns="http://www.w3.org/" xmlns="http://www.w3.org/" />
<a xmlns:prefix="{1}" />
<a xmlns:prefix="http://www.w3.org/" xmlns:prefix="http://www.w3.org/" />
<a xmlns:p="urn:abbrev:NS"><b p:c="" p:d=""/></a>
<a xml:space="   preserve"/>
<a xml:space="PRESERVE"/>
<a xml:space="space"/>
"a xs:string" instance of xs:string
<bad-character-reference>&#xa999999999999999a;</bad-character-reference>
()?banana
<b attr="f"/>[1]
/bib/book[1]/title except /bib/book[1]/title
(/bib/book[1]/title intersect /bib/book[1]/title)/string()
(/bib/book[3] except root(exactly-one(/bib/book[3]/title)))/string(@year)
/bib/book[3]/title intersect root(exactly-one(/bib/book[3]/title))
/bib/book[3]/title | root(fn:exactly-one(/bib/book[3]/title))
/bib/book[3]/title/text() | /bib/book[1]/title
/bib/book[3]/title/text() except /bib/book/title/text()
/bib/book[3]/title/text() intersect /bib/book/title/text()
/bib/book[3]/title/text() union /bib/book[1]/title
/bib/book[3]/title union /bib/book[1]/title
/bib/book except /bib/book
(/bib/book intersect /bib/book)/string(@year)
(/bib/book/price/text()) and (1)
(/bib/book/price/text()) and (/bib/book/price/text())
(/bib/book/price/text()) or (1)
(/bib/book/price/text()) or (/bib/book/price/text())
(/bib/book/title | /bib/book)/local-name()
/bib/book/title except /bib/book[1]/title
/bib/book/title intersect /bib/book[1]/title
<bib> {         for $b in /bib/book         where $b/publisher = "Addison-Wesley" and $b/@year > 1991         return <book year="{ $b/@year }">{ $b/title }</book> }         </bib>
<bib> {         for $b in //book[author]         return <book>         { $b/title } { $b/author } </book> }         { for $b in //book[editor]         return <reference> { $b/title } {$b/editor/affiliation} </reference> }         </bib>
<bib> {         for $b in //book         where $b/publisher = "Addison-Wesley" and $b/@year > 1991         order by exactly-one($b/title)         return <book> { $b/@year } { $b/title } </book> }         </bib>
<bib> {         for $b in //book         where count($b/author) > 0         return <book>         { $b/title }         { for $a in $b/author[position()<=2] return $a }         { if (count($b/author) > 2) then <et-al/> else () }         </book> }         </bib>
"boo" cast as xs:error
//book/price, (), (1)
//book/price, //book/title
<books-with-prices> {          for $b in $bib//book, $a in $reviews//entry          where $b/title = $a/title          return <book-with-prices> { $b/title } <price-bstore2>{ $a/price/text() }</price-bstore2> <price-bstore1>{ $b/price/text() }</price-bstore1> </book-with-prices> } </books-with-prices>
boolean('""')
boolean()
boolean(-1)
boolean(1)
boolean((1, 0))
boolean(1.1)
boolean(1.1e1)
boolean((1, 2))
boolean(1, "wrong param")
boolean((/, 93.7))
boolean((93.7, /))
boolean(("", "a"))
boolean(array{})
boolean(avg(()))
boolean(boolean#1)
boolean(//employee[location = "Denver"] | //employee[last()])
boolean(//employee[location = "Denver"] except //employee[last()])
boolean(//employee[location = "Denver"] intersect //employee[last()])
boolean(//employee[location = "Denver"] union //employee[last()])
boolean(empty(for $x in (1 to 10)[. mod 2 = 0] return "blah"))
boolean( exactly-one( remove( (<a/>, 1), 1 ) ) )
boolean((for $i in (false(), true(), true(), false(), true(), false()) order by $i return $i)[1])
boolean(index-of((1 to 10)[. mod 2 = 0],4))
boolean(index-of((1 to 10)[. mod 2 = 0],5))
boolean(map{})
boolean(map{0:"false", 1:"true"})
boolean('nada')
boolean(//*:NotAtAllOpen)
boolean(one-or-more((1 to 10)[. mod 2 = 0]))
boolean(one-or-more(for $x in (1 to 10)[. div 2 = 1] return true()))
boolean(one-or-more(for $x in 1 to month-from-date(current-date()) return <a/>))
boolean(one-or-more(month-from-date(current-date()) to 0))
boolean(//*:Open)
boolean("string")
boolean(string(false()))
boolean(sum((1 to 10)[. mod 2 = 0]))
boolean(translate(string-join(for $x in 1 to 10 return "blah","-"),exactly-one(("--","==")[position() mod 2 = 0]),"__"))
boolean([true()])
boolean(true())
boolean((true(), //aspidistra))
boolean((true(), false()))
boolean(typeswitch (current-time(), 1, 3e3, "foo") case node() return 0 case xs:integer return 3 case xs:anyAtomicType return true() default return -1)
boolean(unordered(reverse((1 to 10)[. div 2 = 2])))
boolean(xs:anyURI("example.com/"))
boolean(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext"))
boolean(xs:base64Binary("aaaa"))
boolean(xs:boolean("true"))
boolean(xs:date("2004-10-13"))
boolean(xs:dateTime("2002-10-10T12:00:00-05:00"))
boolean(xs:dayTimeDuration("P3DT2H"))
boolean(xs:decimal("10.01"))
boolean(xs:double("3.3e3"))
boolean(xs:duration("P1Y2M3DT10H30M"))
boolean(xs:float("3.4e5"))
boolean(xs:gDay("---03"))
boolean(xs:gMonth("--11"))
boolean(xs:gMonthDay("--11-13"))
boolean(xs:gYear("1999"))
boolean(xs:gYearMonth("1999-11"))
boolean(xs:hexBinary("03"))
boolean(xs:hexBinary("0FB7"))
boolean(xs:integer("6789"))
boolean(xs:QName("ncname"))
boolean(xs:QName("valid-local-name"))
boolean(xs:string("an arbitrary string"))
boolean(xs:time("03:20:00-05:00"))
boolean(xs:untypedAtomic("an arbitrary string(untypedAtomic source)"))
boolean(xs:untypedAtomic("string"))
boolean(xs:yearMonthDuration("P1Y12M"))
<b/>[self::b][last()]
() castable as xs:error?
() castable as xs:integer?
() castable as xs:NOTATION
() castable as xs:NOTATION?
() castable as xs:QName?
() cast as xs:error?
() cast as xs:integer
() cast as xs:NOTATION
() cast as xs:NOTATION?
() cast as xs:QName
. cast as xs:QName
(/ catalog/product[last()])
<c b="a    string literal  "/>
<![CDATA[a string]]>
<![CDATA[content]]>
(ceiling( () ))
ceiling()
ceiling(0.0)
ceiling(0.000000001)
ceiling(0.000000001e0)
ceiling(0.0e0)
ceiling(-0.1)
ceiling(-0.1e0)
ceiling(-10.5) eq -10
ceiling(10.5) eq 11
ceiling(1, 2)
ceiling(-12345678.567890)
ceiling(-12345678.567890e0)
ceiling(-1234567891234567.2)
ceiling(-1234567891234567.2e0)
ceiling(12.5)
ceiling(12.5e0)
ceiling(12.9)
ceiling(12.9e0)
(ceiling(5))
(ceiling(5.1))
(ceiling(-5.5))
(ceiling(5.5))
(ceiling(-5.51))
(ceiling(5), ceiling(5.1), ceiling(5.5), ceiling(-5.5), ceiling(-5.51), ceiling( () ))
ceiling("a string")
ceiling(xs:byte(.)) instance of xs:integer
ceiling(xs:double('-0'))
ceiling(xs:double('-INF'))
ceiling(xs:double('INF'))
ceiling(xs:double('NaN'))
ceiling(xs:float(0.000000001e0))
ceiling(xs:float(0.0e0))
ceiling(xs:float(-0.1e0))
ceiling(xs:float(-1234567.2e0))
ceiling(xs:float(-12345678.1e0))
ceiling(xs:float(12.5e0))
ceiling(xs:float(12.9e0))
ceiling(xs:float(xs:float('-0')))
ceiling(xs:float(xs:float('-INF')))
ceiling(xs:float(xs:float('INF')))
ceiling(xs:float(xs:float('NaN')))
ceiling(xs:int(.)) instance of xs:integer
ceiling(xs:long(.)) instance of xs:integer
ceiling(xs:negativeInteger(.)) instance of xs:integer
ceiling(xs:nonNegativeInteger(.)) instance of xs:integer
ceiling(xs:nonPositiveInteger(.)) instance of xs:integer
ceiling(xs:positiveInteger(.)) instance of xs:integer
ceiling(xs:short(.)) instance of xs:integer
ceiling(xs:unsignedByte(.)) instance of xs:integer
ceiling(xs:unsignedInt(.)) instance of xs:integer
ceiling(xs:unsignedLong(.)) instance of xs:integer
ceiling(xs:unsignedShort(.)) instance of xs:integer
child:
child::element
child::local:b(:ada
/child::works/child::employee[fn:position() = 5]/child::hours[fn:position() = 2]
('Ciao!' || ())
(codepoint-equal('abc', ()))
(codepoint-equal('abc', 'ab c'))
(codepoint-equal('abc', 'abc'))
(codepoint-equal('abc', 'abc'), codepoint-equal('abc', 'ab c'), codepoint-equal('abc', ()))
codepoint-equal(lower-case(concat("B STRING", current-time())),                              lower-case(concat("b string", current-time())))
codepoint-equal(lower-case(concat("B STRING", current-time())),                              lower-case(concat("no match", current-time())))
codepoint-equal(lower-case(concat("B STRING", current-time())),                              upper-case(concat("no match", current-time())))
codepoint-equal(upper-case(concat("B STRING", current-time())),                              lower-case(concat("no match", current-time())))
codepoint-equal(upper-case(concat("B STRING", current-time())),                              upper-case(concat("b string", current-time())))
codepoint-equal(upper-case(concat("B STRING", current-time())),                              upper-case(concat("no match", current-time())))
<codepoints>{string-to-codepoints(<elem>1 2</elem>)}</codepoints>
<codepoints>{string-to-codepoints(<elem>1&#xa;2</elem>) }</codepoints>
<codepoints>{string-to-codepoints(<elem>&#xD;</elem>)}</codepoints>
<codepoints>{string-to-codepoints(<elem>&#xD;&#xA;</elem>)}</codepoints>
(codepoints-to-string(()))
codepoints-to-string(())
codepoints-to-string((),())
codepoints-to-string()
codepoints-to-string(0)
codepoints-to-string(10) eq " "
codepoints-to-string(11)
codepoints-to-string(1114111) eq "􏿿"
codepoints-to-string(1114112)
codepoints-to-string((119070, 119070, 119070, 119070) (:treble clef:)) castable as xs:base64Binary
codepoints-to-string(12)
codepoints-to-string(13) eq "&#xD;"
codepoints-to-string(27637) eq "毵"
codepoints-to-string(32) eq " "
codepoints-to-string(-500)
codepoints-to-string(55295) eq "퟿"
codepoints-to-string(55296)
codepoints-to-string(57343)
codepoints-to-string(57344) eq ""
codepoints-to-string(589823) eq "򏿿"
codepoints-to-string(61438) eq ""
codepoints-to-string(65533) eq "�"
codepoints-to-string(65534)
codepoints-to-string(65535)
codepoints-to-string(65536) eq "𐀀"
codepoints-to-string(8)
codepoints-to-string((84, 104), "INVALID")
codepoints-to-string((87, 36, 56, 87, 102, 96)) eq "W$8Wf`"
(codepoints-to-string(97))
(codepoints-to-string((97, 32, 98, 32, 99)))
(codepoints-to-string((97, 32, 98, 32, 99)), codepoints-to-string(97), codepoints-to-string(()))
codepoints-to-string((97, 98, 99, 119126, 100, 101, 102))
codepoints-to-string((98,223,1682,12365,63744))
codepoints-to-string(9) eq " "
codepoints-to-string(()) eq ""
codepoints-to-string('hello')
codepoints-to-string(one-or-more(string-to-codepoints("foo")))
codepoints-to-string(xs:NMTOKENS('30 31 32 33'))
/comment()
<!--com--ment-->
<!--comment--->
<!--comment-->
comment {()}
comment {., .}
comment(*)
comment{}
comment(1)
comment {1,'',2}
comment {1,<a/>,2}
comment {1,'string',3.14,xs:float('1.2345e-2'),xs:dateTime('2002-04-02T12:00:00-01:00')}
/comment() | /bib/book[1]/title
comment {'com','-','-','ment'}
comment {comment {'one', comment {'two'}}, 'three', comment {'four'}}
comment {<elem>123</elem>, (<elem attr='456'/>)/@attr, (<elem>789</elem>)/text()}
/comment() except /comment()
comment {"name"} {"content"}
comment name {"content"}
comment {/root}
/comment() union /bib/book[1]/title
(compare('a', ()))
(compare('a', 'a'))
(compare('a', 'b'))
(compare('a', 'B'))
(compare('ab', 'abc'))
(compare('a', 'b'), compare('a', 'a'), compare('b', 'a'), compare('ab', 'abc'), compare('a', 'B'), compare(upper-case('a'), upper-case('B')), compare('a', ()))
compare('a', 'b', 'http://www.cbcl.co.u,/collation')
(compare('b', 'a'))
(compare(upper-case('a'), upper-case('B')))
concat()
concat("1", "2", "3", ("a", "b"), "c")
concat("1", "2", "3", "c", ("a", "b"))
concat(1, "2", 3) eq "123"
concat(1, 2, 3) eq "123"
concat#2("one", ?, "three")
concat#3("one", "two")
concat#4("one", ?, "three")
(concat('a', 'b'))
(concat('a', 'b', 'c'))
(concat('a', (), 'b', '', 'c'))
concat(("a", "b"), "c")
concat('a', 'b', 'c', (), 'd', 'e', 'f', 'g', 'h', ' ', 'i', 'j', 'k l') eq "abcdefgh ijk l"
concat("ab", "c") eq "abc"
concat("ab", "c") instance of xs:string
(concat('a', 'b'), concat('a', 'b', 'c'), concat('a', (), 'b', '', 'c'), concat('a', <x>b</x>, 'c'))
concat("a string")
concat(<a>X</a>, <a>Y</a>)
(concat('a', <x>b</x>, 'c'))
concat("b", xs:anyURI(" "), "b")
("concat" || "concat")
concat((), ()) eq ""
concat('#', fn:substring(./concepts/@id, string-length(./concepts/@id) - 18, 1), '#')
concat("http://www.example.com/", encode-for-uri("100% organic"))
concat("http://www.example.com/", encode-for-uri("100% organic")) eq "http://www.example.com/100%25%20organic"
concat("http://www.example.com/",                   encode-for-uri("~bébé"))
concat("http://www.example.com/", encode-for-uri("~bébé")) eq "http://www.example.com/~b%C3%A9b%C3%A9"
concat((), ()) instance of xs:string
(concat("one ", ?, " three"), substring-before("one two three", ?), matches(?, "t.*o"), xs:NCName(?))("two")
construction gt construction
contains("", ())
contains(())
contains()
contains("a string", ())
contains("a string", "a string", "http://www.example.com/COLLATION/NOT/SUPPORTED")
contains("foo", "foo")
contains((), (), "http://www.w3.org/2005/xpath-functions/collation/codepoint", "wrong param")
(contains( (), 'q'))
(contains('query', ''))
(contains('query', ()))
(contains('query', 'e'))
(contains('query', 'e'), contains('query', 'ery'), contains('query', 'query'), contains('query', 'x'), contains('query', ''), contains('query', ()), contains( (), 'q'))
(contains('query', 'ery'))
(contains('query', 'query'))
(contains('query', 'x'))
contains("tattoo", "t")
<!-- content
<!-- content -
count(() << ())
count(() >> ())
count()
count((0, current-time())) ge 1
count((0, current-time())) ne 0
count((0, timezone-from-time(current-time()))) != 0
count((0, timezone-from-time(current-time()))) >= 1
count(0 to 4) eq 5
count(1, ())
count((10, 1 to 4)) eq 5
count([1, 2, 3])
count( (1, 2, 3) ) eq 3
count((1, 2, 3, "four")) eq 4
count((1, 2, 3, timezone-from-time(current-time()), 4)) > 0
count((1, 2, 3, timezone-from-time(current-time()), 4)) >= 0
count((1, 2, 3, timezone-from-time(current-time()), 4)) and count((1, 2, 3, timezone-from-time(current-time()), 4))
count((1, 2, 3, timezone-from-time(current-time()), 4)) and true()
count((1, 2, 3, timezone-from-time(current-time()), 4)) ge 1
count((1, 2, 3, timezone-from-time(current-time()), 4)) gt 0
count((1, 2, 3, timezone-from-time(current-time()), 4)) or count((1, 2, 3, timezone-from-time(current-time()), 4))
count((1, 2, 3, timezone-from-time(current-time()), 4)) or false()
count( (1, 2, ()) ) eq 2
count((1, 2)) eq 2
count((15 to 10))
count(1 to 3) eq 3
count(1 to 4) eq 4
count(-5 to -0) eq 6
count((<a>0</a>,<a>1</a>) intersect (<a>3</a>,<a>4</a>))
count(() << <a>50000</a>)
count(() >> <a>50000</a>)
count(<a>50000</a> << ())
count(<a>50000</a> >> ())
count(<a>50000</a> is ())
count(<a></a>/node())
count(<a><b/></a>/*/subsequence(.,1,1)/..)
count(<a><b/><b/></a>/b[1]/following-sibling::*)
count(<a><b/><b/></a>/b[1]/preceding-sibling::b)
count(<a><b/><b/></a>/b[2]/preceding-sibling::*)
count(<a><b/><b/></a>/b[2]/preceding-sibling::b)
count(<a b="blah"/>/child::attribute(b))
count(<a> <b c=""> <c/> </b> <d/> </a>/b/c/(ancestor::*))
count(<a> <b c=""> <c/> </b> <d/> </a>/b/c/(ancestor-or-self::*))
count(<a> <b c=""/> <d/> </a>/descendant-or-self::node())
count(<a> <b c=""/> <d/> </a>//node())
count((<a/>, <!--comment-->)/3)
count(<a/>/node())
count(<a>{text {''}}<b/>{text {''}}<b/>{text {''}}</a>/text())
count((attribute attr {})/..)
count((comment {'comment'})/..)
count(data((1, 2, 3, 4, 5))) eq 5
count(<e/>/(a except attribute {"name"} {()}))
count(<e/>/(a except attribute name {()}))
count(<e/>/(a except comment {()}))
count(<e/>/(a except element {"name"} {()}))
count(<e/>/(a except element name {()}))
count(<e/>/(a except processing-instruction {"name"} {()}))
count(<e/>/(a except processing-instruction name {}))
count(<e/>/(a except text {()}))
count((<elem/>)/..)
count((<elem>{1,'a',3.5,4e2}</elem>)/text())
count((<elem>{1,'a',<a/>,3.5,4e2}</elem>)/text())
count((<elem>a{1,2,3}b</elem>)/text())
count((<elem>a{1,<a/>,3}b</elem>)/text())
count(<elem><![CDATA[]]></elem>/text())
count((<elem>{''}</elem>)/text())
count((<elem>{()}</elem>)/text())
count((element elem {})/..)
count((element elem {1, 2, <a/>, 3, 4, <b/>, 5, 6})/text())
count((element elem {1, 'string', 1,2e3})/text())
count((element elem {1, //text(), 'string'})/text())
count(element elem {text {''}}/text())
count(<elem>str{""}asdas{"asd", "asd", "''", ""}{''}asd{''}{''}</elem>/text())
count((<elem>text<![CDATA[cdata]]></elem>)/text())
count((<elem>text</elem>)/text())
count(<elem>{text {'te'}, text {'xt'}}</elem>/text())
count(<e/>/(let $i := . return (string($i), data($i))))
count(//employee[if (salary castable as xs:integer) then xs:integer(salary) gt 65000 else false()])
count(//employee[@name='John Doe 4']) > 0
count(//employee[@name='John Doe 4']) = 1
count(//employee[@name='John Doe 4']) < 2
count(//employee[@name='John Doe 4']/@name) > 0.5
count(//employee[salary castable as xs:integer][xs:integer(salary) gt 65000])
count( (((), (), ()), (), (), (), ()) ) eq 0
count( () ) eq 0
count(((((()))))) eq 0
count(()) eq 0
count(exactly-one( "one" )) eq 1
count(() except (<a>3</a>,<a>4</a>,<a>0</a>))
count(<e xmlns="http://example.com/"><a xmlns=""/></e>/namespace-uri(exactly-one(*)))
count(for $e in unordered(reverse(/works/employee)) return $e/@gender)
count((for $fo in (1, 2, 3) where xs:time("08:08:23Z") return $fo)) eq 3
count(for $i in (1, 2, current-time()) return ($i, $i)) eq 6
count(for $i in (1, 2, timezone-from-time(current-time())) return ($i, $i)) eq 6 or count(for $i in (1, 2, timezone-from-time(current-time())) return ($i, $i)) eq 4
count(for $s in ("red", "blue", "green") return string-to-codepoints($s))
count((for $x in 1 to 10 return $x * $x)[position() < 3])
count(index-of((1, 2, 3, 2, 1), 1)) eq 2
count(index-of((1, 2, 3, 2, 1), 2)) eq 2
count(index-of((1, 2, 3, 2, 1), 3)) eq 1
count(index-of((1, 2, 3, 2, 1), 4)) eq 0
count(insert-before((), 1, (1, 2, 3))) eq 3
count(insert-before((1, 2, 3), 1, (4, 5, 6))) eq 6
count(insert-before((1, 2, 3), 30, (4, 5, 6))) eq 6
count(insert-before((1, 2, 3, 4), 1, ())) eq 4
count(insert-before((1, 2, 3, 4), 30, ())) eq 4
count(insert-before((), 30, (1, 2, 3))) eq 3
count(() intersect ())
count(() is ())
count(() is <a>50000</a>)
count(() is (/staff[1]/employee[1]/empnum[1]))
count(() is /works[1]/employee[1]/empnum[1])
count( let $N := <n x="this ain't no date"/> return $N[if (@x castable as xs:date) then xs:date(@x) gt xs:date("2000-01-01") else false()] )
count(map{'decimal':true(), 'integer':true(), 'polygon':false()}?*[.])
count(//*[@name='John Doe 498']) eq 0
count(//*[@name='John Doe 4']) eq 0
count(//*[@name='John Doe 4']) eq 0.3
count(//*[@name='John Doe 4']) gt -5
count(//*[@name='John Doe 4']) lt 1000000000000
count(//*[@name='John Doe 4']) lt 1.5
count(//node()) gt 40
count(//node()) ne -1
count( ("one", (2, "three")) ) eq 3
count( ((), "one", 2, "three")) eq 3
count(one-or-more( (1, 2, 3, "four") )) eq 4
count(one-or-more( "one" )) eq 1
count((processing-instruction pi {()})/..)
count(remove((1, 2, 3), 0)) eq 3
count(remove((1, 2, 3), -4)) eq 3
count(remove((1, 2, "three"), 3)) eq 2
count(remove((1, "two", 3), 2)) eq 2
count(remove(current-time(), 1)) eq 0
count(remove(("one", 2, 3), 1)) eq 2
count(remove(remove((current-time(), 1), 1), 1)) = 0
count(remove(remove((current-time(), 1), 1), 1)) eq 0
count(reverse((1, 2, 3)))
count(reverse((1, 2, 3))) eq 3
count(reverse(1 to 4)) eq 4
count(reverse(-5 to -0)) eq 6
count(reverse(-5 to -2)) eq 4
count(<root> <child/> <child/> <child attr="foo" attr2="foo"/> </root>/child[1]/following-sibling::node())
count(<root> <child/> </root>/following-sibling::node())
count(() << /staff[1]/employee[1]/empnum[1])
count(() >> (/staff[1]/employee[1]/empnum[1]))
count((/staff[1]/employee[1]/empnum[1]) << ())
count((/staff[1]/employee[1]/empnum[1]) >> ())
count((/staff[1]/employee[1]/empnum[1]) is ())
count(string-to-codepoints("123")) eq 3
count(string-to-codepoints("")) eq 0
count(subsequence((1, 2, 2, current-time()), 2, 2)) eq 2
count(subsequence((1, 2), 2)) eq 1
count(subsequence((1, 2, 3), 1, 1)) eq 1
count(subsequence((1, 2, 3), 1, 3)) eq 3
count(subsequence((1, 2, 3, "four"), 2, 2)) eq 2
count(subsequence((1, 2, 3, "four"), 2)) eq 3
count(subsequence((1, 2, 3, "four"), 4, 1)) eq 1
count(subsequence((1, 2, 3, "four"), 4)) eq 1
count(subsequence(1 to 100, -2147483648, 20))
count(subsequence(1 to 10, 2, xs:double("NaN")))
count(subsequence(1 to 10, xs:double("-INF")))
count(subsequence(1 to 10, xs:double("-INF"), xs:double("INF")))
count(subsequence(1 to 10, xs:double("NaN")))
count(subsequence(1 to 10, xs:double("NaN"), 4))
count(subsequence(1 to 3000000000, -2147483649))
count(subsequence(1 to 3, 1, 1)) eq 1
count(subsequence((current-time(), 1), 4)) eq 0
count(subsequence((current-time(), 2 , 3), 1)) eq 3
count(subsequence((current-time(), 2 , 3), 3)) eq 1
count(subsequence((current-time(), 2 , 3, 4), 2, 2)) eq 2
count(subsequence(remove(current-time(), 1), 1, 1)) eq 0
count(tail("a"))
count(text {''})
count(text {()})
count((text {'text'})/..)
count(unordered((1, 2, 3))) eq 3
count(unordered((1, 2, current-time()))) eq 3
count(unordered(for $e in reverse(/works/employee) return $e/@gender))
count(unordered(reverse(for $i in (1,2,1) return /works/employee)))
count(unordered(reverse(/works/employee[@name] | /works/employee[@gender])))
count(/ ! works)
count(() << /works[1]/employee[1]/empnum[1])
count(() >> /works[1]/employee[1]/empnum[1])
count(/works[1]/employee[1]/empnum[1] << ())
count(/works[1]/employee[1]/empnum[1] >> ())
count(/works[1]/employee[1]/empnum[1] is ())
count((/works//day)[last()]/unordered(ancestor-or-self::*))
count(/works/employee[last()]/unordered(preceding::*))
count(/works/employee[last()]/unordered(preceding-sibling::*))
count(xs:base64Binary(()))
count(xs:float(()))
count(xs:hexBinary(()))
count(xs:hexBinary(xs:hexBinary("03"))) eq 1
count(xs:untypedAtomic("1") to 3) eq 3
count(zero-or-one( () )) eq 0
count(zero-or-one( "one" )) eq 1
<critical_sequence> { let $proc := //section[section.title="Procedure"][1], $i1 := ($proc//incision)[1], $i2 := ($proc//incision)[2] for $n in $proc//node() except $i1//node() where $n >> $i1 and $n << $i2 return $n } </critical_sequence>
current()
current-date() and 1
current-date() and current-date()
current-date()[current-date() => string() => string-length()] => string() => translate("0123456789", "xxxxxxxxxx")
current-date() eq current-date()
current-date() or 0
current-date() or current-date()
current-date() => string() => substring(1, 10) => translate("0123456789", "xxxxxxxxxx")
current-dateTime() eq current-dateTime()
current-dateTime("WRONG PARAM")
current-date("WRONG PARAM")
current-date() = xs:date(current-dateTime())
current-grouping-key()
current-time() eq current-time()
current-time("WRONG PARAM")
current-time() = xs:time(current-dateTime())
data()
data([])
data(1, 2)
data([1,2,3])
data(123)
data([[1,2],[3,4]])
data((123, 456))
data([(1,2), (3,4), (5,6)])
data([[1,2], [3,4], [5,6], []])
data([[1,2], [3,4], [5,6], [map{1:2}]])
data(1, "wrong param")
data([<a>1</a>, <a>2</a>, <a>3</a>])
data(abs#1)
data(<!-- a comment -->) instance of xs:string
data(attribute foo {"content"}) instance of xs:untypedAtomic
data(comment {"content"}) instance of xs:string
data(<e>dsa</e>)
data(<e>dsa</e>) instance of xs:untypedAtomic
data(<e foo="content"/>/@*) instance of xs:untypedAtomic
data(element foo {"dsa"})
data(element foo {"dsa"}) instance of xs:untypedAtomic
data(<e>text</e>)
data(function($a, $b) {$a + $b})
data(<name>some text</name>) instance of xs:untypedAtomic
data(processing-instruction name {"content"}) instance of xs:string
data(<?target content?>) instance of xs:string
data(<?target data?>) instance of xs:string
data(text {"content"}) instance of xs:untypedAtomic
data(text{"content"}) instance of xs:untypedAtomic
dateTime()
dateTime(xs:date('2001-01-01-14:00'), xs:time('01:01:01+14:00'))
dateTime(xs:date("2004-03-04"))
dateTime(xs:date("2004-03-04-00:00"), xs:time("08:05:23+00:00")) eq xs:dateTime("2004-03-04T08:05:23Z")
dateTime(xs:date("2004-03-04-00:01"), xs:time("08:05:23+00:01"))
dateTime(xs:date("2004-03-04-00:01"), xs:time("08:05:23Z"))
dateTime(xs:date("2004-03-04+11:00"), xs:time("08:05:23+11:00")) eq xs:dateTime("2004-03-04T08:05:23+11:00")
dateTime(xs:date("2004-03-04+11:00"), xs:time("08:05:23")) eq xs:dateTime("2004-03-04T08:05:23+11:00")
dateTime(xs:date("2004-03-04+13:07"), xs:time("08:05:23")) eq xs:dateTime("2004-03-04T08:05:23+13:07")
dateTime(xs:date("2004-03-04"), xs:time("08:05:23"), ())
dateTime(xs:date("2004-03-04"), xs:time("08:05:23-05:00")) eq xs:dateTime("2004-03-04T08:05:23-05:00")
dateTime(xs:date("2004-03-04"), xs:time("08:05:23+13:07")) eq xs:dateTime("2004-03-04T08:05:23+13:07")
dateTime(xs:date("2004-03-04"), xs:time("08:05:23")) eq xs:dateTime("2004-03-04T08:05:23")
dateTime(xs:date("2004-03-04"), xs:time("08:05:23Z")) eq xs:dateTime("2004-03-04T08:05:23Z")
dateTime(xs:date("2004-03-04Z"), xs:time("08:05:23")) eq xs:dateTime("2004-03-04T08:05:23Z")
dateTime(xs:date("2004-03-04Z"), xs:time("08:05:23Z")) eq xs:dateTime("2004-03-04T08:05:23Z")
(dateTime(xs:date('2006-08-15'), xs:time('12:30:45-05:00')))
day-from-date()
day-from-date(()) instance of xs:integer?
day-from-dateTime()
day-from-dateTime(()) instance of xs:integer?
day-from-dateTime((), "Wrong param")
day-from-dateTime(xs:dateTime("2001-02-03T08:23:12.43")) eq 3
(day-from-dateTime( xs:dateTime('2006-08-15T10:30:23')))
day-from-date((), "Wrong param")
day-from-date(xs:date("2000-02-03")) eq 3
(day-from-date(xs:date('2006-08-15')))
days-from-duration()
days-from-duration(()) instance of xs:integer?
days-from-duration((), "Wrong param")
(days-from-duration( xs:dayTimeDuration('P1DT36H')))
days-from-duration(xs:dayTimeDuration("-P45678DT8H2M1.03S")) eq -45678
days-from-duration(xs:dayTimeDuration("P45678DT8H2M1.03S")) eq 45678
(days-from-duration( xs:dayTimeDuration('P5D')))
(days-from-duration( xs:dayTimeDuration('P5D')), days-from-duration( xs:dayTimeDuration('-PT24H')), days-from-duration( xs:dayTimeDuration('PT23H')), days-from-duration( xs:dayTimeDuration('P1DT36H')), days-from-duration( xs:dayTimeDuration('PT1440M')))
(days-from-duration( xs:dayTimeDuration('PT1440M')))
(days-from-duration( xs:dayTimeDuration('PT23H')))
(days-from-duration( xs:dayTimeDuration('-PT24H')))
days-from-duration(xs:duration("-P3Y4M8DT1H23M2.34S")) eq -8
declare
declare boundary-space preserve; xquery version "1.0"; 1,2
declare(::)construction(::)Preserve;(::)1(::)eq(::)1
declare context item as xs:integer+ := (1 to 17)[position() = 5];         .
declare context item external;         . instance of document-node()
declare context item := last() + 1; .
declare context item := position() + 1; .
declare decimal-format local:df minus-sign="-" currency-symbol="¤" decimal-separator=".";        format-number(95.4857,'¤###.####', "local:df")
declare default decimal-format decimal-sprtr = ".";        true()
declare default decimal-format NaN = ``[not-a-number]``; 12
declare default function namespace "";         declare function foo ($n as xs:integer, $m as xs:integer) { $n };         foo(4, 1)
declare default function namespace ""; declare function foo() { 1 }; 1
declare default function namespace "%gg"; fn:true()
declare default function namespace "http://example.com";         declare function _() { 1 };         _()
declare default function namespace "http://example.com"; <e a="{count()}" xmlns="http://www.w3.org/2001/XMLSchema"/>
declare default function namespace "http://example.com"; <e a="{nametest}" xmlns="http://www.w3.org/2001/XMLSchema"/>
declare default function namespace "http://example.com"; <e a="{p:count()}" xmlns:p="http://www.w3.org/2001/XMLSchema"/>
declare default function namespace "http://example.com"; <e p:p="{p:nametest}" xmlns:p="http://www.w3.org/2001/XMLSchema"/>
declare default function namespace "http://example.com"; <e xmlns="http://www.w3.org/2001/XMLSchema" a="{count()}"/>
declare default function namespace "http://example.com"; <e xmlns="http://www.w3.org/2001/XMLSchema" a="{nametest}"/>
declare default function namespace "http://example.com"; <e xmlns:p="http://www.w3.org/2001/XMLSchema" a="{p:count()}"/>
declare default function namespace "http://example.com"; <e xmlns:p="http://www.w3.org/2001/XMLSchema" p:p="{p:nametest}"/>
declare default function namespace "http://example.com/functions";         declare variable $f := (if (fn:current-date() gt xs:date('1900-01-01')) then plus#2 else fn:round#2);         declare function plus($x, $y) {           $x + $y         };         $f(5, 7)
declare default function namespace "http://example.com/hof-006";        declare function g($x as xs:integer) as xs:integer { $x + 1 };        let $f := g#1 return $f(21)
declare default function namespace "http://www.example.com/"; declare function unordered() { 1 }; unordered()
declare default function namespace "http://www.example.com/"; declare namespace e = "http://www.example.com/"; declare function element() { 1 }; e:element()
declare default function namespace "http://www.example.org/"; declare default function namespace "http://www.w3.org/2005/xpath-functions/collation/codepoint"; 1 + 2
declare default function namespace "http://www.w3.org/2001/XMLSchema";        let $f := date#1 return $f('2008-01-31')
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function attribute() { fn:true() }; local:attribute()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function comment() { fn:true() }; local:comment()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function document-node() { fn:true() }; local:document-node()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function element() { fn:true() }; local:element()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function empty-sequence() { fn:true() }; local:empty-sequence()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions";          declare function exponent-separator () {110};          exponent-separator()          eq 110
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function function() { fn:true() }; local:function()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function if() { fn:true() }; local:if()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function item() { fn:true() }; local:item()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:array() { fn:true() }; array()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:attribute($arg) { fn:true() }; attribute(1)
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:comment($arg) { fn:true() }; comment(1)
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:document-node($arg) { fn:true() }; document-node(1)
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:element($arg) { fn:true() }; element(1)
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:empty-sequence() { fn:true() }; empty-sequence()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:function() { fn:true() }; function()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:if() { fn:true() }; if()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions";         declare function local:is() as xs:integer { 1 };         is() eq 1
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:item($arg) { fn:true() }; item(1)
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:map() { fn:true() }; map()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:namespace-node($arg) { fn:true() }; namespace-node(1)
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:node($arg) { fn:true() }; node(1)
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:processing-instruction($arg) { fn:true() }; processing-instruction(1)
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:schema-attribute() { fn:true() }; schema-attribute()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:schema-element() { fn:true() }; schema-element()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:switch() { fn:true() }; switch()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:text($arg) { fn:true() }; text(1)
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:typeswitch() { fn:true() }; typeswitch()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function namespace-node() { fn:true() }; local:namespace-node()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions";                    declare function NaN () {1};          declare function allowing () {2};          declare function ancestor-or-self () {3};          declare function ancestor () {4};          declare function and () {5};          declare function as () {6};          declare function ascending () {7};          declare function at () {8};          declare function base-uri () {9};          declare function boundary-space () {10};          declare function by () {11};          declare function case () {12};          declare function cast () {13};          declare function castable () {14};          declare function catch () {15};          declare function child () {16};          declare function collation () {17};          declare function construction () {18};          declare function context () {19};          declare function copy-namespaces () {20};          declare function count () {21};          declare function decimal-format () {22};          declare function decimal-separator () {23};          declare function declare () {24};          declare function default () {25};          declare function descendant-or-self () {26};          declare function descendant () {27};          declare function descending () {28};          declare function digit () {29};          declare function div () {30};          declare function document () {31};          declare function else () {32};          declare function empty () {33};          declare function encoding () {34};          declare function end () {35};          declare function eq () {36};          declare function every () {37};          declare function except () {38};          declare function external () {39};          declare function following-sibling () {40};          declare function following () {41};          declare function for () {42};          declare function ge () {43};          declare function greatest () {44};          declare function group () {45};          declare function grouping-separator () {46};          declare function gt () {47};          declare function idiv () {48};          declare function import () {49};          declare function in () {50};          declare function infinity () {51};          declare function inherit () {52};          declare function instance () {53};          declare function intersect () {54};          declare function is () {55};          declare function lax () {56};          declare function le () {57};          declare function least () {58};          declare function let () {59};          declare function lt () {60};          declare function minus-sign () {61};          declare function mod () {62};          declare function module () {63};          declare function namespace () {64};          declare function ne () {65};          declare function next () {66};          declare function no-inherit () {67};          declare function no-preserve () {68};          declare function of () {69};          declare function only () {70};          declare function option () {71};          declare function or () {72};          declare function order () {73};          declare function ordered () {74};          declare function ordering () {75};          declare function parent () {76};          declare function pattern-separator () {77};          declare function per-mille () {78};          declare function percent () {79};          declare function preceding-sibling () {80};          declare function preceding () {81};          declare function preserve () {82};          declare function previous () {83};          declare function return () {84};          declare function satisfies () {85};          declare function schema () {86};          declare function self () {87};          declare function sliding () {88};          declare function some () {89};          declare function stable () {90};          declare function start () {91};          declare function strict () {92};          declare function strip () {93};          declare function then () {94};          declare function to () {95};          declare function treat () {96};          declare function try () {97};          declare function tumbling () {98};          declare function type () {99};          declare function union () {100};          declare function unordered () {101};          declare function validate () {102};          declare function variable () {103};          declare function version () {104};          declare function when () {105};          declare function where () {106};          declare function window () {107};          declare function xquery () {108};          declare function zero-digit () {109};                    NaN() +          allowing() +          ancestor-or-self() +          ancestor() +          and() +          as() +          ascending() +          at() +          base-uri() +          boundary-space() +          by() +          case() +          cast() +          castable() +          catch() +          child() +          collation() +          construction() +          context() +          copy-namespaces() +          count() +          decimal-format() +          decimal-separator() +          declare() +          default() +          descendant-or-self() +          descendant() +          descending() +          digit() +          div() +          document() +          else() +          empty() +          encoding() +          end() +          eq() +          every() +          except() +          external() +          following-sibling() +          following() +          for() +          ge() +          greatest() +          group() +          grouping-separator() +          gt() +          idiv() +          import() +          in() +          infinity() +          inherit() +          instance() +          intersect() +          is() +          lax() +          le() +          least() +          let() +          lt() +          minus-sign() +          mod() +          module() +          namespace() +          ne() +          next() +          no-inherit() +          no-preserve() +          of() +          only() +          option() +          or() +          order() +          ordered() +          ordering() +          parent() +          pattern-separator() +          per-mille() +          percent() +          preceding-sibling() +          preceding() +          preserve() +          previous() +          return() +          satisfies() +          schema() +          self() +          sliding() +          some() +          stable() +          start() +          strict() +          strip() +          then() +          to() +          treat() +          try() +          tumbling() +          type() +          union() +          unordered() +          validate() +          variable() +          version() +          when() +          where() +          window() +          xquery() +          zero-digit()          eq (109 * (109 + 1)) div 2
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function node() { fn:true() }; local:node()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function processing-instruction() { fn:true() }; local:processing-instruction()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function schema-attribute() { fn:true() }; local:schema-attribute()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function schema-element() { fn:true() }; local:schema-element()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function switch() { fn:true() }; local:switch()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function text() { fn:true() }; local:text()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function typeswitch() { fn:true() }; local:typeswitch()
declare function fn:count($var) { fn:count($var) };         1
declare function foo ($n as xs:integer) { $n };         foo(4)
declare function foo() { 1 }; foo()
declare function foo() external; 1
declare function local:_($arg as attribute()?) { 1 };         local:_(1)
declare function local:_($arg as node()) { $arg };         local:_(1)
declare function local:_() { 1 };         local:_()
declare function local:aaa() { 1 };         declare variable $x external := local:bbb() + local:aaa();         declare function local:bbb() { 2 };         $x
declare function local:add($arg1, $arg2, $arg3)         {            $arg1 + $arg2 + $arg3         }; fn:function-name( local:add#3 )
declare function local:addNamespace($argElement as element(), $argPrefix as xs:string, $namespaceURI as xs:string) as element() {              element { QName($namespaceURI, concat($argPrefix, ":x")) }{$argElement}/*          };          local:addNamespace(<a><b/></a>, "prefix", "http://example.com/")
declare function local:aFunction() { (1, 2, 3, (4, <e/>/(<e/>, 2))) }; 1, local:aFunction()
declare function local:aFunction() { <e/>/(1, <e/>) }; 1, local:aFunction()
declare function local:aFunction() { (<e/>/(., 4, 5, <e/>/((<e/>, 2)))) }; 1, local:aFunction()
declare function local:aFunction() { <e/>/(<e/>, 2) }; 1, local:aFunction()
declare function local:aFunction() { (<e/>/., <e/>/((<e/>, 2), 1, 2)) }; 1, local:aFunction()
declare function local:apply($fns as (function(xs:string) as xs:string)*, $s as xs:string) as xs:string*          { for $f in $fns return $f($s) };          let $ops := (upper-case#1, lower-case#1, function($x as xs:double){string($x)})          return string-join(local:apply($ops, 'Michael Kay'), '~')
declare function local:apply($fns as (function(xs:string) as xs:string)*, $s as xs:string) as xs:string*          { for $f in $fns return $f($s) };          let $ops := (upper-case#1, lower-case#1, function($x){translate($x, 'e', 'i')},              string-length#1)          return string-join(local:apply($ops, 'Michael Kay'), '~')
declare function local:apply($fns as (function(xs:string) as xs:string)*, $s as xs:string) as xs:string* { for $f in $fns return $f($s) };        let $ops := (upper-case#1, lower-case#1, function($x){translate($x, 'e', 'i')}, substring-before(?, ' '))        return string-join(local:apply($ops, 'Michael Kay'), '~')
declare function local:bar($c, $d, $e, $f, $g, $h, $i, $j, $a, $b) { 1 };          declare function local:moo($k) { $k };          local:moo(1)
declare function local:base64Binary-value($arg as xs:boolean) as xs:base64Binary {         if ($arg) then xs:base64Binary('aGVsbG8=') else xs:base64Binary('Z29vZGJ5ZQ==')        };        local:base64Binary-value(true()) eq local:base64Binary-value(false())
declare function local:base64Binary-value($arg as xs:boolean) as xs:base64Binary {         if ($arg) then xs:base64Binary('aGVsbG8=') else xs:base64Binary('Z29vZGJ5ZQ==')         };         not(local:base64Binary-value(true()) eq local:base64Binary-value(false()))
declare function local:base64Binary-value($arg as xs:boolean) as xs:base64Binary {         if ($arg) then xs:base64Binary('aGVsbG8=') else xs:base64Binary('Z29vZGJ5ZQ==')         };         not(local:base64Binary-value(true()) ne local:base64Binary-value(false()))
declare function local:case($x as function(*), $y as xs:string) as xs:string { $x($y) };        local:case(upper-case#1, "Mike"), local:case(lower-case#1, "Mike")
declare function local:case($x as function(xs:string?) as xs:string, $y as xs:string) as xs:string { $x($y) };        local:case(upper-case#1, "Mike"), local:case(lower-case#1, "Mike")
declare function local:case($x as xs:boolean) as function(*)         { if ($x) then fn:upper-case#1 else fn:lower-case#1 };        local:case(true())("Mike"), local:case(false())("Mike")
declare function local:case($x as xs:boolean) as function(xs:string?) as xs:string         { if ($x) then fn:upper-case#1 else fn:lower-case#1 };        local:case(true())("Mike"), local:case(false())("Mike")
declare function local:children($n as node()) as node()*                  { $n/child::node() };              declare function local:attributes($e as node()) as node()*                  { $e/attribute::node() };              declare function local:self($e as node()) as node()                  { $e };              declare function local:union(                         $f as function(node()) as node()*,                          $g as function(node()) as node()*) as function(node()) as node()* {                  function($a) {$f($a) | $g($a)} };             let $data := (/a),                  $f := local:union(local:children#1, local:union(local:attributes#1, local:self#1))              return for-each($data/*, $f)[not(. instance of attribute())]
declare function local:clarkname($q as xs:QName) as xs:string {        concat('{', namespace-uri-from-QName($q), '}', local-name-from-QName($q))        };        local:clarkname(xs:QName("xs:integer"))
declare function local:compare($arg1 as xs:string, $arg2 as xs:string) {              let $cps1 := string-to-codepoints($arg1),              $cps2 := string-to-codepoints($arg2)              return abs(count($cps1) - count($cps2)) + sum(for $x in 1 to min((count($cps1), count($cps2)))                                                            return if ($cps1[$x] ne $cps2[$x]) then 1 else ()) };          local:compare("", ""),          local:compare("a", ""),          local:compare("", "a"),          local:compare("a", "a"),          local:compare("", "aa"),          local:compare("aa", "ab"),          local:compare("ba", "ba"),          local:compare("bab", "bbb"),          local:compare("aba", "bab")
declare function local:computeSum() { $myVariable };         declare variable $myVariable := 1;         1
declare function local:computeSum() { $prefix:myVariable };         declare namespaces prefix = "example.com/Anamespace";         1
declare function local:count($x) { count($x) }; local:count((1 to 100000, 1 to 100000))
declare function local:curry($f as function(item()*, item()*) as item()*) as function(item()*) as function(item()*) as item()*          {            function($a) { $f($a, ?) }          };                    local:curry(substring-after#2)("foobar")("foo")
declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date }; exists(local:date(xs:date("1972-12-15"), fn:true()) eq xs:date("1972-12-15"))
declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date };         exists(local:date(xs:date("1972-12-15"), fn:true()) ge xs:date("1972-12-15"))
declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date };         exists(local:date(xs:date("1972-12-15"), fn:true()) gt xs:date("1972-12-15"))
declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date };         exists(local:date(xs:date("1972-12-15"), fn:true()) le xs:date("1972-12-15"))
declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date };         exists(local:date(xs:date("1972-12-15"), fn:true()) lt xs:date("1972-12-15"))
declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date }; exists(local:date(xs:date("1972-12-15"), fn:true()) ne xs:date("1972-12-15"))
declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date }; local:date(xs:date("1972-12-15"), fn:false()) eq xs:date("1972-12-15")
declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date };         local:date(xs:date("1972-12-15"), fn:false()) ge xs:date("1972-12-15")
declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date };         local:date(xs:date("1972-12-15"), fn:false()) gt xs:date("1972-12-15")
declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date };         local:date(xs:date("1972-12-15"), fn:false()) le xs:date("1972-12-15")
declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date };         local:date(xs:date("1972-12-15"), fn:false()) lt xs:date("1972-12-15")
declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date }; local:date(xs:date("1972-12-15"), fn:false()) ne xs:date("1972-12-15")
declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; exists(local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:true()) eq xs:dateTime("1972-12-15T12:00:00"))
declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; exists(local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:true()) ge xs:dateTime("1972-12-15T12:00:00"))
declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; exists(local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:true()) gt xs:dateTime("1972-12-15T12:00:00"))
declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; exists(local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:true()) le xs:dateTime("1972-12-15T12:00:00"))
declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; exists(local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:true()) lt xs:dateTime("1972-12-15T12:00:00"))
declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; exists(local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:true()) ne xs:dateTime("1972-12-15T12:00:00"))
declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:false()) eq xs:dateTime("1972-12-15T12:00:00")
declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:false()) ge xs:dateTime("1972-12-15T12:00:00")
declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:false()) gt xs:dateTime("1972-12-15T12:00:00")
declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:false()) le xs:dateTime("1972-12-15T12:00:00")
declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:false()) lt xs:dateTime("1972-12-15T12:00:00")
declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:false()) ne xs:dateTime("1972-12-15T12:00:00")
declare function local:dayTimeDuration($days as xs:integer, $hours as xs:integer ) { xs:dayTimeDuration(concat('P', $days, 'DT', $hours, 'H')) }; local:dayTimeDuration(1, 1) + local:dayTimeDuration(1, 1)
declare function local:dayTimeDuration($days as xs:integer, $hours as xs:integer ) { xs:dayTimeDuration(concat('P', $days, 'DT', $hours, 'H')) }; local:dayTimeDuration(1, 1) - local:dayTimeDuration(1, 1)
declare function local:dayTimeDuration($days as xs:integer, $hours as xs:integer ) { xs:dayTimeDuration(concat('P', $days, 'DT', $hours, 'H')) }; local:dayTimeDuration(1, 1) + xs:dayTimeDuration("P0D")
declare function local:dayTimeDuration($days as xs:integer, $hours as xs:integer ) { xs:dayTimeDuration(concat('P', $days, 'DT', $hours, 'H')) }; local:dayTimeDuration(1, 1) - xs:dayTimeDuration("P0D")
declare function local:dayTimeDuration($days as xs:integer, $hours as xs:integer ) { xs:dayTimeDuration(concat('P', $days, 'DT', $hours, 'H')) }; not(local:dayTimeDuration(1, 1) eq xs:dayTimeDuration("P0D"))
declare function local:dayTimeDuration($days as xs:integer, $hours as xs:integer ) { xs:dayTimeDuration(concat('P', $days, 'DT', $hours, 'H')) };           not(local:dayTimeDuration(1, 1) ge xs:dayTimeDuration("P0D"))
declare function local:dayTimeDuration($days as xs:integer, $hours as xs:integer ) { xs:dayTimeDuration(concat('P', $days, 'DT', $hours, 'H')) };           not(local:dayTimeDuration(1, 1) gt xs:dayTimeDuration("P0D"))
declare function local:dayTimeDuration($days as xs:integer, $hours as xs:integer ) { xs:dayTimeDuration(concat('P', $days, 'DT', $hours, 'H')) }; not(local:dayTimeDuration(1, 1) le xs:dayTimeDuration("P0D"))
declare function local:dayTimeDuration($days as xs:integer, $hours as xs:integer ) { xs:dayTimeDuration(concat('P', $days, 'DT', $hours, 'H')) }; not(local:dayTimeDuration(1, 1) lt xs:dayTimeDuration("P0D"))
declare function local:dayTimeDuration($days as xs:integer, $hours as xs:integer ) { xs:dayTimeDuration(concat('P', $days, 'DT', $hours, 'H')) }; not(local:dayTimeDuration(1, 1) ne xs:dayTimeDuration("P0D"))
declare function local:dayTimeDuration($days as xs:integer, $hours as xs:integer ) { xs:dayTimeDuration(concat('P', $days, 'DT', $hours, 'H')) }; xs:dayTimeDuration("P0D") + local:dayTimeDuration(1, 1)
declare function local:dayTimeDuration($days as xs:integer, $hours as xs:integer ) { xs:dayTimeDuration(concat('P', $days, 'DT', $hours, 'H')) }; xs:dayTimeDuration("-P5000000000000000000D") - local:dayTimeDuration(5000000000000000000, 1)
declare function local:dayTimeDuration($days as xs:integer) as xs:dayTimeDuration { xs:dayTimeDuration(concat("P", $days, "D")) }; 0 * local:dayTimeDuration(2)
declare function local:dayTimeDuration($days as xs:integer) as xs:dayTimeDuration { xs:dayTimeDuration(concat("P", $days, "D")) }; 1 * local:dayTimeDuration(2)
declare function local:dayTimeDuration($days as xs:integer) as xs:dayTimeDuration { xs:dayTimeDuration(concat("P", $days, "D")) }; local:dayTimeDuration(2) * 0
declare function local:dayTimeDuration($days as xs:integer) as xs:dayTimeDuration { xs:dayTimeDuration(concat("P", $days, "D")) }; local:dayTimeDuration(2) * 1
declare function local:dayTimeDuration($days as xs:integer) as xs:dayTimeDuration { xs:dayTimeDuration(concat("P", $days, "D")) }; local:dayTimeDuration(2) div 0
declare function local:dayTimeDuration($days as xs:integer) as xs:dayTimeDuration { xs:dayTimeDuration(concat("P", $days, "D")) }; local:dayTimeDuration(2) div 1
declare function local:dayTimeDuration($days as xs:integer) as xs:dayTimeDuration { xs:dayTimeDuration(concat("P", $days, "D")) }; local:dayTimeDuration(2) * xs:double("NaN")
declare function local:dayTimeDuration($days as xs:integer) as xs:dayTimeDuration { xs:dayTimeDuration(concat("P", $days, "D")) }; xs:double("NaN") * local:dayTimeDuration(2)
declare function local:dayTimeDuration($dayTimeDuration as xs:dayTimeDuration, $null as xs:boolean) { if ($null) then () else $dayTimeDuration }; exists(local:dayTimeDuration(xs:dayTimeDuration("P0D"), fn:true()) eq xs:dayTimeDuration("P0D"))
declare function local:dayTimeDuration($dayTimeDuration as xs:dayTimeDuration, $null as xs:boolean) { if ($null) then () else $dayTimeDuration };           exists(local:dayTimeDuration(xs:dayTimeDuration("P0D"), fn:true()) gt xs:dayTimeDuration("P0D"))
declare function local:dayTimeDuration($dayTimeDuration as xs:dayTimeDuration, $null as xs:boolean) { if ($null) then () else $dayTimeDuration };           exists(local:dayTimeDuration(xs:dayTimeDuration("P0D"), fn:true()) le xs:dayTimeDuration("P0D"))
declare function local:dayTimeDuration($dayTimeDuration as xs:dayTimeDuration, $null as xs:boolean) { if ($null) then () else $dayTimeDuration }; exists(local:dayTimeDuration(xs:dayTimeDuration("P0D"), fn:true()) le xs:dayTimeDuration("P0D"))
declare function local:dayTimeDuration($dayTimeDuration as xs:dayTimeDuration, $null as xs:boolean) { if ($null) then () else $dayTimeDuration }; exists(local:dayTimeDuration(xs:dayTimeDuration("P0D"), fn:true()) lt xs:dayTimeDuration("P0D"))
declare function local:dayTimeDuration($dayTimeDuration as xs:dayTimeDuration, $null as xs:boolean) { if ($null) then () else $dayTimeDuration }; exists(local:dayTimeDuration(xs:dayTimeDuration("P0D"), fn:true()) ne xs:dayTimeDuration("P0D"))
declare function local:dayTimeDuration($dayTimeDuration as xs:dayTimeDuration, $null as xs:boolean) { if ($null) then () else $dayTimeDuration }; local:dayTimeDuration(xs:dayTimeDuration("P0D"), fn:false()) eq xs:dayTimeDuration("P0D")
declare function local:dayTimeDuration($dayTimeDuration as xs:dayTimeDuration, $null as xs:boolean) { if ($null) then () else $dayTimeDuration };           local:dayTimeDuration(xs:dayTimeDuration("P0D"), fn:false()) gt xs:dayTimeDuration("P0D")
declare function local:dayTimeDuration($dayTimeDuration as xs:dayTimeDuration, $null as xs:boolean) { if ($null) then () else $dayTimeDuration };           local:dayTimeDuration(xs:dayTimeDuration("P0D"), fn:false()) le xs:dayTimeDuration("P0D")
declare function local:dayTimeDuration($dayTimeDuration as xs:dayTimeDuration, $null as xs:boolean) { if ($null) then () else $dayTimeDuration }; local:dayTimeDuration(xs:dayTimeDuration("P0D"), fn:false()) le xs:dayTimeDuration("P0D")
declare function local:dayTimeDuration($dayTimeDuration as xs:dayTimeDuration, $null as xs:boolean) { if ($null) then () else $dayTimeDuration }; local:dayTimeDuration(xs:dayTimeDuration("P0D"), fn:false()) lt xs:dayTimeDuration("P0D")
declare function local:dayTimeDuration($dayTimeDuration as xs:dayTimeDuration, $null as xs:boolean) { if ($null) then () else $dayTimeDuration }; local:dayTimeDuration(xs:dayTimeDuration("P0D"), fn:false()) ne xs:dayTimeDuration("P0D")
declare function local:distinct-nodes-stable ($arg as node()*) as xs:boolean* { for $a in $arg return $a };         local:distinct-nodes-stable((<element1/>,<element2/>))
declare function local:distinct-nodes-stable($seq as node()*) {                  fold-left( $seq, (), function($foundSoFar as node()*, $this as node()) as node()* {                 if ($foundSoFar intersect $this)                 then $foundSoFar                 else ($foundSoFar, $this) })             };              let $nodes := (<a/>, <b/>, <c/>, <d/>, <e/>, <f/>)              let $perm := ($nodes[1], $nodes[2], $nodes[4], $nodes[1], $nodes[2], $nodes[3], $nodes[2], $nodes[1])              return local:distinct-nodes-stable($perm)/local-name()
declare function local:do() as xs:integer { (local:f#1)(5) };          declare function local:f($x as xs:integer) as xs:integer { $x + 1 };          local:do()
declare function local:duration($days as xs:integer, $hours as xs:integer) { xs:duration(concat('P', $days, 'DT', $hours, 'H')) }; not(local:duration(1, 1) eq xs:dayTimeDuration("P0D"))
declare function local:duration($days as xs:integer, $hours as xs:integer) { xs:duration(concat('P', $days, 'DT', $hours, 'H')) }; not(local:duration(1, 1) ne xs:dayTimeDuration("P0D"))
declare function local:duration($duration as xs:duration, $null as xs:boolean) { if ($null) then () else $duration }; exists(local:duration(xs:duration("P1DT1H"), fn:true()) eq xs:duration("P1DT1H"))
declare function local:duration($duration as xs:duration, $null as xs:boolean) { if ($null) then () else $duration }; exists(local:duration(xs:duration("P1DT1H"), fn:true()) ne xs:duration("P1DT1H"))
declare function local:duration($duration as xs:duration, $null as xs:boolean) { if ($null) then () else $duration }; local:duration(xs:duration("P1DT1H"), fn:false()) eq xs:duration("P1DT1H")
declare function local:duration($duration as xs:duration, $null as xs:boolean) { if ($null) then () else $duration }; local:duration(xs:duration("P1DT1H"), fn:false()) ne xs:duration("P1DT1H")
declare function local:durationOrFloat($i as xs:integer) { (xs:float(123), xs:float(234), xs:duration("P1D"))[$i] }; for $x in (xs:untypedAtomic("123"), xs:untypedAtomic("234")) for $y in (for $z in (1,2) return local:durationOrFloat($z)) where $x = $y return $x
declare function local:error() as none() { 1 };         local:error()
declare function local:error() as xs:error             {       1             };        local:error()
declare function local:even-range($arg as xs:integer) as xs:integer* { (1 to $arg)[. mod 2 = 9] };         <element> { attribute { 'attr' } { local:even-range(0) } } </element>
declare function local:exponent-separator () {126};          local:exponent-separator()          eq 126
declare function local:f($arg as xs:anyAtomicType?) { $arg };         local:f(index-of((1,2,3,2),2))
declare function local:f($in as xs:boolean) as xs:boolean { $in };          local:f(<a>0</a>)
declare function local:f($v as xs:double*) as xs:double+ { if (empty($v)) then 0 else $v };         declare function local:g($v as xs:double*) as xs:double+ { local:f($v) };         local:g((1,2,3))
declare function local:f($x, $y) {           let $a := $x           where empty($y)   (every $i in $x satisfies $i = $y)           return $a         };         local:f("x", ())
declare function local:f($x, $y) {             let $a := $x             where (every $i in $x satisfies $i = $y) or empty($y)             return $a         };         local:f("x", ())
declare function local:f($x, $y) {             let $a := $x             where (every $i in $x satisfies $i = $y) or empty($y)             return true()         };         local:f((current-date(), current-date(), current-date()), (current-date()))
declare function local:f($x as xs:integer, $y as xs:long) as xs:integer { $x + $y };        let $f as function(xs:integer, xs:long) as xs:integer := local:f#2        return $f(2, xs:long(5))
declare function local:f($x as xs:integer) as xs:integer { $x + 1 };         exists(data(local:f#1))
declare function local:f($x as xs:integer) as xs:integer { $x + 1 };        let $f as function(*) := local:f#1 return $f(2)
declare function local:f($x as xs:integer) as xs:integer {             $x + 1         };         let $f as function(xs:integer) := local:f#1         return $f(3)
declare function local:f($x as xs:integer) as xs:integer { $x + 1 };         let $f := concat#1 return $f('2008-03-01')
declare function local:f($x as xs:integer) as xs:integer { $x + 1 };          let $f := local:f#1 return $f(2)
declare function local:f($x as xs:integer) as xs:integer { $x + 1 };         let $f := local:f#3 return $f(2)
declare function local:f($x as xs:integer) as xs:integer { $x + 1 };         let $f := local:g#1 return $f(2)
declare function local:f($x as xs:integer) as xs:integer { $x + 1 };         let $f := xs:date#2 return $f('2008-03-01')
declare function local:f($x as xs:integer) as xs:integer { $x + 1 };         local:f#1 eq 3
declare function local:f($x as xs:integer) as xs:integer { $x + 1 };         number(local:f#1)
declare function local:f($x as xs:integer) as xs:integer { $x + 1 };         string(local:f#1)
declare function local:f($x as xs:integer) as xs:integer { $x + 3 };        declare function local:g($x as xs:integer) as xs:integer { $x + 4 };        declare function local:h($x as xs:integer) as xs:integer { $x + 5 };        let $f as (function(xs:integer) as xs:integer)* := (local:f#1, local:g#1, local:h#1) return $f[3](2)[1]
declare function local:f($x as xs:integer) as xs:integer { $x + 3 };        let $f as function(xs:integer) as xs:integer := local:f#1        return $f(2)
declare function local:f($x as xs:integer) as xs:integer { $x };         max(local:f(4) to local:f(10))
declare function local:f($x as xs:integer) as xs:integer { $x };         min(local:f(4) to local:f(10))
declare function local:f($x as xs:integer) as xs:integer { $x };         not(not(local:f(1)))
declare function local:f($x as xs:integer) as xs:integer* { 1 to $x }; deep-equal((local:f(3), 2), (local:f(3), 2, local:f(1)))
declare function local:f($x as xs:integer) as xs:integer* { 1 to $x };         not(exists(local:f(0)))
declare function local:f($x as xs:integer) { if ($x = 0) then false() else true() };         min(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) {         if ($x = 0) then true() else false()         };         max(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) { if ($x = 2) then false() else true() };         min(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) {         if ($x = 2) then true() else false()         };         max(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) { if ($x = 2) then xs:dateTime("1996-12-01T12:00:00") else current-dateTime() };         min(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) {         if ($x = 2) then xs:dateTime("3000-12-01T12:00:00") else current-dateTime()         };         max(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) {         if ($x = 2) then xs:time("12:00:00-01:00") else xs:time("12:00:00+01:00")         };         max(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) { if ($x = 2) then xs:time("12:00:00-01:00") else xs:time("12:00:00+01:00") };         min(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) { if ($x = 2) then xs:yearMonthDuration("P11M") else xs:yearMonthDuration("P1Y") };         min(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) {         if ($x = 2) then xs:yearMonthDuration("P13M") else xs:yearMonthDuration("P1Y")         };        max(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) {         if ($x = 3) then $x else false()         };         max(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) { if ($x = 3) then $x else false() };         min(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) {         if ($x < 3) then current-date() else current-time()         };         max(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) { if ($x < 3) then current-date() else current-time() };         min(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) {         if ($x < 3) then current-dateTime() else xs:dayTimeDuration("PT3S")         };         max(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) { if ($x < 3) then current-dateTime() else xs:dayTimeDuration("PT3S") };         min(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) {         if ($x < 3) then current-time() else xs:dayTimeDuration("PT3S")         };         max(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) { if ($x < 3) then current-time() else xs:dayTimeDuration("PT3S") };         min(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) {         (xs:decimal(1.1), xs:float(1.2), xs:double(0.4), xs:integer("-3"))[$x]         };         max(for $x in (4,2,1,3) return local:f($x)) instance of xs:double
declare function local:f($x as xs:integer) { (xs:decimal(1.1), xs:float(1.2), xs:double(0.4), xs:integer("-3"))[$x] };         min(for $x in (4,2,1,3) return local:f($x)) instance of xs:double
declare function local:f($x as xs:integer) {         (xs:decimal(1.1), xs:float(1.2), xs:double(0.4), xs:string("2"))[$x]         };         max(for $x in (1,4,2,3) return local:f($x))
declare function local:f($x as xs:integer) { (xs:decimal(1.1), xs:float(1.2), xs:double(0.4), xs:string("2"))[$x] };         min(for $x in (1,4,2,3) return local:f($x))
declare function local:f($x as xs:integer) {         (xs:decimal(1.1), xs:float(2.2), xs:double(1.4), xs:integer(2))[$x]         };         max(for $x in (1,2,3) return local:f($x)) instance of xs:double
declare function local:f($x as xs:integer) { (xs:decimal(1.1), xs:float(2.2), xs:double(1.4), xs:integer(2))[$x] };         min(for $x in (1,2,3) return local:f($x)) instance of xs:double
declare function local:f($x as xs:integer) {         (xs:decimal(1.3), xs:float(1.2), xs:double(1.4), xs:integer(2))[$x]         };         max(for $x in (1,2,3) return local:f($x)) instance of xs:double
declare function local:f($x as xs:integer) { (xs:decimal(1.3), xs:float(1.2), xs:double(1.4), xs:integer(2))[$x] };         min(for $x in (1,2,3) return local:f($x)) instance of xs:double
declare function local:f($x) { if ($x mod 2 = 1) then <a/> else "a" };         let $y := for $x in (1 to 10) return <e>{$x}</e> return $y/local:f(.)/a
declare function local:f($x) { if ($x) then true() else () }; declare function local:g($x) { if ($x) then "true" else "false" }; let $x := local:g(true()) for $y in local:f($x) return ($y, $x)
declare function local:f($x) { if ($x) then true() else () }; empty(for $x in local:f(false()), $y in 1 to 10 return ($x, $y))
declare function local:f($x) { if ($x) then true() else () }; for $x in local:f(true()), $y in 1 to 10 return ($x, $y)
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") };         declare function local:g($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(false()) + local:g(false())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") }; declare function local:g($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") }; local:f(false()) - local:g(false())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") };         declare function local:g($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(true()) + local:g(true())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") }; declare function local:g($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") }; local:f(true()) - local:g(true())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") }; local:f(false()) div 2
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") }; local:f(false()) div xs:dayTimeDuration("PT1H")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") };         local:f(false()) + local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") }; local:f(false()) - local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") }; local:f(false()) - xs:date("1997-01-01")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") }; local:f(false()) - xs:dateTime("1997-01-01T12:00:00")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") };         local:f(false()) + xs:dayTimeDuration("PT1H")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") }; local:f(false()) - xs:dayTimeDuration("PT1H")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") }; local:f(true()) div xs:dayTimeDuration("PT1H")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") };         local:f(true()) + local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") }; local:f(true()) - local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") };         local:f(true()) + xs:date("1997-01-01")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") }; local:f(true()) - xs:date("1997-01-01")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") };         local:f(true()) + xs:dateTime("1997-01-01T12:00:00")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") }; local:f(true()) - xs:dateTime("1997-01-01T12:00:00")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") };         local:f(true()) + xs:dayTimeDuration("PT1H")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") }; local:f(true()) - xs:dayTimeDuration("PT1H")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") };         xs:date("1997-01-01") + local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") }; xs:date("1997-01-01") - local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") };         xs:dateTime("1997-01-01T12:00:00") + local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") }; xs:dateTime("1997-01-01T12:00:00") - local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") };         xs:dayTimeDuration("PT1H") + local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") }; xs:dayTimeDuration("PT1H") - local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") };         xs:dayTimeDuration("PT1H") + local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") }; xs:dayTimeDuration("PT1H") - local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1H") }; local:f(true()) - xs:time("12:00:00")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1H") };         xs:time("12:00:00") + local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1H") }; xs:time("12:00:00") - local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("PT1H") }; local:f(false()) - xs:time("12:00:00")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("PT1H") };         local:f(true()) + xs:time("12:00:00")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:yearMonthDuration("P1M") }; local:f(false()) - xs:date("1997-01-01")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:yearMonthDuration("P1M") }; local:f(false()) - xs:dateTime("1997-01-01T12:00:00")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:yearMonthDuration("P1M") };         local:f(true()) + xs:date("1997-01-01")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:yearMonthDuration("P1M") }; local:f(true()) - xs:date("1997-01-01")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:yearMonthDuration("P1M") };         local:f(true()) + xs:dateTime("1997-01-01T12:00:00")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:yearMonthDuration("P1M") }; local:f(true()) - xs:dateTime("1997-01-01T12:00:00")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:yearMonthDuration("P1M") };         xs:date("1997-01-01") + local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:yearMonthDuration("P1M") }; xs:date("1997-01-01") - local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:yearMonthDuration("P1M") };         xs:dateTime("1997-01-01T12:00:00") + local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:yearMonthDuration("P1M") }; xs:dateTime("1997-01-01T12:00:00") - local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("P1D") };         2 * local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("P1D") };         2 * local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("P1D") };         local:f(false()) * 2
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("P1D") };         local:f(true()) * 2
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("P1D") }; local:f(true()) div 2
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") }; local:f(false()) div local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") }; local:f(false()) div local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         local:f(false()) ge local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         local:f(false()) ge local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         local:f(false()) ge xs:dayTimeDuration("P1D")
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         local:f(false()) gt local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         local:f(false()) gt local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         local:f(false()) gt xs:dayTimeDuration("P1D")
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         local:f(false()) le local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         local:f(false()) le local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         local:f(false()) le xs:dayTimeDuration("P1D")
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         local:f(true()) ge xs:dayTimeDuration("P1D")
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         local:f(true()) gt xs:dayTimeDuration("P1D")
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         local:f(true()) le xs:dayTimeDuration("P1D")
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") }; xs:dayTimeDuration("P1D") div local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") }; xs:dayTimeDuration("P1D") div local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         xs:dayTimeDuration("P1D") ge local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         xs:dayTimeDuration("P1D") ge local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         xs:dayTimeDuration("P1D") gt local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         xs:dayTimeDuration("P1D") gt local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         xs:dayTimeDuration("P1D") le local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         xs:dayTimeDuration("P1D") le local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         2 * local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         2 * local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(false()) * 2
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") }; local:f(false()) div local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(false()) ge local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(false()) ge xs:yearMonthDuration("P1Y")
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(false()) gt local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(false()) gt xs:yearMonthDuration("P1Y")
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(false()) le local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(false()) le xs:yearMonthDuration("P1Y")
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(false()) + local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") }; local:f(false()) - local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(false()) + xs:yearMonthDuration("P1Y")
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") }; local:f(false()) - xs:yearMonthDuration("P1Y")
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(true()) * 2
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") }; local:f(true()) div local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(true()) ge local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(true()) ge xs:yearMonthDuration("P1Y")
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(true()) gt local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(true()) gt xs:yearMonthDuration("P1Y")
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(true()) le local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(true()) le xs:yearMonthDuration("P1Y")
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(true()) + local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") }; local:f(true()) - local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(true()) + xs:yearMonthDuration("P1Y")
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") }; local:f(true()) - xs:yearMonthDuration("P1Y")
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") }; xs:yearMonthDuration("P1Y") div local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") }; xs:yearMonthDuration("P1Y") div local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         xs:yearMonthDuration("P1Y") ge local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         xs:yearMonthDuration("P1Y") ge local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         xs:yearMonthDuration("P1Y") gt local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         xs:yearMonthDuration("P1Y") gt local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         xs:yearMonthDuration("P1Y") le local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         xs:yearMonthDuration("P1Y") le local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         xs:yearMonthDuration("P1Y") + local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") }; xs:yearMonthDuration("P1Y") - local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         xs:yearMonthDuration("P1Y") + local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") }; xs:yearMonthDuration("P1Y") - local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1Y") else xs:yearMonthDuration("P1Y") }; local:f(false()) div xs:yearMonthDuration("P1M")
declare function local:f($x) { if ($x) then xs:duration("P1Y") else xs:yearMonthDuration("P1Y") }; local:f(true()) div xs:yearMonthDuration("P1M")
declare function local:f($x) { if ($x) then xs:duration("P2M") else xs:yearMonthDuration("P2M") }; local:f(false()) div 2
declare function local:f($x) { if ($x) then xs:duration("P2M") else xs:yearMonthDuration("P2M") }; local:f(true()) div 2
declare function local:f1() {$a};         declare function local:f2() {$a};         declare variable $a := 19;               local:f1() + local:f2()
declare function local:f() { (<a/>, "a") }; boolean(local:f())
declare function local:fact($n as xs:integer) as xs:integer { if ($n < 2) then 1 else $n * local:fact(($n)-1) };         <table> { for $i in 1 to 10 return <tr> <td>{$i}! = {local:fact($i)}</td> </tr> } </table>
declare function local:factorial($arg as xs:integer) as xs:integer {         if ($arg le 1) then 1 else $arg * local:factorial($arg - 1)         };         <element> { attribute { fn:QName("http://www.example.com/", "sgml:foo") } { local:factorial(5) } } </element>
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x + 1 ge 121
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x - 1 ge 121
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x + 1 gt 121
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x - 1 gt 121
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x + 1 le 121
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x - 1 le 121
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x + 1 lt 121
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x - 1 lt 121
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x - 2 ge 12
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x + 2 ge 121
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x - 2 lt 12
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x + 2 lt 121
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 1 + $x gt 121
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 1 + $x le 121
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 ge $x + 1
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 ge $x + 2
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 ge 1 + $x
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 ge 2 + $x
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 gt $x + 1
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 gt $x - 1
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 gt 1 + $x
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 le $x + 1
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 le $x - 1
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 le 1 + $x
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 lt $x + 1
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 lt $x + 2
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 lt 1 + $x
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 lt 2 + $x
declare function local:factorial($n as xs:integer) as xs:integer { if ($n le 1) then 1 else $n * local:factorial($n - 1) }; declare function local:is-divisible($n as xs:integer, $d as xs:integer) { $n mod $d eq 0 }; not(local:is-divisible(local:factorial(5), 3)) and not(local:is-divisible(local:factorial(5), 2))
declare function local:factorial($n as xs:integer) as xs:integer { if ($n le 1) then 1 else $n * local:factorial($n - 1) }; declare function local:is-divisible($n as xs:integer, $d as xs:integer) { $n mod $d eq 0 }; not(local:is-divisible(local:factorial(5), 3)) or not(local:is-divisible(local:factorial(5), 2))
declare function local:factorial($n as xs:integer) as xs:integer? { if ($n lt 1) then () else if ($n eq 1) then 1 else $n * local:factorial($n - 1) }; (every $x in local:factorial(5) satisfies ($x mod 3 eq 0)) or (every $y in local:factorial(5) satisfies ($y mod 5 eq 0))
declare function local:f() as node() { <a/> };         local:f() is local:f()
declare function local:f() as xs:double* {            if (day-from-date(current-date()) < 32) then xs:integer(3) else -1         };         local:f() + 1
declare function local:f() as xs:integer { 42 };         declare function local:f($x as xs:integer) as xs:integer { $x + 1 };         let $f := local:f#0 return $f()
declare function local:fn1 ($n as xs:integer) as xs:integer { local:fn2($n) };         declare function local:fn2 ($n as xs:integer) as xs:integer { if ($n = 1) then 1 else $n + local:fn1($n - 1) };         local:fn1(4)
declare function local:fold-left(           $seq as item()*,           $zero as item()*,           $f as function(item()*, item()) as item()*)         as item()* {             if (fn:empty($seq))             then $zero             else fn:fold-left(fn:tail($seq), $f($zero, fn:head($seq)), $f)         };         local:fold-left(1 to 5, 0, function($a, $b) { $a + $b })
declare function local:fold-left(           $seq as item()*,           $zero as item()*,           $f as function(item()*, item()) as item()*)         as item()* {             if (fn:empty($seq))             then $zero             else fn:fold-left(fn:tail($seq), $f($zero, fn:head($seq)), $f)         };         local:fold-left((2,3,5,7), 1, function($a, $b) { $a * $b })
declare function local:fold-left(           $seq as item()*,           $zero as item()*,           $f as function(item()*, item()) as item()*)         as item()* {             if (fn:empty($seq))             then $zero             else fn:fold-left(fn:tail($seq), $f($zero, fn:head($seq)), $f)         };         local:fold-left((true(), false(), false()), false(), function($a, $b) { $a and $b })
declare function local:fold-left(           $seq as item()*,           $zero as item()*,           $f as function(item()*, item()) as item()*)         as item()* {             if (fn:empty($seq))             then $zero             else fn:fold-left(fn:tail($seq), $f($zero, fn:head($seq)), $f)         };         local:fold-left((true(), false(), false()), false(), function($a, $b) { $a or $b })
declare function local:fold-right(           $seq as item()*,            $zero as item()*,            $f as function(item(), item()*) as item()*)            as item()* {             if (fn:empty($seq))             then $zero             else $f(fn:head($seq), fn:fold-right(fn:tail($seq), $zero, $f))           };           local:fold-right(1 to 5, 0,function($a, $b) { $a + $b })
declare function local:fold-right(           $seq as item()*,            $zero as item()*,            $f as function(item(), item()*) as item()*)            as item()* {             if (fn:empty($seq))             then $zero             else $f(fn:head($seq), fn:fold-right(fn:tail($seq), $zero, $f))           };           local:fold-right((2,3,5,7), 1,function($a, $b) { $a * $b })
declare function local:fold-right(           $seq as item()*,            $zero as item()*,            $f as function(item(), item()*) as item()*)            as item()* {             if (fn:empty($seq))             then $zero             else $f(fn:head($seq), fn:fold-right(fn:tail($seq), $zero, $f))           };           local:fold-right((true(), false(), false()), false(),function($a, $b) { $a and $b })
declare function local:fold-right(           $seq as item()*,            $zero as item()*,            $f as function(item(), item()*) as item()*)            as item()* {             if (fn:empty($seq))             then $zero             else $f(fn:head($seq), fn:fold-right(fn:tail($seq), $zero, $f))           };           local:fold-right((true(), false(), false()), false(),function($a, $b) { $a or $b })
declare function local:foo($a as xs:integer) { if($a = 3) then $a else let $a := $a return local:foo($a + 1) }; local:foo(1)
declare function local:foo($arg as item()) { $arg[@arg] }; local:foo(<e arg="">result</e>)
declare function local:foo($arg as item()) { string($arg/@arg) }; local:foo(<e arg="result"/>)
declare function local:foo($arg ) as xs:boolean* { $arg };         local:foo(current-date())
declare function local:foo($arg) as xs:boolean { $arg };         local:foo(<e/>)
declare function local:foo($arg ) as xs:boolean* { $arg };         local:foo((<e>true</e>, true(), xs:untypedAtomic("false"), false(), <e> true </e>))
declare function local:foo($arg) as xs:boolean* { $arg };         local:foo((<e>true</e>, true(), xs:untypedAtomic("false"), false(), <e> true </e>))
declare function local:foo($arg) as xs:boolean* { $arg };         local:foo((true(), xs:untypedAtomic("false"))), local:foo((false(), xs:untypedAtomic("false")))
declare function local:foo($arg) as xs:boolean { $arg };         local:foo(xs:untypedAtomic("false"))
declare function local:foo($arg) as xs:boolean* { $arg };         local:foo(xs:untypedAtomic("false"))
declare function local:foo($arg) { local:foo(local:foo(1)) }; 1
declare function local:foo ($n as xs:integer) as xs:string { $n };         local:foo(4)
declare function local:foo($n as xs:integer) { <tr> {$n} </tr> };         local:foo(4)
declare function local:foo() {           $x         };         declare variable $x external := 5;         local:foo()
declare function local:foo2($i as xs:string) as xs:string {local:foo($i)};         declare function local:foo($i as xs:string) as xs:string {$i};         local:foo2("abc")
declare function local:foo() as xs:boolean { text {local:doesNotExist()} };         1
declare function local:foo() external;
declare function local:fun() {1 to 5}; array{local:fun()}?1
declare function local:func($a as xs:integer, $b as xs:integer, $unused) { $a + $b };         local:func(1, 2, 3)
declare function local:func($a as xs:integer, $unused, $c as xs:integer) { $a + $c };         local:func(1, 2, 3)
declare function local:func($arg as element()* ) as element()* { for $n in $arg/attribute return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/castable return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/child return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/comment return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/declare return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/document-node return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/document return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/element return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/following-sibling return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/for return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/if return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/import return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/instance return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/item return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/let return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/ordered return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/processing-instruction return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/schema-attribute return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/schema-element return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/some return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/text return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/typeswitch return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/unordered return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/validate return $n }; 1
declare function local:func($choose, $whenTrue, $whenFalse) { if($choose) then $whenTrue else $whenFalse };         local:func(true(), current-time(), current-date()) instance of xs:time and local:func(false(), current-time(), current-date()) instance of xs:date
declare function local:func($unused, $b as xs:integer, $c as xs:integer) { $b + $c };         local:func(1, 2, 3)
declare function local:func1($a1, $a2, $a3) { 1 };         local:func1(1, 2, 3)
declare function local:func1() { if(local:func2('b')) then 3 else local:func1() };          declare function local:func2($a) { if(matches("",$a)) then () else 4 };          local:func1()
declare function local:func() as xs:integer { <!--1--> };         local:func()
declare function local:func() as xs:integer { attribute name {"1"} };         local:func()
declare function local:func() as xs:integer { <e>1</e> };         local:func()
declare function local:func() as xs:integer { <?target 1?> };         local:func()
declare function local:func() as xs:integer? { text {"1"} };         local:func()
declare function local:function($x as xs:integer) as xs:integer { (:there is nothing here:) };          local:function(3)
declare function local:function() { let $b := (i/a) return 1 }; local:function()
declare function local:function() { let $b := (i/a) return () }; empty(local:function())
declare function local:gDay($day as xs:integer) { if ($day lt 10) then xs:gDay(concat("---0", $day)) else xs:gDay(concat("---", $day)) }; not(local:gDay(1) eq xs:gDay("---31"))
declare function local:gDay($day as xs:integer) { if ($day lt 10) then xs:gDay(concat("---0", $day)) else xs:gDay(concat("---", $day)) }; not(local:gDay(1) ne xs:gDay("---31"))
declare function local:gDay($gDay as xs:gDay, $null as xs:boolean) { if ($null) then () else $gDay }; exists(local:gDay(xs:gDay("---31"), fn:true()) eq xs:gDay("---31"))
declare function local:gDay($gDay as xs:gDay, $null as xs:boolean) { if ($null) then () else $gDay }; exists(local:gDay(xs:gDay("---31"), fn:true()) ne xs:gDay("---31"))
declare function local:gDay($gDay as xs:gDay, $null as xs:boolean) { if ($null) then () else $gDay }; local:gDay(xs:gDay("---31"), fn:false()) eq xs:gDay("---31")
declare function local:gDay($gDay as xs:gDay, $null as xs:boolean) { if ($null) then () else $gDay }; local:gDay(xs:gDay("---31"), fn:false()) ne xs:gDay("---31")
declare function local:generate($arg as xs:boolean) as xs:string+ { if ($arg) then ('a', 'b', 'c') else ('A', 'B', 'C') }; ( for $x in local:generate(true()) return 3)[1]
declare function local:generate($arg as xs:boolean) as xs:string+ { if ($arg) then ('a', 'b', 'c') else ('A', 'B', 'C') }; ( for $x in local:generate(true()) return 3)[last()]
declare function local:generate($arg as xs:integer?) as xs:integer? { $arg }; ( if (local:generate(0) = 0) then () else 1, for $x in local:generate(0) return -$x)[1]
declare function local:generate($arg as xs:integer?) as xs:integer? { $arg };         ( if (local:generate(0) = 0) then () else 1, for $x in local:generate(0) return -$x)[last()]
declare function local:generate($arg as xs:integer?) as xs:integer? { if ($arg = 0) then 0 else () }; ( local:generate(()), for $x in local:generate(0) return $x + 2 )[1]
declare function local:generate($arg as xs:integer?) as xs:integer? { if ($arg = 0) then 0 else () };         ( local:generate(()), for $x in local:generate(0) return $x + 2 )[last()]
declare function local:generate($arg as xs:integer?) as xs:integer* { if ($arg = 0) then ( 1, 2, 3 ) else ( $arg ) }; ( local:generate(()), for $x at $p in local:generate(0) return $p + $x)[1]
declare function local:generate($arg as xs:integer?) as xs:integer* { if ($arg = 0) then ( 1, 2, 3 ) else ( $arg ) };         ( local:generate(()), for $x at $p in local:generate(0) return $p + $x)[last()]
declare function local:generate($arg as xs:integer?) as xs:integer* { if ($arg = 0) then (1, 2, 3) else $arg }; ( local:generate(()), for $x in local:generate(0) return $x + 2 )[1]
declare function local:generate($arg as xs:integer?) as xs:integer* { if ($arg = 0) then (1, 2, 3) else $arg };         ( local:generate(()), for $x in local:generate(0) return $x + 2 )[last()]
declare function local:generate($arg as xs:integer?) as xs:integer? { if ($arg = 0) then 1 else $arg }; ( local:generate(()), for $x at $p in local:generate(0) return $p + $x)[1]
declare function local:generate($arg as xs:integer?) as xs:integer? { if ($arg = 0) then 1 else $arg };         ( local:generate(()), for $x at $p in local:generate(0) return $p + $x)[last()]
declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then ('a', 'b', 'c') else () }; boolean(local:generate(0)[1])
declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then ('a', 'b', 'c') else () };         boolean(local:generate(0)[last()])
declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then ('a', 'b', 'c') else () }; boolean(local:generate(1)[1])
declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then ('a', 'b', 'c') else () }; boolean(local:generate(1)[last()])
declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then ('a', 'b', 'c') else ('d' ) }; ( if (local:generate(1) = 'd') then () else 1, for $x in local:generate(0) return fn:lower-case($x))[1]
declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then ('a', 'b', 'c') else ('d' ) };         ( if (local:generate(1) = 'd') then () else 1, for $x in local:generate(0) return fn:lower-case($x))[last()]
declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then ('a', 'b', 'c') else () }; ( local:generate(()), for $x in local:generate(0) return 3)[1]
declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then ('a', 'b', 'c') else () };         ( local:generate(()), for $x in local:generate(0) return 3)[last()]
declare function local:generate($arg as xs:integer?) { if ($arg = 0) then (1, 2, 3) else $arg }; fn:count( ( (), local:generate( () ), local:generate( 0 ), (1 to 10000000), local:generate( () ), local:generate(1)) )
declare function local:generate($arg as xs:integer?) { if ($arg = 0) then (1, 2, 3) else $arg };         fn:empty( fn:zero-or-one(fn:unordered( local:generate( () ) )) )
declare function local:generate($arg as xs:integer?) { if ($arg = 0) then (1, 2, 3) else $arg };         fn:empty( ((), local:generate( () ), local:generate( 0 ), (1 to 10000000), local:generate( () ), local:generate(1)) )
declare function local:generate($arg as xs:integer) { if ($arg = 0) then (1, 2, 3) else $arg };         fn:exactly-one(fn:unordered( local:generate(1) ))
declare function local:generate($arg as xs:integer?) { if ($arg = 0) then (1, 2, 3) else $arg };         fn:exists( ( (), local:generate( () ), local:generate( 0 ), (1 to 10000000), local:generate( () ), local:generate(1)) )
declare function local:generate($arg as xs:integer?) { if ($arg = 0) then (1, 2, 3) else $arg };         fn:one-or-more(fn:reverse( local:generate( 0 ) ))
declare function local:generate($arg as xs:integer?) { if ($arg = 0) then (1, 2, 3) else $arg };         fn:one-or-more(fn:zero-or-one( local:generate( () ) ))
declare function local:generate($arg as xs:integer?) { if ($arg = 0) then (1, 2, 3) else () }; ( local:generate(0), 1, local:generate(0) )[1]
declare function local:generate($arg as xs:integer?) { if ($arg = 0) then (1, 2, 3) else () };         ( local:generate(0), 1, local:generate(0) )[last()]
declare function local:generate($arg as xs:integer?) { if ($arg = 0) then () else if ($arg = 1) then $arg else ($arg, $arg) };         1 + fn:exactly-one(fn:one-or-more( local:generate( 1 ) ))
declare function local:generate($arg as xs:integer?) { if ($arg = 0) then () else if ($arg = 1) then $arg else ($arg, $arg) };         1 + fn:exactly-one(fn:zero-or-one( local:generate( 1 ) ))
declare function local:generate($arg as xs:integer?) { if ($arg = 0) then () else if ($arg = 1) then $arg else ($arg, $arg) };         1 + fn:zero-or-one(fn:one-or-more( local:generate( 1 ) ))
declare function local:generate($count as xs:integer) {        for $x in 1 to $count         return         if ($x mod 3 = 0) then <a />         else if ($x mod 3 = 1) then <b />         else <c />         };         fn:boolean(fn:count( local:generate(5) ))
declare function local:generate($count as xs:integer) {        if ($count < 0) then "string"         else for $x in 1 to $count          return           if ($x mod 3 = 0) then <a />           else if ($x mod 3 = 1) then <b />           else <c />         };         fn:boolean(fn:reverse( local:generate(5) ))
declare function local:gMonth($gMonth as xs:gMonth, $null as xs:boolean) { if ($null) then () else $gMonth }; exists(local:gMonth(xs:gMonth("--12"), fn:true()) eq xs:gMonth("--12"))
declare function local:gMonth($gMonth as xs:gMonth, $null as xs:boolean) { if ($null) then () else $gMonth }; exists(local:gMonth(xs:gMonth("--12"), fn:true()) ne xs:gMonth("--12"))
declare function local:gMonth($gMonth as xs:gMonth, $null as xs:boolean) { if ($null) then () else $gMonth }; local:gMonth(xs:gMonth("--12"), fn:false()) eq xs:gMonth("--12")
declare function local:gMonth($gMonth as xs:gMonth, $null as xs:boolean) { if ($null) then () else $gMonth }; local:gMonth(xs:gMonth("--12"), fn:false()) ne xs:gMonth("--12")
declare function local:gMonth($month as xs:integer) { if ($month lt 10) then xs:gMonth(concat("--0", $month)) else xs:gMonth(concat("--", $month)) }; not(local:gMonth(1) eq xs:gMonth("--06"))
declare function local:gMonth($month as xs:integer) { if ($month lt 10) then xs:gMonth(concat("--0", $month)) else xs:gMonth(concat("--", $month)) }; not(local:gMonth(1) ne xs:gMonth("--06"))
declare function local:gMonthDay($day as xs:integer) { if ($day lt 10) then xs:gMonthDay(concat("--12-0", $day)) else xs:gMonthDay(concat("--12-", $day)) }; not(local:gMonthDay(1) eq xs:gMonthDay("--12-31"))
declare function local:gMonthDay($day as xs:integer) { if ($day lt 10) then xs:gMonthDay(concat("--12-0", $day)) else xs:gMonthDay(concat("--12-", $day)) }; not(local:gMonthDay(1) ne xs:gMonthDay("--12-31"))
declare function local:gMonthDay($gMonthDay as xs:gMonthDay, $null as xs:boolean) { if ($null) then () else $gMonthDay }; exists(local:gMonthDay(xs:gMonthDay("--12-31"), fn:true()) eq xs:gMonthDay("--12-31"))
declare function local:gMonthDay($gMonthDay as xs:gMonthDay, $null as xs:boolean) { if ($null) then () else $gMonthDay }; exists(local:gMonthDay(xs:gMonthDay("--12-31"), fn:true()) ne xs:gMonthDay("--12-31"))
declare function local:gMonthDay($gMonthDay as xs:gMonthDay, $null as xs:boolean) { if ($null) then () else $gMonthDay }; local:gMonthDay(xs:gMonthDay("--12-31"), fn:false()) eq xs:gMonthDay("--12-31")
declare function local:gMonthDay($gMonthDay as xs:gMonthDay, $null as xs:boolean) { if ($null) then () else $gMonthDay }; local:gMonthDay(xs:gMonthDay("--12-31"), fn:false()) ne xs:gMonthDay("--12-31")
declare function local:gYear($gYear as xs:gYear, $null as xs:boolean) { if ($null) then () else $gYear }; exists(local:gYear(xs:gYear("1972"), fn:true()) eq xs:gYear("1972"))
declare function local:gYear($gYear as xs:gYear, $null as xs:boolean) { if ($null) then () else $gYear }; exists(local:gYear(xs:gYear("1972"), fn:true()) ne xs:gYear("1972"))
declare function local:gYear($gYear as xs:gYear, $null as xs:boolean) { if ($null) then () else $gYear }; local:gYear(xs:gYear("1972"), fn:false()) ne xs:gYear("1972")
declare function local:gYear($year as xs:integer) { xs:gYear(string(2000 + $year)) }; not(local:gYear(7) eq xs:gYear("2008"))
declare function local:gYear($year as xs:integer) { xs:gYear(string(2000 + $year)) }; not(local:gYear(7) ne xs:gYear("2008"))
declare function local:gYearMonth($gYearMonth as xs:gYearMonth, $null as xs:boolean) { if ($null) then () else $gYearMonth }; exists(local:gYearMonth(xs:gYearMonth("1972-12"), fn:true()) eq xs:gYearMonth("1972-12"))
declare function local:gYearMonth($gYearMonth as xs:gYearMonth, $null as xs:boolean) { if ($null) then () else $gYearMonth }; exists(local:gYearMonth(xs:gYearMonth("1972-12"), fn:true()) ne xs:gYearMonth("1972-12"))
declare function local:gYearMonth($gYearMonth as xs:gYearMonth, $null as xs:boolean) { if ($null) then () else $gYearMonth }; local:gYearMonth(xs:gYearMonth("1972-12"), fn:false()) eq xs:gYearMonth("1972-12")
declare function local:gYearMonth($gYearMonth as xs:gYearMonth, $null as xs:boolean) { if ($null) then () else $gYearMonth }; local:gYearMonth(xs:gYearMonth("1972-12"), fn:false()) ne xs:gYearMonth("1972-12")
declare function local:gYearMonth($year as xs:integer) { xs:gYearMonth(concat(string(2000 + $year), "-01")) }; not(local:gYearMonth(7) eq xs:gYearMonth("2008-01"))
declare function local:gYearMonth($year as xs:integer) { xs:gYearMonth(concat(string(2000 + $year), "-01")) }; not(local:gYearMonth(7) ne xs:gYearMonth("2008-01"))
declare function local:hexBinary-value($arg as xs:boolean) as xs:hexBinary {              if ($arg) then xs:hexBinary('68656c6c6f') else xs:hexBinary('676f6f64627965')           };           local:hexBinary-value(true()) eq local:hexBinary-value(false())
declare function local:hexBinary-value($arg as xs:boolean) as xs:hexBinary {              if ($arg) then xs:hexBinary('68656c6c6f') else xs:hexBinary('676f6f64627965')           };           not(local:hexBinary-value(true()) eq local:hexBinary-value(false()))
declare function local:hexBinary-value($arg as xs:boolean) as xs:hexBinary {              if ($arg) then xs:hexBinary('68656c6c6f') else xs:hexBinary('676f6f64627965')           };           not(local:hexBinary-value(true()) ne local:hexBinary-value(false()))
declare function local:hof($s, $f as function(*)) {            $f($s[1], $s[2])          };                    local:hof(('1', '2'), concat#2)
declare function local:identity($arg as xs:error)             {               $arg             };        local:identity(1)
declare function local:index-of($seq, $item) as xs:double? { for $x at $p in $seq return if ($x eq $item) then $p else () };         local:index-of((1, 2.0, xs:float(3), 2), 2)
declare function local:index-of($seq as xs:double*, $item as xs:double) { for $x at $p in $seq return if ($x eq $item) then $p else () };         declare function local:sequence($x as xs:integer) { ("string", 1, 2.0, xs:float(3))[$x] };         local:index-of(for $x in (2,3,4) return local:sequence($x), 2)
declare function local:index-of($seq as xs:integer*, $item as xs:integer?) as xs:float* {            if (empty($item))              then -1             else for $x at $p in $seq return if ($x eq $item) then $p else ()          };         local:index-of(1 to 10, 3)
declare function local:integer($x as xs:decimal) { if ($x mod 1 eq 0) then xs:integer($x) else $x };         (local:integer(2) idiv local:integer(2)) instance of xs:integer
declare function local:integer($x as xs:decimal) { if ($x mod 1 eq 0) then xs:integer($x) else $x };         (local:integer(2) * local:integer(2)) instance of xs:integer
declare function local:integer($x as xs:decimal) { if ($x mod 1 eq 0) then xs:integer($x) else $x };         (local:integer(2) - local:integer(2)) instance of xs:integer
declare function local:integer($x as xs:decimal) { if ($x mod 1 eq 0) then xs:integer($x) else $x };         -(local:integer(2)) - -(local:integer(4))
declare function local:integer($x as xs:decimal) { if ($x mod 1 eq 0) then xs:integer($x) else $x };         -(local:integer(2)) - local:integer(4)
declare function local:integer($x as xs:decimal) { if ($x mod 1 eq 0) then xs:integer($x) else $x };         local:integer(2) - -(local:integer(4))
declare function local:integer($x as xs:decimal) { if ($x mod 1 eq 0) then xs:integer($x) else $x };         (local:integer(3.5) mod local:integer(2)) instance of xs:integer
declare function local:integer($x as xs:decimal) { if ($x mod 1 eq 0) then xs:integer($x) else $x };         (local:integer(3) mod local:integer(2)) instance of xs:integer
declare function local:isComplexType($typeID) { string($typeID) };          "|", //*/local:isComplexType(@type), "|"
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        fn:false() eq local:is-even(17)
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        fn:false() ge local:is-even(17)
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        fn:false() gt local:is-even(17)
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        fn:false() le local:is-even(17)
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        fn:false() lt local:is-even(17)
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        fn:true() ge local:is-even(17)
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        fn:true() gt local:is-even(17)
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        fn:true() le local:is-even(17)
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        fn:true() lt local:is-even(17)
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        fn:true() ne local:is-even(17)
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        local:is-even(17) ge fn:false()
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        local:is-even(17) ge fn:true()
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        local:is-even(17) gt fn:false()
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        local:is-even(17) gt fn:true()
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        local:is-even(17) le fn:false()
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        local:is-even(17) le fn:true()
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        local:is-even(17) lt fn:false()
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        local:is-even(17) lt fn:true()
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        local:is-even(17) ne fn:false()
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        local:is-even(17) ne fn:true()
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        not(local:is-even(13) eq local:is-even(17))
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        not(local:is-even(15) ge local:is-even(17))
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        not(local:is-even(15) gt local:is-even(17))
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        not(local:is-even(15) le local:is-even(17))
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        not(local:is-even(15) lt local:is-even(17))
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        not(not(local:is-even(17) eq local:is-even(16)))
declare function local:levenshtein($arg1 as xs:string, $arg2 as xs:string) as xs:decimal { if(string-length($arg1) = 0) then string-length($arg2) else if(string-length($arg2) = 0) then string-length($arg1) else min((local:levenshtein(substring($arg1, 2), $arg2) + 1, local:levenshtein($arg1, substring($arg2, 2)) + 1, local:levenshtein(substring($arg1, 2), substring($arg2, 2)) + (if(substring($arg1, 1, 1) = substring($arg2, 1, 1)) then 0 else 1))) };         local:levenshtein("a", "a"), local:levenshtein("aa", "aa"), local:levenshtein("aaa", "aaa"), local:levenshtein("aa a", "aa a"), local:levenshtein("a a a", "aaa"), local:levenshtein("aaa", "a a a"), local:levenshtein("aaa", "aaab"), local:levenshtein("978", "abc")
declare function local:lower-case($x as xs:string) as xs:string { concat("'", fn:lower-case($x), "'") };          declare function local:ops() as (function(xs:string) as xs:string)*           { (upper-case#1, local:lower-case#1, function($x){translate($x, 'e', 'i')}, substring-before(?, ' ')) };          string-join(for $f in local:ops() return $f(<a name="Michael Kay"/>/@name), '~')
declare function local:multiplySequence($input as xs:integer*) as xs:integer { if (empty($input)) then 1 else $input[1] * local:multiplySequence($input[position() != 1]) };         local:multiplySequence((1, 2, 3, 4, 5))
declare function local:myFunc($arg as node()) { let $v := aNameTest return $arg/$v }; 1
declare function local:myFunc($arg as node()) { let $v := aNameTest return $arg/$v }; local:myFunc(<e/>)
declare function local:myFunc($arg as node()) { let $v := . return $arg/$v }; local:myFunc(<e/>)
declare function local:myFunc($recurse as xs:integer) as item() { <nested> { if ($recurse = 0) then () else local:myFunc($recurse - 1) } </nested> }; <b> {local:myFunc(3)} {attribute name {"content"}} </b>
declare function local:myFunc($recurse as xs:integer) { attribute {concat("name", $recurse)} {"content"} , if ($recurse = 0) then () else local:myFunc($recurse - 1) }; <b> {local:myFunc(2)} {attribute name {"content"}} </b>
declare function local:myFunc($recurse as xs:integer) { <nested> { if ($recurse = 0) then () else local:myFunc($recurse - 1) } </nested> }; <b> {local:myFunc(3)} {attribute name {"content"}} </b>
declare function local:myFunc() { <a/> }; <b> {local:myFunc()} {attribute name {"content"}} </b>
declare function local:myFunc() as attribute(foo) { <foo/> };         local:myFunc()
declare function local:myFunc() as element()+ { <a/> }; <b> {local:myFunc()} {attribute name {"content"}} </b>
declare function local:myFunc() as item() { <a/> }; <b> {local:myFunc()} {attribute name {"content"}} </b>
declare function local:myFunc() { attribute n2 {"content"} }; <b> {local:myFunc()} {attribute name {"content"}} </b>
declare function local:myFunc() { attribute name {"content"}, <elem/> }; <b> {local:myFunc()} </b>
declare function local:myFunc() { comment {"content"} }; <b> {local:myFunc()} {attribute name {"content"}} </b>
declare function local:myFunc() { e[1] }; local:myFunc()
declare function local:myFunc() { e[928] }; local:myFunc()
declare function local:myFunc() { e };         <e/>/local:myFunc()/1
declare function local:myFunc() { e[last()] }; local:myFunc()
declare function local:myFunc() { <elem/>, attribute name {"content"} }; <b> {local:myFunc()[2]} </b>
declare function local:myFunc() { <elem/>, attribute name {"content"} }; <b> {local:myFunc()} </b>
declare function local:myFunc() { e[true()] }; local:myFunc()
declare function local:myFunc() { for $i at $p in (1, 2, 3) return position() }; 1
declare function local:myFunc() { for $i at $p in (1, 2, 3) return position() }; local:myFunc()
declare function local:myFunc() { for $i in (1, 2, 3) return position() }; 1
declare function local:myFunc() { for $i in (1, 2, 3) return position() };          local:myFunc()
declare function local:myFunc() { let $v := . return $v }; local:myFunc()
declare function local:myFunc() { .. }; local:myFunc()
declare function local:myFunction($arg) { $arg };         local:myFunction()
declare function local:myFunction($arg := 1) {1};         true()
declare function local:myFunction($arg = 1) {1};         true()
declare function local:myFunction($arg := 1 as xs:integer) {1};         true()
declare function local:myFunction($arg = 1 as xs:integer) {1};         true()
declare function local:myFunction($arg as empty-sequence()) { $arg };         empty(local:myFunction(()))
declare function local:myFunction($arg as empty-sequence()+) { $arg };         local:myFunction(())
declare function local:myFunction($arg as empty-sequence()?) { $arg };         local:myFunction(())
declare function local:myFunction($arg as item(), $arg2 as xs:integer) { $arg, $arg2 };         local:myFunction("3", ())
declare function local:myFunction($arg as item(), $arg2 as xs:integer) { $arg, $arg2 };         local:myFunction("3", "3")
declare function local:myFunction($arg as item()?, $arg2 as xs:integer) { $arg, $arg2 };         local:myFunction((), 4.1)
declare function local:myFunction($arg as xs:integer) { $arg };         local:myFunction(1.0)
declare function local:myFunction($arg as xs:integer) as xs:integer { if($arg eq 1) then $arg else local:myFunction3($arg - 1) };         declare function local:myFunction2($arg as xs:integer) as xs:integer { local:myFunction($arg) };         declare function local:myFunction3($arg as xs:integer) as xs:integer { local:myFunction2($arg) };         local:myFunction3(3) eq 1
declare function local:myFunction($local:arg) as item() { 1, $local:arg };         local:myFunction(()), local:myFunction(1)
declare function local:myFunction($local:myVar) { $local:myVar + 1 };         local:myFunction(1), local:myFunction("this will fail")
declare function local:myFunction($local:myVar as xs:integer) { for $local:myVar in ($local:myVar, 3) return $local:myVar };         deep-equal(local:myFunction(1), (1, 3))
declare function local:myFunction($unusedArg) { true() };         local:myFunction(1 + "a string")
declare function local:myFunction($usedArg) { $usedArg };         local:myFunction(1 + "a string")
declare function local:MyFunction() { 1 };         local:myFunction()
declare function local:MyFunction() { 1 };         local:myFunctionn()
declare function local:myFunction { 1 };         true()
declare function local:myFunction() as item()* {***};         1
declare function local:myFunction() as item() { () };         local:myFunction()
declare function local:myFunction() { "a string" + 1 };         true()
declare function local:myFunction() as xs:anyURI { 1 };         true()
declare function local:myFunction() as xs:double { "This is not a double, it's an xs:string." };         local:myFunction()
declare function local:myFunction() as xs:float { 4.0 };         (current-time(), 1, 2, "a string", local:myFunction(), 4.0, xs:double("NaN"), current-date())[5] instance of xs:float
declare function local:myFunction() as xs:integer { 1.0 };         local:myFunction()
declare function local:myFunction as xs:integer { 1 };         true()
declare function local:myFunction() as xs:integer { subsequence((1, 2, "a string"), 3 ,1) };         fn:boolean(local:myFunction())
declare function local:myName($var as xs:integer) as xs:integer { $var };         declare function local:myName() as xs:integer { 1 };         (local:myName(4) - 3) eq local:myName()
declare function local:mysum($i as xs:integer, $j as xs:integer) { let $j := $i + $j return $j };         declare function local:invoke_mysum($st as xs:integer) { for $d in (1,2,3,4,5) let $st := local:mysum($d, $st) return $st };         local:invoke_mysum(0)
declare function local:mysum($i as xs:integer, $j as xs:integer) { let $j := $i + $j return $j };         declare function local:invoke_mysum() { let $s := 1 for $d in (1,2,3,4,5) let $s := local:mysum($s, $d) return $s };         local:invoke_mysum()
declare function local:NaN () {1};          declare function local:allowing () {2};          declare function local:ancestor-or-self () {3};          declare function local:ancestor () {4};          declare function local:and () {5};          declare function local:as () {6};          declare function local:ascending () {7};          declare function local:at () {8};          declare function local:attribute () {9};          declare function local:base-uri () {10};          declare function local:boundary-space () {11};          declare function local:by () {12};          declare function local:case () {13};          declare function local:cast () {14};          declare function local:castable () {15};          declare function local:catch () {16};          declare function local:child () {17};          declare function local:collation () {18};          declare function local:comment () {19};          declare function local:construction () {20};          declare function local:context () {21};          declare function local:copy-namespaces () {22};          declare function local:count () {23};          declare function local:decimal-format () {24};          declare function local:decimal-separator () {25};          declare function local:declare () {26};          declare function local:default () {27};          declare function local:descendant-or-self () {28};          declare function local:descendant () {29};          declare function local:descending () {30};          declare function local:digit () {31};          declare function local:div () {32};          declare function local:document-node () {33};          declare function local:document () {34};          declare function local:element () {35};          declare function local:else () {36};          declare function local:empty-sequence () {37};          declare function local:empty () {38};          declare function local:encoding () {39};          declare function local:end () {40};          declare function local:eq () {41};          declare function local:every () {42};          declare function local:except () {43};          declare function local:external () {44};          declare function local:following-sibling () {45};          declare function local:following () {46};          declare function local:for () {47};          declare function local:function () {48};          declare function local:ge () {49};          declare function local:greatest () {50};          declare function local:group () {51};          declare function local:grouping-separator () {52};          declare function local:gt () {53};          declare function local:idiv () {54};          declare function local:if () {55};          declare function local:import () {56};          declare function local:in () {57};          declare function local:infinity () {58};          declare function local:inherit () {59};          declare function local:instance () {60};          declare function local:intersect () {61};          declare function local:is () {62};          declare function local:item () {63};          declare function local:lax () {64};          declare function local:le () {65};          declare function local:least () {66};          declare function local:let () {67};          declare function local:lt () {68};          declare function local:minus-sign () {69};          declare function local:mod () {70};          declare function local:module () {71};          declare function local:namespace-node () {72};          declare function local:namespace () {73};          declare function local:ne () {74};          declare function local:next () {75};          declare function local:no-inherit () {76};          declare function local:no-preserve () {77};          declare function local:node () {78};          declare function local:of () {79};          declare function local:only () {80};          declare function local:option () {81};          declare function local:or () {82};          declare function local:order () {83};          declare function local:ordered () {84};          declare function local:ordering () {85};          declare function local:parent () {86};          declare function local:pattern-separator () {87};          declare function local:per-mille () {88};          declare function local:percent () {89};          declare function local:preceding-sibling () {90};          declare function local:preceding () {91};          declare function local:preserve () {92};          declare function local:previous () {93};          declare function local:processing-instruction () {94};          declare function local:return () {95};          declare function local:satisfies () {96};          declare function local:schema-attribute () {97};          declare function local:schema-element () {98};          declare function local:schema () {99};          declare function local:self () {100};          declare function local:sliding () {101};          declare function local:some () {102};          declare function local:stable () {103};          declare function local:start () {104};          declare function local:strict () {105};          declare function local:strip () {106};          declare function local:switch () {107};          declare function local:text () {108};          declare function local:then () {109};          declare function local:to () {110};          declare function local:treat () {111};          declare function local:try () {112};          declare function local:tumbling () {113};          declare function local:type () {114};          declare function local:typeswitch () {115};          declare function local:union () {116};          declare function local:unordered () {117};          declare function local:validate () {118};          declare function local:variable () {119};          declare function local:version () {120};          declare function local:when () {121};          declare function local:where () {122};          declare function local:window () {123};          declare function local:xquery () {124};          declare function local:zero-digit () {125};                    local:NaN() +          local:allowing() +          local:ancestor-or-self() +          local:ancestor() +          local:and() +          local:as() +          local:ascending() +          local:at() +          local:attribute() +          local:base-uri() +          local:boundary-space() +          local:by() +          local:case() +          local:cast() +          local:castable() +          local:catch() +          local:child() +          local:collation() +          local:comment() +          local:construction() +          local:context() +          local:copy-namespaces() +          local:count() +          local:decimal-format() +          local:decimal-separator() +          local:declare() +          local:default() +          local:descendant-or-self() +          local:descendant() +          local:descending() +          local:digit() +          local:div() +          local:document-node() +          local:document() +          local:element() +          local:else() +          local:empty-sequence() +          local:empty() +          local:encoding() +          local:end() +          local:eq() +          local:every() +          local:except() +          local:external() +          local:following-sibling() +          local:following() +          local:for() +          local:function() +          local:ge() +          local:greatest() +          local:group() +          local:grouping-separator() +          local:gt() +          local:idiv() +          local:if() +          local:import() +          local:in() +          local:infinity() +          local:inherit() +          local:instance() +          local:intersect() +          local:is() +          local:item() +          local:lax() +          local:le() +          local:least() +          local:let() +          local:lt() +          local:minus-sign() +          local:mod() +          local:module() +          local:namespace-node() +          local:namespace() +          local:ne() +          local:next() +          local:no-inherit() +          local:no-preserve() +          local:node() +          local:of() +          local:only() +          local:option() +          local:or() +          local:order() +          local:ordered() +          local:ordering() +          local:parent() +          local:pattern-separator() +          local:per-mille() +          local:percent() +          local:preceding-sibling() +          local:preceding() +          local:preserve() +          local:previous() +          local:processing-instruction() +          local:return() +          local:satisfies() +          local:schema-attribute() +          local:schema-element() +          local:schema() +          local:self() +          local:sliding() +          local:some() +          local:stable() +          local:start() +          local:strict() +          local:strip() +          local:switch() +          local:text() +          local:then() +          local:to() +          local:treat() +          local:try() +          local:tumbling() +          local:type() +          local:typeswitch() +          local:union() +          local:unordered() +          local:validate() +          local:variable() +          local:version() +          local:when() +          local:where() +          local:window() +          local:xquery() +          local:zero-digit()          eq (125 * (125 + 1)) div 2
declare function local:nan() { xs:float("NaN") };         (1 to 10)[not(position() < xs:float("NaN"))]
declare function local:nothing() as empty-sequence() { () }; empty(local:nothing())
declare function local:odd($x as xs:integer) as xs:boolean {if ($x = 0) then false() else local:even($x - 1)};         declare function local:even($x as xs:integer) as xs:boolean {if ($x = 0) then true() else local:odd($x - 1)};         local:even(3)
declare function local:odd($x as xs:integer) as xs:boolean {if ($x = 0) then false() else local:even($x - 1)};         declare function local:even($x as xs:integer) as xs:boolean {if ($x = 0) then true() else local:odd($x - 1)};         local:even(4)
declare function local:odds($arg as xs:integer?) as xs:integer? { $arg[. mod 2 eq 1] }; boolean(for $x in local:odds(2) where $x < 3 return $x + 1)
declare function local:odds($arg as xs:integer*) as xs:integer* { $arg[. mod 2 eq 1] }; boolean(zero-or-one(for $x in local:odds((2,4,8)),$y in local:odds((2,4,8)) return ($x,$y)))
declare function local:ops() as (function(xs:string) as xs:string)*        { (upper-case#1, lower-case#1, function($x){translate($x, 'e', 'i')}, substring-before(?, ' ')) };        string-join(for $f in local:ops() return $f('Michael Kay'), '~')
declare function local:partners($c as xs:string) as element()* {              let $c := $company-data//company[name = $c]              return $c//partner          };          for $item in $string//news_item,              $c in $company-data//company          let $partners := local:partners(exactly-one($c/name))          where contains(string($item), $c/name)            and (some $p in $partners satisfies contains(string($item), $p) and $item/news_agent != $c/name)          return $item
declare function local:plus($x, $y) {           $x + $y         };         function-arity(local:plus#2)
declare function local:plus($x, $y) {           $x + $y         };         function-name(local:plus#2)
declare function local:plus($x, $y) {           $x + $y         };         let $f := (if (current-date() gt xs:date('1900-01-01')) then local:plus#2 else round#2)         return $f(5, 7)
declare function local:price ($i as element()) as element()? { $i/price };         for $j in /bib/book return local:price($j)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 24.5 eq count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 24.5 ge count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 24.5 gt count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 24.5 le count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 24.5 lt count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 24.5 ne count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 25 eq count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 25 ge count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 25 gt count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 25 le count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 25 lt count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 25 ne count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq -1
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq -1.5
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq 25
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq 25.5
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq xs:double("-1.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq xs:double("25.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq xs:double("INF")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq xs:double("NaN")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq xs:float("-1.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq xs:float("25.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq xs:float("INF")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq xs:float("NaN")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge -1
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge 1
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge -1.5
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge 25
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge 25.5
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge xs:double("1.0")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge xs:double("-1.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge xs:double("25.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge xs:double("INF")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge xs:double("NaN")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge xs:float("1.0")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge xs:float("-1.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge xs:float("25.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge xs:float("INF")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge xs:float("NaN")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt -1
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt -1.5
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt 25
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt 25.5
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt xs:double("-1.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt xs:double("25.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt xs:double("INF")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt xs:double("NaN")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt xs:float("-1.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt xs:float("25.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt xs:float("INF")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt xs:float("NaN")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le -1
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le -1.5
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le 25
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le 25.5
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le xs:double("-1.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le xs:double("25.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le xs:double("INF")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le xs:double("NaN")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le xs:float("-1.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le xs:float("25.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le xs:float("INF")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le xs:float("NaN")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt -1
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt -1.5
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt 25
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt 25.5
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt xs:double("-1.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt xs:double("25.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt xs:double("INF")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt xs:double("NaN")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt xs:float("-1.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt xs:float("25.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt xs:float("INF")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt xs:float("NaN")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne -1
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne -1.5
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne 25
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne 25.5
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne xs:double("-1.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne xs:double("25.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne xs:double("INF")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne xs:double("NaN")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne xs:float("-1.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne xs:float("25.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne xs:float("INF")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne xs:float("NaN")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) eq -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) eq local:square(5.1)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) ge 1.0
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) ge -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) ge local:square(5.1)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) gt -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) gt local:square(5.1)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) le -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) le local:square(5.1)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) lt -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) lt local:square(5.1)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) ne -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) ne local:square(5.1)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) eq -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) eq local:square(xs:double("4.9"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) ge -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) ge local:square(xs:double("4.9"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) gt -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) gt local:square(xs:double("4.9"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) le -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) le local:square(xs:double("4.9"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) lt -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) lt local:square(xs:double("4.9"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) ne -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) ne local:square(xs:double("4.9"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) eq -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) eq local:square(xs:float("4.9"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) ge -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) ge local:square(xs:float("4.9"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) gt -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) gt local:square(xs:float("4.9"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) le -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) le local:square(xs:float("4.9"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) lt -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) lt local:square(xs:float("4.9"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) ne -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) ne local:square(xs:float("4.9"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) eq -local:square(5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) eq local:square(5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) ge -local:square(5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) ge local:square(5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) gt -local:square(5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) gt local:square(5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) le -local:square(5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) le local:square(5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) lt -local:square(5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) lt local:square(5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) ne -local:square(5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) ne local:square(5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) eq local:strange(false())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) eq local:strange(true())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) ge local:strange(false())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) ge local:strange(true())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) gt local:strange(false())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) gt local:strange(true())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) le local:strange(false())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) le local:strange(true())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) lt local:strange(false())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) lt local:strange(true())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) ne local:strange(false())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) ne local:strange(true())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) eq local:strange(false())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) eq local:strange(true())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) ge local:strange(false())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) ge local:strange(true())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) gt local:strange(false())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) gt local:strange(true())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) le local:strange(false())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) le local:strange(true())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) lt local:strange(false())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) lt local:strange(true())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) ne local:strange(false())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) ne local:strange(true())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(24.5 eq count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(24.5 ge count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(24.5 gt count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(24.5 le count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(24.5 lt count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(24.5 ne count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(25 eq count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(25 ge count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(25 gt count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(25 le count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(25 lt count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(25 ne count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) eq 25)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) eq 25.5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) eq xs:double("25.5"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) eq xs:float("25.5"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) ge 25)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) ge 25.5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) ge xs:double("25.5"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) ge xs:float("25.5"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) gt 25)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) gt 25.5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) gt xs:double("25.5"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) gt xs:float("25.5"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) le 25)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) le 25.5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) le xs:double("25.5"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) le xs:float("25.5"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) lt 25)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) lt 25.5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) lt xs:double("25.5"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) lt xs:float("25.5"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) ne 25)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) ne 25.5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) ne xs:double("25.5"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) ne xs:float("25.5"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:double("24.5") eq count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:double("24.5") ge count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:double("24.5") gt count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:double("24.5") le count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:double("24.5") lt count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:double("24.5") ne count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:float("24.5") eq count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:float("24.5") ge count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:float("24.5") gt count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:float("24.5") le count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:float("24.5") lt count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:float("24.5") ne count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:double("24.5") eq count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:double("24.5") ge count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:double("24.5") gt count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:double("24.5") le count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:double("24.5") lt count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:double("24.5") ne count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:float("24.5") eq count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:float("24.5") ge count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:float("24.5") gt count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:float("24.5") le count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:float("24.5") lt count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:float("24.5") ne count(local:primes(100))
declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(2, 100)) eq count(local:primes(100, 200))
declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(2, 100)) ge count(local:primes(100, 200))
declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(2, 100)) gt count(local:primes(100, 200))
declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(2, 100)) le count(local:primes(100, 200))
declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(2, 100)) lt count(local:primes(100, 200))
declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(2, 100)) ne count(local:primes(100, 200))
declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(2, 100)) eq count(local:primes(100, 200)))
declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(2, 100)) ge count(local:primes(100, 200)))
declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(2, 100)) gt count(local:primes(100, 200)))
declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(2, 100)) le count(local:primes(100, 200)))
declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(2, 100)) lt count(local:primes(100, 200)))
declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(2, 100)) ne count(local:primes(100, 200)))
declare function local:prnt($n as xs:integer,$n2 as xs:string, $n3 as xs:date, $n4 as xs:long, $n5 as xs:string, $n6 as xs:decimal) { if ($n < 2) then 1 else concat($n, " ",$n2," ",$n3," ",$n4," ",$n5," ",$n6) };         <table> { <td>Value is = {local:prnt(4,xs:string("hello"),xs:date("2005-02-22"), xs:long(5),xs:string("well"),xs:decimal(1.2))}</td> } </table>
declare function local:QName-value($arg as xs:boolean) as xs:QName { if ($arg) then QName("example.com/", "p:ncname") else QName("example.com/", "q:ncname") };         not(local:QName-value(true()) eq local:QName-value(false()))
declare function local:QName-value($arg as xs:boolean) as xs:QName { if ($arg) then QName("example.com/", "p:ncname") else QName("example.com/", "q:ncname") };         not(local:QName-value(true()) ne local:QName-value(false()))
declare function local:recursiveFunction($i as xs:integer) as xs:integer { if($i eq 5) then $i else local:recursiveFunction($i + 1) };         declare function local:proxy() as xs:integer { local:recursiveFunction(0) + 3 };         local:proxy()
declare function local:repeat($count as xs:integer, $arg as xs:string) as item()* {         if ($count lt 0) then '$count must not be negative'         else text { for $x in 1 to $count return $arg }       };        fn:boolean( local:repeat(0, "string") )
declare function local:repeat($count as xs:integer, $arg as xs:string) as xs:string* { if ($count le 0) then "" else for $x in 1 to $count return $arg };         string-join( for $x in 0 to 4 return local:repeat($x, 'a') , ' ') and string-join( for $x in 0 to 4 return local:repeat($x, 'a') , '')
declare function local:repeat($count as xs:integer, $arg as xs:string) { for $x in 1 to $count return $arg };        fn:boolean( text { local:repeat(0, "string") } )
declare function local:round($x as xs:double, $algorithm as (function(xs:double) as xs:double)) as xs:double { $algorithm($x) };        declare variable $roundToCeiling := local:round(?, ceiling#1); $roundToCeiling(12.4)
declare function local:round($x as xs:double, $algorithm as (function(xs:double) as xs:double)) as xs:double          { $algorithm($x) };          declare variable $roundToCeiling := local:round(?, upper-case#1);          $roundToCeiling(12.4)
declare function local:round($x as xs:double) as xs:double         { fn:floor($x) };        declare function local:ops() as (function(xs:double) as xs:double)*         { (abs#1, local:round#1, function($x){$x+1}, round-half-to-even(?, 2)) };        string-join(for $f in local:ops() return string($f(xs:untypedAtomic('123.456'))), '~')
declare function local:round($x as xs:double) as xs:double { fn:floor($x) };        declare function local:ops() as (function(xs:double) as xs:double)*         { (abs#1, local:round#1, function($x as xs:double){$x+1}, round-half-to-even(?, 2)) };        string-join(for $f in local:ops() return string(round-half-to-even($f(xs:decimal('123.456')), 4)), '~')
declare function local:scramble($x as function(*), $y as xs:string) as xs:string { $x($y) };        declare function local:rot13($x as xs:string) as xs:string { translate($x, "abcdefghijklmnopqrstuvwxyz", "nopqrstuvwxyzabcdefghijklm") };        local:scramble(local:rot13#1, "mike")
declare function local:scramble($x as function(*), $y as xs:string) as xs:string { $x($y) };        local:scramble(function($x){translate($x, "abcdefghijklmnopqrstuvwxyz", "nopqrstuvwxyzabcdefghijklm")}, "john")
declare function local:scramble($x as function(xs:string) as xs:string, $y as xs:string) as xs:string         { $x($y) };        declare function local:rot13($x as xs:string) as xs:string         { translate($x, "abcdefghijklmnopqrstuvwxyz", "nopqrstuvwxyzabcdefghijklm") };        local:scramble(local:rot13#1, "mike")
declare function local:scramble($x as function(xs:string) as xs:string, $y as xs:string) as xs:string { $x($y) };        let $n := function-name(local:scramble#2)        return (local-name-from-QName($n), namespace-uri-from-QName($n), function-arity(local:scramble#2))
declare function local:scramble($x as function(xs:string) as xs:string, $y as xs:string) as xs:string { $x($y) };        local:scramble(function($x){translate($x, "abcdefghijklmnopqrstuvwxyz", "nopqrstuvwxyzabcdefghijklm")}, "john")
declare function local:section-summary($book-or-section as element()*) as element()* {              for $section in $book-or-section              return <section> { $section/@* } { $section/title } <figcount> { count($section/figure) } </figcount> { local:section-summary($section/section) } </section>          };          <toc> {              for $s in /book/section              return local:section-summary($s)          } </toc>
declare function local:sequence($arg as xs:integer) as item()* { if ($arg mod 2 eq 0) then (1, 3, 5, 7, 9, "cheese") else (xs:untypedAtomic("1"), xs:untypedAtomic("2")) }; for $x in local:sequence(2) for $y in local:sequence(3) where $x = $y return ($x, $y)
declare function local:sequence($arg as xs:integer) as item()* { if ($arg mod 2 eq 0) then (1, 3, 5, 7, 9) else ("a", "b", "c") }; for $x in local:sequence(2) for $y in local:sequence(2) where $x = $y return ($x, $y)
declare function local:sequence($arg as xs:integer) as item()* { if ($arg mod 2 eq 0) then (1, 3, 5, 7, 9) else ("a", "b", "c") }; for $x in local:sequence(2) for $y in local:sequence(3) where $x = $y return ($x, $y)
declare function local:splitter($sep as xs:string) as (function(xs:string) as xs:string*)         { function($x as xs:string) { for $i in tokenize($x, $sep) return upper-case($i)} };        string-join(local:splitter("\s")("A nice cup of tea"), '|')
declare function local:splitter($x as xs:string) as (function() as xs:string*)* {              for $sep in ('\s', ',', '!') return function() {                  for $i in tokenize($x, $sep) return                      let $f := function(){ concat($sep, ':', upper-case($i)) }                      return $f() }          };          <out>{              for $f as function(*) in local:splitter("How nice! Thank you, I enjoyed that.")              return <tokens>{ for $t in $f()                               return <t>{$t}</t> }</tokens>          }</out>
declare function local:splitter($x as xs:string) as (function() as xs:string*)* {              for $sep in ('\s', ',', '!')              return function() { for $i in tokenize($x, $sep) return upper-case($i) }          };          <out>{              for $f as function(*) in local:splitter("How nice! Thank you, I enjoyed that.")              return <tokens>{ for $t in $f()                               return <t>{$t}</t>                     }</tokens>         }</out>
declare function local:splitter() as (function(xs:string) as xs:string+)?        { function($x as xs:string) { for $i in tokenize($x, '\s') return upper-case($i)} };        string-join(local:splitter()("A nice cup of tea"), '|')
declare function local:splitter() as (function(xs:string) as xs:string*) { function($x as xs:string) { tokenize($x, '\s') } };        string-join(local:splitter()("A nice cup of tea"), '|')
declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };         0.0 * local:square(7.0)
declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };         -1.0 * local:square(7.0)
declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };         1.0 * local:square(7.0)
declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };         local:square(2.0) * 0.0
declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };         local:square(4294967296.0) idiv 0.0000000000005 gt 0
declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };         local:square(7.0) * -1.0
declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };         local:square(7.0) * 1.0
declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };         local:square(7.0) div -1.0
declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };         local:square(7.0) div 1.0
declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };         local:square(7.5) - 0.0
declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };         local:square(9223372036854775808.1) gt 0
declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };         not( local:square(1.0) eq local:square(2.0) )
declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg }; not( local:square(1.0) ge local:square(2.0) )
declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg }; not( local:square(1.0) gt local:square(2.0) )
declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg }; not( local:square(1.0) le local:square(2.0) )
declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg }; not( local:square(1.0) lt local:square(2.0) )
declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };         not( local:square(1.0) ne local:square(2.0) )
declare function local:square($arg as xs:double) as xs:double { $arg * $arg };         -1e0 * local:square(7)
declare function local:square($arg as xs:double) as xs:double { $arg * $arg };         1e0 * local:square(7)
declare function local:square($arg as xs:double) as xs:double { $arg * $arg };         local:square(7) * -1e0
declare function local:square($arg as xs:double) as xs:double { $arg * $arg };         local:square(7) * 1e0
declare function local:square($arg as xs:double) as xs:double { $arg * $arg };         local:square(7) div -1e0
declare function local:square($arg as xs:double) as xs:double { $arg * $arg };         local:square(7) div 1e0
declare function local:square($arg as xs:double) as xs:double { $arg * $arg };         local:square(7) div xs:double('NaN')
declare function local:square($arg as xs:double) as xs:double { $arg * $arg };         local:square(7) * xs:double('NaN')
declare function local:square($arg as xs:double) as xs:double { $arg * $arg };         not( local:square(1e0) eq local:square(2e0) )
declare function local:square($arg as xs:double) as xs:double { $arg * $arg }; not( local:square(1e0) ge local:square(2e0) )
declare function local:square($arg as xs:double) as xs:double { $arg * $arg }; not( local:square(1e0) gt local:square(2e0) )
declare function local:square($arg as xs:double) as xs:double { $arg * $arg }; not( local:square(1e0) le local:square(2e0) )
declare function local:square($arg as xs:double) as xs:double { $arg * $arg }; not( local:square(1e0) lt local:square(2e0) )
declare function local:square($arg as xs:double) as xs:double { $arg * $arg };         not( local:square(1e0) ne local:square(2e0) )
declare function local:square($arg as xs:double) as xs:double { $arg * $arg }; not(not( local:square(1e0) ge local:square(2e0) ))
declare function local:square($arg as xs:double) as xs:double { $arg * $arg }; not(not( local:square(1e0) gt local:square(2e0) ))
declare function local:square($arg as xs:double) as xs:double { $arg * $arg }; not(not( local:square(1e0) le local:square(2e0) ))
declare function local:square($arg as xs:double) as xs:double { $arg * $arg }; not(not( local:square(1e0) lt local:square(2e0) ))
declare function local:square($arg as xs:double) as xs:double { $arg * $arg };         xs:double('NaN') div local:square(7)
declare function local:square($arg as xs:double) as xs:double { $arg * $arg };         xs:double('NaN') * local:square(7)
declare function local:square($arg as xs:float) as xs:float { $arg * $arg };         local:square(7) div xs:float(-1)
declare function local:square($arg as xs:float) as xs:float { $arg * $arg };         local:square(7) div xs:float(1)
declare function local:square($arg as xs:float) as xs:float { $arg * $arg };         local:square(7) div xs:float('NaN')
declare function local:square($arg as xs:float) as xs:float { $arg * $arg };         local:square(7) * xs:float(-1)
declare function local:square($arg as xs:float) as xs:float { $arg * $arg };         local:square(7) * xs:float(1)
declare function local:square($arg as xs:float) as xs:float { $arg * $arg };         local:square(7) * xs:float('NaN')
declare function local:square($arg as xs:float) as xs:float { $arg * $arg };         not( local:square(xs:float(1e0)) eq local:square(xs:float(2e0)) )
declare function local:square($arg as xs:float) as xs:float { $arg * $arg }; not( local:square(xs:float(1e0)) ge local:square(xs:float(2e0)) )
declare function local:square($arg as xs:float) as xs:float { $arg * $arg }; not( local:square(xs:float(1e0)) gt local:square(xs:float(2e0)) )
declare function local:square($arg as xs:float) as xs:float { $arg * $arg }; not( local:square(xs:float(1e0)) le local:square(xs:float(2e0)) )
declare function local:square($arg as xs:float) as xs:float { $arg * $arg }; not( local:square(xs:float(1e0)) lt local:square(xs:float(2e0)) )
declare function local:square($arg as xs:float) as xs:float { $arg * $arg };         not( local:square(xs:float(1e0)) ne local:square(xs:float(2e0)) )
declare function local:square($arg as xs:float) as xs:float { $arg * $arg }; not(not( local:square(xs:float(1e0)) ge local:square(xs:float(2e0)) ))
declare function local:square($arg as xs:float) as xs:float { $arg * $arg }; not(not( local:square(xs:float(1e0)) gt local:square(xs:float(2e0)) ))
declare function local:square($arg as xs:float) as xs:float { $arg * $arg }; not(not( local:square(xs:float(1e0)) le local:square(xs:float(2e0)) ))
declare function local:square($arg as xs:float) as xs:float { $arg * $arg }; not(not( local:square(xs:float(1e0)) lt local:square(xs:float(2e0)) ))
declare function local:square($arg as xs:float) as xs:float { $arg * $arg };         xs:float(-1) * local:square(7)
declare function local:square($arg as xs:float) as xs:float { $arg * $arg };         xs:float(1) * local:square(7)
declare function local:square($arg as xs:float) as xs:float { $arg * $arg };         xs:float('NaN') div local:square(7)
declare function local:square($arg as xs:float) as xs:float { $arg * $arg };         xs:float('NaN') * local:square(7)
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         0 * local:square(2)
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         -1 * local:square(7)
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         1 * local:square(7)
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         let $x := local:square(4) return 0 eq $x + 1
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         let $x := local:square(4) return 0 eq $x - 1
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         let $x := local:square(4) return 4 eq $x + 1
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         let $x := local:square(4) return 4 eq $x - 1
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         let $x := local:square(4) return 4 eq 1 + $x
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         let $x := local:square(4) return 4 eq 1 - $x
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         let $x := local:square(4) return -52676506002282294014967032012 eq $x + 52676506002282294014967032012
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         let $x := local:square(4) return 52676506002282294014967032012 eq $x - 52676506002282294014967032012
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         let $x := local:square(4) return -52676506002282294014967032012 eq 52676506002282294014967032012 + $x
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         let $x := local:square(4) return -52676506002282294014967032012 eq 52676506002282294014967032012 - $x
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         local:square(2) * 0
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         local:square(7) - 0
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         local:square(7) * -1
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         local:square(7) * 1
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         local:square(7) div -1
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         local:square(7) div 1
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         local:square(9223372036854775808) gt 0
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         not( local:square(1) eq local:square(2) )
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg }; not( local:square(1) ge local:square(2) )
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg }; not( local:square(1) gt local:square(2) )
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg }; not( local:square(1) le local:square(2) )
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg }; not( local:square(1) lt local:square(2) )
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         not( local:square(1) ne local:square(2) )
declare function local:tag($arg) as element() { element { 'tag' } { $arg } };         <element> { processing-instruction { 'pi' } { "content", local:tag('?&gt;') } } </element>
declare function local:test($test as xs:integer) as xs:integer? {            if ($test = 1) then ( 0 ) else if ($test = 2) then ( 9 ) else if ($test = 3) then ( 13 ) else if ($test = 4) then ( 16 ) else ()          };          fn:codepoints-to-string( local:test(1) to 32 )
declare function local:test($test as xs:integer) as xs:integer? {            if ($test = 1) then ( 0 ) else if ($test = 2) then ( 9 ) else if ($test = 3) then ( 13 ) else if ($test = 4) then ( 16 ) else ()          };          fn:codepoints-to-string( local:test(2) to 32 )
declare function local:test($test as xs:integer) as xs:integer? {          if ($test = 1) then ( 0 ) else if ($test = 2) then ( 9 ) else if ($test = 3) then ( 13 )else if ($test = 4) then ( 16 ) else ()        };        fn:codepoints-to-string( local:test(3) to 32 )
declare function local:test($test as xs:integer) as xs:integer? {          if ($test = 1) then ( 0 ) else if ($test = 2) then ( 9 ) else if ($test = 3) then ( 13 ) else if ($test = 4) then ( 16 ) else ()        };        fn:codepoints-to-string( local:test(4) to 32 )
declare function local:tf($i as xs:integer) as function () as xs:boolean {              if ($i) then true#0 else false#0          };          <out>{(local:tf(0)(), local:tf(1)())}</out>
declare function local:times-table($n as xs:integer) as xs:integer* { for $x in 1 to 12 return $x * $n }; (every $x in local:times-table(15) satisfies ($x mod 3 eq 0)) and (every $y in local:times-table(15) satisfies ($y mod 5 eq 0))
declare function local:times-table($n as xs:integer) as xs:integer* { for $x in 1 to 12 return $x * $n }; (some $x in local:times-table(15) satisfies ($x mod 2 eq 0)) or (some $y in local:times-table(15) satisfies ($y mod 3 eq 0))
declare function local:title($a_book as element()) { for $i in $a_book return $i/title };         /bib/book/(local:title(.))
declare function local:toc($book-or-section as element()) as element()* {              for $section in $book-or-section/section              return <section> { $section/@* , $section/title , local:toc($section) } </section> };         <toc> { for $s in /book return local:toc($s) } </toc>
declare function local:t() { text{""}, text{"["}, text{"3"}, text{"]"}, text{""} };          declare variable $var := (text{""}, text{"["}, text{"3"}, text{"]"}, text{""});          <out fromFunction="{local:t()}" fromVariable="{$var}"/>
declare function local:two-digit($number as xs:integer) { let $string := string($number) return if (string-length($string) lt 2) then concat('0', $string) else $string }; declare function local:date($year as xs:integer, $month as xs:integer, $day as xs:integer) { let $m := local:two-digit($month), $d := local:two-digit($day) return xs:date(concat($year, '-', $m, '-', $d)) }; not(local:date(2008, 05, 12) eq xs:date("1972-12-15"))
declare function local:two-digit($number as xs:integer) { let $string := string($number) return if (string-length($string) lt 2) then concat('0', $string) else $string };         declare function local:date($year as xs:integer, $month as xs:integer, $day as xs:integer) { let $m := local:two-digit($month), $d := local:two-digit($day) return xs:date(concat($year, '-', $m, '-', $d)) };         not(local:date(2008, 05, 12) ge xs:date("1972-12-15"))
declare function local:two-digit($number as xs:integer) { let $string := string($number) return if (string-length($string) lt 2) then concat('0', $string) else $string };         declare function local:date($year as xs:integer, $month as xs:integer, $day as xs:integer) { let $m := local:two-digit($month), $d := local:two-digit($day) return xs:date(concat($year, '-', $m, '-', $d)) };         not(local:date(2008, 05, 12) le xs:date("1972-12-15"))
declare function local:two-digit($number as xs:integer) {         let $string := string($number) return if (string-length($string) lt 2) then concat('0', $string) else $string         };         declare function local:date($year as xs:integer, $month as xs:integer, $day as xs:integer) {         let $m := local:two-digit($month), $d := local:two-digit($day) return xs:date(concat($year, '-', $m, '-', $d))         };         not(local:date(2008, 05, 12) lt xs:date("1972-12-15"))
declare function local:two-digit($number as xs:integer) { let $string := string($number) return if (string-length($string) lt 2) then concat('0', $string) else $string }; declare function local:date($year as xs:integer, $month as xs:integer, $day as xs:integer) { let $m := local:two-digit($month), $d := local:two-digit($day) return xs:date(concat($year, '-', $m, '-', $d)) };         not(local:date(2008, 05, 12) lt xs:date("1972-12-15"))
declare function local:two-digit($number as xs:integer) { let $string := string($number) return if (string-length($string) lt 2) then concat('0', $string) else $string }; declare function local:date($year as xs:integer, $month as xs:integer, $day as xs:integer) { let $m := local:two-digit($month), $d := local:two-digit($day) return xs:date(concat($year, '-', $m, '-', $d)) }; not(local:date(2008, 05, 12) ne xs:date("1972-12-15"))
declare function local:two-digit($number as xs:integer) {         let $string := string($number)         return if (string-length($string) lt 2) then concat('0', $string) else $string         };         declare function local:dateTime($year as xs:integer, $month as xs:integer, $day as xs:integer) {         let $m := local:two-digit($month), $d := local:two-digit($day)         return xs:dateTime(concat($year, '-', $m, '-', $d, "T12:00:00"))         };         not(local:dateTime(2008, 05, 12) eq xs:dateTime("1972-12-15T12:00:00"))
declare function local:two-digit($number as xs:integer) { let $string := string($number) return if (string-length($string) lt 2) then concat('0', $string) else $string }; declare function local:dateTime($year as xs:integer, $month as xs:integer, $day as xs:integer) { let $m := local:two-digit($month), $d := local:two-digit($day) return xs:dateTime(concat($year, '-', $m, '-', $d, "T12:00:00")) }; not(local:dateTime(2008, 05, 12) ge xs:dateTime("1972-12-15T12:00:00"))
declare function local:two-digit($number as xs:integer) { let $string := string($number) return if (string-length($string) lt 2) then concat('0', $string) else $string }; declare function local:dateTime($year as xs:integer, $month as xs:integer, $day as xs:integer) { let $m := local:two-digit($month), $d := local:two-digit($day) return xs:dateTime(concat($year, '-', $m, '-', $d, "T12:00:00")) }; not(local:dateTime(2008, 05, 12) gt xs:dateTime("1972-12-15T12:00:00"))
declare function local:two-digit($number as xs:integer) { let $string := string($number) return if (string-length($string) lt 2) then concat('0', $string) else $string }; declare function local:dateTime($year as xs:integer, $month as xs:integer, $day as xs:integer) { let $m := local:two-digit($month), $d := local:two-digit($day) return xs:dateTime(concat($year, '-', $m, '-', $d, "T12:00:00")) }; not(local:dateTime(2008, 05, 12) le xs:dateTime("1972-12-15T12:00:00"))
declare function local:two-digit($number as xs:integer) { let $string := string($number) return if (string-length($string) lt 2) then concat('0', $string) else $string }; declare function local:dateTime($year as xs:integer, $month as xs:integer, $day as xs:integer) { let $m := local:two-digit($month), $d := local:two-digit($day) return xs:dateTime(concat($year, '-', $m, '-', $d, "T12:00:00")) }; not(local:dateTime(2008, 05, 12) lt xs:dateTime("1972-12-15T12:00:00"))
declare function local:two-digit($number as xs:integer) {         let $string := string($number)         return if (string-length($string) lt 2) then concat('0', $string) else $string         };         declare function local:dateTime($year as xs:integer, $month as xs:integer, $day as xs:integer) {         let $m := local:two-digit($month), $d := local:two-digit($day)         return xs:dateTime(concat($year, '-', $m, '-', $d, "T12:00:00"))         };         not(local:dateTime(2008, 05, 12) ne xs:dateTime("1972-12-15T12:00:00"))
declare function local:value($number as xs:boolean) { if ($number) then 1 else xs:string('1') };         +(local:value(true()))
declare function local:value($number as xs:boolean) { if ($number) then 1 else xs:string('1') }; -(local:value(true()))
declare function local:value($number as xs:boolean) { if ($number) then 1 else xs:string('1') };         local:value(true()) idiv local:value(true())
declare function local:value($number as xs:boolean) { if ($number) then 1 else xs:string('1') };         local:value(true()) mod local:value(true())
declare function local:yearMonthDuration($yearMonthDuration as xs:yearMonthDuration, $null as xs:boolean) { if ($null) then () else $yearMonthDuration };         exists(local:yearMonthDuration(xs:yearMonthDuration("P0Y"), fn:true()) ge xs:yearMonthDuration("P0Y"))
declare function local:yearMonthDuration($yearMonthDuration as xs:yearMonthDuration, $null as xs:boolean) { if ($null) then () else $yearMonthDuration };         exists(local:yearMonthDuration(xs:yearMonthDuration("P0Y"), fn:true()) gt xs:yearMonthDuration("P0Y"))
declare function local:yearMonthDuration($yearMonthDuration as xs:yearMonthDuration, $null as xs:boolean) { if ($null) then () else $yearMonthDuration };         exists(local:yearMonthDuration(xs:yearMonthDuration("P0Y"), fn:true()) le xs:yearMonthDuration("P0Y"))
declare function local:yearMonthDuration($yearMonthDuration as xs:yearMonthDuration, $null as xs:boolean) { if ($null) then () else $yearMonthDuration };         exists(local:yearMonthDuration(xs:yearMonthDuration("P0Y"), fn:true()) lt xs:yearMonthDuration("P0Y"))
declare function local:yearMonthDuration($yearMonthDuration as xs:yearMonthDuration, $null as xs:boolean) { if ($null) then () else $yearMonthDuration };         local:yearMonthDuration(xs:yearMonthDuration("P0Y"), fn:false()) ge xs:yearMonthDuration("P0Y")
declare function local:yearMonthDuration($yearMonthDuration as xs:yearMonthDuration, $null as xs:boolean) { if ($null) then () else $yearMonthDuration };         local:yearMonthDuration(xs:yearMonthDuration("P0Y"), fn:false()) gt xs:yearMonthDuration("P0Y")
declare function local:yearMonthDuration($yearMonthDuration as xs:yearMonthDuration, $null as xs:boolean) { if ($null) then () else $yearMonthDuration };         local:yearMonthDuration(xs:yearMonthDuration("P0Y"), fn:false()) le xs:yearMonthDuration("P0Y")
declare function local:yearMonthDuration($yearMonthDuration as xs:yearMonthDuration, $null as xs:boolean) { if ($null) then () else $yearMonthDuration };         local:yearMonthDuration(xs:yearMonthDuration("P0Y"), fn:false()) lt xs:yearMonthDuration("P0Y")
declare function local:yearMonthDuration($years as xs:integer, $months as xs:integer ) { xs:yearMonthDuration(concat('P', $years, 'Y', $months, 'M')) };         local:yearMonthDuration(1, 1) + local:yearMonthDuration(1, 1)
declare function local:yearMonthDuration($years as xs:integer, $months as xs:integer ) { xs:yearMonthDuration(concat('P', $years, 'Y', $months, 'M')) };         local:yearMonthDuration(1, 1) - local:yearMonthDuration(1, 1)
declare function local:yearMonthDuration($years as xs:integer, $months as xs:integer ) { xs:yearMonthDuration(concat('P', $years, 'Y', $months, 'M')) };         local:yearMonthDuration(1, 1) + xs:yearMonthDuration("P0Y")
declare function local:yearMonthDuration($years as xs:integer, $months as xs:integer ) { xs:yearMonthDuration(concat('P', $years, 'Y', $months, 'M')) };         local:yearMonthDuration(1, 1) - xs:yearMonthDuration("P0Y")
declare function local:yearMonthDuration($years as xs:integer, $months as xs:integer ) { xs:yearMonthDuration(concat('P', $years, 'Y', $months, 'M')) };         not(local:yearMonthDuration(1, 1) eq xs:yearMonthDuration("P0Y"))
declare function local:yearMonthDuration($years as xs:integer, $months as xs:integer ) { xs:yearMonthDuration(concat('P', $years, 'Y', $months, 'M')) };         not(local:yearMonthDuration(1, 1) ge xs:yearMonthDuration("P0Y"))
declare function local:yearMonthDuration($years as xs:integer, $months as xs:integer ) { xs:yearMonthDuration(concat('P', $years, 'Y', $months, 'M')) };         not(local:yearMonthDuration(1, 1) gt xs:yearMonthDuration("P0Y"))
declare function local:yearMonthDuration($years as xs:integer, $months as xs:integer ) { xs:yearMonthDuration(concat('P', $years, 'Y', $months, 'M')) };         not(local:yearMonthDuration(1, 1) le xs:yearMonthDuration("P0Y"))
declare function local:yearMonthDuration($years as xs:integer, $months as xs:integer ) { xs:yearMonthDuration(concat('P', $years, 'Y', $months, 'M')) };         not(local:yearMonthDuration(1, 1) lt xs:yearMonthDuration("P0Y"))
declare function local:yearMonthDuration($years as xs:integer, $months as xs:integer ) { xs:yearMonthDuration(concat('P', $years, 'Y', $months, 'M')) };         not(local:yearMonthDuration(1, 1) ne xs:yearMonthDuration("P0Y"))
declare function local:yearMonthDuration($years as xs:integer, $months as xs:integer ) { xs:yearMonthDuration(concat('P', $years, 'Y', $months, 'M')) };         xs:yearMonthDuration("P0Y") + local:yearMonthDuration(1, 1)
declare function local:yearMonthDuration($years as xs:integer, $months as xs:integer ) { xs:yearMonthDuration(concat('P', $years, 'Y', $months, 'M')) };         xs:yearMonthDuration("-P768614336404564650Y") - local:yearMonthDuration(768614336404564650, 1)
declare function local:yearMonthDuration($years as xs:integer) as xs:yearMonthDuration { xs:yearMonthDuration(concat("P", $years, "Y")) };         0 * local:yearMonthDuration(2)
declare function local:yearMonthDuration($years as xs:integer) as xs:yearMonthDuration { xs:yearMonthDuration(concat("P", $years, "Y")) };         1 * local:yearMonthDuration(2)
declare function local:yearMonthDuration($years as xs:integer) as xs:yearMonthDuration { xs:yearMonthDuration(concat("P", $years, "Y")) };         local:yearMonthDuration(2) * 0
declare function local:yearMonthDuration($years as xs:integer) as xs:yearMonthDuration { xs:yearMonthDuration(concat("P", $years, "Y")) };         local:yearMonthDuration(2) * 1
declare function local:yearMonthDuration($years as xs:integer) as xs:yearMonthDuration { xs:yearMonthDuration(concat("P", $years, "Y")) };         local:yearMonthDuration(2) div 0
declare function local:yearMonthDuration($years as xs:integer) as xs:yearMonthDuration { xs:yearMonthDuration(concat("P", $years, "Y")) };         local:yearMonthDuration(2) div 1
declare function local:yearMonthDuration($years as xs:integer) as xs:yearMonthDuration { xs:yearMonthDuration(concat("P", $years, "Y")) };         local:yearMonthDuration(768614336404564650) div 0.5
declare function local:yes-empty($arg as xs:boolean) as xs:string? { if ($arg) then 'yes' else () };        boolean(fn:codepoint-equal( local:yes-empty(fn:false()), local:yes-empty(fn:true()) ) )
declare function local:yes-empty($arg as xs:boolean) as xs:string? { if ($arg) then 'yes' else () };        boolean(fn:codepoint-equal( local:yes-empty(fn:true()), local:yes-empty(fn:false()) ) )
declare function local:yes-empty($arg as xs:boolean) as xs:string? { if ($arg) then 'yes' else () };        empty(fn:codepoint-equal( local:yes-empty(fn:false()), local:yes-empty(fn:true()) ) )
declare function local:yes-empty($arg as xs:boolean) as xs:string? { if ($arg) then 'yes' else () };        empty(fn:codepoint-equal( local:yes-empty(fn:true()), local:yes-empty(fn:false()) ) )
declare function local:yes-no($arg as xs:boolean) as xs:string { if ($arg) then 'yes' else 'no' };        fn:codepoint-equal( local:yes-no(fn:true()), local:yes-no(fn:false()) ) = false()
declare function local:yes-no($arg as xs:boolean) as xs:string { if ($arg) then 'yes' else 'no' };        fn:index-of( (fn:true(), fn:false()), fn:codepoint-equal( local:yes-no(fn:false()), local:yes-no(fn:true()) ) )
declare function name
declare function Q{http://www.example.com/ns/my}fn ($a as xs:integer) as xs:integer { $a + 2 };          <out>{Q{http://www.example.com/ns/my}fn(12)}</out>
declare function wrongNS() { 1 };         1
declare function xml:foo() { 1 }; xml:foo()
declare function xml:wrongNS() { 1 };         1
declare function xs:foo() { 1 }; xs:foo()
declare function xs:gYear($arg as xs:anyAtomicType?) as xs:gYear? { xs:gYear($arg) };         1
declare %local:x variable $foo := "bar";          $foo
declare namespace abc = "gopher://spinaltap.micro.umn.edu/00/Weather/California/somefile"; <abc:someElement>some content</abc:someElement>
declare namespace abc = "http://www.example.com/abc"; let $var := <abc:someElement>some content</abc:someElement> return namespace-uri-from-QName(node-name($var)) eq xs:anyURI("http://www.example.com/abc")
declare namespace abc = "mailto:someuser@someserver.com"; <abc:someElement>some content</abc:someElement>
declare namespace a = "http://a.com"; map:size(<a><a:b>x</a:b></a>/map{self::a:b})
declare namespace a = "http://example.com/A"; declare namespace b = "http://example.com/A"; <e> { attribute a:localName {()}, attribute b:localName {()} } </e>
declare namespace a = "http://example.com";         <dot>           <a:b>key</a:b>           <c>value</c>         </dot>         !         map{a:b:c}         =>         deep-equal(map{"key":<c>value</c>})
declare namespace a = "http://example.com";         <dot>           <a:b>key</a:b>           <c>value</c>         </dot>         !         map{a:*:c}         =>         deep-equal(map{"key":<c>value</c>})
declare namespace a = "http://example.com";         <dot>           <a:b>key</a:b>           <c>value</c>         </dot>         !         map{*:b:c}         =>         deep-equal(map{"key":<c>value</c>})
declare namespace a = "http://example.com";         <dot>           <a:b>key</a:b>         </dot>         !         map{a:b:*}         =>         deep-equal(map{"key":<a:b xmlns:a="http://example.com">key</a:b>})
declare namespace a = "http://example.com";         <dot>           <a:b>key</a:b>         </dot>         !         map{a:*:*}         =>         deep-equal(map{"key":<a:b xmlns:a="http://example.com">key</a:b>})
declare namespace a = "http://example.com";         <dot>           <a:b>key</a:b>         </dot>         !         map{*:b:*}         =>          deep-equal(map{"key":<a:b xmlns:a="http://example.com">key</a:b>})
declare namespace a = "http://www.example.org/annotation";          declare %a:translucent("true") %a:translucent("false") function local:foo() {             "bar"          };          local:foo()
declare namespace a = "http://www.example.org/annotation";          declare %a:translucent("true") %a:translucent("false") variable $foo := "bar";          $foo
declare namespace array="http://www.w3.org/2005/xpath-functions/array";         declare variable $data := map {           "color" : "blue",           "closed" : true(),           "points" : [[10,10], [20,10], [20,20], [10,20]]         };               declare variable $stroke := attribute stroke { $data("color") };         declare variable $points := attribute points { array:flatten($data("points")) };         if ($data("closed")) then <svg><polygon>{ $stroke, $points }</polygon></svg>          else <svg><polyline>{ $stroke, $points }</polyline></svg>
declare namespace b = "http://b.com"; map:size(<a><b:b>x</b:b></a>/map{b:b})
declare namespace b = "http://www.example.com/"; empty(<e xmlns="http://www.example.com/"><d xmlns=""><b/></d></e>/b:d/b:b)
declare namespace cat ='mycat';          <a t='cat:miau'>42</a>
declare namespace dt = "http://www.w3.org/2001/XMLSchema";          <Q3> { //*[@dt:*] } </Q3>
declare namespace eg = "http://example.com";          declare %eg:integer(1+2) function local:foo() { 0 };           local:foo()
declare namespace eg = "http://example.com";          declare %eg:sequential function local:foo() {             "bar"          };          local:foo()
declare namespace eg = "http://example.com";          declare %eg:sequential variable $foo := "bar";          $foo
declare namespace eg = "http://example.com";          %eg:sequential("abc", 3) function () { "bar" } ()
declare namespace eg = "http://example.com";          %eg:sequential function () { "bar" } ()
declare namespace eg = "http://example.com";          %eg:sequential(true())  function () { "bar" } ()
declare namespace eg = "http://example.com";          % Q{http://example.com}sequential("abc", 3) function () { "bar" } ()
declare namespace eg = "http://example.org"; declare function eg:distinct-nodes-stable ($arg as node()*) as node()* { for $a at $apos in $arg let $before_a := fn:subsequence($arg, 1, $apos - 1) where every $ba in $before_a satisfies not($ba is $a) return $a }; let $arg1 := (<element1>some data 1</element1>,<element2>some data 2</element2>) return eg:distinct-nodes-stable($arg1)
declare namespace eg = "http://example.org"; declare function eg:if-absent ( $node as node()?, $value as xs:anyAtomicType) as xs:anyAtomicType* { if ($node) then fn:data($node) else $value }; let $arg1 := <element1>some data</element1> let $arg2 as xs:anyAtomicType := 1 return eg:if-absent($arg1,$arg2)
declare namespace eg = "http://example.org"; declare function eg:if-empty ( $node as node()?, $value as xs:anyAtomicType) as xs:anyAtomicType* { if ($node and $node/child::node()) then fn:data($node) else $value }; let $arg1 := <element1>some data</element1> let $arg2 as xs:anyAtomicType := 1 return eg:if-empty($arg1,$arg2)
declare namespace eg = "http://example.org"; declare function eg:index-of-node($sequence as node()*, $srch as node()) as xs:integer* { for $n at $i in $sequence where ($n is $srch) return $i }; let $arg1 := (<element1>some data 1</element1>,<element2>some data 2</element2>) let $arg2 := $arg1[2] return eg:index-of-node($arg1, exactly-one($arg2))
declare namespace eg = "http://example.org"; declare function eg:noContextFunction() { . }; eg:noContextFunction()
declare namespace eg = "http://example.org";          declare function eg:noContextFunction() { name };          eg:noContextFunction()
declare namespace eg = "http://example.org"; declare function eg:string-pad ( $padString as xs:string?, $padCount as xs:integer) as xs:string { fn:string-join((for $i in 1 to $padCount return $padString), "") }; let $arg1 as xs:string := "A String" let $arg2 as xs:integer := 3 return eg:string-pad($arg1,$arg2)
declare namespace e = "http://example.com/ANamespace"; declare variable $e:exampleComThisVarIsNotRecognized as element(*) external; 1
declare namespace e = "http://example.com/ANamespace"; declare variable $e:exampleComThisVarIsNotRecognized external; 1
declare namespace ex = "http://www.example.com/";           declare function local:userFunction() { document-node(element(local:ncname)) }; 1
declare namespace fn = "http://www.example.com/examples"; let $var := <fn:someElement>some context</fn:someElement> return $var
declare namespace foo:bar = "http://www.example.com/examples"; "aa"
declare namespace foo = "%gg"; true()
declare namespace foo = "http://example.com"; <foo:new/>
declare namespace foo = "http://example.com"; <new/>
declare namespace foo = "http://example.org"; <foo:bar> Lentils </foo:bar>
declare namespace foo="http://localhost/";         <a><foo:b/><foo:c/></a>/foo:b/self::foo:*
declare namespace foo="http://www.example.com/foo"; element elem {attribute foo:attr {'text'}}
declare namespace foo="http://www.example.com/foo"; element foo:elem {'text'}
declare namespace foo="http://www.example.com/prolog"; (<elem xmlns:foo="http://www.example.com/parent"><foo:child/></elem>)//*:child
declare namespace foo="http://www.example.com/prolog"; <foo:elem xmlns:foo="http://www.example.com/element"/>
declare namespace foo = "http://www.example.org"; declare function foo:something($type) as xs:integer { $type }; foo:something('foo')
declare namespace foo = "http://www.example.org"; declare function foo:something($type as xs:integer) as xs:integer { if ($type eq 1) then xs:date('2007-11-28') else $type }; foo:something(1)
declare namespace foo = "http://www.example.org"; declare function foo:something($type as xs:integer) { if ($type eq 1) then xs:date('2007-11-28') else 1.0 }; abs(foo:something(1))
declare namespace foo = "http://www.example.org"; declare function foo:something($type as xs:integer) { if ($type eq 1) then xs:date('2007-11-28') else 'foo' }; <e> { attribute { foo:something(1) } { } } </e>
declare namespace foo = "http://www.example.org"; declare function foo:something($type as xs:integer) { if ($type eq 1) then xs:date('2007-11-28') else 'foo' }; element { foo:something(1) } { }
declare namespace foo = "http://www.example.org"; declare function foo:something($type as xs:integer) { if ($type eq 1) then xs:date('2007-11-28') else 'foo' }; processing-instruction { foo:something(1) } { }
declare namespace foo = "http://www..oracle.com/xquery/test";         declare function foo:price ($b as element()) as element()* { $b/price };         1
declare namespace foo = "http://www..oracle.com/xquery/test";         declare function foo:price () as xs:integer+ { 100 };         declare function foo:price ($z as xs:integer) as xs:integer+ { $z };         declare function foo:price ($x as xs:integer, $y as xs:integer) as xs:integer+ { $x, $y };         declare function foo:price ($x as xs:integer, $y as xs:integer, $z as xs:integer) as xs:integer+ { $x+$y+$z };         foo:price(), foo:price(1), foo:price(2,3), foo:price(4,5,6)
declare namespace foo = "http://www.w3.org/XML/1998/namespace"; "a"
declare namespace foo="http://www.w3.org/XQueryTest/Construct"; <elem foo:attr="value"/>
declare namespace foo="test";         let $x := <a><foo:b/><c/><d/></a> return count($x/foo:* | $x/foo:*)
declare namespace fs="http://www.example.com/filesystem";          for $test as document-node() in (/) return ($test//fs:Folder)[1]/fs:FolderName
declare namespace fs="http://www.example.com/filesystem";          for $test as item() in data( (//fs:Folder)[1]/fs:File/fs:FileName ) return $test
declare namespace fs="http://www.example.com/filesystem";          for $test as item() in (//fs:Folder)[1]/fs:File/fs:FileName return $test
declare namespace fs="http://www.example.com/filesystem";          for $test as node() in (//fs:Folder)[1]/fs:File return $test/fs:FileName
declare namespace fs="http://www.example.com/filesystem";          for $test as processing-instruction() in (//fs:Folder)[1]//processing-instruction() return $test
declare namespace fs="http://www.example.com/filesystem"; for $test as processing-instruction() in (//fs:Folder)[1]//processing-instruction() return $test
declare namespace functx = "http://www.example.com/";                     (:~ : A path to an XML node (or sequence of nodes) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_path-to-node.html : @param $nodes the node sequence :)          declare function functx:path-to-node ( $nodes as node()* ) as xs:string* { $nodes/string-join(ancestor-or-self::*/name(.), '/') } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:path-to-node($in-xml/*[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : A path to an XML node (or sequence of nodes) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_path-to-node.html : @param $nodes the node sequence :)          declare function functx:path-to-node ( $nodes as node()* ) as xs:string* { $nodes/string-join(ancestor-or-self::*/name(.), '/') } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:path-to-node($in-xml//lName[. = 'Doe']))
declare namespace functx = "http://www.example.com/";                     (:~ : A path to an XML node (or sequence of nodes) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_path-to-node.html : @param $nodes the node sequence :)          declare function functx:path-to-node ( $nodes as node()* ) as xs:string* { $nodes/string-join(ancestor-or-self::*/name(.), '/') } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:path-to-node($in-xml//lName[. = 'Doe']), functx:path-to-node($in-xml/*[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : Capitalizes the first character of a string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_capitalize-first.html : @param $arg the word or phrase to capitalize :)          declare function functx:capitalize-first ( $arg as xs:string? ) as xs:string? { concat(upper-case(substring($arg,1,1)), substring($arg,2)) } ;                     (functx:capitalize-first('hello'))
declare namespace functx = "http://www.example.com/";                     (:~ : Capitalizes the first character of a string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_capitalize-first.html : @param $arg the word or phrase to capitalize :)          declare function functx:capitalize-first ( $arg as xs:string? ) as xs:string? { concat(upper-case(substring($arg,1,1)), substring($arg,2)) } ;                     (functx:capitalize-first('hello'), functx:capitalize-first('hello world'), functx:capitalize-first('Hello world'))
declare namespace functx = "http://www.example.com/";                     (:~ : Capitalizes the first character of a string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_capitalize-first.html : @param $arg the word or phrase to capitalize :)          declare function functx:capitalize-first ( $arg as xs:string? ) as xs:string? { concat(upper-case(substring($arg,1,1)), substring($arg,2)) } ;                     (functx:capitalize-first('hello world'))
declare namespace functx = "http://www.example.com/";                     (:~ : Capitalizes the first character of a string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_capitalize-first.html : @param $arg the word or phrase to capitalize :)          declare function functx:capitalize-first ( $arg as xs:string? ) as xs:string? { concat(upper-case(substring($arg,1,1)), substring($arg,2)) } ;                     (functx:capitalize-first('Hello world'))
declare namespace functx = "http://www.example.com/";                     (:~ : Capitalizes the first character of a string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_capitalize-first.html : @param $arg the word or phrase to capitalize :)          declare function functx:capitalize-first ( $arg as xs:string? ) as xs:string? { concat(upper-case(substring($arg,1,1)), substring($arg,2)) } ;                     (:~ : Turns a string of words into camelCase : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_words-to-camel-case.html : @param $arg the string to modify :)          declare function functx:words-to-camel-case ( $arg as xs:string? ) as xs:string { string-join((tokenize($arg,'\s+')[1], for $word in tokenize($arg,'\s+')[position() >                     1] return functx:capitalize-first($word)) ,'') } ;                     (functx:words-to-camel-case('this Is A Term'))
declare namespace functx = "http://www.example.com/";                     (:~ : Capitalizes the first character of a string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_capitalize-first.html : @param $arg the word or phrase to capitalize :)          declare function functx:capitalize-first ( $arg as xs:string? ) as xs:string? { concat(upper-case(substring($arg,1,1)), substring($arg,2)) } ;                     (:~ : Turns a string of words into camelCase : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_words-to-camel-case.html : @param $arg the string to modify :)          declare function functx:words-to-camel-case ( $arg as xs:string? ) as xs:string { string-join((tokenize($arg,'\s+')[1], for $word in tokenize($arg,'\s+')[position() >                     1] return functx:capitalize-first($word)) ,'') } ;                     (functx:words-to-camel-case( 'This is a term'))
declare namespace functx = "http://www.example.com/";                     (:~ : Capitalizes the first character of a string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_capitalize-first.html : @param $arg the word or phrase to capitalize :)          declare function functx:capitalize-first ( $arg as xs:string? ) as xs:string? { concat(upper-case(substring($arg,1,1)), substring($arg,2)) } ;                     (:~ : Turns a string of words into camelCase : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_words-to-camel-case.html : @param $arg the string to modify :)          declare function functx:words-to-camel-case ( $arg as xs:string? ) as xs:string { string-join((tokenize($arg,'\s+')[1], for $word in tokenize($arg,'\s+')[position() >                     1] return functx:capitalize-first($word)) ,'') } ;                     (functx:words-to-camel-case('this Is A Term'), functx:words-to-camel-case( 'This is a term'))
declare namespace functx = "http://www.example.com/";                     (:~ : Changes the namespace of XML elements and its descendants : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-ns-deep.html : @param $nodes the nodes to change : @param $newns the new namespace : @param $prefix the prefix to use for the new namespace :)          declare function functx:change-element-ns-deep ( $nodes as node()* , $newns as xs:string , $prefix as xs:string ) as node()* { for $node in $nodes return if ($node instance of element()) then (element {QName ($newns, concat($prefix, if ($prefix = '') then '' else ':', local-name($node)))} {$node/@*, functx:change-element-ns-deep($node/node(), $newns, $prefix)}) else if ($node instance of document-node()) then functx:change-element-ns-deep($node/node(), $newns, $prefix) else $node } ;                     let $in-xml := <bar:a xmlns:bar="http://bar"> <bar:b>557</bar:b> <bar:c>xyz</bar:c> </bar:a> return (functx:change-element-ns-deep( $in-xml, 'http://foo',''))
declare namespace functx = "http://www.example.com/";                     (:~ : Changes the namespace of XML elements and its descendants : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-ns-deep.html : @param $nodes the nodes to change : @param $newns the new namespace : @param $prefix the prefix to use for the new namespace :)          declare function functx:change-element-ns-deep ( $nodes as node()* , $newns as xs:string , $prefix as xs:string ) as node()* { for $node in $nodes return if ($node instance of element()) then (element {QName ($newns, concat($prefix, if ($prefix = '') then '' else ':', local-name($node)))} {$node/@*, functx:change-element-ns-deep($node/node(), $newns, $prefix)}) else if ($node instance of document-node()) then functx:change-element-ns-deep($node/node(), $newns, $prefix) else $node } ;                     let $in-xml := <bar:a xmlns:bar="http://bar"> <bar:b>557</bar:b> <bar:c>xyz</bar:c> </bar:a> return (functx:change-element-ns-deep( $in-xml, 'http://foo','foo'))
declare namespace functx = "http://www.example.com/";                     (:~ : Changes the namespace of XML elements and its descendants : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-ns-deep.html : @param $nodes the nodes to change : @param $newns the new namespace : @param $prefix the prefix to use for the new namespace :)          declare function functx:change-element-ns-deep ( $nodes as node()* , $newns as xs:string , $prefix as xs:string ) as node()* { for $node in $nodes return if ($node instance of element()) then (element {QName ($newns, concat($prefix, if ($prefix = '') then '' else ':', local-name($node)))} {$node/@*, functx:change-element-ns-deep($node/node(), $newns, $prefix)}) else if ($node instance of document-node()) then functx:change-element-ns-deep($node/node(), $newns, $prefix) else $node } ;                     let $in-xml := <bar:a xmlns:bar="http://bar"> <bar:b>557</bar:b> <bar:c>xyz</bar:c> </bar:a> return (functx:change-element-ns-deep( $in-xml, 'http://foo',''), functx:change-element-ns-deep( $in-xml, 'http://foo','foo'))
declare namespace functx = "http://www.example.com/";                     (:~ : Changes the namespace of XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-ns.html : @param $elements the elements to change : @param $newns the new namespace : @param $prefix the prefix to use for the new namespace :)          declare function functx:change-element-ns ( $elements as element()* , $newns as xs:string , $prefix as xs:string ) as element()? { for $element in $elements return element {QName ($newns, concat($prefix, if ($prefix = '') then '' else ':', local-name($element)))} {$element/@*, $element/node()} } ;                     let $in-xml := <bar:a xmlns:bar="http://bar"> <bar:b>557</bar:b> <bar:c>xyz</bar:c> </bar:a> return (functx:change-element-ns( $in-xml, 'http://foo',''))
declare namespace functx = "http://www.example.com/";                     (:~ : Changes the namespace of XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-ns.html : @param $elements the elements to change : @param $newns the new namespace : @param $prefix the prefix to use for the new namespace :)          declare function functx:change-element-ns ( $elements as element()* , $newns as xs:string , $prefix as xs:string ) as element()? { for $element in $elements return element {QName ($newns, concat($prefix, if ($prefix = '') then '' else ':', local-name($element)))} {$element/@*, $element/node()} } ;                     let $in-xml := <bar:a xmlns:bar="http://bar"> <bar:b>557</bar:b> <bar:c>xyz</bar:c> </bar:a> return (functx:change-element-ns( $in-xml, 'http://foo','foo'))
declare namespace functx = "http://www.example.com/";                     (:~ : Changes the namespace of XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-ns.html : @param $elements the elements to change : @param $newns the new namespace : @param $prefix the prefix to use for the new namespace :)          declare function functx:change-element-ns ( $elements as element()* , $newns as xs:string , $prefix as xs:string ) as element()? { for $element in $elements return element {QName ($newns, concat($prefix, if ($prefix = '') then '' else ':', local-name($element)))} {$element/@*, $element/node()} } ;                     let $in-xml := <bar:a xmlns:bar="http://bar"> <bar:b>557</bar:b> <bar:c>xyz</bar:c> </bar:a> return (functx:change-element-ns( $in-xml, 'http://foo',''), functx:change-element-ns( $in-xml, 'http://foo','foo'))
declare namespace functx = "http://www.example.com/";                     (:~ : Construct a dayTimeDuration from a number of days, hours, etc. : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_daytimeduration.html : @param $days the number of days : @param $hours the number of hours : @param $minutes the number of minutes : @param $seconds the number of seconds :)          declare function functx:dayTimeDuration ( $days as xs:decimal? , $hours as xs:decimal? , $minutes as xs:decimal? , $seconds as xs:decimal? ) as xs:dayTimeDuration { (xs:dayTimeDuration('P1D') * functx:if-empty($days,0)) + (xs:dayTimeDuration('PT1H') * functx:if-empty($hours,0)) + (xs:dayTimeDuration('PT1M') * functx:if-empty($minutes,0)) + (xs:dayTimeDuration('PT1S') * functx:if-empty($seconds,0)) } ;                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (functx:dayTimeDuration(0,0,0,0))
declare namespace functx = "http://www.example.com/";                     (:~ : Construct a dayTimeDuration from a number of days, hours, etc. : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_daytimeduration.html : @param $days the number of days : @param $hours the number of hours : @param $minutes the number of minutes : @param $seconds the number of seconds :)          declare function functx:dayTimeDuration ( $days as xs:decimal? , $hours as xs:decimal? , $minutes as xs:decimal? , $seconds as xs:decimal? ) as xs:dayTimeDuration { (xs:dayTimeDuration('P1D') * functx:if-empty($days,0)) + (xs:dayTimeDuration('PT1H') * functx:if-empty($hours,0)) + (xs:dayTimeDuration('PT1M') * functx:if-empty($minutes,0)) + (xs:dayTimeDuration('PT1S') * functx:if-empty($seconds,0)) } ;                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (functx:dayTimeDuration(0,0,5,0))
declare namespace functx = "http://www.example.com/";                     (:~ : Construct a dayTimeDuration from a number of days, hours, etc. : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_daytimeduration.html : @param $days the number of days : @param $hours the number of hours : @param $minutes the number of minutes : @param $seconds the number of seconds :)          declare function functx:dayTimeDuration ( $days as xs:decimal? , $hours as xs:decimal? , $minutes as xs:decimal? , $seconds as xs:decimal? ) as xs:dayTimeDuration { (xs:dayTimeDuration('P1D') * functx:if-empty($days,0)) + (xs:dayTimeDuration('PT1H') * functx:if-empty($hours,0)) + (xs:dayTimeDuration('PT1M') * functx:if-empty($minutes,0)) + (xs:dayTimeDuration('PT1S') * functx:if-empty($seconds,0)) } ;                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (functx:dayTimeDuration(1,6,0,0))
declare namespace functx = "http://www.example.com/";                     (:~ : Construct a dayTimeDuration from a number of days, hours, etc. : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_daytimeduration.html : @param $days the number of days : @param $hours the number of hours : @param $minutes the number of minutes : @param $seconds the number of seconds :)          declare function functx:dayTimeDuration ( $days as xs:decimal? , $hours as xs:decimal? , $minutes as xs:decimal? , $seconds as xs:decimal? ) as xs:dayTimeDuration { (xs:dayTimeDuration('P1D') * functx:if-empty($days,0)) + (xs:dayTimeDuration('PT1H') * functx:if-empty($hours,0)) + (xs:dayTimeDuration('PT1M') * functx:if-empty($minutes,0)) + (xs:dayTimeDuration('PT1S') * functx:if-empty($seconds,0)) } ;                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (functx:dayTimeDuration(2.5,0,0,0))
declare namespace functx = "http://www.example.com/";                     (:~ : Converts a string to a sequence of characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_chars.html : @param $arg the string to split :)          declare function functx:chars ( $arg as xs:string? ) as xs:string* { for $ch in string-to-codepoints($arg) return codepoints-to-string($ch) } ;                     (functx:chars('a b c'))
declare namespace functx = "http://www.example.com/";                     (:~ : Converts a string to a sequence of characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_chars.html : @param $arg the string to split :)          declare function functx:chars ( $arg as xs:string? ) as xs:string* { for $ch in string-to-codepoints($arg) return codepoints-to-string($ch) } ;                     (functx:chars('abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : Converts a string to a sequence of characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_chars.html : @param $arg the string to split :)          declare function functx:chars ( $arg as xs:string? ) as xs:string* { for $ch in string-to-codepoints($arg) return codepoints-to-string($ch) } ;                     (functx:chars('abc'), functx:chars('a b c'))
declare namespace functx = "http://www.example.com/";                     (:~ : Copies attributes from one element to another : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_copy-attributes.html : @param $copyTo the element to copy attributes to : @param $copyFrom the element to copy attributes from :)          declare function functx:copy-attributes ( $copyTo as element() , $copyFrom as element() ) as element() { element { node-name($copyTo)} { $copyTo/@*[not(node-name(.) = $copyFrom/@*/node-name(.))], $copyFrom/@*, $copyTo/node() } } ;                     let $in-xml := <in-xml> <a>123</a>> <b x="1" y="2">456</b> <c x="9">123</c> <d z="5">123</d> </in-xml> return (functx:copy-attributes( $in-xml/a, $in-xml/b))
declare namespace functx = "http://www.example.com/";                     (:~ : Copies attributes from one element to another : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_copy-attributes.html : @param $copyTo the element to copy attributes to : @param $copyFrom the element to copy attributes from :)          declare function functx:copy-attributes ( $copyTo as element() , $copyFrom as element() ) as element() { element { node-name($copyTo)} { $copyTo/@*[not(node-name(.) = $copyFrom/@*/node-name(.))], $copyFrom/@*, $copyTo/node() } } ;                     let $in-xml := <in-xml> <a>123</a>> <b x="1" y="2">456</b> <c x="9">123</c> <d z="5">123</d> </in-xml> return (functx:copy-attributes( $in-xml/a, $in-xml/b), functx:copy-attributes( $in-xml/b, $in-xml/c), functx:copy-attributes( $in-xml/d, $in-xml/c))
declare namespace functx = "http://www.example.com/";                     (:~ : Copies attributes from one element to another : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_copy-attributes.html : @param $copyTo the element to copy attributes to : @param $copyFrom the element to copy attributes from :)          declare function functx:copy-attributes ( $copyTo as element() , $copyFrom as element() ) as element() { element { node-name($copyTo)} { $copyTo/@*[not(node-name(.) = $copyFrom/@*/node-name(.))], $copyFrom/@*, $copyTo/node() } } ;                     let $in-xml := <in-xml> <a>123</a>> <b x="1" y="2">456</b> <c x="9">123</c> <d z="5">123</d> </in-xml> return (functx:copy-attributes( $in-xml/b, $in-xml/c))
declare namespace functx = "http://www.example.com/";                     (:~ : Copies attributes from one element to another : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_copy-attributes.html : @param $copyTo the element to copy attributes to : @param $copyFrom the element to copy attributes from :)          declare function functx:copy-attributes ( $copyTo as element() , $copyFrom as element() ) as element() { element { node-name($copyTo)} { $copyTo/@*[not(node-name(.) = $copyFrom/@*/node-name(.))], $copyFrom/@*, $copyTo/node() } } ;                     let $in-xml := <in-xml> <a>123</a>> <b x="1" y="2">456</b> <c x="9">123</c> <d z="5">123</d> </in-xml> return (functx:copy-attributes( $in-xml/d, $in-xml/c))
declare namespace functx = "http://www.example.com/";        declare function functx:leaf-elements ( $root as node()? ) as element()* { $root/descendant-or-self::*[not(*)] } ;         let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author>                                   <author> <fName>John</fName> <lName>Doe</lName> </author>                         </authors>          return (functx:leaf-elements($in-xml))
declare namespace functx = "http://www.example.com/";         declare function functx:leaf-elements ( $root as node()? ) as element()* { $root/descendant-or-self::*[not(*)] } ;         let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author>                                   <author> <fName>John</fName> <lName>Doe</lName> </author>                         </authors>          return (functx:leaf-elements($in-xml/author[1]))
declare namespace functx = "http://www.example.com/";         declare function functx:leaf-elements ( $root as node()? ) as element()* { $root/descendant-or-self::*[not(*)] } ;         let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author>                                   <author> <fName>John</fName> <lName>Doe</lName> </author>                         </authors>          return (functx:leaf-elements($in-xml), functx:leaf-elements($in-xml/author[1]))
declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? {              for $element in $elements              return element { node-name($element)} {                 for $attrName at $seq in $attrNames                 return if ($element/@*[node-name(.) = $attrName]) then () else attribute {$attrName} {$attrValues[$seq]}, $element/@*, $element/node() }              } ;          let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml>           return (functx:add-attributes( $in-xml/a, QName('http://new','new:att1'), 1))
declare namespace functx = "http://www.example.com/";             declare namespace new = "http://new";             (:~                 : Adds attributes to XML elements :                 : @author Priscilla Walmsley, Datypic                 : @version 1.0                 : @see http://www.xqueryfunctions.com/xq/functx_add-attributes.html                 : @param $elements the element(s) to which you wish to add the attribute                 : @param $attrNames the name(s) of the attribute(s) to add                 : @param $attrValues the value(s) of the attribute(s) to add :)             declare function functx:add-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? {                 for $element in $elements return element { node-name($element)} {                    for $attrName at $seq in $attrNames return                                          if ($element/@*[node-name(.) = $attrName]) then () else attribute {$attrName} {$attrValues[$seq]}, $element/@*, $element/node() }              } ;             let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml>              return (functx:add-attributes( $in-xml/a, xs:QName('att1'), 1))
declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";          (:~              : Adds attributes to XML elements :              : @author Priscilla Walmsley, Datypic              : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-attributes.html              : @param $elements the element(s) to which you wish to add the attribute              : @param $attrNames the name(s) of the attribute(s) to add              : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? {              for $element in $elements              return element { node-name($element)} {                 for $attrName at $seq in $attrNames                 return if ($element/@*[node-name(.) = $attrName]) then () else attribute {$attrName} {$attrValues[$seq]}, $element/@*, $element/node() }           } ;          let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml>           return (functx:add-attributes( $in-xml/a, xs:QName('att1'), 1),                    functx:add-attributes( $in-xml/a, (xs:QName('att1'),xs:QName('att2')), (1,2)),                    functx:add-attributes( $in-xml/b, (xs:QName('att1'),xs:QName('att2')), (1,2)),                    functx:add-attributes( $in-xml/a, xs:QName('new:att1'), 1),                    functx:add-attributes( $in-xml/a, QName('http://new','new:att1'), 1))
declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";          (:~              : Adds attributes to XML elements :              : @author Priscilla Walmsley, Datypic              : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-attributes.html              : @param $elements the element(s) to which you wish to add the attribute              : @param $attrNames the name(s) of the attribute(s) to add              : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? {              for $element in $elements              return element { node-name($element)} {                 for $attrName at $seq in $attrNames                 return if ($element/@*[node-name(.) = $attrName]) then () else attribute {$attrName} {$attrValues[$seq]}, $element/@*, $element/node() }           } ;          let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml>           return (functx:add-attributes( $in-xml/a, (xs:QName('att1'),xs:QName('att2')), (1,2)))
declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? {              for $element in $elements return element { node-name($element)} {                 for $attrName at $seq in $attrNames                 return if ($element/@*[node-name(.) = $attrName]) then () else attribute {$attrName} {$attrValues[$seq]}, $element/@*, $element/node() }           } ;          let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml>           return (functx:add-attributes( $in-xml/a, xs:QName('new:att1'), 1))
declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";          (:~              : Adds attributes to XML elements :              : @author Priscilla Walmsley, Datypic              : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-attributes.html              : @param $elements the element(s) to which you wish to add the attribute              : @param $attrNames the name(s) of the attribute(s) to add              : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? {              for $element in $elements              return element { node-name($element)} {                 for $attrName at $seq in $attrNames                 return if ($element/@*[node-name(.) = $attrName]) then () else attribute {$attrName} {$attrValues[$seq]}, $element/@*, $element/node() }           } ;          let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml>           return (functx:add-attributes( $in-xml/b, (xs:QName('att1'),xs:QName('att2')), (1,2)))
declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-or-update-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-or-update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return attribute {$attrName} {$attrValues[$seq]}, $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml> return (functx:add-or-update-attributes( $in-xml/a, QName('http://new','new:att1'), 1))
declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-or-update-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-or-update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return attribute {$attrName} {$attrValues[$seq]}, $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml> return (functx:add-or-update-attributes( $in-xml/a, xs:QName('att1'), 1))
declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-or-update-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-or-update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return attribute {$attrName} {$attrValues[$seq]}, $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml> return (functx:add-or-update-attributes( $in-xml/a, xs:QName('att1'), 1), functx:add-or-update-attributes( $in-xml/a, (xs:QName('att1'),xs:QName('att2')), (1,2)), functx:add-or-update-attributes( $in-xml/b, (xs:QName('att1'),xs:QName('att2')), (1,2)), functx:add-or-update-attributes( $in-xml/a, xs:QName('new:att1'), 1), functx:add-or-update-attributes( $in-xml/a, QName('http://new','new:att1'), 1))
declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-or-update-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-or-update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return attribute {$attrName} {$attrValues[$seq]}, $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml> return (functx:add-or-update-attributes( $in-xml/a, (xs:QName('att1'),xs:QName('att2')), (1,2)))
declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-or-update-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-or-update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return attribute {$attrName} {$attrValues[$seq]}, $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml> return (functx:add-or-update-attributes( $in-xml/a, xs:QName('new:att1'), 1))
declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-or-update-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-or-update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return attribute {$attrName} {$attrValues[$seq]}, $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml> return (functx:add-or-update-attributes( $in-xml/b, (xs:QName('att1'),xs:QName('att2')), (1,2)))
declare namespace functx = "http://www.example.com/";          declare namespace new = "http://newns";                     (:~ : Wraps a sequence of atomic values in XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_wrap-values-in-elements.html : @param $values the values to wrap in elements : @param $elementName the name of the elements to construct :)          declare function functx:wrap-values-in-elements ( $values as xs:anyAtomicType* , $elementName as xs:QName ) as element()* { for $value in $values return element {$elementName} {$value} } ;                     (functx:wrap-values-in-elements( (1,2,3), QName('http://newns','new:num')))
declare namespace functx = "http://www.example.com/";          declare namespace new = "http://newns";                     (:~ : Wraps a sequence of atomic values in XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_wrap-values-in-elements.html : @param $values the values to wrap in elements : @param $elementName the name of the elements to construct :)          declare function functx:wrap-values-in-elements ( $values as xs:anyAtomicType* , $elementName as xs:QName ) as element()* { for $value in $values return element {$elementName} {$value} } ;                     (functx:wrap-values-in-elements( (1,2,3), QName('http://newns','num')))
declare namespace functx = "http://www.example.com/";          declare namespace new = "http://newns";                     (:~ : Wraps a sequence of atomic values in XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_wrap-values-in-elements.html : @param $values the values to wrap in elements : @param $elementName the name of the elements to construct :)          declare function functx:wrap-values-in-elements ( $values as xs:anyAtomicType* , $elementName as xs:QName ) as element()* { for $value in $values return element {$elementName} {$value} } ;                     (functx:wrap-values-in-elements( (1,2,3), xs:QName('new:num')))
declare namespace functx = "http://www.example.com/";          declare namespace new = "http://newns";                     (:~ : Wraps a sequence of atomic values in XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_wrap-values-in-elements.html : @param $values the values to wrap in elements : @param $elementName the name of the elements to construct :)          declare function functx:wrap-values-in-elements ( $values as xs:anyAtomicType* , $elementName as xs:QName ) as element()* { for $value in $values return element {$elementName} {$value} } ;                     (functx:wrap-values-in-elements( (1,2,3), xs:QName('num')))
declare namespace functx = "http://www.example.com/";          declare namespace new = "http://newns";                     (:~ : Wraps a sequence of atomic values in XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_wrap-values-in-elements.html : @param $values the values to wrap in elements : @param $elementName the name of the elements to construct :)          declare function functx:wrap-values-in-elements ( $values as xs:anyAtomicType* , $elementName as xs:QName ) as element()* { for $value in $values return element {$elementName} {$value} } ;                     (functx:wrap-values-in-elements( (1,2,3), xs:QName('num')), functx:wrap-values-in-elements( (1,2,3), xs:QName('new:num')), functx:wrap-values-in-elements( (1,2,3), QName('http://newns','num')), functx:wrap-values-in-elements( (1,2,3), QName('http://newns','new:num')))
declare namespace functx = "http://www.example.com/";                     (:~ : Dynamically evaluates a simple XPath path : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_dynamic-path.html : @param $parent the root to start from : @param $path the path expression :)          declare function functx:dynamic-path ( $parent as node() , $path as xs:string ) as item()* { let $nextStep := functx:substring-before-if-contains($path,'/') let $restOfSteps := substring-after($path,'/') for $child in ($parent/*[functx:name-test(name(),$nextStep)], $parent/@*[functx:name-test(name(), substring-after($nextStep,'@'))]) return if ($restOfSteps) then functx:dynamic-path($child, $restOfSteps) else $child } ;                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     (:~ : Performs substring-before, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-before($arg,$delim) else $arg } ;                     let $in-xml := <authors> <author test="abc"> <first>Kate</first> <last>Jones</last> </author> <author> <first>John</first> <a:last xmlns:a="http://a">Doe</a:last> </author> </authors> return (functx:dynamic-path( $in-xml,'author'))
declare namespace functx = "http://www.example.com/";                     (:~ : Dynamically evaluates a simple XPath path : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_dynamic-path.html : @param $parent the root to start from : @param $path the path expression :)          declare function functx:dynamic-path ( $parent as node() , $path as xs:string ) as item()* { let $nextStep := functx:substring-before-if-contains($path,'/') let $restOfSteps := substring-after($path,'/') for $child in ($parent/*[functx:name-test(name(),$nextStep)], $parent/@*[functx:name-test(name(), substring-after($nextStep,'@'))]) return if ($restOfSteps) then functx:dynamic-path($child, $restOfSteps) else $child } ;                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     (:~ : Performs substring-before, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-before($arg,$delim) else $arg } ;                     let $in-xml := <authors> <author test="abc"> <first>Kate</first> <last>Jones</last> </author> <author> <first>John</first> <a:last xmlns:a="http://a">Doe</a:last> </author> </authors> return (functx:dynamic-path( $in-xml,'author/a:last'))
declare namespace functx = "http://www.example.com/";                     (:~ : Dynamically evaluates a simple XPath path : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_dynamic-path.html : @param $parent the root to start from : @param $path the path expression :)          declare function functx:dynamic-path ( $parent as node() , $path as xs:string ) as item()* { let $nextStep := functx:substring-before-if-contains($path,'/') let $restOfSteps := substring-after($path,'/') for $child in ($parent/*[functx:name-test(name(),$nextStep)], $parent/@*[functx:name-test(name(), substring-after($nextStep,'@'))]) return if ($restOfSteps) then functx:dynamic-path($child, $restOfSteps) else $child } ;                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     (:~ : Performs substring-before, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-before($arg,$delim) else $arg } ;                     let $in-xml := <authors> <author test="abc"> <first>Kate</first> <last>Jones</last> </author> <author> <first>John</first> <a:last xmlns:a="http://a">Doe</a:last> </author> </authors> return (functx:dynamic-path( $in-xml,'author/first'))
declare namespace functx = "http://www.example.com/";                     (:~ : Dynamically evaluates a simple XPath path : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_dynamic-path.html : @param $parent the root to start from : @param $path the path expression :)          declare function functx:dynamic-path ( $parent as node() , $path as xs:string ) as item()* { let $nextStep := functx:substring-before-if-contains($path,'/') let $restOfSteps := substring-after($path,'/') for $child in ($parent/*[functx:name-test(name(),$nextStep)], $parent/@*[functx:name-test(name(), substring-after($nextStep,'@'))]) return if ($restOfSteps) then functx:dynamic-path($child, $restOfSteps) else $child } ;                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     (:~ : Performs substring-before, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-before($arg,$delim) else $arg } ;                     let $in-xml := <authors> <author test="abc"> <first>Kate</first> <last>Jones</last> </author> <author> <first>John</first> <a:last xmlns:a="http://a">Doe</a:last> </author> </authors> return (name(functx:dynamic-path( $in-xml,'author/@test')))
declare namespace functx = "http://www.example.com/";                     (:~ : Gets XML element(s) that have an attribute with a particular value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_id-untyped.html : @param $node the root node(s) to start from : @param $id the "id" to find :)          declare function functx:id-untyped ( $node as node()* , $id as xs:anyAtomicType ) as element()* { $node//*[@* = $id] } ;                     let $in-xml := <in-xml> <a id="A001">abc</a> <b foo="A001">def</b> <c id="B001">ghi</c> </in-xml> return (functx:id-untyped($in-xml,'A001'))
declare namespace functx = "http://www.example.com/";                     (:~ : Gets XML element(s) that have an attribute with a particular value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_id-untyped.html : @param $node the root node(s) to start from : @param $id the "id" to find :)          declare function functx:id-untyped ( $node as node()* , $id as xs:anyAtomicType ) as element()* { $node//*[@* = $id] } ;                     let $in-xml := <in-xml> <a id="A001">abc</a> <b foo="A001">def</b> <c id="B001">ghi</c> </in-xml> return (functx:id-untyped($in-xml,'B001'))
declare namespace functx = "http://www.example.com/";                     (:~ : Gets XML element(s) that have an attribute with a particular value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_id-untyped.html : @param $node the root node(s) to start from : @param $id the "id" to find :)          declare function functx:id-untyped ( $node as node()* , $id as xs:anyAtomicType ) as element()* { $node//*[@* = $id] } ;                     let $in-xml := <in-xml> <a id="A001">abc</a> <b foo="A001">def</b> <c id="B001">ghi</c> </in-xml> return (functx:id-untyped($in-xml,'B001'), functx:id-untyped($in-xml,'A001'), functx:id-untyped($in-xml,'C001'))
declare namespace functx = "http://www.example.com/";                     (:~ : Gets XML element(s) that have an attribute with a particular value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_id-untyped.html : @param $node the root node(s) to start from : @param $id the "id" to find :)          declare function functx:id-untyped ( $node as node()* , $id as xs:anyAtomicType ) as element()* { $node//*[@* = $id] } ;                     let $in-xml := <in-xml> <a id="A001">abc</a> <b foo="A001">def</b> <c id="B001">ghi</c> </in-xml> return (functx:id-untyped($in-xml,'C001'))
declare namespace functx = "http://www.example.com/";                     (:~ : Inserts a string at a specified position : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_insert-string.html : @param $originalString the original string to insert into : @param $stringToInsert the string to insert : @param $pos the position :)          declare function functx:insert-string ( $originalString as xs:string? , $stringToInsert as xs:string? , $pos as xs:integer ) as xs:string { concat(substring($originalString,1,$pos - 1), $stringToInsert, substring($originalString,$pos)) } ;                     (functx:insert-string('','def',2))
declare namespace functx = "http://www.example.com/";                     (:~ : Inserts a string at a specified position : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_insert-string.html : @param $originalString the original string to insert into : @param $stringToInsert the string to insert : @param $pos the position :)          declare function functx:insert-string ( $originalString as xs:string? , $stringToInsert as xs:string? , $pos as xs:integer ) as xs:string { concat(substring($originalString,1,$pos - 1), $stringToInsert, substring($originalString,$pos)) } ;                     (functx:insert-string('xyz','',2))
declare namespace functx = "http://www.example.com/";                     (:~ : Inserts a string at a specified position : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_insert-string.html : @param $originalString the original string to insert into : @param $stringToInsert the string to insert : @param $pos the position :)          declare function functx:insert-string ( $originalString as xs:string? , $stringToInsert as xs:string? , $pos as xs:integer ) as xs:string { concat(substring($originalString,1,$pos - 1), $stringToInsert, substring($originalString,$pos)) } ;                     (functx:insert-string('xyz','def',2))
declare namespace functx = "http://www.example.com/";                     (:~ : Inserts a string at a specified position : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_insert-string.html : @param $originalString the original string to insert into : @param $stringToInsert the string to insert : @param $pos the position :)          declare function functx:insert-string ( $originalString as xs:string? , $stringToInsert as xs:string? , $pos as xs:integer ) as xs:string { concat(substring($originalString,1,$pos - 1), $stringToInsert, substring($originalString,$pos)) } ;                     (functx:insert-string('xyz','def',2), functx:insert-string('xyz','def',5), functx:insert-string('xyz','',2), functx:insert-string('','def',2))
declare namespace functx = "http://www.example.com/";                     (:~ : Inserts a string at a specified position : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_insert-string.html : @param $originalString the original string to insert into : @param $stringToInsert the string to insert : @param $pos the position :)          declare function functx:insert-string ( $originalString as xs:string? , $stringToInsert as xs:string? , $pos as xs:integer ) as xs:string { concat(substring($originalString,1,$pos - 1), $stringToInsert, substring($originalString,$pos)) } ;                     (functx:insert-string('xyz','def',5))
declare namespace functx = "http://www.example.com/";                     (:~ : Number of days in the month : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_days-in-month.html : @param $date the date :)          declare function functx:days-in-month ( $date as xs:anyAtomicType? ) as xs:integer? { if (month-from-date(xs:date($date)) = 2 and functx:is-leap-year($date)) then 29 else (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31) [month-from-date(xs:date($date))] } ;                     (:~ : Whether a date falls in a leap year : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-leap-year.html : @param $date the date or year :)          declare function functx:is-leap-year ( $date as xs:anyAtomicType? ) as xs:boolean { for $year in xs:integer(substring(string($date),1,4)) return ($year mod 4 = 0 and $year mod 100 != 0) or $year mod 400 = 0 } ;                     (functx:days-in-month('2005-02-15'))
declare namespace functx = "http://www.example.com/";                     (:~ : Number of days in the month : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_days-in-month.html : @param $date the date :)          declare function functx:days-in-month ( $date as xs:anyAtomicType? ) as xs:integer? { if (month-from-date(xs:date($date)) = 2 and functx:is-leap-year($date)) then 29 else (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31) [month-from-date(xs:date($date))] } ;                     (:~ : Whether a date falls in a leap year : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-leap-year.html : @param $date the date or year :)          declare function functx:is-leap-year ( $date as xs:anyAtomicType? ) as xs:boolean { for $year in xs:integer(substring(string($date),1,4)) return ($year mod 4 = 0 and $year mod 100 != 0) or $year mod 400 = 0 } ;                     (functx:days-in-month(xs:date('2004-01-23')))
declare namespace functx = "http://www.example.com/";                     (:~ : Number of days in the month : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_days-in-month.html : @param $date the date :)          declare function functx:days-in-month ( $date as xs:anyAtomicType? ) as xs:integer? { if (month-from-date(xs:date($date)) = 2 and functx:is-leap-year($date)) then 29 else (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31) [month-from-date(xs:date($date))] } ;                     (:~ : Whether a date falls in a leap year : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-leap-year.html : @param $date the date or year :)          declare function functx:is-leap-year ( $date as xs:anyAtomicType? ) as xs:boolean { for $year in xs:integer(substring(string($date),1,4)) return ($year mod 4 = 0 and $year mod 100 != 0) or $year mod 400 = 0 } ;                     (functx:days-in-month(xs:date('2004-01-23')), functx:days-in-month( xs:dateTime('2004-02-15T12:00:13')), functx:days-in-month('2005-02-15'))
declare namespace functx = "http://www.example.com/";                     (:~ : Number of days in the month : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_days-in-month.html : @param $date the date :)          declare function functx:days-in-month ( $date as xs:anyAtomicType? ) as xs:integer? { if (month-from-date(xs:date($date)) = 2 and functx:is-leap-year($date)) then 29 else (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31) [month-from-date(xs:date($date))] } ;                     (:~ : Whether a date falls in a leap year : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-leap-year.html : @param $date the date or year :)          declare function functx:is-leap-year ( $date as xs:anyAtomicType? ) as xs:boolean { for $year in xs:integer(substring(string($date),1,4)) return ($year mod 4 = 0 and $year mod 100 != 0) or $year mod 400 = 0 } ;                     (functx:days-in-month( xs:dateTime('2004-02-15T12:00:13')))
declare namespace functx = "http://www.example.com/";                     (:~ : Pads a string to a desired length : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-string-to-length.html : @param $stringToPad the string to pad : @param $padChar the character(s) to use as padding : @param $length the desired length :)          declare function functx:pad-string-to-length ( $stringToPad as xs:string? , $padChar as xs:string , $length as xs:integer ) as xs:string { substring( string-join ( ($stringToPad, for $i in (1 to $length) return $padChar) ,'') ,1,$length) } ;                     (functx:pad-string-to-length('', '*', 4))
declare namespace functx = "http://www.example.com/";                     (:~ : Pads a string to a desired length : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-string-to-length.html : @param $stringToPad the string to pad : @param $padChar the character(s) to use as padding : @param $length the desired length :)          declare function functx:pad-string-to-length ( $stringToPad as xs:string? , $padChar as xs:string , $length as xs:integer ) as xs:string { substring( string-join ( ($stringToPad, for $i in (1 to $length) return $padChar) ,'') ,1,$length) } ;                     (functx:pad-string-to-length('abc', '*', 6))
declare namespace functx = "http://www.example.com/";                     (:~ : Pads a string to a desired length : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-string-to-length.html : @param $stringToPad the string to pad : @param $padChar the character(s) to use as padding : @param $length the desired length :)          declare function functx:pad-string-to-length ( $stringToPad as xs:string? , $padChar as xs:string , $length as xs:integer ) as xs:string { substring( string-join ( ($stringToPad, for $i in (1 to $length) return $padChar) ,'') ,1,$length) } ;                     (functx:pad-string-to-length('abc', '*', 6), functx:pad-string-to-length('abcdef', '*', 4), functx:pad-string-to-length('', '*', 4))
declare namespace functx = "http://www.example.com/";                     (:~ : Pads a string to a desired length : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-string-to-length.html : @param $stringToPad the string to pad : @param $padChar the character(s) to use as padding : @param $length the desired length :)          declare function functx:pad-string-to-length ( $stringToPad as xs:string? , $padChar as xs:string , $length as xs:integer ) as xs:string { substring( string-join ( ($stringToPad, for $i in (1 to $length) return $padChar) ,'') ,1,$length) } ;                     (functx:pad-string-to-length('abcdef', '*', 4))
declare namespace functx = "http://www.example.com/";                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     (functx:substring-after-if-contains('abcd','b'))
declare namespace functx = "http://www.example.com/";                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     (functx:substring-after-if-contains('abcd','b'), functx:substring-after-if-contains('abcd','x'))
declare namespace functx = "http://www.example.com/";                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     (functx:substring-after-if-contains('abcd','x'))
declare namespace functx = "http://www.example.com/";                     (:~ : Performs substring-before, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-before($arg,$delim) else $arg } ;                     (functx:substring-before-if-contains('abcd','c'))
declare namespace functx = "http://www.example.com/";                     (:~ : Performs substring-before, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-before($arg,$delim) else $arg } ;                     (functx:substring-before-if-contains('abcd','c'), functx:substring-before-if-contains('abcd','x'))
declare namespace functx = "http://www.example.com/";                     (:~ : Performs substring-before, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-before($arg,$delim) else $arg } ;                     (functx:substring-before-if-contains('abcd','x'))
declare namespace functx = "http://www.example.com/";                     (:~ : Reformats a number as an ordinal number, e.g. 1st, 2nd, 3rd. : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_ordinal-number-en.html : @param $num the number :)          declare function functx:ordinal-number-en ( $num as xs:integer? ) as xs:string { concat(xs:string($num), if (matches(xs:string($num),'[04-9]$|1[1-3]$')) then 'th' else if (ends-with(xs:string($num),'1')) then 'st' else if (ends-with(xs:string($num),'2')) then 'nd' else if (ends-with(xs:string($num),'3')) then 'rd' else '') } ;                     (functx:ordinal-number-en(1))
declare namespace functx = "http://www.example.com/";                     (:~ : Reformats a number as an ordinal number, e.g. 1st, 2nd, 3rd. : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_ordinal-number-en.html : @param $num the number :)          declare function functx:ordinal-number-en ( $num as xs:integer? ) as xs:string { concat(xs:string($num), if (matches(xs:string($num),'[04-9]$|1[1-3]$')) then 'th' else if (ends-with(xs:string($num),'1')) then 'st' else if (ends-with(xs:string($num),'2')) then 'nd' else if (ends-with(xs:string($num),'3')) then 'rd' else '') } ;                     (functx:ordinal-number-en(12))
declare namespace functx = "http://www.example.com/";                     (:~ : Reformats a number as an ordinal number, e.g. 1st, 2nd, 3rd. : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_ordinal-number-en.html : @param $num the number :)          declare function functx:ordinal-number-en ( $num as xs:integer? ) as xs:string { concat(xs:string($num), if (matches(xs:string($num),'[04-9]$|1[1-3]$')) then 'th' else if (ends-with(xs:string($num),'1')) then 'st' else if (ends-with(xs:string($num),'2')) then 'nd' else if (ends-with(xs:string($num),'3')) then 'rd' else '') } ;                     (functx:ordinal-number-en(1), functx:ordinal-number-en(12))
declare namespace functx = "http://www.example.com/";                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:repeat-string('*', 6))
declare namespace functx = "http://www.example.com/";                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:repeat-string('*', 6), functx:repeat-string('abc', 3))
declare namespace functx = "http://www.example.com/";                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:repeat-string('abc', 3))
declare namespace functx = "http://www.example.com/";                     (:~ : Returns the fragment from a URI : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_fragment-from-uri.html : @param $uri the URI :)          declare function functx:fragment-from-uri ( $uri as xs:string? ) as xs:string? { substring-after($uri,'#') } ;                     (functx:fragment-from-uri( 'http://datypic.com/index.htm'))
declare namespace functx = "http://www.example.com/";                     (:~ : Returns the fragment from a URI : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_fragment-from-uri.html : @param $uri the URI :)          declare function functx:fragment-from-uri ( $uri as xs:string? ) as xs:string? { substring-after($uri,'#') } ;                     (functx:fragment-from-uri( 'http://datypic.com/index.htm#abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : Returns the fragment from a URI : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_fragment-from-uri.html : @param $uri the URI :)          declare function functx:fragment-from-uri ( $uri as xs:string? ) as xs:string? { substring-after($uri,'#') } ;                     (functx:fragment-from-uri( 'http://datypic.com/index.htm#abc'), functx:fragment-from-uri( 'http://datypic.com/index.htm'))
declare namespace functx = "http://www.example.com/";                     (:~ : Returns the scheme from a URI : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_scheme-from-uri.html : @param $uri the URI :)          declare function functx:scheme-from-uri ( $uri as xs:string? ) as xs:string? { substring-before($uri,':') } ;                     (functx:scheme-from-uri('ftp.datypic.com'))
declare namespace functx = "http://www.example.com/";                     (:~ : Returns the scheme from a URI : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_scheme-from-uri.html : @param $uri the URI :)          declare function functx:scheme-from-uri ( $uri as xs:string? ) as xs:string? { substring-before($uri,':') } ;                     (functx:scheme-from-uri( 'ftp://ftp.datypic.com'))
declare namespace functx = "http://www.example.com/";                     (:~ : Returns the scheme from a URI : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_scheme-from-uri.html : @param $uri the URI :)          declare function functx:scheme-from-uri ( $uri as xs:string? ) as xs:string? { substring-before($uri,':') } ;                     (functx:scheme-from-uri( 'http://www.datypic.com'))
declare namespace functx = "http://www.example.com/";                     (:~ : Returns the scheme from a URI : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_scheme-from-uri.html : @param $uri the URI :)          declare function functx:scheme-from-uri ( $uri as xs:string? ) as xs:string? { substring-before($uri,':') } ;                     (functx:scheme-from-uri( 'http://www.datypic.com'), functx:scheme-from-uri( 'ftp://ftp.datypic.com'), functx:scheme-from-uri('ftp.datypic.com'), functx:scheme-from-uri('www.datypic.com'), functx:scheme-from-uri('prod.html'))
declare namespace functx = "http://www.example.com/";                     (:~ : Returns the scheme from a URI : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_scheme-from-uri.html : @param $uri the URI :)          declare function functx:scheme-from-uri ( $uri as xs:string? ) as xs:string? { substring-before($uri,':') } ;                     (functx:scheme-from-uri('prod.html'))
declare namespace functx = "http://www.example.com/";                     (:~ : Returns the scheme from a URI : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_scheme-from-uri.html : @param $uri the URI :)          declare function functx:scheme-from-uri ( $uri as xs:string? ) as xs:string? { substring-before($uri,':') } ;                     (functx:scheme-from-uri('www.datypic.com'))
declare namespace functx = "http://www.example.com/";                     (:~ : Reverses the order of characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_reverse-string.html : @param $arg the string to reverse :)          declare function functx:reverse-string ( $arg as xs:string? ) as xs:string { codepoints-to-string(reverse(string-to-codepoints($arg))) } ;                     (functx:reverse-string('a'))
declare namespace functx = "http://www.example.com/";                     (:~ : Reverses the order of characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_reverse-string.html : @param $arg the string to reverse :)          declare function functx:reverse-string ( $arg as xs:string? ) as xs:string { codepoints-to-string(reverse(string-to-codepoints($arg))) } ;                     (functx:reverse-string('abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : Reverses the order of characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_reverse-string.html : @param $arg the string to reverse :)          declare function functx:reverse-string ( $arg as xs:string? ) as xs:string { codepoints-to-string(reverse(string-to-codepoints($arg))) } ;                     (functx:reverse-string('abc'), functx:reverse-string('a'))
declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of nodes in document order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort-document-order.html : @param $seq the sequence to sort :)          declare function functx:sort-document-order ( $seq as node()* ) as node()* { $seq/. } ;                     let $in-xml := <in-xml> <a>123</a> <b>456</b> <c>789</c> </in-xml> return (functx:sort-document-order( ($in-xml/c,$in-xml/a)))
declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of numeric values or nodes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort-as-numeric.html : @param $seq the sequence to sort :)          declare function functx:sort-as-numeric ( $seq as item()* ) as item()* { for $item in $seq order by number($item) return $item } ;                     let $in-xml := <in-xml> <f>1</f> <f>35</f> <e>4</e> </in-xml> return (functx:sort-as-numeric($in-xml/*))
declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of numeric values or nodes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort-as-numeric.html : @param $seq the sequence to sort :)          declare function functx:sort-as-numeric ( $seq as item()* ) as item()* { for $item in $seq order by number($item) return $item } ;                     let $in-xml := <in-xml> <f>1</f> <f>35</f> <e>4</e> </in-xml> return (functx:sort-as-numeric(('1','100','99')))
declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of values or nodes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort.html : @param $seq the sequence to sort :)          declare function functx:sort ( $seq as item()* ) as item()* { for $item in $seq order by $item return $item } ;                     let $in-xml := <in-xml> <f>c</f> <f>a</f> <e>b</e> </in-xml> return (functx:sort($in-xml/*))
declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of values or nodes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort.html : @param $seq the sequence to sort :)          declare function functx:sort ( $seq as item()* ) as item()* { for $item in $seq order by $item return $item } ;                     let $in-xml := <in-xml> <f>c</f> <f>a</f> <e>b</e> </in-xml> return (functx:sort(('c','a','b')))
declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of values or nodes regardless of capitalization : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort-case-insensitive.html : @param $seq the sequence to sort :)          declare function functx:sort-case-insensitive ( $seq as item()* ) as item()* { for $item in $seq order by upper-case(string($item)) return $item } ;                     let $in-xml := <in-xml> <f>a</f> <f>c</f> <e>B</e> </in-xml> return (functx:sort-case-insensitive($in-xml/*))
declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of values or nodes regardless of capitalization : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort-case-insensitive.html : @param $seq the sequence to sort :)          declare function functx:sort-case-insensitive ( $seq as item()* ) as item()* { for $item in $seq order by upper-case(string($item)) return $item } ;                     let $in-xml := <in-xml> <f>a</f> <f>c</f> <e>B</e> </in-xml> return (functx:sort-case-insensitive(('a','c','B')))
declare namespace functx = "http://www.example.com/";                     (:~ : Split a string into separate lines : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_lines.html : @param $arg the string to split :)          declare function functx:lines ( $arg as xs:string? ) as xs:string* { tokenize($arg, '(\r\n?|\n\r?)') } ;                     let $in-xml := <in-xml>a value on many lines</in-xml> return (functx:lines($in-xml))
declare namespace functx = "http://www.example.com/";                     (:~ : Split a string into separate lines : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_lines.html : @param $arg the string to split :)          declare function functx:lines ( $arg as xs:string? ) as xs:string* { tokenize($arg, '(\r\n?|\n\r?)') } ;                     let $in-xml := <in-xml>a value on many lines</in-xml> return (functx:lines('a value'))
declare namespace functx = "http://www.example.com/";                     (:~ : Split a string into separate lines : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_lines.html : @param $arg the string to split :)          declare function functx:lines ( $arg as xs:string? ) as xs:string* { tokenize($arg, '(\r\n?|\n\r?)') } ;                     let $in-xml := <in-xml>a value on many lines</in-xml> return (functx:lines('a value'), functx:lines($in-xml))
declare namespace functx = "http://www.example.com/";                     (:~ : Split a string into separate lines : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_lines.html : @param $arg the string to split :)          declare function functx:lines ( $arg as xs:string? ) as xs:string* { tokenize($arg, '(\r\n?|\n\r?)') } ;                     (:~ : The maximum line length : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-line-length.html : @param $arg the string to test :)          declare function functx:max-line-length ( $arg as xs:string? ) as xs:integer? { max( for $line in functx:lines($arg) return string-length($line)) } ;  let $lines := 'a       value       on       several      lines'           return (functx:max-line-length($lines))
declare namespace functx = "http://www.example.com/";                     (:~ : Split a string into separate lines : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_lines.html : @param $arg the string to split :)          declare function functx:lines ( $arg as xs:string? ) as xs:string* { tokenize($arg, '(\r\n?|\n\r?)') } ;                     (:~ : The maximum line length : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-line-length.html : @param $arg the string to test :)          declare function functx:max-line-length ( $arg as xs:string? ) as xs:integer? { max( for $line in functx:lines($arg) return string-length($line)) } ;                     let $lines := 'a value on several lines' return (functx:max-line-length('a value'))
declare namespace functx = "http://www.example.com/";                     (:~ : Split a string into separate lines : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_lines.html : @param $arg the string to split :)          declare function functx:lines ( $arg as xs:string? ) as xs:string* { tokenize($arg, '(\r\n?|\n\r?)') } ;                     (:~ : The maximum line length : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-line-length.html : @param $arg the string to test :)          declare function functx:max-line-length ( $arg as xs:string? ) as xs:integer? { max( for $line in functx:lines($arg) return string-length($line)) } ; let $lines := 'a       value       on       several      lines'           return (functx:max-line-length('a value'), functx:max-line-length($lines))
declare namespace functx = "http://www.example.com/";                     (:~ : The abbreviated day of the week, from a date, in English : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week-abbrev-en.html : @param $date the date :)          declare function functx:day-of-week-abbrev-en ( $date as xs:anyAtomicType? ) as xs:string? { ('Sun', 'Mon', 'Tues', 'Wed', 'Thurs', 'Fri', 'Sat') [functx:day-of-week($date) + 1] } ;                     (:~ : The day of the week, from a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week.html : @param $date the date :)          declare function functx:day-of-week ( $date as xs:anyAtomicType? ) as xs:integer? { if (empty($date)) then () else xs:integer((xs:date($date) - xs:date('1901-01-06')) div xs:dayTimeDuration('P1D')) mod 7 } ;                     (functx:day-of-week-abbrev-en('2004-11-04'))
declare namespace functx = "http://www.example.com/";                     (:~ : The abbreviated day of the week, from a date, in English : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week-abbrev-en.html : @param $date the date :)          declare function functx:day-of-week-abbrev-en ( $date as xs:anyAtomicType? ) as xs:string? { ('Sun', 'Mon', 'Tues', 'Wed', 'Thurs', 'Fri', 'Sat') [functx:day-of-week($date) + 1] } ;                     (:~ : The day of the week, from a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week.html : @param $date the date :)          declare function functx:day-of-week ( $date as xs:anyAtomicType? ) as xs:integer? { if (empty($date)) then () else xs:integer((xs:date($date) - xs:date('1901-01-06')) div xs:dayTimeDuration('P1D')) mod 7 } ;                     (functx:day-of-week-abbrev-en( xs:date('2004-11-04')))
declare namespace functx = "http://www.example.com/";                     (:~ : The abbreviated day of the week, from a date, in English : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week-abbrev-en.html : @param $date the date :)          declare function functx:day-of-week-abbrev-en ( $date as xs:anyAtomicType? ) as xs:string? { ('Sun', 'Mon', 'Tues', 'Wed', 'Thurs', 'Fri', 'Sat') [functx:day-of-week($date) + 1] } ;                     (:~ : The day of the week, from a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week.html : @param $date the date :)          declare function functx:day-of-week ( $date as xs:anyAtomicType? ) as xs:integer? { if (empty($date)) then () else xs:integer((xs:date($date) - xs:date('1901-01-06')) div xs:dayTimeDuration('P1D')) mod 7 } ;                     (functx:day-of-week-abbrev-en( xs:date('2004-11-04')), functx:day-of-week-abbrev-en('2004-11-04'))
declare namespace functx = "http://www.example.com/";                     (:~ : The average, counting "empty" values as zero : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_avg-empty-is-zero.html : @param $values the values to be averaged : @param $allNodes the sequence of all nodes to find the average over :)          declare function functx:avg-empty-is-zero ( $values as xs:anyAtomicType* , $allNodes as node()* ) as xs:double { if (empty($allNodes)) then 0 else sum($values[string(.) != '']) div count($allNodes) } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="69.99"/> <price value="49.99" discount=""/> </prices> return (functx:avg-empty-is-zero( $in-xml//price/@discount, $in-xml//price))
declare namespace functx = "http://www.example.com/";                     (:~ : The built-in type of an atomic value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_atomic-type.html : @param $values the value(s) whose type you want to determine :)          declare function functx:atomic-type ( $values as xs:anyAtomicType* ) as xs:string* { for $val in $values return (if ($val instance of xs:untypedAtomic) then 'xs:untypedAtomic' else if ($val instance of xs:anyURI) then 'xs:anyURI' else if ($val instance of xs:ENTITY) then 'xs:ENTITY' else if ($val instance of xs:ID) then 'xs:ID' else if ($val instance of xs:NMTOKEN) then 'xs:NMTOKEN' else if ($val instance of xs:language) then 'xs:language' else if ($val instance of xs:NCName) then 'xs:NCName' else if ($val instance of xs:Name) then 'xs:Name' else if ($val instance of xs:token) then 'xs:token' else if ($val instance of xs:normalizedString) then 'xs:normalizedString' else if ($val instance of xs:string) then 'xs:string' else if ($val instance of xs:QName) then 'xs:QName' else if ($val instance of xs:boolean) then 'xs:boolean' else if ($val instance of xs:base64Binary) then 'xs:base64Binary' else if ($val instance of xs:hexBinary) then 'xs:hexBinary' else if ($val instance of xs:byte) then 'xs:byte' else if ($val instance of xs:short) then 'xs:short' else if ($val instance of xs:int) then 'xs:int' else if ($val instance of xs:long) then 'xs:long' else if ($val instance of xs:unsignedByte) then 'xs:unsignedByte' else if ($val instance of xs:unsignedShort) then 'xs:unsignedShort' else if ($val instance of xs:unsignedInt) then 'xs:unsignedInt' else if ($val instance of xs:unsignedLong) then 'xs:unsignedLong' else if ($val instance of xs:positiveInteger) then 'xs:positiveInteger' else if ($val instance of xs:nonNegativeInteger) then 'xs:nonNegativeInteger' else if ($val instance of xs:negativeInteger) then 'xs:negativeInteger' else if ($val instance of xs:nonPositiveInteger) then 'xs:nonPositiveInteger' else if ($val instance of xs:integer) then 'xs:integer' else if ($val instance of xs:decimal) then 'xs:decimal' else if ($val instance of xs:float) then 'xs:float' else if ($val instance of xs:double) then 'xs:double' else if ($val instance of xs:date) then 'xs:date' else if ($val instance of xs:time) then 'xs:time' else if ($val instance of xs:dateTime) then 'xs:dateTime' else if ($val instance of xs:dayTimeDuration) then 'xs:dayTimeDuration' else if ($val instance of xs:yearMonthDuration) then 'xs:yearMonthDuration' else if ($val instance of xs:duration) then 'xs:duration' else if ($val instance of xs:gMonth) then 'xs:gMonth' else if ($val instance of xs:gYear) then 'xs:gYear' else if ($val instance of xs:gYearMonth) then 'xs:gYearMonth' else if ($val instance of xs:gDay) then 'xs:gDay' else if ($val instance of xs:gMonthDay) then 'xs:gMonthDay' else 'unknown') } ;                     (functx:atomic-type(2))
declare namespace functx = "http://www.example.com/";                     (:~ : The built-in type of an atomic value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_atomic-type.html : @param $values the value(s) whose type you want to determine :)          declare function functx:atomic-type ( $values as xs:anyAtomicType* ) as xs:string* { for $val in $values return (if ($val instance of xs:untypedAtomic) then 'xs:untypedAtomic' else if ($val instance of xs:anyURI) then 'xs:anyURI' else if ($val instance of xs:ENTITY) then 'xs:ENTITY' else if ($val instance of xs:ID) then 'xs:ID' else if ($val instance of xs:NMTOKEN) then 'xs:NMTOKEN' else if ($val instance of xs:language) then 'xs:language' else if ($val instance of xs:NCName) then 'xs:NCName' else if ($val instance of xs:Name) then 'xs:Name' else if ($val instance of xs:token) then 'xs:token' else if ($val instance of xs:normalizedString) then 'xs:normalizedString' else if ($val instance of xs:string) then 'xs:string' else if ($val instance of xs:QName) then 'xs:QName' else if ($val instance of xs:boolean) then 'xs:boolean' else if ($val instance of xs:base64Binary) then 'xs:base64Binary' else if ($val instance of xs:hexBinary) then 'xs:hexBinary' else if ($val instance of xs:byte) then 'xs:byte' else if ($val instance of xs:short) then 'xs:short' else if ($val instance of xs:int) then 'xs:int' else if ($val instance of xs:long) then 'xs:long' else if ($val instance of xs:unsignedByte) then 'xs:unsignedByte' else if ($val instance of xs:unsignedShort) then 'xs:unsignedShort' else if ($val instance of xs:unsignedInt) then 'xs:unsignedInt' else if ($val instance of xs:unsignedLong) then 'xs:unsignedLong' else if ($val instance of xs:positiveInteger) then 'xs:positiveInteger' else if ($val instance of xs:nonNegativeInteger) then 'xs:nonNegativeInteger' else if ($val instance of xs:negativeInteger) then 'xs:negativeInteger' else if ($val instance of xs:nonPositiveInteger) then 'xs:nonPositiveInteger' else if ($val instance of xs:integer) then 'xs:integer' else if ($val instance of xs:decimal) then 'xs:decimal' else if ($val instance of xs:float) then 'xs:float' else if ($val instance of xs:double) then 'xs:double' else if ($val instance of xs:date) then 'xs:date' else if ($val instance of xs:time) then 'xs:time' else if ($val instance of xs:dateTime) then 'xs:dateTime' else if ($val instance of xs:dayTimeDuration) then 'xs:dayTimeDuration' else if ($val instance of xs:yearMonthDuration) then 'xs:yearMonthDuration' else if ($val instance of xs:duration) then 'xs:duration' else if ($val instance of xs:gMonth) then 'xs:gMonth' else if ($val instance of xs:gYear) then 'xs:gYear' else if ($val instance of xs:gYearMonth) then 'xs:gYearMonth' else if ($val instance of xs:gDay) then 'xs:gDay' else if ($val instance of xs:gMonthDay) then 'xs:gMonthDay' else 'unknown') } ;                     (functx:atomic-type( (2,'abc',xs:date('2005-12-15'))))
declare namespace functx = "http://www.example.com/";                     (:~ : The built-in type of an atomic value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_atomic-type.html : @param $values the value(s) whose type you want to determine :)          declare function functx:atomic-type ( $values as xs:anyAtomicType* ) as xs:string* { for $val in $values return (if ($val instance of xs:untypedAtomic) then 'xs:untypedAtomic' else if ($val instance of xs:anyURI) then 'xs:anyURI' else if ($val instance of xs:ENTITY) then 'xs:ENTITY' else if ($val instance of xs:ID) then 'xs:ID' else if ($val instance of xs:NMTOKEN) then 'xs:NMTOKEN' else if ($val instance of xs:language) then 'xs:language' else if ($val instance of xs:NCName) then 'xs:NCName' else if ($val instance of xs:Name) then 'xs:Name' else if ($val instance of xs:token) then 'xs:token' else if ($val instance of xs:normalizedString) then 'xs:normalizedString' else if ($val instance of xs:string) then 'xs:string' else if ($val instance of xs:QName) then 'xs:QName' else if ($val instance of xs:boolean) then 'xs:boolean' else if ($val instance of xs:base64Binary) then 'xs:base64Binary' else if ($val instance of xs:hexBinary) then 'xs:hexBinary' else if ($val instance of xs:byte) then 'xs:byte' else if ($val instance of xs:short) then 'xs:short' else if ($val instance of xs:int) then 'xs:int' else if ($val instance of xs:long) then 'xs:long' else if ($val instance of xs:unsignedByte) then 'xs:unsignedByte' else if ($val instance of xs:unsignedShort) then 'xs:unsignedShort' else if ($val instance of xs:unsignedInt) then 'xs:unsignedInt' else if ($val instance of xs:unsignedLong) then 'xs:unsignedLong' else if ($val instance of xs:positiveInteger) then 'xs:positiveInteger' else if ($val instance of xs:nonNegativeInteger) then 'xs:nonNegativeInteger' else if ($val instance of xs:negativeInteger) then 'xs:negativeInteger' else if ($val instance of xs:nonPositiveInteger) then 'xs:nonPositiveInteger' else if ($val instance of xs:integer) then 'xs:integer' else if ($val instance of xs:decimal) then 'xs:decimal' else if ($val instance of xs:float) then 'xs:float' else if ($val instance of xs:double) then 'xs:double' else if ($val instance of xs:date) then 'xs:date' else if ($val instance of xs:time) then 'xs:time' else if ($val instance of xs:dateTime) then 'xs:dateTime' else if ($val instance of xs:dayTimeDuration) then 'xs:dayTimeDuration' else if ($val instance of xs:yearMonthDuration) then 'xs:yearMonthDuration' else if ($val instance of xs:duration) then 'xs:duration' else if ($val instance of xs:gMonth) then 'xs:gMonth' else if ($val instance of xs:gYear) then 'xs:gYear' else if ($val instance of xs:gYearMonth) then 'xs:gYearMonth' else if ($val instance of xs:gDay) then 'xs:gDay' else if ($val instance of xs:gMonthDay) then 'xs:gMonthDay' else 'unknown') } ;                     (functx:atomic-type(2), functx:atomic-type('abc'), functx:atomic-type(xs:date('2005-12-15')), functx:atomic-type( (2,'abc',xs:date('2005-12-15'))))
declare namespace functx = "http://www.example.com/";                     (:~ : The built-in type of an atomic value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_atomic-type.html : @param $values the value(s) whose type you want to determine :)          declare function functx:atomic-type ( $values as xs:anyAtomicType* ) as xs:string* { for $val in $values return (if ($val instance of xs:untypedAtomic) then 'xs:untypedAtomic' else if ($val instance of xs:anyURI) then 'xs:anyURI' else if ($val instance of xs:ENTITY) then 'xs:ENTITY' else if ($val instance of xs:ID) then 'xs:ID' else if ($val instance of xs:NMTOKEN) then 'xs:NMTOKEN' else if ($val instance of xs:language) then 'xs:language' else if ($val instance of xs:NCName) then 'xs:NCName' else if ($val instance of xs:Name) then 'xs:Name' else if ($val instance of xs:token) then 'xs:token' else if ($val instance of xs:normalizedString) then 'xs:normalizedString' else if ($val instance of xs:string) then 'xs:string' else if ($val instance of xs:QName) then 'xs:QName' else if ($val instance of xs:boolean) then 'xs:boolean' else if ($val instance of xs:base64Binary) then 'xs:base64Binary' else if ($val instance of xs:hexBinary) then 'xs:hexBinary' else if ($val instance of xs:byte) then 'xs:byte' else if ($val instance of xs:short) then 'xs:short' else if ($val instance of xs:int) then 'xs:int' else if ($val instance of xs:long) then 'xs:long' else if ($val instance of xs:unsignedByte) then 'xs:unsignedByte' else if ($val instance of xs:unsignedShort) then 'xs:unsignedShort' else if ($val instance of xs:unsignedInt) then 'xs:unsignedInt' else if ($val instance of xs:unsignedLong) then 'xs:unsignedLong' else if ($val instance of xs:positiveInteger) then 'xs:positiveInteger' else if ($val instance of xs:nonNegativeInteger) then 'xs:nonNegativeInteger' else if ($val instance of xs:negativeInteger) then 'xs:negativeInteger' else if ($val instance of xs:nonPositiveInteger) then 'xs:nonPositiveInteger' else if ($val instance of xs:integer) then 'xs:integer' else if ($val instance of xs:decimal) then 'xs:decimal' else if ($val instance of xs:float) then 'xs:float' else if ($val instance of xs:double) then 'xs:double' else if ($val instance of xs:date) then 'xs:date' else if ($val instance of xs:time) then 'xs:time' else if ($val instance of xs:dateTime) then 'xs:dateTime' else if ($val instance of xs:dayTimeDuration) then 'xs:dayTimeDuration' else if ($val instance of xs:yearMonthDuration) then 'xs:yearMonthDuration' else if ($val instance of xs:duration) then 'xs:duration' else if ($val instance of xs:gMonth) then 'xs:gMonth' else if ($val instance of xs:gYear) then 'xs:gYear' else if ($val instance of xs:gYearMonth) then 'xs:gYearMonth' else if ($val instance of xs:gDay) then 'xs:gDay' else if ($val instance of xs:gMonthDay) then 'xs:gMonthDay' else 'unknown') } ;                     (functx:atomic-type('abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : The built-in type of an atomic value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_atomic-type.html : @param $values the value(s) whose type you want to determine :)          declare function functx:atomic-type ( $values as xs:anyAtomicType* ) as xs:string* { for $val in $values return (if ($val instance of xs:untypedAtomic) then 'xs:untypedAtomic' else if ($val instance of xs:anyURI) then 'xs:anyURI' else if ($val instance of xs:ENTITY) then 'xs:ENTITY' else if ($val instance of xs:ID) then 'xs:ID' else if ($val instance of xs:NMTOKEN) then 'xs:NMTOKEN' else if ($val instance of xs:language) then 'xs:language' else if ($val instance of xs:NCName) then 'xs:NCName' else if ($val instance of xs:Name) then 'xs:Name' else if ($val instance of xs:token) then 'xs:token' else if ($val instance of xs:normalizedString) then 'xs:normalizedString' else if ($val instance of xs:string) then 'xs:string' else if ($val instance of xs:QName) then 'xs:QName' else if ($val instance of xs:boolean) then 'xs:boolean' else if ($val instance of xs:base64Binary) then 'xs:base64Binary' else if ($val instance of xs:hexBinary) then 'xs:hexBinary' else if ($val instance of xs:byte) then 'xs:byte' else if ($val instance of xs:short) then 'xs:short' else if ($val instance of xs:int) then 'xs:int' else if ($val instance of xs:long) then 'xs:long' else if ($val instance of xs:unsignedByte) then 'xs:unsignedByte' else if ($val instance of xs:unsignedShort) then 'xs:unsignedShort' else if ($val instance of xs:unsignedInt) then 'xs:unsignedInt' else if ($val instance of xs:unsignedLong) then 'xs:unsignedLong' else if ($val instance of xs:positiveInteger) then 'xs:positiveInteger' else if ($val instance of xs:nonNegativeInteger) then 'xs:nonNegativeInteger' else if ($val instance of xs:negativeInteger) then 'xs:negativeInteger' else if ($val instance of xs:nonPositiveInteger) then 'xs:nonPositiveInteger' else if ($val instance of xs:integer) then 'xs:integer' else if ($val instance of xs:decimal) then 'xs:decimal' else if ($val instance of xs:float) then 'xs:float' else if ($val instance of xs:double) then 'xs:double' else if ($val instance of xs:date) then 'xs:date' else if ($val instance of xs:time) then 'xs:time' else if ($val instance of xs:dateTime) then 'xs:dateTime' else if ($val instance of xs:dayTimeDuration) then 'xs:dayTimeDuration' else if ($val instance of xs:yearMonthDuration) then 'xs:yearMonthDuration' else if ($val instance of xs:duration) then 'xs:duration' else if ($val instance of xs:gMonth) then 'xs:gMonth' else if ($val instance of xs:gYear) then 'xs:gYear' else if ($val instance of xs:gYearMonth) then 'xs:gYearMonth' else if ($val instance of xs:gDay) then 'xs:gDay' else if ($val instance of xs:gMonthDay) then 'xs:gMonthDay' else 'unknown') } ;                     (functx:atomic-type(xs:date('2005-12-15')))
declare namespace functx = "http://www.example.com/";                     (:~ : The day of the week, from a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week.html : @param $date the date :)          declare function functx:day-of-week ( $date as xs:anyAtomicType? ) as xs:integer? { if (empty($date)) then () else xs:integer((xs:date($date) - xs:date('1901-01-06')) div xs:dayTimeDuration('P1D')) mod 7 } ;                     (functx:day-of-week('2004-11-04'))
declare namespace functx = "http://www.example.com/";                     (:~ : The day of the week, from a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week.html : @param $date the date :)          declare function functx:day-of-week ( $date as xs:anyAtomicType? ) as xs:integer? { if (empty($date)) then () else xs:integer((xs:date($date) - xs:date('1901-01-06')) div xs:dayTimeDuration('P1D')) mod 7 } ;                     (functx:day-of-week( xs:date('2004-11-04')))
declare namespace functx = "http://www.example.com/";                     (:~ : The day of the week, from a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week.html : @param $date the date :)          declare function functx:day-of-week ( $date as xs:anyAtomicType? ) as xs:integer? { if (empty($date)) then () else xs:integer((xs:date($date) - xs:date('1901-01-06')) div xs:dayTimeDuration('P1D')) mod 7 } ;                     (functx:day-of-week( xs:date('2004-11-04')), functx:day-of-week( xs:dateTime('2004-11-04T12:00:13')), functx:day-of-week('2004-11-04'))
declare namespace functx = "http://www.example.com/";                     (:~ : The day of the week, from a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week.html : @param $date the date :)          declare function functx:day-of-week ( $date as xs:anyAtomicType? ) as xs:integer? { if (empty($date)) then () else xs:integer((xs:date($date) - xs:date('1901-01-06')) div xs:dayTimeDuration('P1D')) mod 7 } ;                     (functx:day-of-week( xs:dateTime('2004-11-04T12:00:13')))
declare namespace functx = "http://www.example.com/";                     (:~ : The depth (level) of a node in an XML tree : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_depth-of-node.html : @param $node the node to check :)          declare function functx:depth-of-node ( $node as node()? ) as xs:integer { count($node/ancestor-or-self::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:depth-of-node($in-xml))
declare namespace functx = "http://www.example.com/";                     (:~ : The depth (level) of a node in an XML tree : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_depth-of-node.html : @param $node the node to check :)          declare function functx:depth-of-node ( $node as node()? ) as xs:integer { count($node/ancestor-or-self::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:depth-of-node($in-xml/author[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : The depth (level) of a node in an XML tree : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_depth-of-node.html : @param $node the node to check :)          declare function functx:depth-of-node ( $node as node()? ) as xs:integer { count($node/ancestor-or-self::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:depth-of-node( $in-xml/author[1]/fName/text()))
declare namespace functx = "http://www.example.com/";                     (:~ : The depth (level) of a node in an XML tree : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_depth-of-node.html : @param $node the node to check :)          declare function functx:depth-of-node ( $node as node()? ) as xs:integer { count($node/ancestor-or-self::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:depth-of-node($in-xml), functx:depth-of-node($in-xml/author[1]), functx:depth-of-node( $in-xml/author[1]/fName/text()))
declare namespace functx = "http://www.example.com/";                     (:~ : The distinct XML nodes in a sequence (by node identity) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_distinct-nodes.html : @param $nodes the node sequence :)          declare function functx:distinct-nodes ( $nodes as node()* ) as node()* { for $seq in (1 to count($nodes)) return $nodes[$seq][not(functx:is-node-in-sequence( .,$nodes[position() < $seq]))] } ;                     (:~ : Whether an XML node is in a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies $nodeInSeq is $node } ;                     let $in-xml :=  <test> <child>1</child> <child>2</child> <child>3</child> <child>3</child> </test> return (functx:distinct-nodes( ($in-xml/child, $in-xml/*) ))
declare namespace functx = "http://www.example.com/";                     (:~ : The distinct XML nodes in a sequence (by node identity) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_distinct-nodes.html : @param $nodes the node sequence :)          declare function functx:distinct-nodes ( $nodes as node()* ) as node()* { for $seq in (1 to count($nodes)) return $nodes[$seq][not(functx:is-node-in-sequence( .,$nodes[position() < $seq]))] } ;                     (:~ : Whether an XML node is in a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies $nodeInSeq is $node } ;                     let $in-xml :=  <test> <child>1</child> <child>2</child> <child>3</child> <child>3</child> </test> return (functx:distinct-nodes( ($in-xml/child, $in-xml/*) ), functx:distinct-nodes( ($in-xml/child[3], $in-xml/*) ))
declare namespace functx = "http://www.example.com/";                     (:~ : The distinct XML nodes in a sequence (by node identity) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_distinct-nodes.html : @param $nodes the node sequence :)          declare function functx:distinct-nodes ( $nodes as node()* ) as node()* { for $seq in (1 to count($nodes)) return $nodes[$seq][not(functx:is-node-in-sequence( .,$nodes[position() < $seq]))] } ;                     (:~ : Whether an XML node is in a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies $nodeInSeq is $node } ;                     let $in-xml :=  <test> <child>1</child> <child>2</child> <child>3</child> <child>3</child> </test> return (functx:distinct-nodes( ($in-xml/child[3], $in-xml/*) ))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (:~ : Construct a yearMonthDuration from a number of years and months : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_yearmonthduration.html : @param $years the number of years : @param $months the number of months :)          declare function functx:yearMonthDuration ( $years as xs:decimal? , $months as xs:integer? ) as xs:yearMonthDuration { (xs:yearMonthDuration('P1M') * functx:if-empty($months,0)) + (xs:yearMonthDuration('P1Y') * functx:if-empty($years,0)) } ;                     (functx:yearMonthDuration(0,0))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (:~ : Construct a yearMonthDuration from a number of years and months : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_yearmonthduration.html : @param $years the number of years : @param $months the number of months :)          declare function functx:yearMonthDuration ( $years as xs:decimal? , $months as xs:integer? ) as xs:yearMonthDuration { (xs:yearMonthDuration('P1M') * functx:if-empty($months,0)) + (xs:yearMonthDuration('P1Y') * functx:if-empty($years,0)) } ;                     (functx:yearMonthDuration(1,()))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (:~ : Construct a yearMonthDuration from a number of years and months : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_yearmonthduration.html : @param $years the number of years : @param $months the number of months :)          declare function functx:yearMonthDuration ( $years as xs:decimal? , $months as xs:integer? ) as xs:yearMonthDuration { (xs:yearMonthDuration('P1M') * functx:if-empty($months,0)) + (xs:yearMonthDuration('P1Y') * functx:if-empty($years,0)) } ;                     (functx:yearMonthDuration(1,0))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (:~ : Construct a yearMonthDuration from a number of years and months : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_yearmonthduration.html : @param $years the number of years : @param $months the number of months :)          declare function functx:yearMonthDuration ( $years as xs:decimal? , $months as xs:integer? ) as xs:yearMonthDuration { (xs:yearMonthDuration('P1M') * functx:if-empty($months,0)) + (xs:yearMonthDuration('P1Y') * functx:if-empty($years,0)) } ;                     (functx:yearMonthDuration(-1,-3))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (:~ : Construct a yearMonthDuration from a number of years and months : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_yearmonthduration.html : @param $years the number of years : @param $months the number of months :)          declare function functx:yearMonthDuration ( $years as xs:decimal? , $months as xs:integer? ) as xs:yearMonthDuration { (xs:yearMonthDuration('P1M') * functx:if-empty($months,0)) + (xs:yearMonthDuration('P1Y') * functx:if-empty($years,0)) } ;                     (functx:yearMonthDuration(-1,3))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (:~ : Construct a yearMonthDuration from a number of years and months : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_yearmonthduration.html : @param $years the number of years : @param $months the number of months :)          declare function functx:yearMonthDuration ( $years as xs:decimal? , $months as xs:integer? ) as xs:yearMonthDuration { (xs:yearMonthDuration('P1M') * functx:if-empty($months,0)) + (xs:yearMonthDuration('P1Y') * functx:if-empty($years,0)) } ;                     (functx:yearMonthDuration(1.5,0))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (:~ : Construct a yearMonthDuration from a number of years and months : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_yearmonthduration.html : @param $years the number of years : @param $months the number of months :)          declare function functx:yearMonthDuration ( $years as xs:decimal? , $months as xs:integer? ) as xs:yearMonthDuration { (xs:yearMonthDuration('P1M') * functx:if-empty($months,0)) + (xs:yearMonthDuration('P1Y') * functx:if-empty($years,0)) } ;                     (functx:yearMonthDuration(1,6))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (:~ : Construct a yearMonthDuration from a number of years and months : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_yearmonthduration.html : @param $years the number of years : @param $months the number of months :)          declare function functx:yearMonthDuration ( $years as xs:decimal? , $months as xs:integer? ) as xs:yearMonthDuration { (xs:yearMonthDuration('P1M') * functx:if-empty($months,0)) + (xs:yearMonthDuration('P1Y') * functx:if-empty($years,0)) } ;                     (functx:yearMonthDuration(1,6), functx:yearMonthDuration(1.5,0), functx:yearMonthDuration(1,()), functx:yearMonthDuration(1,0), functx:yearMonthDuration(-1,-3), functx:yearMonthDuration(-1,3), functx:yearMonthDuration(0,0))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     let $in-xml := <prices> <price discount="10.00">29.99</price> <price discount="6.00">39.99</price> <price></price> <price discount="">49.99</price> </prices> return (functx:if-empty($in-xml//price[1], 0))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     let $in-xml := <prices> <price discount="10.00">29.99</price> <price discount="6.00">39.99</price> <price></price> <price discount="">49.99</price> </prices> return (functx:if-empty($in-xml//price[1], 0), functx:if-empty($in-xml//price[3], 0), functx:if-empty($in-xml//price[99], 0), functx:if-empty($in-xml//price[1]/@discount, 0), functx:if-empty($in-xml//price[3]/@discount, 0), functx:if-empty($in-xml//price[4]/@discount, 0))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     let $in-xml := <prices> <price discount="10.00">29.99</price> <price discount="6.00">39.99</price> <price></price> <price discount="">49.99</price> </prices> return (functx:if-empty($in-xml//price[1]/@discount, 0))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     let $in-xml := <prices> <price discount="10.00">29.99</price> <price discount="6.00">39.99</price> <price></price> <price discount="">49.99</price> </prices> return (functx:if-empty($in-xml//price[3], 0))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     let $in-xml := <prices> <price discount="10.00">29.99</price> <price discount="6.00">39.99</price> <price></price> <price discount="">49.99</price> </prices> return (functx:if-empty($in-xml//price[3]/@discount, 0))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     let $in-xml := <prices> <price discount="10.00">29.99</price> <price discount="6.00">39.99</price> <price></price> <price discount="">49.99</price> </prices> return (functx:if-empty($in-xml//price[4]/@discount, 0))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     let $in-xml := <prices> <price discount="10.00">29.99</price> <price discount="6.00">39.99</price> <price></price> <price discount="">49.99</price> </prices> return (functx:if-empty($in-xml//price[99], 0))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not empty, otherwise the second argument : : @author W3C XML Query WG : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-absent.html : @param $arg the item(s) that may be absent : @param $value the item(s) to use if the item is absent :)          declare function functx:if-absent ( $arg as item()* , $value as item()* ) as item()* { if (exists($arg)) then $arg else $value } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="69.99"/> <price value="49.99" discount=""/> </prices> return (data(functx:if-absent( $in-xml//price[1]/@discount, 0)))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not empty, otherwise the second argument : : @author W3C XML Query WG : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-absent.html : @param $arg the item(s) that may be absent : @param $value the item(s) to use if the item is absent :)          declare function functx:if-absent ( $arg as item()* , $value as item()* ) as item()* { if (exists($arg)) then $arg else $value } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="69.99"/> <price value="49.99" discount=""/> </prices> return (data(functx:if-absent( $in-xml//price[1]/@discount, 0)), data(functx:if-absent( $in-xml//price[3]/@discount, 0)), data(functx:if-absent( $in-xml//price[4]/@discount, 0)))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not empty, otherwise the second argument : : @author W3C XML Query WG : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-absent.html : @param $arg the item(s) that may be absent : @param $value the item(s) to use if the item is absent :)          declare function functx:if-absent ( $arg as item()* , $value as item()* ) as item()* { if (exists($arg)) then $arg else $value } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="69.99"/> <price value="49.99" discount=""/> </prices> return (data(functx:if-absent( $in-xml//price[3]/@discount, 0)))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not empty, otherwise the second argument : : @author W3C XML Query WG : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-absent.html : @param $arg the item(s) that may be absent : @param $value the item(s) to use if the item is absent :)          declare function functx:if-absent ( $arg as item()* , $value as item()* ) as item()* { if (exists($arg)) then $arg else $value } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="69.99"/> <price value="49.99" discount=""/> </prices> return (data(functx:if-absent( $in-xml//price[4]/@discount, 0)))
declare namespace functx = "http://www.example.com/";                     (:~ : The first position of a matching substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-match-first.html : @param $arg the string : @param $pattern the pattern to match :)          declare function functx:index-of-match-first ( $arg as xs:string? , $pattern as xs:string ) as xs:integer? { if (matches($arg,$pattern)) then string-length(tokenize($arg, $pattern)[1]) + 1 else () } ;                     (functx:index-of-match-first('a1234','\d'))
declare namespace functx = "http://www.example.com/";                     (:~ : The first position of a matching substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-match-first.html : @param $arg the string : @param $pattern the pattern to match :)          declare function functx:index-of-match-first ( $arg as xs:string? , $pattern as xs:string ) as xs:integer? { if (matches($arg,$pattern)) then string-length(tokenize($arg, $pattern)[1]) + 1 else () } ;                     (functx:index-of-match-first('abc abc','\s'))
declare namespace functx = "http://www.example.com/";                     (:~ : The first position of a matching substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-match-first.html : @param $arg the string : @param $pattern the pattern to match :)          declare function functx:index-of-match-first ( $arg as xs:string? , $pattern as xs:string ) as xs:integer? { if (matches($arg,$pattern)) then string-length(tokenize($arg, $pattern)[1]) + 1 else () } ;                     (functx:index-of-match-first('abc abc','z'))
declare namespace functx = "http://www.example.com/";                     (:~ : The first position of a matching substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-match-first.html : @param $arg the string : @param $pattern the pattern to match :)          declare function functx:index-of-match-first ( $arg as xs:string? , $pattern as xs:string ) as xs:integer? { if (matches($arg,$pattern)) then string-length(tokenize($arg, $pattern)[1]) + 1 else () } ;                     (functx:index-of-match-first( 'abcdabcdabcd','abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : The first position of a matching substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-match-first.html : @param $arg the string : @param $pattern the pattern to match :)          declare function functx:index-of-match-first ( $arg as xs:string? , $pattern as xs:string ) as xs:integer? { if (matches($arg,$pattern)) then string-length(tokenize($arg, $pattern)[1]) + 1 else () } ;                     (functx:index-of-match-first( 'abcdabcdabcd','abc'), functx:index-of-match-first( 'abcdabcdabcd','bcd'), functx:index-of-match-first('a1234','\d'), functx:index-of-match-first('abc abc','\s'), functx:index-of-match-first('abc abc','z'))
declare namespace functx = "http://www.example.com/";                     (:~ : The first position of a matching substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-match-first.html : @param $arg the string : @param $pattern the pattern to match :)          declare function functx:index-of-match-first ( $arg as xs:string? , $pattern as xs:string ) as xs:integer? { if (matches($arg,$pattern)) then string-length(tokenize($arg, $pattern)[1]) + 1 else () } ;                     (functx:index-of-match-first( 'abcdabcdabcd','bcd'))
declare namespace functx = "http://www.example.com/";                     (:~ : The first position of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string-first.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string-first ( $arg as xs:string? , $substring as xs:string ) as xs:integer? { if (contains($arg, $substring)) then string-length(substring-before($arg, $substring))+1 else () } ;                     (functx:index-of-string-first( 'abcd','abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : The first position of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string-first.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string-first ( $arg as xs:string? , $substring as xs:string ) as xs:integer? { if (contains($arg, $substring)) then string-length(substring-before($arg, $substring))+1 else () } ;                     (functx:index-of-string-first( 'abcdabcdabcd','abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : The first position of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string-first.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string-first ( $arg as xs:string? , $substring as xs:string ) as xs:integer? { if (contains($arg, $substring)) then string-length(substring-before($arg, $substring))+1 else () } ;                     (functx:index-of-string-first( 'abcdabcdabcd','abc'), functx:index-of-string-first( 'abcd','abc'), functx:index-of-string-first( 'xxx','abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : The first position of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string-first.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string-first ( $arg as xs:string? , $substring as xs:string ) as xs:integer? { if (contains($arg, $substring)) then string-length(substring-before($arg, $substring))+1 else () } ;                     (functx:index-of-string-first( 'xxx','abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : The last position of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string-last.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string-last ( $arg as xs:string? , $substring as xs:string ) as xs:integer? { functx:index-of-string($arg, $substring)[last()] } ;                     (:~ : The position(s) of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string ( $arg as xs:string? , $substring as xs:string ) as xs:integer* { if (contains($arg, $substring)) then (string-length(substring-before($arg, $substring))+1, for $other in functx:index-of-string(substring-after($arg, $substring), $substring) return $other + string-length(substring-before($arg, $substring)) + string-length($substring)) else () } ;                     (functx:index-of-string-last( 'abcd','abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : The last position of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string-last.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string-last ( $arg as xs:string? , $substring as xs:string ) as xs:integer? { functx:index-of-string($arg, $substring)[last()] } ;                     (:~ : The position(s) of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string ( $arg as xs:string? , $substring as xs:string ) as xs:integer* { if (contains($arg, $substring)) then (string-length(substring-before($arg, $substring))+1, for $other in functx:index-of-string(substring-after($arg, $substring), $substring) return $other + string-length(substring-before($arg, $substring)) + string-length($substring)) else () } ;                     (functx:index-of-string-last( 'abcdabcdabcd','abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : The last position of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string-last.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string-last ( $arg as xs:string? , $substring as xs:string ) as xs:integer? { functx:index-of-string($arg, $substring)[last()] } ;                     (:~ : The position(s) of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string ( $arg as xs:string? , $substring as xs:string ) as xs:integer* { if (contains($arg, $substring)) then (string-length(substring-before($arg, $substring))+1, for $other in functx:index-of-string(substring-after($arg, $substring), $substring) return $other + string-length(substring-before($arg, $substring)) + string-length($substring)) else () } ;                     (functx:index-of-string-last( 'abcdabcdabcd','abc'), functx:index-of-string-last( 'abcd','abc'), functx:index-of-string-last( 'xxx','abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : The last position of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string-last.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string-last ( $arg as xs:string? , $substring as xs:string ) as xs:integer? { functx:index-of-string($arg, $substring)[last()] } ;                     (:~ : The position(s) of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string ( $arg as xs:string? , $substring as xs:string ) as xs:integer* { if (contains($arg, $substring)) then (string-length(substring-before($arg, $substring))+1, for $other in functx:index-of-string(substring-after($arg, $substring), $substring) return $other + string-length(substring-before($arg, $substring)) + string-length($substring)) else () } ;                     (functx:index-of-string-last( 'xxx','abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : The maximum depth of elements in an XML tree : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-depth.html : @param $root the root to start from :)          declare function functx:max-depth ( $root as node()? ) as xs:integer? { if ($root/*) then max($root/*/functx:max-depth(.)) + 1 else 1 } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:max-depth($in-xml))
declare namespace functx = "http://www.example.com/";                     (:~ : The maximum depth of elements in an XML tree : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-depth.html : @param $root the root to start from :)          declare function functx:max-depth ( $root as node()? ) as xs:integer? { if ($root/*) then max($root/*/functx:max-depth(.)) + 1 else 1 } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:max-depth($in-xml/author[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : The maximum depth of elements in an XML tree : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-depth.html : @param $root the root to start from :)          declare function functx:max-depth ( $root as node()? ) as xs:integer? { if ($root/*) then max($root/*/functx:max-depth(.)) + 1 else 1 } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:max-depth($in-xml), functx:max-depth($in-xml/author[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : The maximum of a sequence of values, treating them like strings : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-string.html : @param $strings the sequence of values :)          declare function functx:max-string ( $strings as xs:anyAtomicType* ) as xs:string? { max(for $string in $strings return string($string)) } ;                     let $in-xml := <in-xml> <x>a</x> <y>c</y> <z>b</z> </in-xml> return (functx:max-string( $in-xml/* ))
declare namespace functx = "http://www.example.com/";                     (:~ : The maximum of a sequence of values, treating them like strings : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-string.html : @param $strings the sequence of values :)          declare function functx:max-string ( $strings as xs:anyAtomicType* ) as xs:string? { max(for $string in $strings return string($string)) } ;                     let $in-xml := <in-xml> <x>a</x> <y>c</y> <z>b</z> </in-xml> return (functx:max-string( $in-xml/* ), functx:max-string( (100,25,3) ))
declare namespace functx = "http://www.example.com/";                     (:~ : The maximum of a sequence of values, treating them like strings : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-string.html : @param $strings the sequence of values :)          declare function functx:max-string ( $strings as xs:anyAtomicType* ) as xs:string? { max(for $string in $strings return string($string)) } ;                     let $in-xml := <in-xml> <x>a</x> <y>c</y> <z>b</z> </in-xml> return (functx:max-string( (100,25,3) ))
declare namespace functx = "http://www.example.com/";                     (:~ : The maximum value in a sequence, figuring out its type (numeric or string) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-determine-type.html : @param $seq the sequence of values to test :)          declare function functx:max-determine-type ( $seq as xs:anyAtomicType* ) as xs:anyAtomicType? { if (every $value in $seq satisfies ($value castable as xs:double)) then max(for $value in $seq return xs:double($value)) else max(for $value in $seq return xs:string($value)) } ;                     let $in-xml := <values> <nums> <num>12</num> <num>23</num> <num>115</num> <num>12.5</num> </nums> <strings> <string>def</string> <string>abc</string> </strings> </values> return (functx:max-determine-type($in-xml//num))
declare namespace functx = "http://www.example.com/";                     (:~ : The maximum value in a sequence, figuring out its type (numeric or string) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-determine-type.html : @param $seq the sequence of values to test :)          declare function functx:max-determine-type ( $seq as xs:anyAtomicType* ) as xs:anyAtomicType? { if (every $value in $seq satisfies ($value castable as xs:double)) then max(for $value in $seq return xs:double($value)) else max(for $value in $seq return xs:string($value)) } ;                     let $in-xml := <values> <nums> <num>12</num> <num>23</num> <num>115</num> <num>12.5</num> </nums> <strings> <string>def</string> <string>abc</string> </strings> </values> return (functx:max-determine-type($in-xml//num), functx:max-determine-type($in-xml//string), functx:max-determine-type( $in-xml//(num|string)))
declare namespace functx = "http://www.example.com/";                     (:~ : The maximum value in a sequence, figuring out its type (numeric or string) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-determine-type.html : @param $seq the sequence of values to test :)          declare function functx:max-determine-type ( $seq as xs:anyAtomicType* ) as xs:anyAtomicType? { if (every $value in $seq satisfies ($value castable as xs:double)) then max(for $value in $seq return xs:double($value)) else max(for $value in $seq return xs:string($value)) } ;                     let $in-xml := <values> <nums> <num>12</num> <num>23</num> <num>115</num> <num>12.5</num> </nums> <strings> <string>def</string> <string>abc</string> </strings> </values> return (functx:max-determine-type( $in-xml//(num|string)))
declare namespace functx = "http://www.example.com/";                     (:~ : The maximum value in a sequence, figuring out its type (numeric or string) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-determine-type.html : @param $seq the sequence of values to test :)          declare function functx:max-determine-type ( $seq as xs:anyAtomicType* ) as xs:anyAtomicType? { if (every $value in $seq satisfies ($value castable as xs:double)) then max(for $value in $seq return xs:double($value)) else max(for $value in $seq return xs:string($value)) } ;                     let $in-xml := <values> <nums> <num>12</num> <num>23</num> <num>115</num> <num>12.5</num> </nums> <strings> <string>def</string> <string>abc</string> </strings> </values> return (functx:max-determine-type($in-xml//string))
declare namespace functx = "http://www.example.com/";                     (:~ : The minimum of a sequence of strings, ignoring "empty" values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_min-non-empty-string.html : @param $strings the sequence of strings to search :)          declare function functx:min-non-empty-string ( $strings as xs:string* ) as xs:string? { min($strings[. != '']) } ;                     let $in-xml := <authors> <author> <fName/> <lName>Smith</lName> </author> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:min-non-empty-string( $in-xml//fName ))
declare namespace functx = "http://www.example.com/";                     (:~ : The minimum of a sequence of values, treating them like strings : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_min-string.html : @param $strings the sequence of strings :)          declare function functx:min-string ( $strings as xs:anyAtomicType* ) as xs:string? { min(for $string in $strings return string($string)) } ;                     let $in-xml := <in-xml> <x>a</x> <y>c</y> <z>b</z> </in-xml> return (functx:min-string( $in-xml/* ))
declare namespace functx = "http://www.example.com/";                     (:~ : The minimum of a sequence of values, treating them like strings : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_min-string.html : @param $strings the sequence of strings :)          declare function functx:min-string ( $strings as xs:anyAtomicType* ) as xs:string? { min(for $string in $strings return string($string)) } ;                     let $in-xml := <in-xml> <x>a</x> <y>c</y> <z>b</z> </in-xml> return (functx:min-string( $in-xml/* ), functx:min-string( (100,25,3) ))
declare namespace functx = "http://www.example.com/";                     (:~ : The minimum of a sequence of values, treating them like strings : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_min-string.html : @param $strings the sequence of strings :)          declare function functx:min-string ( $strings as xs:anyAtomicType* ) as xs:string? { min(for $string in $strings return string($string)) } ;                     let $in-xml := <in-xml> <x>a</x> <y>c</y> <z>b</z> </in-xml> return (functx:min-string( (100,25,3) ))
declare namespace functx = "http://www.example.com/";                     (:~ : The minimum value in a sequence, figuring out its type (numeric or string) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_min-determine-type.html : @param $seq the sequence of values to test :)          declare function functx:min-determine-type ( $seq as xs:anyAtomicType* ) as xs:anyAtomicType? { if (every $value in $seq satisfies ($value castable as xs:double)) then min(for $value in $seq return xs:double($value)) else min(for $value in $seq return xs:string($value)) } ;                     let $in-xml := <values> <nums> <num>12</num> <num>23</num> <num>115</num> <num>12.5</num> </nums> <strings> <str>def</str> <str>abc</str> </strings> </values> return (functx:min-determine-type($in-xml//num))
declare namespace functx = "http://www.example.com/";                     (:~ : The minimum value in a sequence, figuring out its type (numeric or string) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_min-determine-type.html : @param $seq the sequence of values to test :)          declare function functx:min-determine-type ( $seq as xs:anyAtomicType* ) as xs:anyAtomicType? { if (every $value in $seq satisfies ($value castable as xs:double)) then min(for $value in $seq return xs:double($value)) else min(for $value in $seq return xs:string($value)) } ;                     let $in-xml := <values> <nums> <num>12</num> <num>23</num> <num>115</num> <num>12.5</num> </nums> <strings> <str>def</str> <str>abc</str> </strings> </values> return (functx:min-determine-type($in-xml//num), functx:min-determine-type($in-xml//str), functx:min-determine-type($in-xml//(num|str)))
declare namespace functx = "http://www.example.com/";                     (:~ : The minimum value in a sequence, figuring out its type (numeric or string) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_min-determine-type.html : @param $seq the sequence of values to test :)          declare function functx:min-determine-type ( $seq as xs:anyAtomicType* ) as xs:anyAtomicType? { if (every $value in $seq satisfies ($value castable as xs:double)) then min(for $value in $seq return xs:double($value)) else min(for $value in $seq return xs:string($value)) } ;                     let $in-xml := <values> <nums> <num>12</num> <num>23</num> <num>115</num> <num>12.5</num> </nums> <strings> <str>def</str> <str>abc</str> </strings> </values> return (functx:min-determine-type($in-xml//(num|str)))
declare namespace functx = "http://www.example.com/";                     (:~ : The minimum value in a sequence, figuring out its type (numeric or string) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_min-determine-type.html : @param $seq the sequence of values to test :)          declare function functx:min-determine-type ( $seq as xs:anyAtomicType* ) as xs:anyAtomicType? { if (every $value in $seq satisfies ($value castable as xs:double)) then min(for $value in $seq return xs:double($value)) else min(for $value in $seq return xs:string($value)) } ;                     let $in-xml := <values> <nums> <num>12</num> <num>23</num> <num>115</num> <num>12.5</num> </nums> <strings> <str>def</str> <str>abc</str> </strings> </values> return (functx:min-determine-type($in-xml//str))
declare namespace functx = "http://www.example.com/";                     (:~ : The month of a date as an abbreviated word (Jan, Feb, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_month-abbrev-en.html : @param $date the date :)          declare function functx:month-abbrev-en ( $date as xs:anyAtomicType? ) as xs:string? { ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec') [month-from-date(xs:date($date))] } ;                     (functx:month-abbrev-en('2004-01-23'))
declare namespace functx = "http://www.example.com/";                     (:~ : The month of a date as an abbreviated word (Jan, Feb, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_month-abbrev-en.html : @param $date the date :)          declare function functx:month-abbrev-en ( $date as xs:anyAtomicType? ) as xs:string? { ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec') [month-from-date(xs:date($date))] } ;                     (functx:month-abbrev-en(xs:date('2004-01-23')))
declare namespace functx = "http://www.example.com/";                     (:~ : The month of a date as an abbreviated word (Jan, Feb, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_month-abbrev-en.html : @param $date the date :)          declare function functx:month-abbrev-en ( $date as xs:anyAtomicType? ) as xs:string? { ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec') [month-from-date(xs:date($date))] } ;                     (functx:month-abbrev-en(xs:date('2004-01-23')), functx:month-abbrev-en( xs:dateTime('2004-01-23T12:00:13')), functx:month-abbrev-en('2004-01-23'))
declare namespace functx = "http://www.example.com/";                     (:~ : The month of a date as an abbreviated word (Jan, Feb, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_month-abbrev-en.html : @param $date the date :)          declare function functx:month-abbrev-en ( $date as xs:anyAtomicType? ) as xs:string? { ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec') [month-from-date(xs:date($date))] } ;                     (functx:month-abbrev-en( xs:dateTime('2004-01-23T12:00:13')))
declare namespace functx = "http://www.example.com/";                     (:~ : The month of a date as a word (January, February, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_month-name-en.html : @param $date the date :)          declare function functx:month-name-en ( $date as xs:anyAtomicType? ) as xs:string? { ('January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December') [month-from-date(xs:date($date))] } ;                     (functx:month-name-en('2004-01-23'))
declare namespace functx = "http://www.example.com/";                     (:~ : The month of a date as a word (January, February, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_month-name-en.html : @param $date the date :)          declare function functx:month-name-en ( $date as xs:anyAtomicType? ) as xs:string? { ('January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December') [month-from-date(xs:date($date))] } ;                     (functx:month-name-en(xs:date('2004-01-23')))
declare namespace functx = "http://www.example.com/";                     (:~ : The month of a date as a word (January, February, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_month-name-en.html : @param $date the date :)          declare function functx:month-name-en ( $date as xs:anyAtomicType? ) as xs:string? { ('January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December') [month-from-date(xs:date($date))] } ;                     (functx:month-name-en(xs:date('2004-01-23')), functx:month-name-en( xs:dateTime('2004-01-23T12:00:13')), functx:month-name-en('2004-01-23'))
declare namespace functx = "http://www.example.com/";                     (:~ : The month of a date as a word (January, February, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_month-name-en.html : @param $date the date :)          declare function functx:month-name-en ( $date as xs:anyAtomicType? ) as xs:string? { ('January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December') [month-from-date(xs:date($date))] } ;                     (functx:month-name-en( xs:dateTime('2004-01-23T12:00:13')))
declare namespace functx = "http://www.example.com/";                     (:~ : The name of the day of the week, from a date, in English : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week-name-en.html : @param $date the date :)          declare function functx:day-of-week-name-en ( $date as xs:anyAtomicType? ) as xs:string? { ('Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday') [functx:day-of-week($date) + 1] } ;                     (:~ : The day of the week, from a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week.html : @param $date the date :)          declare function functx:day-of-week ( $date as xs:anyAtomicType? ) as xs:integer? { if (empty($date)) then () else xs:integer((xs:date($date) - xs:date('1901-01-06')) div xs:dayTimeDuration('P1D')) mod 7 } ;                     (functx:day-of-week-name-en('2004-11-04'))
declare namespace functx = "http://www.example.com/";                     (:~ : The name of the day of the week, from a date, in English : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week-name-en.html : @param $date the date :)          declare function functx:day-of-week-name-en ( $date as xs:anyAtomicType? ) as xs:string? { ('Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday') [functx:day-of-week($date) + 1] } ;                     (:~ : The day of the week, from a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week.html : @param $date the date :)          declare function functx:day-of-week ( $date as xs:anyAtomicType? ) as xs:integer? { if (empty($date)) then () else xs:integer((xs:date($date) - xs:date('1901-01-06')) div xs:dayTimeDuration('P1D')) mod 7 } ;                     (functx:day-of-week-name-en( xs:date('2004-11-04')))
declare namespace functx = "http://www.example.com/";                     (:~ : The name of the day of the week, from a date, in English : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week-name-en.html : @param $date the date :)          declare function functx:day-of-week-name-en ( $date as xs:anyAtomicType? ) as xs:string? { ('Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday') [functx:day-of-week($date) + 1] } ;                     (:~ : The day of the week, from a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week.html : @param $date the date :)          declare function functx:day-of-week ( $date as xs:anyAtomicType? ) as xs:integer? { if (empty($date)) then () else xs:integer((xs:date($date) - xs:date('1901-01-06')) div xs:dayTimeDuration('P1D')) mod 7 } ;                     (functx:day-of-week-name-en( xs:date('2004-11-04')), functx:day-of-week-name-en('2004-11-04'))
declare namespace functx = "http://www.example.com/";                     (:~ : The number of lines : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_line-count.html : @param $arg the string to test :)          declare function functx:line-count ( $arg as xs:string? ) as xs:integer { count(functx:lines($arg)) } ;                     (:~ : Split a string into separate lines : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_lines.html : @param $arg the string to split :)          declare function functx:lines ( $arg as xs:string? ) as xs:string* { tokenize($arg, '(\r\n?|\n\r?)') } ;                     let $lines := 'a value on many lines' return (functx:line-count('a value'))
declare namespace functx = "http://www.example.com/";                     (:~ : The number of regions that match a pattern : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_number-of-matches.html : @param $arg the string to test : @param $pattern the regular expression :)          declare function functx:number-of-matches ( $arg as xs:string? , $pattern as xs:string ) as xs:integer { count(tokenize($arg,$pattern)) - 1 } ;                     (functx:number-of-matches('12345','\d'))
declare namespace functx = "http://www.example.com/";                     (:~ : The number of regions that match a pattern : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_number-of-matches.html : @param $arg the string to test : @param $pattern the regular expression :)          declare function functx:number-of-matches ( $arg as xs:string? , $pattern as xs:string ) as xs:integer { count(tokenize($arg,$pattern)) - 1 } ;                     (functx:number-of-matches('aaaaaa','aaa'))
declare namespace functx = "http://www.example.com/";                     (:~ : The number of regions that match a pattern : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_number-of-matches.html : @param $arg the string to test : @param $pattern the regular expression :)          declare function functx:number-of-matches ( $arg as xs:string? , $pattern as xs:string ) as xs:integer { count(tokenize($arg,$pattern)) - 1 } ;                     (functx:number-of-matches('abcabc','ab'))
declare namespace functx = "http://www.example.com/";                     (:~ : The number of regions that match a pattern : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_number-of-matches.html : @param $arg the string to test : @param $pattern the regular expression :)          declare function functx:number-of-matches ( $arg as xs:string? , $pattern as xs:string ) as xs:integer { count(tokenize($arg,$pattern)) - 1 } ;                     (functx:number-of-matches('abcabc','ab'), functx:number-of-matches('12345','\d'), functx:number-of-matches('aaaaaa','aaa'))
declare namespace functx = "http://www.example.com/";                     (:~ : The number of words : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_word-count.html : @param $arg the string to measure :)          declare function functx:word-count ( $arg as xs:string? ) as xs:integer { count(tokenize($arg, '\W+')[. != '']) } ;                     (functx:word-count('a.b.c'))
declare namespace functx = "http://www.example.com/";                     (:~ : The number of words : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_word-count.html : @param $arg the string to measure :)          declare function functx:word-count ( $arg as xs:string? ) as xs:integer { count(tokenize($arg, '\W+')[. != '']) } ;                     (functx:word-count('hello there world'))
declare namespace functx = "http://www.example.com/";                     (:~ : The number of words : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_word-count.html : @param $arg the string to measure :)          declare function functx:word-count ( $arg as xs:string? ) as xs:integer { count(tokenize($arg, '\W+')[. != '']) } ;                     (functx:word-count('hello there world'), functx:word-count(' hello world '), functx:word-count('a.b.c'))
declare namespace functx = "http://www.example.com/";                     (:~ : The number of words : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_word-count.html : @param $arg the string to measure :)          declare function functx:word-count ( $arg as xs:string? ) as xs:integer { count(tokenize($arg, '\W+')[. != '']) } ;                     (functx:word-count(' hello world '))
declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-deep-equal-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-deep-equal-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[deep-equal($nodes[$seq],$nodeToFind)] } ;                     let $in-xml := <authors> <author> <fName/> <lName>Smith</lName> </author> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return let $anotherAuthor := <author> <fName>John</fName> <lName>Smith</lName> </author> return (functx:index-of-deep-equal-node( $in-xml/author,$anAuthor))
declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on contents and attributes :                         : @author Priscilla Walmsley, Datypic                         : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-deep-equal-node.html                         : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)                                   declare function functx:index-of-deep-equal-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* {              for $seq in (1 to count($nodes))              return $seq[deep-equal($nodes[$seq],$nodeToFind)]           } ;          let $in-xml := <authors> <author> <fName/> <lName>Smith</lName> </author> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors>           return               let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author>               return                   let $anotherAuthor := <author> <fName>John</fName> <lName>Smith</lName> </author>                   return (functx:index-of-deep-equal-node( $in-xml/author,$anAuthor),                           functx:index-of-deep-equal-node( $in-xml/author,$anotherAuthor),                           functx:index-of-deep-equal-node( $in-xml/author/lName,$anAuthor/lName))
declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-deep-equal-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-deep-equal-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[deep-equal($nodes[$seq],$nodeToFind)] } ;                     let $in-xml := <authors> <author> <fName/> <lName>Smith</lName> </author> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return let $anotherAuthor := <author> <fName>John</fName> <lName>Smith</lName> </author> return (functx:index-of-deep-equal-node( $in-xml/author,$anotherAuthor))
declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-deep-equal-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-deep-equal-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[deep-equal($nodes[$seq],$nodeToFind)] } ;                     let $in-xml := <authors> <author> <fName/> <lName>Smith</lName> </author> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return let $anotherAuthor := <author> <fName>John</fName> <lName>Smith</lName> </author> return (functx:index-of-deep-equal-node( $in-xml/author/lName,$anAuthor/lName))
declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on node identity : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[$nodes[$seq] is $nodeToFind] } ;                     (:~ : A unique path to an XML node (or sequence of nodes) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_path-to-node-with-pos.html : @param $node the node sequence :)          declare function functx:path-to-node-with-pos ( $node as node()? ) as xs:string { string-join( for $ancestor in $node/ancestor-or-self::* let $sibsOfSameName := $ancestor/../*[name() = name($ancestor)] return concat(name($ancestor), if (count($sibsOfSameName) <= 1) then '' else concat( '[',functx:index-of-node($sibsOfSameName,$ancestor),']')) , '/') } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:path-to-node-with-pos($in-xml/*[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on node identity : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[$nodes[$seq] is $nodeToFind] } ;                     (:~ : A unique path to an XML node (or sequence of nodes) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_path-to-node-with-pos.html : @param $node the node sequence :)          declare function functx:path-to-node-with-pos ( $node as node()? ) as xs:string { string-join( for $ancestor in $node/ancestor-or-self::* let $sibsOfSameName := $ancestor/../*[name() = name($ancestor)] return concat(name($ancestor), if (count($sibsOfSameName) <= 1) then '' else concat( '[',functx:index-of-node($sibsOfSameName,$ancestor),']')) , '/') } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:path-to-node-with-pos( $in-xml//lName[. = 'Doe']))
declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on node identity : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[$nodes[$seq] is $nodeToFind] } ;                     (:~ : A unique path to an XML node (or sequence of nodes) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_path-to-node-with-pos.html : @param $node the node sequence :)          declare function functx:path-to-node-with-pos ( $node as node()? ) as xs:string { string-join( for $ancestor in $node/ancestor-or-self::* let $sibsOfSameName := $ancestor/../*[name() = name($ancestor)] return concat(name($ancestor), if (count($sibsOfSameName) <= 1) then '' else concat( '[',functx:index-of-node($sibsOfSameName,$ancestor),']')) , '/') } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:path-to-node-with-pos( $in-xml//lName[. = 'Doe']), functx:path-to-node-with-pos($in-xml/*[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on node identity : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[$nodes[$seq] is $nodeToFind] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:index-of-node( $in-xml/author,$in-xml/author[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on node identity : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[$nodes[$seq] is $nodeToFind] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:index-of-node( $in-xml/author,$in-xml/author[1]), functx:index-of-node( $in-xml/author,$in-xml/author[2]), functx:index-of-node( $in-xml/author, $in-xml/author[lName='Doe']))
declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on node identity : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[$nodes[$seq] is $nodeToFind] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:index-of-node( $in-xml/author,$in-xml/author[2]))
declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on node identity : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[$nodes[$seq] is $nodeToFind] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:index-of-node( $in-xml/author, $in-xml/author[lName='Doe']))
declare namespace functx = "http://www.example.com/";                     (:~ : The position(s) of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string ( $arg as xs:string? , $substring as xs:string ) as xs:integer* { if (contains($arg, $substring)) then (string-length(substring-before($arg, $substring))+1, for $other in functx:index-of-string(substring-after($arg, $substring), $substring) return $other + string-length(substring-before($arg, $substring)) + string-length($substring)) else () } ;                     (functx:index-of-string('abcd','abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : The position(s) of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string ( $arg as xs:string? , $substring as xs:string ) as xs:integer* { if (contains($arg, $substring)) then (string-length(substring-before($arg, $substring))+1, for $other in functx:index-of-string(substring-after($arg, $substring), $substring) return $other + string-length(substring-before($arg, $substring)) + string-length($substring)) else () } ;                     (functx:index-of-string('abcdabcdabcd','abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : The position(s) of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string ( $arg as xs:string? , $substring as xs:string ) as xs:integer* { if (contains($arg, $substring)) then (string-length(substring-before($arg, $substring))+1, for $other in functx:index-of-string(substring-after($arg, $substring), $substring) return $other + string-length(substring-before($arg, $substring)) + string-length($substring)) else () } ;                     (functx:index-of-string('abcdabcdabcd','abc'), functx:index-of-string('abcd','abc'), functx:index-of-string('xxx','abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : The position(s) of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string ( $arg as xs:string? , $substring as xs:string ) as xs:integer* { if (contains($arg, $substring)) then (string-length(substring-before($arg, $substring))+1, for $other in functx:index-of-string(substring-after($arg, $substring), $substring) return $other + string-length(substring-before($arg, $substring)) + string-length($substring)) else () } ;                     (functx:index-of-string('xxx','abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : The siblings of an XML element that have the same name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_siblings-same-name.html : @param $element the node :)          declare function functx:siblings-same-name ( $element as element()? ) as element()* { $element/../*[node-name(.) = node-name($element)] except $element } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <fName>Jane</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:siblings-same-name( $in-xml/author[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : The siblings of an XML element that have the same name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_siblings-same-name.html : @param $element the node :)          declare function functx:siblings-same-name ( $element as element()? ) as element()* { $element/../*[node-name(.) = node-name($element)] except $element } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <fName>Jane</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:siblings-same-name( $in-xml/author[1]/fName[2]))
declare namespace functx = "http://www.example.com/";                     (:~ : The siblings of an XML element that have the same name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_siblings-same-name.html : @param $element the node :)          declare function functx:siblings-same-name ( $element as element()? ) as element()* { $element/../*[node-name(.) = node-name($element)] except $element } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <fName>Jane</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:siblings-same-name( $in-xml/author[1]), functx:siblings-same-name( $in-xml/author[1]/fName[2]))
declare namespace functx = "http://www.example.com/";                     (:~ : The siblings of an XML node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_siblings.html : @param $node the node :)          declare function functx:siblings ( $node as node()? ) as node()* { $node/../node() except $node } ;                     let $in-xml := <authors a1='xyz'> <author a2='abc'> <fName a3='def'>Kate</fName> <fName a3='def'>Jane</fName> <lName>Jones</lName> </author> <author> <fName a3='def'>John</fName> <lName>Doe</lName> </author> </authors> return (functx:siblings( $in-xml/author[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : The siblings of an XML node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_siblings.html : @param $node the node :)          declare function functx:siblings ( $node as node()? ) as node()* { $node/../node() except $node } ;                     let $in-xml := <authors a1='xyz'> <author a2='abc'> <fName a3='def'>Kate</fName> <fName a3='def'>Jane</fName> <lName>Jones</lName> </author> <author> <fName a3='def'>John</fName> <lName>Doe</lName> </author> </authors> return (functx:siblings( $in-xml/author[1]/fName[2]))
declare namespace functx = "http://www.example.com/";                     (:~ : The siblings of an XML node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_siblings.html : @param $node the node :)          declare function functx:siblings ( $node as node()? ) as node()* { $node/../node() except $node } ;                     let $in-xml := <authors a1='xyz'> <author a2='abc'> <fName a3='def'>Kate</fName> <fName a3='def'>Jane</fName> <lName>Jones</lName> </author> <author> <fName a3='def'>John</fName> <lName>Doe</lName> </author> </authors> return (functx:siblings( $in-xml/author[1]), functx:siblings( $in-xml/author[1]/fName[2]))
declare namespace functx = "http://www.example.com/";                     (:~ : The substring before the first text that matches a regex : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-match.html : @param $arg the string to substring : @param $regex the regular expression :)          declare function functx:substring-before-match ( $arg as xs:string? , $regex as xs:string ) as xs:string? { tokenize($arg,$regex)[1] } ;                     (functx:substring-before-match( 'abcd-abcd', 'bc?'))
declare namespace functx = "http://www.example.com/";                     (:~ : The substring before the first text that matches a regex : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-match.html : @param $arg the string to substring : @param $regex the regular expression :)          declare function functx:substring-before-match ( $arg as xs:string? , $regex as xs:string ) as xs:string? { tokenize($arg,$regex)[1] } ;                     (functx:substring-before-match( 'abcd-abcd', 'x'))
declare namespace functx = "http://www.example.com/";                     (:~ : The substring before the first text that matches a regex : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-match.html : @param $arg the string to substring : @param $regex the regular expression :)          declare function functx:substring-before-match ( $arg as xs:string? , $regex as xs:string ) as xs:string? { tokenize($arg,$regex)[1] } ;                     (functx:substring-before-match( 'abc-def-ghi', '[dg]'))
declare namespace functx = "http://www.example.com/";                     (:~ : The substring before the first text that matches a regex : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-match.html : @param $arg the string to substring : @param $regex the regular expression :)          declare function functx:substring-before-match ( $arg as xs:string? , $regex as xs:string ) as xs:string? { tokenize($arg,$regex)[1] } ;                     (functx:substring-before-match( 'abc-def-ghi', '[dg]'), functx:substring-before-match( 'abcd-abcd', 'bc?'), functx:substring-before-match( 'abcd-abcd', 'x'))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of days in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-days-from-duration.html : @param $duration the duration :)          declare function functx:total-days-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('P1D') } ;                     (functx:total-days-from-duration( xs:dayTimeDuration('P1D')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of days in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-days-from-duration.html : @param $duration the duration :)          declare function functx:total-days-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('P1D') } ;                     (functx:total-days-from-duration( xs:dayTimeDuration('PT24H')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of days in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-days-from-duration.html : @param $duration the duration :)          declare function functx:total-days-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('P1D') } ;                     (functx:total-days-from-duration( xs:dayTimeDuration('PT24H')), functx:total-days-from-duration( xs:dayTimeDuration('P1D')), functx:total-days-from-duration( xs:dayTimeDuration('PT36H')), functx:total-days-from-duration( xs:dayTimeDuration('PT48H')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of days in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-days-from-duration.html : @param $duration the duration :)          declare function functx:total-days-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('P1D') } ;                     (functx:total-days-from-duration( xs:dayTimeDuration('PT36H')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of days in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-days-from-duration.html : @param $duration the duration :)          declare function functx:total-days-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('P1D') } ;                     (functx:total-days-from-duration( xs:dayTimeDuration('PT48H')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of hours in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-hours-from-duration.html : @param $duration the duration :)          declare function functx:total-hours-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1H') } ;                     (functx:total-hours-from-duration( xs:dayTimeDuration('P1D')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of hours in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-hours-from-duration.html : @param $duration the duration :)          declare function functx:total-hours-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1H') } ;                     (functx:total-hours-from-duration( xs:dayTimeDuration('P1DT2H')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of hours in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-hours-from-duration.html : @param $duration the duration :)          declare function functx:total-hours-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1H') } ;                     (functx:total-hours-from-duration( xs:dayTimeDuration('PT1H30M')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of hours in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-hours-from-duration.html : @param $duration the duration :)          declare function functx:total-hours-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1H') } ;                     (functx:total-hours-from-duration( xs:dayTimeDuration('PT26H')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of hours in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-hours-from-duration.html : @param $duration the duration :)          declare function functx:total-hours-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1H') } ;                     (functx:total-hours-from-duration( xs:dayTimeDuration('PT26H')), functx:total-hours-from-duration( xs:dayTimeDuration('PT1H30M')), functx:total-hours-from-duration( xs:dayTimeDuration('-PT3H')), functx:total-hours-from-duration( xs:dayTimeDuration('P1D')), functx:total-hours-from-duration( xs:dayTimeDuration('P1DT2H')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of hours in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-hours-from-duration.html : @param $duration the duration :)          declare function functx:total-hours-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1H') } ;                     (functx:total-hours-from-duration( xs:dayTimeDuration('-PT3H')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of minutes in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-minutes-from-duration.html : @param $duration the duration :)          declare function functx:total-minutes-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1M') } ;                     (functx:total-minutes-from-duration( xs:dayTimeDuration('PT1H90M')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of minutes in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-minutes-from-duration.html : @param $duration the duration :)          declare function functx:total-minutes-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1M') } ;                     (functx:total-minutes-from-duration( xs:dayTimeDuration('PT1M30S')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of minutes in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-minutes-from-duration.html : @param $duration the duration :)          declare function functx:total-minutes-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1M') } ;                     (functx:total-minutes-from-duration( xs:dayTimeDuration('PT3H')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of minutes in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-minutes-from-duration.html : @param $duration the duration :)          declare function functx:total-minutes-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1M') } ;                     (functx:total-minutes-from-duration( xs:dayTimeDuration('PT90M')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of minutes in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-minutes-from-duration.html : @param $duration the duration :)          declare function functx:total-minutes-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1M') } ;                     (functx:total-minutes-from-duration( xs:dayTimeDuration('PT90M')), functx:total-minutes-from-duration( xs:dayTimeDuration('PT1H90M')), functx:total-minutes-from-duration( xs:dayTimeDuration('PT3H')), functx:total-minutes-from-duration( xs:dayTimeDuration('PT1M30S')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of months in a yearMonthDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-months-from-duration.html : @param $duration the duration :)          declare function functx:total-months-from-duration ( $duration as xs:yearMonthDuration? ) as xs:decimal? { $duration div xs:yearMonthDuration('P1M') } ;                     (functx:total-months-from-duration( xs:yearMonthDuration('P18M')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of months in a yearMonthDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-months-from-duration.html : @param $duration the duration :)          declare function functx:total-months-from-duration ( $duration as xs:yearMonthDuration? ) as xs:decimal? { $duration div xs:yearMonthDuration('P1M') } ;                     (functx:total-months-from-duration( xs:yearMonthDuration('P18M')), functx:total-months-from-duration( xs:yearMonthDuration('P1Y')), functx:total-months-from-duration( xs:yearMonthDuration('P1Y6M')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of months in a yearMonthDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-months-from-duration.html : @param $duration the duration :)          declare function functx:total-months-from-duration ( $duration as xs:yearMonthDuration? ) as xs:decimal? { $duration div xs:yearMonthDuration('P1M') } ;                     (functx:total-months-from-duration( xs:yearMonthDuration('P1Y')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of months in a yearMonthDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-months-from-duration.html : @param $duration the duration :)          declare function functx:total-months-from-duration ( $duration as xs:yearMonthDuration? ) as xs:decimal? { $duration div xs:yearMonthDuration('P1M') } ;                     (functx:total-months-from-duration( xs:yearMonthDuration('P1Y6M')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of seconds in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-seconds-from-duration.html : @param $duration the duration :)          declare function functx:total-seconds-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1S') } ;                     (functx:total-seconds-from-duration( xs:dayTimeDuration('PT1M30S')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of seconds in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-seconds-from-duration.html : @param $duration the duration :)          declare function functx:total-seconds-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1S') } ;                     (functx:total-seconds-from-duration( xs:dayTimeDuration('PT3M')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of seconds in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-seconds-from-duration.html : @param $duration the duration :)          declare function functx:total-seconds-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1S') } ;                     (functx:total-seconds-from-duration( xs:dayTimeDuration('PT90.5S')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of seconds in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-seconds-from-duration.html : @param $duration the duration :)          declare function functx:total-seconds-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1S') } ;                     (functx:total-seconds-from-duration( xs:dayTimeDuration('PT90S')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of seconds in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-seconds-from-duration.html : @param $duration the duration :)          declare function functx:total-seconds-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1S') } ;                     (functx:total-seconds-from-duration( xs:dayTimeDuration('PT90S')), functx:total-seconds-from-duration( xs:dayTimeDuration('PT90.5S')), functx:total-seconds-from-duration( xs:dayTimeDuration('PT1M30S')), functx:total-seconds-from-duration( xs:dayTimeDuration('PT3M')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of years in a yearMonthDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-years-from-duration.html : @param $duration the duration :)          declare function functx:total-years-from-duration ( $duration as xs:yearMonthDuration? ) as xs:decimal? { $duration div xs:yearMonthDuration('P1Y') } ;                     (functx:total-years-from-duration( xs:yearMonthDuration('P18M')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of years in a yearMonthDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-years-from-duration.html : @param $duration the duration :)          declare function functx:total-years-from-duration ( $duration as xs:yearMonthDuration? ) as xs:decimal? { $duration div xs:yearMonthDuration('P1Y') } ;                     (functx:total-years-from-duration( xs:yearMonthDuration('P18M')), functx:total-years-from-duration( xs:yearMonthDuration('P1Y')), functx:total-years-from-duration( xs:yearMonthDuration('P1Y6M')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of years in a yearMonthDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-years-from-duration.html : @param $duration the duration :)          declare function functx:total-years-from-duration ( $duration as xs:yearMonthDuration? ) as xs:decimal? { $duration div xs:yearMonthDuration('P1Y') } ;                     (functx:total-years-from-duration( xs:yearMonthDuration('P1Y')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of years in a yearMonthDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-years-from-duration.html : @param $duration the duration :)          declare function functx:total-years-from-duration ( $duration as xs:yearMonthDuration? ) as xs:decimal? { $duration div xs:yearMonthDuration('P1Y') } ;                     (functx:total-years-from-duration( xs:yearMonthDuration('P1Y6M')))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML node in a sequence that appears first in document order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_first-node.html : @param $nodes the sequence of nodes :)          declare function functx:first-node ( $nodes as node()* ) as node()? { ($nodes/.)[1] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:first-node($in-xml//fName))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML node in a sequence that appears first in document order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_first-node.html : @param $nodes the sequence of nodes :)          declare function functx:first-node ( $nodes as node()* ) as node()? { ($nodes/.)[1] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:first-node($in-xml//fName), functx:first-node( ($in-xml//lName, $in-xml//fName) ))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML node in a sequence that appears first in document order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_first-node.html : @param $nodes the sequence of nodes :)          declare function functx:first-node ( $nodes as node()* ) as node()? { ($nodes/.)[1] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:first-node( ($in-xml//lName, $in-xml//fName) ))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML node in a sequence that is last in document order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_last-node.html : @param $nodes the sequence of nodes :)          declare function functx:last-node ( $nodes as node()* ) as node()? { ($nodes/.)[last()] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:last-node($in-xml//fName))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML node in a sequence that is last in document order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_last-node.html : @param $nodes the sequence of nodes :)          declare function functx:last-node ( $nodes as node()* ) as node()? { ($nodes/.)[last()] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:last-node($in-xml//fName), functx:last-node( ($in-xml//lName, $in-xml//fName) ))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML node in a sequence that is last in document order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_last-node.html : @param $nodes the sequence of nodes :)          declare function functx:last-node ( $nodes as node()* ) as node()? { ($nodes/.)[last()] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:last-node( ($in-xml//lName, $in-xml//fName) ))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML node kind (element, attribute, text, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_node-kind.html : @param $nodes the node(s) whose kind you want to determine :)          declare function functx:node-kind ( $nodes as node()* ) as xs:string* { for $node in $nodes return if ($node instance of element()) then 'element' else if ($node instance of attribute()) then 'attribute' else if ($node instance of text()) then 'text' else if ($node instance of document-node()) then 'document-node' else if ($node instance of comment()) then 'comment' else if ($node instance of processing-instruction()) then 'processing-instruction' else 'unknown' } ;          let $in-xml := <in-xml> <!-- this is in-xml --> <?test see?> <a z="2">xyz</a> </in-xml>           return (functx:node-kind(/))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML node kind (element, attribute, text, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_node-kind.html : @param $nodes the node(s) whose kind you want to determine :)          declare function functx:node-kind ( $nodes as node()* ) as xs:string* { for $node in $nodes return if ($node instance of element()) then 'element' else if ($node instance of attribute()) then 'attribute' else if ($node instance of text()) then 'text' else if ($node instance of document-node()) then 'document-node' else if ($node instance of comment()) then 'comment' else if ($node instance of processing-instruction()) then 'processing-instruction' else 'unknown' } ;                     let $in-xml := <in-xml> <!-- this is in-xml --> <?test see?> <a z="2">xyz</a> </in-xml> return (functx:node-kind($in-xml/a))
declare namespace functx = "http://www.example.com/";                                         (:~ : The XML node kind (element, attribute, text, etc.) :                          : @author Priscilla Walmsley, Datypic : @version 1.0                         : @see http://www.xqueryfunctions.com/xq/functx_node-kind.html                         : @param $nodes the node(s) whose kind you want to determine :)          declare function functx:node-kind ( $nodes as node()* ) as xs:string* {            for $node in $nodes return            if ($node instance of element()) then 'element'            else if ($node instance of attribute()) then 'attribute'            else if ($node instance of text()) then 'text'            else if ($node instance of document-node()) then 'document-node'            else if ($node instance of comment()) then 'comment'            else if ($node instance of processing-instruction()) then 'processing-instruction'            else 'unknown' } ;          let $in-xml := <in-xml> <!-- this is in-xml --> <?test see?> <a z="2">xyz</a> </in-xml>           return (functx:node-kind($in-xml/a),                      functx:node-kind($in-xml/a/@z),                      functx:node-kind($in-xml/comment()),                      functx:node-kind( $in-xml/processing-instruction()),                      functx:node-kind($in-xml/a/text()),                      functx:node-kind(/))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML node kind (element, attribute, text, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_node-kind.html : @param $nodes the node(s) whose kind you want to determine :)          declare function functx:node-kind ( $nodes as node()* ) as xs:string* { for $node in $nodes return if ($node instance of element()) then 'element' else if ($node instance of attribute()) then 'attribute' else if ($node instance of text()) then 'text' else if ($node instance of document-node()) then 'document-node' else if ($node instance of comment()) then 'comment' else if ($node instance of processing-instruction()) then 'processing-instruction' else 'unknown' } ;                     let $in-xml := <in-xml> <!-- this is in-xml --> <?test see?> <a z="2">xyz</a> </in-xml> return (functx:node-kind($in-xml/a/text()))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML node kind (element, attribute, text, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_node-kind.html : @param $nodes the node(s) whose kind you want to determine :)          declare function functx:node-kind ( $nodes as node()* ) as xs:string* { for $node in $nodes return if ($node instance of element()) then 'element' else if ($node instance of attribute()) then 'attribute' else if ($node instance of text()) then 'text' else if ($node instance of document-node()) then 'document-node' else if ($node instance of comment()) then 'comment' else if ($node instance of processing-instruction()) then 'processing-instruction' else 'unknown' } ;                     let $in-xml := <in-xml> <!-- this is in-xml --> <?test see?> <a z="2">xyz</a> </in-xml> return (functx:node-kind($in-xml/a/@z))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML node kind (element, attribute, text, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_node-kind.html : @param $nodes the node(s) whose kind you want to determine :)          declare function functx:node-kind ( $nodes as node()* ) as xs:string* { for $node in $nodes return if ($node instance of element()) then 'element' else if ($node instance of attribute()) then 'attribute' else if ($node instance of text()) then 'text' else if ($node instance of document-node()) then 'document-node' else if ($node instance of comment()) then 'comment' else if ($node instance of processing-instruction()) then 'processing-instruction' else 'unknown' } ;                     let $in-xml := <in-xml> <!-- this is in-xml --> <?test see?> <a z="2">xyz</a> </in-xml> return (functx:node-kind($in-xml/comment()))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML node kind (element, attribute, text, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_node-kind.html : @param $nodes the node(s) whose kind you want to determine :)          declare function functx:node-kind ( $nodes as node()* ) as xs:string* { for $node in $nodes return if ($node instance of element()) then 'element' else if ($node instance of attribute()) then 'attribute' else if ($node instance of text()) then 'text' else if ($node instance of document-node()) then 'document-node' else if ($node instance of comment()) then 'comment' else if ($node instance of processing-instruction()) then 'processing-instruction' else 'unknown' } ;                     let $in-xml := <in-xml> <!-- this is in-xml --> <?test see?> <a z="2">xyz</a> </in-xml> return (functx:node-kind( $in-xml/processing-instruction()))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML nodes with distinct values, taking into account attributes and descendants : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_distinct-deep.html : @param $nodes the sequence of nodes to test :)          declare function functx:distinct-deep ( $nodes as node()* ) as node()* { for $seq in (1 to count($nodes)) return $nodes[$seq][not(functx:is-node-in-sequence-deep-equal( .,$nodes[position() < $seq]))] } ;                     (:~ : Whether an XML node is in a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>Kate</fName> <lName>Doe</lName> </author> </authors> return (functx:distinct-deep($in-xml//author))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML nodes with distinct values, taking into account attributes and descendants : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_distinct-deep.html : @param $nodes the sequence of nodes to test :)          declare function functx:distinct-deep ( $nodes as node()* ) as node()* { for $seq in (1 to count($nodes)) return $nodes[$seq][not(functx:is-node-in-sequence-deep-equal( .,$nodes[position() < $seq]))] } ;                     (:~ : Whether an XML node is in a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>Kate</fName> <lName>Doe</lName> </author> </authors> return (functx:distinct-deep($in-xml//author), functx:distinct-deep($in-xml//lName), functx:distinct-deep($in-xml//fName))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML nodes with distinct values, taking into account attributes and descendants : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_distinct-deep.html : @param $nodes the sequence of nodes to test :)          declare function functx:distinct-deep ( $nodes as node()* ) as node()* { for $seq in (1 to count($nodes)) return $nodes[$seq][not(functx:is-node-in-sequence-deep-equal( .,$nodes[position() < $seq]))] } ;                     (:~ : Whether an XML node is in a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>Kate</fName> <lName>Doe</lName> </author> </authors> return (functx:distinct-deep($in-xml//fName))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML nodes with distinct values, taking into account attributes and descendants : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_distinct-deep.html : @param $nodes the sequence of nodes to test :)          declare function functx:distinct-deep ( $nodes as node()* ) as node()* { for $seq in (1 to count($nodes)) return $nodes[$seq][not(functx:is-node-in-sequence-deep-equal( .,$nodes[position() < $seq]))] } ;                     (:~ : Whether an XML node is in a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>Kate</fName> <lName>Doe</lName> </author> </authors> return (functx:distinct-deep($in-xml//lName))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML node whose typed value is the maximum : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-node.html : @param $nodes the sequence of nodes to test :)          declare function functx:max-node ( $nodes as node()* ) as node()* { $nodes[. = max($nodes)] } ;                     let $in-xml := <values> <int>1</int> <int>23</int> <int>115</int> </values> return (functx:max-node($in-xml//int))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML node whose typed value is the minimum : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_min-node.html : @param $nodes the sequence of nodes to test :)          declare function functx:min-node ( $nodes as node()* ) as node()* { $nodes[. = min($nodes)] } ;                     let $in-xml := <values> <int>1</int> <int>23</int> <int>115</int> </values> return (functx:min-node($in-xml//int))
declare namespace functx = "http://www.example.com/";                     (:~ : Updates the attribute value of an XML element : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_update-attributes.html : @param $elements the element(s) for which you wish to update the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return if ($element/@*[node-name(.) = $attrName]) then attribute {$attrName} {$attrValues[$seq]} else (), $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml xmlns:new='http://new'> <a att1='def'>x</a> <b>x</b> <c new:att1='def'>x</c> </in-xml> return (functx:update-attributes( $in-xml/a, xs:QName('att1'), 123))
declare namespace functx = "http://www.example.com/";                     (:~ : Updates the attribute value of an XML element : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_update-attributes.html : @param $elements the element(s) for which you wish to update the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return if ($element/@*[node-name(.) = $attrName]) then attribute {$attrName} {$attrValues[$seq]} else (), $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml xmlns:new='http://new'> <a att1='def'>x</a> <b>x</b> <c new:att1='def'>x</c> </in-xml> return (functx:update-attributes( $in-xml/a, xs:QName('att1'), 123), functx:update-attributes( $in-xml/a, (xs:QName('att1'),xs:QName('att2')), (1,2)), functx:update-attributes( $in-xml/b, xs:QName('att1'), 123), functx:update-attributes( $in-xml/c, QName('http://new','prefix:att1'), 123))
declare namespace functx = "http://www.example.com/";                     (:~ : Updates the attribute value of an XML element : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_update-attributes.html : @param $elements the element(s) for which you wish to update the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return if ($element/@*[node-name(.) = $attrName]) then attribute {$attrName} {$attrValues[$seq]} else (), $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml xmlns:new='http://new'> <a att1='def'>x</a> <b>x</b> <c new:att1='def'>x</c> </in-xml> return (functx:update-attributes( $in-xml/a, (xs:QName('att1'),xs:QName('att2')), (1,2)))
declare namespace functx = "http://www.example.com/";                     (:~ : Updates the attribute value of an XML element : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_update-attributes.html : @param $elements the element(s) for which you wish to update the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return if ($element/@*[node-name(.) = $attrName]) then attribute {$attrName} {$attrValues[$seq]} else (), $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml xmlns:new='http://new'> <a att1='def'>x</a> <b>x</b> <c new:att1='def'>x</c> </in-xml> return (functx:update-attributes( $in-xml/b, xs:QName('att1'), 123))
declare namespace functx = "http://www.example.com/";                     (:~ : Updates the attribute value of an XML element : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_update-attributes.html : @param $elements the element(s) for which you wish to update the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return if ($element/@*[node-name(.) = $attrName]) then attribute {$attrName} {$attrValues[$seq]} else (), $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml xmlns:new='http://new'> <a att1='def'>x</a> <b>x</b> <c new:att1='def'>x</c> </in-xml> return (functx:update-attributes( $in-xml/c, QName('http://new','prefix:att1'), 123))
declare namespace functx = "http://www.example.com/";                     (:~ : Updates the content of one or more elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-element-values.html : @param $elements the elements whose content you wish to replace : @param $values the replacement values :)          declare function functx:replace-element-values ( $elements as element()* , $values as xs:anyAtomicType* ) as element()* { for $element at $seq in $elements return element { node-name($element)} { $element/@*, $values[$seq] } } ;                     let $in-xml := <in-xml> <price num="1">12</price> <price num="2">20</price> <price num="3">5</price> </in-xml> return (for $p in $in-xml/price return functx:replace-element-values( $p,concat($p,'.0')))
declare namespace functx = "http://www.example.com/";                     (:~ : Updates the content of one or more elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-element-values.html : @param $elements the elements whose content you wish to replace : @param $values the replacement values :)          declare function functx:replace-element-values ( $elements as element()* , $values as xs:anyAtomicType* ) as element()* { for $element at $seq in $elements return element { node-name($element)} { $element/@*, $values[$seq] } } ;                     let $in-xml := <in-xml> <price num="1">12</price> <price num="2">20</price> <price num="3">5</price> </in-xml> return (functx:replace-element-values( $in-xml/price, for $p in $in-xml/price return $p * 2))
declare namespace functx = "http://www.example.com/";                     (:~ : Updates the content of one or more elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-element-values.html : @param $elements the elements whose content you wish to replace : @param $values the replacement values :)          declare function functx:replace-element-values ( $elements as element()* , $values as xs:anyAtomicType* ) as element()* { for $element at $seq in $elements return element { node-name($element)} { $element/@*, $values[$seq] } } ;                     let $in-xml := <in-xml> <price num="1">12</price> <price num="2">20</price> <price num="3">5</price> </in-xml> return (functx:replace-element-values( $in-xml/price, for $p in $in-xml/price return $p * 2), for $p in $in-xml/price return functx:replace-element-values( $p,concat($p,'.0')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a date falls in a leap year : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-leap-year.html : @param $date the date or year :)          declare function functx:is-leap-year ( $date as xs:anyAtomicType? ) as xs:boolean { for $year in xs:integer(substring(string($date),1,4)) return ($year mod 4 = 0 and $year mod 100 != 0) or $year mod 400 = 0 } ;                     (functx:is-leap-year(2004))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a date falls in a leap year : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-leap-year.html : @param $date the date or year :)          declare function functx:is-leap-year ( $date as xs:anyAtomicType? ) as xs:boolean { for $year in xs:integer(substring(string($date),1,4)) return ($year mod 4 = 0 and $year mod 100 != 0) or $year mod 400 = 0 } ;                     (functx:is-leap-year('2005-02-15'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a date falls in a leap year : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-leap-year.html : @param $date the date or year :)          declare function functx:is-leap-year ( $date as xs:anyAtomicType? ) as xs:boolean { for $year in xs:integer(substring(string($date),1,4)) return ($year mod 4 = 0 and $year mod 100 != 0) or $year mod 400 = 0 } ;                     (functx:is-leap-year(xs:date('2004-01-23')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a date falls in a leap year : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-leap-year.html : @param $date the date or year :)          declare function functx:is-leap-year ( $date as xs:anyAtomicType? ) as xs:boolean { for $year in xs:integer(substring(string($date),1,4)) return ($year mod 4 = 0 and $year mod 100 != 0) or $year mod 400 = 0 } ;                     (functx:is-leap-year(xs:date('2004-01-23')), functx:is-leap-year(2004), functx:is-leap-year('2005-02-15'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml := <pre:a xmlns:pre="http://ns.example.com/ns1">abc</pre:a> return (functx:name-test(name($in-xml),('*')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml := <pre:a xmlns:pre="http://ns.example.com/ns1">abc</pre:a> return (functx:name-test(name($in-xml),('*:a')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml := <pre:a xmlns:pre="http://ns.example.com/ns1">abc</pre:a> return (functx:name-test( name($in-xml),('a','b','c')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml := <pre:a xmlns:pre="http://ns/example.com/ns1">abc</pre:a> return (functx:name-test(name($in-xml),('*')), functx:name-test(name($in-xml),('pre:*')), functx:name-test(name($in-xml),('*:a')), functx:name-test( name($in-xml),('pre:a','pre:b')), functx:name-test( name($in-xml),('a','b','c')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml := <pre:a xmlns:pre="http://ns.example.com/ns1">abc</pre:a> return (functx:name-test(name($in-xml),('pre:*')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml := <pre:a xmlns:pre="http://ns.example.com/ns1">abc</pre:a> return (functx:name-test( name($in-xml),('pre:a','pre:b')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML element, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes.html : @param $elements the element(s) from which to remove the attributes : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes ( $elements as element()* , $names as xs:string* ) as element() { for $element in $elements return element {node-name($element)} {$element/@*[not(functx:name-test(name(),$names))], $element/node() } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456">abc</a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456">abc</a> return (functx:remove-attributes($in-xml-1, '*'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML element, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes.html : @param $elements the element(s) from which to remove the attributes : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes ( $elements as element()* , $names as xs:string* ) as element() { for $element in $elements return element {node-name($element)} {$element/@*[not(functx:name-test(name(),$names))], $element/node() } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456">abc</a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456">abc</a> return (functx:remove-attributes( $in-xml-1, ('attr1','attr2')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML element, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes.html : @param $elements the element(s) from which to remove the attributes : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes ( $elements as element()* , $names as xs:string* ) as element() { for $element in $elements return element {node-name($element)} {$element/@*[not(functx:name-test(name(),$names))], $element/node() } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456">abc</a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456">abc</a> return (functx:remove-attributes( $in-xml-1, ('attr1','attr2')), functx:remove-attributes( $in-xml-1, ('attr1','attr3')), functx:remove-attributes($in-xml-1, '*'), functx:remove-attributes( $in-xml-2, ('a:attr1')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML element, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes.html : @param $elements the element(s) from which to remove the attributes : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes ( $elements as element()* , $names as xs:string* ) as element() { for $element in $elements return element {node-name($element)} {$element/@*[not(functx:name-test(name(),$names))], $element/node() } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456">abc</a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456">abc</a> return (functx:remove-attributes( $in-xml-1, ('attr1','attr3')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML element, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes.html : @param $elements the element(s) from which to remove the attributes : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes ( $elements as element()* , $names as xs:string* ) as element() { for $element in $elements return element {node-name($element)} {$element/@*[not(functx:name-test(name(),$names))], $element/node() } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456">abc</a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456">abc</a> return (functx:remove-attributes( $in-xml-2, ('a:attr1')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML fragment, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes-deep.html : @param $nodes the root(s) to start from : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then element { node-name($node)} { $node/@*[not(functx:name-test(name(),$names))], functx:remove-attributes-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-attributes-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456"> <b attr1="xzy">abc</b> </a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456"> <b a:attr1="ghi" attr1="xzy">abc</b> </a> return (functx:remove-attributes-deep( $in-xml-1, ('attr1','attr2')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML fragment, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes-deep.html : @param $nodes the root(s) to start from : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then element { node-name($node)} { $node/@*[not(functx:name-test(name(),$names))], functx:remove-attributes-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-attributes-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456"> <b attr1="xzy">abc</b> </a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456"> <b a:attr1="ghi" attr1="xzy">abc</b> </a> return (functx:remove-attributes-deep( $in-xml-1, ('attr1','attr2')), functx:remove-attributes-deep( $in-xml-1, ('attr1','attr3')), functx:remove-attributes-deep( $in-xml-2, 'a:attr1'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML fragment, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes-deep.html : @param $nodes the root(s) to start from : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then element { node-name($node)} { $node/@*[not(functx:name-test(name(),$names))], functx:remove-attributes-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-attributes-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456"> <b attr1="xzy">abc</b> </a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456"> <b a:attr1="ghi" attr1="xzy">abc</b> </a> return (functx:remove-attributes-deep( $in-xml-1, ('attr1','attr3')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML fragment, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes-deep.html : @param $nodes the root(s) to start from : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then element { node-name($node)} { $node/@*[not(functx:name-test(name(),$names))], functx:remove-attributes-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-attributes-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456"> <b attr1="xzy">abc</b> </a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456"> <b a:attr1="ghi" attr1="xzy">abc</b> </a> return (functx:remove-attributes-deep( $in-xml-2, 'a:attr1'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes child elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements.html : @param $elements the element(s) from which you wish to remove the children : @param $names the names of the child elements to remove :)          declare function functx:remove-elements ( $elements as element()* , $names as xs:string* ) as element()* { for $element in $elements return element {node-name($element)} {$element/@*, $element/node()[not(functx:name-test(name(),$names))] } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a>123</a> <a>456</a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a>123</a> <x:a>456</x:a> <c>Mixed <x:a>content</x:a></c> </in-xml> return (functx:remove-elements( $in-xml-1, ('a','b')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes child elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements.html : @param $elements the element(s) from which you wish to remove the children : @param $names the names of the child elements to remove :)          declare function functx:remove-elements ( $elements as element()* , $names as xs:string* ) as element()* { for $element in $elements return element {node-name($element)} {$element/@*, $element/node()[not(functx:name-test(name(),$names))] } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a>123</a> <a>456</a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a>123</a> <x:a>456</x:a> <c>Mixed <x:a>content</x:a></c> </in-xml> return (functx:remove-elements( $in-xml-1, 'c'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes child elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements.html : @param $elements the element(s) from which you wish to remove the children : @param $names the names of the child elements to remove :)          declare function functx:remove-elements ( $elements as element()* , $names as xs:string* ) as element()* { for $element in $elements return element {node-name($element)} {$element/@*, $element/node()[not(functx:name-test(name(),$names))] } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a>123</a> <a>456</a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a>123</a> <x:a>456</x:a> <c>Mixed <x:a>content</x:a></c> </in-xml> return (functx:remove-elements( $in-xml-1, 'c'), functx:remove-elements( $in-xml-1, ('a','b')), functx:remove-elements( $in-xml-2, 'x:a'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes child elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements.html : @param $elements the element(s) from which you wish to remove the children : @param $names the names of the child elements to remove :)          declare function functx:remove-elements ( $elements as element()* , $names as xs:string* ) as element()* { for $element in $elements return element {node-name($element)} {$element/@*, $element/node()[not(functx:name-test(name(),$names))] } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a>123</a> <a>456</a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a>123</a> <x:a>456</x:a> <c>Mixed <x:a>content</x:a></c> </in-xml> return (functx:remove-elements( $in-xml-2, 'x:a'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-deep.html : @param $nodes root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then () else element { node-name($node)} { $node/@*, functx:remove-elements-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-elements-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <x:b>b1</x:b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return (functx:remove-elements-deep( $in-xml-1, 'a'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-deep.html : @param $nodes root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then () else element { node-name($node)} { $node/@*, functx:remove-elements-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-elements-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <x:b>b1</x:b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return (functx:remove-elements-deep( $in-xml-1, 'b'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-deep.html : @param $nodes root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then () else element { node-name($node)} { $node/@*, functx:remove-elements-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-elements-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <x:b>b1</x:b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return (functx:remove-elements-deep( $in-xml-1, ('b','c')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-deep.html : @param $nodes root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then () else element { node-name($node)} { $node/@*, functx:remove-elements-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-elements-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <x:b>b1</x:b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return (functx:remove-elements-deep( $in-xml-1, 'b'), functx:remove-elements-deep( $in-xml-1, 'a'), functx:remove-elements-deep( $in-xml-1, ('b','c')), functx:remove-elements-deep( $in-xml-2, 'x:b'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-deep.html : @param $nodes root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then () else element { node-name($node)} { $node/@*, functx:remove-elements-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-elements-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <x:b>b1</x:b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return (functx:remove-elements-deep( $in-xml-2, 'x:b'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant XML elements but keeps their content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-not-contents.html : @param $nodes the root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-not-contents ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then functx:remove-elements-not-contents($node/node(), $names) else element {node-name($node)} {$node/@*, functx:remove-elements-not-contents($node/node(),$names)} else if ($node instance of document-node()) then functx:remove-elements-not-contents($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <x:b>content</x:b></c> </in-xml> return (functx:remove-elements-not-contents( $in-xml-1, 'a'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant XML elements but keeps their content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-not-contents.html : @param $nodes the root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-not-contents ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then functx:remove-elements-not-contents($node/node(), $names) else element {node-name($node)} {$node/@*, functx:remove-elements-not-contents($node/node(),$names)} else if ($node instance of document-node()) then functx:remove-elements-not-contents($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <x:b>content</x:b></c> </in-xml> return (functx:remove-elements-not-contents( $in-xml-1, 'b'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant XML elements but keeps their content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-not-contents.html : @param $nodes the root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-not-contents ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then functx:remove-elements-not-contents($node/node(), $names) else element {node-name($node)} {$node/@*, functx:remove-elements-not-contents($node/node(),$names)} else if ($node instance of document-node()) then functx:remove-elements-not-contents($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <x:b>content</x:b></c> </in-xml> return (functx:remove-elements-not-contents( $in-xml-1, ('b','c')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant XML elements but keeps their content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-not-contents.html : @param $nodes the root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-not-contents ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then functx:remove-elements-not-contents($node/node(), $names) else element {node-name($node)} {$node/@*, functx:remove-elements-not-contents($node/node(),$names)} else if ($node instance of document-node()) then functx:remove-elements-not-contents($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <x:b>content</x:b></c> </in-xml> return (functx:remove-elements-not-contents( $in-xml-1, 'b'), functx:remove-elements-not-contents( $in-xml-1, ('b','c')), functx:remove-elements-not-contents( $in-xml-1, 'a'), functx:remove-elements-not-contents( $in-xml-2, 'x:b'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant XML elements but keeps their content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-not-contents.html : @param $nodes the root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-not-contents ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then functx:remove-elements-not-contents($node/node(), $names) else element {node-name($node)} {$node/@*, functx:remove-elements-not-contents($node/node(),$names)} else if ($node instance of document-node()) then functx:remove-elements-not-contents($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <x:b>content</x:b></c> </in-xml> return (functx:remove-elements-not-contents( $in-xml-2, 'x:b'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an atomic value appears in a sequence : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-value-in-sequence.html : @param $value the atomic value to test : @param $seq the sequence of values to search :)          declare function functx:is-value-in-sequence ( $value as xs:anyAtomicType? , $seq as xs:anyAtomicType* ) as xs:boolean { $value = $seq } ;                     (functx:is-value-in-sequence(1.0,(1,2,3)))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an atomic value appears in a sequence : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-value-in-sequence.html : @param $value the atomic value to test : @param $seq the sequence of values to search :)          declare function functx:is-value-in-sequence ( $value as xs:anyAtomicType? , $seq as xs:anyAtomicType* ) as xs:boolean { $value = $seq } ;                     (functx:is-value-in-sequence(1,(1,2,3)))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an atomic value appears in a sequence : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-value-in-sequence.html : @param $value the atomic value to test : @param $seq the sequence of values to search :)          declare function functx:is-value-in-sequence ( $value as xs:anyAtomicType? , $seq as xs:anyAtomicType* ) as xs:boolean { $value = $seq } ;                     (functx:is-value-in-sequence(1,(1,2,3)), functx:is-value-in-sequence(5,(1,2,3)), functx:is-value-in-sequence(1.0,(1,2,3)))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an atomic value appears in a sequence : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-value-in-sequence.html : @param $value the atomic value to test : @param $seq the sequence of values to search :)          declare function functx:is-value-in-sequence ( $value as xs:anyAtomicType? , $seq as xs:anyAtomicType* ) as xs:boolean { $value = $seq } ;                     (functx:is-value-in-sequence(5,(1,2,3)))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has element-only content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-element-only-content.html : @param $element the XML element to test :)          declare function functx:has-element-only-content ( $element as element() ) as xs:boolean { not($element/text()[normalize-space(.) != '']) and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> <h><x>xml</x><y>xml</y></h> <i> <x>xml</x> <y>xml</y> </i> </in-xml> return (functx:has-element-only-content($in-xml/a))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has element-only content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-element-only-content.html : @param $element the XML element to test :)          declare function functx:has-element-only-content ( $element as element() ) as xs:boolean { not($element/text()[normalize-space(.) != '']) and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> <h><x>xml</x><y>xml</y></h> <i> <x>xml</x> <y>xml</y> </i> </in-xml> return (functx:has-element-only-content($in-xml/a), functx:has-element-only-content($in-xml/b), functx:has-element-only-content($in-xml/c), functx:has-element-only-content($in-xml/d), functx:has-element-only-content($in-xml/e), functx:has-element-only-content($in-xml/f), functx:has-element-only-content($in-xml/g), functx:has-element-only-content($in-xml/h), functx:has-element-only-content($in-xml/i))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has element-only content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-element-only-content.html : @param $element the XML element to test :)          declare function functx:has-element-only-content ( $element as element() ) as xs:boolean { not($element/text()[normalize-space(.) != '']) and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> <h><x>xml</x><y>xml</y></h> <i> <x>xml</x> <y>xml</y> </i> </in-xml> return (functx:has-element-only-content($in-xml/b))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has element-only content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-element-only-content.html : @param $element the XML element to test :)          declare function functx:has-element-only-content ( $element as element() ) as xs:boolean { not($element/text()[normalize-space(.) != '']) and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> <h><x>xml</x><y>xml</y></h> <i> <x>xml</x> <y>xml</y> </i> </in-xml> return (functx:has-element-only-content($in-xml/c))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has element-only content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-element-only-content.html : @param $element the XML element to test :)          declare function functx:has-element-only-content ( $element as element() ) as xs:boolean { not($element/text()[normalize-space(.) != '']) and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> <h><x>xml</x><y>xml</y></h> <i> <x>xml</x> <y>xml</y> </i> </in-xml> return (functx:has-element-only-content($in-xml/d))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has element-only content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-element-only-content.html : @param $element the XML element to test :)          declare function functx:has-element-only-content ( $element as element() ) as xs:boolean { not($element/text()[normalize-space(.) != '']) and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> <h><x>xml</x><y>xml</y></h> <i> <x>xml</x> <y>xml</y> </i> </in-xml> return (functx:has-element-only-content($in-xml/e))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has element-only content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-element-only-content.html : @param $element the XML element to test :)          declare function functx:has-element-only-content ( $element as element() ) as xs:boolean { not($element/text()[normalize-space(.) != '']) and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> <h><x>xml</x><y>xml</y></h> <i> <x>xml</x> <y>xml</y> </i> </in-xml> return (functx:has-element-only-content($in-xml/f))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has element-only content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-element-only-content.html : @param $element the XML element to test :)          declare function functx:has-element-only-content ( $element as element() ) as xs:boolean { not($element/text()[normalize-space(.) != '']) and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> <h><x>xml</x><y>xml</y></h> <i> <x>xml</x> <y>xml</y> </i> </in-xml> return (functx:has-element-only-content($in-xml/g))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has element-only content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-element-only-content.html : @param $element the XML element to test :)          declare function functx:has-element-only-content ( $element as element() ) as xs:boolean { not($element/text()[normalize-space(.) != '']) and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> <h><x>xml</x><y>xml</y></h> <i> <x>xml</x> <y>xml</y> </i> </in-xml> return (functx:has-element-only-content($in-xml/h))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has element-only content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-element-only-content.html : @param $element the XML element to test :)          declare function functx:has-element-only-content ( $element as element() ) as xs:boolean { not($element/text()[normalize-space(.) != '']) and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> <h><x>xml</x><y>xml</y></h> <i> <x>xml</x> <y>xml</y> </i> </in-xml> return (functx:has-element-only-content($in-xml/i))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has empty content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-empty-content.html : @param $element the XML element to test :)          declare function functx:has-empty-content ( $element as element() ) as xs:boolean { not($element/node()) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-empty-content($in-xml/a))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has empty content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-empty-content.html : @param $element the XML element to test :)          declare function functx:has-empty-content ( $element as element() ) as xs:boolean { not($element/node()) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-empty-content($in-xml/a), functx:has-empty-content($in-xml/b), functx:has-empty-content($in-xml/c), functx:has-empty-content($in-xml/d), functx:has-empty-content($in-xml/e), functx:has-empty-content($in-xml/f), functx:has-empty-content($in-xml/g))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has empty content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-empty-content.html : @param $element the XML element to test :)          declare function functx:has-empty-content ( $element as element() ) as xs:boolean { not($element/node()) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-empty-content($in-xml/b))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has empty content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-empty-content.html : @param $element the XML element to test :)          declare function functx:has-empty-content ( $element as element() ) as xs:boolean { not($element/node()) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-empty-content($in-xml/c))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has empty content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-empty-content.html : @param $element the XML element to test :)          declare function functx:has-empty-content ( $element as element() ) as xs:boolean { not($element/node()) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-empty-content($in-xml/d))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has empty content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-empty-content.html : @param $element the XML element to test :)          declare function functx:has-empty-content ( $element as element() ) as xs:boolean { not($element/node()) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-empty-content($in-xml/e))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has empty content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-empty-content.html : @param $element the XML element to test :)          declare function functx:has-empty-content ( $element as element() ) as xs:boolean { not($element/node()) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-empty-content($in-xml/f))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has empty content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-empty-content.html : @param $element the XML element to test :)          declare function functx:has-empty-content ( $element as element() ) as xs:boolean { not($element/node()) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-empty-content($in-xml/g))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has mixed content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-mixed-content.html : @param $element the XML element to test :)          declare function functx:has-mixed-content ( $element as element() ) as xs:boolean { $element/text()[normalize-space(.) != ''] and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-mixed-content($in-xml/a))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has mixed content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-mixed-content.html : @param $element the XML element to test :)          declare function functx:has-mixed-content ( $element as element() ) as xs:boolean { $element/text()[normalize-space(.) != ''] and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-mixed-content($in-xml/a), functx:has-mixed-content($in-xml/b), functx:has-mixed-content($in-xml/c), functx:has-mixed-content($in-xml/d), functx:has-mixed-content($in-xml/e), functx:has-mixed-content($in-xml/f), functx:has-mixed-content($in-xml/g))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has mixed content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-mixed-content.html : @param $element the XML element to test :)          declare function functx:has-mixed-content ( $element as element() ) as xs:boolean { $element/text()[normalize-space(.) != ''] and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-mixed-content($in-xml/b))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has mixed content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-mixed-content.html : @param $element the XML element to test :)          declare function functx:has-mixed-content ( $element as element() ) as xs:boolean { $element/text()[normalize-space(.) != ''] and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-mixed-content($in-xml/c))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has mixed content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-mixed-content.html : @param $element the XML element to test :)          declare function functx:has-mixed-content ( $element as element() ) as xs:boolean { $element/text()[normalize-space(.) != ''] and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-mixed-content($in-xml/d))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has mixed content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-mixed-content.html : @param $element the XML element to test :)          declare function functx:has-mixed-content ( $element as element() ) as xs:boolean { $element/text()[normalize-space(.) != ''] and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-mixed-content($in-xml/e))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has mixed content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-mixed-content.html : @param $element the XML element to test :)          declare function functx:has-mixed-content ( $element as element() ) as xs:boolean { $element/text()[normalize-space(.) != ''] and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-mixed-content($in-xml/f))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has mixed content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-mixed-content.html : @param $element the XML element to test :)          declare function functx:has-mixed-content ( $element as element() ) as xs:boolean { $element/text()[normalize-space(.) != ''] and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-mixed-content($in-xml/g))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has simple content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-simple-content.html : @param $element the XML element to test :)          declare function functx:has-simple-content ( $element as element() ) as xs:boolean { $element/text() and not($element/*) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> </in-xml> return (functx:has-simple-content($in-xml/a))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has simple content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-simple-content.html : @param $element the XML element to test :)          declare function functx:has-simple-content ( $element as element() ) as xs:boolean { $element/text() and not($element/*) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> </in-xml> return (functx:has-simple-content($in-xml/a), functx:has-simple-content($in-xml/b), functx:has-simple-content($in-xml/c), functx:has-simple-content($in-xml/d), functx:has-simple-content($in-xml/e), functx:has-simple-content($in-xml/f))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has simple content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-simple-content.html : @param $element the XML element to test :)          declare function functx:has-simple-content ( $element as element() ) as xs:boolean { $element/text() and not($element/*) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> </in-xml> return (functx:has-simple-content($in-xml/b))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has simple content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-simple-content.html : @param $element the XML element to test :)          declare function functx:has-simple-content ( $element as element() ) as xs:boolean { $element/text() and not($element/*) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> </in-xml> return (functx:has-simple-content($in-xml/c))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has simple content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-simple-content.html : @param $element the XML element to test :)          declare function functx:has-simple-content ( $element as element() ) as xs:boolean { $element/text() and not($element/*) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> </in-xml> return (functx:has-simple-content($in-xml/d))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has simple content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-simple-content.html : @param $element the XML element to test :)          declare function functx:has-simple-content ( $element as element() ) as xs:boolean { $element/text() and not($element/*) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> </in-xml> return (functx:has-simple-content($in-xml/e))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has simple content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-simple-content.html : @param $element the XML element to test :)          declare function functx:has-simple-content ( $element as element() ) as xs:boolean { $element/text() and not($element/*) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> </in-xml> return (functx:has-simple-content($in-xml/f))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node follows another without being its descendant : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_follows-not-descendant.html : @param $a the first node : @param $b the second node :)          declare function functx:follows-not-descendant ( $a as node()? , $b as node()? ) as xs:boolean { $a >> $b and empty($b intersect $a/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:follows-not-descendant( $in-xml//author[1],$in-xml//author[2]))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node follows another without being its descendant : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_follows-not-descendant.html : @param $a the first node : @param $b the second node :)          declare function functx:follows-not-descendant ( $a as node()? , $b as node()? ) as xs:boolean { $a >> $b and empty($b intersect $a/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:follows-not-descendant( $in-xml//author[1]/fName, $in-xml//author[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node follows another without being its descendant : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_follows-not-descendant.html : @param $a the first node : @param $b the second node :)          declare function functx:follows-not-descendant ( $a as node()? , $b as node()? ) as xs:boolean { $a >> $b and empty($b intersect $a/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:follows-not-descendant( $in-xml//author[2],$in-xml//author[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node follows another without being its descendant : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_follows-not-descendant.html : @param $a the first node : @param $b the second node :)          declare function functx:follows-not-descendant ( $a as node()? , $b as node()? ) as xs:boolean { $a >> $b and empty($b intersect $a/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:follows-not-descendant( $in-xml//author[2],$in-xml//author[1]), functx:follows-not-descendant( $in-xml//author[1]/fName, $in-xml//author[1]), functx:follows-not-descendant( $in-xml//author[1],$in-xml//author[2]))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is a descendant of another node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-descendant.html : @param $node1 the first node : @param $node2 the second node :)          declare function functx:is-descendant ( $node1 as node() , $node2 as node() ) as xs:boolean { boolean($node2 intersect $node1/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:is-descendant( $in-xml//author[1], $in-xml//author[1]/fName))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is a descendant of another node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-descendant.html : @param $node1 the first node : @param $node2 the second node :)          declare function functx:is-descendant ( $node1 as node() , $node2 as node() ) as xs:boolean { boolean($node2 intersect $node1/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:is-descendant( $in-xml//author[1], $in-xml//author[2]))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is a descendant of another node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-descendant.html : @param $node1 the first node : @param $node2 the second node :)          declare function functx:is-descendant ( $node1 as node() , $node2 as node() ) as xs:boolean { boolean($node2 intersect $node1/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:is-descendant( $in-xml//author[1]/fName, $in-xml//author[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is a descendant of another node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-descendant.html : @param $node1 the first node : @param $node2 the second node :)          declare function functx:is-descendant ( $node1 as node() , $node2 as node() ) as xs:boolean { boolean($node2 intersect $node1/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:is-descendant( $in-xml//author[1]/fName, $in-xml//author[1]), functx:is-descendant( $in-xml//author[1], $in-xml//author[1]/fName), functx:is-descendant( $in-xml//author[1]/fName/text(), $in-xml//author[1]/fName), functx:is-descendant( $in-xml//author[1], $in-xml//author[2]))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is a descendant of another node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-descendant.html : @param $node1 the first node : @param $node2 the second node :)          declare function functx:is-descendant ( $node1 as node() , $node2 as node() ) as xs:boolean { boolean($node2 intersect $node1/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:is-descendant( $in-xml//author[1]/fName/text(), $in-xml//author[1]/fName))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is among the descendants of a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-among-descendants-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-among-descendants-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq/descendant-or-self::*/(.|@*) satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>John</fName> <lName>Doe</lName> </author> return let $anotherAuthor := <author> <lName>Doe</lName> <fName>John</fName> </author> return (functx:is-node-among-descendants-deep-equal( $anAuthor,$in-xml))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is among the descendants of a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-among-descendants-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-among-descendants-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq/descendant-or-self::*/(.|@*) satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>John</fName> <lName>Doe</lName> </author> return let $anotherAuthor := <author> <lName>Doe</lName> <fName>John</fName> </author> return (functx:is-node-among-descendants-deep-equal( $anAuthor,$in-xml/author))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is among the descendants of a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-among-descendants-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-among-descendants-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq/descendant-or-self::*/(.|@*) satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>John</fName> <lName>Doe</lName> </author> return let $anotherAuthor := <author> <lName>Doe</lName> <fName>John</fName> </author> return (functx:is-node-among-descendants-deep-equal( $anotherAuthor,$in-xml))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is among the descendants of a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-among-descendants-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-among-descendants-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq/descendant-or-self::*/(.|@*) satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>John</fName> <lName>Doe</lName> </author> return let $anotherAuthor := <author> <lName>Doe</lName> <fName>John</fName> </author> return (functx:is-node-among-descendants-deep-equal( $in-xml/author[1],$in-xml))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is among the descendants of a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-among-descendants-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-among-descendants-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq/descendant-or-self::*/(.|@*) satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>John</fName> <lName>Doe</lName> </author> return let $anotherAuthor := <author> <lName>Doe</lName> <fName>John</fName> </author> return (functx:is-node-among-descendants-deep-equal( $in-xml/author[1],$in-xml), functx:is-node-among-descendants-deep-equal( $anAuthor,$in-xml), functx:is-node-among-descendants-deep-equal( $anotherAuthor,$in-xml), functx:is-node-among-descendants-deep-equal( $anAuthor,$in-xml/author))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is among the descendants of a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-among-descendants.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-among-descendants ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq/descendant-or-self::*/(.|@*) satisfies $nodeInSeq is $node } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="49.99" discount=""/> </prices> return let $aPrice := <price value="49.99" discount=""/> return (functx:is-node-among-descendants( $aPrice,$in-xml))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is among the descendants of a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-among-descendants.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-among-descendants ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq/descendant-or-self::*/(.|@*) satisfies $nodeInSeq is $node } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="49.99" discount=""/> </prices> return let $aPrice := <price value="49.99" discount=""/> return (functx:is-node-among-descendants( $in-xml,$in-xml))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is among the descendants of a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-among-descendants.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-among-descendants ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq/descendant-or-self::*/(.|@*) satisfies $nodeInSeq is $node } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="49.99" discount=""/> </prices> return let $aPrice := <price value="49.99" discount=""/> return (functx:is-node-among-descendants( $in-xml,$in-xml/price[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is among the descendants of a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-among-descendants.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-among-descendants ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq/descendant-or-self::*/(.|@*) satisfies $nodeInSeq is $node } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="49.99" discount=""/> </prices> return let $aPrice := <price value="49.99" discount=""/> return (functx:is-node-among-descendants( $in-xml/price[1],$in-xml))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is among the descendants of a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-among-descendants.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-among-descendants ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq/descendant-or-self::*/(.|@*) satisfies $nodeInSeq is $node } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="49.99" discount=""/> </prices> return let $aPrice := <price value="49.99" discount=""/> return (functx:is-node-among-descendants( $in-xml/price[1],$in-xml), functx:is-node-among-descendants( $in-xml,$in-xml/price[1]), functx:is-node-among-descendants( $in-xml,$in-xml), functx:is-node-among-descendants( $aPrice,$in-xml))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is an ancestor of another node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-ancestor.html : @param $node1 the first node : @param $node2 the second node :)          declare function functx:is-ancestor ( $node1 as node() , $node2 as node() ) as xs:boolean { exists($node1 intersect $node2/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:is-ancestor( $in-xml//author[1], $in-xml//author[1]/fName))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is an ancestor of another node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-ancestor.html : @param $node1 the first node : @param $node2 the second node :)          declare function functx:is-ancestor ( $node1 as node() , $node2 as node() ) as xs:boolean { exists($node1 intersect $node2/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:is-ancestor( $in-xml//author[1], $in-xml//author[1]/fName), functx:is-ancestor( $in-xml//author[1]/fName, $in-xml//author[1]), functx:is-ancestor( $in-xml//author[1]/fName, $in-xml//author[1]/fName/text()), functx:is-ancestor( $in-xml//author[1], $in-xml//author[2]))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is an ancestor of another node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-ancestor.html : @param $node1 the first node : @param $node2 the second node :)          declare function functx:is-ancestor ( $node1 as node() , $node2 as node() ) as xs:boolean { exists($node1 intersect $node2/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:is-ancestor( $in-xml//author[1], $in-xml//author[2]))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is an ancestor of another node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-ancestor.html : @param $node1 the first node : @param $node2 the second node :)          declare function functx:is-ancestor ( $node1 as node() , $node2 as node() ) as xs:boolean { exists($node1 intersect $node2/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:is-ancestor( $in-xml//author[1]/fName, $in-xml//author[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is an ancestor of another node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-ancestor.html : @param $node1 the first node : @param $node2 the second node :)          declare function functx:is-ancestor ( $node1 as node() , $node2 as node() ) as xs:boolean { exists($node1 intersect $node2/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:is-ancestor( $in-xml//author[1]/fName, $in-xml//author[1]/fName/text()))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is in a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>John</fName> <lName>Doe</lName> </author> return (functx:is-node-in-sequence-deep-equal( $anAuthor,$in-xml/author))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is in a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>John</fName> <lName>Doe</lName> </author> return (functx:is-node-in-sequence-deep-equal( $in-xml/author[1],$in-xml))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is in a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>John</fName> <lName>Doe</lName> </author> return (functx:is-node-in-sequence-deep-equal( $in-xml/author[1],$in-xml/author))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is in a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>John</fName> <lName>Doe</lName> </author> return (functx:is-node-in-sequence-deep-equal( $in-xml/author[1],$in-xml/author), functx:is-node-in-sequence-deep-equal( $anAuthor,$in-xml/author), functx:is-node-in-sequence-deep-equal( $in-xml/author[1],$in-xml))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is in a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies $nodeInSeq is $node } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="49.99" discount=""/> </prices> return let $aPrice := <price value="49.99" discount=""/> return (functx:is-node-in-sequence( $aPrice,$in-xml/price))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is in a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies $nodeInSeq is $node } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="49.99" discount=""/> </prices> return let $aPrice := <price value="49.99" discount=""/> return (functx:is-node-in-sequence( $in-xml/price[1],$in-xml))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is in a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies $nodeInSeq is $node } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="49.99" discount=""/> </prices> return let $aPrice := <price value="49.99" discount=""/> return (functx:is-node-in-sequence( $in-xml/price[1],$in-xml/price))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is in a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies $nodeInSeq is $node } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="49.99" discount=""/> </prices> return let $aPrice := <price value="49.99" discount=""/> return (functx:is-node-in-sequence( $in-xml/price[1],$in-xml/price), functx:is-node-in-sequence( $in-xml/price[1],$in-xml), functx:is-node-in-sequence( $aPrice,$in-xml/price))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node precedes another without being its ancestor : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_precedes-not-ancestor.html : @param $a the first node : @param $b the second node :)          declare function functx:precedes-not-ancestor ( $a as node()? , $b as node()? ) as xs:boolean { $a << $b and empty($a intersect $b/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:precedes-not-ancestor( $in-xml//author[1], $in-xml//author[1]/fName))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node precedes another without being its ancestor : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_precedes-not-ancestor.html : @param $a the first node : @param $b the second node :)          declare function functx:precedes-not-ancestor ( $a as node()? , $b as node()? ) as xs:boolean { $a << $b and empty($a intersect $b/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:precedes-not-ancestor( $in-xml//author[1],$in-xml//author[2]))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node precedes another without being its ancestor : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_precedes-not-ancestor.html : @param $a the first node : @param $b the second node :)          declare function functx:precedes-not-ancestor ( $a as node()? , $b as node()? ) as xs:boolean { $a << $b and empty($a intersect $b/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:precedes-not-ancestor( $in-xml//author[1],$in-xml//author[2]), functx:precedes-not-ancestor( $in-xml//author[1], $in-xml//author[1]/fName), functx:precedes-not-ancestor( $in-xml//author[2],$in-xml//author[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node precedes another without being its ancestor : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_precedes-not-ancestor.html : @param $a the first node : @param $b the second node :)          declare function functx:precedes-not-ancestor ( $a as node()? , $b as node()? ) as xs:boolean { $a << $b and empty($a intersect $b/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:precedes-not-ancestor( $in-xml//author[2],$in-xml//author[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a string contains any of a sequence of strings : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_contains-any-of.html : @param $arg the string to test : @param $searchStrings the strings to look for :)          declare function functx:contains-any-of ( $arg as xs:string? , $searchStrings as xs:string* ) as xs:boolean { some $searchString in $searchStrings satisfies contains($arg,$searchString) } ;                     (functx:contains-any-of('abc',('bc','xy')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a string contains any of a sequence of strings : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_contains-any-of.html : @param $arg the string to test : @param $searchStrings the strings to look for :)          declare function functx:contains-any-of ( $arg as xs:string? , $searchStrings as xs:string* ) as xs:boolean { some $searchString in $searchStrings satisfies contains($arg,$searchString) } ;                     (functx:contains-any-of('abc',('bc','xy')), functx:contains-any-of('abc',('de','xy')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a string contains any of a sequence of strings : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_contains-any-of.html : @param $arg the string to test : @param $searchStrings the strings to look for :)          declare function functx:contains-any-of ( $arg as xs:string? , $searchStrings as xs:string* ) as xs:boolean { some $searchString in $searchStrings satisfies contains($arg,$searchString) } ;                     (functx:contains-any-of('abc',('de','xy')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a URI is absolute : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-absolute-uri.html : @param $uri the URI to test :)          declare function functx:is-absolute-uri ( $uri as xs:string? ) as xs:boolean { matches($uri,'^[a-z]+:') } ;                     (functx:is-absolute-uri('ftp.datypic.com'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a URI is absolute : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-absolute-uri.html : @param $uri the URI to test :)          declare function functx:is-absolute-uri ( $uri as xs:string? ) as xs:boolean { matches($uri,'^[a-z]+:') } ;                     (functx:is-absolute-uri( 'ftp://ftp.datypic.com'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a URI is absolute : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-absolute-uri.html : @param $uri the URI to test :)          declare function functx:is-absolute-uri ( $uri as xs:string? ) as xs:boolean { matches($uri,'^[a-z]+:') } ;                     (functx:is-absolute-uri( 'http://www.datypic.com'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a URI is absolute : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-absolute-uri.html : @param $uri the URI to test :)          declare function functx:is-absolute-uri ( $uri as xs:string? ) as xs:boolean { matches($uri,'^[a-z]+:') } ;                     (functx:is-absolute-uri( 'http://www.datypic.com'), functx:is-absolute-uri( 'ftp://ftp.datypic.com'), functx:is-absolute-uri('ftp.datypic.com'), functx:is-absolute-uri('www.datypic.com'), functx:is-absolute-uri('prod.html'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a URI is absolute : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-absolute-uri.html : @param $uri the URI to test :)          declare function functx:is-absolute-uri ( $uri as xs:string? ) as xs:boolean { matches($uri,'^[a-z]+:') } ;                     (functx:is-absolute-uri('prod.html'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a URI is absolute : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-absolute-uri.html : @param $uri the URI to test :)          declare function functx:is-absolute-uri ( $uri as xs:string? ) as xs:boolean { matches($uri,'^[a-z]+:') } ;                     (functx:is-absolute-uri('www.datypic.com'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is all whitespace or a zero-length string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_all-whitespace.html : @param $arg the string (or node) to test :)          declare function functx:all-whitespace ( $arg as xs:string? ) as xs:boolean { normalize-space($arg) = '' } ;                     let $in-xml := <in-xml> <a> </a> <b>x </b> <c> <x>x</x> </c> </in-xml> return (functx:all-whitespace(' '))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is all whitespace or a zero-length string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_all-whitespace.html : @param $arg the string (or node) to test :)          declare function functx:all-whitespace ( $arg as xs:string? ) as xs:boolean { normalize-space($arg) = '' } ;                     let $in-xml := <in-xml> <a> </a> <b>x </b> <c> <x>x</x> </c> </in-xml> return (functx:all-whitespace($in-xml/a))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is all whitespace or a zero-length string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_all-whitespace.html : @param $arg the string (or node) to test :)          declare function functx:all-whitespace ( $arg as xs:string? ) as xs:boolean { normalize-space($arg) = '' } ;                     let $in-xml := <in-xml> <a> </a> <b>x </b> <c> <x>x</x> </c> </in-xml> return (functx:all-whitespace($in-xml/b))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is all whitespace or a zero-length string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_all-whitespace.html : @param $arg the string (or node) to test :)          declare function functx:all-whitespace ( $arg as xs:string? ) as xs:boolean { normalize-space($arg) = '' } ;                     let $in-xml := <in-xml> <a> </a> <b>x </b> <c> <x>x</x> </c> </in-xml> return (functx:all-whitespace($in-xml/c))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is all whitespace or a zero-length string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_all-whitespace.html : @param $arg the string (or node) to test :)          declare function functx:all-whitespace ( $arg as xs:string? ) as xs:boolean { normalize-space($arg) = '' } ;                     let $in-xml := <in-xml> <a> </a> <b>x </b> <c> <x>x</x> </c> </in-xml> return (functx:all-whitespace($in-xml/c/text()[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is all whitespace or a zero-length string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_all-whitespace.html : @param $arg the string (or node) to test :)          declare function functx:all-whitespace ( $arg as xs:string? ) as xs:boolean { normalize-space($arg) = '' } ;                     let $in-xml := <in-xml> <a> </a> <b>x </b> <c> <x>x</x> </c> </in-xml> return (functx:all-whitespace(' '), functx:all-whitespace(' x '), functx:all-whitespace($in-xml/a), functx:all-whitespace($in-xml/b), functx:all-whitespace($in-xml/c), functx:all-whitespace($in-xml/c/text()[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is all whitespace or a zero-length string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_all-whitespace.html : @param $arg the string (or node) to test :)          declare function functx:all-whitespace ( $arg as xs:string? ) as xs:boolean { normalize-space($arg) = '' } ;                     let $in-xml := <in-xml> <a> </a> <b>x </b> <c> <x>x</x> </c> </in-xml> return (functx:all-whitespace(' x '))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-exclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-exclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value > $minValue and $value < $maxValue } ;                     (functx:between-exclusive(1, 1, 1000))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-exclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-exclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value > $minValue and $value < $maxValue } ;                     (functx:between-exclusive(1200, 1, 1000))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-exclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-exclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value > $minValue and $value < $maxValue } ;                     (functx:between-exclusive(55, 1, 1000))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-exclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-exclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value > $minValue and $value < $maxValue } ;                     (functx:between-exclusive(55, 1, 1000), functx:between-exclusive(1, 1, 1000), functx:between-exclusive(1200, 1, 1000), functx:between-exclusive('b', 'a', 'c'), functx:between-exclusive(xs:date('2004-10-31'), xs:date('2004-10-15'), xs:date('2004-11-01')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-exclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-exclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value > $minValue and $value < $maxValue } ;                     (functx:between-exclusive('b', 'a', 'c'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-exclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-exclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value > $minValue and $value < $maxValue } ;                     (functx:between-exclusive(xs:date('2004-10-31'), xs:date('2004-10-15'), xs:date('2004-11-01')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values, or equal to one of them : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-inclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-inclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value >= $minValue and $value <= $maxValue } ;                     (functx:between-inclusive(1, 1, 1000))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values, or equal to one of them : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-inclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-inclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value >= $minValue and $value <= $maxValue } ;                     (functx:between-inclusive(1200, 1, 1000))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values, or equal to one of them : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-inclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-inclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value >= $minValue and $value <= $maxValue } ;                     (functx:between-inclusive(55, 1, 1000))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values, or equal to one of them : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-inclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-inclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value >= $minValue and $value <= $maxValue } ;                     (functx:between-inclusive(55, 1, 1000), functx:between-inclusive(1, 1, 1000), functx:between-inclusive(1200, 1, 1000), functx:between-inclusive('b', 'b', 'd'), functx:between-inclusive(xs:date('2004-10-31'), xs:date('2004-10-15'), xs:date('2004-11-01')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values, or equal to one of them : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-inclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-inclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value >= $minValue and $value <= $maxValue } ;                     (functx:between-inclusive('b', 'b', 'd'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values, or equal to one of them : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-inclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-inclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value >= $minValue and $value <= $maxValue } ;                     (functx:between-inclusive(xs:date('2004-10-31'), xs:date('2004-10-15'), xs:date('2004-11-01')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is numeric : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-a-number.html : @param $value the value to test :)          declare function functx:is-a-number ( $value as xs:anyAtomicType? ) as xs:boolean { string(number($value)) != 'NaN' } ;                     let $in-xml := <in-xml> <a>123</a> <b>abc</b> </in-xml> return (functx:is-a-number(''))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is numeric : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-a-number.html : @param $value the value to test :)          declare function functx:is-a-number ( $value as xs:anyAtomicType? ) as xs:boolean { string(number($value)) != 'NaN' } ;                     let $in-xml := <in-xml> <a>123</a> <b>abc</b> </in-xml> return (functx:is-a-number($in-xml/a))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is numeric : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-a-number.html : @param $value the value to test :)          declare function functx:is-a-number ( $value as xs:anyAtomicType? ) as xs:boolean { string(number($value)) != 'NaN' } ;                     let $in-xml := <in-xml> <a>123</a> <b>abc</b> </in-xml> return (functx:is-a-number($in-xml/b))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is numeric : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-a-number.html : @param $value the value to test :)          declare function functx:is-a-number ( $value as xs:anyAtomicType? ) as xs:boolean { string(number($value)) != 'NaN' } ;                     let $in-xml := <in-xml> <a>123</a> <b>abc</b> </in-xml> return (functx:is-a-number(' 123 '))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is numeric : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-a-number.html : @param $value the value to test :)          declare function functx:is-a-number ( $value as xs:anyAtomicType? ) as xs:boolean { string(number($value)) != 'NaN' } ;                     let $in-xml := <in-xml> <a>123</a> <b>abc</b> </in-xml> return (functx:is-a-number('123'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is numeric : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-a-number.html : @param $value the value to test :)          declare function functx:is-a-number ( $value as xs:anyAtomicType? ) as xs:boolean { string(number($value)) != 'NaN' } ;                     let $in-xml := <in-xml> <a>123</a> <b>abc</b> </in-xml> return (functx:is-a-number(123))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is numeric : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-a-number.html : @param $value the value to test :)          declare function functx:is-a-number ( $value as xs:anyAtomicType? ) as xs:boolean { string(number($value)) != 'NaN' } ;                     let $in-xml := <in-xml> <a>123</a> <b>abc</b> </in-xml> return (functx:is-a-number('123abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is numeric : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-a-number.html : @param $value the value to test :)          declare function functx:is-a-number ( $value as xs:anyAtomicType? ) as xs:boolean { string(number($value)) != 'NaN' } ;                     let $in-xml := <in-xml> <a>123</a> <b>abc</b> </in-xml> return (functx:is-a-number('123'), functx:is-a-number(123), functx:is-a-number(' 123 '), functx:is-a-number(''), functx:is-a-number('123abc'), functx:is-a-number('NaN'), functx:is-a-number($in-xml/a), functx:is-a-number($in-xml/b))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is numeric : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-a-number.html : @param $value the value to test :)          declare function functx:is-a-number ( $value as xs:anyAtomicType? ) as xs:boolean { string(number($value)) != 'NaN' } ;                     let $in-xml := <in-xml> <a>123</a> <b>abc</b> </in-xml> return (functx:is-a-number('NaN'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether one (and only one) of two boolean values is true : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_exclusive-or.html : @param $arg1 the first boolean value : @param $arg2 the second boolean value :)          declare function functx:exclusive-or ( $arg1 as xs:boolean? , $arg2 as xs:boolean? ) as xs:boolean? { $arg1 != $arg2 } ;                     (functx:exclusive-or(4 >                     3,1 >                     2))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether one (and only one) of two boolean values is true : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_exclusive-or.html : @param $arg1 the first boolean value : @param $arg2 the second boolean value :)          declare function functx:exclusive-or ( $arg1 as xs:boolean? , $arg2 as xs:boolean? ) as xs:boolean? { $arg1 != $arg2 } ;                     (functx:exclusive-or(true(),false()))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether one (and only one) of two boolean values is true : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_exclusive-or.html : @param $arg1 the first boolean value : @param $arg2 the second boolean value :)          declare function functx:exclusive-or ( $arg1 as xs:boolean? , $arg2 as xs:boolean? ) as xs:boolean? { $arg1 != $arg2 } ;                     (functx:exclusive-or(true(),false()), functx:exclusive-or(true(),true()), functx:exclusive-or(4 >                     3,1 >                     2))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether one (and only one) of two boolean values is true : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_exclusive-or.html : @param $arg1 the first boolean value : @param $arg2 the second boolean value :)          declare function functx:exclusive-or ( $arg1 as xs:boolean? , $arg2 as xs:boolean? ) as xs:boolean? { $arg1 != $arg2 } ;                     (functx:exclusive-or(true(),true()))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether one string contains another, without regard to case : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_contains-case-insensitive.html : @param $arg the string to search : @param $substring the substring to find :)          declare function functx:contains-case-insensitive ( $arg as xs:string? , $substring as xs:string ) as xs:boolean? { contains(upper-case($arg), upper-case($substring)) } ;                     (functx:contains-case-insensitive( 'abcdef', 'def'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether one string contains another, without regard to case : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_contains-case-insensitive.html : @param $arg the string to search : @param $substring the substring to find :)          declare function functx:contains-case-insensitive ( $arg as xs:string? , $substring as xs:string ) as xs:boolean? { contains(upper-case($arg), upper-case($substring)) } ;                     (functx:contains-case-insensitive( 'abcdEF', 'def'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether one string contains another, without regard to case : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_contains-case-insensitive.html : @param $arg the string to search : @param $substring the substring to find :)          declare function functx:contains-case-insensitive ( $arg as xs:string? , $substring as xs:string ) as xs:boolean? { contains(upper-case($arg), upper-case($substring)) } ;                     (functx:contains-case-insensitive( 'abcdef', 'def'), functx:contains-case-insensitive( 'abcdEF', 'def'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences contain the same XML nodes, in the same order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-node-equal.html : @param $seq1 the first sequence of nodes : @param $seq2 the second sequence of nodes :)          declare function functx:sequence-node-equal ( $seq1 as node()* , $seq2 as node()* ) as xs:boolean { every $i in 1 to max((count($seq1),count($seq2))) satisfies $seq1[$i] is $seq2[$i] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-node-equal( $in-xml/author/*, $in-xml/*/*))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences contain the same XML nodes, in the same order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-node-equal.html : @param $seq1 the first sequence of nodes : @param $seq2 the second sequence of nodes :)          declare function functx:sequence-node-equal ( $seq1 as node()* , $seq2 as node()* ) as xs:boolean { every $i in 1 to max((count($seq1),count($seq2))) satisfies $seq1[$i] is $seq2[$i] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-node-equal( $in-xml/author, ($in-xml/author[2],$in-xml/author[1])))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences contain the same XML nodes, in the same order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-node-equal.html : @param $seq1 the first sequence of nodes : @param $seq2 the second sequence of nodes :)          declare function functx:sequence-node-equal ( $seq1 as node()* , $seq2 as node()* ) as xs:boolean { every $i in 1 to max((count($seq1),count($seq2))) satisfies $seq1[$i] is $seq2[$i] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-node-equal( $in-xml/author/*, $in-xml/*/*), functx:sequence-node-equal( $in-xml/author, ($in-xml/author[2],$in-xml/author[1])), functx:sequence-node-equal( $in-xml/author[1],$anAuthor))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences contain the same XML nodes, in the same order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-node-equal.html : @param $seq1 the first sequence of nodes : @param $seq2 the second sequence of nodes :)          declare function functx:sequence-node-equal ( $seq1 as node()* , $seq2 as node()* ) as xs:boolean { every $i in 1 to max((count($seq1),count($seq2))) satisfies $seq1[$i] is $seq2[$i] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-node-equal( $in-xml/author[1],$anAuthor))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences contain the same XML nodes, regardless of order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-node-equal-any-order.html : @param $seq1 the first sequence of nodes : @param $seq2 the second sequence of nodes :)          declare function functx:sequence-node-equal-any-order ( $seq1 as node()* , $seq2 as node()* ) as xs:boolean { not( ($seq1 except $seq2, $seq2 except $seq1)) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-node-equal-any-order( $in-xml/author, $in-xml/*))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences contain the same XML nodes, regardless of order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-node-equal-any-order.html : @param $seq1 the first sequence of nodes : @param $seq2 the second sequence of nodes :)          declare function functx:sequence-node-equal-any-order ( $seq1 as node()* , $seq2 as node()* ) as xs:boolean { not( ($seq1 except $seq2, $seq2 except $seq1)) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-node-equal-any-order( $in-xml/author, ($in-xml/author[2],$in-xml/author[1])))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences contain the same XML nodes, regardless of order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-node-equal-any-order.html : @param $seq1 the first sequence of nodes : @param $seq2 the second sequence of nodes :)          declare function functx:sequence-node-equal-any-order ( $seq1 as node()* , $seq2 as node()* ) as xs:boolean { not( ($seq1 except $seq2, $seq2 except $seq1)) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-node-equal-any-order( $in-xml/author, $in-xml/*), functx:sequence-node-equal-any-order( $in-xml/author, ($in-xml/author[2],$in-xml/author[1])), functx:sequence-node-equal-any-order( $in-xml/author[1],$anAuthor))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences contain the same XML nodes, regardless of order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-node-equal-any-order.html : @param $seq1 the first sequence of nodes : @param $seq2 the second sequence of nodes :)          declare function functx:sequence-node-equal-any-order ( $seq1 as node()* , $seq2 as node()* ) as xs:boolean { not( ($seq1 except $seq2, $seq2 except $seq1)) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-node-equal-any-order( $in-xml/author[1],$anAuthor))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences have the same XML node content and/or values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-deep-equal.html : @param $seq1 the first sequence : @param $seq2 the second sequence :)          declare function functx:sequence-deep-equal ( $seq1 as item()* , $seq2 as item()* ) as xs:boolean { every $i in 1 to max((count($seq1),count($seq2))) satisfies deep-equal($seq1[$i],$seq2[$i]) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-deep-equal( $in-xml/author/*, $in-xml/*/*))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences have the same XML node content and/or values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-deep-equal.html : @param $seq1 the first sequence : @param $seq2 the second sequence :)          declare function functx:sequence-deep-equal ( $seq1 as item()* , $seq2 as item()* ) as xs:boolean { every $i in 1 to max((count($seq1),count($seq2))) satisfies deep-equal($seq1[$i],$seq2[$i]) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-deep-equal( $in-xml/author/*, $in-xml/*/*), functx:sequence-deep-equal( $in-xml/author[1], $anAuthor), functx:sequence-deep-equal( (1,2,3), (1.0,2.0,3.0)))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences have the same XML node content and/or values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-deep-equal.html : @param $seq1 the first sequence : @param $seq2 the second sequence :)          declare function functx:sequence-deep-equal ( $seq1 as item()* , $seq2 as item()* ) as xs:boolean { every $i in 1 to max((count($seq1),count($seq2))) satisfies deep-equal($seq1[$i],$seq2[$i]) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-deep-equal( $in-xml/author[1], $anAuthor))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences have the same XML node content and/or values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-deep-equal.html : @param $seq1 the first sequence : @param $seq2 the second sequence :)          declare function functx:sequence-deep-equal ( $seq1 as item()* , $seq2 as item()* ) as xs:boolean { every $i in 1 to max((count($seq1),count($seq2))) satisfies deep-equal($seq1[$i],$seq2[$i]) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-deep-equal( (1,2,3), (1.0,2.0,3.0)))
declare namespace ht="http://www.example.com/example"; element {fn:QName( "http://www.example.com/another-example", "ht:person" )}{ "test" }
declare namespace ht="http://www.example.com/example"; element {fn:QName( "http://www.example.com/example", "ht2:person" )}{ "test" }
declare namespace local = "http://www.example.com/examples"; let $var := <local:someElement>some context</local:someElement> return $var
declare namespace ma = "http://www.example.com/AuctionWatch";          declare namespace anyzone = "http://www.example.com/auctioneers#anyzone";          <Q6 xmlns:ma="http://www.example.com/AuctionWatch"> { //ma:Auction[@anyzone:ID]/ma:Schedule/ma:Close } </Q6>
declare namespace ma = "http://www.example.com/AuctionWatch";          <Q7 xmlns:xlink="http://www.w3.org/1999/xlink"> {              for $a in //ma:Auction              let $seller_id := $a/ma:Trading_Partners/ma:Seller/*:ID,                  $buyer_id := $a/ma:Trading_Partners/ma:High_Bidder/*:ID              where namespace-uri(exactly-one($seller_id)) = namespace-uri($buyer_id)              return $a/ma:AuctionHomepage } </Q7>
declare namespace ma = "http://www.example.com/AuctionWatch";          <Q8 xmlns:ma="http://www.example.com/AuctionWatch"              xmlns:eachbay="http://www.example.com/auctioneers#eachbay"              xmlns:xlink="http://www.w3.org/1999/xlink"> {                  for $s in //ma:Trading_Partners/(ma:Seller | ma:High_Bidder)                  where $s/*:NegativeComments = 0                  return $s } </Q8>
declare namespace music = "http://www.example.org/music/records";          <Q2> { //music:title } </Q2>
declare namespace music = "http://www.example.org/music/records";          <Q5 xmlns:music="http://www.example.org/music/records"> { //music:record[music:remark/@xml:lang = "de"] } </Q5>
declare namespace my = "http://example.com/ANamespace";         my:function(1)
declare namespace my = "http://example.com/MyNamespace/";         declare variable $my:error-qname := QName("http://example.com/MyErrorNS", "my:qName");         declare function my:error($choice, $msg as xs:string) as empty-sequence() { if($choice) then error($my:error-qname, concat('No luck: ', $msg)) else () };         my:error(false(), "msg"), my:error(true(), "The message")
declare namespace my = "http://example.com/MyNamespace/";         declare variable $my:error-qname := QName("http://example.com/MyErrorNS", "my:qName");         declare function my:error($msg as xs:string) as empty-sequence() { error($my:error-qname, concat('No luck: ', $msg)) };         my:error("The message")
declare namespace my = "http://www.w3.org/2001/XMLSchema";         declare function my:wrongNS() { 1 };         1
declare namespace my = "http://www.w3.org/2001/XMLSchema-instance";         declare function my:wrongNS() { 1 };         1
declare namespace my = "urn:foo";         declare function my:fact($n as xs:integer) as xs:integer { if ($n < 2) then 1 else $n * my:fact($n - 1) };         declare variable $my:ten := my:fact(10);         <table> { for $i in 1 to 10 return <tr> <td>10!/{$i}! = {$my:ten div my:fact($i)}</td> </tr> } </table>
declare namespace namespace = "http://example.com"; declare union <union>for gibberish { for $for in for return <for>***div div</for> }</union>, if(if) then then else else- +-++-**-* instance of element(*)* * * **---++div- div -div
declare namespace NCName := "http://example.com/";
(::)declare(::)namespace(::)ncname(::)=(::)"http://example.com/"(::);(::)1(::)eq(::)1(::)
(::)declare(::)namespace(::)ncname(::)=(::)'http://example.com/';(::)1(::)eq(::)1(::)
declare namespace ns1 = "http://example.org"; let $var := <a attr1 = "abc1"><ns1:b attr2 = "abc2">context2</ns1:b></a> return $var/child::*:b
declare namespace ns1 = "http://example.org"; let $var := <a attr1 = "abc1"><ns1:b attr2 = "abc2">context2</ns1:b></a> return $var/child::ns1:b
declare namespace ns1 = "http://www.example.org/ns1";          declare namespace ns2 = "http://www.example.org/ns2";          let $attribute as attribute(*) := attribute ns1:foo { }          return count($attribute/self::ns2:*)
declare namespace ns1 = "http://www.example.org/ns1";          declare namespace ns2 = "http://www.example.org/ns2";          let $attribute as attribute(ns1:foo) := attribute ns1:foo { }          return count($attribute/self::ns2:*)
declare namespace ns1 = "http://www.example.org/ns1"; declare namespace ns2 = "http://www.example.org/ns2"; let $element as element(ns1:foo) := <ns1:foo/> return count($element/self::ns2:*)
declare namespace ns1 = "http://www.example.org/ns1";          declare namespace ns2 = "http://www.example.org/ns2";          let $element as element(*) := <ns1:foo/>          return count($element/self::ns2:*)
declare namespace ns1 = "http://www.example.org/ns1";          let $comment as comment() := <!--comment-->          return count($comment/self::ns1:*)
declare namespace ns1 = "http://www.example.org/ns1";          let $processing-instruction as processing-instruction() := <?processing instruction?>          return count($processing-instruction/self::ns1:*)
declare namespace p1 = "http://www.example.com";         declare namespace p2 = "http://www.example.com/examples";         declare variable $p1:var as xs:integer := 10;         declare variable $p2:var as xs:integer := 20;         $p2:var
declare namespace p1 = "http://www.example.com";         declare variable $p1:var as xs:integer := 10;         $p1:var
declare namespace p = "http://example.com/"; <a>{<e p:a="1" p:b="2" p:c="3"/>/attribute::*/p:*}</a>
declare namespace p = "http://example.com/QuiteWeirdNamespace"; empty(p:e[1])
declare namespace p = "http://www.example.com/A"; <e xmlns="http://www.example.com/A" xmlns:A="http://www.example.com/C"> <b xmlns:B="http://www.example.com/C"/> </e>/p:b
declare namespace p = "http://www.example.com/"; <p:e/>
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (name($in-xml))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (name($in-xml), name($in-xml//pre2:prefixed), name($in-xml//unpre2:unprefixed), name($in-xml//@pre2:prefAttr), name($in-xml//@noNSAttr))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (name($in-xml//@noNSAttr))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (name($in-xml//@pre2:prefAttr))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (name($in-xml//pre2:prefixed))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (name($in-xml//unpre2:unprefixed))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (node-name($in-xml))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (node-name($in-xml), node-name($in-xml/pre2:prefixed), node-name($in-xml//unpre2:unprefixed), node-name($in-xml//@pre2:prefAttr), node-name($in-xml//@noNSAttr))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (node-name($in-xml//@noNSAttr))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (node-name($in-xml//@pre2:prefAttr))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (node-name($in-xml/pre2:prefixed))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (node-name($in-xml//unpre2:unprefixed))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (prefix-from-QName( node-name($in-xml)))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (prefix-from-QName( node-name($in-xml//@noNSAttr)))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (prefix-from-QName( node-name($in-xml//@pre2:prefAttr)))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (prefix-from-QName( node-name($in-xml//pre2:prefixed)))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (prefix-from-QName( node-name($in-xml)), prefix-from-QName( node-name($in-xml//pre2:prefixed)), prefix-from-QName( node-name($in-xml//unpre:unprefixed)), prefix-from-QName( node-name($in-xml//@pre2:prefAttr)), prefix-from-QName( node-name($in-xml//@noNSAttr)), prefix-from-QName( node-name(<pre2:new>xyz</pre2:new>)))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (prefix-from-QName( node-name($in-xml//unpre:unprefixed)))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (prefix-from-QName( node-name(<pre2:new>xyz</pre2:new>)))
declare namespace prefix = "http://example.com/";
declare namespace prefix = "http://example.com/" { 1 }
declare namespace prefix = "http://example.com/"; declare variable $a := <e><a/><b/><c/></e>; <a>{$a/@prefix:* eq 1}</a>
declare namespace prefix = "http://example.com/"; declare variable $a := <e><a/><b/><c/></e>; <a>{$a/prefix:* eq 1}</a>
declare namespace prefix = "http://www.w3.org/2000/xmlns/";          <e>{attribute prefix:localName {"content"}}</e>
declare namespace prefix = "http://www.w3.org/2000/xmlns/"; <e>{attribute {"prefix:localName"} {"content"}}</e>
declare namespace prefix = "http://www.w3.org/"; <a> { <b />, attribute prefix:foo { 'bar' } } </a>
declare namespace prefix = "http://www/w3.org/"; let $attr1 := attribute attr { 'foo' } return let $attr2 := attribute attr { 'bar' } return <prefix:a>{$attr1, $attr2 }</prefix:a>
declare namespace prefix = "http://www/w3.org/"; let $attr1 := attribute prefix:attr { 'foo' } return let $attr2 := attribute prefix:attr { 'bar' } return <a>{$attr1, $attr2 }</a>
declare namespace prefix = "http://www/w3.org/"; let $attr1 := attribute prefix:attr { 'foo' } return let $attr2 := attribute prefix:attr { 'bar' } return <prefix:a>{$attr1, $attr2 }</prefix:a>
declare namespace prefix = "http://www.w3.org/"; <prefix:a> { <b />, attribute foo { 'bar' } } </prefix:a>
declare namespace prefix = "http://www.w3.org/"; <prefix:a> { <b />, attribute prefix:foo { 'bar' } } </prefix:a>
declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (local-name($in-xml))
declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (local-name($in-xml), local-name($in-xml//pre:prefixed), local-name($in-xml//unpre:unprefixed), local-name($in-xml//@pre:prefAttr), local-name($in-xml//@noNSAttr))
declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (local-name($in-xml//@noNSAttr))
declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (local-name($in-xml//@pre:prefAttr))
declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (local-name($in-xml//pre:prefixed))
declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (local-name($in-xml//unpre:unprefixed))
declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (namespace-uri($in-xml))
declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (namespace-uri($in-xml), namespace-uri($in-xml//pre:prefixed), namespace-uri($in-xml//unpre:unprefixed), namespace-uri($in-xml//@pre:prefAttr), namespace-uri($in-xml//@noNSAttr))
declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (namespace-uri($in-xml//@noNSAttr))
declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (namespace-uri($in-xml//@pre:prefAttr))
declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (namespace-uri($in-xml//pre:prefixed))
declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (namespace-uri($in-xml//unpre:unprefixed))
declare namespace px1 = "http://www.example.com/examples"; declare namespace px2 = "http://www.example.com/examples"; let $var := <px1:someElement>some context</px1:someElement> return $var
declare namespace px = "ftp://ftp.is.co.za/rfc/somefile.txt"; let $var := <px:someElement>some context</px:someElement> return $var
declare namespace px = "http://www.example.com/abc"; let $var := <px:someElement>some context</px:someElement> return namespace-uri-from-QName(node-name($var)) eq xs:anyURI("http://www.example.com/abc")
declare namespace px = "http://www.example.com/examples"; let $var := <px:someElement xmlns:px = "http://www.examples.com/localexamples">some context</px:someElement> return $var
declare namespace test = "http://www.w3.org/2005/xpath-datatypes";         declare function test:myFunction() { 1};         1 eq 1
declare namespace thisPrefixIsNotBoundExampleCom = ""; true()
declare namespace t = "http://example.com/2"; <p:a xmlns:p="http://example.com/"> <p:e xmlns:p="http://example.com/2"/> </p:a>//t:e
declare namespace xdt = "http://www.example.com/examples"; let $var := <xdt:someElement>some context</xdt:someElement> return $var
declare namespace xlink = "http://www.w3.org/1999/xlink";          <Q4 xmlns:xlink="http://www.w3.org/1999/xlink"> { for $hr in //@xlink:href return <ns>{ $hr }</ns> } </Q4>
declare namespace xml = ""; 1
declare namespace xml = "http://example.com/"; 1
declare namespace XML = "http://www.example.com/examples"; let $var := <XML:someElement>some context</XML:someElement> return $var
declare namespace xml = "http://www.example.org/"; 1 + 2
declare namespace xml = "http://www.w3.org/XML/1998/namespace"; "a"
declare namespace xmlns = ""; 1
declare namespace xmlns = "http://example.com/examples"; "a"
declare namespace XMLNS = "http://www.example.com/examples"; let $var := <XMLNS:someElement>some context</XMLNS:someElement> return $var
declare namespace xqt="http://www.w3.org/XQueryTestOrderBy";          for $num as xs:decimal as xs:decimal in data( /xqt:DataValues/xqt:NegativeNumbers/xqt:orderData ) return $num
declare namespace xs = "http://www.example.com/examples"; let $var := <xs:someElement>some context</xs:someElement> return $var
declare namespace xsi = "http://www.example.com/examples"; let $var := <xsi:someElement>some context</xsi:someElement> return $var
declare namespace xsl=``[http://www.w3.org/1999/XSL/Transform]``;         <xsl:output/>
declare namespace xx = "http://example.org"; let $i := <foo:bar xmlns:foo = "http://example.org"> <foo:bing> Lentils </foo:bing> </foo:bar> return $i/xx:bing
declare namespace xx = "http://www.example.com/abc123"; let $var := <xx:someElement>some content</xx:someElement> return namespace-uri-from-QName(node-name($var)) eq xs:anyURI("http://www.example.com/abc123")
declare namespace z = "http://z.com"; map:size(<a><z:b>x</z:b></a>/map{z:b:z:b})
declare namespace zzz="http://example.com/options";         declare option zzz:synonymous = ``[http://www.w3.org/1999/XSL/Transform]``;         <zzz:output/>
declare ne gt
declare option Q{http://www.example.com/ns}option "ignore me"; <a/>
declare variable $a := 1;         declare function local:foo($a as xs:integer) {              if ($a > 100) then $a else let $a := $a + 1 return local:foo($a) };         local:foo($a)
declare variable $a := 1;         declare variable $x external := $a + $b;         declare variable $b external := 2;         $x
declare variable $a := <a/>;          declare function local:testSingleNodeIdentity($node as node()) { $node is $node };          declare function local:testDoubleNodeIdentity($a as node(), $b as node()) { $a is $b };          local:testSingleNodeIdentity(<a/>), local:testDoubleNodeIdentity(<a/>, <b/>), local:testDoubleNodeIdentity($a, $a)
declare variable $A:=(<A>{local:functionA()}</A>);         declare function local:functionA() as element() { <input>testing ...</input> };         declare function local:functionB ( ) as xs:string { $A };         local:functionB()
declare variable $A:=(<A>{local:functionA()}</A>);         declare function local:functionA() as element() { <input>testing ...</input> };         declare function local:functionB ( ) as xs:string { xs:string($A) };         local:functionB()
declare variable $a as attribute()* := (attribute name1 {()}, attribute name2 {()}, attribute name3 {()}); declare variable $b as attribute()* := (attribute name1 {()}, attribute name2 {()}, attribute name3 {()}); $a/(let $p := position() return . is $b[$p])
declare variable $a as attribute()* := (attribute name1 {()}, attribute name2 {()}, attribute name3 {()}); <r> <e> { $a } </e> <e> { $a } </e> </r>
declare variable $a := <e><a/><b/><a/></e>; <a>{$a/a eq 1}</a>
declare variable $a := <e><a/><b/><c/></e>; <a>{$a/*:ncname eq 1}</a>
declare variable $a external := 6 + local:foo();         declare variable $b external := 12;         declare function local:foo() { $b + 10 };         $a
declare variable $array1 := ["abc","def","ghi"]; declare variable $array2 := ["abc", [10,20]];  array:get($array2,3)
declare variable $array1 := ["abc","def","ghi","jkl"];  array:remove($array1,5)
declare variable $array1 := ["abc","def","ghi","jkl"];  array:subarray($array1,2,-1)
declare variable $array1 := ["abc","def","ghi","jkl"];  array:subarray($array1,2,6)
declare variable $array1 := ["abc","def","ghi","jkl"];  array:subarray($array1,6)
declare variable $array1 := ["abc","ghi","jkl"];  array:insert-before($array1,0,"aaa")
declare variable $array1 := ["abc","ghi","jkl"];  array:insert-before($array1,6,"mno")
declare variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  $array-of-arrays instance of item()
declare variable $d1 := <e a="1" b="2"><!-- content -->text</e>; declare variable $d2 := <e b="2" a="1">text</e>; deep-equal($d1, $d2), deep-equal($d2, $d1)
declare variable $d1 := <e a="1" b="2"><?target data?>text</e>; declare variable $d2 := <e b="2" a="1">text</e>; deep-equal($d1, $d2), deep-equal($d2, $d1)
declare variable $d1 := <e a="1" b="2">te<!-- content -->xt</e>; declare variable $d2 := <e b="2" a="1">text</e>; deep-equal($d1, $d2), deep-equal($d2, $d1)
declare variable $d1 := <e a="1" b="2">te<?target data?>xt</e>; declare variable $d2 := <e b="2" a="1">text</e>; deep-equal($d1, $d2), deep-equal($d2, $d1)
declare variable $deptinfo := map {   "ACC": map {             "deptname": "Accessories",             "deptnum": 300 } ,   "WMN": map {             "deptname": "Women's",             "deptnum": 310 } ,   "MEN": map {             "deptname": "Men's",             "deptnum": 320 }  }; $deptinfo instance of item()
declare variable $deptinfo := map {   "ACC": map {             "deptname": "Accessories",             "deptnum": 300 } ,   "WMN": map {             "deptname": "Women's",             "deptnum": 310 } ,   "MEN": map {             "deptname": "Men's",             "deptnum": 320 }  }; deep-equal( $deptinfo?*[?deptname = "Accessories"], map { "deptname": "Accessories",             "deptnum": 300 })
declare variable $deptnames := map {   "ACC" : "Accessories",   "WMN" : "Women's",   "MEN" : "Men's" }; deep-equal(map:put($deptnames,"ACC","Other"), map {   "ACC" : "Other",   "WMN" : "Women's",   "MEN" : "Men's" } )
declare variable $deptnames := map {   "ACC" : "Accessories",   "WMN" : "Women's",   "MEN" : "Men's" }; deep-equal(map:put($deptnames,"SHO","Shoes"), map {   "ACC" : "Accessories",   "WMN" : "Women's",   "MEN" : "Men's",   "SHO" : "Shoes" } )
declare variable $deptnames := map {   "ACC" : "Accessories",   "WMN" : "Women's",   "MEN" : "Men's" }; deep-equal(map:remove($deptnames,"ACC"), map {   "WMN" : "Women's",   "MEN" : "Men's" } )
declare variable $deptnames := map {   "ACC" : "Accessories",   "WMN" : "Women's",   "MEN" : "Men's" };  map:contains($deptnames,"ACC")
declare variable $doc := <root><test><x/><y/></test></root>;         $doc/test[x] union $doc/test[y]
declare variable $e := <a b ="content"><?b asd?><b/></a>; $e/*
declare variable $e := <a b ="content"><?b asd?><b/></a>; $e/processing-instruction(b)
declare variable $e := <a b ="content"><?b asd?><b/></a>; <a>{$e/@*}</a>
declare variable $e := <a b ="content"><?b asd?><b/></a>; <a>{$e/@b}</a>
declare variable $e := <a b ="content"><?b asd?><b/></a>; <a>{$e/processing-instruction()}</a>
declare variable $e := <a b ="content"><?b asd?><b/><c b="content"/></a>; $e/b
declare variable $e := attribute name {()}; $e is $e, <is/> is <is/>
declare variable $e := current-time(); let $i := ($e, 1 to 50000, $e) return $i[1] = $i[last()]
declare variable $e := ()/.; declare variable $b := <b/>/.; $e, <b/>
declare variable $e := <e> <a>3</a> <a>2</a> <a>1</a> </e>; exactly-one(for $i in $e/a order by $i return $i)
declare variable $e := <e> <a>3</a> <a>2</a> <a>1</a> </e>; <result> { avg(for $i in $e/a order by $i return $i) } </result>
declare variable $e := <e> <a/> </e>; declare variable $f := $e; <r> { $e is $e, $f is $e, $e, $f } </r>
declare variable $e := <e>{current-time()}</e>/(string-length(.) > 0); $e, if($e) then "SUCCESS" else "FAILURE"
declare variable $e := <e/>; for $i in (<a/>, $e, <c/>) return $i is $e
declare variable $exampleComThisVarIsNotRecognized as processing-instruction()? external; 1
declare variable $exampleComThisVarIsNotRecognized external; 1
declare variable $ext as xs:integer* external := (0,1,2); <a>{sum($ext)}</a>
declare variable $ext as xs:integer* external := 0,1,2; <a>{sum($ext)}</a>
declare variable $ext as xs:integer external := 0; <a>{$ext}</a>
declare variable $ext as xs:integer* external := ; <a></a>
declare variable $ext external := 0; $ext
declare variable $ext external := 0; <a>{$ext}</a>
declare variable $f := (if (current-date() gt xs:date('1900-01-01')) then local:plus#2 else round#2);         declare function local:plus($x, $y) {           $x + $y + $a         };         declare variable $a := function-arity($f);         $f(3, 4)
declare variable $f := (if (current-date() gt xs:date('1900-01-01')) then local:plus#2 else round#2);         declare function local:plus($x, $y) {           $x + $y         };         $f(5, 7)
declare variable $global := count(*); $global, <wrongFocus> <e1/> <e2/> </wrongFocus>/$global, $global
declare variable $global := count(*); <e/>/$global
declare variable $global := count(*);          <e/>/($global, $global)
declare variable $global := count(*); <wrongFocus> <e1/> <e2/> </wrongFocus>/$global
declare variable $global := node();         declare function local:function() { exists($global) };         local:function()
declare variable $i := 1, 1; 1
declare variable $i := 3; (for $i in 1 return $i) eq 1
declare variable $i := <e> <a>1</a> <b>2</b> </e>; <result> { ($i/b, $i/a)/. } </result>
declare variable $i := <e xmlns="http://example.com/"/>; empty($i/@xmlns)
declare variable $i := false();          declare variable $t := false();          deep-equal( for $i in (true(), true()), $t in (true(), true())                      return ($i, $t), (true(), true(), true(), true(), true(), true(), true(), true()))
declare variable $i := false();          declare variable $t := false();          deep-equal((let $i := true(), $t := true() return ($i, $t)), (true(), true()))
declare variable $i := false();          declare variable $t := false();          some $i in (true(), true()), $t in (true(), true()) satisfies ($i eq $t)
declare variable $i := false();          declare variable $t := false();          some $i in (true(), true()), $t in (true(), true()) satisfies $i eq $t
declare variable $i := false();          every $i in (true(), true()) satisfies $i
declare variable $i := false();          some $i in (true(), true(), true()) satisfies $i
declare variable $in := <in><e on="2017-09-18"/><e on="2016-04-15"/><e on="2012-07-09"/></in>;          for $j in ($in//e/@on, xs:date('1999-12-17'))           order by $j           return $j
declare variable $input-context1 := $string;         declare variable $input-context2 := $company-data;         declare function local:partners($company as xs:string) as element()*         {             let $c := $input-context2//company[name = $company]             return $c//partner         };         let $foobar_partners := local:partners("Foobar Corporation")         for $item in $input-context1//news_item         where           some $t in $item//title satisfies             (contains(exactly-one($t/text()), "Foobar Corporation")             and (some $partner in $foobar_partners satisfies               contains(exactly-one($t/text()), $partner/text())))           or (some $par in $item//par satisfies            (contains(string($par), "Foobar Corporation")              and (some $partner in $foobar_partners satisfies                 contains(string($par), $partner/text()))))         return             <news_item>                 { $item/title }                 { $item/date }             </news_item>
declare variable $input-context := .;         declare function local:one_level($p as element()) as element() {              <part partid="{ $p/@partid }" name="{ $p/@name }" > {                  for $s in ($input-context//part)                 where $s/@partof = $p/@partid                  return local:one_level($s) } </part> };          <parttree> { for $p in //part[empty(@partof)]                       return local:one_level($p) } </parttree>
declare variable $inputDoc := 2; declare namespace x = "http://example.com/"; 1
declare variable $input := <e/>;          empty(for $PI as processing-instruction() in $input//processing-instruction() return $PI)
declare variable $i := <root> <child> <child2> <child3> <leaf/> </child3> <following/> </child2> <following/> </child> <following/> </root>; empty(root($i)//leaf/preceding::node())
declare variable $i := <root> <child/> <child/> <child> <child2> <child3> <leaf/> </child3> </child2> </child> </root>; 1, root($i)//leaf/child::node(), 1
declare variable $i := <root> <child/> <child/> <child> <child2> <child3> <leaf/> </child3> </child2> </child> </root>;          1, root($i)//leaf/following::node(), 1
declare variable $i := <root> <child/> <child/> <child> <child2> <child3> <leaf/> </child3> </child2> </child> </root>;          empty(root($i)/following::node())
declare variable $i := <root> <child/> <child/> <child> <child2> <child3> <leaf/> </child3> </child2> </child> </root>; empty(root($i)/preceding::node())
declare variable $i := <root> <child/> <child/> <child> <child2> <child3> <leaf/> </child3> </child2> </child> </root>;          root($i)//count(following::node())
declare variable $i := <root> <child/> <child/> <child> <child2> <child3> <leaf/> </child3> </child2> </child> </root>;          root($i)//count(following-sibling::node())
declare variable $i := <root> <child/> <child/> <child> <child2> <child3> <leaf/> </child3> </child2> </child> </root>;          root($i)//following-sibling::node()
declare variable $i := <root> <child/> <child/> <child> <child2> <child3> <leaf/> </child3> </child2> </child> </root>;          root($i)//(following-sibling::node(), "BOO")
declare variable $i := <root> <child> <preceding2/> <child2> <preceding1/> <child3> <leaf/> </child3> <following/> </child2> <following/> </child> <following/> </root>; count(root($i)//leaf/preceding::node())
declare variable $i := <root> <child> <preceding2/> <child2> <preceding1/> <child3> <leaf/> </child3> <following/> </child2> <following/> </child> <following/> </root>; count(root($i)/preceding::node())
declare variable $i := <root> <child> <preceding2/> <child2> <preceding1/> <child3> <leaf/> </child3> <following/> </child2> <following/> </child> <following/> </root>; empty(root($i)/preceding::node())
declare variable $i := <root> <child> <preceding2/> <child2> <preceding1/> <child3> <leaf/> </child3> <following/> </child2> <following/> </child> <following/> </root>; empty(root($i)/preceding-sibling::node())
declare variable $i := <root> <child> <preceding2/> <child2> <preceding1/> <child3> <leaf/> </child3> <following/> </child2> <following/> </child> <following/> </root>; root($i)//count(preceding::*)
declare variable $i := <root> <child> <preceding2/> <child2> <preceding1/> <child3> <leaf/> </child3> <following/> </child2> <following/> </child> <following/> </root>; root($i)//count(preceding-sibling::node())
declare variable $i := <root> <child> <preceding2/> <child2> <preceding1/> <child3> <leaf/> </child3> <following/> </child2> <following/> </child> <following/> </root>; root($i)//leaf/(preceding::node())[1]
declare variable $i := <root> <child> <preceding2/> <child2> <preceding1/> <child3> <leaf/> </child3> <following/> </child2> <following/> </child> <following/> </root>; root($i)//leaf/preceding::node()[1]
declare variable $i := <root> <child> <preceding2/> <child2> <preceding1/> <child3> <leaf/> </child3> <following/> </child2> <following/> </child> <following/> </root>; root($i)//leaf/(preceding::node())[last()]
declare variable $i := <root> <child> <preceding2/> <child2> <preceding1/> <child3> <leaf/> </child3> <following/> </child2> <following/> </child> <following/> </root>; root($i)//leaf/preceding::node()[last()]
declare variable $i := ("x", 1);         declare variable $j := $i[position() ne 1];         $i[$j]
declare variable $j external := 1;          for $x at $i in (2, 3)          where $i = $j          return $x
declare variable $local:myName := 1;         declare function local:myName() as xs:integer { 1 };         $local:myName eq local:myName()
declare variable $local:myVar := 1;         declare function local:myFunction($local:myVar) { $local:myVar };         $local:myVar, local:myFunction(2)
declare variable $local:myVar := <a/>; <b> {$local:myVar} {attribute name {"content"}} </b>
declare variable $local:myVar as item() := <a/>; <b> {$local:myVar} {attribute name {"content"}} </b>
declare variable $local:myVar := attribute n2 {"content"}; <b> {$local:myVar} {attribute name {"content"}} </b>
declare variable $local:myVar := local:myFunc(3); declare function local:myFunc($local:myVar) { $local:myVar }; local:myFunc(6)
declare variable $local:myVar := local:myFunction();          declare function local:myFunction() {            if (current-date() lt xs:date('1990-01-01')) then $local:myVar + 1 else 22          };          $local:myVar
declare variable $local:myVar := local:thisFunctionDoesNotExist(); $local:myVar
declare variable $local:myVar := local:thisFunctionDoesNotExist(); 1
declare variable $local:var1 := 1; declare variable $local:var2 := 2; declare variable $local:var3 := 3; declare variable $local:var4 := 4; declare variable $local:var5 := 5; declare variable $local:var6 := 6; declare variable $local:var7 := 7; declare variable $local:var8 := 8; declare variable $local:var9 := 9; declare variable $local:var10 := 10; declare variable $local:var11 := 11; declare variable $local:var12 := 12; declare variable $local:var13 := 13; declare variable $local:var14 := 14; declare variable $local:var15 := 15; declare variable $local:var16 := 16; declare variable $local:var17 := 17; declare variable $local:var18 := 18; declare variable $local:var19 := 19; declare variable $local:var20 := 20; deep-equal((1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20), ($local:var1, $local:var2, $local:var3, $local:var4, $local:var5, $local:var6, $local:var7, $local:var8, $local:var9, $local:var10, $local:var11, $local:var12, $local:var13, $local:var14, $local:var15, $local:var16, $local:var17, $local:var18, $local:var19, $local:var20))
(::)declare(::)variable(::)$local:var(::):=(::)3;(::)1(::)eq(::)1(::)
declare variable $local:var as item() *:=3; true()
declare variable $map1 := map {1:"first", 2:"second", 3:"third",4:()}; declare variable $map2 := map {};  map:contains($map1, "1")
declare variable $map1 := map {1:"first", 2:"second", 3:"third",4:()}; declare variable $map2 := map {};  map:contains($map1, 1)
declare variable $map1 := map {1:"first", 2:"second", 3:"third",4:()}; declare variable $map2 := map {};  map:contains($map1, 4)
declare variable $map1 := map {1:"first", 2:"second", 3:"third",4:()}; declare variable $map2 := map {};  map:contains($map1, 9)
declare variable $map1 := map {1:"first", 2:"second", 3:"third",4:()}; declare variable $map2 := map {};  map:contains($map2, 1)
declare variable $map1 := map {1:"first", 2:"second"}; declare variable $map2 := map {1:"ONE", "abc":"def"}; declare variable $map3 := map {"1":"first", "2":"second"}; deep-equal(  map:merge( ($map1, $map2, $map3) ),  map {1:"ONE", 2:"second", "abc":"def", "1":"first", "2":"second"}  )
declare variable $map1 := map {1:"first", 2:"second"}; declare variable $map2 := map {1:"ONE", "abc":"def"}; declare variable $map3 := map {"1":"first", "2":"second"}; deep-equal(  map:merge( ($map1, $map2) ),  map {1:"first", 2:"second", "abc":"def"}  )
declare variable $map1 := map {1:"first", 2:"second"}; declare variable $map2 := map {1:"ONE", "abc":"def"}; declare variable $map3 := map {"1":"first", "2":"second"}; deep-equal(  map:merge( ($map1, $map3) ),  map {1:"first", 2:"second", "1":"first", "2":"second"}  )
declare variable $map1 := map {1:"first", 2:"second"}; declare variable $map2 := map {1:"ONE", "abc":"def"}; declare variable $map3 := map {"1":"first", "2":"second"}; deep-equal(  map:merge( ($map1) ),  map {1:"first", 2:"second"}  )
declare variable $map1 := map {1:"first", 2:"second"}; declare variable $map2 := map {1:"ONE", "abc":"def"}; declare variable $map3 := map {"1":"first", "2":"second"}; deep-equal(  map:merge( ($map1, map{2:"second-new"}) ),  map {1:"first", 2:"second"}  )
declare variable $map1 := map {1:"first", 2:"second"}; declare variable $map2 := map {1:"ONE", "abc":"def"}; declare variable $map3 := map {"1":"first", "2":"second"}; deep-equal(  map:merge( ($map1, map{3:"third"}) ),  map {1:"first", 2:"second", 3:"third"}  )
declare variable $map1 := map {1:"first", 2:"second"}; declare variable $map2 := map {1:"ONE", "abc":"def"}; declare variable $map3 := map {"1":"first", "2":"second"}; deep-equal(  map:merge( ($map1, map:entry(2,"second-new")) ),  map {1:"first", 2:"second"}  )
declare variable $map1 := map {1:"first", 2:"second"}; declare variable $map2 := map {1:"ONE", "abc":"def"}; declare variable $map3 := map {"1":"first", "2":"second"}; deep-equal(  map:merge( ($map2, $map1) ),  map {1:"ONE", 2:"second", "abc":"def"}  )
declare variable $map1 := map {1:"first", 2:"second"}; declare variable $map2 := map {1:"ONE", "abc":"def"}; declare variable $map3 := map {"1":"first", "2":"second"}; deep-equal(  map:merge( () ),  map {}  )
declare variable $map1 := map {1:"first", 2:"second"}; deep-equal( map:entry(1,"first"), map {1:"first"} )
declare variable $map1 := map {1:"first", 2:"second"}; deep-equal(  map:merge( ($map1, map:entry(3, "third")) ),   map {1:"first", 2:"second", 3:"third"} )
declare variable $map1 := map {1:"first", 2:"second"}; deep-equal(  map:merge( (map:entry(1, "first"), map:entry(2, "second")) ),  map {1:"first", 2:"second"}  )
declare variable $map1 := map {1:"first", 2:"second"};          deep-equal(  map:merge(map:for-each($map1,function($k,$v) {map:entry($k + 1, $v)})),  map {2:"first", 3:"second"}  )
declare variable $map1 := map {1:"first", 2:"second"};          deep-equal(  map:put($map1, 1, "ONE"),  map {1:"ONE", 2:"second"}  )
declare variable $map1 := map {1:"first", 2:"second"};          deep-equal(  map:put($map1, 3, "third"),  map {1:"first", 2:"second", 3:"third"}  )
declare variable $map1 := map {1:"first", 2:"second"};          deep-equal(  map:put($map1, "abc", "def"),  map {1:"first", 2:"second", "abc":"def"}  )
declare variable $map1 := map {1:"first", 2:"second"}; deep-equal(  map:remove($map1,2),  map {1:"first"}  )
declare variable $map1 := map {1:"first", 2:"second"}; deep-equal( map:remove($map1,3), map {1:"first", 2:"second"} )
declare variable $map1 := map {1:"first", 2:"second"}; deep-equal( map:remove($map1,"abc"), map {1:"first", 2:"second"} )
declare variable $m as xs:integer external := 5;          declare variable $n as xs:integer external := 5;          <out>{ for $x allowing empty at $p in 1 to $m, $y at $q in 1 to $n return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>
declare variable $my := 3;         declare function local:myFunction($my, $arg2, $arg4) { 1 };         $my eq 3
declare variable $my := 3; (for $i in 1 return $my) eq 3
declare variable $myVar as xs:gYear := 2006; true()
declare variable $myVar as xs:integer := subsequence((1, 2, "a string"), 3, 1); $myVar eq 3
declare variable $myVar := (attribute name {"content"}, <elem/>); <b> {$myVar[2]} </b>
declare variable $myVar := <e/>; $myVar/(/)/
declare variable $myVar := <e/>; empty($myVar/descendant-or-self::text())
declare variable $myVar := <e/>;          empty($myVar/preceding-sibling::comment()/a/b/c/1/@*)
declare variable $myVar := <e/>; empty(fn:root($myVar/(/)/..))
declare variable $myvar := <elem> <a/> <b/> <c/></elem>; $myvar/*[1]
declare variable $myvar := <elem> <a/> <b/> <c/></elem>; $myvar/*[last()]
declare variable $myvar := <elem> <a/> <b/> <c/></elem>; $myvar/*[last() - 1]
declare variable $myVar := (<elem/>, attribute name {"content"}); <b> {$myVar[2]} </b>
declare variable $myVar := (<elem/>, attribute name {"content"}); <b> {$myVar} </b>
declare variable $myVar := <e>{nametest}</e>; <e/>/$myVar
declare variable $myVar := <e>text</e>; $myVar/text()/(<e/>, (), 1, <e/>)
declare variable $myVariable := <e/>/(1, <e/>); $myVariable
declare variable $myVariable := <e/>/(<e/>, 2); $myVariable
declare variable $myVar := unordered(fn:reverse((<a/>, <b/>))); deep-equal($myVar, (<a/>, <b/>)) or deep-equal($myVar, (<b/>, <a/>))
declare variable $n as xs:integer external := 10;          }`nasty!]``
declare variable $n as xs:integer external := 10;          <out>{ for $x allowing empty at $p in 1 to $n return <a position="{$p}">{$x}</a> }</out>
declare variable $n as xs:integer external := 10;          <out>{ for $x allowing empty in 1 to $n return <a>{$x}</a> }</out>
declare variable $n as xs:integer external := 10;         <out>{ string-join(for $x allowing empty in 1 to $n return concat('[',$x,']'), '|') }</out>
declare variable $n as xs:integer external := 10;          ``[There were `{$n
declare variable $n as xs:integer external := 10;          ``[There were `{$n} green
declare variable $n as xs:integer external := 10;          `[There were `{$n}` green bottles]``
declare variable $n as xs:integer external := 10;          ``[There were `{$n}` green bottles
declare variable $n as xs:integer external := 10;          ``[There were `{$n}` green bottles]
declare variable $n as xs:integer external := 10;          ``[There were `{$n}` green bottles]`
declare variable $n as xs:integer external := 10;          ``{There were `{$n}` green bottles}``
declare variable $n as xs:integer external := 10;          unordered{$n}`
declare variable $n as xs:integer external := 5;          <out>{ for $x as xs:integer? allowing empty at $p in 1 to $n                 for $y as xs:integer? allowing empty at $q in (if (empty($x)) then () else (1 to $x))                 where deep-equal($x,$y)                 return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>
declare variable $n as xs:integer external := 5;          <out>{ for $x as xs:integer? allowing empty at $p in 1 to $n                 for $y as xs:integer at $q in (if (empty($x)) then 0 else (1 to $x))                 return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>
declare variable $n external := 0;          for $x in -2 to +2          where ($n - $x)          return $x
declare variable $n external := 10;          for $x allowing empty in 1 to $n          where $x lt 5          return $x
declare variable $p as xs:integer external;          declare function local:negate($x) {-$x};          declare variable $f := let $x := $p return function($a) {local:negate($a + $x + $p)};          $f(12)
declare variable $p as xs:integer external;          declare variable $f := function($a) {$a + $p};          $f(12)
declare variable $p := "base-uri";         declare variable $f := function-lookup(xs:QName("fn:"||$p), 0);         declare context item := $f();         .
declare variable $p external := -101; (1, 8, 13, 14, 98, -22, 0, 17, 34, 87, 99, 54, 22, 33, 44, 55, 66, 77) = $p
declare variable $p external := (105, 22e0); $p = (1, 8, 13, 14, 98, -22, 0, 17, 34, 87, 99, 54, 22, 33, 44, 55, 66, 77)
declare variable $p external := (105, xs:untypedAtomic('22e0')); (1, 8, 13, 14, 98, -22, 0, 17, 34, 87, 99, 54, 22, 33, 44, 55, 66, 77) = $p
declare variable $p external := 17; $p = (1, 8, 13, 14, 98, -22, 0, 17, 34, 87, 99, 54, 22, 33, 44, 55, 66, 77)
declare variable $p external := (1 to 10, xs:untypedAtomic('860302'), 83);          $p = (35 to 65, xs:untypedAtomic('082'), xs:untypedAtomic('0010'))
declare variable $p external := 276; $p = (1 to 1000)
declare variable $p external := -276; (1 to 1000) = $p
declare variable $p external := xs:untypedAtomic('000504e0'); $p = (1 to 1000)
declare variable $p external := xs:untypedAtomic('000504e0'); $p = (1 to xs:integer(xs:double($p)))
declare variable $p external := xs:untypedAtomic('-022e0'); (1, 8, 13, 14, 98, -22, 0, 17, 34, 87, 99, 54, 22, 33, 44, 55, 66, 77) = $p
declare variable $p external := xs:untypedAtomic('4.5'); (1 to 1000) = $p
declare variable $p external := xs:untypedAtomic('-840'); $p = (1, 8, 13, 14, 98, -22, 0, 17, 34, 87, 99, 54, 22, 33, 44, 55, 66, 77)
declare variable $p external := xs:untypedAtomic('860302'); (1 to xs:integer($p)) = $p
declare variable $prefix:var1 := 2; declare namespace prefix = "http://example.com/myNamespace"; true()
declare variable $Q{http://www.example.com/ns/my}var := 12;              <out>{$Q{http://www.example.com/ns/my}var}</out>
declare variable $root := <a> <b e="B"/> <c e="B"/> </a>; declare function local:function($arg) { $root["B" eq $arg/@e] }; $root/local:function(c)
declare variable $root := <a> <b e="B"/> <c e="B"/> </a>; declare function local:function($arg) { $root[exactly-one($arg/@e)] }; $root/local:function(c)
declare variable $root := <a><c e=""/></a>; declare function local:function($arg) { $root[$arg/@e] }; $root/local:function(c)
declare variable $root := ( <b d=""/>, <c> <c d=""/> </c> ); declare function local:function($object) { $root[@d eq $object/@d] }; $root/local:function(c)
declare variable $root := ( <b d=""/>, <c d=""> <c d=""/> </c> );          declare function local:function($object) { $root[@d eq $object/@d] };          $root!local:function(c)
declare variable $root := <root> <b d=""/> <c> <c d=""/> <c/> </c> </root>; declare function local:function($object) { $root[$object/@d] }; $root//local:function(c)
declare variable $root := <root> <b d=""/> <c> <c d=""/> <c/> </c> </root>; declare function local:function($object) { $root/b[$object/@d] }; $root//local:function(c)
declare variable $root := <root> <b d=""/> <c> <c d=""/> <c/> </c> </root>; declare function local:function($object) { $root/b[@d = $object/@d] }; $root/c/c/local:function(.)
declare variable $root := <root> <b d=""/> <c> <c d=""/> <c/> </c> </root>;          declare function local:function($object) { $root/b[@d = $object/@d] };          $root//local:function(c)
declare variable $root := <root> <b d=""/> <c d=""/> </root>; declare function local:function($object) { $root[$object/@d] }; $root//local:function(c)
declare variable $root := <root> <c d=""/> </root>; declare function local:function($object) { $root[$object] }; $root//local:function(c)
declare variable $root := <root> <c d=""/> </root>; declare function local:function($object) { $root[$object/@d] }; $root//local:function(c)
declare variable $root := <root><c/></root>; declare function local:function($arg) { $root[$arg] }; $root//local:function(.)
declare variable $root := <root/>; declare function local:function($arg, $count as xs:integer) { $arg, $root, if($count eq 2) then $root else local:function($arg, $count + 1) }; $root/local:function(., 1)
declare variable $s :=[['A', 'DT'], ['bride', 'NN'], [',', ','], ['you', 'PRP'], ['know', 'VBP'], [',', ','], ['must', 'MD'],  ['appear', 'VB'], ['like', 'IN'], ['a', 'DT'], ['bride', 'NN'], [',', ','], ['but', 'CC'], ['my', 'PRP$'],  ['natural', 'JJ'], ['taste', 'NN'], ['is', 'VBZ'], ['all', 'DT'], ['for', 'IN'], ['simplicity', 'NN'], [';', ':'],  ['a', 'DT'], ['simple', 'JJ'], ['style', 'NN'], ['of', 'IN'], ['dress', 'NN'], ['is', 'VBZ'],  ['so', 'RB'], ['infinitely', 'RB'], ['preferable', 'JJ'], ['to', 'TO'], ['finery', 'VB'], ['.', '.'] ]; declare variable $index := map { "pos" : 2, "lemma" : 1 }; <s>  {   for $w in $s?*   return <w pos="{ $w($index("pos")) }">{ $w($index("lemma")) }</w>  } </s>
declare variable $s :=[['A', 'DT'], ['bride', 'NN'], [',', ','], ['you', 'PRP'], ['know', 'VBP'], [',', ','], ['must', 'MD'],  ['appear', 'VB'], ['like', 'IN'], ['a', 'DT'], ['bride', 'NN'], [',', ','], ['but', 'CC'], ['my', 'PRP$'],  ['natural', 'JJ'], ['taste', 'NN'], ['is', 'VBZ'], ['all', 'DT'], ['for', 'IN'], ['simplicity', 'NN'], [';', ':'],  ['a', 'DT'], ['simple', 'JJ'], ['style', 'NN'], ['of', 'IN'], ['dress', 'NN'], ['is', 'VBZ'],  ['so', 'RB'], ['infinitely', 'RB'], ['preferable', 'JJ'], ['to', 'TO'], ['finery', 'VB'], ['.', '.'] ]; <s>  {   for $w in $s?*   return <w pos="{ $w(2) }">{ $w(1) }</w>  } </s>
declare variable $sep as xs:string := "\s";        declare function local:splitter() as (function(xs:string) as xs:string*)?         { function($x as xs:string) { for $i in tokenize($x, $sep) return upper-case($i)} };        string-join(local:splitter()("A nice cup of tea"), '|')
declare variable $span := <root><span class="ocr_word" title="bbox 1388 430 1461 474">the</span> <span class="ocr_word" title="bbox 1514 433 1635 476">other</span> <span class="ocr_word" title="bbox 133 498 317 554">pcssible</span> <span class="ocr_word" title="bbox 354 498 590 541">derivation</span> <span class="ocr_word" title="bbox 631 497 738 538">from</span> <span class="ocr_word" title="bbox 772 495 799 547" lang="grc" xml:lang="grc">?</span> <span class="ocr_word" title="bbox 835 495 1019 538" lang="grc" xml:lang="grc">???????</span> <span class="ocr_word" title="bbox 134 567 220 607">dies</span> <span class="ocr_word" title="bbox 257 566 462 607">erastinus</span></root>; declare function local:extract-text($spans) {   for $s in $spans//span return string($s) };   local:extract-text($span)
declare variable $strings := ('1','2'); declare variable $untypeds := (<untyped>1</untyped>,<untyped>2</untyped>); for $string in $strings for $untyped in $untypeds where $untyped = $string return $string
declare variable $v : = 1; 1
declare variable $v ::= 1; 1
declare variable $v := <a><b/><b/><b/></a>; $v//45
declare variable $v := <a><b/><b/><b/></a>; deep-equal($v//45, (45, 45, 45, 45))
declare variable $var1 := $var2; declare variable $var2 := 2; $var1
declare variable $var1 := $var2; declare variable $var2 := 2; true()
declare variable $var1 = 1; 1
declare variable $var1 := 1;         declare function local:func1() as xs:integer { $var1 };         declare variable $var2 := 2;         declare function local:func2() as xs:integer { $var2 };         1 eq local:func1() and 2 eq local:func2()
(::)declare(::)variable(::)$var(::):=(::)1(::);(::) 1(::)eq(::)1
declare variable $var := 1 := 2; 3
declare variable $var1 := 2; declare variable $var2 := $var1; $var2 eq 2
declare variable $var1 := let $var1 := 1 return 1;         $var1 eq 1
declare variable $var1 := local:myFunc(); declare function local:myFunc() { 1 }; $var1 eq 1
declare variable $var := <a> <b/> <c/> <d/> </a>; ($var/*, $var/*)
declare variable $var := <a> <b/> <c/> <d/> </a>; ($var/*, $var/*)/.
declare variable $var as xs:anyURI := xs:anyURI("http://example.com"); $var
declare variable $var as xs:boolean := fn:empty((1,2,3)); $var
declare variable $var as xs:boolean := fn:false(); $var
declare variable $var as xs:boolean := fn:not(fn:true()); $var
declare variable $var as xs:boolean := fn:true(); $var
declare variable $var as xs:dateTime := xs:dateTime("1999-11-28T09:00:00Z"); $var
declare variable $var as xs:date := xs:date("1999-11-28Z"); $var
declare variable $var as xs:date := xs:date("1999-11-28Z");         declare variable $var as xs:date := xs:date("1999-11-28Z");         $var
declare variable $var as xs:decimal := 100; $var
declare variable $var as xs:integer := $e +1;        declare variable $e as xs:integer := 10;         $var
declare variable $var as xs:integer := 100; $var
declare variable $var as xs:integer := 17;           declare variable $ext as element(a) external := <a>{$var}</a>;           <out>{$ext}</out>
declare variable $var as xs:integer := 17;          declare variable $ext as xs:integer external := $var;          <out>{$ext}</out>
declare variable $var as xs:integer := 17;          declare variable $ext as xs:integer external := <a>{$var}</a>;          <out>{$ext}</out>
declare variable $var as xs:integer := fn:count((10,2)); $var
declare variable $var as xs:integer := fn:string-length("ABC"); $var
declare variable $var as xs:string := "abc"; $var
declare variable $var as xs:time := xs:time("11:12:00Z"); $var
declare variable $var := document {<a>123</a>}; $var[/*5]
declare variable $var := document {<a>123</a>}; $var[/<5]
declare variable $var := document {<a>123</a>}; $var[/<a]
declare variable $var := document {<a>123</a>}; $var[/<a div 3]
declare variable $var := document {<a>123</a>}; $var[/</b]
declare variable $var := document {<a>123</a>}; $var[/if ($doclevel) then / else /*]
declare variable $var := document {<a>123</a>};          $var[/ instance of document-node(element(x))]
declare variable $var := document {<a>123</a>};          declare variable $a := document {<a>123</a>}; $var[/ is $a]
declare variable $var := document {<a>123</a>};          let $doc := / return $doc/*
declare variable $var := <e><f>f's value</f></e>; $var/(/)/(/)//f
declare variable $var := <elem/>; $var is $var
declare variable $var := <elem/>; <a>{$var}</a>/elem[1] is $var
declare variable $var := <elem/>; not($var is <elem/>)
declare variable $var := <elem>text<a/><!-- a comment --><b/><?target data?><c/><![CDATA[more text]]></elem>; $var/child::*
declare variable $var := <elem xml:space="default"/>; $var/@xml:space eq "default"
declare variable $var := <elem xml:space="preserve"/>; string(($var/@xml:*)[1])
declare variable $var external := 1; 1
declare variable $var := (for $i in 1 to 100 return <e>{$i}</e>); $var[5]
declare variable $var := (for $i in 1 to 100 return <e>{$i}</e>); $var[last()]
declare variable $v as element(notWildcard, xs:untyped*)+ := <e/>; 1
declare variable $v as element(notWildcard, xs:untyped+)+ := <e/>; 1
declare variable $v as element(*, xs:untyped*)+ := <e/>; 1
declare variable $v as element(*, xs:untyped+)+ := <e/>; 1
declare variable $v := function-arity(local:plus#2);         declare function local:plus($x, $y) {           $x + $y         };         $v
declare variable $v := function-name(local:plus#2);         declare function local:plus($x, $y) {           $x + $y         };         $v
declare variable $x := "" ; $x
declare variable $x := '' ; $x
declare variable $x := $y + 3;         declare variable $y := 17;         $x + 5
declare variable $x := 0 ; $x
declare variable $x := 0.0E0 ; $x
declare variable $x := +1 ; $x
declare variable $x := -1 ; $x
declare variable $x := 1 ; $x
declare variable $x := -10000000 ; $x
declare variable $x := ((1+1), (2-2)) ; $x
declare variable $x := ((1,2,2),(1,2,3),(123,""),(),("")) ; $x
declare variable $x := (1,2,3) ; $x
declare variable $x := -1.23 ; $x
declare variable $x := 1.23 ; $x
declare variable $x := 1.2e5 ; $x
declare variable $x := -1.2E5 ; $x
declare variable $x := -1.7976931348623157E308 ; $x
declare variable $x := 1e-5 ; $x
declare variable $x := 1 to 10 ; $x
declare variable $x := 2*2 ; $x
declare variable $x := 2+2 ; $x
declare variable $x := 3-2 ; $x
declare variable $x := -3.4028235E38 ; $x
declare variable $x := 3 div 2 ; $x
declare variable $x := 3 idiv 2 ; $x
declare variable $x := 3 mod 2 ; $x
declare variable $x := -999999999999999999 ; $x
declare variable $x := 999999999999999999 ; $x
declare variable $x := "a "" or a ' delimits a string literal" ; $x
declare variable $x := 'a " or a '' delimits a string literal' ; $x
declare variable $x := "a string" ; $x
declare variable $x := 'a string' ; $x
declare variable $x as xs:boolean external; $x and fn:false()
declare variable $x as xs:boolean external; $x or fn:false()
declare variable $x as xs:boolean external; fn:not($x)
declare variable $x as xs:boolean external; fn:string($x)
declare variable $x as xs:decimal external; $x
declare variable $x as xs:decimal external := xs:integer(10);         $x
declare variable $x as xs:double external; $x
declare variable $x as xs:integer := 10; declare variable $var as xs:integer := $x +1; $var
declare variable $x as xs:integer external; $x
declare variable $x as xs:integer external; $x * $x
declare variable $x as xs:integer external; $x + $x
declare variable $x as xs:integer external; $x div xs:integer(10)
declare variable $x as xs:integer external; $x idiv xs:integer(2)
declare variable $x as xs:integer external; $x mod xs:integer(2)
declare variable $x as xs:integer external; $x - xs:integer(1)
declare variable $x as xs:integer external := xs:int(5);         declare variable $y as xs:decimal external := $x;         $y instance of xs:decimal
declare variable $x as xs:string external; $x
declare variable $x as xs:string external; fn:lower-case($x)
declare variable $x as xs:string external; fn:upper-case($x)
declare variable $x := <b/>;         declare variable $y := <a/>;         ($x union $y) union $x, ($x intersect $y) union $x, ($x except $y) union $x, ($y except $x) union $x, $x union ($x union $y), $x union ($x intersect $y), $x union ($x except $y), $x union ($y except $x)
declare variable $x := /comment() ; $x
declare variable $x external := $a + 10;         $x
declare variable $x external; $x
declare variable $x external; $x * $x
declare variable $x external; $x + $x
declare variable $x external; $x - 1
declare variable $x external; $x and fn:false()
declare variable $x external; $x div 10
declare variable $x external; $x idiv 2
declare variable $x external; $x mod 2
declare variable $x external; $x or fn:false()
declare variable $x external := 10;         declare variable $y external := 18 + $x;         $y
declare variable $x external := 5;         declare variable $a := $x + 2;         declare function local:foo() {$x +$a};         declare variable $y external := 11 + local:foo() + $x;         $y
declare variable $x external; fn:lower-case($x)
declare variable $x external; fn:not($x)
declare variable $x external; fn:string($x)
declare variable $x external; fn:upper-case($x)
declare variable $x external; "result"
declare variable $x external := /works/employee[@name eq "Jane Doe 1"];         fn:count($x)
declare variable $x external; xs:dateTime($x)
declare variable $x external; xs:integer($x)
declare variable $x := false(); $x
declare variable $x := fn:false() ; $x
declare variable $x := fn:true() ; $x
declare variable $x := '&lt;bold&gt;A sample element.&lt;/bold&gt;' ; $x
declare variable $x := //Price/text() ; $x
declare variable $x := /processing-instruction() ; $x
declare variable $x := 'This is a "String"' ; $x
declare variable $x := "This is a string, isn't it?" ; $x
declare variable $x := true() ; $x
declare variable $x := true(); $x
declare variable $x := (xs:boolean("true") , xs:boolean("0"), xs:integer("0")) ; $x
declare variable $x := xs:date("1970-01-01Z") ; $x
declare variable $x := (xs:date("1993-03-31") , xs:boolean("true"), xs:string("abc")) ; $x
declare variable $x := xs:dateTime("2030-12-31T23:59:59Z") ; $x
declare variable $x := xs:decimal("-999999999999999999") ; $x
declare variable $x := xs:decimal("999999999999999999") ; $x
declare variable $x := xs:double("-1.7976931348623157E308") ; $x
declare variable $x := xs:double('-INF'); $x
declare variable $x := xs:double('INF'); $x
declare variable $x := xs:double('NaN'); $x
declare variable $x := xs:float("-3.4028235E38") ; $x
declare variable $x := (xs:float("INF") , xs:double("NaN")) ; $x
declare variable $x := (xs:string("a") , xs:anyURI("www.example.com")) ; $x
declare variable $x := (xs:string("a") , (), "xyz") ; $x
declare variable $x := xs:time("08:03:35Z") ; $x
declare variable $x := (xs:time("12:30:00") , xs:string(" ") , xs:decimal("2.000000000000002")) ; $x
declare variable $y external;         declare variable $z external := 10;         declare function local:aaa() { $z };         declare variable $x external := local:bbb() + local:aaa() + 2;         declare function local:bbb() { $y };         $x
declare variable $y := /works/employee;         declare context item := $y[9];         declare variable $x external := fn:position();         $x
declare variable $y := /works/employee;         declare context item := $y[9];         declare variable $x external := if (./*) then fn:position() else 0;         ($x, $y)
declare variable var1 := 1; 1
deep-equal()
deep-equal((0, 1, 2), (0, 1, 2)[. eq 0 or . eq 1 or . eq 2])
deep-equal((0, 1, 2), (0, 1, 2)[if(. eq 8) then 0 else position()])
deep-equal((0, 1, 2), (0, 1, 2)[if(. eq 8) then "str" else position()])
deep-equal((0, 1, 2), (0, 1, 2)[position() eq position()])
deep-equal((0, 1, 2), (0, 1, 2)[position() = position()])
deep-equal((0, -1, -2, -3, -4, -5), reverse(-5 to 0))
deep-equal((), 0 to -5)
deep-equal(0 to -5, ())
deep-equal((11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1), reverse(((), (), 1, 2, (3, 4), (5), (6, (7, 8), 9), 10, (), 11, ())))
deep-equal(((), 1, 1), ((), 1, 1))
deep-equal((1, (), 1), (1, (), 1))
deep-equal((1, 1, ()), (1, 1, ()))
deep-equal((1, 1, 1), (1, 1, 1))
deep-equal((1, 1, "str"), (1, 1, "str"))
deep-equal((1, 2), (0, 1, 2)[if(. eq 1) then 2 else 3])
deep-equal((1, 2), (1, 2)[remove((true(), "a string"), 2)])
deep-equal((1, 2), (1, 2)[remove((true(), "a string"), 2)]) eq 0
deep-equal((1, 2, 3))
deep-equal((1, 2, 3), (1, 2, 3)[2 or 3])
deep-equal((1, 2, 3), (1, 2, 3)[3 ge position()])
deep-equal((1, 2, 3), (1, 2, 3)[3 >= position()])
deep-equal((1, 2, 3), (1, 2, 3, current-time())[3 ge position()])
deep-equal((1, 2, 3), (1, 2, 3, current-time())[3 >= position()])
deep-equal((1, 2, 3), (1, 2, 3, current-time())[4 gt position()])
deep-equal((1, 2, 3), (1, 2, 3, current-time())[4 > position()])
deep-equal((1, 2, 3), (1, 2, 3, current-time())[position() <= 3])
deep-equal((1, 2, 3), (1, 2, 3, current-time())[position() < 4])
deep-equal((1, 2, 3), (1, 2, 3, current-time())[position() le 3])
deep-equal((1, 2, 3), (1, 2, 3, current-time())[position() lt 4])
deep-equal((1, 2, 3), (1, 2, 3)[. instance of xs:integer])
deep-equal((1, 2, 3), (1, 2, 3)[number(.)])
deep-equal((1, 2, 3), (1, 2, 3)[position() >= 1])
deep-equal((1, 2, 3), (1, 2, 3)[position() ge 1])
deep-equal((1, 2, 3), (1, 2, 3)[true()])
deep-equal((1, 2, 3), (1, 2, 3)[xs:anyURI("example.com/")])
deep-equal((1, 2, 3), (1, 2, 3)[xs:untypedAtomic("content")])
deep-equal(((1, (2, (3, 4, (5, 6)), 7), 8, (9, 10), 11)), (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))
deep-equal((1, 2, 3, 4, 5, 6), index-of((4, 4, 4, 4, 4, 4), 4))
deep-equal((1, 2, 3, 4), for $i at $p in -10 to -7 return $p)
deep-equal((1, 2, 3, 4), for $i at $p in 1 to 4 return $p)
deep-equal((1, 2, 3, 4), for $i at $p in insert-before((1, current-time()), 13, (current-date(), 3)) return $p)
deep-equal((1, 2, 3, 4), for $i at $p in insert-before((1, current-time()), 1, (current-date(), 3)) return $p)
deep-equal((1, 2, 3, 4), for $i at $p in insert-before((1, current-time()), 2, (current-date(), 3)) return $p)
deep-equal((-1, -2, -3, -4), reverse(-4 to -1))
deep-equal((1, 2, 3)[count((last(), last())) eq 2], (1, 2, 3))
deep-equal((1, 2, 3), for $i at $p in (1, 2, 3) return $p)
deep-equal((1, 2, 3), for $i at $p in remove((1, 2, 3, current-time()), 1) return $p)
deep-equal((1, 2, 3), for $i at $p in remove((1, 2, 3, current-time()), 2) return $p)
deep-equal((1, 2, 3), for $i at $p in remove((1, 2, 3, current-time()), 3) return $p)
deep-equal((1, 2, 3), for $i at $p in remove((1, 2, 3, current-time()), 4) return $p)
deep-equal((1, 2, 3), for $i at $p in remove((1, 2, current-time()), 0) return $p)
deep-equal((1, 2, 3), for $i at $p in remove((1, 2, current-time()), 10) return $p)
deep-equal((1, 2, 3), for $i at $p in string-to-codepoints("abc") return $p)
deep-equal((1, 2, 3)[last() eq last()], (1, 2, 3))
deep-equal((1, 2, 3)[number()], (1, 2, 3))
deep-equal( (1, 2, 3, remove((current-time(), 4), 1)) [0 != last()], (1, 2, 3, 4))
deep-equal( (1, 2, 3, remove((current-time(), 4), 1)) [0 ne last()], (1, 2, 3, 4))
deep-equal( (1, 2, 3, remove((current-time(), 4), 1)) [0 ne position()], (1, 2, 3, 4))
deep-equal( (1, 2, 3, remove((current-time(), 4), 1)) [0 != position()], (1, 2, 3, 4))
deep-equal( (1, 2, 3, remove((current-time(), 4), 1)) [last() != 0], (1, 2, 3, 4))
deep-equal( (1, 2, 3, remove((current-time(), 4), 1)) [last() > 0], (1, 2, 3, 4))
deep-equal( (1, 2, 3, remove((current-time(), 4), 1)) [last() >= 1], (1, 2, 3, 4))
deep-equal( (1, 2, 3, remove((current-time(), 4), 1)) [last() ge 1], (1, 2, 3, 4))
deep-equal( (1, 2, 3, remove((current-time(), 4), 1)) [last() gt 0], (1, 2, 3, 4))
deep-equal( (1, 2, 3, remove((current-time(), 4), 1)) [last() ne 0], (1, 2, 3, 4))
deep-equal( (1, 2, 3, remove((current-time(), 4), 1)) [position() != 0], (1, 2, 3, 4))
deep-equal( (1, 2, 3, remove((current-time(), 4), 1)) [position() > 0], (1, 2, 3, 4))
deep-equal( (1, 2, 3, remove((current-time(), 4), 1)) [position() >= 1], (1, 2, 3, 4))
deep-equal( (1, 2, 3, remove((current-time(), 4), 1)) [position() ge 1], (1, 2, 3, 4))
deep-equal( (1, 2, 3, remove((current-time(), 4), 1)) [position() gt 0], (1, 2, 3, 4))
deep-equal( (1, 2, 3, remove((current-time(), 4), 1)) [position() ne 0], (1, 2, 3, 4))
deep-equal((1, 2, 3), unordered((1, 2, 3)))
deep-equal((1, 2, 4), (1, 2, current-time(), 4)[3 ne position()])
deep-equal((1, 2, 4), (1, 2, current-time(), 4)[3 != position()])
deep-equal((1, 2, 4), (1, 2, current-time(), 4)[position() != 3])
deep-equal((1, 2, 4), (1, 2, current-time(), 4)[position() ne 3])
deep-equal((1, 2), for $i at $p in subsequence((1, 2, 3, current-time()), 1, 2) return $p)
deep-equal((1, 2), for $i at $p in subsequence((1, 2, 3, current-time()), 2, 2) return $p)
deep-equal((1, 2), for $i at $p in subsequence((1, 2, 3, current-time()), 3, 2) return $p)
deep-equal((1, 2, xs:base64Binary("FFFF")), (1, 2, xs:base64Binary("FFFF")))
deep-equal((1, <a/>, 2), (1, <b/>, 2))
deep-equal(1, <e>1</e>)
deep-equal((1, <e/>, 2), (1, <e/>, 2))
deep-equal((1, "str", 1), (1, "str", 1))
deep-equal(1, subsequence((1, 2, current-time()), 1, 1))
deep-equal(1 to 5, (for $i in (1,2,3,4,5) return $i))
deep-equal((2, 2), (for $foo in (1, 1) return 1 + $foo))
deep-equal((2, 3, 4, 5, 7, 8, 9), (0, 2, 3, 4, 5, 5, 7, 8, 10 - 1)[.])
deep-equal((3, 2, 1), reverse((1, 2, 3)))
deep-equal((3, 2, 1), reverse((1, 2, 3))[true()])
deep-equal((3, 2, 1), reverse(1 to 3))
deep-equal((4, 5), (1, 2, current-time(), 4, 5)[3 lt position()])
deep-equal((4, 5), (1, 2, current-time(), 4, 5)[3 < position()])
deep-equal((4, 5), (1, 2, current-time(), 4, 5)[4 le position()])
deep-equal((4, 5), (1, 2, current-time(), 4, 5)[4 <= position()])
deep-equal((4, 5), (1, 2, current-time(), 4, 5)[position() > 3])
deep-equal((4, 5), (1, 2, current-time(), 4, 5)[position() >= 4])
deep-equal((4, 5), (1, 2, current-time(), 4, 5)[position() ge 4])
deep-equal((4, 5), (1, 2, current-time(), 4, 5)[position() gt 3])
deep-equal((<a/>, <b/>, 4), (<a/>, <b/>, 2))
deep-equal((<a/>, <b/>), (<a/>, <b/>, <c/>))
deep-equal(("a", "b", "c"), (0, 1, 2, "a", "b", "c")[. instance of xs:string])
deep-equal((<a/>, <b/>, <c/>), (<a/>, <b/>))
deep-equal((<a/>, <b/>, <c/>), (<a/>, <b/>, <a/>))
deep-equal((<a/>, <b/>, <c/>), (<a/>, <b/>, <c/>))
deep-equal('a', 'b', 'http://www.cbcl.co.u,/collation')
deep-equal("a string")
deep-equal("a string", "a string", ())
deep-equal("a string", "a string", "http://www.example.com/COLLATION/NOT/SUPPORTED")
deep-equal("a string", "a string", "http://www.w3.org/2005/xpath-functions/collation/codepoint", "wrong param")
deep-equal((attribute name2 {"content"}, attribute name {"content"}), (attribute name {"content"}, attribute name2 {"content"}))
deep-equal(attribute name {}, attribute name {})
deep-equal(attribute name {}, attribute name2 {})
deep-equal(attribute name {"content"}, attribute name {})
deep-equal(attribute name {"content "}, attribute name2 {"content "})
deep-equal(attribute name {"content"}, attribute name {"content"})
deep-equal((attribute name {"content"}, attribute name {"content"}), (attribute name {"content"}))
deep-equal((attribute name {"content"}, attribute name {"content"}), attribute name {"content"})
deep-equal("a", xs:NCName("a"))
deep-equal((<a />, xs:untypedAtomic("a"), xs:untypedAtomic("P1Y"), 2.0), (<a />, xs:untypedAtomic("a"), xs:yearMonthDuration("P12M"), xs:untypedAtomic(" 2")))
deep-equal((<b/>, <b/>, <b/>, <b/>), (for $v1 in (1, 2, 3, 4) let $v2 := <b/> return ($v2)))
deep-equal((<b/>, <b/>, <b/>, <b/>), (for $v1 in (1, 2, 3, 4) let $v2 := <b/> return ($v2))/.)
deep-equal((current-time(), current-time(), current-time()), (current-time(), current-time()))
deep-equal(current-time(), <e/>)
deep-equal(<e>1</e>, 1)
deep-equal(<e><a>12</a></e>/*, <f><a>12</a></f>/*)
deep-equal(<e/>, current-time())
deep-equal((), ()) eq true()
deep-equal(<e xmlns="http://www.example.com/ns"/>, <p:e xmlns:p="http://www.example.com/ns"/>)
deep-equal(fn:innermost( //*/@* ), //*/@*)
deep-equal(fn:outermost( //*/@* ), //*/@*)
deep-equal((for $a in 1, $b in $a, $c in $a, $d in $c return ($a, $b, $c, $d)), (1, 1, 1, 1))
deep-equal((for $fo in trace((1, 2, 3), "msg") return $fo), (1, 2, 3))
deep-equal(for $i at $p in (1, 2, 3, 4) return ($i, $p), (1, 1, 2, 2, 3, 3, 4, 4))
deep-equal((for $var in (1, 2, 3) return $var), (1, 2, 3))
deep-equal(index-of((10, 20, 30, 30, 20, 10), 20), (2, 5))
deep-equal(index-of(20, 20), (1))
deep-equal(index-of((20, 20), 20), (1, 2))
deep-equal(index-of((20, 40), 20), (1))
deep-equal(index-of((20, 40, 20), 20), (1, 3))
deep-equal(index-of(("a", "sport", "and", "a", "pastime"), "a"), (1, 4))
deep-equal(map{"a":1,"b":2,"c":(3,4,5)}, map{"c":(3,4,5),"a":1,"b":2})
deep-equal(map{"a":1}, map:entry("a", 1))
deep-equal(map{"a":1}, map:merge(()))
deep-equal(map{"a":1}, map:put(map{}, 'a', 1))
deep-equal(map {   "ACC" : "Accessories",   "WMN" : "Women's",   "MEN" : "Men's" },map {   "ACC" : "Accessories",   "WMN" : "Women's",   "MEN" : "Men's" })
deep-equal( map {     "ACC": map {               "name": "Accessories",               "code": 300 } ,     "WMN": map {               "name": "Women's",               "code": 310 } ,     "MEN": map {               "name": "Men's",               "code": 320 }      },map {     "ACC": map {               "name": "Accessories",               "code": 300 } ,     "WMN": map {               "name": "Women's",               "code": 310 } ,     "MEN": map {               "name": "Men's",               "code": 320 }      })
deep-equal(map{}, map:merge(()))
deep-equal(map{}, map:remove(map:put(map:merge(()), 1, 2), 1))
deep-equal(map:merge(for $i in 1 to 1000 return map:entry($i, $i+1)),                          map:merge(for $i in 0 to 1000 return map:entry($i, $i+1)))
deep-equal(map:merge(for $i in 1 to 1000 return map:entry($i, $i+1)),                          map:merge(((for $i in 1 to 1000 return map:entry($i, $i+1)), map:entry(400, 402)),                          map{"duplicates":"use-last"}))
deep-equal(map:merge(for $i in 1 to 1000 return map:entry($i, $i+1)),                          map:merge(for $i in 2 to 1000 return map:entry($i, $i+1)))
deep-equal(map:merge(for $i in 1 to 1000 return map:entry($i, $i+1)),                          map:merge(for $i in 2 to 1001 return map:entry($i, $i+1)))
deep-equal(map:put(map{"a":1,"b":2,"c":(3,4,5)}, "d", 6), map:put(map{"d":6,"c":(3,4,5),"a":1}, "b", 2))
deep-equal(map:put(map:merge(for $i in 1 to 1000 return map:entry($i, $i+1)), 1001, 1002),                          map:merge(for $i in 1 to 1001 return map:entry($i, $i+1)))
deep-equal(map:remove(map{"a":1,"b":(2,3)}, "a"), map:entry("b", (2,3)))
deep-equal(map:remove(map{"a":1,"b":(2,3), "c":1 to 5}, ("a", "c", "d")), map:entry("b", (2,3)))
deep-equal(map:remove(map{"a":1,"b":(2,3), "c":1 to 5}, ("a", "c")), map:entry("b", (2,3)))
deep-equal(map{xs:double('NaN'): 10}, map{xs:float('NaN'):10e0})
deep-equal (  parse-json('{    "number": 557,    "name": "Fleece Pullover",    "colorChoices": ["navy","black"],    "is-current": true,    "other": null  }'), map {    "number": xs:double(557),    "name": "Fleece Pullover",    "colorChoices": ["navy", "black"],    "is-current": true(),    "other": ()  })
deep-equal (  parse-json('{    "number": 557,    "name": "Fleece Pullover",    "colorChoices": ["navy","black"] }'), map {    "number": xs:double(557),    "name": "Fleece Pullover",    "colorChoices": ["navy", "black"] })
deep-equal(remove((1, 2, 3, current-time()), 4)[true()], (1, 2, 3))
deep-equal(remove(for $var in (current-time(), 2, 3, 4) return $var, 1), (2, 3, 4))
deep-equal((), reverse(0 to -5))
deep-equal(reverse(0 to -5), ())
deep-equal(("str", 1, 1), ("str", 1, 1))
deep-equal(string-to-codepoints(' '), (10))
deep-equal(string-to-codepoints(' '), (10, 133))
deep-equal(string-to-codepoints('     '), (10, 32, 10, 32, 10, 10))
deep-equal(string-to-codepoints('  '), (32, 133, 32))
deep-equal(string-to-codepoints('   '), (32, 8232, 32))
deep-equal(string-to-codepoints("ee"), (101, 101))
deep-equal(string-to-codepoints("eee"), (101, 101, 101))
deep-equal(string-to-codepoints("Thérèse"), (84, 104, 233, 114, 232, 115, 101))
deep-equal((true(), true()), for $i at $p in (1, 2) return boolean($p))
deep-equal((true(), true(), true()), (false(), true(), true(), false(), true(), false())[.])
deep-equal(xs:double("NaN"), xs:double("NaN"))
deep-equal(xs:double("NaN"), xs:float("NaN"))
deep-equal(xs:float("NaN"), xs:double("NaN"))
deep-equal(xs:float("NaN"), xs:float("NaN"))
deep-equal(xs:gMonth("--12+03:00"), xs:gMonth("--12")) eq (implicit-timezone() eq xs:dayTimeDuration("PT3H"))
deep-equal((xs:untypedAtomic("a"), xs:untypedAtomic("P1Y"), 2.0), (xs:untypedAtomic("a"), xs:yearMonthDuration("P12M"), xs:untypedAtomic(" 2")))
() div 1
//doc/normalize-space(zero-or-one(a[normalize-space() = 'Hello, How are you?']))
document()
document(*)
document{"content"};
document("example.com/file.ext")
document-node(*)
document-node(1)
document-node{"content"}
document-node(local:name)
document-node(name)
document-node(processing-instruction())
document-node(schema-attribute(ncname))
document-node(unknown())
(<e/>, 1)[..]
<e>{1}{1}{1}<e/></e>
<e>1.1</e> < 3
<e>1.1</e> < 3.
<e>1.1</e> < 3e3
<e>1.1</e> < xs:float(3e3)
<e>{[1, 2, 3]}</e>
<e>{1}A{1}</e>
<e>{1}{text{""}}{2}</e>
<e>{1}{text{()}}{2}</e>
<e/>[1]/text{string-join(., " ")}, 1
<e a=""/>/@a instance of attribute(a)
<e a=""/>/attribute::a instance of attribute(a)
<e> <a/> <b/> </e>/((b, a)/., (.), (*, *))
<e> <a/> <b/> </e>/(if(position() = 10) then (<e/>, .) else 4)
<e>a<!--data tar-->b</e>
<e> <a/> </e>/(., .)/.
<e> <a/> </e>/*/(., .)/.
<e a="{<e><b>data</b></e>/b}" xmlns="http://www.example.com/"/>
<e a="{<e b="data"/>/@b}" xmlns="http://www.example.com/"/>
<e>a</e>, <e>b</e>, <e>c</e>
<e a="{p:count(())}" xmlns:p="http://www.w3.org/2005/xpath-functions"/>
<e attr="    "/>
<e attr="<"/>
<e attr="]]>"/>
<e attr="{1}&#86;{1}&#86;"/>
<e attr="   a"/>
<e attr="abc{ 23 (:":) }xyz"/>
<e attr="abc{ 23 (:{:) }xyz"/>
<e attr="abc{ 23 (:}:) }xyz"/>
<e attr="abc{ (# }xyz"/>
<e attr=""/>/(@attr instance of attribute(), @* instance of attribute())
<e attr="c"/>/@attr/..
<e attr="content'/>
<e attr="content}"/>
<e attr='content"/>
<e/>/attribute("any"))
<e> { attribute name {<anElement/>}, attribute name2 {"content"} } </e>
<e> { attribute name {"content"}, attribute name2 {"content"} } </e>
<e> { attribute {QName("http://example.com/", "attr")} {()}, attribute {QName("http://example.com/", "attr")} {()} } </e>
<e> { attribute {QName("http://example.com/", "attr")} {()} } </e>
<e> { attribute {QName("http://www.w3.org/2000/xmlns/", "space")} {"default"} } </e>
<e> { attribute {QName("http://www.w3.org/XML/1998/namespace", "space")} {"default"} } </e>
<e/>/attribute::schema-attribute()
<e attr="x{<e>a</e>, <e>b</e>, <e>c</e>, 1, 2, 3}y"/>
<e> <b a=""/> <b/> </e>/b
<e> { <b attr="fo" a="bo"/>/@* } </e>
<e> <b attr="fo"/> <b/> </e>/descendant-or-self::node()
<e> <b/> <b a=""/> </e>/b
<e><b/></e>/b/..
<e><b/></e>/element(b, xs:anyType)
<e>{<b foo="1"/>/attribute(foo, xs:anyType)}</e>
<e><![CDATA]
<e><![CDATA]]
<e><![CDATA]]>
<e><![CDATA[content]]]></e>
<e><![CDATA[content]]]]]]></e>
<e><![CDATA[]]]></e>
<e><![CDATA[]]]]]]></e>
eclare function
<e> <!-- comment --> <?PA ?>text<b/> <?PB ?> <b/> <?PC ?> </e>/child::node()
<e> content}</e>
<e><!--data --></e>/comment()/..
<e>]]></e>
<e><e/>{1}{1}{1}</e>
<e/>/<e a="{p:asd}" xmlns:p="http://example.com/asd"/>
<e>{<e><b/></e>/element(p:foo)}</e>
<e>{<e foo="asd"/>/attribute(foo, xs:untypedAtomic)}</e>
<e>{<e foo="asd"/>/attribute(notBound:foo, xs:untypedAtomic)}</e>
<e>{<e foo="asd"/>/attribute(*, xs:untypedAtomic)}</e>
<e/>/element("any"))
<e/>/(every $b in 1, $v in self::node() satisfies $v)
<e/>/(every $v in self::node() satisfies $v)
<e/>/(/)//f
<e>{[<f>{[1,<x/>,3]}</f>, <g>{[4, <x/>, 5]}</g>]}</e>
<e><f>foo</f></e> ! map{*:*}         =>         deep-equal(map{"foo":<f>foo</f>})
<e><f>foo</f></e> ! map{*:f:*:f}         =>         deep-equal(map{"foo":<f>foo</f>})
<e>{fn:root(attribute name {"value"})}</e>
<e/>/(for $b in 1, $i in self::node() return $i)
<e/>/(for $i in 1, $b in self::node() return $b)
<e/>/(for $i in self::node() return $i)
<e>{for $PI in <e/>/processing-instruction() return ()}</e>
<e>{for $PI in ()/processing-instruction() return ()}</e>
<e> { for $x in 1 to 10 return <a>{for $y in 1 to 10 where $x > 7 and $y = $x return $y}</a> } </e>
<e> { for $x in 1 to 10 where $x > 7 return <a>{for $y in 1 to 10 where $y = $x return $y}</a> } </e>
<e/>/if(true()) then 1 else 3
<e/> instance of attribute()
<e/> instance of attribute(*)
<e/> instance of attribute(e)
<e/> instance of element()
<e/> instance of element(*)
<e/> instance of element(a, xs:anyType)
<e/> instance of element(e)
<e/> instance of element(name)
<e/> instance of element(*, xs:anyType)
<e/> instance of element(*, xs:untyped)
(<elem/>)
<elem />
<elem/>
<elem>
<elem><
<elem><!-
<elem><![
<elem><[
<elem>{1}{2}{3}{4}{5}</elem>
<elem>{1}{2}{3}{4}</elem>
<elem>{1}{2}{3}</elem>
<elem>{1, '', 2}</elem>
<elem>{1}{2}</elem>
<elem>{1,//a,2,3,//comment(),4,5,//processing-instruction(),6,7,//text(),8}</elem>
<elem>{1,'a',3.5,4e2}</elem>
<elem>{1}{text{""}}{2}</elem>
<elem>{1, //west/@mark}</elem>
<elem>A<a>B<?pi?>C<b/>D<!---->E</a>F<!--content-->G<a/>H<?pi content?>I<c/>J</elem>
<elem><a><b/></a><a/><c/></elem>
<elem> {"a string", attribute name {"content"}} </elem>
<elem att="{<e2 a2="{<e3 a3="{<p:e/>/namespace-uri()}"></e3>/@a3}"></e2>/@a2}"                                       xmlns:p="http://ns.example.com/uri"/>
<elem att="{<p:e/>/namespace-uri()}" xmlns:p="http://ns.example.com/uri"/>
<elem attr=" "/>
<elem attr=""""/>
<elem attr="&"/>
<elem attr="<"/>
<elem attr="{"/>
<elem attr="}"/>
<elem attr='                                                                                                              '/>
<elem attr=''''/>
<elem attr="{1,'',2}"/>
<elem attr="{(1,2)}{3}"/>
<elem attr="{123}456"/>
<elem attr="123{456}"/>
<elem attr="1{2,3}{4,5}6{<a>7</a>}{<a>8</a>}9"/>
<elem attr="{1,<a/>,2}"/>
<elem attr1="""" attr2='''' attr3="''" attr4='""' attr5="'" attr6='"'/>
<elem attr="{(1)}">{(<child/>),(<child/>)}</elem>
<elem attr="{1,'string',3.14,xs:float('1.2345e-2'),xs:dateTime('2002-04-02T12:00:00-01:00')}"/>
<elem attr1="val1" attr2="val2"/>
<elem attr1="val1" attr2="val2" attr3="val3"/>
<elem attr1="val1" attr="val2" attr2="val3" attr="val4" attr3="val5"/>
<elem attr="abxxyz123890!@#$%^*()[]\|?/>:;"/>
<elem attr="&amp;&lt;&gt;"/>
<elem attr="content'/>
<elem attr='content"/>
<elem attr="{<elem>123</elem>, (<elem attr='456'/>)/@attr, (<elem>789</elem>)/text()}"/>
<elem {"attribute-name"} = "attribute value"/>
<elem attributename = {"attribute value"} />
<elem attributename = {"attribute value"}></elem>
<elem attr="val1" attr2="val2" attr="val3"/>
<elem attr="val1" attr="val2" attr2="val3"/>
<elem attr = "value"/>
<elem attr="value" />
<elem attr="value"/>
<elem attr="value'/>
<elem attr='value"/>
<elem attr='value'/>
<elem attr="&#x30;&#x31;&#x32;"/>
<elem attr="&#x9;"/>
<elem attr="&#xa;"/>
<elem attr="&#xd;"/>
<elem attr="z{ (:comment:) }z"/>
<elem attr="z{ }z"/>
<elem attr="z{}z"/>
<elem><a/>{//west/@mark}</elem>
<elem><![CDA
<elem><![CDATA[]]>{attribute name {"content"}}<alem/> </elem>
<elem> <![CDATA[]]> {attribute name {"content"}} </elem>
<elem><![CDATA[cdata&<>'"&lt;&#x20;]]></elem>
<elem><![CDATA[CONTENT]
<elem><![CDATA[CONTENT]]
<elem><![CDATA[CONTENT]]>
<elem> <![CDATA[content]]> {attribute name {"content"}} </elem>
<elem><![cdata[CONTENT]]></elem>
<elem> <!-- comment --> { "a string", 999, ("another string", attribute name {"content"}, 383), xs:hexBinary("FF") } </elem>
<elem> <!-- comment --> { "a string", 999, attribute name {"content"}, xs:hexBinary("FF") } </elem>
<elem>{comment {'one'}}<a>{comment {'two'}}</a>{comment {'three'}}</elem>
<elem> <!-- content --> {attribute name {"content"}} </elem>
<elem>content{(:comment:)}content</elem>
<elem>content{}content</elem>
<elem><!----><!--content--></elem>
<elem>{"", "", <e/>, <b></b>}</elem>
<elem>{<e/>, <b></b>, "", ""}</elem>
<elem>&</elem>
<elem></elem>
<elem><</elem>
<elem>{""}</elem>
<elem>{(/), (/)}</elem>
<elem>{</elem>
<elem>{{</elem>
<elem>}</elem>
<elem>}}</elem>
<elem></elemother>
element()
element { 1 } { }
element(1)
element {123} {'text'}
element {1,2} {'text'}
element {"aPrefix:localName"} {"content"}
element {//a} {'text'}
<element attributeName="}"/>
<element attributeName='}'/>
element e {"content"} instance of element(a, xs:anyType)
element e {"content"} instance of element(*, xs:anyType)
element e {"content"} instance of element(*, xs:untyped)
element e {element b{()}}
element elem {., .}
element elem {}
element elem {1, '', 2}
element elem {1,//a,2,3,//comment(),4,5,//processing-instruction(),6,7,//text(),8}
element elem {1,'a',3.5,4e2}
element elem {1, element a {2, element b {element c {}, element d {3}}, 4}}
element elem {1, //west/@mark}
element elem {attribute {123} {'text'}}
element elem {attribute {1,2} {'text'}}
element elem {attribute {//a} {'text'}}
element elem {attribute attr {., .}}
element elem {attribute attr {1,'',2}}
element elem {attribute attr {1,<a/>,2}}
element elem {attribute attr {1,'string',3.14,xs:float('1.2345e-2'),xs:dateTime('2002-04-02T12:00:00-01:00')}}
element elem {attribute attr {<elem>123</elem>, (<elem attr='456'/>)/@attr, (<elem>789</elem>)/text()}}
element elem {attribute {'attr', ()} {'text'}}
element elem {attribute {'attr'} {'text'}}
element elem {attribute {(), 'attr'} {'text'}}
element elem {attribute attr {'text'}}
element elem {attribute {'el em'} {'text'}}
element elem {attribute {'foo:attr'} {}}
element elem {attribute foo:attr {'text'}}
element elem {attribute {//*:NCName[1]} {'text'}}
element elem {attribute {'one', 'two'} {'text'}}
element elem {attribute {()} {'text'}}
element elem {attribute xml:id {"ncname"}}
element elem {attribute {xs:dateTime("1999-05-31T13:20:00")} {'text'}}
element elem {attribute {xs:QName('aQname')} {'text'}}
element elem {attribute {xs:untypedAtomic('attr')} {'text'}}
element elem {attribute {xs:untypedAtomic('el em')} {'text'}}
element elem {attribute {xs:untypedAtomic('foo:elem')} {'text'}}
element elem {attribute {xs:untypedAtomic('one'), xs:untypedAtomic('two')} {'text'}}
element elem {element a {}, //west/@mark}
element {'el em'} {'text'}
element {'elem', ()} {'text'}
element {'elem'} {'text'}
element {(), 'elem'} {'text'}
element elem {'text'}
element elem {//west/@mark, //center/@mark}
element elem {//west/@mark, //west/@west-attr-1}
element {fn:QName( concat('http://www.example.com/', string((//FolderName)[2])), "people" )}{ "test" }
element {fn:QName("http://www.example.com/example", "ht:person")}{ "test" }
element {fn:QName("http://www.example.com/example", "person")}{ "test" }
element {fn:QName( "http://www.example.com/example", string((//FolderName)[2]) )}{ "test" }
element {fn:QName( "http://www.example.com/example", "" )}{ "test" }
element {fn:QName("", "person")}{ "test" }
element {fn:QName((), "person")}{ "test" }
element foo:anElement {"Element content"}
element {'foo:elem'} {}
element foo:elem {'text'}
element "name" {"content"}
element {//*:NCName[1]} {'text'}
element(notBound:ncname)
element {'one', 'two'} {'text'}
<element> { processing-instruction { 'pi' } { <element>?&gt;</element> } } </element>
element {()} {'text'}
element x { attribute Q{http://example.com/x}y { } }
element {"xmlns:error"} {}
<element xmlns:sgml="http://www.example.com/other"> {         for $a in attribute { fn:QName("http://www.example.com/", "sgml:foo") } { }         return concat(name($a), "=", namespace-uri($a)) }         </element>
element {xs:dateTime("1999-05-31T13:20:00")} {'text'}
element {xs:QName('aQname')} {'text'}
element {xs:untypedAtomic("aPrefix::localName")} {"content"}
element {xs:untypedAtomic('el em')} {'text'}
element {xs:untypedAtomic('elem')} {'text'}
element {xs:untypedAtomic('foo:elem')} {'text'}
element {xs:untypedAtomic('one'), xs:untypedAtomic('two')} {'text'}
<elem foo:attr="value" xmlns:foo="http://www.w3.org/XQueryTest/Construct"/>
<elem mark="w0">{//west/@west-attr-1, //west/@mark}</elem>
<elem mark="w0">{//west/@west-attr-1, //west/@west-attr-2}</elem>
<elem>{(//node() | //node()) except //comment()}</elem>
<elem>{//node() | (//node() except //comment())}</elem>
<elem>{(//(north)/(/)//(@mark)[(1)]/(.)/(..))}</elem>
<elem><?pi?><?pi content?></elem>
<elem>{/root}</elem>
<elem>some text<node/>some text</elem>
<elem> <?target content ?> {attribute name {"content"}} </elem>
<elem>{text {'one'}}<a>{text {'two'}}</a>{text {'three'}}</elem>
<elem><![THISISWRONG[content]]></elem>
<elem>{//west/@mark, //center/@mark}</elem>
<elem>{()}{//west/@mark}</elem>
<elem>{//west/@mark, //west/@west-attr-1}</elem>
<elem>{//west/@mark}x{//west/@west-attr-1}</elem>
<elem>{//west/@west-attr-1}{//west/@west-attr-2}</elem>
<elem>&#x0;</elem>
<elem>&#x30;</elem>
<elem>&#x7b;</elem>
<elem>&#x7d;</elem>
<elem xml:id="ncname"/>
<elem xmlns:cm="http://www.example.com" attr="{count(//cm:b)}"/>
<elem xmlns:cm="http://www.example.com">{count(//cm:b)}</elem>
<elem xmlns:foo="http://www.example.com"/>
<elem xmlns:foo="http://www.example.com/foo">{attribute {xs:untypedAtomic('foo:attr')} {'text'}}</elem>
(<elem xmlns:foo="http://www.example.com"><foo:child/></elem>)/*:child
<elem xmlns:foo="http://www.example.com/foo">{element elem {attribute {'foo:attr'} {}}}</elem>
<elem xmlns:foo="http://www.example.com/foo">{element {'foo:elem'} {'text'}}</elem>
<elem xmlns:foo="http://www.example.com/foo">{element {xs:untypedAtomic('foo:elem')} {'text'}}</elem>
<elem xmlns:foo="http://www.example.com/foo">{processing-instruction {'foo:attr'} {}}</elem>
<elem xmlns:foo="http://www.example.com/foo">{processing-instruction {xs:untypedAtomic('foo:pi')} {'text'}}</elem>
<elem xmlns:foo="http://www.example.com/parent"><foo:child xmlns:foo="http://www.example.com/child"/></elem>
(<elem xmlns:foo="http://www.example.com/parent"><foo:child xmlns:foo="http://www.example.com/child"><foo:grand-child/></foo:child></elem>)//*:grand-child
<elem xmlns:foo="http://www.example.com">{processing-instruction foo:pi {'text'}}</elem>
<elem xmlns:foo="http://www.example.com" xmlns:foo="http://www.example.com"/>
<elem xmlns:foo="http://www.w3.org/XQueryTest/Construct"><child foo:attr="value"/></elem>
<elem xmlns:foo="http://www.w3.org/XQueryTest/Construct" foo:attr="value"/>
<elem xmlns:foo="http://www.w3.org/XQueryTest/Construct" xmlns:bar="http://www.w3.org/XQueryTest/Construct" foo:attr="val1" bar:attr="val2"/>
<elem xmlns="{'http://www.example.com'}"/>
<elem xmlns="http://www.example.com"/>
(<elem xmlns="http://www.example.com"><child/></elem>)/*:child
<elem xmlns="http://www.example.com{'/namespace'}"/>
<elem xmlns="http://www.example.com/parent"><child xmlns=""/></elem>
(<elem xmlns="http://www.example.com/parent"><child xmlns=""><grand-child/></child></elem>)//*:grand-child
<elem xmlns="http://www.example.com/parent"><child xmlns="http://www.example.com/child"/></elem>
(<elem xmlns="http://www.example.com/parent"><child xmlns="http://www.example.com/child"><grand-child/></child></elem>)//*:grand-child
<elem xmlns="http://www.example.com" xmlns="http://www.example.com"/>
<e>{map:for-each(map{"a":1, "b":2}, function($k,$v){attribute{$k}{$v}})}</e>
(//employee[fn:last()])
//(employee[location = "Denver"] intersect //employee[last()])/./location
//empnum
(//empnum | (/))//employee[xs:integer(hours[1]) gt 20]
empty( ((), (), ()) )
empty(((), (), ((), (), ((), (), (())), ()), (), (())))
empty(() * ())
empty(() + ())
empty(() - ())
empty(() << ())
empty(() >> ())
empty(())
empty(()[()])
empty()
empty(+())
empty(-())
empty((0, 1, 2)[false()][1])
empty(0 to -3)
empty(0 to -5)
empty(() * 1)
empty(() << 1)
empty(() >> 1)
empty(()[1])
empty(1 << ())
empty(1 >> ())
empty(() + (1, 2))
empty((1, 2) + ())
empty(1, 2)
empty((1, 2, 3)[()])
empty((1, 2, 3)[0])
empty((1, 2, 3)[0.1])
empty((1, 2, 3)[1.01])
empty((1, 2, 3)[1.1])
empty((1, 2, 3)[3][0])
empty((1, 2, 3)[3][2])
empty((1, 2, 3)[3e8])
empty((1, 2, 3)[4])
empty((1, 2, 3)[4.01])
empty((1, 2, 3)[4.1])
empty((1,2,3,4,5)[3.4])
empty((1, 2, 3, current-time())[0])
empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [0 eq last()])
empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [0 eq position()])
empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [0 = last()])
empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [0 = position()])
empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [last() <= 0])
empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [last() = 0])
empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [last() < 1])
empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [last() eq 0])
empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [last() le 0])
empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [last() lt 1])
empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [position() <= 0])
empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [position() = 0])
empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [position() < 1])
empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [position() eq 0])
empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [position() le 0])
empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [position() lt 1])
empty((1, 2, 3, current-time())[last() + 1])
empty((1, 2, 3)[false()])
empty((1, 2, 3)[position() eq 2 or position() eq 3][3])
empty((1, 2, 3)[remove((false(), "a string"), 2)])
empty(1 div ())
empty(1 eq ())
empty(1 is ())
empty(1 to ())
empty(1 to 0)
empty(-1 to -3)
empty(30 to 3)
empty(-4 to -5)
empty(<a/>/a)
empty(<a> <b/> <c/> </a>[self::b][last()])
empty(abs(()))
empty(<anElement/>/ancestor::node())
empty(()/@attr)
empty(attribute name {"content"}/ancestor::node())
empty(attribute theName {"some text"}/..)
empty(avg( () ))
empty(avg(((), ())))
empty(avg(()))
empty(() cast as xs:QName?)
empty(ceiling(()))
empty(comment {"some text"}/..)
empty(<!-- content -->/ancestor::node())
empty(()[count(remove((current-time(), 1), 1)) eq 1])
empty(current-time()[2])
empty(data( () ))
empty(dateTime((), ()))
empty(dateTime(xs:date("2004-03-04"), ()))
empty(dateTime((), xs:time("08:05:23")))
empty(day-from-date(()))
empty(day-from-dateTime(()))
empty(days-from-duration(()))
empty(() div ())
empty(() div 1)
empty(() div xs:decimal(1))
empty(<e/>/..)
empty(<e><a/></e>//a[3.4])
empty(<e/>/(a except ancestor))
empty(<e/>/(a except ancestor-or-self))
empty(<e/>/(a except attribute))
empty(<e/>/(a except declare))
empty(<e/>/(a except descendant))
empty(<e/>/(a except descendant-or-self))
empty(<e/>/(a except following))
empty(<e/>/(a except following-sibling))
empty(<e/>/(a except parent))
empty(<e/>/(a except preceding))
empty(<e/>/(a except preceding-sibling))
empty(<e/>/(a except self))
empty(<e/>/(a intersect ancestor))
empty(<e/>/(a intersect ancestor-or-self))
empty(<e/>/(a intersect attribute))
empty(<e/>/(a intersect attribute {"name"} {()}))
empty(<e/>/(a intersect attribute name {()}))
empty(<e/>/(a intersect comment {()}))
empty(<e/>/(a intersect declare))
empty(<e/>/(a intersect descendant))
empty(<e/>/(a intersect descendant-or-self))
empty(<e/>/(a intersect element {"name"} {()}))
empty(<e/>/(a intersect element name {()}))
empty(<e/>/(a intersect following))
empty(<e/>/(a intersect following-sibling))
empty(<e/>/(a intersect parent))
empty(<e/>/(a intersect preceding))
empty(<e/>/(a intersect preceding-sibling))
empty(<e/>/(a intersect processing-instruction {"name"} {()}))
empty(<e/>/(a intersect processing-instruction name {}))
empty(<e/>/(a intersect self))
empty(<e/>/(a intersect text {()}))
empty(<e attr=""/>/descendant::node())
empty(<e attr=""/>/descendant-or-self::node())
empty(<e/>/attribute::attribute())
empty(<e/>/(a union ancestor))
empty(<e/>/(a union ancestor-or-self))
empty(<e/>/(a union attribute))
empty(<e/>/(a union attribute {"name"} {()}))
empty(<e/>/(a union attribute name {()}))
empty(<e/>/(a union comment {()}))
empty(<e/>/(a union declare))
empty(<e/>/(a union descendant))
empty(<e/>/(a union descendant-or-self))
empty(<e/>/(a union element {"name"} {()}))
empty(<e/>/(a union element name {()}))
empty(<e/>/(a union following))
empty(<e/>/(a union following-sibling))
empty(<e/>/(a union parent))
empty(<e/>/(a union preceding))
empty(<e/>/(a union preceding-sibling))
empty(<e/>/(a union processing-instruction {"name"} {()}))
empty(<e/>/(a union processing-instruction name {}))
empty(<e/>/(a union self))
empty(<e/>/(a union text {()}))
empty(<e/>/(author except attribute))
empty(<e/>/(author except comment))
empty(<e/>/(author except div))
empty(<e/>/(author except document))
empty(<e/>/(author except document-node))
empty(<e/>/(author except element))
empty(<e/>/(author except empty-sequence))
empty(<e/>/(author except if))
empty(<e/>/(author except item))
empty(<e/>/(author except mod))
empty(<e/>/(author except node))
empty(<e/>/(author except processing-instruction))
empty(<e/>/(author except schema-attribute))
empty(<e/>/(author except schema-element))
empty(<e/>/(author except text))
empty(<e/>/(author except then))
empty(<e/>/(author intersect attribute))
empty(<e/>/(author intersect comment))
empty(<e/>/(author intersect div))
empty(<e/>/(author intersect document))
empty(<e/>/(author intersect document-node))
empty(<e/>/(author intersect element))
empty(<e/>/(author intersect empty-sequence))
empty(<e/>/(author intersect if))
empty(<e/>/(author intersect item))
empty(<e/>/(author intersect mod))
empty(<e/>/(author intersect node))
empty(<e/>/(author intersect processing-instruction))
empty(<e/>/(author intersect schema-attribute))
empty(<e/>/(author intersect schema-element))
empty(<e/>/(author intersect text))
empty(<e/>/(author intersect then))
empty(<e/>/(author union attribute))
empty(<e/>/(author union comment))
empty(<e/>/(author union div))
empty(<e/>/(author union document))
empty(<e/>/(author union document-node))
empty(<e/>/(author union element))
empty(<e/>/(author union empty-sequence))
empty(<e/>/(author union if))
empty(<e/>/(author union item))
empty(<e/>/(author union mod))
empty(<e/>/(author union node))
empty(<e/>/(author union processing-instruction))
empty(<e/>/(author union schema-attribute))
empty(<e/>/(author union schema-element))
empty(<e/>/(author union text))
empty(<e/>/(author union then))
empty(<e/>/descendant::node())
empty(<e/>/descendant-or-self::node())
empty(<e/>/(div div div))
empty(<e/>/(for $i in e return $i))
empty(<e/>/(gt gt gt))
empty(<elem/>/..)
empty(<element/>/ancestor::node())
empty(<element attr="foo" attr2="foo"/>/*)
empty(element theName {"some text"}/..)
empty(<e/>/(mod mod mod))
empty(<e/>[parent::node()])
empty(() eq ())
empty(() eq 1)
empty(exactly-one(<e/>/*) is exactly-one(<e/>/*))
empty(floor(()))
empty(fn:root(<e/>)/..)
empty(fn:root(<e/>/..))
empty(for $b in <e/> where $b/@id="person0" return ())
<empty> { for $file in (//Folder)[1]/File return () } </empty>
<empty> { for $file in (//Folder)[1]/File where false() return $file/FileName } </empty>
<empty> { for $file in (//Folder)[1]/File where () return $file/FileName } </empty>
<empty> { for $folder in /MyComputer/Drive2//Folder where 1 = 2 return <Folder> { $folder/FolderName/text() } </Folder> } </empty>
empty(for $i at $p in () return $p)
empty(for $i at $p in subsequence((1, 2, 3, current-time()), 5, 8) return $p)
empty(for $i at $p in subsequence((1, 2, 3, current-time()), 5) return $p)
empty(for $i in (1, 2, current-time())[1] where xs:anyURI("") return true())
empty(for $i in 1 where false() return $i)
empty(for $var in () return 1)
empty((for $var in () return 1) eq 1)
empty((for $var in () return current-time()))
empty(for $var in () return current-time())
empty(for $var in subsequence((current-time(), 1), 4) return 1)
empty(for $x in (1 to 10)[. mod 2 = 0] return "blah")
empty(for $x in (1 to 10)[. mod 2 = 0] return floor($x))
empty(for $x in (1 to 10)[. mod 2 = 0] return true())
empty(function-lookup(fn:QName('http://www.w3.org/2005/xquery-local-functions', 'missing'), 1))
empty(hours-from-dateTime(()))
empty(hours-from-duration(()))
empty(hours-from-time(()))
empty(() idiv ())
empty(() idiv xs:decimal(1))
empty(if(<e>{current-time()}</e>) then 1 else 1)
empty(if(<e>{current-time()}</e>) then () else ())
empty(index-of((10, 20, 30, 40), 35))
empty(index-of((), 4))
empty(index-of(xs:double("NaN"), xs:double("NaN")))
empty(index-of(xs:double("NaN"), xs:float("NaN")))
empty(index-of(xs:float("NaN"), xs:double("NaN")))
empty(index-of(xs:float("NaN"), xs:float("NaN")))
empty(insert-before((1, current-time(), 3), 0, (4, 5, 6))[last() - 10])
empty(() is ())
empty(() is 1)
empty((())[last()])
empty(()[last()])
empty(local-name-from-QName( () ))
empty(max(()))
empty(min(()))
empty(minutes-from-dateTime(()))
empty(minutes-from-duration(()))
empty(minutes-from-time(()))
empty(() mod ())
empty(month-from-date(()))
empty(month-from-dateTime(()))
empty(months-from-duration(()))
empty(()/name)
empty(namespace-uri-from-QName( () ))
empty(node-name(()))
empty(node-name( comment { "comments have no name " } ) )
empty(()[position()])
empty(prefix-from-QName( () ))
empty(processing-instruction theName {"some text"}/..)
empty(remove((1, 2, 3, current-time()), 4)[false()])
empty(remove((1, 2, 3, current-time()), 9)[last() - 10])
empty(remove((), 4))
empty(remove(current-time(), 1))
empty(reverse( () ))
empty(reverse(()))
empty(reverse(0 to -5))
empty(reverse(1 to 0))
empty(reverse(4 to 1))
empty(reverse(-4 to -5))
empty(root(()))
empty(round(()))
empty(round-half-to-even(()))
empty(round-half-to-even((), 3))
empty(seconds-from-dateTime(()))
empty(seconds-from-duration(()))
empty(seconds-from-time(()))
empty-sequence()
empty(string-to-codepoints(""))
empty(string-to-codepoints(()))
empty(string-to-codepoints("Thérèse")[last() - 7])
empty(subsequence((1, 2, 3), 2, -10))
empty(subsequence((1, 2, 3, current-time(), 5, 6, 7), 1, 1)[2])
empty(subsequence((1, 2, 3, current-time(), 5, 6, 7), 4, 1)[last() - 10])
empty(subsequence((1, 2, 3, "four"), -4, -3))
empty(subsequence((1, 2, 3, "four"), 4, -3))
empty(subsequence((1, 2), 4))
empty(subsequence((), 2, 3))
empty(subsequence((current-time(), 1), 4))
empty(sum((), ()))
empty(<?target data?>/ancestor::node())
empty(text {(1 to 10)[. mod 2 = 0]})
empty(text {"some text"}/..)
empty(timezone-from-date(()))
empty(timezone-from-dateTime(()))
empty(timezone-from-dateTime(xs:dateTime("2004-12-10T23:43:41.965")))
empty(timezone-from-date(xs:date("2004-10-12")))
empty(timezone-from-time(()))
empty(timezone-from-time(xs:time("23:43:12.765")))
empty(() to 1)
empty(unordered(()))
empty(() - xs:double(3))
empty(xs:double(3) div ())
empty(() - xs:float(3))
empty(xs:float(3) mod ())
empty(year-from-date(()))
empty(year-from-dateTime(()))
empty(years-from-duration(()))
empty(zero-or-one(()))
empty(zero-or-one(<e/>/*) is zero-or-one(<e/>/*))
<e><?name data?></e>/processing-instruction()/..
encode-for-uri('')
encode-for-uri('',())
encode-for-uri(())
encode-for-uri()
encode-for-uri("100% organic")
encode-for-uri(12)
encode-for-uri("~bébé")
encode-for-uri(()) eq ""
(encode-for-uri( 'http://datypic.com/a%20URI#frag'))
encode-for-uri("http://example.com/", "wrong param")
(encode-for-uri( 'Sales % Numbers.pdf'))
(encode-for-uri( 'Sales % Numbers.pdf'), encode-for-uri( 'http://datypic.com/a%20URI#frag'))
encoding :localName
(:encoding "utf-8xx":)xquery version "1.0"; <bib/>
(:encoding "UTF-8XX":)xquery version "1.0" encoding "UTF-8"; 1 eq 1
ends-with(())
ends-with((), ())
ends-with()
ends-with('a', 'b', 'http://www.cbcl.co.u,/collation')
ends-with("a string", "a string", "http://www.example.com/COLLATION/NOT/SUPPORTED")
ends-with((), (), "http://www.w3.org/2005/xpath-functions/collation/codepoint", "wrong param")
(ends-with('query', ''))
(ends-with('query', 'query'))
(ends-with('query ', 'y'))
(ends-with('query', 'y'))
(ends-with('query', 'y'), ends-with('query', 'query'), ends-with('query', ''), ends-with('query ', 'y'), ends-with('', 'y'))
ends-with("tattoo", "tattoo")
(ends-with('', 'y'))
'en-gb' castable as xs:language
<!-- <<<>><&%(/?=(=)&entity;-]]> -->
<e/>/processing-instruction(1))
<e/>/processing-instruction(prefix:ncname))
"""" eq '"'
'' eq ''
'''' eq "'"
(() ||  ()) eq ""
() eq ()
<!-- - - - - - - - - - - - - - - - - --> eq " - - - - - - - - - - - - - - - - "
[] eq ()
(() != ()) eq false()
'equals' eq 'equals'
<e/>/(some $b in 1, $v in self::node() satisfies $v)
<e/>/(some $v in self::node() satisfies $v)
<e>some text</e>/text()/..
<e/>/(typeswitch (self::node()) case $i as node() return . default return 1)
every $aaa in (3, 3, 3), $bbb in (3, 3, 3) satisfies $aaa + $bbb eq 6
every $a as empty-sequence() in (), $b as xs:integer in $a satisfies $b
every $a as empty-sequence()? in (1, 2) satisfies $a
every $a as item() at $p in (1, 2) satisfies $a
every $a as item()* in (1, 2), $b as item()* in $a satisfies $b
every $a as item()+ in (1, 2), $b as item()+ in $a satisfies $b
every $a as item()? in (1, 2), $b as item()? in $a satisfies $b
every $a as item()* in (1, 2), $b as xs:integer in $a satisfies $b
every $a as xs:integer in (1, 2), $b as xs:integer in $a satisfies $b
every $a as xs:integer+ in (1, 2), $b as xs:integer in $a satisfies $b
every $a at $p in (1, 2) satisfies $a
every $a in 1, $b in $b satisfies 1
every $a in (1, 2), $b in $a satisfies $b
every $a in (1, 2), $b in (1, 2), $c in (1, 2) satisfies 1, $a
every $a in (1, 2), $b in (1, 2), $c in (1, 2) satisfies 1, $b
every $a in (1, 2), $b in (1, 2), $c in (1, 2) satisfies 1, $c
every $a in (1, 2), $b in (1, 2) satisfies 1, $b
every $a in (1, 2, 3), $b in ($a, 4) satisfies $b gt 0
every $a in (1, 2, 3), $b in (1, 2, 3, $b) satisfies ($a eq $b)
every $foo in ($foo, 2, 3) satisfies 1
every $foo in $foo satisfies 1
every $foo in (1, $2) return 1
every $foo in (1, $foo, 3) satisfies 1
every $foo in (1, $foo) satisfies 1
every $foo in (1, 2, $foo) satisfies 1
every $foo in 1 satisfies $bar + (every $bar in 2 satisfies $bar)
every $foo in 1 satisfies $bar + (some $bar in 2 satisfies $bar)
every $foo in 1 satisfies $foo eq "1"
every $foo in 1 satisfies $NOTEXIST
every $foo in 1 satisfies 1
every $foo in 1 satisfies "a string"
every $foo in 1 satisfies QName("example.com/", "ncname")
every $foo in 1 satisfies true()
EVERY $i in (1, 2, 3) satisfies $i
every $i in (1, 2, 3) satisfies ($i, $i)
every $i in (1, 2, 3) satisfies count($i)
every $i in () satisfies $i
(every $s in tokenize('　〿,　、。〃〄々〆〇〈〉《》「」『』【】〒〓〔〕〖〗〘〙〚〛〜〝〞〟〠〡〢〣〤〥〦〧〨〩〪〭〮〯〫〬〰〱〲〳〴〵〶〷〸〹〺〻〼〽〾〿', ',') satisfies matches($s, '^(?:\p{IsCJKSymbolsandPunctuation}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCJKSymbolsandPunctuation}+)$')))
(every $s in tokenize('    !"#$%''''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~', '') satisfies matches($s, '^(?:\p{IsBasicLatin}+)$')) and (every $s in tokenize('', '') satisfies not(matches($s, '^(?:\p{IsBasicLatin}+)$')))
(every $s in tokenize('＀￯,＀！＂＃＄％＆＇（）＊＋，－．／０１２３４５６７８９：；＜＝＞？＠ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸＹＺ［＼］＾＿｀ａｂｃｄｅｆｇｈｉｊｋｌｍｎｏｐｑｒｓｔｕｖｗｘｙｚ｛｜｝～｟｠｡｢｣､･ｦｧｨｩｪｫｬｭｮｯｰｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐﾑﾒﾓﾔﾕﾖﾗﾘﾙﾚﾛﾜﾝﾞﾟﾠﾡﾢﾣﾤﾥﾦﾧﾨﾩﾪﾫﾬﾭﾮﾯﾰﾱﾲﾳﾴﾵﾶﾷﾸﾹﾺﾻﾼﾽﾾ﾿￀￁ￂￃￄￅￆￇ￈￉ￊￋￌￍￎￏ￐￑ￒￓￔￕￖￗ￘￙ￚￛￜ￝￞￟￠￡￢￣￤￥￦￧￨￩￪￫￬￭￮￯', ',') satisfies matches($s, '^(?:\p{IsHalfwidthandFullwidthForms}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsHalfwidthandFullwidthForms}+)$')))
(every $s in tokenize('﹐﹯,﹐﹑﹒﹓﹔﹕﹖﹗﹘﹙﹚﹛﹜﹝﹞﹟﹠﹡﹢﹣﹤﹥﹦﹧﹨﹩﹪﹫﹬﹭﹮﹯', ',') satisfies matches($s, '^(?:\p{IsSmallFormVariants}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsSmallFormVariants}+)$')))
(every $s in tokenize(',#$', ',') satisfies matches($s, '^(?:[\P{L}*]{0,2})$')) and (every $s in tokenize('!$#,A', ',') satisfies not(matches($s, '^(?:[\P{L}*]{0,2})$')))
(every $s in tokenize('԰֏,԰ԱԲԳԴԵԶԷԸԹԺԻԼԽԾԿՀՁՂՃՄՅՆՇՈՉՊՋՌՍՎՏՐՑՒՓՔՕՖ՗՘ՙ՚՛՜՝՞՟ՠաբգդեզէըթժիլխծկհձղճմյնշոչպջռսվտրցւփքօֆևֈ։֊֋֌֍֎֏', ',') satisfies matches($s, '^(?:\p{IsArmenian}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsArmenian}+)$')))
(every $s in tokenize('₠⃏,₠₡₢₣₤₥₦₧₨₩₪₫€₭₮₯₰₱₲₳₴₵₶₷₸₹₺₻₼₽₾₿⃀⃁⃂⃃⃄⃅⃆⃇⃈⃉⃊⃋⃌⃍⃎⃏', ',') satisfies matches($s, '^(?:\p{IsCurrencySymbols}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCurrencySymbols}+)$')))
(every $s in tokenize('⁄￢₠₠￦゛゛￣㆐㆐𝇝', ',') satisfies matches($s, '^(?:\p{S}*)$')) and (every $s in tokenize(' ', ',') satisfies not(matches($s, '^(?:\p{S}*)$')))
(every $s in tokenize('₠￦', ',') satisfies matches($s, '^(?:\p{Sc}*)$')) and (every $s in tokenize('゛', ',') satisfies not(matches($s, '^(?:\p{Sc}*)$')))
(every $s in tokenize('₠', ',') satisfies matches($s, '^(?:\P{C}*)$')) and (every $s in tokenize(' ܏܏󠁸􀀀󰀀󿿽􏿽', ',') satisfies not(matches($s, '^(?:\P{C}*)$')))
(every $s in tokenize('₠', ',') satisfies matches($s, '^(?:\P{Sm}*)$')) and (every $s in tokenize('⁄￢', ',') satisfies not(matches($s, '^(?:\P{Sm}*)$')))
(every $s in tokenize('0,۰,০,੦,૦,୦,௧,౦,೦,൦,๐,໐,༠,၀,០,᠐,０,𝟎,9,٩,۹,९,৯,੯,૯,୯,௯,౯,೯,൯,๙,໙,༩,၉,៩,᠙,９,𝟿', ',') satisfies matches($s, '^(?:\d)$'))          and (every $s in tokenize('),ٙ,ۮ,॥,৥,੥,૥,୥,౥,೥,൥,้,໏,༙,္,፨,៟,᠉,）,𝟍,:,٪,ۺ,॰,ৰ,੹,૰,୰,௰,౰,೰,൰,๚,໚,༪,၊,፲,៪,᠚,：,𝠀', ',') satisfies not(matches($s, '^(?:\d)$')))
(every $s in tokenize('⁰₟,⁰ⁱ⁲⁳⁴⁵⁶⁷⁸⁹⁺⁻⁼⁽⁾ⁿ₀₁₂₃₄₅₆₇₈₉₊₋₌₍₎₏ₐₑₒₓₔₕₖₗₘₙₚₛₜ₝₞₟', ',') satisfies matches($s, '^(?:\p{IsSuperscriptsandSubscripts}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsSuperscriptsandSubscripts}+)$')))
(every $s in tokenize('0,1,2,3,4,5,6,7,8,9,٠,١,٢,٣,٤,٥,٦,٧,٨,٩,۰,۱,۲,۳,۴,۵,۶,۷,۸,۹,०,१,२,३,४,५,६,७,८,९,০,১,২,৩,৪,৫,৬,৭,৮,৯,੦,੧,੨,੩,੪,੫,੬,੭,੮,੯,૦,૧,૨,૩,૪,૫,૬,૭,૮,૯,୦,୧,୨,୩,୪,୫,୬,୭,୮,୯,௧,௨,௩,௪,௫,௬,௭,௮,௯,౦,౧,౨,౩,౪,౫,౬,౭,౮,౯,೦,೧,೨,೩,೪,೫,೬,೭,೮,೯,൦,൧,൨,൩,൪,൫,൬,൭,൮,൯,๐,๑,๒,๓,๔,๕,๖,๗,๘,๙,໐,໑,໒,໓,໔,໕,໖,໗,໘,໙,༠,༡,༢,༣,༤,༥,༦,༧,༨,༩,၀,၁,၂,၃,၄,၅,၆,၇,၈,၉,០,១,២,៣,៤,៥,៦,៧,៨,៩,᠐,᠑,᠒,᠓,᠔,᠕,᠖,᠗,᠘,᠙,０,１,２,３,４,５,６,７,８,９', ',') satisfies matches($s, '^(?:[\d])$')) and (every $s in tokenize(' , , , ,!,",#,$,왣,왤,왥,왦,왧,왨,왩,왪,왫,왬,왭,왮,왯,왰,왱,왲,왳,왴,왵,왶,왷,외,왹,왺,왻,왼,왽,왾,왿,욀,욁,욂,욃,욄,욅,욆,욇,욈,욉,욊,욋,욌,욍,욎,욏,욐,욑,욒,욓,요,욕,욖,욗,욘,욙,욚,욛,욜,욝,욞,욟,욠,욡,욢,욣,욤,욥,욦,욧,욨,용,욪,욫,욬,욭,욮,욯,우,욱,욲,욳,운,욵,욶,욷,울,욹,욺,욻,욼,욽,욾,욿,움,웁,웂,웃,웄,웅,웆,웇,웈,웉,웊,웋,워,웍,웎,웏,원,웑,웒,웓,월,웕,웖,웗,웘,웙,웚,웛,웜,웝,웞,웟,웠,웡,웢,웣,웤,웥,웦,웧,웨,웩,웪,웫,웬,웭,웮,웯,웰,웱,웲,웳,웴,웵,웶,웷,웸,웹,웺,웻,웼,웽,웾,웿,윀,윁,윂,윃,위,윅,윆,윇,윈,윉,윊,윋,윌,윍,윎,윏,윐,윑,윒,윓,윔,윕,윖,윗,윘,윙,윚,윛,윜,윝,윞,윟,유,육,윢,윣,윤,윥,윦,윧,율,윩,윪,윫,윬,윭,윮,윯,윰,윱,윲,윳,윴,융,윶,윷,윸,윹,윺,윻,으,윽,윾,윿,은,읁,읂,읃,을,읅,읆,읇,읈,읉,읊,읋,음,읍,읎,읏,읐,응,읒,읓,읔,읕,읖,읗,의,읙,읚,읛,읜,읝,읞,읟,읠,읡,읢,읣,읤,읥,읦,읧,읨,읩,읪,읫,읬,읭,읮,읯,읰,읱,읲,읳,이,익,읶,읷,인,읹,읺,읻,일,재,잭,잮,잯,잰,잱,잲,잳,잴,잵,잶,잷,잸,잹,잺,잻,잼,잽,잾,잿,쟀,쟁,쟂,쟃,쟄,쟅,쟆,쟇,쟈,쟉,쟊,쟋,쟌,쟍,쟎,쟏,쟐,쟑,쟒,쟓,쟔,쟕,쟖,쟗,쟘,쟙,쟚,쟛,쟜,쟝,쟞,쟟,쟠,쟡,쟢,쟣,쟤,쟥,쟦,쟧,쟨,쟩,쟪,쟫,쟬,쟭,쟮,쟯,쟰,쟱,쟲,쟳,쟴,쟵,쟶,쟷,쟸,쟹,쟺,쟻,쟼,쟽,쟾,쟿,저,적,젂,젃,전,젅,젆,젇,절,젉,젊,젋,젌,젍,젎,젏,점,접,젒,젓,젔,정,젖,젗,젘,젙,젚,젛,제,젝,젞,젟,젠,젡,젢,젣,젤,젥,젦,젧,젨,젩,젪,젫,젬,젭,젮,젯,젰,젱,젲,젳,젴,젵,젶,젷,져,젹,젺,젻,젼,젽,젾,젿,졀,졁,졂,졃,졄,졅,졆,졇,졈,졉,졊,졋'|| ',졌,졍,졎,졏,졐,졑,졒,졓,졔,졕,졖,졗,졘,졙,졚,졛,졜,졝,졞,졟,졠,졡,졢,졣,졤,졥,졦,졧,졨,졩,졪,졫,졬,졭,졮,졯,조,족,졲,졳,존,졵,졶,졷,졸,졹,졺,졻,졼,졽,졾,졿,좀,좁,좂,좃,좄,종,좆,좇,좈,좉,좊,좋,좌,좍,좎,좏,좐,좑,좒,좓,좔,좕,좖,좗,좘,좙,좚,좛,좜,좝,좞,좟,좠,좡,좢,좣,좤,좥,좦,좧,좨,좩,좪,좫,좬,좭,좮,좯,좰,좱,좲,좳,좴,좵,좶,좷,좸,좹,좺,좻,좼,좽,좾,좿,죀,죁,죂,죃,죄,죅,죆,죇,죈,죉,죊,죋,죌,죍,죎,죏,죐,죑,죒,죓,죔,죕,죖,죗,죘,죙,죚,죛,죜,죝,죞,죟,죠,죡,죢,죣,죤,죥,죦,죧,죨,죩,죪,죫,죬,죭,죮,죯,죰,죱,죲,죳,죴,죵,죶,죷,죸,죹,죺,죻,주,죽,죾,죿,준,줁,줂,줃,줄,줅,줆,줇,줈,줉,줊,줋,줌,줍,줎,줏,줐,중,줒,줓,줔,줕,줖,줗,줘,줙,줚,줛,줜,줝,줞,줟,줠,줡,줢,줣,줤,줥,줦,줧,줨,줩,줪,줫,줬,줭,줮,줯,줰,줱,줲,줳,줴,줵,줶,줷,줸,줹,줺,줻,줼,줽,줾,줿,쥀,쥁,쥂,쥃,쥄,쥅,쥆,쥇,쥈,쥉,쥊,쥋,쥌,쥍,쥎,쥏,쥐,쥑,쥒,쥓,쥔,쥕,쥖,쥗,쥘,쥙,쥚,쥛,쥜,쥝,쥞,쥟,쥠,쥡,쥢,쥣,쥤,쥥,쥦,쥧,쥨,쥩,쥪,쥫,쥬,쥭,쥮,쥯,쥰,쥱,쥲,＂,＃,＄,％,＆,＇,（,）,＊,＋,，,－,．,／,：,；,＜,＝,＞,？,＠,Ａ,Ｂ,Ｃ,Ｄ,Ｅ,Ｆ,Ｇ,Ｈ,Ｉ,Ｊ,Ｋ,Ｌ,Ｍ,Ｎ,Ｏ,Ｐ,Ｑ,Ｒ,Ｓ,Ｔ,Ｕ,Ｖ,Ｗ,Ｘ,Ｙ,Ｚ,［,＼,］,＾,＿,｀,ａ,ｂ,ｃ,ｄ,ｅ,ｆ,ｇ,ｈ,ｉ,ｊ,ｋ,ｌ,ｍ,ｎ,ｏ,ｐ,ｑ,ｒ,ｓ,ｔ,ｕ,ｖ,ｗ,ｘ,ｙ,ｚ,｛,｜,｝,～,｟,｠,｡,｢,｣,､,･,ｦ,ｧ,ｨ,ｩ,ｪ,ｫ,ｬ,ｭ,ｮ,ｯ,ｰ,ｱ,ｲ,ｳ,ｴ,ｵ,ｶ,ｷ,ｸ,ｹ,ｺ,ｻ,ｼ,ｽ,ｾ,ｿ,ﾀ,ﾁ,ﾂ,ﾃ,ﾄ,ﾅ,ﾆ,ﾇ,ﾈ,ﾉ,ﾊ,ﾋ,ﾌ,ﾍ,￢,￣,￤,￥,￦,￧,￨,￩,￪,￫,￬,￭,￮,￯,￰,￱,￲,￳,￴,￵,￶,￷,￸,￹,￺,￻,￼,�', ',') satisfies not(matches($s, '^(?:[\d])$')))
(every $s in tokenize('᠀᢯,᠀᠁᠂᠃᠄᠅᠆᠇᠈᠉᠊᠋᠌᠍᠎᠏᠐᠑᠒᠓᠔᠕᠖᠗᠘᠙᠚᠛᠜᠝᠞᠟ᠠᠡᠢᠣᠤᠥᠦᠧᠨᠩᠪᠫᠬᠭᠮᠯᠰᠱᠲᠳᠴᠵᠶᠷᠸᠹᠺᠻᠼᠽᠾᠿᡀᡁᡂᡃᡄᡅᡆᡇᡈᡉᡊᡋᡌᡍᡎᡏᡐᡑᡒᡓᡔᡕᡖᡗᡘᡙᡚᡛᡜᡝᡞᡟᡠᡡᡢᡣᡤᡥᡦᡧᡨᡩᡪᡫᡬᡭᡮᡯᡰᡱᡲᡳᡴᡵᡶᡷᡸ᡹᡺᡻᡼᡽᡾᡿ᢀᢁᢂᢃᢄᢅᢆᢇᢈᢉᢊᢋᢌᢍᢎᢏᢐᢑᢒᢓᢔᢕᢖᢗᢘᢙᢚᢛᢜᢝᢞᢟᢠᢡᢢᢣᢤᢥᢦᢧᢨᢩᢪ᢫᢬᢭᢮᢯', ',') satisfies matches($s, '^(?:\p{IsMongolian}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsMongolian}+)$')))
(every $s in tokenize('--03-14', ',') satisfies matches($s, '^(?:--0[123]\-(12|14))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:--0[123]\-(12|14))$')))
(every $s in tokenize('０𝟿', ',') satisfies matches($s, '^(?:\p{Nd}*)$')) and (every $s in tokenize('𐍊', ',') satisfies not(matches($s, '^(?:\p{Nd}*)$')))
(every $s in tokenize('０𝟿𐍊𐍊〥²²𐌣', ',') satisfies matches($s, '^(?:\p{N}*)$')) and (every $s in tokenize('ः', ',') satisfies not(matches($s, '^(?:\p{N}*)$')))
(every $s in tokenize('0', ',') satisfies matches($s, '^(?:(1|true|false|0|0))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(1|true|false|0|0))$')))
(every $s in tokenize('０', ',') satisfies matches($s, '^(?:\P{Me}*)$')) and (every $s in tokenize('⃝⃠', ',') satisfies not(matches($s, '^(?:\P{Me}*)$')))
(every $s in tokenize('10000101,10000201', ',') satisfies matches($s, '^(?:\p{Nd}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Nd}+)$')))
(every $s in tokenize('1.001,1.001', ',') satisfies matches($s, '^(?:\d*\.\d+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\d*\.\d+)$')))
(every $s in tokenize('①⓿,①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳⑴⑵⑶⑷⑸⑹⑺⑻⑼⑽⑾⑿⒀⒁⒂⒃⒄⒅⒆⒇⒈⒉⒊⒋⒌⒍⒎⒏⒐⒑⒒⒓⒔⒕⒖⒗⒘⒙⒚⒛⒜⒝⒞⒟⒠⒡⒢⒣⒤⒥⒦⒧⒨⒩⒪⒫⒬⒭⒮⒯⒰⒱⒲⒳⒴⒵ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏⓐⓑⓒⓓⓔⓕⓖⓗⓘⓙⓚⓛⓜⓝⓞⓟⓠⓡⓢⓣⓤⓥⓦⓧⓨⓩ⓪⓫⓬⓭⓮⓯⓰⓱⓲⓳⓴⓵⓶⓷⓸⓹⓺⓻⓼⓽⓾⓿', ',') satisfies matches($s, '^(?:\p{IsEnclosedAlphanumerics}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsEnclosedAlphanumerics}+)$')))
(every $s in tokenize('11:00:00,13:20:00-05:00', ',') satisfies matches($s, '^(?:\p{Nd}{2}:\d\d:\d\d(\-\d\d:\d\d)?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Nd}{2}:\d\d:\d\d(\-\d\d:\d\d)?)$')))
(every $s in tokenize('1111,11001010', ',') satisfies matches($s, '^(?:([0-1]{4}|(0|1){8}))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:([0-1]{4}|(0|1){8}))$')))
(every $s in tokenize('-11111,-9', ',') satisfies matches($s, '^(?:\-[0-9]*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\-[0-9]*)$')))
(every $s in tokenize('1111', ',') satisfies matches($s, '^(?:\p{Nd}\d+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Nd}\d+)$')))
(every $s in tokenize('112233123,abcaabbccabc,abab', ',') satisfies matches($s, '^(?:([abc]+)|([123]+))$')) and (every $s in tokenize('1a,1a,x', ',') satisfies not(matches($s, '^(?:([abc]+)|([123]+))$')))
(every $s in tokenize('112233123,abcaabbccabc', ',') satisfies matches($s, '^(?:[123]+|[abc]+)$')) and (every $s in tokenize('1a,a1', ',') satisfies not(matches($s, '^(?:[123]+|[abc]+)$')))
(every $s in tokenize('+1,1,+9', ',') satisfies matches($s, '^(?:\+?\d)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\+?\d)$')))
(every $s in tokenize('123,12', ',') satisfies matches($s, '^(?:\d+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\d+)$')))
(every $s in tokenize('1234567890:;<=>?@Azaz', ',') satisfies matches($s, '^(?:[0-z]*)$')) and (every $s in tokenize('{,/', ',') satisfies not(matches($s, '^(?:[0-z]*)$')))
(every $s in tokenize('✀➿,✀✁✂✃✄✅✆✇✈✉✊✋✌✍✎✏✐✑✒✓✔✕✖✗✘✙✚✛✜✝✞✟✠✡✢✣✤✥✦✧✨✩✪✫✬✭✮✯✰✱✲✳✴✵✶✷✸✹✺✻✼✽✾✿❀❁❂❃❄❅❆❇❈❉❊❋❌❍❎❏❐❑❒❓❔❕❖❗❘❙❚❛❜❝❞❟❠❡❢❣❤❥❦❧❨❩❪❫❬❭❮❯❰❱❲❳❴❵❶❷❸❹❺❻❼❽❾❿➀➁➂➃➄➅➆➇➈➉➊➋➌➍➎➏➐➑➒➓➔➕➖➗➘➙➚➛➜➝➞➟➠➡➢➣➤➥➦➧➨➩➪➫➬➭➮➯➰➱➲➳➴➵➶➷➸➹➺➻➼➽➾➿', ',') satisfies matches($s, '^(?:\p{IsDingbats}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsDingbats}+)$')))
(every $s in tokenize('1234', ',') satisfies matches($s, '^(?:\I*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\I*)$')))
(every $s in tokenize('123', ',') satisfies matches($s, '^(?:[1-3]{1,4})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[1-3]{1,4})$')))
(every $s in tokenize('123', ',') satisfies matches($s, '^(?:\d+\d+\d+)$')) and (every $s in tokenize('12', ',') satisfies not(matches($s, '^(?:\d+\d+\d+)$')))
(every $s in tokenize('-128', ',') satisfies matches($s, '^(?:((\-|\+)?[1-127])|(\-?128))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:((\-|\+)?[1-127])|(\-?128))$')))
(every $s in tokenize('--12--', ',') satisfies matches($s, '^(?:--((0[1-9])|(1(1|2)))--)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:--((0[1-9])|(1(1|2)))--)$')))
(every $s in tokenize('1,3', ',') satisfies matches($s, '^(?:[13])$')) and (every $s in tokenize('2', ',') satisfies not(matches($s, '^(?:[13])$')))
(every $s in tokenize('⅐↏,⅐⅑⅒⅓⅔⅕⅖⅗⅘⅙⅚⅛⅜⅝⅞⅟ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫⅬⅭⅮⅯⅰⅱⅲⅳⅴⅵⅶⅷⅸⅹⅺⅻⅼⅽⅾⅿↀↁↂↃↄↅↆↇↈ↉↊↋↌↍↎↏', ',') satisfies matches($s, '^(?:\p{IsNumberForms}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsNumberForms}+)$')))
(every $s in tokenize('1999-12-12', ',') satisfies matches($s, '^(?:\p{Nd}{4}-\p{Nd}{2}-\p{Nd}{2})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Nd}{4}-\p{Nd}{2}-\p{Nd}{2})$')))
(every $s in tokenize('1999', ',') satisfies matches($s, '^(?:\p{Nd}{4})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Nd}{4})$')))
(every $s in tokenize('1]', ',') satisfies matches($s, '^(?:[1-\]]+)$')) and (every $s in tokenize('0,^', ',') satisfies not(matches($s, '^(?:[1-\]]+)$')))
(every $s in tokenize('1', ',') satisfies matches($s, '^(?:(1|true))$')) and (every $s in tokenize('0', ',') satisfies not(matches($s, '^(?:(1|true))$')))
(every $s in tokenize('1z', ',') satisfies matches($s, '^(?:[^2-9a-x]{2})$')) and (every $s in tokenize('1x', ',') satisfies not(matches($s, '^(?:[^2-9a-x]{2})$')))
(every $s in tokenize('2001-06-06T12:12:00', ',') satisfies matches($s, '^(?:\p{Nd}{4}-\d\d-\d\dT\d\d:\d\d:\d\d)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Nd}{4}-\d\d-\d\dT\d\d:\d\d:\d\d)$')))
(every $s in tokenize('209.25.0.111', ',') satisfies matches($s, '^(?:([0-9]+(\.[0-9]+){3}))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:([0-9]+(\.[0-9]+){3}))$')))
(every $s in tokenize('²', ',') satisfies matches($s, '^(?:\P{Nl}*)$')) and (every $s in tokenize('𐍊〥', ',') satisfies not(matches($s, '^(?:\P{Nl}*)$')))
(every $s in tokenize('²𐌣', ',') satisfies matches($s, '^(?:\p{No}*)$')) and (every $s in tokenize('‿', ',') satisfies not(matches($s, '^(?:\p{No}*)$')))
(every $s in tokenize('²', ',') satisfies matches($s, '^(?:\P{P}*)$')) and (every $s in tokenize('‿･〜〜－〝〝｢〞〞｣««‹»»›¿¿､', ',') satisfies not(matches($s, '^(?:\P{P}*)$')))
(every $s in tokenize('-300', ',') satisfies matches($s, '^(?:\-?[0-3]{3})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\-?[0-3]{3})$')))
(every $s in tokenize('---30', ',') satisfies matches($s, '^(?:---([123]0)|([12]?[1-9])|(31))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:---([123]0)|([12]?[1-9])|(31))$')))
(every $s in tokenize('9,0', ',') satisfies matches($s, '^(?:[0-9]*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[0-9]*)$')))
(every $s in tokenize('a  123c', ',') satisfies matches($s, '^(?:a\I+\c)$')) and (every $s in tokenize('b123c,a123 123cc', ',') satisfies not(matches($s, '^(?:a\I+\c)$')))
(every $s in tokenize('a1b,ab,ab,name1', ',') satisfies matches($s, '^(?:\c[\c\d]*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\c[\c\d]*)$')))
(every $s in tokenize(',a-1x-7,c-4z-9,a-1z-8a-1z-9,a1z-9,a-1z8,a-1,z-9', ',') satisfies matches($s, '^(?:[a-c-1-4x-z-7-9]*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[a-c-1-4x-z-7-9]*)$')))
(every $s in tokenize(',aa,aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa', ',') satisfies matches($s, '^(?:(a{2})*)$')) and (every $s in tokenize('a,aaa,aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa', ',') satisfies not(matches($s, '^(?:(a{2})*)$')))
(every $s in tokenize('a,aa,aaaaaaaaaaaaaaaaaaaaaaaaaa', ',') satisfies matches($s, '^(?:\c?\c+\c*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\c?\c+\c*)$')))
(every $s in tokenize('aa,aaaa,aaaaaaaaaaaaaaaaaaaa', ',') satisfies matches($s, '^(?:(a{2})+)$')) and (every $s in tokenize(',a,a2,aaa', ',') satisfies not(matches($s, '^(?:(a{2})+)$')))
(every $s in tokenize('a?,a?a?a?,a,a??,aa?', ',') satisfies matches($s, '^(?:[(a\?)?]+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[(a\?)?]+)$')))
(every $s in tokenize('a*a****aaaaa*', ',') satisfies matches($s, '^(?:[\*a]*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[\*a]*)$')))
(every $s in tokenize('aa,a a,a   a', ',') satisfies matches($s, '^(?:a\s{0,3}a)$')) and (every $s in tokenize('a    a,aa a', ',') satisfies not(matches($s, '^(?:a\s{0,3}a)$')))
(every $s in tokenize('a*a**a***,aa*a', ',') satisfies matches($s, '^(?:\c\C?\c\C+\c\C*)$'))          and (every $s in tokenize(',a12b1c1,ab12345,1a2a2,a1b1c1a', ',') satisfies not(matches($s, '^(?:\c\C?\c\C+\c\C*)$')))
(every $s in tokenize('a**,aa*,a', ',') satisfies matches($s, '^(?:[a\*]*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[a\*]*)$')))
(every $s in tokenize('aaabbb,bb,bbb,bbbb', ',') satisfies matches($s, '^(?:a*b{2,4}c{0})$')) and (every $s in tokenize('ab,abbc,bbc,abbbbb,', ',') satisfies not(matches($s, '^(?:a*b{2,4}c{0})$')))
(every $s in tokenize('aaabbbcccdddeeefff', ',') satisfies matches($s, '^(?:(([a-d]*)|(.*)))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(([a-d]*)|(.*)))$')))
(every $s in tokenize('aaabbbcccdddeeefff', ',') satisfies matches($s, '^(?:(([a-d]*)|([a-z]*)))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(([a-d]*)|([a-z]*)))$')))
(every $s in tokenize('aaa', ',') satisfies matches($s, '^(?:(111|aaa))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(111|aaa))$')))
(every $s in tokenize('a--aa---', ',') satisfies matches($s, '^(?:[-a]+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[-a]+)$')))
(every $s in tokenize('a--aa---', ',') satisfies matches($s, '^(?:[a-]*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[a-]*)$')))
(every $s in tokenize(',a,ab, a', ',') satisfies matches($s, '^(?:[^@]{0,2})$')) and (every $s in tokenize('@', ',') satisfies not(matches($s, '^(?:[^@]{0,2})$')))
(every $s in tokenize('a,abcdef', ',') satisfies matches($s, '^(?:\c+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\c+)$')))
(every $s in tokenize('a+*abc', ',') satisfies matches($s, '^(?:([^\?])*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:([^\?])*)$')))
(every $s in tokenize('a*a', ',') satisfies matches($s, '^(?:\c[^\d]\c)$')) and (every $s in tokenize('aa', ',') satisfies not(matches($s, '^(?:\c[^\d]\c)$')))
(every $s in tokenize('abab,ababab,ababababababababababababababababababababababababababababababababab', ',') satisfies matches($s, '^(?:(ab){2,})$')) and (every $s in tokenize('ab,ababa,ababaa,ababababa,abab abab,', ',') satisfies not(matches($s, '^(?:(ab){2,})$')))
(every $s in tokenize(' a    b, a  b, a  b , a    b', ',') satisfies matches($s, '^(?:(\t|\s)a(\r\n|\r|\n|\s)+(\s|\t)b(\s|\r\n|\r|\n)*)$')) and (every $s in tokenize(' a b, a b ', ',') satisfies not(matches($s, '^(?:(\t|\s)a(\r\n|\r|\n|\s)+(\s|\t)b(\s|\r\n|\r|\n)*)$')))
(every $s in tokenize(',a b,a ba b', ',') satisfies matches($s, '^(?:(a\sb){0,2})$')) and (every $s in tokenize('a ba ba b,ab,a b a b,a  b', ',') satisfies not(matches($s, '^(?:(a\sb){0,2})$')))
(every $s in tokenize('ab,abac,abacac', ',') satisfies matches($s, '^(?:((ab)(ac){0,2})?)$')) and (every $s in tokenize('ac,abacacac,abaca,abab,abacabac', ',') satisfies not(matches($s, '^(?:((ab)(ac){0,2})?)$')))
(every $s in tokenize('ab,abc', ',') satisfies matches($s, '^(?:abc?)$')) and (every $s in tokenize('a,bc,abcc,', ',') satisfies not(matches($s, '^(?:abc?)$')))
(every $s in tokenize('abab,', ',') satisfies matches($s, '^(?:((ab){2})?)$')) and (every $s in tokenize('a,ab,ababa,abababab', ',') satisfies not(matches($s, '^(?:((ab){2})?)$')))
(every $s in tokenize('abab', ',') satisfies matches($s, '^(?:[abxyz]+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[abxyz]+)$')))
(every $s in tokenize('a b , a   ', ',') satisfies matches($s, '^(?:\S?\s?\S?\s+)$')) and (every $s in tokenize('a  b, a b,ab', ',') satisfies not(matches($s, '^(?:\S?\s?\S?\s+)$')))
(every $s in tokenize('abbc', ',') satisfies matches($s, '^(?:ab{2}c)$')) and (every $s in tokenize('ac,abc,abbbc,a,', ',') satisfies not(matches($s, '^(?:ab{2}c)$')))
(every $s in tokenize('abc,ab,abccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc', ',') satisfies matches($s, '^(?:abc*)$')) and (every $s in tokenize('a,abcd,abbc,', ',') satisfies not(matches($s, '^(?:abc*)$')))
(every $s in tokenize('abc,abbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbc', ',') satisfies matches($s, '^(?:ab+c)$')) and (every $s in tokenize('ac,bbbc,abbb,', ',') satisfies not(matches($s, '^(?:ab+c)$')))
(every $s in tokenize('abc,abbbbbbbc,ac', ',') satisfies matches($s, '^(?:ab*c)$')) and (every $s in tokenize('a,ab,bc,c,abcb,', ',') satisfies not(matches($s, '^(?:ab*c)$')))
(every $s in tokenize('abc?,abbbc??,abca??,abbbbca?', ',') satisfies matches($s, '^(?:(ab+c)a?\?\??)$')) and (every $s in tokenize('ac??,bc??,abc,abc???', ',') satisfies not(matches($s, '^(?:(ab+c)a?\?\??)$')))
(every $s in tokenize('abc,abccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc', ',') satisfies matches($s, '^(?:abc+)$')) and (every $s in tokenize('a,ab,abcd', ',') satisfies not(matches($s, '^(?:abc+)$')))
(every $s in tokenize('abcc,abccc,abbcc,abbccc,bbcc,bbccc', ',') satisfies matches($s, '^(?:a{0,1}b{1,2}c{2,3})$')) and (every $s in tokenize('aabcc,bbbcc,acc,aabcc,abbc,abbcccc', ',') satisfies not(matches($s, '^(?:a{0,1}b{1,2}c{2,3})$')))
(every $s in tokenize('abcc', ',') satisfies matches($s, '^(?:abc{2})$')) and (every $s in tokenize('abc,abccc,', ',') satisfies not(matches($s, '^(?:abc{2})$')))
(every $s in tokenize('ab.cc', ',') satisfies matches($s, '^(?:a+\.?b*\.+c{2})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:a+\.?b*\.+c{2})$')))
(every $s in tokenize('_:abcdefghijklmnopqrstuvwxyzAZ:_', ',') satisfies matches($s, '^(?:\i*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\i*)$')))
(every $s in tokenize('a,b,c,d', ',') satisfies matches($s, '^(?:a|b|a|c|b|d|a)$')) and (every $s in tokenize('aa,ac,e', ',') satisfies not(matches($s, '^(?:a|b|a|c|b|d|a)$')))
(every $s in tokenize('\.abcd,\sssss,\SSSSSS,\iiiiiii,\,\c,\CCCCCC,\ddd,\D,\wwwwwww,\WWW', ';') satisfies matches($s, '^(?:\\.*,\\s*,\\S*,\\i*,\\I?,\\c+,\\C+,\\d{0,3},\\D{1,1000},\\w*,\\W+)$')) and (every $s in tokenize('', ';') satisfies not(matches($s, '^(?:\\.*,\\s*,\\S*,\\i*,\\I?,\\c+,\\C+,\\d{0,3},\\D{1,1000},\\w*,\\W+)$')))
(every $s in tokenize('abc\nsfc', ',') satisfies matches($s, '^(?:(.*))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(.*))$')))
(every $s in tokenize(' abc       ', ',') satisfies matches($s, '^(?: ([^/]+)       )$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?: ([^/]+)       )$')))
(every $s in tokenize('abc', ',') satisfies matches($s, '^(?:[a-abc]{3})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[a-abc]{3})$')))
(every $s in tokenize('?a?,?b?,?c?', ',') satisfies matches($s, '^(?:[\C\?a-c\?]+)$')) and (every $s in tokenize('?d?', ',') satisfies not(matches($s, '^(?:[\C\?a-c\?]+)$')))
(every $s in tokenize(' a b c ', ',') satisfies matches($s, '^(?:\na\nb\nc\n)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\na\nb\nc\n)$')))
(every $s in tokenize('abc', ',') satisfies matches($s, '^(?:[^\s]{3})$')) and (every $s in tokenize('a c', ',') satisfies not(matches($s, '^(?:[^\s]{3})$')))
(every $s in tokenize(' a b c ', ',') satisfies matches($s, '^(?:\ta\tb\tc\t)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\ta\tb\tc\t)$')))
(every $s in tokenize('abcxyz}', ',') satisfies matches($s, '^(?:[a-\}]+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[a-\}]+)$')))
(every $s in tokenize('a b  c  Z  :_   d y  b     ', ',') satisfies matches($s, '^(?:[\s\i]*)$')) and (every $s in tokenize('1', ',') satisfies not(matches($s, '^(?:[\s\i]*)$')))
(every $s in tokenize('a,b', ',') satisfies matches($s, '^(?:a|b)$')) and (every $s in tokenize('aa,bb,ab,', ',') satisfies not(matches($s, '^(?:a|b)$')))
(every $s in tokenize('ab', ',') satisfies matches($s, '^(?:ab)$')) and (every $s in tokenize('a,b,aa,bb,', ',') satisfies not(matches($s, '^(?:ab)$')))
(every $s in tokenize('ab', ',') satisfies matches($s, '^(?:[\i\c]*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[\i\c]*)$')))
(every $s in tokenize('a:b', ',') satisfies matches($s, '^(?:[\i\c]+:[\i\c]+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[\i\c]+:[\i\c]+)$')))
(every $s in tokenize('   a c  a      ,aa a', ',') satisfies matches($s, '^(?:\s*\c\s?\c\s+\c\s*)$')) and (every $s in tokenize(' a  a a,aaa, a aa ', ',') satisfies not(matches($s, '^(?:\s*\c\s?\c\s+\c\s*)$')))
(every $s in tokenize('ac,abc', ',') satisfies matches($s, '^(?:ab?c)$')) and (every $s in tokenize('a,ab,bc,', ',') satisfies not(matches($s, '^(?:ab?c)$')))
(every $s in tokenize('℀⅏,℀℁ℂ℃℄℅℆ℇ℈℉ℊℋℌℍℎℏℐℑℒℓ℔ℕ№℗℘ℙℚℛℜℝ℞℟℠℡™℣ℤ℥Ω℧ℨ℩KÅℬℭ℮ℯℰℱℲℳℴℵℶℷℸℹ℺℻ℼℽℾℿ⅀⅁⅂⅃⅄ⅅⅆⅇⅈⅉ⅊⅋⅌⅍ⅎ⅏', ',') satisfies matches($s, '^(?:\p{IsLetterlikeSymbols}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsLetterlikeSymbols}+)$')))
(every $s in tokenize('̴̵̶̷̸̡̢̧̨̛̖̗̘̙̜̝̞̟̠̣̤̥̦̩̪̫̬̭̮̯̰̱̲̳̹̺̻̼͇͈͉͍͎̀́̂̃̄̅̆̇̈̉̊̋̌̍̎̏̐̑̒̓̔̽̾̿̀́͂̓̈́͆͊͋͌̕̚ͅ͏͓͔͕͖͙͚͐͑͒͗͛ͣͤͥͦͧͨͩͪͫͬͭͮͯ͘͜͟͢͝͞͠͡', ',') satisfies matches($s, '^(?:\p{IsCombiningDiacriticalMarks}+)$')) and (every $s in tokenize('a', ',') satisfies not(matches($s, '^(?:\p{IsCombiningDiacriticalMarks}+)$')))
(every $s in tokenize('AF01D1', ',') satisfies matches($s, '^(?:AF01D1)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:AF01D1)$')))
(every $s in tokenize('Āſ,ĀāĂăĄąĆćĈĉĊċČčĎďĐđĒēĔĕĖėĘęĚěĜĝĞğĠġĢģĤĥĦħĨĩĪīĬĭĮįİıĲĳĴĵĶķĸĹĺĻļĽľĿŀŁłŃńŅņŇňŉŊŋŌōŎŏŐőŒœŔŕŖŗŘřŚśŜŝŞşŠšŢţŤťŦŧŨũŪūŬŭŮůŰűŲųŴŵŶŷŸŹźŻżŽžſ', ',') satisfies matches($s, '^(?:\p{IsLatinExtended-A}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsLatinExtended-A}+)$')))
(every $s in tokenize('a, ', ',') satisfies matches($s, '^(?:.)$')) and (every $s in tokenize('aa,', ',') satisfies not(matches($s, '^(?:.)$')))
(every $s in tokenize('a', ',') satisfies matches($s, '^(?:a)$')) and (every $s in tokenize('aa,b,', ',') satisfies not(matches($s, '^(?:a)$')))
(every $s in tokenize('a', ',') satisfies matches($s, '^(?:a|a)$')) and (every $s in tokenize('aa,b,', ',') satisfies not(matches($s, '^(?:a|a)$')))
(every $s in tokenize('a', ',') satisfies matches($s, '^(?:[a-a])$')) and (every $s in tokenize('b', ',') satisfies not(matches($s, '^(?:[a-a])$')))
(every $s in tokenize('       a', ',') satisfies matches($s, '^(?:       a|b      )$')) and (every $s in tokenize('abc', ',') satisfies not(matches($s, '^(?:       a|b      )$')))
(every $s in tokenize('_,:,a', ',') satisfies matches($s, '^(?:\c)$')) and (every $s in tokenize(' , , , ', ',') satisfies not(matches($s, '^(?:\c)$')))
(every $s in tokenize('_,:,a', ',') satisfies matches($s, '^(?:\i)$')) and (every $s in tokenize(' , , , ', ',') satisfies not(matches($s, '^(?:\i)$')))
(every $s in tokenize('a', ',') satisfies matches($s, '^(?:[^\P{IsBasicLatin}])$')) and (every $s in tokenize('Ā', ',') satisfies not(matches($s, '^(?:[^\P{IsBasicLatin}])$')))
(every $s in tokenize('Ā', ',') satisfies matches($s, '^(?:[^\p{IsBasicLatin}]+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[^\p{IsBasicLatin}]+)$')))
(every $s in tokenize('\a', ',') satisfies matches($s, '^(?:\\\p{L}*)$')) and (every $s in tokenize('a', ',') satisfies not(matches($s, '^(?:\\\p{L}*)$')))
(every $s in tokenize('a', ',') satisfies matches($s, '^(?:\P{Lu}*)$')) and (every $s in tokenize('A𝞨', ',') satisfies not(matches($s, '^(?:\P{Lu}*)$')))
(every $s in tokenize('a', ',') satisfies matches($s, '^(?:\S)$')) and (every $s in tokenize(' , , , ,aa', ',') satisfies not(matches($s, '^(?:\S)$')))
(every $s in tokenize('a-x', ',') satisfies matches($s, '^(?:[a-a-x-x]+)$')) and (every $s in tokenize('j,a-b', ',') satisfies not(matches($s, '^(?:[a-a-x-x]+)$')))
(every $s in tokenize('aX', ',') satisfies matches($s, '^(?:[\p{L}*]{0,2})$')) and (every $s in tokenize('aBC', ',') satisfies not(matches($s, '^(?:[\p{L}*]{0,2})$')))
(every $s in tokenize('Ḁỿ,ḀḁḂḃḄḅḆḇḈḉḊḋḌḍḎḏḐḑḒḓḔḕḖḗḘḙḚḛḜḝḞḟḠḡḢḣḤḥḦḧḨḩḪḫḬḭḮḯḰḱḲḳḴḵḶḷḸḹḺḻḼḽḾḿṀṁṂṃṄṅṆṇṈṉṊṋṌṍṎṏṐṑṒṓṔṕṖṗṘṙṚṛṜṝṞṟṠṡṢṣṤṥṦṧṨṩṪṫṬṭṮṯṰṱṲṳṴṵṶṷṸṹṺṻṼṽṾṿẀẁẂẃẄẅẆẇẈẉẊẋẌẍẎẏẐẑẒẓẔẕẖẗẘẙẚẛẜẝẞẟẠạẢảẤấẦầẨẩẪẫẬậẮắẰằẲẳẴẵẶặẸẹẺẻẼẽẾếỀềỂểỄễỆệỈỉỊịỌọỎỏỐốỒồỔổỖỗỘộỚớỜờỞởỠỡỢợỤụỦủỨứỪừỬửỮữỰựỲỳỴỵỶỷỸỹỺỻỼỽỾỿ', ',') satisfies matches($s, '^(?:\p{IsLatinExtendedAdditional}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsLatinExtendedAdditional}+)$')))
(every $s in tokenize('a𝟉', ',') satisfies matches($s, '^(?:\p{Ll}*)$')) and (every $s in tokenize('ǅ', ',') satisfies not(matches($s, '^(?:\p{Ll}*)$')))
(every $s in tokenize('A𝞨', ',') satisfies matches($s, '^(?:\p{Lu}*)$')) and (every $s in tokenize('a', ',') satisfies not(matches($s, '^(?:\p{Lu}*)$')))
(every $s in tokenize('ɐʯ,ɐɑɒɓɔɕɖɗɘəɚɛɜɝɞɟɠɡɢɣɤɥɦɧɨɩɪɫɬɭɮɯɰɱɲɳɴɵɶɷɸɹɺɻɼɽɾɿʀʁʂʃʄʅʆʇʈʉʊʋʌʍʎʏʐʑʒʓʔʕʖʗʘʙʚʛʜʝʞʟʠʡʢʣʤʥʦʧʨʩʪʫʬʭʮʯ', ',') satisfies matches($s, '^(?:\p{IsIPAExtensions}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsIPAExtensions}+)$')))
(every $s in tokenize('b,ab,bcccccc,abc,abbbc', ',') satisfies matches($s, '^(?:a?b+c*)$')) and (every $s in tokenize('aabc,a,c,ac,', ',') satisfies not(matches($s, '^(?:a?b+c*)$')))
(every $s in tokenize(',boy0xx,woman1y,girl1xymany,boy0xxwoman1ygirl1xymany,boy0xxwoman1ygirl1xymanyboy0xxwoman1ygirl1xymany', ',') satisfies matches($s, '^(?:(((((boy)|(girl))[0-1][x-z]{2})?)|(man|woman)[0-1]?[y|n])*)$')) and (every $s in tokenize('boy0xxwoman1ygirl1xyman,boyxx', ',') satisfies not(matches($s, '^(?:(((((boy)|(girl))[0-1][x-z]{2})?)|(man|woman)[0-1]?[y|n])*)$')))
(every $s in tokenize('ƀɏ,ƀƁƂƃƄƅƆƇƈƉƊƋƌƍƎƏƐƑƒƓƔƕƖƗƘƙƚƛƜƝƞƟƠơƢƣƤƥƦƧƨƩƪƫƬƭƮƯưƱƲƳƴƵƶƷƸƹƺƻƼƽƾƿǀǁǂǃǄǅǆǇǈǉǊǋǌǍǎǏǐǑǒǓǔǕǖǗǘǙǚǛǜǝǞǟǠǡǢǣǤǥǦǧǨǩǪǫǬǭǮǯǰǱǲǳǴǵǶǷǸǹǺǻǼǽǾǿȀȁȂȃȄȅȆȇȈȉȊȋȌȍȎȏȐȑȒȓȔȕȖȗȘșȚțȜȝȞȟȠȡȢȣȤȥȦȧȨȩȪȫȬȭȮȯȰȱȲȳȴȵȶȷȸȹȺȻȼȽȾȿɀɁɂɃɄɅɆɇɈɉɊɋɌɍɎɏ', ',') satisfies matches($s, '^(?:\p{IsLatinExtended-B}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsLatinExtended-B}+)$')))
(every $s in tokenize('c?1 abc,?0 zzz', ',') satisfies matches($s, '^(?:\c?\?\d\s\c+)$')) and (every $s in tokenize('aa?3 c,a?2 ', ',') satisfies not(matches($s, '^(?:\c?\?\d\s\c+)$')))
(every $s in tokenize('ch-a', ',') satisfies matches($s, '^(?:\c{2,4})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\c{2,4})$')))
(every $s in tokenize('\c', ',') satisfies matches($s, '^(?:\\c)$')) and (every $s in tokenize('\p{_xmlC},\\c,\\', ',') satisfies not(matches($s, '^(?:\\c)$')))
(every $s in tokenize('dddeeeccceee', ',') satisfies matches($s, '^(?:(([c-e]*)|(.*)))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(([c-e]*)|(.*)))$')))
(every $s in tokenize('dddeeeccceee', ',') satisfies matches($s, '^(?:(([c-e]*)|([d-f]*)))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(([c-e]*)|([d-f]*)))$')))
(every $s in tokenize('dddeeeccceee', ',') satisfies matches($s, '^(?:(([d-f]*)|(.*)))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(([d-f]*)|(.*)))$')))
(every $s in tokenize('dddeeeccceee', ',') satisfies matches($s, '^(?:(([d-f]*)|([c-e]*)))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(([d-f]*)|([c-e]*)))$')))
(every $s in tokenize('ǅello ǅorld', ',') satisfies matches($s, '^(?:(\p{Lt}\w*)\s(\p{Lt}*\w*))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(\p{Lt}\w*)\s(\p{Lt}*\w*))$')))
(every $s in tokenize('ǅ', ',') satisfies matches($s, '^(?:\P{Ll}*)$')) and (every $s in tokenize('a𝟉', ',') satisfies not(matches($s, '^(?:\P{Ll}*)$')))
(every $s in tokenize('ǅ', ',') satisfies matches($s, '^(?:\P{M}*)$')) and (every $s in tokenize('ً𝆭ः𝅲ः𝅲⃝⃝⃠', ',') satisfies not(matches($s, '^(?:\P{M}*)$')))
(every $s in tokenize('ǅῼ', ',') satisfies matches($s, '^(?:\p{Lt}*)$')) and (every $s in tokenize('ʰ', ',') satisfies not(matches($s, '^(?:\p{Lt}*)$')))
(every $s in tokenize('false', ',') satisfies matches($s, '^(?:false)$')) and (every $s in tokenize('true', ',') satisfies not(matches($s, '^(?:false)$')))
(every $s in tokenize('ﬀﭏ,ﬀﬁﬂﬃﬄﬅﬆ﬇﬈﬉﬊﬋﬌﬍﬎﬏﬐﬑﬒ﬓﬔﬕﬖﬗ﬘﬙﬚﬛﬜יִﬞײַﬠﬡﬢﬣﬤﬥﬦﬧﬨ﬩שׁשׂשּׁשּׂאַאָאּבּגּדּהּוּזּ﬷טּיּךּכּלּ﬽מּ﬿נּסּ﭂ףּפּ﭅צּקּרּשּתּוֹבֿכֿפֿﭏ', ',') satisfies matches($s, '^(?:\p{IsAlphabeticPresentationForms}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsAlphabeticPresentationForms}+)$')))
(every $s in tokenize('first.last@seznam.cz,first-last@seznam.cz', ',') satisfies matches($s, '^(?:[\w\-\.]+@.*)$')) and (every $s in tokenize('first_last@seznam.cz', ',') satisfies not(matches($s, '^(?:[\w\-\.]+@.*)$')))
(every $s in tokenize('Foo Bar,Foo Bar', ',') satisfies matches($s, '^(?:(Foo) (Bar))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(Foo) (Bar))$')))
(every $s in tokenize('fooʰ barʱ', ',') satisfies matches($s, '^(?:(\w+)\s+(\w+))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(\w+)\s+(\w+))$')))
(every $s in tokenize('foo', ',') satisfies matches($s, '^(?:([a-z]*)([\w]))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:([a-z]*)([\w]))$')))
(every $s in tokenize('hellofoo barworld', ',') satisfies matches($s, '^(?:(hello)foo\s+bar(world))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(hello)foo\s+bar(world))$')))
(every $s in tokenize('Hello World,Hello World', ',') satisfies matches($s, '^(?:([\P{Ll}][\p{Ll}]*)\s([\P{Ll}][\p{Ll}]*))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:([\P{Ll}][\p{Ll}]*)\s([\P{Ll}][\p{Ll}]*))$')))
(every $s in tokenize('Hello World,Hello World', ',') satisfies matches($s, '^(?:([\p{Lu}]\w*)\s([\p{Lu}]\w*))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:([\p{Lu}]\w*)\s([\p{Lu}]\w*))$')))
(every $s in tokenize('Hello World', ',') satisfies matches($s, '^(?:(\P{Ll}\p{Ll}*)\s(\P{Ll}\p{Ll}*))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(\P{Ll}\p{Ll}*)\s(\P{Ll}\p{Ll}*))$')))
(every $s in tokenize('Hello World', ',') satisfies matches($s, '^(?:\P{Ll}\p{Ll}*\s\P{Ll}\p{Ll}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\P{Ll}\p{Ll}*\s\P{Ll}\p{Ll}*)$')))
(every $s in tokenize('Hello World', ',') satisfies matches($s, '^(?:(\P{Lt}\w*)\s(\P{Lt}*\w*))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(\P{Lt}\w*)\s(\P{Lt}*\w*))$')))
(every $s in tokenize('Hello World', ',') satisfies matches($s, '^(?:(\p{Lu}\p{Ll}*)\s(\p{Lu}\p{Ll}*))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(\p{Lu}\p{Ll}*)\s(\p{Lu}\p{Ll}*))$')))
(every $s in tokenize('hellO worlD', ',') satisfies matches($s, '^(?:(\P{Lu}+\p{Lu})\s(\P{Lu}+\p{Lu}))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(\P{Lu}+\p{Lu})\s(\P{Lu}+\p{Lu}))$')))
(every $s in tokenize('Hello World', ',') satisfies matches($s, '^(?:(\p{Lu}\w*)\s(\p{Lu}\w*))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(\p{Lu}\w*)\s(\p{Lu}\w*))$')))
(every $s in tokenize('Hello World', ',') satisfies matches($s, '^(?:\p{Lu}(\w*)\s\p{Lu}(\w*))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Lu}(\w*)\s\p{Lu}(\w*))$')))
(every $s in tokenize('ʰ˿,ʰʱʲʳʴʵʶʷʸʹʺʻʼʽʾʿˀˁ˂˃˄˅ˆˇˈˉˊˋˌˍˎˏːˑ˒˓˔˕˖˗˘˙˚˛˜˝˞˟ˠˡˢˣˤ˥˦˧˨˩˪˫ˬ˭ˮ˯˰˱˲˳˴˵˶˷˸˹˺˻˼˽˾˿', ',') satisfies matches($s, '^(?:\p{IsSpacingModifierLetters}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsSpacingModifierLetters}+)$')))
(every $s in tokenize('ʰﾟ', ',') satisfies matches($s, '^(?:\p{Lm}*)$')) and (every $s in tokenize('א', ',') satisfies not(matches($s, '^(?:\p{Lm}*)$')))
(every $s in tokenize('ʰ', ',') satisfies matches($s, '^(?:\P{Lt}*)$')) and (every $s in tokenize('ǅῼ', ',') satisfies not(matches($s, '^(?:\P{Lt}*)$')))
(every $s in tokenize('http://www.foo.com', ',') satisfies matches($s, '^(?:http://\c*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:http://\c*)$')))
(every $s in tokenize('\n', ',') satisfies matches($s, '^(?:\\n)$')) and (every $s in tokenize('n,\\n, ', ',') satisfies not(matches($s, '^(?:\\n)$')))
(every $s in tokenize('P1111Y12M', ',') satisfies matches($s, '^(?:P\p{Nd}{4}Y\p{Nd}{2}M)$')) and (every $s in tokenize('P111Y12M,P1111Y1M,P11111Y12M,P1111Y,P12M,P11111Y00M,P11111Y13M', ',') satisfies not(matches($s, '^(?:P\p{Nd}{4}Y\p{Nd}{2}M)$')))
(every $s in tokenize('Price: 5 dollars', ',') satisfies matches($s, '^(?:(\S+):\W(\d+)\s(\D+))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(\S+):\W(\d+)\s(\D+))$')))
(every $s in tokenize('\r', ',') satisfies matches($s, '^(?:\\r)$')) and (every $s in tokenize('r,\\r, ', ',') satisfies not(matches($s, '^(?:\\r)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:            ((.)+)      )$')) and (every $s in tokenize('abc', ',') satisfies not(matches($s, '^(?:            ((.)+)      )$')))
(every $s in tokenize('@', ',') satisfies matches($s, '^(?:[@])$')) and (every $s in tokenize('a', ',') satisfies not(matches($s, '^(?:[@])$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:)$')) and (every $s in tokenize('a,#x20;,#xD;,#x9;,#xA;', ',') satisfies not(matches($s, '^(?:)$')))
(every $s in tokenize('࿿', ',') satisfies matches($s, '^(?:[࿿])$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[࿿])$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\\-\{^])$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[\\-\{^])$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[^\?])$')) and (every $s in tokenize('?', ',') satisfies not(matches($s, '^(?:[^\?])$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:|)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:|)$')))
(every $s in tokenize('(', ',') satisfies matches($s, '^(?:\()$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\()$')))
(every $s in tokenize(')', ',') satisfies matches($s, '^(?:\))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\))$')))
(every $s in tokenize('*', ',') satisfies matches($s, '^(?:\*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\*)$')))
(every $s in tokenize('+', ',') satisfies matches($s, '^(?:\+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\+)$')))
(every $s in tokenize('-', ',') satisfies matches($s, '^(?:[-])$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[-])$')))
(every $s in tokenize('-', ',') satisfies matches($s, '^(?:\-)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\-)$')))
(every $s in tokenize('.', ',') satisfies matches($s, '^(?:\.)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\.)$')))
(every $s in tokenize('.\?*+{}[]()|', ',') satisfies matches($s, '^(?:\.\\\?\*\+\{\}\[\]\(\)\|)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\.\\\?\*\+\{\}\[\]\(\)\|)$')))
(every $s in tokenize('.\?*+{}[]()|.\?*+{}[]()|.\?*+{}[]()|', ',') satisfies matches($s, '^(?:(([\.\\\?\*\+\{\}\[\]\(\)\|]?)*)+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(([\.\\\?\*\+\{\}\[\]\(\)\|]?)*)+)$')))
(every $s in tokenize('=,>', ',') satisfies matches($s, '^(?:[=->])$')) and (every $s in tokenize('\?', ',') satisfies not(matches($s, '^(?:[=->])$')))
(every $s in tokenize('?', ',') satisfies matches($s, '^(?:\?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\?)$')))
(every $s in tokenize('[', ',') satisfies matches($s, '^(?:\[)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\[)$')))
(every $s in tokenize('\', ',') satisfies matches($s, '^(?:\\)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\\)$')))
(every $s in tokenize('\|.?*+(){}-[]^', ',') satisfies matches($s, '^(?:[\\\|\.\?\*\+\(\)\{\}\-\[\]\^]*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[\\\|\.\?\*\+\(\)\{\}\-\[\]\^]*)$')))
(every $s in tokenize(']', ',') satisfies matches($s, '^(?:\])$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\])$')))
(every $s in tokenize('^', ',') satisfies matches($s, '^(?:\^)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\^)$')))
(every $s in tokenize('{', ',') satisfies matches($s, '^(?:\{)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\{)$')))
(every $s in tokenize('|', ',') satisfies matches($s, '^(?:\|)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\|)$')))
(every $s in tokenize('}', ',') satisfies matches($s, '^(?:\})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\})$')))
(every $s in tokenize('\,[,],\[,\[],[],[\\,\]\,[][', ',') satisfies matches($s, '^(?:[\\\[\]]{0,3})$')) and (every $s in tokenize('\[][,\]\],[][]', ',') satisfies not(matches($s, '^(?:[\\\[\]]{0,3})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:([0-9-[02468]]|[0-9-[13579]])+)$')) and (every $s in tokenize('az1234567890za', ',') satisfies not(matches($s, '^(?:([0-9-[02468]]|[0-9-[13579]])+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:([0-9]+?)([a-z]+?))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:([0-9]+?)([a-z]+?))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:([^0-9-[a-zAE-Z]]|[\w-[a-zAF-Z]])+)$')) and (every $s in tokenize('azBCDE1234567890BCDEFza', ',') satisfies not(matches($s, '^(?:([^0-9-[a-zAE-Z]]|[\w-[a-zAF-Z]])+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(([0-9])|([a-z])|([A-Z]))*)$')) and (every $s in tokenize('{hello 1234567890 world},{HELLO 1234567890 world},{1234567890 hello  world}', ',') satisfies not(matches($s, '^(?:(([0-9])|([a-z])|([A-Z]))*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(([0-9])|([a-z])|([A-Z]))+)$')) and (every $s in tokenize('{hello 1234567890 world},{HELLO 1234567890 world},{1234567890 hello world}', ',') satisfies not(matches($s, '^(?:(([0-9])|([a-z])|([A-Z]))+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:([0-9]+?)([\w]+?))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:([0-9]+?)([\w]+?))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:98[\d-[9]][\d-[8]][\d-[0]])$')) and (every $s in tokenize('98911 98881 98870 98871', ',') satisfies not(matches($s, '^(?:98[\d-[9]][\d-[8]][\d-[0]])$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[^\^a])$')) and (every $s in tokenize('^,a', ',') satisfies not(matches($s, '^(?:[^\^a])$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[a])$')) and (every $s in tokenize('b,', ',') satisfies not(matches($s, '^(?:[a])$')))
(every $s in tokenize('}-', ',') satisfies matches($s, '^(?:[a-\}-]+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[a-\}-]+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:a{0})$')) and (every $s in tokenize('a', ',') satisfies not(matches($s, '^(?:a{0})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:a.{0,5}?c)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:a.{0,5}?c)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(a)|\1)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(a)|\1)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:((((((((((a))))))))))\10)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:((((((((((a))))))))))\10)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:^aa$)$')) and (every $s in tokenize('aA', ',') satisfies not(matches($s, '^(?:^aa$)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:^Aa$)$')) and (every $s in tokenize('aA', ',') satisfies not(matches($s, '^(?:^Aa$)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:aA)$')) and (every $s in tokenize('Aa,Aa', ',') satisfies not(matches($s, '^(?:aA)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:AA)$')) and (every $s in tokenize('Aa,Aa', ',') satisfies not(matches($s, '^(?:AA)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[a-[a-f]])$')) and (every $s in tokenize('abcdefghijklmnopqrstuvwxyz', ',') satisfies not(matches($s, '^(?:[a-[a-f]])$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(ab){0,0})$')) and (every $s in tokenize('a,ab', ',') satisfies not(matches($s, '^(?:(ab){0,0})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(a+|b){0,1}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(a+|b){0,1}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:ab{0,1}?bc)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:ab{0,1}?bc)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:ab{0,1}?c)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:ab{0,1}?c)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[a-b-[0-9]]+)$')) and (every $s in tokenize('a1', ',') satisfies not(matches($s, '^(?:[a-b-[0-9]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:ab{0,}?bc)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:ab{0,}?bc)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:ab{1,3}?bc)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:ab{1,3}?bc)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:ab{1,}?bc)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:ab{1,}?bc)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:ab{3,4}?bc)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:ab{3,4}?bc)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:ab{4,5}?bc)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:ab{4,5}?bc)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:ab*?bc)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:ab*?bc)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:ab+?bc)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:ab+?bc)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:ab??bc)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:ab??bc)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(a+)(b*)(c?))$')) and (every $s in tokenize('aaabbbccc', ',') satisfies not(matches($s, '^(?:(a+)(b*)(c?))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[a\-\[\-\[\-bc]+)$')) and (every $s in tokenize('```bbbaaa---[[[cccddd', ',') satisfies not(matches($s, '^(?:[a\-\[\-\[\-bc]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:ab??c)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:ab??c)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(abc)\1)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(abc)\1)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[abc\--[b]]+)$')) and (every $s in tokenize('[[[```bbbaaa---cccddd', ',') satisfies not(matches($s, '^(?:[abc\--[b]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[abcd-[d]]+)$')) and (every $s in tokenize('dddaabbccddd', ',') satisfies not(matches($s, '^(?:[abcd-[d]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[abcd\-d-[bc]]+)$')) and (every $s in tokenize('bbbaaa---dddccc,bbbaaa---dddccc', ',') satisfies not(matches($s, '^(?:[abcd\-d-[bc]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[abcd-[def]]+)$')) and (every $s in tokenize('fedddaabbccddd', ',') satisfies not(matches($s, '^(?:[abcd-[def]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[abcdef-[^bce]]+)$')) and (every $s in tokenize('adfbcefda', ',') satisfies not(matches($s, '^(?:[abcdef-[^bce]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[abc-[defg]]+)$')) and (every $s in tokenize('dddaabbccddd', ',') satisfies not(matches($s, '^(?:[abc-[defg]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[abc\-z-[b]]+)$')) and (every $s in tokenize('```aaaccc---zzzbbb', ',') satisfies not(matches($s, '^(?:[abc\-z-[b]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(abra(cad)?)+)$')) and (every $s in tokenize('abracadabra1abracadabra2abracadabra3', ',') satisfies not(matches($s, '^(?:(abra(cad)?)+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:a.*?c)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:a.*?c)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:a.+?c)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:a.+?c)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:([a-c]*)\1)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:([a-c]*)\1)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[a-c-[^a-c]])$')) and (every $s in tokenize('d', ',') satisfies not(matches($s, '^(?:[a-c-[^a-c]])$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(([a-c])b*?\2)*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(([a-c])b*?\2)*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(([a-c])b*?\2){3})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(([a-c])b*?\2){3})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:a(.)c(.)e)$')) and (every $s in tokenize('123abcde456aBCDe789', ',') satisfies not(matches($s, '^(?:a(.)c(.)e)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[a-[c-e]]+)$')) and (every $s in tokenize('bbbaaaccc,```aaaccc', ',') satisfies not(matches($s, '^(?:[a-[c-e]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[^a-d-b-c])$')) and (every $s in tokenize('a-b,c-c,ab,cc', ',') satisfies not(matches($s, '^(?:[^a-d-b-c])$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[a-d-[b-c]])$')) and (every $s in tokenize('b,c', ',') satisfies not(matches($s, '^(?:[a-d-[b-c]])$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[a-d\--[bc]]+)$')) and (every $s in tokenize('cccaaa--dddbbb', ',') satisfies not(matches($s, '^(?:[a-d\--[bc]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[a-e - m-p]+)$')) and (every $s in tokenize('---a b c d e m n o p---', ',') satisfies not(matches($s, '^(?:[a-e - m-p]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:a\sb)$')) and (every $s in tokenize('a  b', ',') satisfies not(matches($s, '^(?:a\sb)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[^a-z^])$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[^a-z^])$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:^([a-z0-9]+)@([a-z]+)\.([a-z]+)$)$')) and (every $s in tokenize('bar@bar.foo.com', ',') satisfies not(matches($s, '^(?:^([a-z0-9]+)@([a-z]+)\.([a-z]+)$)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[a-z-[^a]])$')) and (every $s in tokenize('b', ',') satisfies not(matches($s, '^(?:[a-z-[^a]])$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[a-zA-Z0-9-[\s]]+)$')) and (every $s in tokenize('  azAZ09', ',') satisfies not(matches($s, '^(?:[a-zA-Z0-9-[\s]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[a-zA-Z-[aeiouAEIOU]]+)$')) and (every $s in tokenize('aeiouAEIOUbcdfghjklmnpqrstvwxyz', ',') satisfies not(matches($s, '^(?:[a-zA-Z-[aeiouAEIOU]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:([a-z]*?)([\w]))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:([a-z]*?)([\w]))$')))
(every $s in tokenize(' , , , ', ',') satisfies matches($s, '^(?:\C)$')) and (every $s in tokenize('_,:,a', ',') satisfies not(matches($s, '^(?:\C)$')))
(every $s in tokenize('?', ',') satisfies matches($s, '^(?:[\c\?a-c\?]+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[\c\?a-c\?]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:^(cat|chat))$')) and (every $s in tokenize('cats are bad', ',') satisfies not(matches($s, '^(?:^(cat|chat))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[^cde-[ag]]+)$')) and (every $s in tokenize('agbfxyzga', ',') satisfies not(matches($s, '^(?:[^cde-[ag]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:cH)$')) and (every $s in tokenize('Ch,Ch', ',') satisfies not(matches($s, '^(?:cH)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:CH)$')) and (every $s in tokenize('Ch,Ch', ',') satisfies not(matches($s, '^(?:CH)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\c[^\s]\c)$')) and (every $s in tokenize('a c,a z,a c,a r', ',') satisfies not(matches($s, '^(?:\c[^\s]\c)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\-?\d)$')) and (every $s in tokenize('+1', ',') satisfies not(matches($s, '^(?:\-?\d)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[>-D]+)$')) and (every $s in tokenize('eE=>?@ABCDabcdeE', ',') satisfies not(matches($s, '^(?:[>-D]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[@-D]+)$')) and (every $s in tokenize('eE?@ABCDabcdeE', ',') satisfies not(matches($s, '^(?:[@-D]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\d-[13579]]+)$')) and (every $s in tokenize('1024689', ',') satisfies not(matches($s, '^(?:[\d-[13579]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\d-[13579abcd]]+)$')) and (every $s in tokenize('abcd١02468٠', ',') satisfies not(matches($s, '^(?:[\d-[13579abcd]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\d-[13579a-zA-Z]]+)$')) and (every $s in tokenize('AZ1024689', ',') satisfies not(matches($s, '^(?:[\d-[13579a-zA-Z]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\d-[13579\s]]+)$')) and (every $s in tokenize('  ١02468٠', ',') satisfies not(matches($s, '^(?:[\d-[13579\s]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\d-[357]]+)$')) and (every $s in tokenize('33312468955,51246897,3312468977', ',') satisfies not(matches($s, '^(?:[\d-[357]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\d-[357a-z]]+)$')) and (every $s in tokenize('az33312468955', ',') satisfies not(matches($s, '^(?:[\d-[357a-z]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\d-[357\p{Ll}]]+)$')) and (every $s in tokenize('az3312468977', ',') satisfies not(matches($s, '^(?:[\d-[357\p{Ll}]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\d-[abc]]+)$')) and (every $s in tokenize('abc09abc', ',') satisfies not(matches($s, '^(?:[\d-[abc]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\D\?a-c\?]+)$')) and (every $s in tokenize('?1?', ',') satisfies not(matches($s, '^(?:[\D\?a-c\?]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\d-[a-zA-Z]]+)$')) and (every $s in tokenize('az09AZ,azAZ١02468٠', ',') satisfies not(matches($s, '^(?:[\d-[a-zA-Z]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:([\D]*)bar)$')) and (every $s in tokenize('65498foobar58719,65498foobar58719', ',') satisfies not(matches($s, '^(?:([\D]*)bar)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\D*(bar))$')) and (every $s in tokenize('65498foobar58719', ',') satisfies not(matches($s, '^(?:\D*(bar))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\-\d\d)$')) and (every $s in tokenize('11', ',') satisfies not(matches($s, '^(?:\-\d\d)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\d-[\D]]+)$')) and (every $s in tokenize('azAZ1024689', ',') satisfies not(matches($s, '^(?:[\d-[\D]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\d-[de357fgA-Z]]+)$')) and (every $s in tokenize('AZ51246897', ',') satisfies not(matches($s, '^(?:[\d-[de357fgA-Z]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\d+\d+\p{Nd}\d+)$')) and (every $s in tokenize('123', ',') satisfies not(matches($s, '^(?:\d+\d+\p{Nd}\d+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(d+?)(e*?)(f??))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(d+?)(e*?)(f??))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(d)(o)(g)(\s)(c)(a)(t)(\s)(h)(a)(s))$')) and (every $s in tokenize('My dog cat has fleas.,My dog cat has fleas.', ',') satisfies not(matches($s, '^(?:(d)(o)(g)(\s)(c)(a)(t)(\s)(h)(a)(s))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\d-[\p{Ll}]]+)$')) and (every $s in tokenize('az09az', ',') satisfies not(matches($s, '^(?:[\d-[\p{Ll}]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[-e-g]+)$')) and (every $s in tokenize('ddd---eeefffggghhh,ddd---eeefffggghhh', ',') satisfies not(matches($s, '^(?:[-e-g]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(foo)(\176))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(foo)(\176))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(foo)\c)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(foo)\c)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(foo)(\c *)(bar))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(foo)(\c *)(bar))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(foo)(\c*)(bar))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(foo)(\c*)(bar))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(foo)(\c\[*)(bar))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(foo)(\c\[*)(bar))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(foo)(\c\|*)(bar))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(foo)(\c\|*)(bar))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(foo)(\c`*)(bar))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(foo)(\c`*)(bar))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:foo\d+)$')) and (every $s in tokenize('0123456789foo4567890foo         ,0123456789foo4567890foo1foo  0987', ',') satisfies not(matches($s, '^(?:foo\d+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:foo([\d]*)bar)$')) and (every $s in tokenize('hello123foo230927bar1412d,hello123foo230927bar1412d', ',') satisfies not(matches($s, '^(?:foo([\d]*)bar)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(foo)\d*bar)$')) and (every $s in tokenize('hello123foo230927bar1412d', ',') satisfies not(matches($s, '^(?:(foo)\d*bar)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(foo) #foo        \s+ #followed by 1 or more whitespace        (bar)  #followed by bar        )$')) and (every $s in tokenize('foo    bar', ',') satisfies not(matches($s, '^(?:(foo) #foo        \s+ #followed by 1 or more whitespace        (bar)  #followed by bar        )$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(foo) #foo        \s+ #followed by 1 or more whitespace        (bar)  #followed by bar)$')) and (every $s in tokenize('foo    bar', ',') satisfies not(matches($s, '^(?:(foo) #foo        \s+ #followed by 1 or more whitespace        (bar)  #followed by bar)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(foo)([\r]*)(bar))$')) and (every $s in tokenize('foo   bar', ',') satisfies not(matches($s, '^(?:(foo)([\r]*)(bar))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:foo\s+)$')) and (every $s in tokenize('0123456789foo4567890foo         ', ',') satisfies not(matches($s, '^(?:foo\s+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(foo)\S*)$')) and (every $s in tokenize('sfdfoobar    3270', ',') satisfies not(matches($s, '^(?:(foo)\S*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:foo([\S]*))$')) and (every $s in tokenize('sfdfoobar    3270,sfdfoobar    3270', ',') satisfies not(matches($s, '^(?:foo([\S]*))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(foo)\s+(bar))$')) and (every $s in tokenize('before textfoo barafter text,before textfoo barafter text,before textfoo barafter text', ',') satisfies not(matches($s, '^(?:(foo)\s+(bar))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(foo)\s*(bar))$')) and (every $s in tokenize('wiofoo   bar3270', ',') satisfies not(matches($s, '^(?:(foo)\s*(bar))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:foo([\s]*)bar)$')) and (every $s in tokenize('wiofoo   bar3270,wiofoo   bar3270', ',') satisfies not(matches($s, '^(?:foo([\s]*)bar)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(foo)\w*)$')) and (every $s in tokenize('sfdfoobar    3270', ',') satisfies not(matches($s, '^(?:(foo)\w*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:foo([\w]*))$')) and (every $s in tokenize('sfdfoobar    3270,sfdfoobar    3270', ',') satisfies not(matches($s, '^(?:foo([\w]*))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(foo)\W*(bar))$')) and (every $s in tokenize('wiofoo   bar3270', ',') satisfies not(matches($s, '^(?:(foo)\W*(bar))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:foo([\W]*)bar)$')) and (every $s in tokenize('wiofoo   bar3270,wiofoo   bar3270', ',') satisfies not(matches($s, '^(?:foo([\W]*)bar)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(foo\w+)\s+(bar\w+))$')) and (every $s in tokenize('STARTfooー bar々END,STARTfooﾞ barﾟEND', ',') satisfies not(matches($s, '^(?:(foo\w+)\s+(bar\w+))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(hello)\s+(world))$')) and (every $s in tokenize('What the hello world goodby,What the hello world goodby,START hello    world END,START hello    world END', ',') satisfies not(matches($s, '^(?:(hello)\s+(world))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:http://([a-zA-Z0-9\-]*\.?)*?/)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:http://([a-zA-Z0-9\-]*\.?)*?/)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:http://([a-zA-z0-9\-]*\.?)*?(:[0-9]*)??/)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:http://([a-zA-z0-9\-]*\.?)*?(:[0-9]*)??/)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:^http://www.([a-zA-Z0-9]+)\.([a-z]+)$)$')) and (every $s in tokenize('http://www.foo.bar.com', ',') satisfies not(matches($s, '^(?:^http://www.([a-zA-Z0-9]+)\.([a-z]+)$)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\i+)$')) and (every $s in tokenize('a b', ',') satisfies not(matches($s, '^(?:\i+)$')))
(every $s in tokenize(' , , , ', ',') satisfies matches($s, '^(?:\I)$')) and (every $s in tokenize('_,:,a', ',') satisfies not(matches($s, '^(?:\I)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:İ)$')) and (every $s in tokenize('i,i,I,i,I,i', ',') satisfies not(matches($s, '^(?:İ)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:ı)$')) and (every $s in tokenize('I,I,I,i,I,i', ',') satisfies not(matches($s, '^(?:ı)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:m[\w-[^aeiou]][\w-[^aeiou]]t)$')) and (every $s in tokenize('mbbt mect meet', ',') satisfies not(matches($s, '^(?:m[\w-[^aeiou]][\w-[^aeiou]]t)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:([^{}]|\n)+)$')) and (every $s in tokenize('{{{{Hello  World  }END', ',') satisfies not(matches($s, '^(?:([^{}]|\n)+)$')))
(every $s in tokenize(' ', ',') satisfies matches($s, '^(?:[\n])$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[\n])$')))
(every $s in tokenize(' ', ',') satisfies matches($s, '^(?:\n)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\n)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\n\\\r\|\t\.\-\^\?\*\+\{\}\(\)\[\])$')) and (every $s in tokenize(' \ | .-^?*+{}()[,\ | .-^?*+{}()[], \ | -^?*+{}()[]', ',') satisfies not(matches($s, '^(?:\n\\\r\|\t\.\-\^\?\*\+\{\}\(\)\[\])$')))
(every $s in tokenize('\|.-^?*+[]{}()*[[]{}})) *()', ',') satisfies matches($s, '^(?:[\n\r\t\\\|\.\-\^\?\*\+\{\}\[\]\(\)]*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[\n\r\t\\\|\.\-\^\?\*\+\{\}\[\]\(\)]*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{C}*)$')) and (every $s in tokenize('₠', ',') satisfies not(matches($s, '^(?:\p{C}*)$')))
(every $s in tokenize(' ', ',') satisfies matches($s, '^(?:\p{Cc}*)$')) and (every $s in tokenize('܏', ',') satisfies not(matches($s, '^(?:\p{Cc}*)$')))
(every $s in tokenize('܏', ',') satisfies matches($s, '^(?:\P{Cc}*)$')) and (every $s in tokenize(' ', ',') satisfies not(matches($s, '^(?:\P{Cc}*)$')))
(every $s in tokenize('܏󠁸', ',') satisfies matches($s, '^(?:\p{Cf}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Cf}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\P{Cf}*)$')) and (every $s in tokenize('܏󠁸', ',') satisfies not(matches($s, '^(?:\P{Cf}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{Cn}*)$')) and (every $s in tokenize(' ', ',') satisfies not(matches($s, '^(?:\p{Cn}*)$')))
(every $s in tokenize('􀀀󰀀󿿽􏿽', ',') satisfies matches($s, '^(?:(\p{Co})*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(\p{Co})*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{Co}*)$')) and (every $s in tokenize('⁄', ',') satisfies not(matches($s, '^(?:\p{Co}*)$')))
(every $s in tokenize('⁄', ',') satisfies matches($s, '^(?:\P{Co}*)$')) and (every $s in tokenize('􀀀󰀀󿿽􏿽', ',') satisfies not(matches($s, '^(?:\P{Co}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsAlphabeticPresentationForms})$')) and (every $s in tokenize('﫿', ',') satisfies not(matches($s, '^(?:\p{IsAlphabeticPresentationForms})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsAlphabeticPresentationForms}?)$')) and (every $s in tokenize('ﭐ', ',') satisfies not(matches($s, '^(?:\p{IsAlphabeticPresentationForms}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsArabic})$')) and (every $s in tokenize('׿', ',') satisfies not(matches($s, '^(?:\p{IsArabic})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsArabic}?)$')) and (every $s in tokenize('܀', ',') satisfies not(matches($s, '^(?:\p{IsArabic}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsArabicPresentationForms-A}?)$')) and (every $s in tokenize('︠', ',') satisfies not(matches($s, '^(?:\p{IsArabicPresentationForms-A}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsArabicPresentationForms-A})$')) and (every $s in tokenize('ﭏ', ',') satisfies not(matches($s, '^(?:\p{IsArabicPresentationForms-A})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsArabicPresentationForms-B})$')) and (every $s in tokenize('﹯', ',') satisfies not(matches($s, '^(?:\p{IsArabicPresentationForms-B})$')))
(every $s in tokenize('ﹰ﻾', ',') satisfies matches($s, '^(?:\p{IsArabicPresentationForms-B}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsArabicPresentationForms-B}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsArmenian}?)$')) and (every $s in tokenize('֐', ',') satisfies not(matches($s, '^(?:\p{IsArmenian}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsArmenian})$')) and (every $s in tokenize('ӿ', ',') satisfies not(matches($s, '^(?:\p{IsArmenian})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsArrows})$')) and (every $s in tokenize('↏', ',') satisfies not(matches($s, '^(?:\p{IsArrows})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsArrows}?)$')) and (every $s in tokenize('∀', ',') satisfies not(matches($s, '^(?:\p{IsArrows}?)$')))
(every $s in tokenize('←⇿,←↑→↓↔↕↖↗↘↙↚↛↜↝↞↟↠↡↢↣↤↥↦↧↨↩↪↫↬↭↮↯↰↱↲↳↴↵↶↷↸↹↺↻↼↽↾↿⇀⇁⇂⇃⇄⇅⇆⇇⇈⇉⇊⇋⇌⇍⇎⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇚⇛⇜⇝⇞⇟⇠⇡⇢⇣⇤⇥⇦⇧⇨⇩⇪⇫⇬⇭⇮⇯⇰⇱⇲⇳⇴⇵⇶⇷⇸⇹⇺⇻⇼⇽⇾⇿', ',') satisfies matches($s, '^(?:\p{IsArrows}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsArrows}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[^\p{IsBasicLatin}]*)$')) and (every $s in tokenize('a', ',') satisfies not(matches($s, '^(?:[^\p{IsBasicLatin}]*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsBasicLatin}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsBasicLatin}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsBasicLatin})$')) and (every $s in tokenize('ۿ', ',') satisfies not(matches($s, '^(?:\p{IsBasicLatin})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsBengali}?)$')) and (every $s in tokenize('਀', ',') satisfies not(matches($s, '^(?:\p{IsBengali}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsBengali})$')) and (every $s in tokenize('ॿ', ',') satisfies not(matches($s, '^(?:\p{IsBengali})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsBlockElements})$')) and (every $s in tokenize('╿', ',') satisfies not(matches($s, '^(?:\p{IsBlockElements})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsBlockElements}?)$')) and (every $s in tokenize('■', ',') satisfies not(matches($s, '^(?:\p{IsBlockElements}?)$')))
(every $s in tokenize('▀▟,▀▁▂▃▄▅▆▇█▉▊▋▌▍▎▏▐░▒▓▔▕▖▗▘▙▚▛▜▝▞▟', ',') satisfies matches($s, '^(?:\p{IsBlockElements}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsBlockElements}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsBopomofo}?)$')) and (every $s in tokenize('㄰', ',') satisfies not(matches($s, '^(?:\p{IsBopomofo}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsBopomofo})$')) and (every $s in tokenize('ヿ', ',') satisfies not(matches($s, '^(?:\p{IsBopomofo})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsBopomofoExtended}?)$')) and (every $s in tokenize('㈀', ',') satisfies not(matches($s, '^(?:\p{IsBopomofoExtended}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsBopomofoExtended})$')) and (every $s in tokenize('㆟', ',') satisfies not(matches($s, '^(?:\p{IsBopomofoExtended})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsBoxDrawing})$')) and (every $s in tokenize('⓿', ',') satisfies not(matches($s, '^(?:\p{IsBoxDrawing})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsBoxDrawing}?)$')) and (every $s in tokenize('▀', ',') satisfies not(matches($s, '^(?:\p{IsBoxDrawing}?)$')))
(every $s in tokenize('─╿,─━│┃┄┅┆┇┈┉┊┋┌┍┎┏┐┑┒┓└┕┖┗┘┙┚┛├┝┞┟┠┡┢┣┤┥┦┧┨┩┪┫┬┭┮┯┰┱┲┳┴┵┶┷┸┹┺┻┼┽┾┿╀╁╂╃╄╅╆╇╈╉╊╋╌╍╎╏═║╒╓╔╕╖╗╘╙╚╛╜╝╞╟╠╡╢╣╤╥╦╧╨╩╪╫╬╭╮╯╰╱╲╳╴╵╶╷╸╹╺╻╼╽╾╿', ',') satisfies matches($s, '^(?:\p{IsBoxDrawing}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsBoxDrawing}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsBraillePatterns})$')) and (every $s in tokenize('➿', ',') satisfies not(matches($s, '^(?:\p{IsBraillePatterns})$')))
(every $s in tokenize('⠀⣿,⠀⠁⠂⠃⠄⠅⠆⠇⠈⠉⠊⠋⠌⠍⠎⠏⠐⠑⠒⠓⠔⠕⠖⠗⠘⠙⠚⠛⠜⠝⠞⠟⠠⠡⠢⠣⠤⠥⠦⠧⠨⠩⠪⠫⠬⠭⠮⠯⠰⠱⠲⠳⠴⠵⠶⠷⠸⠹⠺⠻⠼⠽⠾⠿⡀⡁⡂⡃⡄⡅⡆⡇⡈⡉⡊⡋⡌⡍⡎⡏⡐⡑⡒⡓⡔⡕⡖⡗⡘⡙⡚⡛⡜⡝⡞⡟⡠⡡⡢⡣⡤⡥⡦⡧⡨⡩⡪⡫⡬⡭⡮⡯⡰⡱⡲⡳⡴⡵⡶⡷⡸⡹⡺⡻⡼⡽⡾⡿⢀⢁⢂⢃⢄⢅⢆⢇⢈⢉⢊⢋⢌⢍⢎⢏⢐⢑⢒⢓⢔⢕⢖⢗⢘⢙⢚⢛⢜⢝⢞⢟⢠⢡⢢⢣⢤⢥⢦⢧⢨⢩⢪⢫⢬⢭⢮⢯⢰⢱⢲⢳⢴⢵⢶⢷⢸⢹⢺⢻⢼⢽⢾⢿⣀⣁⣂⣃⣄⣅⣆⣇⣈⣉⣊⣋⣌⣍⣎⣏⣐⣑⣒⣓⣔⣕⣖⣗⣘⣙⣚⣛⣜⣝⣞⣟⣠⣡⣢⣣⣤⣥⣦⣧⣨⣩⣪⣫⣬⣭⣮⣯⣰⣱⣲⣳⣴⣵⣶⣷⣸⣹⣺⣻⣼⣽⣾⣿', ',') satisfies matches($s, '^(?:\p{IsBraillePatterns}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsBraillePatterns}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsBraillePatterns}?)$')) and (every $s in tokenize('⺀', ',') satisfies not(matches($s, '^(?:\p{IsBraillePatterns}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsByzantineMusicalSymbols}?)$')) and (every $s in tokenize('𝄀', ',') satisfies not(matches($s, '^(?:\p{IsByzantineMusicalSymbols}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsByzantineMusicalSymbols})$')) and (every $s in tokenize('𐑏', ',') satisfies not(matches($s, '^(?:\p{IsByzantineMusicalSymbols})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCherokee})$')) and (every $s in tokenize('፿', ',') satisfies not(matches($s, '^(?:\p{IsCherokee})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCherokee}?)$')) and (every $s in tokenize('᐀', ',') satisfies not(matches($s, '^(?:\p{IsCherokee}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKCompatibility})$')) and (every $s in tokenize('㋿', ',') satisfies not(matches($s, '^(?:\p{IsCJKCompatibility})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKCompatibility}?)$')) and (every $s in tokenize('㐀', ',') satisfies not(matches($s, '^(?:\p{IsCJKCompatibility}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKCompatibilityForms})$')) and (every $s in tokenize('︯', ',') satisfies not(matches($s, '^(?:\p{IsCJKCompatibilityForms})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKCompatibilityForms}?)$')) and (every $s in tokenize('﹐', ',') satisfies not(matches($s, '^(?:\p{IsCJKCompatibilityForms}?)$')))
(every $s in tokenize('︰﹏,︰︱︲︳︴︵︶︷︸︹︺︻︼︽︾︿﹀﹁﹂﹃﹄﹅﹆﹇﹈﹉﹊﹋﹌﹍﹎﹏', ',') satisfies matches($s, '^(?:\p{IsCJKCompatibilityForms}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCJKCompatibilityForms}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKCompatibilityIdeographs}?)$')) and (every $s in tokenize('ﬀ', ',') satisfies not(matches($s, '^(?:\p{IsCJKCompatibilityIdeographs}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKCompatibilityIdeographs})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCJKCompatibilityIdeographs})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKCompatibilityIdeographsSupplement})$')) and (every $s in tokenize('𪛖', ',') satisfies not(matches($s, '^(?:\p{IsCJKCompatibilityIdeographsSupplement})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKCompatibilityIdeographsSupplement}?)$')) and (every $s in tokenize('󠀀', ',') satisfies not(matches($s, '^(?:\p{IsCJKCompatibilityIdeographsSupplement}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKRadicalsSupplement})$')) and (every $s in tokenize('⣿', ',') satisfies not(matches($s, '^(?:\p{IsCJKRadicalsSupplement})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKRadicalsSupplement}?)$')) and (every $s in tokenize('⼀', ',') satisfies not(matches($s, '^(?:\p{IsCJKRadicalsSupplement}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKSymbolsandPunctuation})$')) and (every $s in tokenize('⿿', ',') satisfies not(matches($s, '^(?:\p{IsCJKSymbolsandPunctuation})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKSymbolsandPunctuation}?)$')) and (every $s in tokenize('぀', ',') satisfies not(matches($s, '^(?:\p{IsCJKSymbolsandPunctuation}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKUnifiedIdeographs})$')) and (every $s in tokenize('䶵', ',') satisfies not(matches($s, '^(?:\p{IsCJKUnifiedIdeographs})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKUnifiedIdeographs}?)$')) and (every $s in tokenize('ꀀ', ',') satisfies not(matches($s, '^(?:\p{IsCJKUnifiedIdeographs}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKUnifiedIdeographsExtensionA})$')) and (every $s in tokenize('㏿', ',') satisfies not(matches($s, '^(?:\p{IsCJKUnifiedIdeographsExtensionA})$')))
(every $s in tokenize('㐀䶵', ',') satisfies matches($s, '^(?:\p{IsCJKUnifiedIdeographsExtensionA}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCJKUnifiedIdeographsExtensionA}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKUnifiedIdeographsExtensionA}?)$')) and (every $s in tokenize('一', ',') satisfies not(matches($s, '^(?:\p{IsCJKUnifiedIdeographsExtensionA}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKUnifiedIdeographsExtensionB})$')) and (every $s in tokenize('𝟿', ',') satisfies not(matches($s, '^(?:\p{IsCJKUnifiedIdeographsExtensionB})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKUnifiedIdeographsExtensionB}?)$')) and (every $s in tokenize('丽', ',') satisfies not(matches($s, '^(?:\p{IsCJKUnifiedIdeographsExtensionB}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCombiningHalfMarks})$')) and (every $s in tokenize('﷿', ',') satisfies not(matches($s, '^(?:\p{IsCombiningHalfMarks})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCombiningHalfMarks}?)$')) and (every $s in tokenize('︰', ',') satisfies not(matches($s, '^(?:\p{IsCombiningHalfMarks}?)$')))
(every $s in tokenize('︠︯,︧︨︩︪︫︬︭︠︡︢︣︤︥︦︮︯', ',') satisfies matches($s, '^(?:\p{IsCombiningHalfMarks}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCombiningHalfMarks}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCombiningMarksforSymbols}?)$')) and (every $s in tokenize('℀', ',') satisfies not(matches($s, '^(?:\p{IsCombiningMarksforSymbols}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCombiningMarksforSymbols})$')) and (every $s in tokenize('⃏', ',') satisfies not(matches($s, '^(?:\p{IsCombiningMarksforSymbols})$')))
(every $s in tokenize('⃐⃿', ',') satisfies matches($s, '^(?:\p{IsCombiningMarksforSymbols}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCombiningMarksforSymbols}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsControlPictures})$')) and (every $s in tokenize('⏿', ',') satisfies not(matches($s, '^(?:\p{IsControlPictures})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsControlPictures}?)$')) and (every $s in tokenize('⑀', ',') satisfies not(matches($s, '^(?:\p{IsControlPictures}?)$')))
(every $s in tokenize('␀␿,␀␁␂␃␄␅␆␇␈␉␊␋␌␍␎␏␐␑␒␓␔␕␖␗␘␙␚␛␜␝␞␟␠␡␢␣␤␥␦␧␨␩␪␫␬␭␮␯␰␱␲␳␴␵␶␷␸␹␺␻␼␽␾␿', ',') satisfies matches($s, '^(?:\p{IsControlPictures}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsControlPictures}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCurrencySymbols})$')) and (every $s in tokenize('₟', ',') satisfies not(matches($s, '^(?:\p{IsCurrencySymbols})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCurrencySymbols}?)$')) and (every $s in tokenize('⃐', ',') satisfies not(matches($s, '^(?:\p{IsCurrencySymbols}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCyrillic}?)$')) and (every $s in tokenize('԰', ',') satisfies not(matches($s, '^(?:\p{IsCyrillic}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCyrillic})$')) and (every $s in tokenize('Ͽ', ',') satisfies not(matches($s, '^(?:\p{IsCyrillic})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsDeseret})$')) and (every $s in tokenize('𐍏', ',') satisfies not(matches($s, '^(?:\p{IsDeseret})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsDeseret}?)$')) and (every $s in tokenize('𝀀', ',') satisfies not(matches($s, '^(?:\p{IsDeseret}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsDevanagari})$')) and (every $s in tokenize('޿', ',') satisfies not(matches($s, '^(?:\p{IsDevanagari})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsDevanagari}?)$')) and (every $s in tokenize('ঀ', ',') satisfies not(matches($s, '^(?:\p{IsDevanagari}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsDingbats})$')) and (every $s in tokenize('⛿', ',') satisfies not(matches($s, '^(?:\p{IsDingbats})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsDingbats}?)$')) and (every $s in tokenize('⠀', ',') satisfies not(matches($s, '^(?:\p{IsDingbats}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsEnclosedAlphanumerics})$')) and (every $s in tokenize('⑟', ',') satisfies not(matches($s, '^(?:\p{IsEnclosedAlphanumerics})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsEnclosedAlphanumerics}?)$')) and (every $s in tokenize('─', ',') satisfies not(matches($s, '^(?:\p{IsEnclosedAlphanumerics}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsEnclosedCJKLettersandMonths})$')) and (every $s in tokenize('ㆿ', ',') satisfies not(matches($s, '^(?:\p{IsEnclosedCJKLettersandMonths})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsEnclosedCJKLettersandMonths}?)$')) and (every $s in tokenize('㌀', ',') satisfies not(matches($s, '^(?:\p{IsEnclosedCJKLettersandMonths}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsEthiopic}?)$')) and (every $s in tokenize('Ꭰ', ',') satisfies not(matches($s, '^(?:\p{IsEthiopic}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsEthiopic})$')) and (every $s in tokenize('ᇿ', ',') satisfies not(matches($s, '^(?:\p{IsEthiopic})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsGeneralPunctuation}?)$')) and (every $s in tokenize('⁰', ',') satisfies not(matches($s, '^(?:\p{IsGeneralPunctuation}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsGeneralPunctuation})$')) and (every $s in tokenize('῿', ',') satisfies not(matches($s, '^(?:\p{IsGeneralPunctuation})$')))
(every $s in tokenize(' ⁯,           ​‌‍‎‏‐‑‒–—―‖‗‘’‚‛“”„‟†‡•‣․‥…‧  ‪‫‬‭‮ ‰‱′″‴‵‶‷‸‹›※‼‽‾‿⁀⁁⁂⁃⁄⁅⁆⁇⁈⁉⁊⁋⁌⁍⁎⁏⁐⁑⁒⁓⁔⁕⁖⁗⁘⁙⁚⁛⁜⁝⁞ ⁠⁡⁢⁣⁤⁥⁦⁧⁨⁩⁪⁫⁬⁭⁮⁯', ',') satisfies matches($s, '^(?:\p{IsGeneralPunctuation}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsGeneralPunctuation}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsGeometricShapes})$')) and (every $s in tokenize('▟', ',') satisfies not(matches($s, '^(?:\p{IsGeometricShapes})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsGeometricShapes}?)$')) and (every $s in tokenize('☀', ',') satisfies not(matches($s, '^(?:\p{IsGeometricShapes}?)$')))
(every $s in tokenize('■◿,■□▢▣▤▥▦▧▨▩▪▫▬▭▮▯▰▱▲△▴▵▶▷▸▹►▻▼▽▾▿◀◁◂◃◄◅◆◇◈◉◊○◌◍◎●◐◑◒◓◔◕◖◗◘◙◚◛◜◝◞◟◠◡◢◣◤◥◦◧◨◩◪◫◬◭◮◯◰◱◲◳◴◵◶◷◸◹◺◻◼◽◾◿', ',') satisfies matches($s, '^(?:\p{IsGeometricShapes}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsGeometricShapes}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsGeorgian})$')) and (every $s in tokenize('႟', ',') satisfies not(matches($s, '^(?:\p{IsGeorgian})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsGeorgian}?)$')) and (every $s in tokenize('ᄀ', ',') satisfies not(matches($s, '^(?:\p{IsGeorgian}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsGothic})$')) and (every $s in tokenize('𐌯', ',') satisfies not(matches($s, '^(?:\p{IsGothic})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsGothic}?)$')) and (every $s in tokenize('𐐀', ',') satisfies not(matches($s, '^(?:\p{IsGothic}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsGreek})$')) and (every $s in tokenize('ͯ', ',') satisfies not(matches($s, '^(?:\p{IsGreek})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsGreekExtended}?)$')) and (every $s in tokenize(' ', ',') satisfies not(matches($s, '^(?:\p{IsGreekExtended}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsGreekExtended})$')) and (every $s in tokenize('ỿ', ',') satisfies not(matches($s, '^(?:\p{IsGreekExtended})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\p{IsGreek}-[\P{Lu}]]+)$')) and (every $s in tokenize('ΐϾΆΈϬϮЀ', ',') satisfies not(matches($s, '^(?:[\p{IsGreek}-[\P{Lu}]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsGujarati})$')) and (every $s in tokenize('੿', ',') satisfies not(matches($s, '^(?:\p{IsGujarati})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsGujarati}?)$')) and (every $s in tokenize('଀', ',') satisfies not(matches($s, '^(?:\p{IsGujarati}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsGurmukhi})$')) and (every $s in tokenize('৿', ',') satisfies not(matches($s, '^(?:\p{IsGurmukhi})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsGurmukhi}?)$')) and (every $s in tokenize('઀', ',') satisfies not(matches($s, '^(?:\p{IsGurmukhi}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsHalfwidthandFullwidthForms})$')) and (every $s in tokenize('﻿', ',') satisfies not(matches($s, '^(?:\p{IsHalfwidthandFullwidthForms})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsHalfwidthandFullwidthForms}?)$')) and (every $s in tokenize('￰', ',') satisfies not(matches($s, '^(?:\p{IsHalfwidthandFullwidthForms}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsHangulCompatibilityJamo})$')) and (every $s in tokenize('ㄯ', ',') satisfies not(matches($s, '^(?:\p{IsHangulCompatibilityJamo})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsHangulCompatibilityJamo}?)$')) and (every $s in tokenize('㆐', ',') satisfies not(matches($s, '^(?:\p{IsHangulCompatibilityJamo}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsHangulJamo})$')) and (every $s in tokenize('ჿ', ',') satisfies not(matches($s, '^(?:\p{IsHangulJamo})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsHangulJamo}?)$')) and (every $s in tokenize('ሀ', ',') satisfies not(matches($s, '^(?:\p{IsHangulJamo}?)$')))
(every $s in tokenize('가힣', ',') satisfies matches($s, '^(?:\p{IsHangulSyllables}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsHangulSyllables}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsHangulSyllables})$')) and (every $s in tokenize('꓏', ',') satisfies not(matches($s, '^(?:\p{IsHangulSyllables})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsHebrew})$')) and (every $s in tokenize('֏', ',') satisfies not(matches($s, '^(?:\p{IsHebrew})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsHebrew}?)$')) and (every $s in tokenize('؀', ',') satisfies not(matches($s, '^(?:\p{IsHebrew}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsHighSurrogates})$')) and (every $s in tokenize('''힣', ',') satisfies not(matches($s, '^(?:\p{IsHighSurrogates})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsHighSurrogates}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsHighSurrogates}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsHiragana})$')) and (every $s in tokenize('〿', ',') satisfies not(matches($s, '^(?:\p{IsHiragana})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsHiragana}?)$')) and (every $s in tokenize('゠', ',') satisfies not(matches($s, '^(?:\p{IsHiragana}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsIdeographicDescriptionCharacters})$')) and (every $s in tokenize('⿟', ',') satisfies not(matches($s, '^(?:\p{IsIdeographicDescriptionCharacters})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsIdeographicDescriptionCharacters}?)$')) and (every $s in tokenize('　', ',') satisfies not(matches($s, '^(?:\p{IsIdeographicDescriptionCharacters}?)$')))
(every $s in tokenize('⿰⿿,⿰⿱⿲⿳⿴⿵⿶⿷⿸⿹⿺⿻⿼⿽⿾⿿', ',') satisfies matches($s, '^(?:\p{IsIdeographicDescriptionCharacters}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsIdeographicDescriptionCharacters}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsIPAExtensions}?)$')) and (every $s in tokenize('ʰ', ',') satisfies not(matches($s, '^(?:\p{IsIPAExtensions}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsIPAExtensions})$')) and (every $s in tokenize('ɏ', ',') satisfies not(matches($s, '^(?:\p{IsIPAExtensions})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsKanbun})$')) and (every $s in tokenize('㆏', ',') satisfies not(matches($s, '^(?:\p{IsKanbun})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsKanbun}?)$')) and (every $s in tokenize('ㆠ', ',') satisfies not(matches($s, '^(?:\p{IsKanbun}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsKangxiRadicals})$')) and (every $s in tokenize('⻿', ',') satisfies not(matches($s, '^(?:\p{IsKangxiRadicals})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsKangxiRadicals}?)$')) and (every $s in tokenize('⿰', ',') satisfies not(matches($s, '^(?:\p{IsKangxiRadicals}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsKannada})$')) and (every $s in tokenize('౿', ',') satisfies not(matches($s, '^(?:\p{IsKannada})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsKannada}?)$')) and (every $s in tokenize('ഀ', ',') satisfies not(matches($s, '^(?:\p{IsKannada}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsKatakana}?)$')) and (every $s in tokenize('㄀', ',') satisfies not(matches($s, '^(?:\p{IsKatakana}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsKatakana})$')) and (every $s in tokenize('ゟ', ',') satisfies not(matches($s, '^(?:\p{IsKatakana})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsKhmer})$')) and (every $s in tokenize('᛿', ',') satisfies not(matches($s, '^(?:\p{IsKhmer})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsKhmer}?)$')) and (every $s in tokenize('᠀', ',') satisfies not(matches($s, '^(?:\p{IsKhmer}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsLao})$')) and (every $s in tokenize('๿', ',') satisfies not(matches($s, '^(?:\p{IsLao})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsLao}?)$')) and (every $s in tokenize('ༀ', ',') satisfies not(matches($s, '^(?:\p{IsLao}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsLatin-1Supplement}?)$')) and (every $s in tokenize('Ā', ',') satisfies not(matches($s, '^(?:\p{IsLatin-1Supplement}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsLatin-1Supplement})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsLatin-1Supplement})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsLatinExtended-A}?)$')) and (every $s in tokenize('ƀ', ',') satisfies not(matches($s, '^(?:\p{IsLatinExtended-A}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsLatinExtended-A})$')) and (every $s in tokenize('ÿ', ',') satisfies not(matches($s, '^(?:\p{IsLatinExtended-A})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsLatinExtendedAdditional})$')) and (every $s in tokenize('᢯', ',') satisfies not(matches($s, '^(?:\p{IsLatinExtendedAdditional})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsLatinExtendedAdditional}?)$')) and (every $s in tokenize('ἀ', ',') satisfies not(matches($s, '^(?:\p{IsLatinExtendedAdditional}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsLatinExtended-B}?)$')) and (every $s in tokenize('ɐ', ',') satisfies not(matches($s, '^(?:\p{IsLatinExtended-B}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsLatinExtended-B})$')) and (every $s in tokenize('ſ', ',') satisfies not(matches($s, '^(?:\p{IsLatinExtended-B})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsLetterlikeSymbols}?)$')) and (every $s in tokenize('⅐', ',') satisfies not(matches($s, '^(?:\p{IsLetterlikeSymbols}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsLetterlikeSymbols})$')) and (every $s in tokenize('⃿', ',') satisfies not(matches($s, '^(?:\p{IsLetterlikeSymbols})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsLowSurrogates}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsLowSurrogates}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsMalayalam})$')) and (every $s in tokenize('೿', ',') satisfies not(matches($s, '^(?:\p{IsMalayalam})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsMalayalam}?)$')) and (every $s in tokenize('඀', ',') satisfies not(matches($s, '^(?:\p{IsMalayalam}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsMathematicalAlphanumericSymbols})$')) and (every $s in tokenize('𝇿', ',') satisfies not(matches($s, '^(?:\p{IsMathematicalAlphanumericSymbols})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsMathematicalAlphanumericSymbols}?)$')) and (every $s in tokenize('𠀀', ',') satisfies not(matches($s, '^(?:\p{IsMathematicalAlphanumericSymbols}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsMathematicalOperators})$')) and (every $s in tokenize('⇿', ',') satisfies not(matches($s, '^(?:\p{IsMathematicalOperators})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsMathematicalOperators}?)$')) and (every $s in tokenize('⌀', ',') satisfies not(matches($s, '^(?:\p{IsMathematicalOperators}?)$')))
(every $s in tokenize('∀⋿,∀∁∂∃∄∅∆∇∈∉∊∋∌∍∎∏∐∑−∓∔∕∖∗∘∙√∛∜∝∞∟∠∡∢∣∤∥∦∧∨∩∪∫∬∭∮∯∰∱∲∳∴∵∶∷∸∹∺∻∼∽∾∿≀≁≂≃≄≅≆≇≈≉≊≋≌≍≎≏≐≑≒≓≔≕≖≗≘≙≚≛≜≝≞≟≠≡≢≣≤≥≦≧≨≩≪≫≬≭≮≯≰≱≲≳≴≵≶≷≸≹≺≻≼≽≾≿⊀⊁⊂⊃⊄⊅⊆⊇⊈⊉⊊⊋⊌⊍⊎⊏⊐⊑⊒⊓⊔⊕⊖⊗⊘⊙⊚⊛⊜⊝⊞⊟⊠⊡⊢⊣⊤⊥⊦⊧⊨⊩⊪⊫⊬⊭⊮⊯⊰⊱⊲⊳⊴⊵⊶⊷⊸⊹⊺⊻⊼⊽⊾⊿⋀⋁⋂⋃⋄⋅⋆⋇⋈⋉⋊⋋⋌⋍⋎⋏⋐⋑⋒⋓⋔⋕⋖⋗⋘⋙⋚⋛⋜⋝⋞⋟⋠⋡⋢⋣⋤⋥⋦⋧⋨⋩⋪⋫⋬⋭⋮⋯⋰⋱⋲⋳⋴⋵⋶⋷⋸⋹⋺⋻⋼⋽⋾⋿', ',') satisfies matches($s, '^(?:\p{IsMathematicalOperators}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsMathematicalOperators}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsMiscellaneousSymbols})$')) and (every $s in tokenize('◿', ',') satisfies not(matches($s, '^(?:\p{IsMiscellaneousSymbols})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsMiscellaneousSymbols}?)$')) and (every $s in tokenize('✀', ',') satisfies not(matches($s, '^(?:\p{IsMiscellaneousSymbols}?)$')))
(every $s in tokenize('☀⛿,☀☁☂☃☄★☆☇☈☉☊☋☌☍☎☏☐☑☒☓☔☕☖☗☘☙☚☛☜☝☞☟☠☡☢☣☤☥☦☧☨☩☪☫☬☭☮☯☰☱☲☳☴☵☶☷☸☹☺☻☼☽☾☿♀♁♂♃♄♅♆♇♈♉♊♋♌♍♎♏♐♑♒♓♔♕♖♗♘♙♚♛♜♝♞♟♠♡♢♣♤♥♦♧♨♩♪♫♬♭♮♯♰♱♲♳♴♵♶♷♸♹♺♻♼♽♾♿⚀⚁⚂⚃⚄⚅⚆⚇⚈⚉⚊⚋⚌⚍⚎⚏⚐⚑⚒⚓⚔⚕⚖⚗⚘⚙⚚⚛⚜⚝⚞⚟⚠⚡⚢⚣⚤⚥⚦⚧⚨⚩⚪⚫⚬⚭⚮⚯⚰⚱⚲⚳⚴⚵⚶⚷⚸⚹⚺⚻⚼⚽⚾⚿⛀⛁⛂⛃⛄⛅⛆⛇⛈⛉⛊⛋⛌⛍⛎⛏⛐⛑⛒⛓⛔⛕⛖⛗⛘⛙⛚⛛⛜⛝⛞⛟⛠⛡⛢⛣⛤⛥⛦⛧⛨⛩⛪⛫⛬⛭⛮⛯⛰⛱⛲⛳⛴⛵⛶⛷⛸⛹⛺⛻⛼⛽⛾⛿', ',') satisfies matches($s, '^(?:\p{IsMiscellaneousSymbols}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsMiscellaneousSymbols}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsMiscellaneousTechnical})$')) and (every $s in tokenize('⋿', ',') satisfies not(matches($s, '^(?:\p{IsMiscellaneousTechnical})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsMiscellaneousTechnical}?)$')) and (every $s in tokenize('␀', ',') satisfies not(matches($s, '^(?:\p{IsMiscellaneousTechnical}?)$')))
(every $s in tokenize('⌀⏿,⌀⌁⌂⌃⌄⌅⌆⌇⌈⌉⌊⌋⌌⌍⌎⌏⌐⌑⌒⌓⌔⌕⌖⌗⌘⌙⌚⌛⌜⌝⌞⌟⌠⌡⌢⌣⌤⌥⌦⌧⌨〈〉⌫⌬⌭⌮⌯⌰⌱⌲⌳⌴⌵⌶⌷⌸⌹⌺⌻⌼⌽⌾⌿⍀⍁⍂⍃⍄⍅⍆⍇⍈⍉⍊⍋⍌⍍⍎⍏⍐⍑⍒⍓⍔⍕⍖⍗⍘⍙⍚⍛⍜⍝⍞⍟⍠⍡⍢⍣⍤⍥⍦⍧⍨⍩⍪⍫⍬⍭⍮⍯⍰⍱⍲⍳⍴⍵⍶⍷⍸⍹⍺⍻⍼⍽⍾⍿⎀⎁⎂⎃⎄⎅⎆⎇⎈⎉⎊⎋⎌⎍⎎⎏⎐⎑⎒⎓⎔⎕⎖⎗⎘⎙⎚⎛⎜⎝⎞⎟⎠⎡⎢⎣⎤⎥⎦⎧⎨⎩⎪⎫⎬⎭⎮⎯⎰⎱⎲⎳⎴⎵⎶⎷⎸⎹⎺⎻⎼⎽⎾⎿⏀⏁⏂⏃⏄⏅⏆⏇⏈⏉⏊⏋⏌⏍⏎⏏⏐⏑⏒⏓⏔⏕⏖⏗⏘⏙⏚⏛⏜⏝⏞⏟⏠⏡⏢⏣⏤⏥⏦⏧⏨⏩⏪⏫⏬⏭⏮⏯⏰⏱⏲⏳⏴⏵⏶⏷⏸⏹⏺⏻⏼⏽⏾⏿', ',') satisfies matches($s, '^(?:\p{IsMiscellaneousTechnical}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsMiscellaneousTechnical}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsMongolian}?)$')) and (every $s in tokenize('Ḁ', ',') satisfies not(matches($s, '^(?:\p{IsMongolian}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsMongolian})$')) and (every $s in tokenize('៿', ',') satisfies not(matches($s, '^(?:\p{IsMongolian})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsMusicalSymbols}?)$')) and (every $s in tokenize('𝐀', ',') satisfies not(matches($s, '^(?:\p{IsMusicalSymbols}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsMusicalSymbols})$')) and (every $s in tokenize('𝃿', ',') satisfies not(matches($s, '^(?:\p{IsMusicalSymbols})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsMyanmar})$')) and (every $s in tokenize('࿿', ',') satisfies not(matches($s, '^(?:\p{IsMyanmar})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsMyanmar}?)$')) and (every $s in tokenize('Ⴀ', ',') satisfies not(matches($s, '^(?:\p{IsMyanmar}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsNumberForms})$')) and (every $s in tokenize('⅏', ',') satisfies not(matches($s, '^(?:\p{IsNumberForms})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsNumberForms}?)$')) and (every $s in tokenize('←', ',') satisfies not(matches($s, '^(?:\p{IsNumberForms}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsOgham})$')) and (every $s in tokenize('ᙿ', ',') satisfies not(matches($s, '^(?:\p{IsOgham})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsOgham}?)$')) and (every $s in tokenize('ᚠ', ',') satisfies not(matches($s, '^(?:\p{IsOgham}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsOldItalic}?)$')) and (every $s in tokenize('𐌰', ',') satisfies not(matches($s, '^(?:\p{IsOldItalic}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsOldItalic})$')) and (every $s in tokenize('�', ',') satisfies not(matches($s, '^(?:\p{IsOldItalic})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsOpticalCharacterRecognition}?)$')) and (every $s in tokenize('①', ',') satisfies not(matches($s, '^(?:\p{IsOpticalCharacterRecognition}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsOpticalCharacterRecognition})$')) and (every $s in tokenize('␿', ',') satisfies not(matches($s, '^(?:\p{IsOpticalCharacterRecognition})$')))
(every $s in tokenize('⑀⑟,⑀⑁⑂⑃⑄⑅⑆⑇⑈⑉⑊⑋⑌⑍⑎⑏⑐⑑⑒⑓⑔⑕⑖⑗⑘⑙⑚⑛⑜⑝⑞⑟', ',') satisfies matches($s, '^(?:\p{IsOpticalCharacterRecognition}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsOpticalCharacterRecognition}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsOriya})$')) and (every $s in tokenize('૿', ',') satisfies not(matches($s, '^(?:\p{IsOriya})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsOriya}?)$')) and (every $s in tokenize('஀', ',') satisfies not(matches($s, '^(?:\p{IsOriya}?)$')))
(every $s in tokenize(',󰀀󿿽,􀀀􏿽', ',') satisfies matches($s, '^(?:\p{IsPrivateUse}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsPrivateUse}+)$')))
(every $s in tokenize('󿿽', ',') satisfies matches($s, '^(?:\p{IsPrivateUse})$')) and (every $s in tokenize('󠁿', ',') satisfies not(matches($s, '^(?:\p{IsPrivateUse})$')))
(every $s in tokenize('􀀀', ',') satisfies matches($s, '^(?:\p{IsPrivateUse}?)$')) and (every $s in tokenize('豈,', ',') satisfies not(matches($s, '^(?:\p{IsPrivateUse}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsRunic})$')) and (every $s in tokenize('᚟', ',') satisfies not(matches($s, '^(?:\p{IsRunic})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsRunic}?)$')) and (every $s in tokenize('ក', ',') satisfies not(matches($s, '^(?:\p{IsRunic}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsSinhala}?)$')) and (every $s in tokenize('฀', ',') satisfies not(matches($s, '^(?:\p{IsSinhala}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsSinhala})$')) and (every $s in tokenize('ൿ', ',') satisfies not(matches($s, '^(?:\p{IsSinhala})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsSmallFormVariants})$')) and (every $s in tokenize('﹏', ',') satisfies not(matches($s, '^(?:\p{IsSmallFormVariants})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsSmallFormVariants}?)$')) and (every $s in tokenize('ﹰ', ',') satisfies not(matches($s, '^(?:\p{IsSmallFormVariants}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsSpacingModifierLetters}?)$')) and (every $s in tokenize('̀', ',') satisfies not(matches($s, '^(?:\p{IsSpacingModifierLetters}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsSpacingModifierLetters})$')) and (every $s in tokenize('ʯ', ',') satisfies not(matches($s, '^(?:\p{IsSpacingModifierLetters})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsSpecials})$')) and (every $s in tokenize('﻾,￯', ',') satisfies not(matches($s, '^(?:\p{IsSpecials})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsSpecials}?)$')) and (every $s in tokenize('＀,𐌀', ',') satisfies not(matches($s, '^(?:\p{IsSpecials}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsSuperscriptsandSubscripts}?)$')) and (every $s in tokenize('₠', ',') satisfies not(matches($s, '^(?:\p{IsSuperscriptsandSubscripts}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsSuperscriptsandSubscripts})$')) and (every $s in tokenize('⁯', ',') satisfies not(matches($s, '^(?:\p{IsSuperscriptsandSubscripts})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsSyriac})$')) and (every $s in tokenize('ۿ', ',') satisfies not(matches($s, '^(?:\p{IsSyriac})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsSyriac}?)$')) and (every $s in tokenize('ހ', ',') satisfies not(matches($s, '^(?:\p{IsSyriac}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsTags})$')) and (every $s in tokenize('𯨟', ',') satisfies not(matches($s, '^(?:\p{IsTags})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsTags}?)$')) and (every $s in tokenize('󰀀', ',') satisfies not(matches($s, '^(?:\p{IsTags}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsTamil})$')) and (every $s in tokenize('୿', ',') satisfies not(matches($s, '^(?:\p{IsTamil})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsTamil}?)$')) and (every $s in tokenize('ఀ', ',') satisfies not(matches($s, '^(?:\p{IsTamil}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsTelugu})$')) and (every $s in tokenize('௿', ',') satisfies not(matches($s, '^(?:\p{IsTelugu})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsTelugu}?)$')) and (every $s in tokenize('ಀ', ',') satisfies not(matches($s, '^(?:\p{IsTelugu}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsThaana}?)$')) and (every $s in tokenize('ऀ', ',') satisfies not(matches($s, '^(?:\p{IsThaana}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsThaana})$')) and (every $s in tokenize('ݏ', ',') satisfies not(matches($s, '^(?:\p{IsThaana})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsThai})$')) and (every $s in tokenize('෿', ',') satisfies not(matches($s, '^(?:\p{IsThai})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsThai}?)$')) and (every $s in tokenize('຀', ',') satisfies not(matches($s, '^(?:\p{IsThai}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsTibetan})$')) and (every $s in tokenize('໿', ',') satisfies not(matches($s, '^(?:\p{IsTibetan})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsTibetan}?)$')) and (every $s in tokenize('က', ',') satisfies not(matches($s, '^(?:\p{IsTibetan}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsUnifiedCanadianAboriginalSyllabics})$')) and (every $s in tokenize('᏿', ',') satisfies not(matches($s, '^(?:\p{IsUnifiedCanadianAboriginalSyllabics})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsUnifiedCanadianAboriginalSyllabics}?)$')) and (every $s in tokenize(' ', ',') satisfies not(matches($s, '^(?:\p{IsUnifiedCanadianAboriginalSyllabics}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsYiRadicals})$')) and (every $s in tokenize('꒏', ',') satisfies not(matches($s, '^(?:\p{IsYiRadicals})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsYiRadicals}?)$')) and (every $s in tokenize('가', ',') satisfies not(matches($s, '^(?:\p{IsYiRadicals}?)$')))
(every $s in tokenize('꒐꓏,꒐꒑꒒꒓꒔꒕꒖꒗꒘꒙꒚꒛꒜꒝꒞꒟꒠꒡꒢꒣꒤꒥꒦꒧꒨꒩꒪꒫꒬꒭꒮꒯꒰꒱꒲꒳꒴꒵꒶꒷꒸꒹꒺꒻꒼꒽꒾꒿꓀꓁꓂꓃꓄꓅꓆꓇꓈꓉꓊꓋꓌꓍꓎꓏', ',') satisfies matches($s, '^(?:\p{IsYiRadicals}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsYiRadicals}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsYiSyllables})$')) and (every $s in tokenize('鿿', ',') satisfies not(matches($s, '^(?:\p{IsYiSyllables})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsYiSyllables}?)$')) and (every $s in tokenize('꒐', ',') satisfies not(matches($s, '^(?:\p{IsYiSyllables}?)$')))
(every $s in tokenize('_,⃝', ',') satisfies matches($s, '^(?:\P{L}*)$')) and (every $s in tokenize('aAbB,A𝞨aa𝟉ǅǅῼʰʰﾟאא𪘀', ',') satisfies not(matches($s, '^(?:\P{L}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{L}*)$')) and (every $s in tokenize('⃝', ',') satisfies not(matches($s, '^(?:\p{L}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:([\p{Ll}-[aeiou]]|[^\w-[\s]])+)$')) and (every $s in tokenize('aeiobcdxyz!@#aeio', ',') satisfies not(matches($s, '^(?:([\p{Ll}-[aeiou]]|[^\w-[\s]])+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\p{Ll}-[ae-z]]+)$')) and (every $s in tokenize('aaabbbcccdddeee', ',') satisfies not(matches($s, '^(?:[\p{Ll}-[ae-z]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\p{Ll}-[ae-z0-9]]+)$')) and (every $s in tokenize('09aaabbbcccdddeee', ',') satisfies not(matches($s, '^(?:[\p{Ll}-[ae-z0-9]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\p{Ll}-[A-Z]]+)$')) and (every $s in tokenize('AZaz09', ',') satisfies not(matches($s, '^(?:[\p{Ll}-[A-Z]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(\p{Ll}\p{Cc}\p{Nd})*)$')) and (every $s in tokenize(' ', ',') satisfies not(matches($s, '^(?:(\p{Ll}\p{Cc}\p{Nd})*)$')))
(every $s in tokenize('ً', ',') satisfies matches($s, '^(?:\P{Lo}*)$')) and (every $s in tokenize('א𪘀', ',') satisfies not(matches($s, '^(?:\P{Lo}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\P{Lu}-[ae-z]]+)$')) and (every $s in tokenize('aaabbbcccdddeee', ',') satisfies not(matches($s, '^(?:[\P{Lu}-[ae-z]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\P{Lu}-[ae-zA-Z]]+)$')) and (every $s in tokenize('AZaaabbbcccdddeee', ',') satisfies not(matches($s, '^(?:[\P{Lu}-[ae-zA-Z]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\P{Lu}-[A-Z]]+)$')) and (every $s in tokenize('AZazAZ', ',') satisfies not(matches($s, '^(?:[\P{Lu}-[A-Z]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\P{Lu}-[\p{Lu}]]+)$')) and (every $s in tokenize('AZazAZ', ',') satisfies not(matches($s, '^(?:[\P{Lu}-[\p{Lu}]]+)$')))
(every $s in tokenize('ً𝆭ः𝅲ः𝅲⃝⃝⃠', ',') satisfies matches($s, '^(?:\p{M}*)$')) and (every $s in tokenize('ǅ', ',') satisfies not(matches($s, '^(?:\p{M}*)$')))
(every $s in tokenize('⃝', ',') satisfies matches($s, '^(?:\P{Mc}*)$')) and (every $s in tokenize('ः𝅲', ',') satisfies not(matches($s, '^(?:\P{Mc}*)$')))
(every $s in tokenize('ः𝅲', ',') satisfies matches($s, '^(?:\p{Mc}*)$')) and (every $s in tokenize('⃝', ',') satisfies not(matches($s, '^(?:\p{Mc}*)$')))
(every $s in tokenize('⃝⃠', ',') satisfies matches($s, '^(?:\p{Me}*)$')) and (every $s in tokenize('０', ',') satisfies not(matches($s, '^(?:\p{Me}*)$')))
(every $s in tokenize('ً𝆭', ',') satisfies matches($s, '^(?:\p{Mn}*)$')) and (every $s in tokenize('ः', ',') satisfies not(matches($s, '^(?:\p{Mn}*)$')))
(every $s in tokenize('ः𝅲', ',') satisfies matches($s, '^(?:\P{Mn}*)$')) and (every $s in tokenize('ً𝆭', ',') satisfies not(matches($s, '^(?:\P{Mn}*)$')))
(every $s in tokenize('ः', ',') satisfies matches($s, '^(?:\P{N}*)$')) and (every $s in tokenize('０𝟿𐍊𐍊〥²²𐌣', ',') satisfies not(matches($s, '^(?:\P{N}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{Nd}{2})$')) and (every $s in tokenize('1999', ',') satisfies not(matches($s, '^(?:\p{Nd}{2})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\p{Nd}-[2468]]+)$')) and (every $s in tokenize('20135798', ',') satisfies not(matches($s, '^(?:[\p{Nd}-[2468]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\p{Nd}-[2468az]]+)$')) and (every $s in tokenize('az20135798', ',') satisfies not(matches($s, '^(?:[\p{Nd}-[2468az]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\P{Nd}-[2-8]]+)$')) and (every $s in tokenize('1234567890azAZ1234567890', ',') satisfies not(matches($s, '^(?:[\P{Nd}-[2-8]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\p{Nd}-[a-z]]+)$')) and (every $s in tokenize('az09', ',') satisfies not(matches($s, '^(?:[\p{Nd}-[a-z]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\P{Nd}-[\p{Nd}]]+)$')) and (every $s in tokenize('azAZ09', ',') satisfies not(matches($s, '^(?:[\P{Nd}-[\p{Nd}]]+)$')))
(every $s in tokenize('‿', ',') satisfies matches($s, '^(?:\P{No}*)$')) and (every $s in tokenize('²𐌣', ',') satisfies not(matches($s, '^(?:\P{No}*)$')))
(every $s in tokenize('‿･〜〜－〝〝｢〞〞｣««‹»»›¿¿､', ',') satisfies matches($s, '^(?:\p{P}*)$')) and (every $s in tokenize('²', ',') satisfies not(matches($s, '^(?:\p{P}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{Pc}*)$')) and (every $s in tokenize('〜', ',') satisfies not(matches($s, '^(?:\p{Pc}*)$')))
(every $s in tokenize('〜', ',') satisfies matches($s, '^(?:\P{Pc}*)$')) and (every $s in tokenize('‿･', ',') satisfies not(matches($s, '^(?:\P{Pc}*)$')))
(every $s in tokenize('〜－', ',') satisfies matches($s, '^(?:\p{Pd}*)$')) and (every $s in tokenize('〝', ',') satisfies not(matches($s, '^(?:\p{Pd}*)$')))
(every $s in tokenize('〝', ',') satisfies matches($s, '^(?:\P{Pd}*)$')) and (every $s in tokenize('〜－', ',') satisfies not(matches($s, '^(?:\P{Pd}*)$')))
(every $s in tokenize('〞｣', ',') satisfies matches($s, '^(?:\p{Pe}*)$')) and (every $s in tokenize('«', ',') satisfies not(matches($s, '^(?:\p{Pe}*)$')))
(every $s in tokenize('«', ',') satisfies matches($s, '^(?:\P{Pe}*)$')) and (every $s in tokenize('〞｣', ',') satisfies not(matches($s, '^(?:\P{Pe}*)$')))
(every $s in tokenize('»›', ',') satisfies matches($s, '^(?:\p{Pf}*)$')) and (every $s in tokenize('¿', ',') satisfies not(matches($s, '^(?:\p{Pf}*)$')))
(every $s in tokenize('¿', ',') satisfies matches($s, '^(?:\P{Pf}*)$')) and (every $s in tokenize('»›', ',') satisfies not(matches($s, '^(?:\P{Pf}*)$')))
(every $s in tokenize('«‹', ',') satisfies matches($s, '^(?:\p{Pi}*)$')) and (every $s in tokenize('»', ',') satisfies not(matches($s, '^(?:\p{Pi}*)$')))
(every $s in tokenize('»', ',') satisfies matches($s, '^(?:\P{Pi}*)$')) and (every $s in tokenize('«‹', ',') satisfies not(matches($s, '^(?:\P{Pi}*)$')))
(every $s in tokenize('¿､', ',') satisfies matches($s, '^(?:\p{Po}*)$')) and (every $s in tokenize(' ', ',') satisfies not(matches($s, '^(?:\p{Po}*)$')))
(every $s in tokenize(' ', ',') satisfies matches($s, '^(?:\P{Po}*)$')) and (every $s in tokenize('¿､', ',') satisfies not(matches($s, '^(?:\P{Po}*)$')))
(every $s in tokenize('〝｢', ',') satisfies matches($s, '^(?:\p{Ps}*)$')) and (every $s in tokenize('〞', ',') satisfies not(matches($s, '^(?:\p{Ps}*)$')))
(every $s in tokenize('〞', ',') satisfies matches($s, '^(?:\P{Ps}*)$')) and (every $s in tokenize('〝｢', ',') satisfies not(matches($s, '^(?:\P{Ps}*)$')))
(every $s in tokenize(' ', ',') satisfies matches($s, '^(?:\P{S}*)$')) and (every $s in tokenize('⁄￢₠₠￦゛゛￣㆐㆐𝇝', ',') satisfies not(matches($s, '^(?:\P{S}*)$')))
(every $s in tokenize('゛', ',') satisfies matches($s, '^(?:\P{Sc}*)$')) and (every $s in tokenize('₠￦', ',') satisfies not(matches($s, '^(?:\P{Sc}*)$')))
(every $s in tokenize('゛￣', ',') satisfies matches($s, '^(?:\p{Sk}*)$')) and (every $s in tokenize('㆐', ',') satisfies not(matches($s, '^(?:\p{Sk}*)$')))
(every $s in tokenize('㆐', ',') satisfies matches($s, '^(?:\P{Sk}*)$')) and (every $s in tokenize('゛￣', ',') satisfies not(matches($s, '^(?:\P{Sk}*)$')))
(every $s in tokenize('⁄￢', ',') satisfies matches($s, '^(?:\p{Sm}*)$')) and (every $s in tokenize('₠', ',') satisfies not(matches($s, '^(?:\p{Sm}*)$')))
(every $s in tokenize('㆐𝇝', ',') satisfies matches($s, '^(?:\p{So}*)$')) and (every $s in tokenize(' ', ',') satisfies not(matches($s, '^(?:\p{So}*)$')))
(every $s in tokenize(' ', ',') satisfies matches($s, '^(?:\P{So}*)$')) and (every $s in tokenize('㆐𝇝', ',') satisfies not(matches($s, '^(?:\P{So}*)$')))
(every $s in tokenize(' 　    ', ',') satisfies matches($s, '^(?:\p{Z}*)$')) and (every $s in tokenize('¿', ',') satisfies not(matches($s, '^(?:\p{Z}*)$')))
(every $s in tokenize('¿', ',') satisfies matches($s, '^(?:\P{Z}*)$')) and (every $s in tokenize(' 　    ', ',') satisfies not(matches($s, '^(?:\P{Z}*)$')))
(every $s in tokenize(' ', ',') satisfies matches($s, '^(?:\p{Zl}*)$')) and (every $s in tokenize(' ', ',') satisfies not(matches($s, '^(?:\p{Zl}*)$')))
(every $s in tokenize(' ', ',') satisfies matches($s, '^(?:\P{Zl}*)$')) and (every $s in tokenize(' ', ',') satisfies not(matches($s, '^(?:\P{Zl}*)$')))
(every $s in tokenize(' ', ',') satisfies matches($s, '^(?:\p{Zp}*)$')) and (every $s in tokenize('⁄', ',') satisfies not(matches($s, '^(?:\p{Zp}*)$')))
(every $s in tokenize('⁄', ',') satisfies matches($s, '^(?:\P{Zp}*)$')) and (every $s in tokenize(' ', ',') satisfies not(matches($s, '^(?:\P{Zp}*)$')))
(every $s in tokenize(' 　', ',') satisfies matches($s, '^(?:\p{Zs}*)$')) and (every $s in tokenize(' ', ',') satisfies not(matches($s, '^(?:\p{Zs}*)$')))
(every $s in tokenize(' ', ',') satisfies matches($s, '^(?:\P{Zs}*)$')) and (every $s in tokenize(' 　', ',') satisfies not(matches($s, '^(?:\P{Zs}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:qqq(123)*)$')) and (every $s in tokenize('Startqqq123123End', ',') satisfies not(matches($s, '^(?:qqq(123)*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\S+)$')) and (every $s in tokenize('a b', ',') satisfies not(matches($s, '^(?:\S+)$')))
(every $s in tokenize(' , , , ', ',') satisfies matches($s, '^(?:\s)$')) and (every $s in tokenize('a,', ',') satisfies not(matches($s, '^(?:\s)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(\s)?(-))$')) and (every $s in tokenize('once -upon-a time', ',') satisfies not(matches($s, '^(?:(\s)?(-))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\S*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\S*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\S\?a-c\?]+)$')) and (every $s in tokenize('? ?,? ?', ',') satisfies not(matches($s, '^(?:[\S\?a-c\?]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\s+\d+)$')) and (every $s in tokenize('sdf 12sad', ',') satisfies not(matches($s, '^(?:\s+\d+)$')))
(every $s in tokenize(' ', ',') satisfies matches($s, '^(?:[\t])$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[\t])$')))
(every $s in tokenize(' ', ',') satisfies matches($s, '^(?:\t)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\t)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\t\ta\t\tb\t\t)$')) and (every $s in tokenize(' a b , a b , a , a b ', ',') satisfies not(matches($s, '^(?:\t\ta\t\tb\t\t)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\W)$')) and (every $s in tokenize('A,𝞨,a,a,𝟉,ǅ,ǅ,ῼ,ʰ,ʰ,ﾟ,א,א,𪘀,ً,𝆭,ः,𝅲,ः,𝅲,⃝,⃝,⃢,０,𝟿,𐍊,𐍊,〥,²,²,𐌣,⁄,￢,₠,₠,￦,゛,゛,￣,㆐,㆐,𝇝', ',') satisfies not(matches($s, '^(?:\W)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\w)$')) and (every $s in tokenize(',܏,,‐,︷,},“,»,༄, , , ', ',') satisfies not(matches($s, '^(?:\w)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:([ ]|[\w-[0-9]])+)$')) and (every $s in tokenize('09az AZ90', ',') satisfies not(matches($s, '^(?:([ ]|[\w-[0-9]])+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\w-[b-y]]+)$')) and (every $s in tokenize('bbbaaaABCD09zzzyyy,bbbaaaABCD09zzzyyy,bbbaaaABCD09zzzyyy,bbbaaaABCD09zzzyyy', ',') satisfies not(matches($s, '^(?:[\w-[b-y]]+)$')))
(every $s in tokenize('', ';') satisfies matches($s, '^(?:[\w-[b-y!.,]]+)$')) and (every $s in tokenize('!.,bbbaaaABCD09zzzyyy', ';') satisfies not(matches($s, '^(?:[\w-[b-y!.,]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\w-[b-y\p{Po}]]+)$')) and (every $s in tokenize('!#bbbaaaABCD09zzzyyy', ',') satisfies not(matches($s, '^(?:[\w-[b-y\p{Po}]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\w-[b-y\s]]+)$')) and (every $s in tokenize('  bbbaaaABCD09zzzyyy', ',') satisfies not(matches($s, '^(?:[\w-[b-y\s]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\w-[\d]]+)$')) and (every $s in tokenize('0AZaz9', ',') satisfies not(matches($s, '^(?:[\w-[\d]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\w-[\d\p{Po}]]+)$')) and (every $s in tokenize('!#0AZaz9', ',') satisfies not(matches($s, '^(?:[\w-[\d\p{Po}]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\w-[\p{Ll}]]+)$')) and (every $s in tokenize('a09AZz', ',') satisfies not(matches($s, '^(?:[\w-[\p{Ll}]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\w-[\p{Ll}\s]]+)$')) and (every $s in tokenize('a09AZz', ',') satisfies not(matches($s, '^(?:[\w-[\p{Ll}\s]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\w-[\p{Po}]]+)$')) and (every $s in tokenize('#a09AZz!', ',') satisfies not(matches($s, '^(?:[\w-[\p{Po}]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[X-\]]+)$')) and (every $s in tokenize('wWXYZxyz[\]^', ',') satisfies not(matches($s, '^(?:[X-\]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[X-a]+)$')) and (every $s in tokenize('wWAXYZaxyz', ',') satisfies not(matches($s, '^(?:[X-a]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[X-c]+)$')) and (every $s in tokenize('wWABCXYZabcxyz', ',') satisfies not(matches($s, '^(?:[X-c]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[^-z]+)$')) and (every $s in tokenize('aaz,a-z', ',') satisfies not(matches($s, '^(?:[^-z]+)$')))
(every $s in tokenize('\.,\s,\S,\i,\I,\c,\C,\d,\D,\w,\W', ';') satisfies matches($s, '^(?:\\.,\\s,\\S,\\i,\\I,\\c,\\C,\\d,\\D,\\w,\\W)$')) and (every $s in tokenize('', ';') satisfies not(matches($s, '^(?:\\.,\\s,\\S,\\i,\\I,\\c,\\C,\\d,\\D,\\w,\\W)$')))
(every $s in tokenize('true,false', ',') satisfies matches($s, '^(?:(true|false))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(true|false))$')))
(every $s in tokenize('true', ',') satisfies matches($s, '^(?:true)$')) and (every $s in tokenize('false', ',') satisfies not(matches($s, '^(?:true)$')))
(every $s in tokenize('\t', ',') satisfies matches($s, '^(?:\\t)$')) and (every $s in tokenize('t,\\t, ', ',') satisfies not(matches($s, '^(?:\\t)$')))
(every $s in tokenize('&#xA;&#xD;a&#xA;&#xD;b', ',') satisfies (matches($s, '^(?:\n\ra\n\rb)$'))) and          (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\n\ra\n\rb)$')))
(every $s in tokenize('ÿ, ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ', ',') satisfies matches($s, '^(?:\p{IsLatin-1Supplement}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsLatin-1Supplement}+)$')))
(every $s in tokenize('zabcsdea', ',') satisfies matches($s, '^(?:\c\i*a)$')) and (every $s in tokenize('ab', ',') satisfies not(matches($s, '^(?:\c\i*a)$')))
(every $s in tokenize('ἀ῿,ἀἁἂἃἄἅἆἇἈἉἊἋἌἍἎἏἐἑἒἓἔἕ἖἗ἘἙἚἛἜἝ἞἟ἠἡἢἣἤἥἦἧἨἩἪἫἬἭἮἯἰἱἲἳἴἵἶἷἸἹἺἻἼἽἾἿὀὁὂὃὄὅ὆὇ὈὉὊὋὌὍ὎὏ὐὑὒὓὔὕὖὗ὘Ὑ὚Ὓ὜Ὕ὞ὟὠὡὢὣὤὥὦὧὨὩὪὫὬὭὮὯὰάὲέὴήὶίὸόὺύὼώ὾὿ᾀᾁᾂᾃᾄᾅᾆᾇᾈᾉᾊᾋᾌᾍᾎᾏᾐᾑᾒᾓᾔᾕᾖᾗᾘᾙᾚᾛᾜᾝᾞᾟᾠᾡᾢᾣᾤᾥᾦᾧᾨᾩᾪᾫᾬᾭᾮᾯᾰᾱᾲᾳᾴ᾵ᾶᾷᾸᾹᾺΆᾼ᾽ι᾿῀῁ῂῃῄ῅ῆῇῈΈῊΉῌ῍῎῏ῐῑῒΐ῔῕ῖῗῘῙῚΊ῜῝῞῟ῠῡῢΰῤῥῦῧῨῩῪΎῬ῭΅`῰῱ῲῳῴ῵ῶῷῸΌῺΏῼ´῾῿', ',') satisfies matches($s, '^(?:\p{IsGreekExtended}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsGreekExtended}+)$')))
(every $s in tokenize('ЀЁЂЃЄЅІЇЈЉЊЋЌЍЎЏАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюяѐёђѓєѕіїјљњћќѝўџѠѡѢѣѤѥѦѧѨѩѪѫѬѭѮѯѰѱѲѳѴѵѶѷѸѹѺѻѼѽѾѿҀҁ҂҃҄҅҆҇҈҉ҊҋҌҍҎҏҐґҒғҔҕҖҗҘҙҚқҜҝҞҟҠҡҢңҤҥҦҧҨҩҪҫҬҭҮүҰұҲҳҴҵҶҷҸҹҺһҼҽҾҿӀӁӂӃӄӅӆӇӈӉӊӋӌӍӎӏӐӑӒӓӔӕӖӗӘәӚӛӜӝӞӟӠӡӢӣӤӥӦӧӨөӪӫӬӭӮӯӰӱӲӳӴӵӶӷӸӹӺӻӼӽӾӿ', ',') satisfies matches($s, '^(?:\p{IsCyrillic}+)$')) and (every $s in tokenize('a', ',') satisfies not(matches($s, '^(?:\p{IsCyrillic}+)$')))
(every $s in tokenize('Ⴀჿ,ႠႡႢႣႤႥႦႧႨႩႪႫႬႭႮႯႰႱႲႳႴႵႶႷႸႹႺႻႼႽႾႿჀჁჂჃჄჅ჆Ⴧ჈჉჊჋჌Ⴭ჎჏აბგდევზთიკლმნოპჟრსტუფქღყშჩცძწჭხჯჰჱჲჳჴჵჶჷჸჹჺ჻ჼჽჾჿ', ',') satisfies matches($s, '^(?:\p{IsGeorgian}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsGeorgian}+)$')))
(every $s in tokenize('א', ',') satisfies matches($s, '^(?:\P{Lm}*)$')) and (every $s in tokenize('ʰﾟ', ',') satisfies not(matches($s, '^(?:\P{Lm}*)$')))
(every $s in tokenize('֐׿,֐ְֱֲֳִֵֶַָֹֺֻּֽ֑֖֛֢֣֤֥֦֧֪֚֭֮֒֓֔֕֗֘֙֜֝֞֟֠֡֨֩֫֬֯־ֿ׀ׁׂ׃ׅׄ׆ׇ׈׉׊׋׌׍׎׏אבגדהוזחטיךכלםמןנסעףפץצקרשת׫׬׭׮ׯװױײ׳״׵׶׷׸׹׺׻׼׽׾׿', ',') satisfies matches($s, '^(?:\p{IsHebrew}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsHebrew}+)$')))
(every $s in tokenize('א𪘀', ',') satisfies matches($s, '^(?:\p{Lo}*)$')) and (every $s in tokenize('ً', ',') satisfies not(matches($s, '^(?:\p{Lo}*)$')))
(every $s in tokenize('ﭐ﷿,ﭐﭑﭒﭓﭔﭕﭖﭗﭘﭙﭚﭛﭜﭝﭞﭟﭠﭡﭢﭣﭤﭥﭦﭧﭨﭩﭪﭫﭬﭭﭮﭯﭰﭱﭲﭳﭴﭵﭶﭷﭸﭹﭺﭻﭼﭽﭾﭿﮀﮁﮂﮃﮄﮅﮆﮇﮈﮉﮊﮋﮌﮍﮎﮏﮐﮑﮒﮓﮔﮕﮖﮗﮘﮙﮚﮛﮜﮝﮞﮟﮠﮡﮢﮣﮤﮥﮦﮧﮨﮩﮪﮫﮬﮭﮮﮯﮰﮱ﮲﮳﮴﮵﮶﮷﮸﮹﮺﮻﮼﮽﮾﮿﯀﯁﯂﯃﯄﯅﯆﯇﯈﯉﯊﯋﯌﯍﯎﯏﯐﯑﯒ﯓﯔﯕﯖﯗﯘﯙﯚﯛﯜﯝﯞﯟﯠﯡﯢﯣﯤﯥﯦﯧﯨﯩﯪﯫﯬﯭﯮﯯﯰﯱﯲﯳﯴﯵﯶﯷﯸﯹﯺﯻﯼﯽﯾﯿﰀﰁﰂﰃﰄﰅﰆﰇﰈﰉﰊﰋﰌﰍﰎﰏﰐﰑﰒﰓﰔﰕﰖﰗﰘﰙﰚﰛﰜﰝﰞﰟﰠﰡﰢﰣﰤﰥﰦﰧﰨﰩﰪﰫﰬﰭﰮﰯﰰﰱﰲﰳﰴﰵﰶﰷﰸﰹﰺﰻﰼﰽﰾﰿﱀﱁﱂﱃﱄﱅﱆﱇﱈﱉﱊﱋﱌﱍﱎﱏﱐﱑﱒﱓﱔﱕﱖﱗﱘﱙﱚﱛﱜﱝﱞﱟﱠﱡﱢﱣﱤﱥﱦﱧﱨﱩﱪﱫﱬﱭﱮﱯﱰﱱﱲﱳﱴﱵﱶﱷﱸﱹﱺﱻﱼﱽﱾﱿﲀﲁﲂﲃﲄﲅﲆﲇﲈﲉﲊﲋﲌﲍﲎﲏﲐﲑﲒﲓﲔﲕﲖﲗﲘﲙﲚﲛﲜﲝﲞﲟﲠﲡﲢﲣﲤﲥﲦﲧﲨﲩﲪﲫﲬﲭﲮﲯﲰﲱﲲﲳﲴﲵﲶﲷﲸﲹﲺﲻﲼﲽﲾﲿﳀﳁﳂﳃﳄﳅﳆﳇﳈﳉﳊﳋﳌﳍﳎﳏﳐﳑﳒﳓﳔﳕﳖﳗﳘﳙﳚﳛﳜﳝﳞﳟﳠﳡﳢﳣﳤﳥﳦﳧﳨﳩﳪﳫﳬﳭﳮﳯﳰﳱﳲﳳﳴﳵﳶﳷﳸﳹﳺﳻﳼﳽﳾﳿﴀﴁﴂﴃﴄﴅﴆﴇﴈﴉﴊﴋﴌﴍﴎﴏﴐﴑﴒﴓﴔﴕﴖﴗﴘﴙﴚﴛﴜﴝﴞﴟﴠﴡﴢﴣﴤﴥﴦﴧﴨﴩﴪﴫﴬﴭﴮﴯﴰﴱﴲﴳﴴﴵﴶﴷﴸﴹﴺﴻﴼﴽ﴾﴿﵀﵁﵂﵃﵄﵅﵆﵇﵈﵉﵊﵋﵌﵍﵎﵏ﵐﵑﵒﵓﵔﵕﵖﵗﵘﵙﵚﵛﵜﵝﵞﵟﵠﵡﵢﵣﵤﵥﵦﵧﵨﵩﵪﵫﵬﵭﵮﵯﵰﵱﵲﵳﵴﵵﵶﵷﵸﵹﵺﵻﵼﵽﵾﵿﶀﶁﶂﶃﶄﶅﶆﶇﶈﶉﶊﶋﶌﶍﶎﶏ﶐﶑ﶒﶓﶔﶕﶖﶗﶘﶙﶚﶛﶜﶝﶞﶟﶠﶡﶢﶣﶤﶥﶦﶧﶨﶩﶪﶫﶬﶭﶮﶯﶰﶱﶲﶳﶴﶵﶶﶷﶸﶹﶺﶻﶼﶽﶾﶿﷀﷁﷂﷃﷄﷅﷆﷇ﷈﷉﷊﷋﷌﷍﷎﷏﷐﷑﷒﷓﷔﷕﷖﷗﷘﷙﷚﷛﷜﷝﷞﷟﷠﷡﷢﷣﷤﷥﷦﷧﷨﷩﷪﷫﷬﷭﷮﷯ﷰﷱﷲﷳﷴﷵﷶﷷﷸﷹﷺﷻ﷼﷽﷾﷿', ',') satisfies matches($s, '^(?:\p{IsArabicPresentationForms-A}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsArabicPresentationForms-A}+)$')))
(every $s in tokenize('),ٙ,ۮ,॥,৥,੥,૥,୥,౥,೥,൥,้,໏,༙,္,፨,៟,᠉,）,𝟍,:,٪,ۺ,॰,ৰ,੹,૰,୰,௰,౰,೰,൰,๚,໚,༪,၊,፲,៪,᠚,：,𝠀', ',') satisfies matches($s, '^(?:\D)$'))          and (every $s in tokenize('0,٠,۰,०,০,૦,௧,౦,೦,൦,๐,໐,༠,၀,០,᠐,０,𝟎,9,٩,۹,९,৯,੯,૯,୯,௯,౯,೯,൯,๙,໙,༩,၉,៩,᠙,９,𝟿', ',') satisfies not(matches($s, '^(?:\D)$')))
(every $s in tokenize('؀ۿ,؀؁؂؃؄؅؆؇؈؉؊؋،؍؎؏ؘؙؚؐؑؒؓؔؕؖؗ؛؜؝؞؟ؠءآأؤإئابةتثجحخدذرزسشصضطظعغػؼؽؾؿـفقكلمنهوىيًٌٍَُِّْٕٖٜٟٓٔٗ٘ٙٚٛٝٞ٠١٢٣٤٥٦٧٨٩٪٫٬٭ٮٯٰٱٲٳٴٵٶٷٸٹٺٻټٽپٿڀځڂڃڄڅچڇڈډڊڋڌڍڎڏڐڑڒړڔڕږڗژڙښڛڜڝڞڟڠڡڢڣڤڥڦڧڨکڪګڬڭڮگڰڱڲڳڴڵڶڷڸڹںڻڼڽھڿۀہۂۃۄۅۆۇۈۉۊۋیۍێۏېۑےۓ۔ەۖۗۘۙۚۛۜ۝۞ۣ۟۠ۡۢۤۥۦۧۨ۩۪ۭ۫۬ۮۯ۰۱۲۳۴۵۶۷۸۹ۺۻۼ۽۾ۿ', ',') satisfies matches($s, '^(?:\p{IsArabic}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsArabic}+)$')))
(every $s in tokenize('܀ݏ,܀܁܂܃܄܅܆܇܈܉܊܋܌܍܎܏ܐܑܒܓܔܕܖܗܘܙܚܛܜܝܞܟܠܡܢܣܤܥܦܧܨܩܪܫܬܭܮܯܱܴܷܸܹܻܼܾ݂݄݆݈ܰܲܳܵܶܺܽܿ݀݁݃݅݇݉݊݋݌ݍݎݏ', ',') satisfies matches($s, '^(?:\p{IsSyriac}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsSyriac}+)$')))
(every $s in tokenize('ހ޿,ހށނރބޅކއވމފދތލގޏސޑޒޓޔޕޖޗޘޙޚޛޜޝޞޟޠޡޢޣޤޥަާިީުޫެޭޮޯްޱ޲޳޴޵޶޷޸޹޺޻޼޽޾޿', ',') satisfies matches($s, '^(?:\p{IsThaana}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsThaana}+)$')))
(every $s in tokenize('ሀ፿,ሀሁሂሃሄህሆሇለሉሊላሌልሎሏሐሑሒሓሔሕሖሗመሙሚማሜምሞሟሠሡሢሣሤሥሦሧረሩሪራሬርሮሯሰሱሲሳሴስሶሷሸሹሺሻሼሽሾሿቀቁቂቃቄቅቆቇቈ቉ቊቋቌቍ቎቏ቐቑቒቓቔቕቖ቗ቘ቙ቚቛቜቝ቞቟በቡቢባቤብቦቧቨቩቪቫቬቭቮቯተቱቲታቴትቶቷቸቹቺቻቼችቾቿኀኁኂኃኄኅኆኇኈ኉ኊኋኌኍ኎኏ነኑኒናኔንኖኗኘኙኚኛኜኝኞኟአኡኢኣኤእኦኧከኩኪካኬክኮኯኰ኱ኲኳኴኵ኶኷ኸኹኺኻኼኽኾ኿ዀ዁ዂዃዄዅ዆዇ወዉዊዋዌውዎዏዐዑዒዓዔዕዖ዗ዘዙዚዛዜዝዞዟዠዡዢዣዤዥዦዧየዩዪያዬይዮዯደዱዲዳዴድዶዷዸዹዺዻዼዽዾዿጀጁጂጃጄጅጆጇገጉጊጋጌግጎጏጐ጑ጒጓጔጕ጖጗ጘጙጚጛጜጝጞጟጠጡጢጣጤጥጦጧጨጩጪጫጬጭጮጯጰጱጲጳጴጵጶጷጸጹጺጻጼጽጾጿፀፁፂፃፄፅፆፇፈፉፊፋፌፍፎፏፐፑፒፓፔፕፖፗፘፙፚ፛፜፝፞፟፠፡።፣፤፥፦፧፨፩፪፫፬፭፮፯፰፱፲፳፴፵፶፷፸፹፺፻፼፽፾፿', ',') satisfies matches($s, '^(?:\p{IsEthiopic}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsEthiopic}+)$')))
(every $s in tokenize('ऀॿ,ऀँंःऄअआइईउऊऋऌऍऎएऐऑऒओऔकखगघङचछजझञटठडढणतथदधनऩपफबभमयरऱलळऴवशषसहऺऻ़ऽािीुूृॄॅॆेैॉॊोौ्ॎॏॐ॒॑॓॔ॕॖॗक़ख़ग़ज़ड़ढ़फ़य़ॠॡॢॣ।॥०१२३४५६७८९॰ॱॲॳॴॵॶॷॸॹॺॻॼॽॾॿ', ',') satisfies matches($s, '^(?:\p{IsDevanagari}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsDevanagari}+)$')))
(every $s in tokenize('ঀ৿,ঀঁংঃ঄অআইঈউঊঋঌ঍঎এঐ঑঒ওঔকখগঘঙচছজঝঞটঠডঢণতথদধন঩পফবভমযর঱ল঳঴঵শষসহ঺঻়ঽািীুূৃৄ৅৆েৈ৉৊োৌ্ৎ৏৐৑৒৓৔৕৖ৗ৘৙৚৛ড়ঢ়৞য়ৠৡৢৣ৤৥০১২৩৪৫৬৭৮৯ৰৱ৲৳৴৵৶৷৸৹৺৻ৼ৽৾৿', ',') satisfies matches($s, '^(?:\p{IsBengali}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsBengali}+)$')))
(every $s in tokenize('਀੿,਀ਁਂਃ਄ਅਆਇਈਉਊ਋਌਍਎ਏਐ਑਒ਓਔਕਖਗਘਙਚਛਜਝਞਟਠਡਢਣਤਥਦਧਨ਩ਪਫਬਭਮਯਰ਱ਲਲ਼਴ਵਸ਼਷ਸਹ਺਻਼਽ਾਿੀੁੂ੃੄੅੆ੇੈ੉੊ੋੌ੍੎੏੐ੑ੒੓੔੕੖੗੘ਖ਼ਗ਼ਜ਼ੜ੝ਫ਼੟੠੡੢੣੤੥੦੧੨੩੪੫੬੭੮੯ੰੱੲੳੴੵ੶੷੸੹੺੻੼੽੾੿', ',') satisfies matches($s, '^(?:\p{IsGurmukhi}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsGurmukhi}+)$')))
(every $s in tokenize('઀૿,઀ઁંઃ઄અઆઇઈઉઊઋઌઍ઎એઐઑ઒ઓઔકખગઘઙચછજઝઞટઠડઢણતથદધન઩પફબભમયર઱લળ઴વશષસહ઺઻઼ઽાિીુૂૃૄૅ૆ેૈૉ૊ોૌ્૎૏ૐ૑૒૓૔૕૖૗૘૙૚૛૜૝૞૟ૠૡૢૣ૤૥૦૧૨૩૪૫૬૭૮૯૰૱૲૳૴૵૶૷૸ૹૺૻૼ૽૾૿', ',') satisfies matches($s, '^(?:\p{IsGujarati}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsGujarati}+)$')))
(every $s in tokenize('଀୿,଀ଁଂଃ଄ଅଆଇଈଉଊଋଌ଍଎ଏଐ଑଒ଓଔକଖଗଘଙଚଛଜଝଞଟଠଡଢଣତଥଦଧନ଩ପଫବଭମଯର଱ଲଳ଴ଵଶଷସହ଺଻଼ଽାିୀୁୂୃୄ୅୆େୈ୉୊ୋୌ୍୎୏୐୑୒୓୔୕ୖୗ୘୙୚୛ଡ଼ଢ଼୞ୟୠୡୢୣ୤୥୦୧୨୩୪୫୬୭୮୯୰ୱ୲୳୴୵୶୷୸୹୺୻୼୽୾୿', ',') satisfies matches($s, '^(?:\p{IsOriya}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsOriya}+)$')))
(every $s in tokenize('஀௿,஀஁ஂஃ஄அஆஇஈஉஊ஋஌஍எஏஐ஑ஒஓஔக஖஗஘ஙச஛ஜ஝ஞட஠஡஢ணத஥஦஧நனப஫஬஭மயரறலளழவஶஷஸஹ஺஻஼஽ாிீுூ௃௄௅ெேை௉ொோௌ்௎௏ௐ௑௒௓௔௕௖ௗ௘௙௚௛௜௝௞௟௠௡௢௣௤௥௦௧௨௩௪௫௬௭௮௯௰௱௲௳௴௵௶௷௸௹௺௻௼௽௾௿', ',') satisfies matches($s, '^(?:\p{IsTamil}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsTamil}+)$')))
(every $s in tokenize('ఀ౿,ఀఁంఃఄఅఆఇఈఉఊఋఌ఍ఎఏఐ఑ఒఓఔకఖగఘఙచఛజఝఞటఠడఢణతథదధన఩పఫబభమయరఱలళఴవశషసహ఺఻఼ఽాిీుూృౄ౅ెేై౉ొోౌ్౎౏౐౑౒౓౔ౕౖ౗ౘౙౚ౛౜ౝ౞౟ౠౡౢౣ౤౥౦౧౨౩౪౫౬౭౮౯౰౱౲౳౴౵౶౷౸౹౺౻౼౽౾౿', ',') satisfies matches($s, '^(?:\p{IsTelugu}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsTelugu}+)$')))
(every $s in tokenize('ಀ೿,ಀಁಂಃ಄ಅಆಇಈಉಊಋಌ಍ಎಏಐ಑ಒಓಔಕಖಗಘಙಚಛಜಝಞಟಠಡಢಣತಥದಧನ಩ಪಫಬಭಮಯರಱಲಳ಴ವಶಷಸಹ಺಻಼ಽಾಿೀುೂೃೄ೅ೆೇೈ೉ೊೋೌ್೎೏೐೑೒೓೔ೕೖ೗೘೙೚೛೜ೝೞ೟ೠೡೢೣ೤೥೦೧೨೩೪೫೬೭೮೯೰ೱೲೳ೴೵೶೷೸೹೺೻೼೽೾೿', ',') satisfies matches($s, '^(?:\p{IsKannada}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsKannada}+)$')))
(every $s in tokenize('ഀൿ,ഀഁംഃഄഅആഇഈഉഊഋഌ഍എഏഐ഑ഒഓഔകഖഗഘങചഛജഝഞടഠഡഢണതഥദധനഩപഫബഭമയരറലളഴവശഷസഹഺ഻഼ഽാിീുൂൃൄ൅െേൈ൉ൊോൌ്ൎ൏൐൑൒൓ൔൕൖൗ൘൙൚൛൜൝൞ൟൠൡൢൣ൤൥൦൧൨൩൪൫൬൭൮൯൰൱൲൳൴൵൶൷൸൹ൺൻർൽൾൿ', ',') satisfies matches($s, '^(?:\p{IsMalayalam}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsMalayalam}+)$')))
(every $s in tokenize('඀෿,඀ඁංඃ඄අආඇඈඉඊඋඌඍඎඏඐඑඒඓඔඕඖ඗඘඙කඛගඝඞඟචඡජඣඤඥඦටඨඩඪණඬතථදධන඲ඳපඵබභමඹයර඼ල඾඿වශෂසහළෆ෇෈෉්෋෌෍෎ාැෑිීු෕ූ෗ෘෙේෛොෝෞෟ෠෡෢෣෤෥෦෧෨෩෪෫෬෭෮෯෰෱ෲෳ෴෵෶෷෸෹෺෻෼෽෾෿', ',') satisfies matches($s, '^(?:\p{IsSinhala}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsSinhala}+)$')))
(every $s in tokenize('฀๿,฀กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู฻฼฽฾฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛๜๝๞๟๠๡๢๣๤๥๦๧๨๩๪๫๬๭๮๯๰๱๲๳๴๵๶๷๸๹๺๻๼๽๾๿', ',') satisfies matches($s, '^(?:\p{IsThai}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsThai}+)$')))
(every $s in tokenize('຀໿,຀ກຂ຃ຄ຅ຆງຈຉຊ຋ຌຍຎຏຐຑຒຓດຕຖທຘນບປຜຝພຟຠມຢຣ຤ລ຦ວຨຩສຫຬອຮຯະັາຳິີຶື຺ຸູົຼຽ຾຿ເແໂໃໄ໅ໆ໇່້໊໋໌ໍ໎໏໐໑໒໓໔໕໖໗໘໙໚໛ໜໝໞໟ໠໡໢໣໤໥໦໧໨໩໪໫໬໭໮໯໰໱໲໳໴໵໶໷໸໹໺໻໼໽໾໿', ',') satisfies matches($s, '^(?:\p{IsLao}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsLao}+)$')))
(every $s in tokenize('ༀ࿿,ༀ༁༂༃༄༅༆༇༈༉༊་༌།༎༏༐༑༒༓༔༕༖༗༘༙༚༛༜༝༞༟༠༡༢༣༤༥༦༧༨༩༪༫༬༭༮༯༰༱༲༳༴༵༶༷༸༹༺༻༼༽༾༿ཀཁགགྷངཅཆཇ཈ཉཊཋཌཌྷཎཏཐདདྷནཔཕབབྷམཙཚཛཛྷཝཞཟའཡརལཤཥསཧཨཀྵཪཫཬ཭཮཯཰ཱཱཱིིུུྲྀཷླྀཹེཻོཽཾཿ྄ཱྀྀྂྃ྅྆྇ྈྉྊྋྌྍྎྏྐྑྒྒྷྔྕྖྗ྘ྙྚྛྜྜྷྞྟྠྡྡྷྣྤྥྦྦྷྨྩྪྫྫྷྭྮྯྰྱྲླྴྵྶྷྸྐྵྺྻྼ྽྾྿࿀࿁࿂࿃࿄࿅࿆࿇࿈࿉࿊࿋࿌࿍࿎࿏࿐࿑࿒࿓࿔࿕࿖࿗࿘࿙࿚࿛࿜࿝࿞࿟࿠࿡࿢࿣࿤࿥࿦࿧࿨࿩࿪࿫࿬࿭࿮࿯࿰࿱࿲࿳࿴࿵࿶࿷࿸࿹࿺࿻࿼࿽࿾࿿', ',') satisfies matches($s, '^(?:\p{IsTibetan}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsTibetan}+)$')))
(every $s in tokenize('က႟,ကခဂဃငစဆဇဈဉညဋဌဍဎဏတထဒဓနပဖဗဘမယရလဝသဟဠအဢဣဤဥဦဧဨဩဪါာိီုူေဲဳဴဵံ့း္်ျြွှဿ၀၁၂၃၄၅၆၇၈၉၊။၌၍၎၏ၐၑၒၓၔၕၖၗၘၙၚၛၜၝၞၟၠၡၢၣၤၥၦၧၨၩၪၫၬၭၮၯၰၱၲၳၴၵၶၷၸၹၺၻၼၽၾၿႀႁႂႃႄႅႆႇႈႉႊႋႌႍႎႏ႐႑႒႓႔႕႖႗႘႙ႚႛႜႝ႞႟', ',') satisfies matches($s, '^(?:\p{IsMyanmar}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsMyanmar}+)$')))
(every $s in tokenize('ក៿,កខគឃងចឆជឈញដឋឌឍណតថទធនបផពភមយរលវឝឞសហឡអឣឤឥឦឧឨឩឪឫឬឭឮឯឰឱឲឳ឴឵ាិីឹឺុូួើឿៀេែៃោៅំះៈ៉៊់៌៍៎៏័៑្៓។៕៖ៗ៘៙៚៛ៜ៝៞៟០១២៣៤៥៦៧៨៩៪៫៬៭៮៯៰៱៲៳៴៵៶៷៸៹៺៻៼៽៾៿', ',') satisfies matches($s, '^(?:\p{IsKhmer}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsKhmer}+)$')))
(every $s in tokenize('Ꭰ᏿,ᎠᎡᎢᎣᎤᎥᎦᎧᎨᎩᎪᎫᎬᎭᎮᎯᎰᎱᎲᎳᎴᎵᎶᎷᎸᎹᎺᎻᎼᎽᎾᎿᏀᏁᏂᏃᏄᏅᏆᏇᏈᏉᏊᏋᏌᏍᏎᏏᏐᏑᏒᏓᏔᏕᏖᏗᏘᏙᏚᏛᏜᏝᏞᏟᏠᏡᏢᏣᏤᏥᏦᏧᏨᏩᏪᏫᏬᏭᏮᏯᏰᏱᏲᏳᏴᏵ᏶᏷ᏸᏹᏺᏻᏼᏽ᏾᏿', ',') satisfies matches($s, '^(?:\p{IsCherokee}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCherokee}+)$')))
(every $s in tokenize('᐀ᙿ,᐀ᐁᐂᐃᐄᐅᐆᐇᐈᐉᐊᐋᐌᐍᐎᐏᐐᐑᐒᐓᐔᐕᐖᐗᐘᐙᐚᐛᐜᐝᐞᐟᐠᐡᐢᐣᐤᐥᐦᐧᐨᐩᐪᐫᐬᐭᐮᐯᐰᐱᐲᐳᐴᐵᐶᐷᐸᐹᐺᐻᐼᐽᐾᐿᑀᑁᑂᑃᑄᑅᑆᑇᑈᑉᑊᑋᑌᑍᑎᑏᑐᑑᑒᑓᑔᑕᑖᑗᑘᑙᑚᑛᑜᑝᑞᑟᑠᑡᑢᑣᑤᑥᑦᑧᑨᑩᑪᑫᑬᑭᑮᑯᑰᑱᑲᑳᑴᑵᑶᑷᑸᑹᑺᑻᑼᑽᑾᑿᒀᒁᒂᒃᒄᒅᒆᒇᒈᒉᒊᒋᒌᒍᒎᒏᒐᒑᒒᒓᒔᒕᒖᒗᒘᒙᒚᒛᒜᒝᒞᒟᒠᒡᒢᒣᒤᒥᒦᒧᒨᒩᒪᒫᒬᒭᒮᒯᒰᒱᒲᒳᒴᒵᒶᒷᒸᒹᒺᒻᒼᒽᒾᒿᓀᓁᓂᓃᓄᓅᓆᓇᓈᓉᓊᓋᓌᓍᓎᓏᓐᓑᓒᓓᓔᓕᓖᓗᓘᓙᓚᓛᓜᓝᓞᓟᓠᓡᓢᓣᓤᓥᓦᓧᓨᓩᓪᓫᓬᓭᓮᓯᓰᓱᓲᓳᓴᓵᓶᓷᓸᓹᓺᓻᓼᓽᓾᓿᔀᔁᔂᔃᔄᔅᔆᔇᔈᔉᔊᔋᔌᔍᔎᔏᔐᔑᔒᔓᔔᔕᔖᔗᔘᔙᔚᔛᔜᔝᔞᔟᔠᔡᔢᔣᔤᔥᔦᔧᔨᔩᔪᔫᔬᔭᔮᔯᔰᔱᔲᔳᔴᔵᔶᔷᔸᔹᔺᔻᔼᔽᔾᔿᕀᕁᕂᕃᕄᕅᕆᕇᕈᕉᕊᕋᕌᕍᕎᕏᕐᕑᕒᕓᕔᕕᕖᕗᕘᕙᕚᕛᕜᕝᕞᕟᕠᕡᕢᕣᕤᕥᕦᕧᕨᕩᕪᕫᕬᕭᕮᕯᕰᕱᕲᕳᕴᕵᕶᕷᕸᕹᕺᕻᕼᕽᕾᕿᖀᖁᖂᖃᖄᖅᖆᖇᖈᖉᖊᖋᖌᖍᖎᖏᖐᖑᖒᖓᖔᖕᖖᖗᖘᖙᖚᖛᖜᖝᖞᖟᖠᖡᖢᖣᖤᖥᖦᖧᖨᖩᖪᖫᖬᖭᖮᖯᖰᖱᖲᖳᖴᖵᖶᖷᖸᖹᖺᖻᖼᖽᖾᖿᗀᗁᗂᗃᗄᗅᗆᗇᗈᗉᗊᗋᗌᗍᗎᗏᗐᗑᗒᗓᗔᗕᗖᗗᗘᗙᗚᗛᗜᗝᗞᗟᗠᗡᗢᗣᗤᗥᗦᗧᗨᗩᗪᗫᗬᗭᗮᗯᗰᗱᗲᗳᗴᗵᗶᗷᗸᗹᗺᗻᗼᗽᗾᗿᘀᘁᘂᘃᘄᘅᘆᘇᘈᘉᘊᘋᘌᘍᘎᘏᘐᘑᘒᘓᘔᘕᘖᘗᘘᘙᘚᘛᘜᘝᘞᘟᘠᘡᘢᘣᘤᘥᘦᘧᘨᘩᘪᘫᘬᘭᘮᘯᘰᘱᘲᘳᘴᘵᘶᘷᘸᘹᘺᘻᘼᘽᘾᘿᙀᙁᙂᙃᙄᙅᙆᙇᙈᙉᙊᙋᙌᙍᙎᙏᙐᙑᙒᙓᙔᙕᙖᙗᙘᙙᙚᙛᙜᙝᙞᙟᙠᙡᙢᙣᙤᙥᙦᙧᙨᙩᙪᙫᙬ᙭᙮ᙯᙰᙱᙲᙳᙴᙵᙶᙷᙸᙹᙺᙻᙼᙽᙾᙿ', ',') satisfies matches($s, '^(?:\p{IsUnifiedCanadianAboriginalSyllabics}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsUnifiedCanadianAboriginalSyllabics}+)$')))
(every $s in tokenize(' ᚟, ᚁᚂᚃᚄᚅᚆᚇᚈᚉᚊᚋᚌᚍᚎᚏᚐᚑᚒᚓᚔᚕᚖᚗᚘᚙᚚ᚛᚜᚝᚞᚟', ',') satisfies matches($s, '^(?:\p{IsOgham}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsOgham}+)$')))
(every $s in tokenize('ᚠ᛿,ᚠᚡᚢᚣᚤᚥᚦᚧᚨᚩᚪᚫᚬᚭᚮᚯᚰᚱᚲᚳᚴᚵᚶᚷᚸᚹᚺᚻᚼᚽᚾᚿᛀᛁᛂᛃᛄᛅᛆᛇᛈᛉᛊᛋᛌᛍᛎᛏᛐᛑᛒᛓᛔᛕᛖᛗᛘᛙᛚᛛᛜᛝᛞᛟᛠᛡᛢᛣᛤᛥᛦᛧᛨᛩᛪ᛫᛬᛭ᛮᛯᛰᛱᛲᛳᛴᛵᛶᛷᛸ᛹᛺᛻᛼᛽᛾᛿', ',') satisfies matches($s, '^(?:\p{IsRunic}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsRunic}+)$')))
(every $s in tokenize('㈀㋿,㈀㈁㈂㈃㈄㈅㈆㈇㈈㈉㈊㈋㈌㈍㈎㈏㈐㈑㈒㈓㈔㈕㈖㈗㈘㈙㈚㈛㈜㈝㈞㈟㈠㈡㈢㈣㈤㈥㈦㈧㈨㈩㈪㈫㈬㈭㈮㈯㈰㈱㈲㈳㈴㈵㈶㈷㈸㈹㈺㈻㈼㈽㈾㈿㉀㉁㉂㉃㉄㉅㉆㉇㉈㉉㉊㉋㉌㉍㉎㉏㉐㉑㉒㉓㉔㉕㉖㉗㉘㉙㉚㉛㉜㉝㉞㉟㉠㉡㉢㉣㉤㉥㉦㉧㉨㉩㉪㉫㉬㉭㉮㉯㉰㉱㉲㉳㉴㉵㉶㉷㉸㉹㉺㉻㉼㉽㉾㉿㊀㊁㊂㊃㊄㊅㊆㊇㊈㊉㊊㊋㊌㊍㊎㊏㊐㊑㊒㊓㊔㊕㊖㊗㊘㊙㊚㊛㊜㊝㊞㊟㊠㊡㊢㊣㊤㊥㊦㊧㊨㊩㊪㊫㊬㊭㊮㊯㊰㊱㊲㊳㊴㊵㊶㊷㊸㊹㊺㊻㊼㊽㊾㊿㋀㋁㋂㋃㋄㋅㋆㋇㋈㋉㋊㋋㋌㋍㋎㋏㋐㋑㋒㋓㋔㋕㋖㋗㋘㋙㋚㋛㋜㋝㋞㋟㋠㋡㋢㋣㋤㋥㋦㋧㋨㋩㋪㋫㋬㋭㋮㋯㋰㋱㋲㋳㋴㋵㋶㋷㋸㋹㋺㋻㋼㋽㋾㋿', ',') satisfies matches($s, '^(?:\p{IsEnclosedCJKLettersandMonths}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsEnclosedCJKLettersandMonths}+)$')))
(every $s in tokenize('㄰㆏,㄰ㄱㄲㄳㄴㄵㄶㄷㄸㄹㄺㄻㄼㄽㄾㄿㅀㅁㅂㅃㅄㅅㅆㅇㅈㅉㅊㅋㅌㅍㅎㅏㅐㅑㅒㅓㅔㅕㅖㅗㅘㅙㅚㅛㅜㅝㅞㅟㅠㅡㅢㅣㅤㅥㅦㅧㅨㅩㅪㅫㅬㅭㅮㅯㅰㅱㅲㅳㅴㅵㅶㅷㅸㅹㅺㅻㅼㅽㅾㅿㆀㆁㆂㆃㆄㆅㆆㆇㆈㆉㆊㆋㆌㆍㆎ㆏', ',') satisfies matches($s, '^(?:\p{IsHangulCompatibilityJamo}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsHangulCompatibilityJamo}+)$')))
(every $s in tokenize('ᄀᇿ,ᄀᄁᄂᄃᄄᄅᄆᄇᄈᄉᄊᄋᄌᄍᄎᄏᄐᄑᄒᄓᄔᄕᄖᄗᄘᄙᄚᄛᄜᄝᄞᄟᄠᄡᄢᄣᄤᄥᄦᄧᄨᄩᄪᄫᄬᄭᄮᄯᄰᄱᄲᄳᄴᄵᄶᄷᄸᄹᄺᄻᄼᄽᄾᄿᅀᅁᅂᅃᅄᅅᅆᅇᅈᅉᅊᅋᅌᅍᅎᅏᅐᅑᅒᅓᅔᅕᅖᅗᅘᅙᅚᅛᅜᅝᅞᅟᅠᅡᅢᅣᅤᅥᅦᅧᅨᅩᅪᅫᅬᅭᅮᅯᅰᅱᅲᅳᅴᅵᅶᅷᅸᅹᅺᅻᅼᅽᅾᅿᆀᆁᆂᆃᆄᆅᆆᆇᆈᆉᆊᆋᆌᆍᆎᆏᆐᆑᆒᆓᆔᆕᆖᆗᆘᆙᆚᆛᆜᆝᆞᆟᆠᆡᆢᆣᆤᆥᆦᆧᆨᆩᆪᆫᆬᆭᆮᆯᆰᆱᆲᆳᆴᆵᆶᆷᆸᆹᆺᆻᆼᆽᆾᆿᇀᇁᇂᇃᇄᇅᇆᇇᇈᇉᇊᇋᇌᇍᇎᇏᇐᇑᇒᇓᇔᇕᇖᇗᇘᇙᇚᇛᇜᇝᇞᇟᇠᇡᇢᇣᇤᇥᇦᇧᇨᇩᇪᇫᇬᇭᇮᇯᇰᇱᇲᇳᇴᇵᇶᇷᇸᇹᇺᇻᇼᇽᇾᇿ', ',') satisfies matches($s, '^(?:\p{IsHangulJamo}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsHangulJamo}+)$')))
(every $s in tokenize('㌀㏿,㌀㌁㌂㌃㌄㌅㌆㌇㌈㌉㌊㌋㌌㌍㌎㌏㌐㌑㌒㌓㌔㌕㌖㌗㌘㌙㌚㌛㌜㌝㌞㌟㌠㌡㌢㌣㌤㌥㌦㌧㌨㌩㌪㌫㌬㌭㌮㌯㌰㌱㌲㌳㌴㌵㌶㌷㌸㌹㌺㌻㌼㌽㌾㌿㍀㍁㍂㍃㍄㍅㍆㍇㍈㍉㍊㍋㍌㍍㍎㍏㍐㍑㍒㍓㍔㍕㍖㍗㍘㍙㍚㍛㍜㍝㍞㍟㍠㍡㍢㍣㍤㍥㍦㍧㍨㍩㍪㍫㍬㍭㍮㍯㍰㍱㍲㍳㍴㍵㍶㍷㍸㍹㍺㍻㍼㍽㍾㍿㎀㎁㎂㎃㎄㎅㎆㎇㎈㎉㎊㎋㎌㎍㎎㎏㎐㎑㎒㎓㎔㎕㎖㎗㎘㎙㎚㎛㎜㎝㎞㎟㎠㎡㎢㎣㎤㎥㎦㎧㎨㎩㎪㎫㎬㎭㎮㎯㎰㎱㎲㎳㎴㎵㎶㎷㎸㎹㎺㎻㎼㎽㎾㎿㏀㏁㏂㏃㏄㏅㏆㏇㏈㏉㏊㏋㏌㏍㏎㏏㏐㏑㏒㏓㏔㏕㏖㏗㏘㏙㏚㏛㏜㏝㏞㏟㏠㏡㏢㏣㏤㏥㏦㏧㏨㏩㏪㏫㏬㏭㏮㏯㏰㏱㏲㏳㏴㏵㏶㏷㏸㏹㏺㏻㏼㏽㏾㏿', ',') satisfies matches($s, '^(?:\p{IsCJKCompatibility}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCJKCompatibility}+)$')))
(every $s in tokenize('゠ヿ,゠ァアィイゥウェエォオカガキギクグケゲコゴサザシジスズセゼソゾタダチヂッツヅテデトドナニヌネノハバパヒビピフブプヘベペホボポマミムメモャヤュユョヨラリルレロヮワヰヱヲンヴヵヶヷヸヹヺ・ーヽヾヿ', ',') satisfies matches($s, '^(?:\p{IsKatakana}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsKatakana}+)$')))
(every $s in tokenize('぀ゟ,぀ぁあぃいぅうぇえぉおかがきぎくぐけげこごさざしじすずせぜそぞただちぢっつづてでとどなにぬねのはばぱひびぴふぶぷへべぺほぼぽまみむめもゃやゅゆょよらりるれろゎわゐゑをんゔゕゖ゗゘゙゚゛゜ゝゞゟ', ',') satisfies matches($s, '^(?:\p{IsHiragana}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsHiragana}+)$')))
(every $s in tokenize('ㆠㆿ,ㆠㆡㆢㆣㆤㆥㆦㆧㆨㆩㆪㆫㆬㆭㆮㆯㆰㆱㆲㆳㆴㆵㆶㆷㆸㆹㆺㆻㆼㆽㆾㆿ', ',') satisfies matches($s, '^(?:\p{IsBopomofoExtended}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsBopomofoExtended}+)$')))
(every $s in tokenize('㄀ㄯ,㄀㄁㄂㄃㄄ㄅㄆㄇㄈㄉㄊㄋㄌㄍㄎㄏㄐㄑㄒㄓㄔㄕㄖㄗㄘㄙㄚㄛㄜㄝㄞㄟㄠㄡㄢㄣㄤㄥㄦㄧㄨㄩㄪㄫㄬㄭㄮㄯ', ',') satisfies matches($s, '^(?:\p{IsBopomofo}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsBopomofo}+)$')))
(every $s in tokenize('ꀀ꒏,ꀀꀁꀂꀃꀄꀅꀆꀇꀈꀉꀊꀋꀌꀍꀎꀏꀐꀑꀒꀓꀔꀕꀖꀗꀘꀙꀚꀛꀜꀝꀞꀟꀠꀡꀢꀣꀤꀥꀦꀧꀨꀩꀪꀫꀬꀭꀮꀯꀰꀱꀲꀳꀴꀵꀶꀷꀸꀹꀺꀻꀼꀽꀾꀿꁀꁁꁂꁃꁄꁅꁆꁇꁈꁉꁊꁋꁌꁍꁎꁏꁐꁑꁒꁓꁔꁕꁖꁗꁘꁙꁚꁛꁜꁝꁞꁟꁠꁡꁢꁣꁤꁥꁦꁧꁨꁩꁪꁫꁬꁭꁮꁯꁰꁱꁲꁳꁴꁵꁶꁷꁸꁹꁺꁻꁼꁽꁾꁿꂀꂁꂂꂃꂄꂅꂆꂇꂈꂉꂊꂋꂌꂍꂎꂏꂐꂑꂒꂓꂔꂕꂖꂗꂘꂙꂚꂛꂜꂝꂞꂟꂠꂡꂢꂣꂤꂥꂦꂧꂨꂩꂪꂫꂬꂭꂮꂯꂰꂱꂲꂳꂴꂵꂶꂷꂸꂹꂺꂻꂼꂽꂾꂿꃀꃁꃂꃃꃄꃅꃆꃇꃈꃉꃊꃋꃌꃍꃎꃏꃐꃑꃒꃓꃔꃕꃖꃗꃘꃙꃚꃛꃜꃝꃞꃟꃠꃡꃢꃣꃤꃥꃦꃧꃨꃩꃪꃫꃬꃭꃮꃯꃰꃱꃲꃳꃴꃵꃶꃷꃸꃹꃺꃻꃼꃽꃾꃿꄀꄁꄂꄃꄄꄅꄆꄇꄈꄉꄊꄋꄌꄍꄎꄏꄐꄑꄒꄓꄔꄕꄖꄗꄘꄙꄚꄛꄜꄝꄞꄟꄠꄡꄢꄣꄤꄥꄦꄧꄨꄩꄪꄫꄬꄭꄮꄯꄰꄱꄲꄳꄴꄵꄶꄷꄸꄹꄺꄻꄼꄽꄾꄿꅀꅁꅂꅃꅄꅅꅆꅇꅈꅉꅊꅋꅌꅍꅎꅏꅐꅑꅒꅓꅔꅕꅖꅗꅘꅙꅚꅛꅜꅝꅞꅟꅠꅡꅢꅣꅤꅥꅦꅧꅨꅩꅪꅫꅬꅭꅮꅯꅰꅱꅲꅳꅴꅵꅶꅷꅸꅹꅺꅻꅼꅽꅾꅿꆀꆁꆂꆃꆄꆅꆆꆇꆈꆉꆊꆋꆌꆍꆎꆏꆐꆑꆒꆓꆔꆕꆖꆗꆘꆙꆚꆛꆜꆝꆞꆟꆠꆡꆢꆣꆤꆥꆦꆧꆨꆩꆪꆫꆬꆭꆮꆯꆰꆱꆲꆳꆴꆵꆶꆷꆸꆹꆺꆻꆼꆽꆾꆿꇀꇁꇂꇃꇄꇅꇆꇇꇈꇉꇊꇋꇌꇍꇎꇏꇐꇑꇒꇓꇔꇕꇖꇗꇘꇙꇚꇛꇜꇝꇞꇟꇠꇡꇢꇣꇤꇥꇦꇧꇨꇩꇪꇫꇬꇭꇮꇯꇰꇱꇲꇳꇴꇵꇶꇷꇸꇹꇺꇻꇼꇽꇾꇿꈀꈁꈂꈃꈄꈅꈆꈇꈈꈉꈊꈋꈌꈍꈎꈏꈐꈑꈒꈓꈔꈕꈖꈗꈘꈙꈚꈛꈜꈝꈞꈟꈠꈡꈢꈣꈤꈥꈦꈧꈨꈩꈪꈫꈬꈭꈮꈯꈰꈱꈲꈳꈴꈵꈶꈷꈸꈹꈺꈻꈼꈽꈾꈿꉀꉁꉂꉃꉄꉅꉆꉇꉈꉉꉊꉋꉌꉍꉎꉏꉐꉑꉒꉓꉔꉕꉖꉗꉘꉙꉚꉛꉜꉝꉞꉟꉠꉡꉢꉣꉤꉥꉦꉧꉨꉩꉪꉫꉬꉭꉮꉯꉰꉱꉲꉳꉴꉵꉶꉷꉸꉹꉺꉻꉼꉽꉾꉿꊀꊁꊂꊃꊄꊅꊆꊇꊈꊉꊊꊋꊌꊍꊎꊏꊐꊑꊒꊓꊔꊕꊖꊗꊘꊙꊚꊛꊜꊝꊞꊟꊠꊡꊢꊣꊤꊥꊦꊧꊨꊩꊪꊫꊬꊭꊮꊯꊰꊱꊲꊳꊴꊵꊶꊷꊸꊹꊺꊻꊼꊽꊾꊿꋀꋁꋂꋃꋄꋅꋆꋇꋈꋉꋊꋋꋌꋍꋎꋏꋐꋑꋒꋓꋔꋕꋖꋗꋘꋙꋚꋛꋜꋝꋞꋟꋠꋡꋢꋣꋤꋥꋦꋧꋨꋩꋪꋫꋬꋭꋮꋯꋰꋱꋲꋳꋴꋵꋶꋷꋸꋹꋺꋻꋼꋽꋾꋿꌀꌁꌂꌃꌄꌅꌆꌇꌈꌉꌊꌋꌌꌍꌎꌏꌐꌑꌒꌓꌔꌕꌖꌗꌘꌙꌚꌛꌜꌝꌞꌟꌠꌡꌢꌣꌤꌥꌦꌧꌨꌩꌪꌫꌬꌭꌮꌯꌰꌱꌲꌳꌴꌵꌶꌷꌸꌹꌺꌻꌼꌽꌾꌿꍀꍁꍂꍃꍄꍅꍆꍇꍈꍉꍊꍋꍌꍍꍎꍏꍐꍑꍒꍓꍔꍕꍖꍗꍘꍙꍚꍛꍜꍝꍞꍟꍠꍡꍢꍣꍤꍥꍦꍧꍨꍩꍪꍫꍬꍭꍮꍯꍰꍱꍲꍳꍴꍵꍶꍷꍸꍹꍺꍻꍼꍽꍾꍿꎀꎁꎂꎃꎄꎅꎆꎇꎈꎉꎊꎋꎌꎍꎎꎏꎐꎑꎒꎓꎔꎕꎖꎗꎘꎙꎚꎛꎜꎝꎞꎟꎠꎡꎢꎣꎤꎥꎦꎧꎨꎩꎪꎫꎬꎭꎮꎯꎰꎱꎲꎳꎴꎵꎶꎷꎸꎹꎺꎻꎼꎽꎾꎿꏀꏁꏂꏃꏄꏅꏆꏇꏈꏉꏊꏋꏌꏍꏎꏏꏐꏑꏒꏓꏔꏕꏖꏗꏘꏙꏚꏛꏜꏝꏞꏟꏠꏡꏢꏣꏤꏥꏦꏧꏨꏩꏪꏫꏬꏭꏮꏯꏰꏱꏲꏳꏴꏵꏶꏷꏸꏹꏺꏻꏼꏽꏾꏿꐀꐁꐂꐃꐄꐅꐆꐇꐈꐉꐊꐋꐌꐍꐎꐏꐐꐑꐒꐓꐔꐕꐖꐗꐘꐙꐚꐛꐜꐝꐞꐟꐠꐡꐢꐣꐤꐥꐦꐧꐨꐩꐪꐫꐬꐭꐮꐯꐰꐱꐲꐳꐴꐵꐶꐷꐸꐹꐺꐻꐼꐽꐾꐿꑀꑁꑂꑃꑄꑅꑆꑇꑈꑉꑊꑋꑌꑍꑎꑏꑐꑑꑒꑓꑔꑕꑖꑗꑘꑙꑚꑛꑜꑝꑞꑟꑠꑡꑢꑣꑤꑥꑦꑧꑨꑩꑪꑫꑬꑭꑮꑯꑰꑱꑲꑳꑴꑵꑶꑷꑸꑹꑺꑻꑼꑽꑾꑿꒀꒁꒂꒃꒄꒅꒆꒇꒈꒉꒊꒋꒌ꒍꒎꒏', ',') satisfies matches($s, '^(?:\p{IsYiSyllables}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsYiSyllables}+)$')))
(every $s in tokenize('𐍊〥', ',') satisfies matches($s, '^(?:\p{Nl}*)$')) and (every $s in tokenize('²', ',') satisfies not(matches($s, '^(?:\p{Nl}*)$')))
(every $s in tokenize('𐍊', ',') satisfies matches($s, '^(?:\P{Nd}*)$')) and (every $s in tokenize('０𝟿', ',') satisfies not(matches($s, '^(?:\P{Nd}*)$')))
(every $s in tokenize('𐀀', ',') satisfies matches($s, '^(?:[𐀀])$')) and (every $s in tokenize('𐀁', ',') satisfies not(matches($s, '^(?:[𐀀])$')))
(every $s in tokenize('⼀⿟,⼀⼁⼂⼃⼄⼅⼆⼇⼈⼉⼊⼋⼌⼍⼎⼏⼐⼑⼒⼓⼔⼕⼖⼗⼘⼙⼚⼛⼜⼝⼞⼟⼠⼡⼢⼣⼤⼥⼦⼧⼨⼩⼪⼫⼬⼭⼮⼯⼰⼱⼲⼳⼴⼵⼶⼷⼸⼹⼺⼻⼼⼽⼾⼿⽀⽁⽂⽃⽄⽅⽆⽇⽈⽉⽊⽋⽌⽍⽎⽏⽐⽑⽒⽓⽔⽕⽖⽗⽘⽙⽚⽛⽜⽝⽞⽟⽠⽡⽢⽣⽤⽥⽦⽧⽨⽩⽪⽫⽬⽭⽮⽯⽰⽱⽲⽳⽴⽵⽶⽷⽸⽹⽺⽻⽼⽽⽾⽿⾀⾁⾂⾃⾄⾅⾆⾇⾈⾉⾊⾋⾌⾍⾎⾏⾐⾑⾒⾓⾔⾕⾖⾗⾘⾙⾚⾛⾜⾝⾞⾟⾠⾡⾢⾣⾤⾥⾦⾧⾨⾩⾪⾫⾬⾭⾮⾯⾰⾱⾲⾳⾴⾵⾶⾷⾸⾹⾺⾻⾼⾽⾾⾿⿀⿁⿂⿃⿄⿅⿆⿇⿈⿉⿊⿋⿌⿍⿎⿏⿐⿑⿒⿓⿔⿕⿖⿗⿘⿙⿚⿛⿜⿝⿞⿟', ',') satisfies matches($s, '^(?:\p{IsKangxiRadicals}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsKangxiRadicals}+)$')))
(every $s in tokenize('⺀⻿,⺀⺁⺂⺃⺄⺅⺆⺇⺈⺉⺊⺋⺌⺍⺎⺏⺐⺑⺒⺓⺔⺕⺖⺗⺘⺙⺚⺛⺜⺝⺞⺟⺠⺡⺢⺣⺤⺥⺦⺧⺨⺩⺪⺫⺬⺭⺮⺯⺰⺱⺲⺳⺴⺵⺶⺷⺸⺹⺺⺻⺼⺽⺾⺿⻀⻁⻂⻃⻄⻅⻆⻇⻈⻉⻊⻋⻌⻍⻎⻏⻐⻑⻒⻓⻔⻕⻖⻗⻘⻙⻚⻛⻜⻝⻞⻟⻠⻡⻢⻣⻤⻥⻦⻧⻨⻩⻪⻫⻬⻭⻮⻯⻰⻱⻲⻳⻴⻵⻶⻷⻸⻹⻺⻻⻼⻽⻾⻿', ',') satisfies matches($s, '^(?:\p{IsCJKRadicalsSupplement}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCJKRadicalsSupplement}+)$')))
(every $s in tokenize('㆐㆟,㆐㆑㆒㆓㆔㆕㆖㆗㆘㆙㆚㆛㆜㆝㆞㆟', ',') satisfies matches($s, '^(?:\p{IsKanbun}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsKanbun}+)$')))
(every $s in tokenize('豈﫿,豈更車賈滑串句龜龜契金喇奈懶癩羅蘿螺裸邏樂洛烙珞落酪駱亂卵欄爛蘭鸞嵐濫藍襤拉臘蠟廊朗浪狼郎來冷勞擄櫓爐盧老蘆虜路露魯鷺碌祿綠菉錄鹿論壟弄籠聾牢磊賂雷壘屢樓淚漏累縷陋勒肋凜凌稜綾菱陵讀拏樂諾丹寧怒率異北磻便復不泌數索參塞省葉說殺辰沈拾若掠略亮兩凉梁糧良諒量勵呂女廬旅濾礪閭驪麗黎力曆歷轢年憐戀撚漣煉璉秊練聯輦蓮連鍊列劣咽烈裂說廉念捻殮簾獵令囹寧嶺怜玲瑩羚聆鈴零靈領例禮醴隸惡了僚寮尿料樂燎療蓼遼龍暈阮劉杻柳流溜琉留硫紐類六戮陸倫崙淪輪律慄栗率隆利吏履易李梨泥理痢罹裏裡里離匿溺吝燐璘藺隣鱗麟林淋臨立笠粒狀炙識什茶刺切度拓糖宅洞暴輻行降見廓兀嗀﨎﨏塚﨑晴﨓﨔凞猪益礼神祥福靖精羽﨟蘒﨡諸﨣﨤逸都﨧﨨﨩飯飼館鶴郞隷侮僧免勉勤卑喝嘆器塀墨層屮悔慨憎懲敏既暑梅海渚漢煮爫琢碑社祉祈祐祖祝禍禎穀突節練縉繁署者臭艹艹著褐視謁謹賓贈辶逸難響頻恵𤋮舘﩮﩯並况全侀充冀勇勺喝啕喙嗢塚墳奄奔婢嬨廒廙彩徭惘慎愈憎慠懲戴揄搜摒敖晴朗望杖歹殺流滛滋漢瀞煮瞧爵犯猪瑱甆画瘝瘟益盛直睊着磌窱節类絛練缾者荒華蝹襁覆視調諸請謁諾諭謹變贈輸遲醙鉶陼難靖韛響頋頻鬒龜𢡊𢡄𣏕㮝䀘䀹𥉉𥳐𧻓齃龎﫚﫛﫜﫝﫞﫟﫠﫡﫢﫣﫤﫥﫦﫧﫨﫩﫪﫫﫬﫭﫮﫯﫰﫱﫲﫳﫴﫵﫶﫷﫸﫹﫺﫻﫼﫽﫾﫿', ',') satisfies matches($s, '^(?:\p{IsCJKCompatibilityIdeographs}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCJKCompatibilityIdeographs}+)$')))
(every $s in tokenize('￰�,￰￱￲￳￴￵￶￷￸￹￺￻￼�', ',') satisfies matches($s, '^(?:\p{IsSpecials}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsSpecials}+)$')))
(every $s in tokenize('一鿿,一丁丂七丄丅丆万丈三上下丌不与丏丐丑丒专且丕世丗丘丙业丛东丝丞丟丠両丢丣两严並丧丨丩个丫丬中丮丯丰丱串丳临丵丶丷丸丹为主丼丽举丿乀乁乂乃乄久乆乇么义乊之乌乍乎乏乐乑乒乓乔乕乖乗乘乙乚乛乜九乞也习乡乢乣乤乥书乧乨乩乪乫乬乭乮乯买乱乲乳乴乵乶乷乸乹乺乻乼乽乾乿亀亁亂亃亄亅了亇予争亊事二亍于亏亐云互亓五井亖亗亘亙亚些亜亝亞亟亠亡亢亣交亥亦产亨亩亪享京亭亮亯亰亱亲亳亴亵亶亷亸亹人亻亼亽亾亿什仁仂仃仄仅仆仇仈仉今介仌仍从仏仐仑仒仓仔仕他仗付仙仚仛仜仝仞仟仠仡仢代令以仦仧仨仩仪仫们仭仮仯仰仱仲仳仴仵件价仸仹仺任仼份仾仿伀企伂伃伄伅伆伇伈伉伊伋伌伍伎伏伐休伒伓伔伕伖众优伙会伛伜伝伞伟传伡伢伣伤伥伦伧伨伩伪伫伬伭伮伯估伱伲伳伴伵伶伷伸伹伺伻似伽伾伿佀佁佂佃佄佅但佇佈佉佊佋佌位低住佐佑佒体佔何佖佗佘余佚佛作佝佞佟你佡佢佣佤佥佦佧佨佩佪佫佬佭佮佯佰佱佲佳佴併佶佷佸佹佺佻佼佽佾使侀侁侂侃侄侅來侇侈侉侊例侌侍侎侏侐侑侒侓侔侕侖侗侘侙侚供侜依侞侟侠価侢侣侤侥侦侧侨侩侪侫侬侭侮侯侰侱侲侳侴侵侶侷侸侹侺侻侼侽侾便俀俁係促俄俅俆俇俈俉俊俋俌俍俎俏俐俑俒俓俔俕俖俗俘俙俚俛俜保俞俟俠信俢俣俤俥俦俧俨俩俪俫俬俭修俯俰俱俲俳俴俵俶俷俸俹俺俻俼俽俾俿倀倁倂倃倄倅倆倇倈倉倊個倌倍倎倏倐們倒倓倔倕倖倗倘候倚倛倜倝倞借倠倡倢倣値倥倦倧倨倩倪倫倬倭倮倯倰倱倲倳倴倵倶倷倸倹债倻值倽倾倿偀偁偂偃偄偅偆假偈偉偊偋偌偍偎偏偐偑偒偓偔偕偖偗偘偙做偛停偝偞偟偠偡偢偣偤健偦偧偨偩偪偫偬偭偮偯偰偱偲偳側偵偶偷偸偹偺偻偼偽偾偿傀傁傂傃傄傅傆傇傈傉傊傋傌傍傎傏傐傑傒傓傔傕傖傗傘備傚傛傜傝傞傟傠傡傢傣傤傥傦傧储傩傪傫催傭傮傯傰傱傲傳傴債傶傷傸傹傺傻傼傽傾傿僀僁僂僃僄僅僆僇僈僉僊僋僌働僎像僐僑僒僓僔僕僖僗僘僙僚僛僜僝僞僟僠僡僢僣僤僥僦僧僨僩僪僫僬僭僮僯僰僱僲僳僴僵僶僷僸價僺僻僼僽僾僿儀儁儂儃億儅儆儇儈儉儊儋儌儍儎儏儐儑儒儓儔儕儖儗儘儙儚儛儜儝儞償儠儡儢儣儤儥儦儧儨儩優儫儬儭儮儯儰儱儲儳儴儵儶儷儸儹儺儻儼儽儾儿兀允兂元兄充兆兇先光兊克兌免兎兏児兑兒兓兔兕兖兗兘兙党兛兜兝兞兟兠兡兢兣兤入兦內全兩兪八公六兮兯兰共兲关兴兵其具典兹兺养兼兽兾兿冀冁冂冃冄内円冇冈冉冊冋册再冎冏冐冑冒冓冔冕冖冗冘写冚军农冝冞冟冠冡冢冣冤冥冦冧冨冩冪冫冬冭冮冯冰冱冲决冴况冶冷冸冹冺冻冼冽冾冿净凁凂凃凄凅准凇凈凉凊凋凌凍凎减凐凑凒凓凔凕凖凗凘凙凚凛凜凝凞凟几凡凢凣凤凥処凧凨凩凪凫凬凭凮凯凰凱凲凳凴凵凶凷凸凹出击凼函凾凿刀刁刂刃刄刅分切刈刉刊刋刌刍刎刏刐刑划刓刔刕刖列刘则刚创刜初刞刟删刡刢刣判別刦刧刨利刪别刬刭刮刯到刱刲刳刴刵制刷券刹刺刻刼刽刾刿剀剁剂剃剄剅剆則剈剉削剋剌前剎剏剐剑剒剓剔剕剖剗剘剙剚剛剜剝剞剟剠剡剢剣剤剥剦剧剨剩剪剫剬剭剮副剰剱割剳剴創剶剷剸剹剺剻剼剽剾剿劀劁劂劃劄劅劆劇劈劉劊劋劌劍劎劏劐劑劒劓劔劕劖劗劘劙劚力劜劝办功加务劢劣劤劥劦劧动助努劫劬劭劮劯劰励劲劳労劵劶劷劸効劺劻劼劽劾势勀勁勂勃勄勅勆勇勈勉勊勋勌勍勎勏勐勑勒勓勔動勖勗勘務勚勛勜勝勞募勠勡勢勣勤勥勦勧勨勩勪勫勬勭勮勯勰勱勲勳勴勵勶勷勸勹勺勻勼勽勾勿匀匁匂匃匄包匆匇匈匉匊匋匌匍匎匏匐匑匒匓匔匕化北匘匙匚匛匜匝匞匟匠匡匢匣匤匥匦匧匨匩匪匫匬匭匮匯匰匱匲匳匴匵匶匷匸匹区医匼匽匾匿區十卂千卄卅卆升午卉半卋卌卍华协卐卑卒卓協单卖南単卙博卛卜卝卞卟占卡卢卣卤卥卦卧卨卩卪卫卬卭卮卯印危卲即却卵卶卷卸卹卺卻卼卽卾卿厀厁厂厃厄厅历厇厈厉厊压厌厍厎厏厐厑厒厓厔厕厖厗厘厙厚厛厜厝厞原厠厡厢厣厤厥厦厧厨厩厪厫厬厭厮厯厰厱厲厳厴厵厶厷厸厹厺去厼厽厾县叀叁参參叄叅叆叇又叉及友双反収叏叐发叒叓叔叕取受变叙叚叛叜叝叞叟叠叡叢口古句另叧叨叩只叫召叭叮可台叱史右叴叵叶号司叹叺叻叼叽叾叿吀吁吂吃各吅吆吇合吉吊吋同名后吏吐向吒吓吔吕吖吗吘吙吚君吜吝吞吟吠吡吢吣吤吥否吧吨吩吪含听吭吮启吰吱吲吳吴吵吶吷吸吹吺吻吼吽吾吿呀呁呂呃呄呅呆呇呈呉告呋呌呍呎呏呐呑呒呓呔呕呖呗员呙呚呛呜呝呞呟呠呡呢呣呤呥呦呧周呩呪呫呬呭呮呯呰呱呲味呴呵呶呷呸呹呺呻呼命呾呿咀咁咂咃咄咅咆咇咈咉咊咋和咍咎咏咐咑咒咓咔咕咖咗咘咙咚咛咜咝咞咟咠咡咢咣咤咥咦咧咨咩咪咫咬咭咮咯咰咱咲咳咴咵咶咷咸咹咺咻咼咽咾咿哀品哂哃哄哅哆哇哈哉哊哋哌响哎哏哐哑哒哓哔哕哖哗哘哙哚哛哜哝哞哟哠員哢哣哤哥哦哧哨哩哪哫哬哭哮哯哰哱哲哳哴哵哶哷哸哹哺哻哼哽哾哿唀唁唂唃唄唅唆唇唈唉唊唋唌唍唎唏唐唑唒唓唔唕唖唗唘唙唚唛唜唝唞唟唠唡唢唣唤唥唦唧唨唩唪唫唬唭售唯唰唱唲唳唴唵唶唷唸唹唺唻唼唽唾唿啀啁啂啃啄啅商啇啈啉啊啋啌啍啎問啐啑啒啓啔啕啖啗啘啙啚啛啜啝啞啟啠啡啢啣啤啥啦啧啨啩啪啫啬啭啮啯啰啱啲啳啴啵啶啷啸啹啺啻啼啽啾啿喀喁喂喃善喅喆喇喈喉喊喋喌喍喎喏喐喑喒喓喔喕喖喗喘喙喚喛喜喝喞喟喠喡喢喣喤喥喦喧喨喩喪喫喬喭單喯喰喱喲喳喴喵営喷喸喹喺喻喼喽喾喿嗀嗁嗂嗃嗄嗅嗆嗇嗈嗉嗊嗋嗌嗍嗎嗏嗐嗑嗒嗓嗔嗕嗖嗗嗘嗙嗚嗛嗜嗝嗞嗟嗠嗡嗢嗣嗤嗥嗦嗧嗨嗩嗪嗫嗬嗭嗮嗯嗰嗱嗲嗳嗴嗵嗶嗷嗸嗹嗺嗻嗼嗽嗾嗿嘀嘁嘂嘃嘄嘅嘆嘇嘈嘉嘊嘋嘌嘍嘎嘏嘐嘑嘒嘓嘔嘕嘖嘗嘘嘙嘚嘛嘜嘝嘞嘟嘠嘡嘢嘣嘤嘥嘦嘧嘨嘩嘪嘫嘬嘭嘮嘯嘰嘱嘲嘳嘴嘵嘶嘷嘸嘹嘺嘻嘼嘽嘾嘿噀噁噂噃噄噅噆噇噈噉噊噋噌噍噎噏噐噑噒噓噔噕噖噗噘噙噚噛噜噝噞噟噠噡噢噣噤噥噦噧器噩噪噫噬噭噮噯噰噱噲噳噴噵噶噷噸噹噺噻噼噽噾噿嚀嚁嚂嚃嚄嚅嚆嚇嚈嚉嚊嚋嚌嚍嚎嚏嚐嚑嚒嚓嚔嚕嚖嚗嚘嚙嚚嚛嚜嚝嚞嚟嚠嚡嚢嚣嚤嚥嚦嚧嚨嚩嚪嚫嚬嚭嚮嚯嚰嚱嚲嚳嚴嚵嚶嚷嚸嚹嚺嚻嚼嚽嚾嚿囀囁囂囃囄囅囆囇囈囉囊囋囌囍囎囏囐囑囒囓囔囕囖囗囘囙囚四囜囝回囟因囡团団囤囥囦囧囨囩囪囫囬园囮囯困囱囲図围囵囶囷囸囹固囻囼国图囿圀圁圂圃圄圅圆圇圈圉圊國圌圍圎圏圐圑園圓圔圕圖圗團圙圚圛圜圝圞土圠圡圢圣圤圥圦圧在圩圪圫圬圭圮圯地圱圲圳圴圵圶圷圸圹场圻圼圽圾圿址坁坂坃坄坅坆均坈坉坊坋坌坍坎坏坐坑坒坓坔坕坖块坘坙坚坛坜坝坞坟坠坡坢坣坤坥坦坧坨坩坪坫坬坭坮坯坰坱坲坳坴坵坶坷坸坹坺坻坼坽坾坿垀垁垂垃垄垅垆垇垈垉垊型垌垍垎垏垐垑垒垓垔垕垖垗垘垙垚垛垜垝垞垟垠垡垢垣垤垥垦垧垨垩垪垫垬垭垮垯垰垱垲垳垴垵垶垷垸垹垺垻垼垽垾垿埀埁埂埃埄埅埆埇埈埉埊埋埌埍城埏埐埑埒埓埔埕埖埗埘埙埚埛埜埝埞域埠埡埢埣埤埥埦埧埨埩埪埫埬埭埮埯埰埱埲埳埴埵埶執埸培基埻埼埽埾埿堀堁堂堃堄堅堆堇堈堉堊堋堌堍堎堏堐堑堒堓堔堕堖堗堘堙堚堛堜堝堞堟堠堡堢堣堤堥堦堧堨堩堪堫堬堭堮堯堰報堲堳場堵堶堷堸堹堺堻堼堽堾堿塀塁塂塃塄塅塆塇塈塉塊塋塌塍塎塏塐塑塒塓塔塕塖塗塘塙塚塛塜塝塞塟塠塡塢塣塤塥塦塧塨塩塪填塬塭塮塯塰塱塲塳塴塵塶塷塸塹塺塻塼塽塾塿墀墁墂境墄墅墆墇墈墉墊墋墌墍墎墏墐墑墒墓墔墕墖増墘墙墚墛墜墝增墟墠墡墢墣墤墥墦墧墨墩墪墫墬墭墮墯墰墱墲墳墴墵墶墷墸墹墺墻墼墽墾墿壀壁壂壃壄壅壆壇壈壉壊壋壌壍壎壏壐壑壒壓壔壕壖壗壘壙壚壛壜壝壞壟壠壡壢壣壤壥壦壧壨壩壪士壬壭壮壯声壱売壳壴壵壶壷壸壹壺壻壼壽壾壿夀夁夂夃处夅夆备夈変夊夋夌复夎夏夐夑夒夓夔夕外夗夘夙多夛夜夝夞够夠夡夢夣夤夥夦大夨天太夫夬夭央夯夰失夲夳头夵夶夷夸夹夺夻夼夽夾夿奀奁奂奃奄奅奆奇奈奉奊奋奌奍奎奏奐契奒奓奔奕奖套奘奙奚奛奜奝奞奟奠奡奢奣奤奥奦奧奨奩奪奫奬奭奮奯奰奱奲女奴奵奶奷奸她奺奻奼好奾奿妀妁如妃妄妅妆妇妈妉妊妋妌妍妎妏妐妑妒妓妔妕妖妗妘妙妚妛妜妝妞妟妠妡妢妣妤妥妦妧妨妩妪妫妬妭妮妯妰妱妲妳妴妵妶妷妸妹妺妻妼妽妾妿姀姁姂姃姄姅姆姇姈姉姊始姌姍姎姏姐姑姒姓委姕姖姗姘姙姚姛姜姝姞姟姠姡姢姣姤姥姦姧姨姩姪姫姬姭姮姯姰姱姲姳姴姵姶姷姸姹姺姻姼姽姾姿娀威娂娃娄娅娆娇娈娉娊娋娌娍娎娏娐娑娒娓娔娕娖娗娘娙娚娛娜娝娞娟娠娡娢娣娤娥娦娧娨娩娪娫娬娭娮娯娰娱娲娳娴娵娶娷娸娹娺娻娼娽娾娿婀婁婂婃婄婅婆婇婈婉婊婋婌婍婎婏婐婑婒婓婔婕婖婗婘婙婚婛婜婝婞婟婠婡婢婣婤婥婦婧婨婩婪婫婬婭婮婯婰婱婲婳婴婵婶婷婸婹婺婻婼婽婾婿媀媁媂媃媄媅媆媇媈媉媊媋媌媍媎媏媐媑媒媓媔媕媖媗媘媙媚媛媜媝媞媟媠媡媢媣媤媥媦媧媨媩媪媫媬媭媮媯媰媱媲媳媴媵媶媷媸媹媺媻媼媽媾媿嫀嫁嫂嫃嫄嫅嫆嫇嫈嫉嫊嫋嫌嫍嫎嫏嫐嫑嫒嫓嫔嫕嫖嫗嫘嫙嫚嫛嫜嫝嫞嫟嫠嫡嫢嫣嫤嫥嫦嫧嫨嫩嫪嫫嫬嫭嫮嫯嫰嫱嫲嫳嫴嫵嫶嫷嫸嫹嫺嫻嫼嫽嫾嫿嬀嬁嬂嬃嬄嬅嬆嬇嬈嬉嬊嬋嬌嬍嬎嬏嬐嬑嬒嬓嬔嬕嬖嬗嬘嬙嬚嬛嬜嬝嬞嬟嬠嬡嬢嬣嬤嬥嬦嬧嬨嬩嬪嬫嬬嬭嬮嬯嬰嬱嬲嬳嬴嬵嬶嬷嬸嬹嬺嬻嬼嬽嬾嬿孀孁孂孃孄孅孆孇孈孉孊孋孌孍孎孏子孑孒孓孔孕孖字存孙孚孛孜孝孞孟孠孡孢季孤孥学孧孨孩孪孫孬孭孮孯孰孱孲孳孴孵孶孷學孹孺孻孼孽孾孿宀宁宂它宄宅宆宇守安宊宋完宍宎宏宐宑宒宓宔宕宖宗官宙定宛宜宝实実宠审客宣室宥宦宧宨宩宪宫宬宭宮宯宰宱宲害宴宵家宷宸容宺宻宼宽宾宿寀寁寂寃寄寅密寇寈寉寊寋富寍寎寏寐寑寒寓寔寕寖寗寘寙寚寛寜寝寞察寠寡寢寣寤寥實寧寨審寪寫寬寭寮寯寰寱寲寳寴寵寶寷寸对寺寻导寽対寿尀封専尃射尅将將專尉尊尋尌對導小尐少尒尓尔尕尖尗尘尙尚尛尜尝尞尟尠尡尢尣尤尥尦尧尨尩尪尫尬尭尮尯尰就尲尳尴尵尶尷尸尹尺尻尼尽尾尿局屁层屃屄居屆屇屈屉届屋屌屍屎屏屐屑屒屓屔展屖屗屘屙屚屛屜屝属屟屠屡屢屣層履屦屧屨屩屪屫屬屭屮屯屰山屲屳屴屵屶屷屸屹屺屻屼屽屾屿岀岁岂岃岄岅岆岇岈岉岊岋岌岍岎岏岐岑岒岓岔岕岖岗岘岙岚岛岜岝岞岟岠岡岢岣岤岥岦岧岨岩岪岫岬岭岮岯岰岱岲岳岴岵岶岷岸岹岺岻岼岽岾岿峀峁峂峃峄峅峆峇峈峉峊峋峌峍峎峏峐峑峒峓峔峕峖峗峘峙峚峛峜峝峞峟峠峡峢峣峤峥峦峧峨峩峪峫峬峭峮峯峰峱峲峳峴峵島峷峸峹峺峻峼峽峾峿崀崁崂崃崄崅崆崇崈崉崊崋崌崍崎崏崐崑崒崓崔崕崖崗崘崙崚崛崜崝崞崟崠崡崢崣崤崥崦崧崨崩崪崫崬崭崮崯崰崱崲崳崴崵崶崷崸崹崺崻崼崽崾崿嵀嵁嵂嵃嵄嵅嵆嵇嵈嵉嵊嵋嵌嵍嵎嵏嵐嵑嵒嵓嵔嵕嵖嵗嵘嵙嵚嵛嵜嵝嵞嵟嵠嵡嵢嵣嵤嵥嵦嵧嵨嵩嵪嵫嵬嵭嵮嵯嵰嵱嵲嵳嵴嵵嵶嵷嵸嵹嵺嵻嵼嵽嵾嵿嶀嶁嶂嶃嶄嶅嶆嶇嶈嶉嶊嶋嶌嶍嶎嶏嶐嶑嶒嶓嶔嶕嶖嶗嶘嶙嶚嶛嶜嶝嶞嶟嶠嶡嶢嶣嶤嶥嶦嶧嶨嶩嶪嶫嶬嶭嶮嶯嶰嶱嶲嶳嶴嶵嶶嶷嶸嶹嶺嶻嶼嶽嶾嶿巀巁巂巃巄巅巆巇巈巉巊巋巌巍巎巏巐巑巒巓巔巕巖巗巘巙巚巛巜川州巟巠巡巢巣巤工左巧巨巩巪巫巬巭差巯巰己已巳巴巵巶巷巸巹巺巻巼巽巾巿帀币市布帄帅帆帇师帉帊帋希帍帎帏帐帑帒帓帔帕帖帗帘帙帚帛帜帝帞帟帠帡帢帣帤帥带帧帨帩帪師帬席帮帯帰帱帲帳帴帵帶帷常帹帺帻帼帽帾帿幀幁幂幃幄幅幆幇幈幉幊幋幌幍幎幏幐幑幒幓幔幕幖幗幘幙幚幛幜幝幞幟幠幡幢幣幤幥幦幧幨幩幪幫幬幭幮幯幰幱干平年幵并幷幸幹幺幻幼幽幾广庀庁庂広庄庅庆庇庈庉床庋庌庍庎序庐庑庒库应底庖店庘庙庚庛府庝庞废庠庡庢庣庤庥度座庨庩庪庫庬庭庮庯庰庱庲庳庴庵庶康庸庹庺庻庼庽庾庿廀廁廂廃廄廅廆廇廈廉廊廋廌廍廎廏廐廑廒廓廔廕廖廗廘廙廚廛廜廝廞廟廠廡廢廣廤廥廦廧廨廩廪廫廬廭廮廯廰廱廲廳廴廵延廷廸廹建廻廼廽廾廿开弁异弃弄弅弆弇弈弉弊弋弌弍弎式弐弑弒弓弔引弖弗弘弙弚弛弜弝弞弟张弡弢弣弤弥弦弧弨弩弪弫弬弭弮弯弰弱弲弳弴張弶強弸弹强弻弼弽弾弿彀彁彂彃彄彅彆彇彈彉彊彋彌彍彎彏彐彑归当彔录彖彗彘彙彚彛彜彝彞彟彠彡形彣彤彥彦彧彨彩彪彫彬彭彮彯彰影彲彳彴彵彶彷彸役彺彻彼彽彾彿往征徂徃径待徆徇很徉徊律後徍徎徏徐徑徒従徔徕徖得徘徙徚徛徜徝從徟徠御徢徣徤徥徦徧徨復循徫徬徭微徯徰徱徲徳徴徵徶德徸徹徺徻徼徽徾徿忀忁忂心忄必忆忇忈忉忊忋忌忍忎忏忐忑忒忓忔忕忖志忘忙忚忛応忝忞忟忠忡忢忣忤忥忦忧忨忩忪快忬忭忮忯忰忱忲忳忴念忶忷忸忹忺忻忼忽忾忿怀态怂怃怄怅怆怇怈怉怊怋怌怍怎怏怐怑怒怓怔怕怖怗怘怙怚怛怜思怞怟怠怡怢怣怤急怦性怨怩怪怫怬怭怮怯怰怱怲怳怴怵怶怷怸怹怺总怼怽怾怿恀恁恂恃恄恅恆恇恈恉恊恋恌恍恎恏恐恑恒恓恔恕恖恗恘恙恚恛恜恝恞恟恠恡恢恣恤恥恦恧恨恩恪恫恬恭恮息恰恱恲恳恴恵恶恷恸恹恺恻恼恽恾恿悀悁悂悃悄悅悆悇悈悉悊悋悌悍悎悏悐悑悒悓悔悕悖悗悘悙悚悛悜悝悞悟悠悡悢患悤悥悦悧您悩悪悫悬悭悮悯悰悱悲悳悴悵悶悷悸悹悺悻悼悽悾悿惀惁惂惃惄情惆惇惈惉惊惋惌惍惎惏惐惑惒惓惔惕惖惗惘惙惚惛惜惝惞惟惠惡惢惣惤惥惦惧惨惩惪惫惬惭惮惯惰惱惲想惴惵惶惷惸惹惺惻惼惽惾惿愀愁愂愃愄愅愆愇愈愉愊愋愌愍愎意愐愑愒愓愔愕愖愗愘愙愚愛愜愝愞感愠愡愢愣愤愥愦愧愨愩愪愫愬愭愮愯愰愱愲愳愴愵愶愷愸愹愺愻愼愽愾愿慀慁慂慃慄慅慆慇慈慉慊態慌慍慎慏慐慑慒慓慔慕慖慗慘慙慚慛慜慝慞慟慠慡慢慣慤慥慦慧慨慩慪慫慬慭慮慯慰慱慲慳慴慵慶慷慸慹慺慻慼慽慾慿憀憁憂憃憄憅憆憇憈憉憊憋憌憍憎憏憐憑憒憓憔憕憖憗憘憙憚憛憜憝憞憟憠憡憢憣憤憥憦憧憨憩憪憫憬憭憮憯憰憱憲憳憴憵憶憷憸憹憺憻憼憽憾憿懀懁懂懃懄懅懆懇懈應懊懋懌懍懎懏懐懑懒懓懔懕懖懗懘懙懚懛懜懝懞懟懠懡懢懣懤懥懦懧懨懩懪懫懬懭懮懯懰懱懲懳懴懵懶懷懸懹懺懻懼懽懾懿戀戁戂戃戄戅戆戇戈戉戊戋戌戍戎戏成我戒戓戔戕或戗战戙戚戛戜戝戞戟戠戡戢戣戤戥戦戧戨戩截戫戬戭戮戯戰戱戲戳戴戵戶户戸戹戺戻戼戽戾房所扁扂扃扄扅扆扇扈扉扊手扌才扎扏扐扑扒打扔払扖扗托扙扚扛扜扝扞扟扠扡扢扣扤扥扦执扨扩扪扫扬扭扮扯扰扱扲扳扴扵扶扷扸批扺扻扼扽找承技抁抂抃抄抅抆抇抈抉把抋抌抍抎抏抐抑抒抓抔投抖抗折抙抚抛抜抝択抟抠抡抢抣护报抦抧抨抩抪披抬抭抮抯抰抱抲抳抴抵抶抷抸抹抺抻押抽抾抿拀拁拂拃拄担拆拇拈拉拊拋拌拍拎拏拐拑拒拓拔拕拖拗拘拙拚招拜拝拞拟拠拡拢拣拤拥拦拧拨择拪拫括拭拮拯拰拱拲拳拴拵拶拷拸拹拺拻拼拽拾拿挀持挂挃挄挅挆指挈按挊挋挌挍挎挏挐挑挒挓挔挕挖挗挘挙挚挛挜挝挞挟挠挡挢挣挤挥挦挧挨挩挪挫挬挭挮振挰挱挲挳挴挵挶挷挸挹挺挻挼挽挾挿捀捁捂捃捄捅捆捇捈捉捊捋捌捍捎捏捐捑捒捓捔捕捖捗捘捙捚捛捜捝捞损捠捡换捣捤捥捦捧捨捩捪捫捬捭据捯捰捱捲捳捴捵捶捷捸捹捺捻捼捽捾捿掀掁掂掃掄掅掆掇授掉掊掋掌掍掎掏掐掑排掓掔掕掖掗掘掙掚掛掜掝掞掟掠採探掣掤接掦控推掩措掫掬掭掮掯掰掱掲掳掴掵掶掷掸掹掺掻掼掽掾掿揀揁揂揃揄揅揆揇揈揉揊揋揌揍揎描提揑插揓揔揕揖揗揘揙揚換揜揝揞揟揠握揢揣揤揥揦揧揨揩揪揫揬揭揮揯揰揱揲揳援揵揶揷揸揹揺揻揼揽揾揿搀搁搂搃搄搅搆搇搈搉搊搋搌損搎搏搐搑搒搓搔搕搖搗搘搙搚搛搜搝搞搟搠搡搢搣搤搥搦搧搨搩搪搫搬搭搮搯搰搱搲搳搴搵搶搷搸搹携搻搼搽搾搿摀摁摂摃摄摅摆摇摈摉摊摋摌摍摎摏摐摑摒摓摔摕摖摗摘摙摚摛摜摝摞摟摠摡摢摣摤摥摦摧摨摩摪摫摬摭摮摯摰摱摲摳摴摵摶摷摸摹摺摻摼摽摾摿撀撁撂撃撄撅撆撇撈撉撊撋撌撍撎撏撐撑撒撓撔撕撖撗撘撙撚撛撜撝撞撟撠撡撢撣撤撥撦撧撨撩撪撫撬播撮撯撰撱撲撳撴撵撶撷撸撹撺撻撼撽撾撿擀擁擂擃擄擅擆擇擈擉擊擋擌操擎擏擐擑擒擓擔擕擖擗擘擙據擛擜擝擞擟擠擡擢擣擤擥擦擧擨擩擪擫擬擭擮擯擰擱擲擳擴擵擶擷擸擹擺擻擼擽擾擿攀攁攂攃攄攅攆攇攈攉攊攋攌攍攎攏攐攑攒攓攔攕攖攗攘攙攚攛攜攝攞攟攠攡攢攣攤攥攦攧攨攩攪攫攬攭攮支攰攱攲攳攴攵收攷攸改攺攻攼攽放政敀敁敂敃敄故敆敇效敉敊敋敌敍敎敏敐救敒敓敔敕敖敗敘教敚敛敜敝敞敟敠敡敢散敤敥敦敧敨敩敪敫敬敭敮敯数敱敲敳整敵敶敷數敹敺敻敼敽敾敿斀斁斂斃斄斅斆文斈斉斊斋斌斍斎斏斐斑斒斓斔斕斖斗斘料斚斛斜斝斞斟斠斡斢斣斤斥斦斧斨斩斪斫斬断斮斯新斱斲斳斴斵斶斷斸方斺斻於施斾斿旀旁旂旃旄旅旆旇旈旉旊旋旌旍旎族旐旑旒旓旔旕旖旗旘旙旚旛旜旝旞旟无旡既旣旤日旦旧旨早旪旫旬旭旮旯旰旱旲旳旴旵时旷旸旹旺旻旼旽旾旿昀昁昂昃昄昅昆昇昈昉昊昋昌昍明昏昐昑昒易昔昕昖昗昘昙昚昛昜昝昞星映昡昢昣昤春昦昧昨昩昪昫昬昭昮是昰昱昲昳昴昵昶昷昸昹昺昻昼昽显昿晀晁時晃晄晅晆晇晈晉晊晋晌晍晎晏晐晑晒晓晔晕晖晗晘晙晚晛晜晝晞晟晠晡晢晣晤晥晦晧晨晩晪晫晬晭普景晰晱晲晳晴晵晶晷晸晹智晻晼晽晾晿暀暁暂暃暄暅暆暇暈暉暊暋暌暍暎暏暐暑暒暓暔暕暖暗暘暙暚暛暜暝暞暟暠暡暢暣暤暥暦暧暨暩暪暫暬暭暮暯暰暱暲暳暴暵暶暷暸暹暺暻暼暽暾暿曀曁曂曃曄曅曆曇曈曉曊曋曌曍曎曏曐曑曒曓曔曕曖曗曘曙曚曛曜曝曞曟曠曡曢曣曤曥曦曧曨曩曪曫曬曭曮曯曰曱曲曳更曵曶曷書曹曺曻曼曽曾替最朁朂會朄朅朆朇月有朊朋朌服朎朏朐朑朒朓朔朕朖朗朘朙朚望朜朝朞期朠朡朢朣朤朥朦朧木朩未末本札朮术朰朱朲朳朴朵朶朷朸朹机朻朼朽朾朿杀杁杂权杄杅杆杇杈杉杊杋杌杍李杏材村杒杓杔杕杖杗杘杙杚杛杜杝杞束杠条杢杣杤来杦杧杨杩杪杫杬杭杮杯杰東杲杳杴杵杶杷杸杹杺杻杼杽松板枀极枂枃构枅枆枇枈枉枊枋枌枍枎枏析枑枒枓枔枕枖林枘枙枚枛果枝枞枟枠枡枢枣枤枥枦枧枨枩枪枫枬枭枮枯枰枱枲枳枴枵架枷枸枹枺枻枼枽枾枿柀柁柂柃柄柅柆柇柈柉柊柋柌柍柎柏某柑柒染柔柕柖柗柘柙柚柛柜柝柞柟柠柡柢柣柤查柦柧柨柩柪柫柬柭柮柯柰柱柲柳柴柵柶柷柸柹柺査柼柽柾柿栀栁栂栃栄栅栆标栈栉栊栋栌栍栎栏栐树栒栓栔栕栖栗栘栙栚栛栜栝栞栟栠校栢栣栤栥栦栧栨栩株栫栬栭栮栯栰栱栲栳栴栵栶样核根栺栻格栽栾栿桀桁桂桃桄桅框桇案桉桊桋桌桍桎桏桐桑桒桓桔桕桖桗桘桙桚桛桜桝桞桟桠桡桢档桤桥桦桧桨桩桪桫桬桭桮桯桰桱桲桳桴桵桶桷桸桹桺桻桼桽桾桿梀梁梂梃梄梅梆梇梈梉梊梋梌梍梎梏梐梑梒梓梔梕梖梗梘梙梚梛梜條梞梟梠梡梢梣梤梥梦梧梨梩梪梫梬梭梮梯械梱梲梳梴梵梶梷梸梹梺梻梼梽梾梿检棁棂棃棄棅棆棇棈棉棊棋棌棍棎棏棐棑棒棓棔棕棖棗棘棙棚棛棜棝棞棟棠棡棢棣棤棥棦棧棨棩棪棫棬棭森棯棰棱棲棳棴棵棶棷棸棹棺棻棼棽棾棿椀椁椂椃椄椅椆椇椈椉椊椋椌植椎椏椐椑椒椓椔椕椖椗椘椙椚椛検椝椞椟椠椡椢椣椤椥椦椧椨椩椪椫椬椭椮椯椰椱椲椳椴椵椶椷椸椹椺椻椼椽椾椿楀楁楂楃楄楅楆楇楈楉楊楋楌楍楎楏楐楑楒楓楔楕楖楗楘楙楚楛楜楝楞楟楠楡楢楣楤楥楦楧楨楩楪楫楬業楮楯楰楱楲楳楴極楶楷楸楹楺楻楼楽楾楿榀榁概榃榄榅榆榇榈榉榊榋榌榍榎榏榐榑榒榓榔榕榖榗榘榙榚榛榜榝榞榟榠榡榢榣榤榥榦榧榨榩榪榫榬榭榮榯榰榱榲榳榴榵榶榷榸榹榺榻榼榽榾榿槀槁槂槃槄槅槆槇槈槉槊構槌槍槎槏槐槑槒槓槔槕槖槗様槙槚槛槜槝槞槟槠槡槢槣槤槥槦槧槨槩槪槫槬槭槮槯槰槱槲槳槴槵槶槷槸槹槺槻槼槽槾槿樀樁樂樃樄樅樆樇樈樉樊樋樌樍樎樏樐樑樒樓樔樕樖樗樘標樚樛樜樝樞樟樠模樢樣樤樥樦樧樨権横樫樬樭樮樯樰樱樲樳樴樵樶樷樸樹樺樻樼樽樾樿橀橁橂橃橄橅橆橇橈橉橊橋橌橍橎橏橐橑橒橓橔橕橖橗橘橙橚橛橜橝橞機橠橡橢橣橤橥橦橧橨橩橪橫橬橭橮橯橰橱橲橳橴橵橶橷橸橹橺橻橼橽橾橿檀檁檂檃檄檅檆檇檈檉檊檋檌檍檎檏檐檑檒檓檔檕檖檗檘檙檚檛檜檝檞檟檠檡檢檣檤檥檦檧檨檩檪檫檬檭檮檯檰檱檲檳檴檵檶檷檸檹檺檻檼檽檾檿櫀櫁櫂櫃櫄櫅櫆櫇櫈櫉櫊櫋櫌櫍櫎櫏櫐櫑櫒櫓櫔櫕櫖櫗櫘櫙櫚櫛櫜櫝櫞櫟櫠櫡櫢櫣櫤櫥櫦櫧櫨櫩櫪櫫櫬櫭櫮櫯櫰櫱櫲櫳櫴櫵櫶櫷櫸櫹櫺櫻櫼櫽櫾櫿欀欁欂欃欄欅欆欇欈欉權欋欌欍欎欏欐欑欒欓欔欕欖欗欘欙欚欛欜欝欞欟欠次欢欣欤欥欦欧欨欩欪欫欬欭欮欯欰欱欲欳欴欵欶欷欸欹欺欻欼欽款欿歀歁歂歃歄歅歆歇歈歉歊歋歌歍歎歏歐歑歒歓歔歕歖歗歘歙歚歛歜歝歞歟歠歡止正此步武歧歨歩歪歫歬歭歮歯歰歱歲歳歴歵歶歷歸歹歺死歼歽歾歿殀殁殂殃殄殅殆殇殈殉殊残殌殍殎殏殐殑殒殓殔殕殖殗殘殙殚殛殜殝殞殟殠殡殢殣殤殥殦殧殨殩殪殫殬殭殮殯殰殱殲殳殴段殶殷殸殹殺殻殼殽殾殿毀毁毂毃毄毅毆毇毈毉毊毋毌母毎每毐毑毒毓比毕毖毗毘毙毚毛毜毝毞毟毠毡毢毣毤毥毦毧毨毩毪毫毬毭毮毯毰毱毲毳毴毵毶毷毸毹毺毻毼毽毾毿氀氁氂氃氄氅氆氇氈氉氊氋氌氍氎氏氐民氒氓气氕氖気氘氙氚氛氜氝氞氟氠氡氢氣氤氥氦氧氨氩氪氫氬氭氮氯氰氱氲氳水氵氶氷永氹氺氻氼氽氾氿汀汁求汃汄汅汆汇汈汉汊汋汌汍汎汏汐汑汒汓汔汕汖汗汘汙汚汛汜汝汞江池污汢汣汤汥汦汧汨汩汪汫汬汭汮汯汰汱汲汳汴汵汶汷汸汹決汻汼汽汾汿沀沁沂沃沄沅沆沇沈沉沊沋沌沍沎沏沐沑沒沓沔沕沖沗沘沙沚沛沜沝沞沟沠没沢沣沤沥沦沧沨沩沪沫沬沭沮沯沰沱沲河沴沵沶沷沸油沺治沼沽沾沿泀況泂泃泄泅泆泇泈泉泊泋泌泍泎泏泐泑泒泓泔法泖泗泘泙泚泛泜泝泞泟泠泡波泣泤泥泦泧注泩泪泫泬泭泮泯泰泱泲泳泴泵泶泷泸泹泺泻泼泽泾泿洀洁洂洃洄洅洆洇洈洉洊洋洌洍洎洏洐洑洒洓洔洕洖洗洘洙洚洛洜洝洞洟洠洡洢洣洤津洦洧洨洩洪洫洬洭洮洯洰洱洲洳洴洵洶洷洸洹洺活洼洽派洿浀流浂浃浄浅浆浇浈浉浊测浌浍济浏浐浑浒浓浔浕浖浗浘浙浚浛浜浝浞浟浠浡浢浣浤浥浦浧浨浩浪浫浬浭浮浯浰浱浲浳浴浵浶海浸浹浺浻浼浽浾浿涀涁涂涃涄涅涆涇消涉涊涋涌涍涎涏涐涑涒涓涔涕涖涗涘涙涚涛涜涝涞涟涠涡涢涣涤涥润涧涨涩涪涫涬涭涮涯涰涱液涳涴涵涶涷涸涹涺涻涼涽涾涿淀淁淂淃淄淅淆淇淈淉淊淋淌淍淎淏淐淑淒淓淔淕淖淗淘淙淚淛淜淝淞淟淠淡淢淣淤淥淦淧淨淩淪淫淬淭淮淯淰深淲淳淴淵淶混淸淹淺添淼淽淾淿渀渁渂渃渄清渆渇済渉渊渋渌渍渎渏渐渑渒渓渔渕渖渗渘渙渚減渜渝渞渟渠渡渢渣渤渥渦渧渨温渪渫測渭渮港渰渱渲渳渴渵渶渷游渹渺渻渼渽渾渿湀湁湂湃湄湅湆湇湈湉湊湋湌湍湎湏湐湑湒湓湔湕湖湗湘湙湚湛湜湝湞湟湠湡湢湣湤湥湦湧湨湩湪湫湬湭湮湯湰湱湲湳湴湵湶湷湸湹湺湻湼湽湾湿満溁溂溃溄溅溆溇溈溉溊溋溌溍溎溏源溑溒溓溔溕準溗溘溙溚溛溜溝溞溟溠溡溢溣溤溥溦溧溨溩溪溫溬溭溮溯溰溱溲溳溴溵溶溷溸溹溺溻溼溽溾溿滀滁滂滃滄滅滆滇滈滉滊滋滌滍滎滏滐滑滒滓滔滕滖滗滘滙滚滛滜滝滞滟滠满滢滣滤滥滦滧滨滩滪滫滬滭滮滯滰滱滲滳滴滵滶滷滸滹滺滻滼滽滾滿漀漁漂漃漄漅漆漇漈漉漊漋漌漍漎漏漐漑漒漓演漕漖漗漘漙漚漛漜漝漞漟漠漡漢漣漤漥漦漧漨漩漪漫漬漭漮漯漰漱漲漳漴漵漶漷漸漹漺漻漼漽漾漿潀潁潂潃潄潅潆潇潈潉潊潋潌潍潎潏潐潑潒潓潔潕潖潗潘潙潚潛潜潝潞潟潠潡潢潣潤潥潦潧潨潩潪潫潬潭潮潯潰潱潲潳潴潵潶潷潸潹潺潻潼潽潾潿澀澁澂澃澄澅澆澇澈澉澊澋澌澍澎澏澐澑澒澓澔澕澖澗澘澙澚澛澜澝澞澟澠澡澢澣澤澥澦澧澨澩澪澫澬澭澮澯澰澱澲澳澴澵澶澷澸澹澺澻澼澽澾澿激濁濂濃濄濅濆濇濈濉濊濋濌濍濎濏濐濑濒濓濔濕濖濗濘濙濚濛濜濝濞濟濠濡濢濣濤濥濦濧濨濩濪濫濬濭濮濯濰濱濲濳濴濵濶濷濸濹濺濻濼濽濾濿瀀瀁瀂瀃瀄瀅瀆瀇瀈瀉瀊瀋瀌瀍瀎瀏瀐瀑瀒瀓瀔瀕瀖瀗瀘瀙瀚瀛瀜瀝瀞瀟瀠瀡瀢瀣瀤瀥瀦瀧瀨瀩瀪瀫瀬瀭瀮瀯瀰瀱瀲瀳瀴瀵瀶瀷瀸瀹瀺瀻瀼瀽瀾瀿灀灁灂灃灄灅灆灇灈灉灊灋灌灍灎灏灐灑灒灓灔灕灖灗灘灙灚灛灜灝灞灟灠灡灢灣灤灥灦灧灨灩灪火灬灭灮灯灰灱灲灳灴灵灶灷灸灹灺灻灼災灾灿炀炁炂炃炄炅炆炇炈炉炊炋炌炍炎炏炐炑炒炓炔炕炖炗炘炙炚炛炜炝炞炟炠炡炢炣炤炥炦炧炨炩炪炫炬炭炮炯炰炱炲炳炴炵炶炷炸点為炻炼炽炾炿烀烁烂烃烄烅烆烇烈烉烊烋烌烍烎烏烐烑烒烓烔烕烖烗烘烙烚烛烜烝烞烟烠烡烢烣烤烥烦烧烨烩烪烫烬热烮烯烰烱烲烳烴烵烶烷烸烹烺烻烼烽烾烿焀焁焂焃焄焅焆焇焈焉焊焋焌焍焎焏焐焑焒焓焔焕焖焗焘焙焚焛焜焝焞焟焠無焢焣焤焥焦焧焨焩焪焫焬焭焮焯焰焱焲焳焴焵然焷焸焹焺焻焼焽焾焿煀煁煂煃煄煅煆煇煈煉煊煋煌煍煎煏煐煑煒煓煔煕煖煗煘煙煚煛煜煝煞煟煠煡煢煣煤煥煦照煨煩煪煫煬煭煮煯煰煱煲煳煴煵煶煷煸煹煺煻煼煽煾煿熀熁熂熃熄熅熆熇熈熉熊熋熌熍熎熏熐熑熒熓熔熕熖熗熘熙熚熛熜熝熞熟熠熡熢熣熤熥熦熧熨熩熪熫熬熭熮熯熰熱熲熳熴熵熶熷熸熹熺熻熼熽熾熿燀燁燂燃燄燅燆燇燈燉燊燋燌燍燎燏燐燑燒燓燔燕燖燗燘燙燚燛燜燝燞營燠燡燢燣燤燥燦燧燨燩燪燫燬燭燮燯燰燱燲燳燴燵燶燷燸燹燺燻燼燽燾燿爀爁爂爃爄爅爆爇爈爉爊爋爌爍爎爏爐爑爒爓爔爕爖爗爘爙爚爛爜爝爞爟爠爡爢爣爤爥爦爧爨爩爪爫爬爭爮爯爰爱爲爳爴爵父爷爸爹爺爻爼爽爾爿牀牁牂牃牄牅牆片版牉牊牋牌牍牎牏牐牑牒牓牔牕牖牗牘牙牚牛牜牝牞牟牠牡牢牣牤牥牦牧牨物牪牫牬牭牮牯牰牱牲牳牴牵牶牷牸特牺牻牼牽牾牿犀犁犂犃犄犅犆犇犈犉犊犋犌犍犎犏犐犑犒犓犔犕犖犗犘犙犚犛犜犝犞犟犠犡犢犣犤犥犦犧犨犩犪犫犬犭犮犯犰犱犲犳犴犵状犷犸犹犺犻犼犽犾犿狀狁狂狃狄狅狆狇狈狉狊狋狌狍狎狏狐狑狒狓狔狕狖狗狘狙狚狛狜狝狞狟狠狡狢狣狤狥狦狧狨狩狪狫独狭狮狯狰狱狲狳狴狵狶狷狸狹狺狻狼狽狾狿猀猁猂猃猄猅猆猇猈猉猊猋猌猍猎猏猐猑猒猓猔猕猖猗猘猙猚猛猜猝猞猟猠猡猢猣猤猥猦猧猨猩猪猫猬猭献猯猰猱猲猳猴猵猶猷猸猹猺猻猼猽猾猿獀獁獂獃獄獅獆獇獈獉獊獋獌獍獎獏獐獑獒獓獔獕獖獗獘獙獚獛獜獝獞獟獠獡獢獣獤獥獦獧獨獩獪獫獬獭獮獯獰獱獲獳獴獵獶獷獸獹獺獻獼獽獾獿玀玁玂玃玄玅玆率玈玉玊王玌玍玎玏玐玑玒玓玔玕玖玗玘玙玚玛玜玝玞玟玠玡玢玣玤玥玦玧玨玩玪玫玬玭玮环现玱玲玳玴玵玶玷玸玹玺玻玼玽玾玿珀珁珂珃珄珅珆珇珈珉珊珋珌珍珎珏珐珑珒珓珔珕珖珗珘珙珚珛珜珝珞珟珠珡珢珣珤珥珦珧珨珩珪珫珬班珮珯珰珱珲珳珴珵珶珷珸珹珺珻珼珽現珿琀琁琂球琄琅理琇琈琉琊琋琌琍琎琏琐琑琒琓琔琕琖琗琘琙琚琛琜琝琞琟琠琡琢琣琤琥琦琧琨琩琪琫琬琭琮琯琰琱琲琳琴琵琶琷琸琹琺琻琼琽琾琿瑀瑁瑂瑃瑄瑅瑆瑇瑈瑉瑊瑋瑌瑍瑎瑏瑐瑑瑒瑓瑔瑕瑖瑗瑘瑙瑚瑛瑜瑝瑞瑟瑠瑡瑢瑣瑤瑥瑦瑧瑨瑩瑪瑫瑬瑭瑮瑯瑰瑱瑲瑳瑴瑵瑶瑷瑸瑹瑺瑻瑼瑽瑾瑿璀璁璂璃璄璅璆璇璈璉璊璋璌璍璎璏璐璑璒璓璔璕璖璗璘璙璚璛璜璝璞璟璠璡璢璣璤璥璦璧璨璩璪璫璬璭璮璯環璱璲璳璴璵璶璷璸璹璺璻璼璽璾璿瓀瓁瓂瓃瓄瓅瓆瓇瓈瓉瓊瓋瓌瓍瓎瓏瓐瓑瓒瓓瓔瓕瓖瓗瓘瓙瓚瓛瓜瓝瓞瓟瓠瓡瓢瓣瓤瓥瓦瓧瓨瓩瓪瓫瓬瓭瓮瓯瓰瓱瓲瓳瓴瓵瓶瓷瓸瓹瓺瓻瓼瓽瓾瓿甀甁甂甃甄甅甆甇甈甉甊甋甌甍甎甏甐甑甒甓甔甕甖甗甘甙甚甛甜甝甞生甠甡產産甤甥甦甧用甩甪甫甬甭甮甯田由甲申甴电甶男甸甹町画甼甽甾甿畀畁畂畃畄畅畆畇畈畉畊畋界畍畎畏畐畑畒畓畔畕畖畗畘留畚畛畜畝畞畟畠畡畢畣畤略畦畧畨畩番畫畬畭畮畯異畱畲畳畴畵當畷畸畹畺畻畼畽畾畿疀疁疂疃疄疅疆疇疈疉疊疋疌疍疎疏疐疑疒疓疔疕疖疗疘疙疚疛疜疝疞疟疠疡疢疣疤疥疦疧疨疩疪疫疬疭疮疯疰疱疲疳疴疵疶疷疸疹疺疻疼疽疾疿痀痁痂痃痄病痆症痈痉痊痋痌痍痎痏痐痑痒痓痔痕痖痗痘痙痚痛痜痝痞痟痠痡痢痣痤痥痦痧痨痩痪痫痬痭痮痯痰痱痲痳痴痵痶痷痸痹痺痻痼痽痾痿瘀瘁瘂瘃瘄瘅瘆瘇瘈瘉瘊瘋瘌瘍瘎瘏瘐瘑瘒瘓瘔瘕瘖瘗瘘瘙瘚瘛瘜瘝瘞瘟瘠瘡瘢瘣瘤瘥瘦瘧瘨瘩瘪瘫瘬瘭瘮瘯瘰瘱瘲瘳瘴瘵瘶瘷瘸瘹瘺瘻瘼瘽瘾瘿癀癁療癃癄癅癆癇癈癉癊癋癌癍癎癏癐癑癒癓癔癕癖癗癘癙癚癛癜癝癞癟癠癡癢癣癤癥癦癧癨癩癪癫癬癭癮癯癰癱癲癳癴癵癶癷癸癹発登發白百癿皀皁皂皃的皅皆皇皈皉皊皋皌皍皎皏皐皑皒皓皔皕皖皗皘皙皚皛皜皝皞皟皠皡皢皣皤皥皦皧皨皩皪皫皬皭皮皯皰皱皲皳皴皵皶皷皸皹皺皻皼皽皾皿盀盁盂盃盄盅盆盇盈盉益盋盌盍盎盏盐监盒盓盔盕盖盗盘盙盚盛盜盝盞盟盠盡盢監盤盥盦盧盨盩盪盫盬盭目盯盰盱盲盳直盵盶盷相盹盺盻盼盽盾盿眀省眂眃眄眅眆眇眈眉眊看県眍眎眏眐眑眒眓眔眕眖眗眘眙眚眛眜眝眞真眠眡眢眣眤眥眦眧眨眩眪眫眬眭眮眯眰眱眲眳眴眵眶眷眸眹眺眻眼眽眾眿着睁睂睃睄睅睆睇睈睉睊睋睌睍睎睏睐睑睒睓睔睕睖睗睘睙睚睛睜睝睞睟睠睡睢督睤睥睦睧睨睩睪睫睬睭睮睯睰睱睲睳睴睵睶睷睸睹睺睻睼睽睾睿瞀瞁瞂瞃瞄瞅瞆瞇瞈瞉瞊瞋瞌瞍瞎瞏瞐瞑瞒瞓瞔瞕瞖瞗瞘瞙瞚瞛瞜瞝瞞瞟瞠瞡瞢瞣瞤瞥瞦瞧瞨瞩瞪瞫瞬瞭瞮瞯瞰瞱瞲瞳瞴瞵瞶瞷瞸瞹瞺瞻瞼瞽瞾瞿矀矁矂矃矄矅矆矇矈矉矊矋矌矍矎矏矐矑矒矓矔矕矖矗矘矙矚矛矜矝矞矟矠矡矢矣矤知矦矧矨矩矪矫矬短矮矯矰矱矲石矴矵矶矷矸矹矺矻矼矽矾矿砀码砂砃砄砅砆砇砈砉砊砋砌砍砎砏砐砑砒砓研砕砖砗砘砙砚砛砜砝砞砟砠砡砢砣砤砥砦砧砨砩砪砫砬砭砮砯砰砱砲砳破砵砶砷砸砹砺砻砼砽砾砿础硁硂硃硄硅硆硇硈硉硊硋硌硍硎硏硐硑硒硓硔硕硖硗硘硙硚硛硜硝硞硟硠硡硢硣硤硥硦硧硨硩硪硫硬硭确硯硰硱硲硳硴硵硶硷硸硹硺硻硼硽硾硿碀碁碂碃碄碅碆碇碈碉碊碋碌碍碎碏碐碑碒碓碔碕碖碗碘碙碚碛碜碝碞碟碠碡碢碣碤碥碦碧碨碩碪碫碬碭碮碯碰碱碲碳碴碵碶碷碸碹確碻碼碽碾碿磀磁磂磃磄磅磆磇磈磉磊磋磌磍磎磏磐磑磒磓磔磕磖磗磘磙磚磛磜磝磞磟磠磡磢磣磤磥磦磧磨磩磪磫磬磭磮磯磰磱磲磳磴磵磶磷磸磹磺磻磼磽磾磿礀礁礂礃礄礅礆礇礈礉礊礋礌礍礎礏礐礑礒礓礔礕礖礗礘礙礚礛礜礝礞礟礠礡礢礣礤礥礦礧礨礩礪礫礬礭礮礯礰礱礲礳礴礵礶礷礸礹示礻礼礽社礿祀祁祂祃祄祅祆祇祈祉祊祋祌祍祎祏祐祑祒祓祔祕祖祗祘祙祚祛祜祝神祟祠祡祢祣祤祥祦祧票祩祪祫祬祭祮祯祰祱祲祳祴祵祶祷祸祹祺祻祼祽祾祿禀禁禂禃禄禅禆禇禈禉禊禋禌禍禎福禐禑禒禓禔禕禖禗禘禙禚禛禜禝禞禟禠禡禢禣禤禥禦禧禨禩禪禫禬禭禮禯禰禱禲禳禴禵禶禷禸禹禺离禼禽禾禿秀私秂秃秄秅秆秇秈秉秊秋秌种秎秏秐科秒秓秔秕秖秗秘秙秚秛秜秝秞租秠秡秢秣秤秥秦秧秨秩秪秫秬秭秮积称秱秲秳秴秵秶秷秸秹秺移秼秽秾秿稀稁稂稃稄稅稆稇稈稉稊程稌稍税稏稐稑稒稓稔稕稖稗稘稙稚稛稜稝稞稟稠稡稢稣稤稥稦稧稨稩稪稫稬稭種稯稰稱稲稳稴稵稶稷稸稹稺稻稼稽稾稿穀穁穂穃穄穅穆穇穈穉穊穋穌積穎穏穐穑穒穓穔穕穖穗穘穙穚穛穜穝穞穟穠穡穢穣穤穥穦穧穨穩穪穫穬穭穮穯穰穱穲穳穴穵究穷穸穹空穻穼穽穾穿窀突窂窃窄窅窆窇窈窉窊窋窌窍窎窏窐窑窒窓窔窕窖窗窘窙窚窛窜窝窞窟窠窡窢窣窤窥窦窧窨窩窪窫窬窭窮窯窰窱窲窳窴窵窶窷窸窹窺窻窼窽窾窿竀竁竂竃竄竅竆竇竈竉竊立竌竍竎竏竐竑竒竓竔竕竖竗竘站竚竛竜竝竞竟章竡竢竣竤童竦竧竨竩竪竫竬竭竮端竰竱竲竳竴竵競竷竸竹竺竻竼竽竾竿笀笁笂笃笄笅笆笇笈笉笊笋笌笍笎笏笐笑笒笓笔笕笖笗笘笙笚笛笜笝笞笟笠笡笢笣笤笥符笧笨笩笪笫第笭笮笯笰笱笲笳笴笵笶笷笸笹笺笻笼笽笾笿筀筁筂筃筄筅筆筇筈等筊筋筌筍筎筏筐筑筒筓答筕策筗筘筙筚筛筜筝筞筟筠筡筢筣筤筥筦筧筨筩筪筫筬筭筮筯筰筱筲筳筴筵筶筷筸筹筺筻筼筽签筿简箁箂箃箄箅箆箇箈箉箊箋箌箍箎箏箐箑箒箓箔箕箖算箘箙箚箛箜箝箞箟箠管箢箣箤箥箦箧箨箩箪箫箬箭箮箯箰箱箲箳箴箵箶箷箸箹箺箻箼箽箾箿節篁篂篃範篅篆篇篈築篊篋篌篍篎篏篐篑篒篓篔篕篖篗篘篙篚篛篜篝篞篟篠篡篢篣篤篥篦篧篨篩篪篫篬篭篮篯篰篱篲篳篴篵篶篷篸篹篺篻篼篽篾篿簀簁簂簃簄簅簆簇簈簉簊簋簌簍簎簏簐簑簒簓簔簕簖簗簘簙簚簛簜簝簞簟簠簡簢簣簤簥簦簧簨簩簪簫簬簭簮簯簰簱簲簳簴簵簶簷簸簹簺簻簼簽簾簿籀籁籂籃籄籅籆籇籈籉籊籋籌籍籎籏籐籑籒籓籔籕籖籗籘籙籚籛籜籝籞籟籠籡籢籣籤籥籦籧籨籩籪籫籬籭籮籯籰籱籲米籴籵籶籷籸籹籺类籼籽籾籿粀粁粂粃粄粅粆粇粈粉粊粋粌粍粎粏粐粑粒粓粔粕粖粗粘粙粚粛粜粝粞粟粠粡粢粣粤粥粦粧粨粩粪粫粬粭粮粯粰粱粲粳粴粵粶粷粸粹粺粻粼粽精粿糀糁糂糃糄糅糆糇糈糉糊糋糌糍糎糏糐糑糒糓糔糕糖糗糘糙糚糛糜糝糞糟糠糡糢糣糤糥糦糧糨糩糪糫糬糭糮糯糰糱糲糳糴糵糶糷糸糹糺系糼糽糾糿紀紁紂紃約紅紆紇紈紉紊紋紌納紎紏紐紑紒紓純紕紖紗紘紙級紛紜紝紞紟素紡索紣紤紥紦紧紨紩紪紫紬紭紮累細紱紲紳紴紵紶紷紸紹紺紻紼紽紾紿絀絁終絃組絅絆絇絈絉絊絋経絍絎絏結絑絒絓絔絕絖絗絘絙絚絛絜絝絞絟絠絡絢絣絤絥給絧絨絩絪絫絬絭絮絯絰統絲絳絴絵絶絷絸絹絺絻絼絽絾絿綀綁綂綃綄綅綆綇綈綉綊綋綌綍綎綏綐綑綒經綔綕綖綗綘継続綛綜綝綞綟綠綡綢綣綤綥綦綧綨綩綪綫綬維綮綯綰綱網綳綴綵綶綷綸綹綺綻綼綽綾綿緀緁緂緃緄緅緆緇緈緉緊緋緌緍緎総緐緑緒緓緔緕緖緗緘緙線緛緜緝緞緟締緡緢緣緤緥緦緧編緩緪緫緬緭緮緯緰緱緲緳練緵緶緷緸緹緺緻緼緽緾緿縀縁縂縃縄縅縆縇縈縉縊縋縌縍縎縏縐縑縒縓縔縕縖縗縘縙縚縛縜縝縞縟縠縡縢縣縤縥縦縧縨縩縪縫縬縭縮縯縰縱縲縳縴縵縶縷縸縹縺縻縼總績縿繀繁繂繃繄繅繆繇繈繉繊繋繌繍繎繏繐繑繒繓織繕繖繗繘繙繚繛繜繝繞繟繠繡繢繣繤繥繦繧繨繩繪繫繬繭繮繯繰繱繲繳繴繵繶繷繸繹繺繻繼繽繾繿纀纁纂纃纄纅纆纇纈纉纊纋續纍纎纏纐纑纒纓纔纕纖纗纘纙纚纛纜纝纞纟纠纡红纣纤纥约级纨纩纪纫纬纭纮纯纰纱纲纳纴纵纶纷纸纹纺纻纼纽纾线绀绁绂练组绅细织终绉绊绋绌绍绎经绐绑绒结绔绕绖绗绘给绚绛络绝绞统绠绡绢绣绤绥绦继绨绩绪绫绬续绮绯绰绱绲绳维绵绶绷绸绹绺绻综绽绾绿缀缁缂缃缄缅缆缇缈缉缊缋缌缍缎缏缐缑缒缓缔缕编缗缘缙缚缛缜缝缞缟缠缡缢缣缤缥缦缧缨缩缪缫缬缭缮缯缰缱缲缳缴缵缶缷缸缹缺缻缼缽缾缿罀罁罂罃罄罅罆罇罈罉罊罋罌罍罎罏罐网罒罓罔罕罖罗罘罙罚罛罜罝罞罟罠罡罢罣罤罥罦罧罨罩罪罫罬罭置罯罰罱署罳罴罵罶罷罸罹罺罻罼罽罾罿羀羁羂羃羄羅羆羇羈羉羊羋羌羍美羏羐羑羒羓羔羕羖羗羘羙羚羛羜羝羞羟羠羡羢羣群羥羦羧羨義羪羫羬羭羮羯羰羱羲羳羴羵羶羷羸羹羺羻羼羽羾羿翀翁翂翃翄翅翆翇翈翉翊翋翌翍翎翏翐翑習翓翔翕翖翗翘翙翚翛翜翝翞翟翠翡翢翣翤翥翦翧翨翩翪翫翬翭翮翯翰翱翲翳翴翵翶翷翸翹翺翻翼翽翾翿耀老耂考耄者耆耇耈耉耊耋而耍耎耏耐耑耒耓耔耕耖耗耘耙耚耛耜耝耞耟耠耡耢耣耤耥耦耧耨耩耪耫耬耭耮耯耰耱耲耳耴耵耶耷耸耹耺耻耼耽耾耿聀聁聂聃聄聅聆聇聈聉聊聋职聍聎聏聐聑聒聓联聕聖聗聘聙聚聛聜聝聞聟聠聡聢聣聤聥聦聧聨聩聪聫聬聭聮聯聰聱聲聳聴聵聶職聸聹聺聻聼聽聾聿肀肁肂肃肄肅肆肇肈肉肊肋肌肍肎肏肐肑肒肓肔肕肖肗肘肙肚肛肜肝肞肟肠股肢肣肤肥肦肧肨肩肪肫肬肭肮肯肰肱育肳肴肵肶肷肸肹肺肻肼肽肾肿胀胁胂胃胄胅胆胇胈胉胊胋背胍胎胏胐胑胒胓胔胕胖胗胘胙胚胛胜胝胞胟胠胡胢胣胤胥胦胧胨胩胪胫胬胭胮胯胰胱胲胳胴胵胶胷胸胹胺胻胼能胾胿脀脁脂脃脄脅脆脇脈脉脊脋脌脍脎脏脐脑脒脓脔脕脖脗脘脙脚脛脜脝脞脟脠脡脢脣脤脥脦脧脨脩脪脫脬脭脮脯脰脱脲脳脴脵脶脷脸脹脺脻脼脽脾脿腀腁腂腃腄腅腆腇腈腉腊腋腌腍腎腏腐腑腒腓腔腕腖腗腘腙腚腛腜腝腞腟腠腡腢腣腤腥腦腧腨腩腪腫腬腭腮腯腰腱腲腳腴腵腶腷腸腹腺腻腼腽腾腿膀膁膂膃膄膅膆膇膈膉膊膋膌膍膎膏膐膑膒膓膔膕膖膗膘膙膚膛膜膝膞膟膠膡膢膣膤膥膦膧膨膩膪膫膬膭膮膯膰膱膲膳膴膵膶膷膸膹膺膻膼膽膾膿臀臁臂臃臄臅臆臇臈臉臊臋臌臍臎臏臐臑臒臓臔臕臖臗臘臙臚臛臜臝臞臟臠臡臢臣臤臥臦臧臨臩自臫臬臭臮臯臰臱臲至致臵臶臷臸臹臺臻臼臽臾臿舀舁舂舃舄舅舆與興舉舊舋舌舍舎舏舐舑舒舓舔舕舖舗舘舙舚舛舜舝舞舟舠舡舢舣舤舥舦舧舨舩航舫般舭舮舯舰舱舲舳舴舵舶舷舸船舺舻舼舽舾舿艀艁艂艃艄艅艆艇艈艉艊艋艌艍艎艏艐艑艒艓艔艕艖艗艘艙艚艛艜艝艞艟艠艡艢艣艤艥艦艧艨艩艪艫艬艭艮良艰艱色艳艴艵艶艷艸艹艺艻艼艽艾艿芀芁节芃芄芅芆芇芈芉芊芋芌芍芎芏芐芑芒芓芔芕芖芗芘芙芚芛芜芝芞芟芠芡芢芣芤芥芦芧芨芩芪芫芬芭芮芯芰花芲芳芴芵芶芷芸芹芺芻芼芽芾芿苀苁苂苃苄苅苆苇苈苉苊苋苌苍苎苏苐苑苒苓苔苕苖苗苘苙苚苛苜苝苞苟苠苡苢苣苤若苦苧苨苩苪苫苬苭苮苯苰英苲苳苴苵苶苷苸苹苺苻苼苽苾苿茀茁茂范茄茅茆茇茈茉茊茋茌茍茎茏茐茑茒茓茔茕茖茗茘茙茚茛茜茝茞茟茠茡茢茣茤茥茦茧茨茩茪茫茬茭茮茯茰茱茲茳茴茵茶茷茸茹茺茻茼茽茾茿荀荁荂荃荄荅荆荇荈草荊荋荌荍荎荏荐荑荒荓荔荕荖荗荘荙荚荛荜荝荞荟荠荡荢荣荤荥荦荧荨荩荪荫荬荭荮药荰荱荲荳荴荵荶荷荸荹荺荻荼荽荾荿莀莁莂莃莄莅莆莇莈莉莊莋莌莍莎莏莐莑莒莓莔莕莖莗莘莙莚莛莜莝莞莟莠莡莢莣莤莥莦莧莨莩莪莫莬莭莮莯莰莱莲莳莴莵莶获莸莹莺莻莼莽莾莿菀菁菂菃菄菅菆菇菈菉菊菋菌菍菎菏菐菑菒菓菔菕菖菗菘菙菚菛菜菝菞菟菠菡菢菣菤菥菦菧菨菩菪菫菬菭菮華菰菱菲菳菴菵菶菷菸菹菺菻菼菽菾菿萀萁萂萃萄萅萆萇萈萉萊萋萌萍萎萏萐萑萒萓萔萕萖萗萘萙萚萛萜萝萞萟萠萡萢萣萤营萦萧萨萩萪萫萬萭萮萯萰萱萲萳萴萵萶萷萸萹萺萻萼落萾萿葀葁葂葃葄葅葆葇葈葉葊葋葌葍葎葏葐葑葒葓葔葕葖著葘葙葚葛葜葝葞葟葠葡葢董葤葥葦葧葨葩葪葫葬葭葮葯葰葱葲葳葴葵葶葷葸葹葺葻葼葽葾葿蒀蒁蒂蒃蒄蒅蒆蒇蒈蒉蒊蒋蒌蒍蒎蒏蒐蒑蒒蒓蒔蒕蒖蒗蒘蒙蒚蒛蒜蒝蒞蒟蒠蒡蒢蒣蒤蒥蒦蒧蒨蒩蒪蒫蒬蒭蒮蒯蒰蒱蒲蒳蒴蒵蒶蒷蒸蒹蒺蒻蒼蒽蒾蒿蓀蓁蓂蓃蓄蓅蓆蓇蓈蓉蓊蓋蓌蓍蓎蓏蓐蓑蓒蓓蓔蓕蓖蓗蓘蓙蓚蓛蓜蓝蓞蓟蓠蓡蓢蓣蓤蓥蓦蓧蓨蓩蓪蓫蓬蓭蓮蓯蓰蓱蓲蓳蓴蓵蓶蓷蓸蓹蓺蓻蓼蓽蓾蓿蔀蔁蔂蔃蔄蔅蔆蔇蔈蔉蔊蔋蔌蔍蔎蔏蔐蔑蔒蔓蔔蔕蔖蔗蔘蔙蔚蔛蔜蔝蔞蔟蔠蔡蔢蔣蔤蔥蔦蔧蔨蔩蔪蔫蔬蔭蔮蔯蔰蔱蔲蔳蔴蔵蔶蔷蔸蔹蔺蔻蔼蔽蔾蔿蕀蕁蕂蕃蕄蕅蕆蕇蕈蕉蕊蕋蕌蕍蕎蕏蕐蕑蕒蕓蕔蕕蕖蕗蕘蕙蕚蕛蕜蕝蕞蕟蕠蕡蕢蕣蕤蕥蕦蕧蕨蕩蕪蕫蕬蕭蕮蕯蕰蕱蕲蕳蕴蕵蕶蕷蕸蕹蕺蕻蕼蕽蕾蕿薀薁薂薃薄薅薆薇薈薉薊薋薌薍薎薏薐薑薒薓薔薕薖薗薘薙薚薛薜薝薞薟薠薡薢薣薤薥薦薧薨薩薪薫薬薭薮薯薰薱薲薳薴薵薶薷薸薹薺薻薼薽薾薿藀藁藂藃藄藅藆藇藈藉藊藋藌藍藎藏藐藑藒藓藔藕藖藗藘藙藚藛藜藝藞藟藠藡藢藣藤藥藦藧藨藩藪藫藬藭藮藯藰藱藲藳藴藵藶藷藸藹藺藻藼藽藾藿蘀蘁蘂蘃蘄蘅蘆蘇蘈蘉蘊蘋蘌蘍蘎蘏蘐蘑蘒蘓蘔蘕蘖蘗蘘蘙蘚蘛蘜蘝蘞蘟蘠蘡蘢蘣蘤蘥蘦蘧蘨蘩蘪蘫蘬蘭蘮蘯蘰蘱蘲蘳蘴蘵蘶蘷蘸蘹蘺蘻蘼蘽蘾蘿虀虁虂虃虄虅虆虇虈虉虊虋虌虍虎虏虐虑虒虓虔處虖虗虘虙虚虛虜虝虞號虠虡虢虣虤虥虦虧虨虩虪虫虬虭虮虯虰虱虲虳虴虵虶虷虸虹虺虻虼虽虾虿蚀蚁蚂蚃蚄蚅蚆蚇蚈蚉蚊蚋蚌蚍蚎蚏蚐蚑蚒蚓蚔蚕蚖蚗蚘蚙蚚蚛蚜蚝蚞蚟蚠蚡蚢蚣蚤蚥蚦蚧蚨蚩蚪蚫蚬蚭蚮蚯蚰蚱蚲蚳蚴蚵蚶蚷蚸蚹蚺蚻蚼蚽蚾蚿蛀蛁蛂蛃蛄蛅蛆蛇蛈蛉蛊蛋蛌蛍蛎蛏蛐蛑蛒蛓蛔蛕蛖蛗蛘蛙蛚蛛蛜蛝蛞蛟蛠蛡蛢蛣蛤蛥蛦蛧蛨蛩蛪蛫蛬蛭蛮蛯蛰蛱蛲蛳蛴蛵蛶蛷蛸蛹蛺蛻蛼蛽蛾蛿蜀蜁蜂蜃蜄蜅蜆蜇蜈蜉蜊蜋蜌蜍蜎蜏蜐蜑蜒蜓蜔蜕蜖蜗蜘蜙蜚蜛蜜蜝蜞蜟蜠蜡蜢蜣蜤蜥蜦蜧蜨蜩蜪蜫蜬蜭蜮蜯蜰蜱蜲蜳蜴蜵蜶蜷蜸蜹蜺蜻蜼蜽蜾蜿蝀蝁蝂蝃蝄蝅蝆蝇蝈蝉蝊蝋蝌蝍蝎蝏蝐蝑蝒蝓蝔蝕蝖蝗蝘蝙蝚蝛蝜蝝蝞蝟蝠蝡蝢蝣蝤蝥蝦蝧蝨蝩蝪蝫蝬蝭蝮蝯蝰蝱蝲蝳蝴蝵蝶蝷蝸蝹蝺蝻蝼蝽蝾蝿螀螁螂螃螄螅螆螇螈螉螊螋螌融螎螏螐螑螒螓螔螕螖螗螘螙螚螛螜螝螞螟螠螡螢螣螤螥螦螧螨螩螪螫螬螭螮螯螰螱螲螳螴螵螶螷螸螹螺螻螼螽螾螿蟀蟁蟂蟃蟄蟅蟆蟇蟈蟉蟊蟋蟌蟍蟎蟏蟐蟑蟒蟓蟔蟕蟖蟗蟘蟙蟚蟛蟜蟝蟞蟟蟠蟡蟢蟣蟤蟥蟦蟧蟨蟩蟪蟫蟬蟭蟮蟯蟰蟱蟲蟳蟴蟵蟶蟷蟸蟹蟺蟻蟼蟽蟾蟿蠀蠁蠂蠃蠄蠅蠆蠇蠈蠉蠊蠋蠌蠍蠎蠏蠐蠑蠒蠓蠔蠕蠖蠗蠘蠙蠚蠛蠜蠝蠞蠟蠠蠡蠢蠣蠤蠥蠦蠧蠨蠩蠪蠫蠬蠭蠮蠯蠰蠱蠲蠳蠴蠵蠶蠷蠸蠹蠺蠻蠼蠽蠾蠿血衁衂衃衄衅衆衇衈衉衊衋行衍衎衏衐衑衒術衔衕衖街衘衙衚衛衜衝衞衟衠衡衢衣衤补衦衧表衩衪衫衬衭衮衯衰衱衲衳衴衵衶衷衸衹衺衻衼衽衾衿袀袁袂袃袄袅袆袇袈袉袊袋袌袍袎袏袐袑袒袓袔袕袖袗袘袙袚袛袜袝袞袟袠袡袢袣袤袥袦袧袨袩袪被袬袭袮袯袰袱袲袳袴袵袶袷袸袹袺袻袼袽袾袿裀裁裂裃裄装裆裇裈裉裊裋裌裍裎裏裐裑裒裓裔裕裖裗裘裙裚裛補裝裞裟裠裡裢裣裤裥裦裧裨裩裪裫裬裭裮裯裰裱裲裳裴裵裶裷裸裹裺裻裼製裾裿褀褁褂褃褄褅褆複褈褉褊褋褌褍褎褏褐褑褒褓褔褕褖褗褘褙褚褛褜褝褞褟褠褡褢褣褤褥褦褧褨褩褪褫褬褭褮褯褰褱褲褳褴褵褶褷褸褹褺褻褼褽褾褿襀襁襂襃襄襅襆襇襈襉襊襋襌襍襎襏襐襑襒襓襔襕襖襗襘襙襚襛襜襝襞襟襠襡襢襣襤襥襦襧襨襩襪襫襬襭襮襯襰襱襲襳襴襵襶襷襸襹襺襻襼襽襾西覀要覂覃覄覅覆覇覈覉覊見覌覍覎規覐覑覒覓覔覕視覗覘覙覚覛覜覝覞覟覠覡覢覣覤覥覦覧覨覩親覫覬覭覮覯覰覱覲観覴覵覶覷覸覹覺覻覼覽覾覿觀见观觃规觅视觇览觉觊觋觌觍觎觏觐觑角觓觔觕觖觗觘觙觚觛觜觝觞觟觠觡觢解觤觥触觧觨觩觪觫觬觭觮觯觰觱觲觳觴觵觶觷觸觹觺觻觼觽觾觿言訁訂訃訄訅訆訇計訉訊訋訌訍討訏訐訑訒訓訔訕訖託記訙訚訛訜訝訞訟訠訡訢訣訤訥訦訧訨訩訪訫訬設訮訯訰許訲訳訴訵訶訷訸訹診註証訽訾訿詀詁詂詃詄詅詆詇詈詉詊詋詌詍詎詏詐詑詒詓詔評詖詗詘詙詚詛詜詝詞詟詠詡詢詣詤詥試詧詨詩詪詫詬詭詮詯詰話該詳詴詵詶詷詸詹詺詻詼詽詾詿誀誁誂誃誄誅誆誇誈誉誊誋誌認誎誏誐誑誒誓誔誕誖誗誘誙誚誛誜誝語誟誠誡誢誣誤誥誦誧誨誩說誫説読誮誯誰誱課誳誴誵誶誷誸誹誺誻誼誽誾調諀諁諂諃諄諅諆談諈諉諊請諌諍諎諏諐諑諒諓諔諕論諗諘諙諚諛諜諝諞諟諠諡諢諣諤諥諦諧諨諩諪諫諬諭諮諯諰諱諲諳諴諵諶諷諸諹諺諻諼諽諾諿謀謁謂謃謄謅謆謇謈謉謊謋謌謍謎謏謐謑謒謓謔謕謖謗謘謙謚講謜謝謞謟謠謡謢謣謤謥謦謧謨謩謪謫謬謭謮謯謰謱謲謳謴謵謶謷謸謹謺謻謼謽謾謿譀譁譂譃譄譅譆譇譈證譊譋譌譍譎譏譐譑譒譓譔譕譖譗識譙譚譛譜譝譞譟譠譡譢譣譤譥警譧譨譩譪譫譬譭譮譯議譱譲譳譴譵譶護譸譹譺譻譼譽譾譿讀讁讂讃讄讅讆讇讈讉變讋讌讍讎讏讐讑讒讓讔讕讖讗讘讙讚讛讜讝讞讟讠计订讣认讥讦讧讨让讪讫讬训议讯记讱讲讳讴讵讶讷许讹论讻讼讽设访诀证诂诃评诅识诇诈诉诊诋诌词诎诏诐译诒诓诔试诖诗诘诙诚诛诜话诞诟诠诡询诣诤该详诧诨诩诪诫诬语诮误诰诱诲诳说诵诶请诸诹诺读诼诽课诿谀谁谂调谄谅谆谇谈谉谊谋谌谍谎谏谐谑谒谓谔谕谖谗谘谙谚谛谜谝谞谟谠谡谢谣谤谥谦谧谨谩谪谫谬谭谮谯谰谱谲谳谴谵谶谷谸谹谺谻谼谽谾谿豀豁豂豃豄豅豆豇豈豉豊豋豌豍豎豏豐豑豒豓豔豕豖豗豘豙豚豛豜豝豞豟豠象豢豣豤豥豦豧豨豩豪豫豬豭豮豯豰豱豲豳豴豵豶豷豸豹豺豻豼豽豾豿貀貁貂貃貄貅貆貇貈貉貊貋貌貍貎貏貐貑貒貓貔貕貖貗貘貙貚貛貜貝貞貟負財貢貣貤貥貦貧貨販貪貫責貭貮貯貰貱貲貳貴貵貶買貸貹貺費貼貽貾貿賀賁賂賃賄賅賆資賈賉賊賋賌賍賎賏賐賑賒賓賔賕賖賗賘賙賚賛賜賝賞賟賠賡賢賣賤賥賦賧賨賩質賫賬賭賮賯賰賱賲賳賴賵賶賷賸賹賺賻購賽賾賿贀贁贂贃贄贅贆贇贈贉贊贋贌贍贎贏贐贑贒贓贔贕贖贗贘贙贚贛贜贝贞负贠贡财责贤败账货质贩贪贫贬购贮贯贰贱贲贳贴贵贶贷贸费贺贻贼贽贾贿赀赁赂赃资赅赆赇赈赉赊赋赌赍赎赏赐赑赒赓赔赕赖赗赘赙赚赛赜赝赞赟赠赡赢赣赤赥赦赧赨赩赪赫赬赭赮赯走赱赲赳赴赵赶起赸赹赺赻赼赽赾赿趀趁趂趃趄超趆趇趈趉越趋趌趍趎趏趐趑趒趓趔趕趖趗趘趙趚趛趜趝趞趟趠趡趢趣趤趥趦趧趨趩趪趫趬趭趮趯趰趱趲足趴趵趶趷趸趹趺趻趼趽趾趿跀跁跂跃跄跅跆跇跈跉跊跋跌跍跎跏跐跑跒跓跔跕跖跗跘跙跚跛跜距跞跟跠跡跢跣跤跥跦跧跨跩跪跫跬跭跮路跰跱跲跳跴践跶跷跸跹跺跻跼跽跾跿踀踁踂踃踄踅踆踇踈踉踊踋踌踍踎踏踐踑踒踓踔踕踖踗踘踙踚踛踜踝踞踟踠踡踢踣踤踥踦踧踨踩踪踫踬踭踮踯踰踱踲踳踴踵踶踷踸踹踺踻踼踽踾踿蹀蹁蹂蹃蹄蹅蹆蹇蹈蹉蹊蹋蹌蹍蹎蹏蹐蹑蹒蹓蹔蹕蹖蹗蹘蹙蹚蹛蹜蹝蹞蹟蹠蹡蹢蹣蹤蹥蹦蹧蹨蹩蹪蹫蹬蹭蹮蹯蹰蹱蹲蹳蹴蹵蹶蹷蹸蹹蹺蹻蹼蹽蹾蹿躀躁躂躃躄躅躆躇躈躉躊躋躌躍躎躏躐躑躒躓躔躕躖躗躘躙躚躛躜躝躞躟躠躡躢躣躤躥躦躧躨躩躪身躬躭躮躯躰躱躲躳躴躵躶躷躸躹躺躻躼躽躾躿軀軁軂軃軄軅軆軇軈軉車軋軌軍軎軏軐軑軒軓軔軕軖軗軘軙軚軛軜軝軞軟軠軡転軣軤軥軦軧軨軩軪軫軬軭軮軯軰軱軲軳軴軵軶軷軸軹軺軻軼軽軾軿輀輁輂較輄輅輆輇輈載輊輋輌輍輎輏輐輑輒輓輔輕輖輗輘輙輚輛輜輝輞輟輠輡輢輣輤輥輦輧輨輩輪輫輬輭輮輯輰輱輲輳輴輵輶輷輸輹輺輻輼輽輾輿轀轁轂轃轄轅轆轇轈轉轊轋轌轍轎轏轐轑轒轓轔轕轖轗轘轙轚轛轜轝轞轟轠轡轢轣轤轥车轧轨轩轪轫转轭轮软轰轱轲轳轴轵轶轷轸轹轺轻轼载轾轿辀辁辂较辄辅辆辇辈辉辊辋辌辍辎辏辐辑辒输辔辕辖辗辘辙辚辛辜辝辞辟辠辡辢辣辤辥辦辧辨辩辪辫辬辭辮辯辰辱農辳辴辵辶辷辸边辺辻込辽达辿迀迁迂迃迄迅迆过迈迉迊迋迌迍迎迏运近迒迓返迕迖迗还这迚进远违连迟迠迡迢迣迤迥迦迧迨迩迪迫迬迭迮迯述迱迲迳迴迵迶迷迸迹迺迻迼追迾迿退送适逃逄逅逆逇逈选逊逋逌逍逎透逐逑递逓途逕逖逗逘這通逛逜逝逞速造逡逢連逤逥逦逧逨逩逪逫逬逭逮逯逰週進逳逴逵逶逷逸逹逺逻逼逽逾逿遀遁遂遃遄遅遆遇遈遉遊運遌遍過遏遐遑遒道達違遖遗遘遙遚遛遜遝遞遟遠遡遢遣遤遥遦遧遨適遪遫遬遭遮遯遰遱遲遳遴遵遶遷選遹遺遻遼遽遾避邀邁邂邃還邅邆邇邈邉邊邋邌邍邎邏邐邑邒邓邔邕邖邗邘邙邚邛邜邝邞邟邠邡邢那邤邥邦邧邨邩邪邫邬邭邮邯邰邱邲邳邴邵邶邷邸邹邺邻邼邽邾邿郀郁郂郃郄郅郆郇郈郉郊郋郌郍郎郏郐郑郒郓郔郕郖郗郘郙郚郛郜郝郞郟郠郡郢郣郤郥郦郧部郩郪郫郬郭郮郯郰郱郲郳郴郵郶郷郸郹郺郻郼都郾郿鄀鄁鄂鄃鄄鄅鄆鄇鄈鄉鄊鄋鄌鄍鄎鄏鄐鄑鄒鄓鄔鄕鄖鄗鄘鄙鄚鄛鄜鄝鄞鄟鄠鄡鄢鄣鄤鄥鄦鄧鄨鄩鄪鄫鄬鄭鄮鄯鄰鄱鄲鄳鄴鄵鄶鄷鄸鄹鄺鄻鄼鄽鄾鄿酀酁酂酃酄酅酆酇酈酉酊酋酌配酎酏酐酑酒酓酔酕酖酗酘酙酚酛酜酝酞酟酠酡酢酣酤酥酦酧酨酩酪酫酬酭酮酯酰酱酲酳酴酵酶酷酸酹酺酻酼酽酾酿醀醁醂醃醄醅醆醇醈醉醊醋醌醍醎醏醐醑醒醓醔醕醖醗醘醙醚醛醜醝醞醟醠醡醢醣醤醥醦醧醨醩醪醫醬醭醮醯醰醱醲醳醴醵醶醷醸醹醺醻醼醽醾醿釀釁釂釃釄釅釆采釈釉释釋里重野量釐金釒釓釔釕釖釗釘釙釚釛釜針釞釟釠釡釢釣釤釥釦釧釨釩釪釫釬釭釮釯釰釱釲釳釴釵釶釷釸釹釺釻釼釽釾釿鈀鈁鈂鈃鈄鈅鈆鈇鈈鈉鈊鈋鈌鈍鈎鈏鈐鈑鈒鈓鈔鈕鈖鈗鈘鈙鈚鈛鈜鈝鈞鈟鈠鈡鈢鈣鈤鈥鈦鈧鈨鈩鈪鈫鈬鈭鈮鈯鈰鈱鈲鈳鈴鈵鈶鈷鈸鈹鈺鈻鈼鈽鈾鈿鉀鉁鉂鉃鉄鉅鉆鉇鉈鉉鉊鉋鉌鉍鉎鉏鉐鉑鉒鉓鉔鉕鉖鉗鉘鉙鉚鉛鉜鉝鉞鉟鉠鉡鉢鉣鉤鉥鉦鉧鉨鉩鉪鉫鉬鉭鉮鉯鉰鉱鉲鉳鉴鉵鉶鉷鉸鉹鉺鉻鉼鉽鉾鉿銀銁銂銃銄銅銆銇銈銉銊銋銌銍銎銏銐銑銒銓銔銕銖銗銘銙銚銛銜銝銞銟銠銡銢銣銤銥銦銧銨銩銪銫銬銭銮銯銰銱銲銳銴銵銶銷銸銹銺銻銼銽銾銿鋀鋁鋂鋃鋄鋅鋆鋇鋈鋉鋊鋋鋌鋍鋎鋏鋐鋑鋒鋓鋔鋕鋖鋗鋘鋙鋚鋛鋜鋝鋞鋟鋠鋡鋢鋣鋤鋥鋦鋧鋨鋩鋪鋫鋬鋭鋮鋯鋰鋱鋲鋳鋴鋵鋶鋷鋸鋹鋺鋻鋼鋽鋾鋿錀錁錂錃錄錅錆錇錈錉錊錋錌錍錎錏錐錑錒錓錔錕錖錗錘錙錚錛錜錝錞錟錠錡錢錣錤錥錦錧錨錩錪錫錬錭錮錯錰錱録錳錴錵錶錷錸錹錺錻錼錽錾錿鍀鍁鍂鍃鍄鍅鍆鍇鍈鍉鍊鍋鍌鍍鍎鍏鍐鍑鍒鍓鍔鍕鍖鍗鍘鍙鍚鍛鍜鍝鍞鍟鍠鍡鍢鍣鍤鍥鍦鍧鍨鍩鍪鍫鍬鍭鍮鍯鍰鍱鍲鍳鍴鍵鍶鍷鍸鍹鍺鍻鍼鍽鍾鍿鎀鎁鎂鎃鎄鎅鎆鎇鎈鎉鎊鎋鎌鎍鎎鎏鎐鎑鎒鎓鎔鎕鎖鎗鎘鎙鎚鎛鎜鎝鎞鎟鎠鎡鎢鎣鎤鎥鎦鎧鎨鎩鎪鎫鎬鎭鎮鎯鎰鎱鎲鎳鎴鎵鎶鎷鎸鎹鎺鎻鎼鎽鎾鎿鏀鏁鏂鏃鏄鏅鏆鏇鏈鏉鏊鏋鏌鏍鏎鏏鏐鏑鏒鏓鏔鏕鏖鏗鏘鏙鏚鏛鏜鏝鏞鏟鏠鏡鏢鏣鏤鏥鏦鏧鏨鏩鏪鏫鏬鏭鏮鏯鏰鏱鏲鏳鏴鏵鏶鏷鏸鏹鏺鏻鏼鏽鏾鏿鐀鐁鐂鐃鐄鐅鐆鐇鐈鐉鐊鐋鐌鐍鐎鐏鐐鐑鐒鐓鐔鐕鐖鐗鐘鐙鐚鐛鐜鐝鐞鐟鐠鐡鐢鐣鐤鐥鐦鐧鐨鐩鐪鐫鐬鐭鐮鐯鐰鐱鐲鐳鐴鐵鐶鐷鐸鐹鐺鐻鐼鐽鐾鐿鑀鑁鑂鑃鑄鑅鑆鑇鑈鑉鑊鑋鑌鑍鑎鑏鑐鑑鑒鑓鑔鑕鑖鑗鑘鑙鑚鑛鑜鑝鑞鑟鑠鑡鑢鑣鑤鑥鑦鑧鑨鑩鑪鑫鑬鑭鑮鑯鑰鑱鑲鑳鑴鑵鑶鑷鑸鑹鑺鑻鑼鑽鑾鑿钀钁钂钃钄钅钆钇针钉钊钋钌钍钎钏钐钑钒钓钔钕钖钗钘钙钚钛钜钝钞钟钠钡钢钣钤钥钦钧钨钩钪钫钬钭钮钯钰钱钲钳钴钵钶钷钸钹钺钻钼钽钾钿铀铁铂铃铄铅铆铇铈铉铊铋铌铍铎铏铐铑铒铓铔铕铖铗铘铙铚铛铜铝铞铟铠铡铢铣铤铥铦铧铨铩铪铫铬铭铮铯铰铱铲铳铴铵银铷铸铹铺铻铼铽链铿销锁锂锃锄锅锆锇锈锉锊锋锌锍锎锏锐锑锒锓锔锕锖锗锘错锚锛锜锝锞锟锠锡锢锣锤锥锦锧锨锩锪锫锬锭键锯锰锱锲锳锴锵锶锷锸锹锺锻锼锽锾锿镀镁镂镃镄镅镆镇镈镉镊镋镌镍镎镏镐镑镒镓镔镕镖镗镘镙镚镛镜镝镞镟镠镡镢镣镤镥镦镧镨镩镪镫镬镭镮镯镰镱镲镳镴镵镶長镸镹镺镻镼镽镾长門閁閂閃閄閅閆閇閈閉閊開閌閍閎閏閐閑閒間閔閕閖閗閘閙閚閛閜閝閞閟閠閡関閣閤閥閦閧閨閩閪閫閬閭閮閯閰閱閲閳閴閵閶閷閸閹閺閻閼閽閾閿闀闁闂闃闄闅闆闇闈闉闊闋闌闍闎闏闐闑闒闓闔闕闖闗闘闙闚闛關闝闞闟闠闡闢闣闤闥闦闧门闩闪闫闬闭问闯闰闱闲闳间闵闶闷闸闹闺闻闼闽闾闿阀阁阂阃阄阅阆阇阈阉阊阋阌阍阎阏阐阑阒阓阔阕阖阗阘阙阚阛阜阝阞队阠阡阢阣阤阥阦阧阨阩阪阫阬阭阮阯阰阱防阳阴阵阶阷阸阹阺阻阼阽阾阿陀陁陂陃附际陆陇陈陉陊陋陌降陎陏限陑陒陓陔陕陖陗陘陙陚陛陜陝陞陟陠陡院陣除陥陦陧陨险陪陫陬陭陮陯陰陱陲陳陴陵陶陷陸陹険陻陼陽陾陿隀隁隂隃隄隅隆隇隈隉隊隋隌隍階随隐隑隒隓隔隕隖隗隘隙隚際障隝隞隟隠隡隢隣隤隥隦隧隨隩險隫隬隭隮隯隰隱隲隳隴隵隶隷隸隹隺隻隼隽难隿雀雁雂雃雄雅集雇雈雉雊雋雌雍雎雏雐雑雒雓雔雕雖雗雘雙雚雛雜雝雞雟雠雡離難雤雥雦雧雨雩雪雫雬雭雮雯雰雱雲雳雴雵零雷雸雹雺電雼雽雾雿需霁霂霃霄霅霆震霈霉霊霋霌霍霎霏霐霑霒霓霔霕霖霗霘霙霚霛霜霝霞霟霠霡霢霣霤霥霦霧霨霩霪霫霬霭霮霯霰霱露霳霴霵霶霷霸霹霺霻霼霽霾霿靀靁靂靃靄靅靆靇靈靉靊靋靌靍靎靏靐靑青靓靔靕靖靗靘静靚靛靜靝非靟靠靡面靣靤靥靦靧靨革靪靫靬靭靮靯靰靱靲靳靴靵靶靷靸靹靺靻靼靽靾靿鞀鞁鞂鞃鞄鞅鞆鞇鞈鞉鞊鞋鞌鞍鞎鞏鞐鞑鞒鞓鞔鞕鞖鞗鞘鞙鞚鞛鞜鞝鞞鞟鞠鞡鞢鞣鞤鞥鞦鞧鞨鞩鞪鞫鞬鞭鞮鞯鞰鞱鞲鞳鞴鞵鞶鞷鞸鞹鞺鞻鞼鞽鞾鞿韀韁韂韃韄韅韆韇韈韉韊韋韌韍韎韏韐韑韒韓韔韕韖韗韘韙韚韛韜韝韞韟韠韡韢韣韤韥韦韧韨韩韪韫韬韭韮韯韰韱韲音韴韵韶韷韸韹韺韻韼韽韾響頀頁頂頃頄項順頇須頉頊頋頌頍頎頏預頑頒頓頔頕頖頗領頙頚頛頜頝頞頟頠頡頢頣頤頥頦頧頨頩頪頫頬頭頮頯頰頱頲頳頴頵頶頷頸頹頺頻頼頽頾頿顀顁顂顃顄顅顆顇顈顉顊顋題額顎顏顐顑顒顓顔顕顖顗願顙顚顛顜顝類顟顠顡顢顣顤顥顦顧顨顩顪顫顬顭顮顯顰顱顲顳顴页顶顷顸项顺须顼顽顾顿颀颁颂颃预颅领颇颈颉颊颋颌颍颎颏颐频颒颓颔颕颖颗题颙颚颛颜额颞颟颠颡颢颣颤颥颦颧風颩颪颫颬颭颮颯颰颱颲颳颴颵颶颷颸颹颺颻颼颽颾颿飀飁飂飃飄飅飆飇飈飉飊飋飌飍风飏飐飑飒飓飔飕飖飗飘飙飚飛飜飝飞食飠飡飢飣飤飥飦飧飨飩飪飫飬飭飮飯飰飱飲飳飴飵飶飷飸飹飺飻飼飽飾飿餀餁餂餃餄餅餆餇餈餉養餋餌餍餎餏餐餑餒餓餔餕餖餗餘餙餚餛餜餝餞餟餠餡餢餣餤餥餦餧館餩餪餫餬餭餮餯餰餱餲餳餴餵餶餷餸餹餺餻餼餽餾餿饀饁饂饃饄饅饆饇饈饉饊饋饌饍饎饏饐饑饒饓饔饕饖饗饘饙饚饛饜饝饞饟饠饡饢饣饤饥饦饧饨饩饪饫饬饭饮饯饰饱饲饳饴饵饶饷饸饹饺饻饼饽饾饿馀馁馂馃馄馅馆馇馈馉馊馋馌馍馎馏馐馑馒馓馔馕首馗馘香馚馛馜馝馞馟馠馡馢馣馤馥馦馧馨馩馪馫馬馭馮馯馰馱馲馳馴馵馶馷馸馹馺馻馼馽馾馿駀駁駂駃駄駅駆駇駈駉駊駋駌駍駎駏駐駑駒駓駔駕駖駗駘駙駚駛駜駝駞駟駠駡駢駣駤駥駦駧駨駩駪駫駬駭駮駯駰駱駲駳駴駵駶駷駸駹駺駻駼駽駾駿騀騁騂騃騄騅騆騇騈騉騊騋騌騍騎騏騐騑騒験騔騕騖騗騘騙騚騛騜騝騞騟騠騡騢騣騤騥騦騧騨騩騪騫騬騭騮騯騰騱騲騳騴騵騶騷騸騹騺騻騼騽騾騿驀驁驂驃驄驅驆驇驈驉驊驋驌驍驎驏驐驑驒驓驔驕驖驗驘驙驚驛驜驝驞驟驠驡驢驣驤驥驦驧驨驩驪驫马驭驮驯驰驱驲驳驴驵驶驷驸驹驺驻驼驽驾驿骀骁骂骃骄骅骆骇骈骉骊骋验骍骎骏骐骑骒骓骔骕骖骗骘骙骚骛骜骝骞骟骠骡骢骣骤骥骦骧骨骩骪骫骬骭骮骯骰骱骲骳骴骵骶骷骸骹骺骻骼骽骾骿髀髁髂髃髄髅髆髇髈髉髊髋髌髍髎髏髐髑髒髓體髕髖髗高髙髚髛髜髝髞髟髠髡髢髣髤髥髦髧髨髩髪髫髬髭髮髯髰髱髲髳髴髵髶髷髸髹髺髻髼髽髾髿鬀鬁鬂鬃鬄鬅鬆鬇鬈鬉鬊鬋鬌鬍鬎鬏鬐鬑鬒鬓鬔鬕鬖鬗鬘鬙鬚鬛鬜鬝鬞鬟鬠鬡鬢鬣鬤鬥鬦鬧鬨鬩鬪鬫鬬鬭鬮鬯鬰鬱鬲鬳鬴鬵鬶鬷鬸鬹鬺鬻鬼鬽鬾鬿魀魁魂魃魄魅魆魇魈魉魊魋魌魍魎魏魐魑魒魓魔魕魖魗魘魙魚魛魜魝魞魟魠魡魢魣魤魥魦魧魨魩魪魫魬魭魮魯魰魱魲魳魴魵魶魷魸魹魺魻魼魽魾魿鮀鮁鮂鮃鮄鮅鮆鮇鮈鮉鮊鮋鮌鮍鮎鮏鮐鮑鮒鮓鮔鮕鮖鮗鮘鮙鮚鮛鮜鮝鮞鮟鮠鮡鮢鮣鮤鮥鮦鮧鮨鮩鮪鮫鮬鮭鮮鮯鮰鮱鮲鮳鮴鮵鮶鮷鮸鮹鮺鮻鮼鮽鮾鮿鯀鯁鯂鯃鯄鯅鯆鯇鯈鯉鯊鯋鯌鯍鯎鯏鯐鯑鯒鯓鯔鯕鯖鯗鯘鯙鯚鯛鯜鯝鯞鯟鯠鯡鯢鯣鯤鯥鯦鯧鯨鯩鯪鯫鯬鯭鯮鯯鯰鯱鯲鯳鯴鯵鯶鯷鯸鯹鯺鯻鯼鯽鯾鯿鰀鰁鰂鰃鰄鰅鰆鰇鰈鰉鰊鰋鰌鰍鰎鰏鰐鰑鰒鰓鰔鰕鰖鰗鰘鰙鰚鰛鰜鰝鰞鰟鰠鰡鰢鰣鰤鰥鰦鰧鰨鰩鰪鰫鰬鰭鰮鰯鰰鰱鰲鰳鰴鰵鰶鰷鰸鰹鰺鰻鰼鰽鰾鰿鱀鱁鱂鱃鱄鱅鱆鱇鱈鱉鱊鱋鱌鱍鱎鱏鱐鱑鱒鱓鱔鱕鱖鱗鱘鱙鱚鱛鱜鱝鱞鱟鱠鱡鱢鱣鱤鱥鱦鱧鱨鱩鱪鱫鱬鱭鱮鱯鱰鱱鱲鱳鱴鱵鱶鱷鱸鱹鱺鱻鱼鱽鱾鱿鲀鲁鲂鲃鲄鲅鲆鲇鲈鲉鲊鲋鲌鲍鲎鲏鲐鲑鲒鲓鲔鲕鲖鲗鲘鲙鲚鲛鲜鲝鲞鲟鲠鲡鲢鲣鲤鲥鲦鲧鲨鲩鲪鲫鲬鲭鲮鲯鲰鲱鲲鲳鲴鲵鲶鲷鲸鲹鲺鲻鲼鲽鲾鲿鳀鳁鳂鳃鳄鳅鳆鳇鳈鳉鳊鳋鳌鳍鳎鳏鳐鳑鳒鳓鳔鳕鳖鳗鳘鳙鳚鳛鳜鳝鳞鳟鳠鳡鳢鳣鳤鳥鳦鳧鳨鳩鳪鳫鳬鳭鳮鳯鳰鳱鳲鳳鳴鳵鳶鳷鳸鳹鳺鳻鳼鳽鳾鳿鴀鴁鴂鴃鴄鴅鴆鴇鴈鴉鴊鴋鴌鴍鴎鴏鴐鴑鴒鴓鴔鴕鴖鴗鴘鴙鴚鴛鴜鴝鴞鴟鴠鴡鴢鴣鴤鴥鴦鴧鴨鴩鴪鴫鴬鴭鴮鴯鴰鴱鴲鴳鴴鴵鴶鴷鴸鴹鴺鴻鴼鴽鴾鴿鵀鵁鵂鵃鵄鵅鵆鵇鵈鵉鵊鵋鵌鵍鵎鵏鵐鵑鵒鵓鵔鵕鵖鵗鵘鵙鵚鵛鵜鵝鵞鵟鵠鵡鵢鵣鵤鵥鵦鵧鵨鵩鵪鵫鵬鵭鵮鵯鵰鵱鵲鵳鵴鵵鵶鵷鵸鵹鵺鵻鵼鵽鵾鵿鶀鶁鶂鶃鶄鶅鶆鶇鶈鶉鶊鶋鶌鶍鶎鶏鶐鶑鶒鶓鶔鶕鶖鶗鶘鶙鶚鶛鶜鶝鶞鶟鶠鶡鶢鶣鶤鶥鶦鶧鶨鶩鶪鶫鶬鶭鶮鶯鶰鶱鶲鶳鶴鶵鶶鶷鶸鶹鶺鶻鶼鶽鶾鶿鷀鷁鷂鷃鷄鷅鷆鷇鷈鷉鷊鷋鷌鷍鷎鷏鷐鷑鷒鷓鷔鷕鷖鷗鷘鷙鷚鷛鷜鷝鷞鷟鷠鷡鷢鷣鷤鷥鷦鷧鷨鷩鷪鷫鷬鷭鷮鷯鷰鷱鷲鷳鷴鷵鷶鷷鷸鷹鷺鷻鷼鷽鷾鷿鸀鸁鸂鸃鸄鸅鸆鸇鸈鸉鸊鸋鸌鸍鸎鸏鸐鸑鸒鸓鸔鸕鸖鸗鸘鸙鸚鸛鸜鸝鸞鸟鸠鸡鸢鸣鸤鸥鸦鸧鸨鸩鸪鸫鸬鸭鸮鸯鸰鸱鸲鸳鸴鸵鸶鸷鸸鸹鸺鸻鸼鸽鸾鸿鹀鹁鹂鹃鹄鹅鹆鹇鹈鹉鹊鹋鹌鹍鹎鹏鹐鹑鹒鹓鹔鹕鹖鹗鹘鹙鹚鹛鹜鹝鹞鹟鹠鹡鹢鹣鹤鹥鹦鹧鹨鹩鹪鹫鹬鹭鹮鹯鹰鹱鹲鹳鹴鹵鹶鹷鹸鹹鹺鹻鹼鹽鹾鹿麀麁麂麃麄麅麆麇麈麉麊麋麌麍麎麏麐麑麒麓麔麕麖麗麘麙麚麛麜麝麞麟麠麡麢麣麤麥麦麧麨麩麪麫麬麭麮麯麰麱麲麳麴麵麶麷麸麹麺麻麼麽麾麿黀黁黂黃黄黅黆黇黈黉黊黋黌黍黎黏黐黑黒黓黔黕黖黗默黙黚黛黜黝點黟黠黡黢黣黤黥黦黧黨黩黪黫黬黭黮黯黰黱黲黳黴黵黶黷黸黹黺黻黼黽黾黿鼀鼁鼂鼃鼄鼅鼆鼇鼈鼉鼊鼋鼌鼍鼎鼏鼐鼑鼒鼓鼔鼕鼖鼗鼘鼙鼚鼛鼜鼝鼞鼟鼠鼡鼢鼣鼤鼥鼦鼧鼨鼩鼪鼫鼬鼭鼮鼯鼰鼱鼲鼳鼴鼵鼶鼷鼸鼹鼺鼻鼼鼽鼾鼿齀齁齂齃齄齅齆齇齈齉齊齋齌齍齎齏齐齑齒齓齔齕齖齗齘齙齚齛齜齝齞齟齠齡齢齣齤齥齦齧齨齩齪齫齬齭齮齯齰齱齲齳齴齵齶齷齸齹齺齻齼齽齾齿龀龁龂龃龄龅龆龇龈龉龊龋龌龍龎龏龐龑龒龓龔龕龖龗龘龙龚龛龜龝龞龟龠龡龢龣龤龥龦龧龨龩龪龫龬龭龮龯龰龱龲龳龴龵龶龷龸龹龺龻龼龽龾龿鿀鿁鿂鿃鿄鿅鿆鿇鿈鿉鿊鿋鿌鿍鿎鿏鿐鿑鿒鿓鿔鿕鿖鿗鿘鿙鿚鿛鿜鿝鿞鿟鿠鿡鿢鿣鿤鿥鿦鿧鿨鿩鿪鿫鿬鿭鿮鿯鿰鿱鿲鿳鿴鿵鿶鿷鿸鿹鿺鿻鿼鿽鿾鿿', ',') satisfies matches($s, '^(?:\p{IsCJKUnifiedIdeographs}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCJKUnifiedIdeographs}+)$')))
every $var in (1, 2, 3) satisfies $var eq 1 or $var eq 2 or $var eq 3
every $var in (true(), true(), true()) satisfies $var
every $var in (true(), true(), xs:hexBinary("FF")) satisfies $var
every $var in (true(), xs:hexBinary("FF"), true()) satisfies $var
every $var in (xs:hexBinary("FF"), true(), true()) satisfies $var
every $x as xs:string in ("cat","dog","rat"), $y as xs:integer in (3, 3, 3) satisfies fn:string-length($x) = $y
every $x as xs:string in ("cat","dog","rat") satisfies fn:string-length($x) = 3
every $x in (1, 1) satisfies $x + $x = 2
every $x in (1,2,3), $y in (4,5,6) satisfies $x * $y = 10
every $x in (1,2,3), $y in (4,5,6) satisfies $x + $y = 5
every $x in (1,2,3), $y in (4,5,6) satisfies $x - $y = 5
every $x in (1,2,3), $y in (4,5,6) satisfies $x div $y = 2
every $x in (1,2,3), $y in (4,5,6) satisfies $x idiv $y = 2
every $x in (1,2,3), $y in (4,5,6) satisfies fn:string($x) = fn:string($y)
every $x in (1,2,3), $y in (4,5,6) satisfies xs:decimal($x) = xs:decimal($y)
every $x in (1,2,3), $y in (4,5,6) satisfies xs:double($x) = xs:double($y)
every $x in (1,2,3), $y in (4,5,6) satisfies xs:float($x) = xs:float($y)
every $x in (1,2,3), $y in (4,5,6) satisfies xs:integer($x) = xs:integer($y)
every $x in (1, 2) satisfies $x + $x = 3
every $x in (1, 2) satisfies $x = 1 and ($x +1) = 2
every $x in (1, 2) satisfies $x = 1 or $x = 2
every $x in (1, 2) satisfies $x - 2 = 2
every $x in (1, 2) satisfies $x * 2 = 4
every $x in (1, 2) satisfies $x div 2 = 1
every $x in (1, 2) satisfies $x idiv 2 = 1
every $x in (1, 2) satisfies fn:avg(($x, 1)) = 1
every $x in (1, 2) satisfies fn:count(($x)) = 1
every $x in (1, 2) satisfies fn:not($x)
every $x in (1, 2) satisfies fn:string($x) = "1"
every $x in (1, 2) satisfies fn:string-length(xs:string($x)) = 1
every $x in (1, 2) satisfies fn:true()
every $x in ("1980-05-05T13:13:13Z", "1980-05-05T13:13:13Z"), $y in ("1980-05-05T13:13:13Z","1980-05-05T13:13:13Z") satisfies xs:dateTime($x) = xs:dateTime($y)
every $x in ("1985-07-05Z", "1985-07-05Z"), $y in ("1985-07-05Z","1985-07-05Z") satisfies xs:date($x) = xs:date($y)
every $x in (1 to 10)[. div 2 = 11] satisfies false()
every $x in (1 to 10)[. mod 2 = 0] satisfies true()
every $x in (2, 2) satisfies $x - 2 = 0
every $x in ("A","B","C") satisfies $x = "A"
every $x in ("true", "false"), $y in ("false","true") satisfies xs:boolean($x) = xs:boolean($y)
exactly-one( () )
exactly-one()
exactly-one(1, 2)
exactly-one( (1, 2, 3) )
(exactly-one('a'))
exactly-one("one") eq "one"
exactly-one(/works[1]/employee[12]) >> exactly-one(/works[1]/employee[12]/following::employee)
exactly-one(/works[1]/employee[12]) >> exactly-one(/works[1]/employee[12]/following-sibling::employee)
exactly-one(/works[1]/employee[12]/following::employee) << exactly-one(/works[1]/employee[12]/following::employee)
exactly-one(/works[1]/employee[12]/following::employee) >> exactly-one(/works[1]/employee[12]/following::employee)
exactly-one(/works[1]/employee[12]/following::employee) << exactly-one(/works[1]/employee[12]/overtime[1])
exactly-one(/works[1]/employee[12]/following::employee) is exactly-one(/works[1]/employee[12])
exactly-one(/works[1]/employee[12]/following-sibling::employee) << exactly-one(/works[1]/employee[12]/following-sibling::employee)
exactly-one(/works[1]/employee[12]/following-sibling::employee) >> exactly-one(/works[1]/employee[12]/following-sibling::employee)
exactly-one(/works[1]/employee[12]/following-sibling::employee) << exactly-one(/works[1]/employee[12]/overtime[1])
exactly-one(/works[1]/employee[12]/following-sibling::employee) is exactly-one(/works[1]/employee[12])
exactly-one(/works[1]/employee[12]/overtime/day[1]/following-sibling::day) << exactly-one(/works[1]/employee[13])
exactly-one(/works[1]/employee[13]) >> exactly-one(/works[1]/employee[12]/overtime[1]/day[1]/following::day)
exactly-one(/works[1]/employee[13]) >> exactly-one(/works[1]/employee[12]/overtime[1]/day[1]/following-sibling::day)
exactly-one(/works[1]/employee[13]) >> exactly-one(/works[1]/employee[12]/overtime[1]/day[2]/preceding::day)
exactly-one(/works[1]/employee[13]) >> exactly-one(/works[1]/employee[12]/preceding-sibling::employee[1])
exactly-one(/works[1]/employee[13]) >> exactly-one(/works[1]/employee[2]/preceding::employee)
exactly-one(/works[1]/employee[13]) >> exactly-one(/works[1]/employee[2]/preceding-sibling::employee)
exactly-one(/works[1]/employee[2]/preceding::employee) << exactly-one(/works[1])
exactly-one(/works[1]/employee[2]/preceding::employee) << exactly-one(/works[1]/employee[2])
exactly-one(/works[1]/employee[2]/preceding::employee) << exactly-one(/works[1]/employee[2]/preceding::employee)
exactly-one(/works[1]/employee[2]/preceding::employee) >> exactly-one(/works[1]/employee[2]/preceding::employee)
exactly-one(/works[1]/employee[2]/preceding::employee) is exactly-one(/works[1]/employee[2])
exactly-one(/works[1]/employee[2]/preceding-sibling::employee) << exactly-one(/works[1])
exactly-one(/works[1]/employee[2]/preceding-sibling::employee) << exactly-one(/works[1]/employee[2])
exactly-one(/works[1]/employee[2]/preceding-sibling::employee) << exactly-one(/works[1]/employee[2]/preceding-sibling::employee)
exactly-one(/works[1]/employee[2]/preceding-sibling::employee) >> exactly-one(/works[1]/employee[2]/preceding-sibling::employee)
exactly-one(/works[1]/employee[2]/preceding-sibling::employee) is exactly-one(/works[1]/employee[2])
exactly-one(/works/employee[12]/following::employee) is exactly-one(/works/employee[13])
exactly-one(/works/employee[12]/following-sibling::employee) is exactly-one(/works/employee[13])
exactly-one(/works/employee[1]/ancestor-or-self::works) << exactly-one(/works/employee[1])
exactly-one(/works/employee[1]/ancestor-or-self::works) << exactly-one(/works/employee[1]/ancestor-or-self::works)
exactly-one(/works/employee[1]/ancestor-or-self::works) >> exactly-one(/works/employee[1]/ancestor-or-self::works)
exactly-one(/works/employee[1]/ancestor-or-self::works) >> exactly-one(/works/employee[1]/hours)
exactly-one(/works/employee[1]/ancestor-or-self::works) is exactly-one(/works)
exactly-one(/works/employee[1]/ancestor-or-self::works) is exactly-one(/works/employee[1])
exactly-one(/works/employee[1]/ancestor::works) << exactly-one(/works/employee[1])
exactly-one(/works/employee[1]/ancestor::works) << exactly-one(/works/employee[1]/ancestor::works)
exactly-one(/works/employee[1]/ancestor::works) >> exactly-one(/works/employee[1]/ancestor::works)
exactly-one(/works/employee[1]/ancestor::works) >> exactly-one(/works/employee[1]/hours)
exactly-one(/works/employee[1]/ancestor::works) is exactly-one(/works)
exactly-one(/works/employee[1]/ancestor::works) is exactly-one(/works/employee[1])
exactly-one(/works/employee[1]) >> exactly-one(/works/employee[1]/ancestor-or-self::works)
exactly-one(/works/employee[1]) >> exactly-one(/works/employee[1]/ancestor::works)
exactly-one(/works/employee[2]/preceding::employee) is exactly-one(/works/employee[1])
exactly-one(/works/employee[2]/preceding-sibling::employee) is exactly-one(/works/employee[1])
"example.com/" cast as xs:anyURI eq xs:anyURI('example.com/')
() except ()
(exists( '' ))
(exists( () ))
exists()
exists((1))
exists(1)
exists(1, 2)
exists((1, 2, 3))
(exists( ('a', 'b', 'c') ))
(exists( ('a', 'b', 'c') ), exists( '' ), exists( () ), exists( false() ))
(exists( false() ))
exists(fn:function-name#1)
exists(fn:timezone-from-dateTime(fn:current-dateTime()))
exists(fn:timezone-from-dateTime(xs:dateTimeStamp("2011-07-28T12:34:56-08:00")))
exists(for $x in (1 to 10)[. mod 2 = 0] return "blah")
exists(for $x in (1 to 10)[. mod 2 = 0] return floor($x))
exists(for $x in (1 to 10)[. mod 2 = 0] return true())
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'anyURI'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'base64Binary'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'boolean'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'byte'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'date'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'dateTime'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'dateTimeStamp'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'dayTimeDuration'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'decimal'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'double'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'duration'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'ENTITIES'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'ENTITY'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'float'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'gDay'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'gMonth'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'gMonthDay'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'gYear'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'gYearMonth'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'hexBinary'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'ID'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'IDREF'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'IDREFS'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'int'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'integer'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'language'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'long'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'Name'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'NCName'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'negativeInteger'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'NMTOKEN'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'NMTOKENS'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'nonNegativeInteger'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'nonPositiveInteger'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'normalizedString'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'positiveInteger'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'QName'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'short'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'string'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'time'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'token'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'unsignedByte'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'unsignedInt'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'unsignedLong'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'unsignedShort'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'untypedAtomic'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'yearMonthDuration'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'abs'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'append'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'filter'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'flatten'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'fold-left'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'fold-right'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'for-each'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'for-each-pair'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'get'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'head'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'insert-before'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'join'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'put'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'remove'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'reverse'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'size'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'sort'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'subarray'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'subarray'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'tail'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'avg'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'boolean'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'ceiling'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'codepoint-equal'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'codepoints-to-string'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'compare'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'compare'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'concat'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'contains'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'contains'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'count'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'current-date'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'current-dateTime'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'current-time'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'data'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'data'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'dateTime'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'day-from-date'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'day-from-dateTime'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'days-from-duration'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'deep-equal'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'deep-equal'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'empty'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'encode-for-uri'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'ends-with'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'ends-with'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'exactly-one'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'exists'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'false'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'filter'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'floor'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'fold-left'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'fold-right'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'for-each'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'function-arity'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'function-lookup'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'function-name'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'has-children'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'has-children'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'head'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'hours-from-dateTime'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'hours-from-duration'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'hours-from-time'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'id'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'id'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'idref'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'idref'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'implicit-timezone'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'index-of'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'index-of'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'innermost'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'insert-before'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'iri-to-uri'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'last'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'local-name'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'local-name'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'local-name-from-QName'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'lower-case'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/map', 'contains'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/map', 'entry'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/map', 'for-each'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/map', 'get'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/map', 'keys'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/map', 'merge'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/map', 'merge'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/map', 'put'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/map', 'remove'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/map', 'size'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'matches'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'acos'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'asin'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'atan'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'atan2'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'cos'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'exp'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'exp10'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'log'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'log10'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'pi'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'pow'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'sin'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'sqrt'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'tan'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'max'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'max'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'min'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'min'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'minutes-from-dateTime'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'minutes-from-duration'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'minutes-from-time'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'month-from-date'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'month-from-dateTime'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'months-from-duration'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'name'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'name'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'namespace-uri'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'namespace-uri'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'namespace-uri-from-QName'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'node-name'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'node-name'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'normalize-space'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'normalize-space'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'not'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'number'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'number'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'one-or-more'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'outermost'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'parse-json'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'path'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'path'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'position'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'prefix-from-QName'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'QName'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'random-number-generator'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'remove'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'reverse'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'root'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'root'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'round'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'round'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'round-half-to-even'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'round-half-to-even'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'seconds-from-dateTime'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'seconds-from-duration'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'seconds-from-time'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'starts-with'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'starts-with'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'string'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'string'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'string-join'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'string-join'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'string-length'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'string-length'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'string-to-codepoints'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'subsequence'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'subsequence'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'substring'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'substring'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'substring-after'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'substring-before'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'sum'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'sum'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'tail'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'timezone-from-date'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'timezone-from-dateTime'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'timezone-from-time'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'tokenize'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'tokenize'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'tokenize'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'trace'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'translate'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'true'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'unordered'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'upper-case'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'year-from-date'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'year-from-dateTime'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'years-from-duration'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'zero-or-one'), 1))
exists(one-or-more(("one", 2)))
exists(Q{http://www.w3.org/2001/XMLSchema}anyURI#1)
exists(Q{http://www.w3.org/2001/XMLSchema}base64Binary#1)
exists(Q{http://www.w3.org/2001/XMLSchema}boolean#1)
exists(Q{http://www.w3.org/2001/XMLSchema}byte#1)
exists(Q{http://www.w3.org/2001/XMLSchema}date#1)
exists(Q{http://www.w3.org/2001/XMLSchema}dateTime#1)
exists(Q{http://www.w3.org/2001/XMLSchema}dayTimeDuration#1)
exists(Q{http://www.w3.org/2001/XMLSchema}decimal#1)
exists(Q{http://www.w3.org/2001/XMLSchema}double#1)
exists(Q{http://www.w3.org/2001/XMLSchema}duration#1)
exists(Q{http://www.w3.org/2001/XMLSchema}ENTITIES#1)
exists(Q{http://www.w3.org/2001/XMLSchema}ENTITY#1)
exists(Q{http://www.w3.org/2001/XMLSchema}float#1)
exists(Q{http://www.w3.org/2001/XMLSchema}gDay#1)
exists(Q{http://www.w3.org/2001/XMLSchema}gMonth#1)
exists(Q{http://www.w3.org/2001/XMLSchema}gMonthDay#1)
exists(Q{http://www.w3.org/2001/XMLSchema}gYear#1)
exists(Q{http://www.w3.org/2001/XMLSchema}gYearMonth#1)
exists(Q{http://www.w3.org/2001/XMLSchema}hexBinary#1)
exists(Q{http://www.w3.org/2001/XMLSchema}ID#1)
exists(Q{http://www.w3.org/2001/XMLSchema}IDREF#1)
exists(Q{http://www.w3.org/2001/XMLSchema}IDREFS#1)
exists(Q{http://www.w3.org/2001/XMLSchema}int#1)
exists(Q{http://www.w3.org/2001/XMLSchema}integer#1)
exists(Q{http://www.w3.org/2001/XMLSchema}language#1)
exists(Q{http://www.w3.org/2001/XMLSchema}long#1)
exists(Q{http://www.w3.org/2001/XMLSchema}Name#1)
exists(Q{http://www.w3.org/2001/XMLSchema}NCName#1)
exists(Q{http://www.w3.org/2001/XMLSchema}negativeInteger#1)
exists(Q{http://www.w3.org/2001/XMLSchema}NMTOKEN#1)
exists(Q{http://www.w3.org/2001/XMLSchema}NMTOKENS#1)
exists(Q{http://www.w3.org/2001/XMLSchema}nonNegativeInteger#1)
exists(Q{http://www.w3.org/2001/XMLSchema}nonPositiveInteger#1)
exists(Q{http://www.w3.org/2001/XMLSchema}normalizedString#1)
exists(Q{http://www.w3.org/2001/XMLSchema}positiveInteger#1)
exists(Q{http://www.w3.org/2001/XMLSchema}QName#1)
exists(Q{http://www.w3.org/2001/XMLSchema}short#1)
exists(Q{http://www.w3.org/2001/XMLSchema}string#1)
exists(Q{http://www.w3.org/2001/XMLSchema}time#1)
exists(Q{http://www.w3.org/2001/XMLSchema}token#1)
exists(Q{http://www.w3.org/2001/XMLSchema}unsignedByte#1)
exists(Q{http://www.w3.org/2001/XMLSchema}unsignedInt#1)
exists(Q{http://www.w3.org/2001/XMLSchema}unsignedLong#1)
exists(Q{http://www.w3.org/2001/XMLSchema}unsignedShort#1)
exists(Q{http://www.w3.org/2001/XMLSchema}untypedAtomic#1)
exists(Q{http://www.w3.org/2001/XMLSchema}yearMonthDuration#1)
exists(Q{http://www.w3.org/2005/xpath-functions}abs#1)
exists(Q{http://www.w3.org/2005/xpath-functions}avg#1)
exists(Q{http://www.w3.org/2005/xpath-functions}boolean#1)
exists(Q{http://www.w3.org/2005/xpath-functions}ceiling#1)
exists(Q{http://www.w3.org/2005/xpath-functions}codepoint-equal#2)
exists(Q{http://www.w3.org/2005/xpath-functions}codepoints-to-string#1)
exists(Q{http://www.w3.org/2005/xpath-functions}compare#2)
exists(Q{http://www.w3.org/2005/xpath-functions}compare#3)
exists(Q{http://www.w3.org/2005/xpath-functions}concat#3)
exists(Q{http://www.w3.org/2005/xpath-functions}contains#2)
exists(Q{http://www.w3.org/2005/xpath-functions}contains#3)
exists(Q{http://www.w3.org/2005/xpath-functions}count#1)
exists(Q{http://www.w3.org/2005/xpath-functions}current-date#0)
exists(Q{http://www.w3.org/2005/xpath-functions}current-dateTime#0)
exists(Q{http://www.w3.org/2005/xpath-functions}current-time#0)
exists(Q{http://www.w3.org/2005/xpath-functions}data#0)
exists(Q{http://www.w3.org/2005/xpath-functions}data#1)
exists(Q{http://www.w3.org/2005/xpath-functions}dateTime#2)
exists(Q{http://www.w3.org/2005/xpath-functions}day-from-date#1)
exists(Q{http://www.w3.org/2005/xpath-functions}day-from-dateTime#1)
exists(Q{http://www.w3.org/2005/xpath-functions}days-from-duration#1)
exists(Q{http://www.w3.org/2005/xpath-functions}deep-equal#2)
exists(Q{http://www.w3.org/2005/xpath-functions}deep-equal#3)
exists(Q{http://www.w3.org/2005/xpath-functions}empty#1)
exists(Q{http://www.w3.org/2005/xpath-functions}encode-for-uri#1)
exists(Q{http://www.w3.org/2005/xpath-functions}ends-with#2)
exists(Q{http://www.w3.org/2005/xpath-functions}ends-with#3)
exists(Q{http://www.w3.org/2005/xpath-functions}exactly-one#1)
exists(Q{http://www.w3.org/2005/xpath-functions}exists#1)
exists(Q{http://www.w3.org/2005/xpath-functions}false#0)
exists(Q{http://www.w3.org/2005/xpath-functions}filter#2)
exists(Q{http://www.w3.org/2005/xpath-functions}floor#1)
exists(Q{http://www.w3.org/2005/xpath-functions}fold-left#3)
exists(Q{http://www.w3.org/2005/xpath-functions}fold-right#3)
exists(Q{http://www.w3.org/2005/xpath-functions}for-each#2)
exists(Q{http://www.w3.org/2005/xpath-functions}function-arity#1)
exists(Q{http://www.w3.org/2005/xpath-functions}function-lookup#2)
exists(Q{http://www.w3.org/2005/xpath-functions}function-name#1)
exists(Q{http://www.w3.org/2005/xpath-functions}has-children#0)
exists(Q{http://www.w3.org/2005/xpath-functions}has-children#1)
exists(Q{http://www.w3.org/2005/xpath-functions}head#1)
exists(Q{http://www.w3.org/2005/xpath-functions}hours-from-dateTime#1)
exists(Q{http://www.w3.org/2005/xpath-functions}hours-from-duration#1)
exists(Q{http://www.w3.org/2005/xpath-functions}hours-from-time#1)
exists(Q{http://www.w3.org/2005/xpath-functions}id#1)
exists(Q{http://www.w3.org/2005/xpath-functions}id#2)
exists(Q{http://www.w3.org/2005/xpath-functions}idref#1)
exists(Q{http://www.w3.org/2005/xpath-functions}idref#2)
exists(Q{http://www.w3.org/2005/xpath-functions}implicit-timezone#0)
exists(Q{http://www.w3.org/2005/xpath-functions}index-of#2)
exists(Q{http://www.w3.org/2005/xpath-functions}index-of#3)
exists(Q{http://www.w3.org/2005/xpath-functions}innermost#1)
exists(Q{http://www.w3.org/2005/xpath-functions}insert-before#3)
exists(Q{http://www.w3.org/2005/xpath-functions}iri-to-uri#1)
exists(Q{http://www.w3.org/2005/xpath-functions}last#0)
exists(Q{http://www.w3.org/2005/xpath-functions}local-name#0)
exists(Q{http://www.w3.org/2005/xpath-functions}local-name#1)
exists(Q{http://www.w3.org/2005/xpath-functions}local-name-from-QName#1)
exists(Q{http://www.w3.org/2005/xpath-functions}lower-case#1)
exists(Q{http://www.w3.org/2005/xpath-functions}matches#2)
exists(Q{http://www.w3.org/2005/xpath-functions/math}acos#1)
exists(Q{http://www.w3.org/2005/xpath-functions/math}asin#1)
exists(Q{http://www.w3.org/2005/xpath-functions/math}atan#1)
exists(Q{http://www.w3.org/2005/xpath-functions/math}atan2#2)
exists(Q{http://www.w3.org/2005/xpath-functions/math}cos#1)
exists(Q{http://www.w3.org/2005/xpath-functions/math}exp#1)
exists(Q{http://www.w3.org/2005/xpath-functions/math}exp10#1)
exists(Q{http://www.w3.org/2005/xpath-functions/math}log#1)
exists(Q{http://www.w3.org/2005/xpath-functions/math}log10#1)
exists(Q{http://www.w3.org/2005/xpath-functions/math}pi#0)
exists(Q{http://www.w3.org/2005/xpath-functions/math}pow#2)
exists(Q{http://www.w3.org/2005/xpath-functions/math}sin#1)
exists(Q{http://www.w3.org/2005/xpath-functions/math}sqrt#1)
exists(Q{http://www.w3.org/2005/xpath-functions/math}tan#1)
exists(Q{http://www.w3.org/2005/xpath-functions}max#1)
exists(Q{http://www.w3.org/2005/xpath-functions}max#2)
exists(Q{http://www.w3.org/2005/xpath-functions}min#1)
exists(Q{http://www.w3.org/2005/xpath-functions}min#2)
exists(Q{http://www.w3.org/2005/xpath-functions}minutes-from-dateTime#1)
exists(Q{http://www.w3.org/2005/xpath-functions}minutes-from-duration#1)
exists(Q{http://www.w3.org/2005/xpath-functions}minutes-from-time#1)
exists(Q{http://www.w3.org/2005/xpath-functions}month-from-date#1)
exists(Q{http://www.w3.org/2005/xpath-functions}month-from-dateTime#1)
exists(Q{http://www.w3.org/2005/xpath-functions}months-from-duration#1)
exists(Q{http://www.w3.org/2005/xpath-functions}name#0)
exists(Q{http://www.w3.org/2005/xpath-functions}name#1)
exists(Q{http://www.w3.org/2005/xpath-functions}namespace-uri#0)
exists(Q{http://www.w3.org/2005/xpath-functions}namespace-uri#1)
exists(Q{http://www.w3.org/2005/xpath-functions}namespace-uri-from-QName#1)
exists(Q{http://www.w3.org/2005/xpath-functions}node-name#0)
exists(Q{http://www.w3.org/2005/xpath-functions}node-name#1)
exists(Q{http://www.w3.org/2005/xpath-functions}normalize-space#0)
exists(Q{http://www.w3.org/2005/xpath-functions}normalize-space#1)
exists(Q{http://www.w3.org/2005/xpath-functions}not#1)
exists(Q{http://www.w3.org/2005/xpath-functions}number#0)
exists(Q{http://www.w3.org/2005/xpath-functions}number#1)
exists(Q{http://www.w3.org/2005/xpath-functions}one-or-more#1)
exists(Q{http://www.w3.org/2005/xpath-functions}outermost#1)
exists(Q{http://www.w3.org/2005/xpath-functions}path#0)
exists(Q{http://www.w3.org/2005/xpath-functions}path#1)
exists(Q{http://www.w3.org/2005/xpath-functions}position#0)
exists(Q{http://www.w3.org/2005/xpath-functions}prefix-from-QName#1)
exists(Q{http://www.w3.org/2005/xpath-functions}QName#2)
exists(Q{http://www.w3.org/2005/xpath-functions}remove#2)
exists(Q{http://www.w3.org/2005/xpath-functions}reverse#1)
exists(Q{http://www.w3.org/2005/xpath-functions}root#0)
exists(Q{http://www.w3.org/2005/xpath-functions}root#1)
exists(Q{http://www.w3.org/2005/xpath-functions}round#1)
exists(Q{http://www.w3.org/2005/xpath-functions}round#2)
exists(Q{http://www.w3.org/2005/xpath-functions}round-half-to-even#1)
exists(Q{http://www.w3.org/2005/xpath-functions}round-half-to-even#2)
exists(Q{http://www.w3.org/2005/xpath-functions}seconds-from-dateTime#1)
exists(Q{http://www.w3.org/2005/xpath-functions}seconds-from-duration#1)
exists(Q{http://www.w3.org/2005/xpath-functions}seconds-from-time#1)
exists(Q{http://www.w3.org/2005/xpath-functions}starts-with#2)
exists(Q{http://www.w3.org/2005/xpath-functions}starts-with#3)
exists(Q{http://www.w3.org/2005/xpath-functions}string#0)
exists(Q{http://www.w3.org/2005/xpath-functions}string#1)
exists(Q{http://www.w3.org/2005/xpath-functions}string-join#1)
exists(Q{http://www.w3.org/2005/xpath-functions}string-join#2)
exists(Q{http://www.w3.org/2005/xpath-functions}string-length#0)
exists(Q{http://www.w3.org/2005/xpath-functions}string-length#1)
exists(Q{http://www.w3.org/2005/xpath-functions}string-to-codepoints#1)
exists(Q{http://www.w3.org/2005/xpath-functions}subsequence#2)
exists(Q{http://www.w3.org/2005/xpath-functions}subsequence#3)
exists(Q{http://www.w3.org/2005/xpath-functions}substring#2)
exists(Q{http://www.w3.org/2005/xpath-functions}substring#3)
exists(Q{http://www.w3.org/2005/xpath-functions}substring-after#2)
exists(Q{http://www.w3.org/2005/xpath-functions}substring-before#2)
exists(Q{http://www.w3.org/2005/xpath-functions}sum#1)
exists(Q{http://www.w3.org/2005/xpath-functions}sum#2)
exists(Q{http://www.w3.org/2005/xpath-functions}tail#1)
exists(Q{http://www.w3.org/2005/xpath-functions}timezone-from-date#1)
exists(Q{http://www.w3.org/2005/xpath-functions}timezone-from-dateTime#1)
exists(Q{http://www.w3.org/2005/xpath-functions}timezone-from-time#1)
exists(Q{http://www.w3.org/2005/xpath-functions}tokenize#1)
exists(Q{http://www.w3.org/2005/xpath-functions}tokenize#2)
exists(Q{http://www.w3.org/2005/xpath-functions}tokenize#3)
exists(Q{http://www.w3.org/2005/xpath-functions}trace#1)
exists(Q{http://www.w3.org/2005/xpath-functions}trace#2)
exists(Q{http://www.w3.org/2005/xpath-functions}translate#3)
exists(Q{http://www.w3.org/2005/xpath-functions}true#0)
exists(Q{http://www.w3.org/2005/xpath-functions}unordered#1)
exists(Q{http://www.w3.org/2005/xpath-functions}upper-case#1)
exists(Q{http://www.w3.org/2005/xpath-functions}year-from-date#1)
exists(Q{http://www.w3.org/2005/xpath-functions}year-from-dateTime#1)
exists(Q{http://www.w3.org/2005/xpath-functions}years-from-duration#1)
exists(Q{http://www.w3.org/2005/xpath-functions}zero-or-one#1)
exists(reverse((1)))
exists(reverse((1, 2, 3)))
exists(seconds-from-duration(implicit-timezone()))
exists(text {(1 to 10)[. mod 2 = 0]})
exists(timezone-from-date(current-date()))
exists(timezone-from-dateTime(current-dateTime()))
exists(timezone-from-time(current-time()))
exists(xs:double("+INF"))
exists(xs:float("+INF"))
exists(xs:hexBinary("aa"))
exists(xs:hexBinary("Ab08bcFFAA08b6"))
exists(xs:hexBinary("FF"))
<e xmlns=""/>
<e xmlns="{()}"/>
<e xmlns="{1}"/>/@xmlns
<e xmlns="content{()}"/>
<e xmlns="content{{ {'1'}"/>
<e xmlns:d="http://www.example.com/"/>, d:d
<e xmlns="{"http://example.com/"}"/>
<e xmlns="http://example.com/3">{namespace-uri-from-QName(node-name(<e/>)), namespace-uri-from-QName(node-name(element e2 {()}))}</e>
<e xmlns="http://example.com/"> <b xmlns=""> { attribute {QName("http://example.com/2", "p:attr")} {()} } </b> </e>
<e xmlns="http://example.com/"> {namespace-uri-from-QName(node-name(element anElement{"text"}))} </e>/string()
<e xmlns="http://{exa}mple.com/"/>/@xmlns
<e xmlns="http://www.example.com/A" xmlns:A="http://www.example.com/C"> <b xmlns:B="http://www.example.com/C" xmlns=""/> </e>/b
<e xmlns="http://www.example.com/"> <e xmlns="http://www.example.com/"/> </e>
<e xmlns:p="{"/>
<e xmlns:p="{()}"/>
<e xmlns:p="}"/>
<e xmlns:p="{content"/>
<e xmlns:p="}content"/>
<e xmlns:p="content{"/>
<e xmlns:p="content{()}"/>
<e xmlns:p="content}"/>
<e xmlns:p="content{{ {'1'}"/>
<e xmlns:p="content{content"/>
<e xmlns:p="content}content"/>
<e xmlns:p="{"http://example.com/"}"/>
<e xmlns:p="http://example.com"/>
<e xmlns:p="http://example.com/{{1}}"/>
<e xmlns:p="http://example.com/" p:attr1="value"> { attribute {QName("http://example.com/", "attr2")} {()} } </e>
<e xmlns:p="http://example.com/" p:attr=""> { attribute {QName("http://example.com/", "p:attr")} {()} } </e>
<e xmlns:p="http://www.example.com/"> <e xmlns:p="http://www.example.com/"/> </e>
<e xmlns:p="http://www.w3.org/2001/XMLSchema"> <b xmlns:p="http://www.w3.org/2001/XMLSchema"/> {p:integer(1)} </e>
<e xmlns:p="http://www.w3.org/2005/xpath-functions"> <b xmlns:p="http://www.w3.org/2001/XMLSchema"/> {fn:count(0)} </e>
<e xmlns:prefix="http://example.com/"> { xs:QName("prefix:localName") } </e>
<e xmlns="/www.example.com/{"/>/@xmlns
<e xmlns="/www.example.com/}"/>/@xmlns
<e xmlns:xml="http://www.w3.org/XML/1998/namespace"/>
<e xmlns:xml="http://www.w3.org/XML/1998/namespace" xmlns:xml="http://www.w3.org/XML/1998/namespace"/>
<e xmlns="" xmlns=""/>
<e xmlns="{xs:anyURI("http://www.example.com/")}"/>/@xmlns
<e xmlns="{xs:untypedAtomic("http://www.example.com/")}"/>/@xmlns
:f()
(false())
false(1)
false() = 5
false() and false()
false() and true()
'false' cast as xs:boolean eq false()
false() cast as xs:boolean eq false()
false() cast as xs:string eq "false"
false() cast as xs:untypedAtomic eq xs:untypedAtomic("false")
false() cast as xs:untypedAtomic instance of xs:untypedAtomic
false() eq false()
((((((((((((false() eq false()) eq false()) eq false()) eq false()) eq false()) eq false()) eq false()) eq false()) eq false()) eq false()) eq false()) eq false()) eq false()
false() instance of xs:anyAtomicType
false() instance of xs:boolean
false() le true()
false() lt true()
false() ne true()
false() or count((1, 2, 3, timezone-from-time(current-time()), 4))
false() or false()
false() or true()
false() != xs:anyURI("example.com/")
false() = xs:anyURI("example.com/")
false() != xs:string("false")
false() = xs:string("false")
false() <= xs:untypedAtomic("false")
false() = xs:untypedAtomic("false")
false() >= xs:untypedAtomic("false")
false() != xs:untypedAtomic("falseERR")
false() = xs:untypedAtomic("falseERR")
false() != xs:untypedAtomic("true")
false() < xs:untypedAtomic("true")
<f><c></f></c>
f:f:()
<figlist> { for $f in //figure return <figure> { $f/@* } { $f/title } </figure> } </figlist>
filter((12, 4, 46, 23, -8), function($x){$x gt 10})
filter(("apple", "pear", "apricot", "advocado", "orange", current-date()), ends-with(?, 'e'))
filter(("apple", "pear", "apricot", "advocado", "orange"), function($x){if(starts-with($x,'a')) then true() else ()})
filter( ("apple", "pear", "apricot", "advocado", "orange"), function($x){if(starts-with($x,'a')) then (true(), true()) else false()})
filter(("apple", "pear", "apricot", "advocado", "orange"), normalize-space#1)
filter(("apple", "pear", "apricot", "advocado", "orange"),starts-with(?, "a"))
"first second third"=>concat()
"first second third"=>concat(" fourth")
("first","second","third","fourth")=>head()
(floor( () ))
floor()
floor(0.0)
floor(0.000000001)
floor(0.000000001e0)
floor(0.0e0)
floor(-0.1)
floor(-0.1e0)
floor(10.5) eq 10
floor(-10.5) eq -11
floor(1, 2)
floor(-12345678.567890)
floor(-12345678.567890e0)
floor(-1234567891234567.2)
floor(-1234567891234567.2e0)
floor(12.5)
floor(12.5e0)
floor(12.9)
floor(12.9e0)
(floor#1, ceiling#1, round#1, abs#1)?1
(floor#1, ceiling#1, round#1, abs#1)[.?1 = 1]
(floor#1, ceiling#1, round#1, abs#1)[?1 = 1]
[floor#1, ceiling#1, round#1, abs#1]?2(1.3)
(floor(5))
(floor(-5.1))
(floor(5.1))
(floor(-5.7))
(floor(5.7))
(floor(5), floor(5.1), floor(5.7), floor(-5.1), floor(-5.7), floor( () ))
floor("a string")
floor(unordered((1 to 10)[. div 2 = 0]))
floor(xs:byte(.)) instance of xs:integer
floor(xs:double('-0'))
floor(xs:double('-INF'))
floor(xs:double('INF'))
floor(xs:double('NaN'))
floor(xs:float(0.000000001e0))
floor(xs:float(0.0e0))
floor(xs:float(-0.1e0))
floor(xs:float(-1234567.2e0))
floor(xs:float(-12345678.567890e0))
floor(xs:float(12.5e0))
floor(xs:float(12.9e0))
floor(xs:float(xs:float('-0')))
floor(xs:float(xs:float('-INF')))
floor(xs:float(xs:float('INF')))
floor(xs:float(xs:float('NaN')))
floor(xs:int(.)) instance of xs:integer
floor(xs:long(.)) instance of xs:integer
floor(xs:negativeInteger(.)) instance of xs:integer
floor(xs:nonNegativeInteger(.)) instance of xs:integer
floor(xs:nonPositiveInteger(.)) instance of xs:integer
floor(xs:positiveInteger(.)) instance of xs:integer
floor(xs:short(.)) instance of xs:integer
floor(xs:unsignedByte(.)) instance of xs:integer
floor(xs:unsignedInt(.)) instance of xs:integer
floor(xs:unsignedLong(.)) instance of xs:integer
floor(xs:unsignedShort(.)) instance of xs:integer
fn:abs(-10.5)
fn:abs(10.5)
fn:abs(1.1) instance of xs:decimal
fn:abs(1.1) instance of xs:integer
fn:abs(1e1) instance of xs:double
fn:abs(1e1) instance of xs:integer
fn:abs(fn:minutes-from-time(xs:time("23:20:00Z")))
fn:abs( fn:reverse( (1, xs:decimal(2.2), xs:float(3.3), xs:double(4.4)) )[2] )
fn:abs(xs:anyURI("www.examples.org"))
fn:abs(xs:boolean("0"))
fn:abs(xs:boolean("1"))
fn:abs(xs:boolean(fn:false()))
fn:abs(xs:boolean(fn:true()))
fn:abs(xs:byte(-4))
fn:abs(xs:byte(-4)) instance of xs:integer
fn:abs(xs:date("2002-10-09"))
fn:abs(xs:dateTime("2002-10-10T12:00:00-05:00"))
fn:abs(xs:decimal("-0"))
fn:abs(xs:decimal("0"))
fn:abs(xs:decimal("617375191608514839"))
fn:abs(xs:decimal("-999999999999999999"))
fn:abs(xs:decimal("999999999999999999"))
fn:abs(xs:decimal("-INF"))
fn:abs(xs:decimal("INF"))
fn:abs(xs:decimal("-NaN"))
fn:abs(xs:decimal("NaN"))
fn:abs(xs:double("-0"))
fn:abs(xs:double("0"))
fn:abs(xs:double("-1.7976931348623157E308"))
fn:abs(xs:double("1.7976931348623157E308"))
fn:abs(xs:double("-INF"))
fn:abs(xs:double("INF"))
fn:abs(xs:double("NaN"))
fn:abs(xs:float("-0"))
fn:abs(xs:float("0"))
fn:abs(xs:float(1)) instance of xs:double
fn:abs(xs:float(1)) instance of xs:float
fn:abs(xs:float("-3.4028235E38"))
fn:abs(xs:float("3.4028235E38"))
fn:abs(xs:float("-INF"))
fn:abs(xs:float("INF"))
fn:abs(xs:float("NaN"))
fn:abs(xs:int("-0"))
fn:abs(xs:int("0"))
fn:abs(xs:int("-1873914410"))
fn:abs(xs:int("2147483647"))
fn:abs(xs:int("-2147483648"))
fn:abs(xs:int(-4))
fn:abs(xs:int(-4)) instance of xs:integer
fn:abs(xs:integer("-0"))
fn:abs(xs:integer("0"))
fn:abs(xs:integer(1)) instance of xs:integer
fn:abs(xs:integer(-4))
fn:abs(xs:integer(-4)) instance of xs:integer
fn:abs(xs:integer("-INF"))
fn:abs(xs:integer("INF"))
fn:abs(xs:integer("-NaN"))
fn:abs(xs:integer("NaN"))
fn:abs(xs:int("-INF"))
fn:abs(xs:int("INF"))
fn:abs(xs:int("-NaN"))
fn:abs(xs:int("NaN"))
fn:abs(xs:long("-0"))
fn:abs(xs:long("0"))
fn:abs(xs:long(-4))
fn:abs(xs:long(-4)) instance of xs:integer
fn:abs(xs:long("-INF"))
fn:abs(xs:long("INF"))
fn:abs(xs:long("-NaN"))
fn:abs(xs:long("NaN"))
fn:abs(xs:negativeInteger("-0"))
fn:abs(xs:negativeInteger("0"))
fn:abs(xs:negativeInteger("-1"))
fn:abs(xs:negativeInteger("2"))
fn:abs(xs:negativeInteger(-4))
fn:abs(xs:negativeInteger(-4)) instance of xs:integer
fn:abs(xs:negativeInteger("-INF"))
fn:abs(xs:negativeInteger("INF"))
fn:abs(xs:negativeInteger("-NaN"))
fn:abs(xs:negativeInteger("NaN"))
fn:abs(xs:nonNegativeInteger("-0"))
fn:abs(xs:nonNegativeInteger("0"))
fn:abs(xs:nonNegativeInteger("-2"))
fn:abs(xs:nonNegativeInteger(4))
fn:abs(xs:nonNegativeInteger(4)) instance of xs:integer
fn:abs(xs:nonNegativeInteger("-INF"))
fn:abs(xs:nonNegativeInteger("INF"))
fn:abs(xs:nonNegativeInteger("-NaN"))
fn:abs(xs:nonNegativeInteger("NaN"))
fn:abs(xs:nonPositiveInteger("-0"))
fn:abs(xs:nonPositiveInteger("0"))
fn:abs(xs:nonPositiveInteger("2"))
fn:abs(xs:nonPositiveInteger(-4))
fn:abs(xs:nonPositiveInteger(-4)) instance of xs:integer
fn:abs(xs:nonPositiveInteger("-INF"))
fn:abs(xs:nonPositiveInteger("INF"))
fn:abs(xs:nonPositiveInteger("-NaN"))
fn:abs(xs:nonPositiveInteger("NaN"))
fn:abs(xs:positiveInteger("-0"))
fn:abs(xs:positiveInteger("0"))
fn:abs(xs:positiveInteger("1"))
fn:abs(xs:positiveInteger("-2"))
fn:abs(xs:positiveInteger(4))
fn:abs(xs:positiveInteger(4)) instance of xs:integer
fn:abs(xs:positiveInteger("-INF"))
fn:abs(xs:positiveInteger("INF"))
fn:abs(xs:positiveInteger("-NaN"))
fn:abs(xs:positiveInteger("NaN"))
fn:abs(xs:short("-0"))
fn:abs(xs:short("0"))
fn:abs(xs:short("32767"))
fn:abs(xs:short("-32768"))
fn:abs(xs:short(-4))
fn:abs(xs:short(-4)) instance of xs:integer
fn:abs(xs:short("-5324"))
fn:abs(xs:short("-INF"))
fn:abs(xs:short("INF"))
fn:abs(xs:short("-NaN"))
fn:abs(xs:short("NaN"))
fn:abs(xs:string("1"))
fn:abs(xs:string("hello"))
fn:abs(xs:time("13:20:00-05:00"))
fn:abs(xs:unsignedByte(4))
fn:abs(xs:unsignedByte(4)) instance of xs:integer
fn:abs(xs:unsignedInt(4))
fn:abs(xs:unsignedInt(4)) instance of xs:integer
fn:abs(xs:unsignedLong("-0"))
fn:abs(xs:unsignedLong("0"))
fn:abs(xs:unsignedLong(4))
fn:abs(xs:unsignedLong(4)) instance of xs:integer
fn:abs(xs:unsignedLong("-INF"))
fn:abs(xs:unsignedLong("INF"))
fn:abs(xs:unsignedLong("-NaN"))
fn:abs(xs:unsignedLong("NaN"))
fn:abs(xs:unsignedShort("-0"))
fn:abs(xs:unsignedShort("0"))
fn:abs(xs:unsignedShort(4))
fn:abs(xs:unsignedShort("44633"))
fn:abs(xs:unsignedShort(4)) instance of xs:integer
fn:abs(xs:unsignedShort("65535"))
fn:abs(xs:unsignedShort("-INF"))
fn:abs(xs:unsignedShort("INF"))
fn:abs(xs:unsignedShort("-NaN"))
fn:abs(xs:unsignedShort("NaN"))
fn:avg(())
fn:avg((1 to 5))
fn:avg( (3, 4, 5) )
fn:avg(( (3, 4, 5), xs:float('NaN') ))
fn:avg(("a","b","c"))
fn:avg(( ("a", "b", "c", true()) ))
fn:avg(( concat('hi',' all') ))
fn:avg(( (false(), xs:string("xyz"), (), (), "a" , "b")))
fn:avg(( fn:count("Hello") ))
fn:avg((fn:day-from-dateTime(xs:dateTime("1996-12-10T12:00:00Z")),fn:day-from-dateTime(xs:dateTime("2000-12-20T12:00:00Z"))))
fn:avg((fn:day-from-date(xs:date("1999-12-31Z")),fn:day-from-date(xs:date("1999-12-29Z"))))
fn:avg((fn:days-from-duration(xs:dayTimeDuration("P23DT10H")),fn:days-from-duration(xs:dayTimeDuration("P21DT10H"))))
fn:avg(( fn:empty("Hello") ))
fn:avg(( fn:empty("Hello")) or fn:boolean(fn:count("Hello")))
fn:avg((fn:hours-from-duration(xs:dayTimeDuration("P23DT10H")),fn:hours-from-duration(xs:dayTimeDuration("P21DT08H"))))
fn:avg((fn:minutes-from-duration(xs:dayTimeDuration("P23DT10H20M")),fn:minutes-from-duration(xs:dayTimeDuration("P21DT10H10M"))))
fn:avg((fn:minutes-from-time(xs:time("01:10:00Z")), fn:minutes-from-time(xs:time("01:20:00Z"))))
fn:avg((fn:month-from-dateTime(xs:dateTime("1996-12-31T12:00:00Z")),fn:month-from-dateTime(xs:dateTime("2000-10-31T12:00:00Z"))))
fn:avg((fn:months-from-duration(xs:yearMonthDuration("P23Y10M")),fn:months-from-duration(xs:yearMonthDuration("P21Y10M"))))
fn:avg((fn:seconds-from-dateTime(xs:dateTime("1999-05-31T13:30:10Z")), fn:seconds-from-dateTime(xs:dateTime("1999-05-31T13:30:15Z"))))
fn:avg((fn:seconds-from-duration(xs:dayTimeDuration("P23DT10H20M30S")),fn:seconds-from-duration(xs:dayTimeDuration("P21DT10H10M32S"))))
fn:avg((fn:seconds-from-time(xs:time("01:10:20Z")), fn:seconds-from-time(xs:time("01:20:30Z"))))
fn:avg(( fn:string-length("Hello") ))
fn:avg(fn:string-to-codepoints("A String"))
fn:avg((fn:year-from-dateTime(xs:dateTime("1996-12-31T12:00:00Z")),fn:year-from-dateTime(xs:dateTime("2000-12-31T12:00:00Z"))))
fn:avg((fn:years-from-duration(xs:yearMonthDuration("P23Y10M")),fn:years-from-duration(xs:yearMonthDuration("P21Y10M"))))
fn:avg(( (true(), xs:string("xyz"), (), (), "a" , "b")))
fn:avg(/works/employee[1])
fn:avg(( (xs:anyURI("www.example.com"), "a", (""), "b")))
fn:avg(( (xs:boolean("1"), xs:double("-INF"), "s")))
fn:avg(( (xs:boolean("false"), xs:string("xyz"), (), (), "a" , "b")))
fn:avg(( (xs:boolean("true"), xs:date("1993-03-31"), 4, "a")))
fn:avg(( (xs:date("1993-03-31"), xs:string("xyz"), (), (), "a" , "b")))
fn:avg(( (xs:dateTime("1972-12-31T00:00:00"), xs:boolean("false"), (), (" ")) ))
fn:avg((xs:dayTimeDuration("P1DT2H"), xs:dayTimeDuration("PT22H"), xs:yearMonthDuration("P1M")))
fn:avg((xs:dayTimeDuration("P9223372036854775807D"), xs:dayTimeDuration("P1D")))
fn:avg( ( ( xs:decimal("-1.000000000001"), xs:integer("-100"))))
fn:avg(( (xs:decimal("1.01"), xs:integer("12") )))
fn:avg(( (xs:decimal("1.01"), xs:integer("12"), xs:anyURI("www.example.com"))))
fn:avg((xs:decimal("617375191608514839")))
fn:avg(( (xs:decimal("617375191608514839"), "a", (), "3") ))
fn:avg((xs:decimal("617375191608514839"),xs:decimal("-999999999999999999")))
fn:avg((xs:decimal("79000000000000000000000000000"),                     xs:decimal("79000000000000000000000000000")))             eq 79000000000000000000000000000
fn:avg((xs:decimal("-999999999999999999")))
fn:avg((xs:decimal("999999999999999999")))
fn:avg(( (xs:decimal("-999999999999999999") , "a", (), "3") ))
fn:avg(( (xs:decimal("999999999999999999"), "a", (), "3") ))
fn:avg((xs:decimal("-999999999999999999"),xs:decimal("617375191608514839")))
fn:avg((xs:decimal("-999999999999999999"),xs:decimal("-999999999999999999")))
fn:avg((xs:decimal("-999999999999999999"),xs:decimal("999999999999999999")))
fn:avg((xs:decimal("999999999999999999"),xs:decimal("-999999999999999999")))
fn:avg((xs:double("0")))
fn:avg((xs:double("0"),xs:double("-1.7976931348623157E308"))) eq -8.9884656743115785E307
fn:avg(( (xs:double("1.34"), xs:float("INF"))))
fn:avg(( (xs:double("1.34"), xs:float("INF"), true())))
fn:avg((xs:double("-1.7976931348623157E150"),xs:double("-1.7976931348623157E150"))) eq -1.7976931348623157E150
fn:avg((xs:double("-1.7976931348623157E308")))
fn:avg((xs:double("1.7976931348623157E308")))
fn:avg((xs:double("-1.7976931348623157E308"),xs:double("0"))) eq -8.9884656743115785E307
fn:avg((xs:double("-1.7976931348623157E308"),xs:double("1.7976931348623157E308")))
fn:avg((xs:double("1.7976931348623157E308"),xs:double("-1.7976931348623157E308")))
fn:avg(( (xs:double("INF"), 2, 3)))
fn:avg((xs:float("0")))
fn:avg(( (xs:float("-0"), xs:decimal("-999999999999999999") , "a", (), "3") ))
fn:avg(( (xs:float("0"), xs:decimal("-999999999999999999") , "a", (), "3") ))
fn:avg(( (xs:float("-0"), xs:decimal("-999999999999999999") ))) eq xs:float("-4.9999999999999999E17")
fn:avg(( (xs:float("0"), xs:decimal("-999999999999999999") ))) eq xs:float("-4.9999999999999999E17")
fn:avg(( (xs:float("1.01"))))
fn:avg(( (xs:float("1.01"), xs:string("a"))))
fn:avg((xs:float("-3.4028235E38")))
fn:avg((xs:float("3.4028235E38")))
fn:avg(( (xs:float("-3.4028235E38"), xs:decimal("-999999999999999999") , "a", (), "3") ))
fn:avg(( (xs:float("3.4028235E38"), xs:decimal("-999999999999999999") , "a", (), "3") ))
fn:avg((xs:float("-3.4028235E38"),xs:float("-3.4028235E38")))
fn:avg((xs:float("-3.4028235E38"),xs:float("3.4028235E38")))
fn:avg((xs:float("3.4028235E38"),xs:float("-3.4028235E38")))
fn:avg(( (xs:float("-INF"), xs:decimal("2.34"))))
fn:avg(( (xs:float("-INF"), xs:decimal("2.34"), "abc")))
fn:avg(( (xs:float("INF"), xs:decimal("-999999999999999999") )))
fn:avg(( (xs:float("INF"), xs:decimal("-999999999999999999") , "a", (), "3") ))
fn:avg(( xs:float('INF'), xs:float('-INF')))
fn:avg((xs:float('INF'), xs:float('-INF')))
fn:avg(( (xs:float("NaN"), 100, (), 2)))
fn:avg(( (xs:float("NaN"), xs:decimal("-999999999999999999") )))
fn:avg(( (xs:float("NaN"), xs:decimal("-999999999999999999") , "a", (), "3") ))
fn:avg((xs:int("-1873914410")))
fn:avg((xs:int("-1873914410"),xs:int("-2147483648")))
fn:avg((xs:int("2147483647")))
fn:avg((xs:int("2147483647"),xs:int("-2147483648")))
fn:avg((xs:int("-2147483648")))
fn:avg((xs:int("-2147483648"),xs:int("-1873914410")))
fn:avg((xs:int("-2147483648"),xs:int("2147483647")))
fn:avg((xs:int("-2147483648"),xs:int("-2147483648")))
fn:avg( ( ( xs:integer("100"), xs:integer("-100"))))
fn:avg(( (xs:integer("100"), xs:string("abc"))))
fn:avg((xs:negativeInteger("-1")))
fn:avg((xs:nonNegativeInteger("0")))
fn:avg((xs:nonNegativeInteger("0"),xs:nonNegativeInteger("0")))
fn:avg((xs:nonPositiveInteger("0")))
fn:avg((xs:positiveInteger("1")))
fn:avg((xs:positiveInteger("1"),xs:positiveInteger("1")))
fn:avg((xs:short("32767")))
fn:avg((xs:short("32767"),xs:short("-32768")))
fn:avg((xs:short("-32768")))
fn:avg((xs:short("-32768"),xs:short("32767")))
fn:avg((xs:short("-32768"),xs:short("-32768")))
fn:avg((xs:short("-32768"),xs:short("-5324")))
fn:avg((xs:short("-5324")))
fn:avg((xs:short("-5324"),xs:short("-32768")))
fn:avg(( (xs:string("xyz"), (), (), "a" , "b") ))
fn:avg(( (xs:time("12:30:00"), xs:decimal("2.000003"), 2)))
fn:avg((xs:unsignedLong("0")))
fn:avg((xs:unsignedLong("0"),xs:unsignedLong("0")))
fn:avg((xs:unsignedShort("0")))
fn:avg((xs:unsignedShort("0"),xs:unsignedShort("0")))
fn:avg((xs:unsignedShort("0"),xs:unsignedShort("44633")))
fn:avg((xs:unsignedShort("0"),xs:unsignedShort("65535")))
fn:avg((xs:unsignedShort("44633")))
fn:avg((xs:unsignedShort("44633"),xs:unsignedShort("0")))
fn:avg((xs:unsignedShort("65535")))
fn:avg((xs:unsignedShort("65535"),xs:unsignedShort("0")))
fn:avg( (xs:yearMonthDuration('P1Y0M'), 1) )
fn:avg((xs:yearMonthDuration("P1Y1M"), xs:yearMonthDuration("P11M"), xs:dayTimeDuration("P1D")))
fn:avg((xs:yearMonthDuration("P20Y") , (3, 4, 5)))
fn:avg((xs:yearMonthDuration("P768614336404564650Y"), xs:yearMonthDuration("P1Y")))
fn:boolean("")
fn:boolean(())
fn:boolean([])
fn:boolean(0)
fn:boolean(-1)
fn:boolean(1)
fn:boolean( (1, 2) )
fn:boolean(('a'))
fn:boolean(("ab" || "cde"))
fn:boolean(count((1, 2, 3, timezone-from-time(current-time()), 4)))
fn:boolean(false())
fn:boolean(fn:codepoints-to-string( () ))
fn:boolean(fn:codepoints-to-string( 0 ))
fn:boolean(fn:codepoints-to-string( 65 ))
fn:boolean(fn:codepoints-to-string( 65 to 76 ))
fn:boolean(fn:codepoints-to-string( 999999999 ))
fn:boolean(fn:concat('', ''))
fn:boolean(fn:concat("ab","cde"))
fn:boolean(fn:lower-case("abcde"))
fn:boolean(fn:round-half-to-even(5, 1))
fn:boolean(fn:string(fn:timezone-from-date(xs:date("1970-01-02+10:00"))))
fn:boolean(fn:string(fn:timezone-from-time(xs:time("10:10:20Z"))))
fn:boolean(fn:string-length("abcde"))
fn:boolean(fn:string(xs:date("1962-03-12Z") - xs:date("1962-03-12Z")))
fn:boolean(fn:string(xs:dateTime("1962-03-12T10:09:09Z") - xs:dateTime("1961-02-01T20:10:10Z")))
fn:boolean(fn:string(xs:dayTimeDuration("P05DT09H08M") *2.0))
fn:boolean(fn:string(xs:dayTimeDuration("P05DT09H08M") div 2.0))
fn:boolean(fn:string(xs:dayTimeDuration("P05DT09H08M") + xs:dayTimeDuration("P03DT08H06M")))
fn:boolean(fn:string(xs:dayTimeDuration("P05DT09H08M") - xs:dayTimeDuration("P03DT08H06M")))
fn:boolean(fn:string(xs:time("13:00:00Z") - xs:time("10:00:00Z")))
fn:boolean(fn:string(xs:yearMonthDuration("P05Y08M") * 2.0))
fn:boolean(fn:string(xs:yearMonthDuration("P05Y08M") div 2.0))
fn:boolean(fn:string(xs:yearMonthDuration("P05Y08M") + xs:yearMonthDuration("P03Y06M")))
fn:boolean(fn:string(xs:yearMonthDuration("P05Y08M") - xs:yearMonthDuration("P03Y06M")))
fn:boolean(fn:substring('', 1, 1))
fn:boolean(fn:substring("ABC",1))
fn:boolean(fn:substring('five', 5, 1))
fn:boolean(fn:upper-case("abcde"))
fn:boolean(true())
fn:boolean(xs:anyURI("http://www.example.org/examples"))
fn:boolean( xs:date('2007-01-01') )
fn:boolean(xs:dateTime("1999-12-31T00:00:00"))
fn:boolean(xs:dayTimeDuration("P05DT09H08M") div xs:dayTimeDuration("P03DT08H06M"))
fn:boolean(xs:decimal('0'))
fn:boolean(xs:decimal('-1'))
fn:boolean(xs:decimal('1'))
fn:boolean(xs:decimal('-123456789.123456789123456789'))
fn:boolean(xs:decimal("617375191608514839"))
fn:boolean(xs:decimal("-999999999999999999"))
fn:boolean(xs:decimal("999999999999999999"))
fn:boolean(xs:decimal('9.99999999999999999999999999'))
fn:boolean(xs:double("0"))
fn:boolean(xs:double(0))
fn:boolean(xs:double('1'))
fn:boolean(xs:double(1))
fn:boolean(xs:double("-1.7976931348623157E308"))
fn:boolean(xs:double("1.7976931348623157E308"))
fn:boolean(xs:double('-INF'))
fn:boolean(xs:double('INF'))
fn:boolean(xs:double('NaN'))
fn:boolean(xs:float("0"))
fn:boolean(xs:float(0))
fn:boolean(xs:float(-1))
fn:boolean(xs:float(1))
fn:boolean(xs:float("-3.4028235E38"))
fn:boolean(xs:float("3.4028235E38"))
fn:boolean(xs:float('-INF'))
fn:boolean(xs:float('INF'))
fn:boolean(xs:float('NaN'))
fn:boolean(xs:int('0'))
fn:boolean(xs:int('-1'))
fn:boolean(xs:int('1'))
fn:boolean(xs:int("-1873914410"))
fn:boolean(xs:int("2147483647"))
fn:boolean(xs:int('2147483647'))
fn:boolean(xs:int("-2147483648"))
fn:boolean(xs:int('-2147483648'))
fn:boolean(xs:integer('0'))
fn:boolean(xs:integer('-1'))
fn:boolean(xs:integer('1'))
fn:boolean(xs:long('0'))
fn:boolean(xs:long('-1'))
fn:boolean(xs:long('1'))
fn:boolean(xs:negativeInteger("-1"))
fn:boolean(xs:negativeInteger('-1'))
fn:boolean(xs:nonNegativeInteger("0"))
fn:boolean(xs:nonPositiveInteger("0"))
fn:boolean(xs:nonPositiveInteger('0'))
fn:boolean(xs:nonPositiveInteger('-1'))
fn:boolean(xs:positiveInteger("1"))
fn:boolean(xs:positiveInteger('1'))
fn:boolean(xs:short("32767"))
fn:boolean(xs:short("-32768"))
fn:boolean(xs:short("-5324"))
fn:boolean(xs:string(""))
fn:boolean(xs:string('abc'))
fn:boolean(xs:unsignedLong("0"))
fn:boolean(xs:unsignedShort("0"))
fn:boolean(xs:unsignedShort("44633"))
fn:boolean(xs:unsignedShort("65535"))
fn:boolean(xs:yearMonthDuration("P05Y08M") div xs:yearMonthDuration("P03Y06M"))
fn:ceiling(-10.5)
fn:ceiling(10.5)
fn:ceiling(xs:decimal("617375191608514839"))
fn:ceiling(xs:decimal("-999999999999999999"))
fn:ceiling(xs:decimal("999999999999999999"))
fn:ceiling(xs:double("0"))
fn:ceiling(xs:double("-1.7976931348623157E308"))
fn:ceiling(xs:double("1.7976931348623157E308"))
fn:ceiling(xs:float("0"))
fn:ceiling(xs:float("-3.4028235E38"))
fn:ceiling(xs:float("3.4028235E38"))
fn:ceiling(xs:int("-1873914410"))
fn:ceiling(xs:int("2147483647"))
fn:ceiling(xs:int("-2147483648"))
fn:ceiling(xs:negativeInteger("-1"))
fn:ceiling(xs:nonNegativeInteger("0"))
fn:ceiling(xs:nonPositiveInteger("0"))
fn:ceiling(xs:positiveInteger("1"))
fn:ceiling(xs:short("32767"))
fn:ceiling(xs:short("-32768"))
fn:ceiling(xs:short("-5324"))
fn:ceiling(xs:unsignedLong("0"))
fn:ceiling(xs:unsignedShort("0"))
fn:ceiling(xs:unsignedShort("44633"))
fn:ceiling(xs:unsignedShort("65535"))
fn:codepoint-equal("", "")
fn:codepoint-equal("", ())
fn:codepoint-equal("","")
fn:codepoint-equal((), "")
fn:codepoint-equal((), ())
fn:codepoint-equal((),())
fn:codepoint-equal("a")
fn:codepoint-equal("a","a")
fn:codepoint-equal("aa","AA")
fn:codepoint-equal("aa","aa") and fn:codepoint-equal("aa","aa")
fn:codepoint-equal("aa","aa") and fn:false()
fn:codepoint-equal("aa","aa") and fn:true()
fn:codepoint-equal("aa","aa") or fn:codepoint-equal("aa","aa")
fn:codepoint-equal("aa","aa") or fn:false()
fn:codepoint-equal("aa","aa") or fn:true()
fn:codepoint-equal("aa",fn:lower-case("AA"))
fn:codepoint-equal("aa",fn:upper-case("aa"))
fn:codepoint-equal("aa",xs:integer(1))
fn:codepoint-equal("a","b")
fn:codepoint-equal("abc",())
fn:codepoint-equal("abcd", "abcd ")
fn:codepoint-equal("abcd", "abcd")
fn:codepoint-equal(fn:string(1),fn:string(1))
fn:codepoint-equal(fn:string("aa"),fn:string("aa"))
fn:codepoint-equal(xs:integer(1),xs:integer(1))
fn:codepoints-to-string(())
fn:codepoints-to-string(0)
fn:codepoints-to-string(10000000)
fn:codepoints-to-string((2309, 2358, 2378, 2325))
fn:codepoints-to-string((35, 42, 94, 36))
fn:codepoints-to-string(49)
fn:codepoints-to-string((49,97))
fn:codepoints-to-string( 55295 to 55297 )
fn:codepoints-to-string( 55296 to 57343 )
fn:codepoints-to-string( 65530 to 70000 )
fn:codepoints-to-string( 65535 to 70000 )
fn:codepoints-to-string( 65536 to 1114112 )
fn:codepoints-to-string((66, 65, 67, 72))
fn:codepoints-to-string(97)
fn:codepoints-to-string((99,111,100,101,112,111,105,110,116,115,45,116,111,45,115,116,114,105,110,103))
fn:codepoints-to-string(xs:integer(97))
fn:codepoints-to-string(xs:integer(fn:avg((65,32,83,116,114,105,110,103))))
fn:compare('abc', 'abc')
fn:concat("**","***")
fn:concat("%$","#@!")
fn:concat(01, 02, 03, 04, true())
fn:concat("abc","abc") and fn:concat("abc","abc")
fn:concat("abc","abc", fn:concat#3)
fn:concat("AB","CD")
fn:concat("abc","de")
fn:concat("ABCDE","abcde")
fn:concat('Ciao!',())
fn:concat("concat","concat")
fn:concat(fn:codepoints-to-string((49,97)),"1a")
fn:concat(fn:concat("zzz","zz"),"123")
fn:concat(fn:lower-case("abcde"), fn:lower-case("fghi"))
fn:concat(fn:prefix-from-QName(xs:QName("foo:bar")),":bar")
fn:concat(fn:string-length("abcde"), fn:string-length("fghi"))
fn:concat(fn:substring("ABC",1),"DEF")
fn:concat(fn:upper-case("abcde"), fn:upper-case("fghi"))
fn:concat(fn:upper-case("Abc"),fn:upper-case("DH"))
fn:concat('Ingratitude, ', 'thou ', 'marble-hearted', ' fiend!')
fn:concat('Thy ', (), 'old ', "groans", "", ' ring',                   ' yet', ' in', ' my', ' ancient',' ears.')
fn:concat('Thy ', (), 'old ', "groans", "", ' ring', ' yet', ' in', ' my', ' ancient',' ears.')
fn:concat('un', 'grateful')
fn:concat(xs:double("0"),xs:double("-1.7976931348623157E308"))
fn:concat(xs:double("-1.7976931348623157E308"),xs:double("0"))
fn:concat(xs:double("-1.7976931348623157E308"),xs:double("-1.7976931348623157E308"))
fn:concat(xs:double("-1.7976931348623157E308"),xs:double("1.7976931348623157E308"))
fn:concat(xs:double("1.7976931348623157E308"),xs:double("-1.7976931348623157E308"))
fn:concat(xs:float("0"),xs:float("-3.4028235E38"))
fn:concat(xs:float("-3.4028235E38"),xs:float("0"))
fn:concat(xs:float("-3.4028235E38"),xs:float("-3.4028235E38"))
fn:concat(xs:float("-3.4028235E38"),xs:float("3.4028235E38"))
fn:concat(xs:float("3.4028235E38"),xs:float("-3.4028235E38"))
fn:concat(xs:int("-1873914410"),xs:int("-2147483648"))
fn:concat(xs:int("2147483647"),xs:int("-2147483648"))
fn:concat(xs:int("-2147483648"),xs:int("-1873914410"))
fn:concat(xs:int("-2147483648"),xs:int("2147483647"))
fn:concat(xs:int("-2147483648"),xs:int("-2147483648"))
fn:concat(xs:nonNegativeInteger("0"),xs:nonNegativeInteger("0"))
fn:concat(xs:positiveInteger("1"),xs:positiveInteger("1"))
fn:concat(xs:short("32767"),xs:short("-32768"))
fn:concat(xs:short("-32768"),xs:short("32767"))
fn:concat(xs:short("-32768"),xs:short("-32768"))
fn:concat(xs:short("-32768"),xs:short("-5324"))
fn:concat(xs:short("-5324"),xs:short("-32768"))
fn:concat(xs:string(fn:false()),xs:string(fn:false()))
fn:concat(xs:string(fn:not("true")),xs:string(fn:not("true")))
fn:concat(xs:string(fn:true()),xs:string(fn:true()))
fn:concat(xs:unsignedLong("0"),xs:unsignedLong("0"))
fn:concat(xs:unsignedShort("0"),xs:unsignedShort("0"))
fn:concat(xs:unsignedShort("0"),xs:unsignedShort("44633"))
fn:concat(xs:unsignedShort("0"),xs:unsignedShort("65535"))
fn:concat(xs:unsignedShort("44633"),xs:unsignedShort("0"))
fn:concat(xs:unsignedShort("65535"),xs:unsignedShort("0"))
fn:contains ( "", ())
fn:contains("","")
fn:contains("",())
fn:contains((),"")
fn:contains("a","A")
fn:contains("A","a")
fn:contains(" ","AAAAABBBBB")
fn:contains("AAAAABBBBB"," ")
fn:contains("AAAAABBBBBCCCCC","BBBBB")
fn:contains("","A Character String")
fn:contains("A Character String","")
fn:contains("A Character String",())
fn:contains((),"A Character String")
fn:contains("A",xs:string("A"))
fn:contains(fn:prefix-from-QName(xs:QName("foo:bar")),"f")
fn:contains(fn:substring("ABCDEF",1),"DEF")
fn:contains ( "tattoo", "t")
fn:contains ( "tattoo", "ttt")
fn:contains(xs:string("A"),"A")
fn:contains(xs:string(fn:false()),xs:string(fn:false()))
fn:contains(xs:string(fn:not("true")),xs:string(fn:not("true")))
fn:contains(xs:string(fn:true()),xs:string(fn:true()))
fn:contains(xs:string("This is a characte"),xs:string("This is a characte"))
fn:count( / )
fn:count(("" || ""))
fn:count(/*)
fn:count(//*)
fn:count(//@*)
fn:count([])
fn:count(() << 100)
fn:count(() >> 100)
fn:count([1,2,3])
fn:count(((1,2,3,4,5,6,7,8,9,10,11)[fn:false()]))
fn:count((1, 2 to ()))
fn:count(15 to 10)
fn:count(1 to 10000000)
fn:count((1 to 5))
fn:count(.[(/) * 5])
fn:count(.[(/) < 5])
fn:count(.[/ * 5])
fn:count(.[/ < 5])
fn:count(.[/-5])
fn:count(.[5 * /])
fn:count(.[5</])
fn:count(.[/ < a])
fn:count(.[/<a/>])
fn:count(.[/<a div 3])
fn:count(//attribute::*)
fn:count(//attribute::mark)
fn:count(.[/ < /b])
fn:count(//center/*)
fn:count(//center/..)
fn:count(//center//*)
fn:count(//center//attribute::center-attr-2)
fn:count(//center//@center-attr-2)
fn:count(//center/@center-attr-3/descendant-or-self::node())
fn:count(//center/@center-attr-3/self::node())
fn:count(//center//child::*)
fn:count(//center/child::*)
fn:count(//center//child::node())
fn:count(//center/child::node())
fn:count(//center//child::south)
fn:count(//center/child::south-east)
fn:count(//center/descendant::*)
fn:count(//center/descendant::node())
fn:count(//center/descendant-or-self::*)
fn:count(//center/descendant-or-self::center)
fn:count(//center/descendant-or-self::node())
fn:count(//center/descendant-or-self::south)
fn:count(//center/descendant::south)
fn:count(//center//node())
fn:count(//center/node())
fn:count(//center/parent::*)
fn:count(//center/parent::near-north)
fn:count(//center/parent::node())
fn:count(//center/parent::nowhere)
fn:count(//center/self::*)
fn:count(//center/self::center)
fn:count(//center/self::node())
fn:count(//center//south)
fn:count(//center/south-east)
fn:count(//center/text()/descendant-or-self::node())
fn:count(//center/text()/self::node())
fn:count(//child::*)
fn:count(/child::*)
fn:count(/child::far-north)
fn:count(//child::node())
fn:count(/child::node())
fn:count(//child::south)
fn:count(/descendant::*)
fn:count(/descendant::node())
fn:count(/descendant-or-self::*)
fn:count(/descendant-or-self::node())
fn:count(/descendant-or-self::south)
fn:count(/descendant::south)
fn:count((<elem></elem>)/node())
fn:count((<elem/>)/node())
fn:count((<elem xmlns:foo="http://ns.example.com/uri"/>)/@*)
fn:count((<elem xmlns="http://ns.example.com/uri"/>)/@*)
fn:count(/far-north)
fn:count(/far-north/parent::*)
fn:count(/far-north/parent::node())
fn:count(fn:concat("",""))
fn:count(fn:dateTime((),()))
fn:count(fn:dateTime(xs:date("1999-12-31+10:00"), ()))
fn:count(fn:dateTime((), xs:time("23:00:00+10:00")))
fn:count(fn:day-from-date(()))
fn:count(fn:day-from-dateTime(()))
fn:count(fn:days-from-duration(()))
fn:count(fn:hours-from-dateTime(()))
fn:count(fn:hours-from-duration(()))
fn:count(fn:hours-from-time(()))
fn:count(fn:id("nomatching1 nomatching2", /IDS[1]))
fn:count(fn:id("nomatchingid", /IDS[1]))
fn:count(fn:idref("", /IDS[1]))
fn:count(fn:idref("nomatching1 nomatching2", /IDS[1]))
fn:count(fn:local-name-from-QName(fn:node-name(text {""})))
fn:count(fn:local-name-from-QName(fn:node-name(text {"a text value"})))
fn:count(fn:lower-case(""))
fn:count(fn:lower-case(()))
fn:count(fn:matches("()", "^bra"))
fn:count(fn:minutes-from-dateTime(()))
fn:count(fn:minutes-from-duration(()))
fn:count(fn:minutes-from-time(()))
fn:count(fn:month-from-date(()))
fn:count(fn:month-from-dateTime(()))
fn:count(fn:months-from-duration(()))
fn:count(fn:namespace-uri-from-QName(fn:node-name(attribute attributeName {"an attribute value"})))
fn:count(fn:namespace-uri-from-QName(fn:node-name(element elementName {})))
fn:count(fn:namespace-uri-from-QName(fn:node-name(processing-instruction piName {"Processing Instruction content"})))
fn:count(fn:namespace-uri-from-QName(fn:node-name(text {""})))
fn:count(fn:namespace-uri-from-QName(fn:node-name(text {"a text value"})))
fn:count(((fn:name(/works[1]/employee[1]),fn:name(/works[1]/employee[2]))))
fn:count(fn:node-name(()))
fn:count(fn:node-name(<!-- This a comment node -->))
fn:count(fn:node-name(/works[1]/employee[2]/child::text()[last()]))
fn:count(fn:prefix-from-QName(()))
fn:count(fn:prefix-from-QName(xs:QName("name")))
fn:count(fn:root(()))
fn:count(fn:seconds-from-dateTime(()))
fn:count(fn:seconds-from-duration(()))
fn:count(fn:seconds-from-time(()))
fn:count(fn:string-join("",""))
fn:count(fn:string-join((),""))
fn:count(fn:string-join((" "),"AAAAABBBBB"))
fn:count(fn:string-join("","A Character String"))
fn:count(fn:string-join((),"A Character String"))
fn:count(fn:string-join((), 'separator'))
fn:count(fn:string-to-codepoints("A String"))
fn:count(fn:substring("",0))
fn:count(fn:substring("12345", 0 div 0E0, 3))
fn:count(fn:substring("12345", 1, 0 div 0E0))
fn:count(fn:substring("12345", -1 div 0E0, 1 div 0E0))
fn:count(fn:substring("12345", 5, -3))
fn:count(fn:substring((), 1, 3))
fn:count(fn:timezone-from-date(()))
fn:count(fn:timezone-from-dateTime(()))
fn:count(fn:timezone-from-dateTime(xs:dateTime("2004-08-27T00:00:00")))
fn:count(fn:timezone-from-time(()))
fn:count(fn:timezone-from-time(xs:time("13:20:00")))
fn:count(fn:translate("","",""))
fn:count(fn:upper-case(""))
fn:count(fn:upper-case(()))
fn:count(fn:year-from-date(()))
fn:count(fn:year-from-dateTime(()))
fn:count(fn:years-from-duration(()))
fn:count(.[if (doclevel) then / else /*])
fn:count(.[/ instance of document-node(schema-element(x))])
fn:count((//integer[fn:false()]))
fn:count((//integer[fn:false() and fn:false()]))
fn:count((//integer[fn:false() or fn:false()]))
fn:count((//integer[fn:true()]))
fn:count(() is 100)
fn:count(.[let $doc := / return $doc/*])
fn:count(//@mark)
fn:count(//node())
fn:count(/node())
fn:count(//self::*)
fn:count(//self::node())
fn:count(/self::node())
fn:count(//south)
fn:count(//west//@*)
fn:count(//west/@*)
fn:count(//west//attribute::*)
fn:count(//west/attribute::*)
fn:count(//west//attribute::node())
fn:count(//west/attribute::node())
fn:count(//west/attribute::west-attr-2)
fn:count(//west/@west-attr-2)
fn:count((/works[1]/employee[12]/following::employee) except (/works[1]/employee[12]/following::employee))
fn:count((/works[1]/employee[12]/following-sibling::employee) except (/works[1]/employee[12]/following-sibling::employee))
fn:count((/works[1]/employee[12]/preceding::employee) except (/works[1]/employee[12]/preceding::employee))
fn:count((/works[1]/employee[12]/preceding-sibling::employee) except (/works[1]/employee[12]/preceding-sibling::employee))
fn:count((/works/employee[12]/overtime/day[ancestor-or-self::overtime]) except (/works/employee[12]/overtime/day[ancestor-or-self::overtime]))
fn:count((/works/employee[12]/overtime/day[ancestor::overtime]) except (/works/employee[12]/overtime/day[ancestor::overtime]))
fn:count(/works/employee[1]/ancestor::noSuchNode)
fn:count(/works/employee[1]/ancestor-or-self::noSuchNode)
fn:count(/works/employee[1]/following::noSuchNode)
fn:count(/works/employee[1]/following-sibling::noSuchNode)
fn:count(/works/employee[1]/preceding::noSuchNode)
fn:count(/works/employee[1]/preceding-sibling::noSuchNode)
fn:count(xs:dayTimeDuration("P13DT09H09M") * +0)
fn:count(xs:dayTimeDuration("P13DT09H09M") * -0)
fn:count((xs:decimal("617375191608514839")))
fn:count((xs:decimal("-999999999999999999")))
fn:count((xs:decimal("999999999999999999")))
fn:count((xs:double("0")))
fn:count((xs:double("-1.7976931348623157E308")))
fn:count((xs:double("1.7976931348623157E308")))
fn:count((xs:float("0")))
fn:count((xs:float("-3.4028235E38")))
fn:count((xs:float("3.4028235E38")))
fn:count((xs:int("-1873914410")))
fn:count((xs:int("2147483647")))
fn:count((xs:int("-2147483648")))
fn:count((xs:negativeInteger("-1")))
fn:count((xs:nonNegativeInteger("0")))
fn:count((xs:nonPositiveInteger("0")))
fn:count((xs:positiveInteger("1")))
fn:count((xs:short("32767")))
fn:count((xs:short("-32768")))
fn:count((xs:short("-5324")))
fn:count(((),(),())[xs:string(.)])
fn:count((xs:unsignedLong("0")))
fn:count((xs:unsignedShort("0")))
fn:count((xs:unsignedShort("44633")))
fn:count((xs:unsignedShort("65535")))
fn:count((xs:yearMonthDuration("P13Y09M") *+0))
fn:count((xs:yearMonthDuration("P13Y09M") *-0))
fn:current-date()
fn:current-date("Argument 1")
fn:current-date() - fn:current-date()
fn:current-date() gt xs:date('2010-01-01')
fn:current-dateTime()
fn:current-dateTime("Argument 1")
fn:current-dateTime() - fn:current-dateTime()
fn:current-time()
fn:current-time("Argument 1")
fn:current-time() castable as xs:Name
fn:current-time() castable as xs:NCName
fn:current-time() cast as xs:ENTITY
fn:current-time() cast as xs:ID
fn:current-time() cast as xs:IDREF
fn:current-time() cast as xs:Name
fn:current-time() cast as xs:NCName
fn:current-time() - fn:current-time()
fn:data(<!---->) = ""
fn:data([['A', 'B', 'C'], ['D', 'E'], []]?*?*)
fn:data([['A', 'B', 'C'], ['D', 'E'], []]?2)
fn:data([['A', 'B', 'C'], ['D', 'E'], []]?3)
fn:data(attribute attr {'a', element a {}, 'b'})
fn:data(comment {'a', element a {}, 'b'})
fn:data(<!--comment-->) = "comment"
fn:data(<elem>a<a/>b</elem>)
fn:data(element elem {'a', element a {}, 'b'})
fn:data(<?pi ?>) = ""
fn:data(<?pi content?>) = "content"
fn:data(processing-instruction pi {'a', element a {}, 'b'})
fn:data(text {'a', element a {}, 'b'})
fn:data((xs:decimal("617375191608514839")))
fn:data((xs:decimal("-999999999999999999")))
fn:data((xs:decimal("999999999999999999")))
fn:data((xs:double("0")))
fn:data((xs:double("-1.7976931348623157E308")))
fn:data((xs:double("1.7976931348623157E308")))
fn:data((xs:float("0")))
fn:data((xs:float("-3.4028235E38")))
fn:data((xs:float("3.4028235E38")))
fn:data((xs:int("-1873914410")))
fn:data((xs:int("2147483647")))
fn:data((xs:int("-2147483648")))
fn:data((xs:negativeInteger("-1")))
fn:data((xs:nonNegativeInteger("0")))
fn:data((xs:nonPositiveInteger("0")))
fn:data((xs:positiveInteger("1")))
fn:data((xs:short("32767")))
fn:data((xs:short("-32768")))
fn:data((xs:short("-5324")))
fn:data((xs:unsignedLong("0")))
fn:data((xs:unsignedShort("0")))
fn:data((xs:unsignedShort("44633")))
fn:data((xs:unsignedShort("65535")))
fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00"))
fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00")) eq fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00"))
fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00")) - fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("22:00:00+10:00"))
fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00")) ge fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00"))
fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00")) gt fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00"))
fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00")) le fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00"))
fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00")) lt fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00"))
fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00")) ne fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00"))
fn:dateTime(xs:date("1999-12-31"),                   xs:time("12:00:00"))
fn:dateTime(xs:date("1999-12-31"), xs:time("12:00:00"))
fn:dateTime(xs:date("1999-12-31"), xs:time("23:00:00Z"))
fn:dateTime(xs:date("1999-12-31"),                   xs:time("24:00:00"))
fn:dateTime(xs:date("1999-12-31"), xs:time("24:00:00"))
fn:dateTime(xs:date("1999-12-31Z"), xs:time("12:00:00+10:00"))
fn:dateTime(xs:date("1999-12-31Z"), xs:time("23:00:00"))
fn:dateTime(xs:date("1999-12-31Z"), xs:time("23:00:00Z"))
fn:day-from-date(fn:current-date())
fn:day-from-dateTime(fn:current-dateTime())
fn:day-from-dateTime(fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00")))
fn:day-from-dateTime(xs:dateTime("0001-05-31T23:20:00-05:00"))
fn:day-from-dateTime(xs:dateTime("1000-01-10T02:00:00Z")) div fn:day-from-dateTime(xs:dateTime("0050-01-05T10:00:00Z"))
fn:day-from-dateTime(xs:dateTime("1970-01-01T00:00:00Z"))
fn:day-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) eq fn:day-from-dateTime(xs:dateTime("1970-01-02T10:00:00Z"))
fn:day-from-dateTime(xs:dateTime("1970-01-02T02:00:00Z")) * fn:day-from-dateTime(xs:dateTime("0002-01-04T10:00:00Z"))
fn:day-from-dateTime(xs:dateTime("1970-01-02T10:00:00Z")) ne fn:day-from-dateTime(xs:dateTime("1970-02-02T10:00:00Z"))
fn:day-from-dateTime(xs:dateTime("1970-01-03T00:00:00Z")) + fn:day-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
-fn:day-from-dateTime(xs:dateTime("1970-01-03T10:00:00Z"))
fn:day-from-dateTime(xs:dateTime("1970-01-10T00:00:00Z")) - fn:day-from-dateTime(xs:dateTime("1969-01-01T10:00:00Z"))
fn:day-from-dateTime(xs:dateTime("1970-01-10T10:00:00Z")) idiv fn:day-from-dateTime(xs:dateTime("1970-01-10T02:00:00Z"))
fn:day-from-dateTime(xs:dateTime("1970-01-10T10:00:00Z")) mod fn:day-from-dateTime(xs:dateTime("1970-01-03T03:00:00Z"))
+fn:day-from-dateTime(xs:dateTime("1971-01-01T10:00:00Z"))
fn:day-from-dateTime(xs:dateTime("1971-01-03T10:00:00Z")) ge fn:day-from-dateTime(xs:dateTime("1970-01-03T10:00:00Z"))
fn:day-from-dateTime(xs:dateTime("1971-01-10T10:00:00Z")) ge fn:day-from-dateTime(xs:dateTime("1970-01-11T10:00:00Z"))
fn:day-from-dateTime(xs:dateTime("1996-04-07T01:40:52Z"))
fn:day-from-dateTime(xs:dateTime("1999-01-01T00:20:00-05:00"))
fn:day-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))
fn:day-from-dateTime(xs:dateTime("1999-12-31T20:00:00-05:00"))
fn:day-from-dateTime(xs:dateTime("2030-12-31T23:59:59Z"))
+fn:day-from-date(xs:date("1970-01-01Z"))
-fn:day-from-date(xs:date("1970-01-01Z"))
fn:day-from-date(xs:date("1970-01-01Z"))
fn:day-from-date(xs:date("1970-01-01Z")) + fn:day-from-date(xs:date("1970-01-01Z"))
fn:day-from-date(xs:date("1970-01-01Z")) - fn:day-from-date(xs:date("1970-01-01Z"))
fn:day-from-date(xs:date("1970-01-01Z")) le fn:day-from-date(xs:date("1970-01-02Z"))
fn:day-from-date(xs:date("1970-01-02Z")) div fn:day-from-date(xs:date("1970-01-01Z"))
fn:day-from-date(xs:date("1970-01-02Z")) eq fn:day-from-date(xs:date("1970-01-01Z"))
fn:day-from-date(xs:date("1970-01-02Z")) idiv fn:day-from-date(xs:date("1970-01-01Z"))
fn:day-from-date(xs:date("1970-01-02Z")) mod fn:day-from-date(xs:date("1970-01-01Z"))
fn:day-from-date(xs:date("1970-01-03Z")) * fn:day-from-date(xs:date("0002-01-01Z"))
fn:day-from-date(xs:date("1970-01-03Z")) ge fn:day-from-date(xs:date("1970-01-01Z"))
fn:day-from-date(xs:date("1983-11-17Z"))
fn:day-from-date(xs:date("1999-05-31-05:00"))
fn:day-from-date(xs:date("1999-05-31Z"))
fn:day-from-date(xs:date("1999-12-31Z")) le fn:day-from-date(xs:date("1999-12-31Z"))
fn:day-from-date(xs:date("1999-12-31Z")) lt fn:day-from-date(xs:date("1999-12-31Z"))
fn:day-from-date(xs:date("2000-01-01+05:00"))
fn:day-from-date(xs:date("2030-12-31Z"))
fn:days-from-duration(xs:dayTimeDuration("P01DT01H"))
fn:days-from-duration(xs:dayTimeDuration("P0DT0H0M0S"))
fn:days-from-duration(xs:dayTimeDuration("P10DT10H")) mod fn:days-from-duration(xs:dayTimeDuration("P03DT03H"))
fn:days-from-duration(xs:dayTimeDuration("P15DT11H59M59S"))
-fn:days-from-duration(xs:dayTimeDuration("P20DT03H"))
fn:days-from-duration(xs:dayTimeDuration("P20DT03H")) le fn:days-from-duration(xs:dayTimeDuration("P21DT15H"))
fn:days-from-duration(xs:dayTimeDuration("P20DT09H")) * fn:days-from-duration(xs:dayTimeDuration("P03DT10H"))
fn:days-from-duration(xs:dayTimeDuration("P20DT10H")) div fn:days-from-duration(xs:dayTimeDuration("P05DT05H"))
fn:days-from-duration(xs:dayTimeDuration("P20DT20H")) lt fn:days-from-duration(xs:dayTimeDuration("P03DT02H"))
fn:days-from-duration(xs:dayTimeDuration("P21DT07H")) ge fn:days-from-duration(xs:dayTimeDuration("P20DT01H"))
+fn:days-from-duration(xs:dayTimeDuration("P21DT10H"))
fn:days-from-duration(xs:dayTimeDuration("P21DT10H")) + fn:days-from-duration(xs:dayTimeDuration("P22DT11H"))
fn:days-from-duration(xs:dayTimeDuration("P21DT10H")) le fn:days-from-duration(xs:dayTimeDuration("P22DT10H"))
fn:days-from-duration(xs:dayTimeDuration("P22DT10H")) eq fn:days-from-duration(xs:dayTimeDuration("P22DT09H"))
fn:days-from-duration(xs:dayTimeDuration("P23DT08H")) ne fn:days-from-duration(xs:dayTimeDuration("P12DT05H"))
fn:days-from-duration(xs:dayTimeDuration("P25DT10H")) idiv fn:days-from-duration(xs:dayTimeDuration("P05DT02H"))
fn:days-from-duration(xs:dayTimeDuration("P30DT10H")) - fn:days-from-duration(xs:dayTimeDuration("P10DT09H"))
fn:days-from-duration(xs:dayTimeDuration("P31DT23H59M59S"))
fn:days-from-duration(xs:dayTimeDuration("P3DT10H"))
fn:days-from-duration(xs:dayTimeDuration("P3DT55H"))
fn:days-from-duration(xs:duration("P1Y2M3DT10H30M"))
fn:days-from-duration(xs:yearMonthDuration('P1Y'))
fn:days-from-duration(xs:yearMonthDuration("P3Y5M"))
fn:deep-equal( ( ) , ())
fn:deep-equal( (()) , ())
fn:deep-equal( () , ())
fn:deep-equal([()], [()])
fn:deep-equal([[]], [[]])
fn:deep-equal([], [()])
fn:deep-equal([], [])
fn:deep-equal([], [1])
fn:deep-equal([1], 1)
fn:deep-equal( (1,2) , (1,2))
fn:deep-equal([1,2], [1,2])
fn:deep-equal( (1,2) , (2,1))
fn:deep-equal((1, 2, 3), [1, 2, 3])
fn:deep-equal([1, 2, 3], [1, 2, 3])
fn:deep-equal([<a>1</a>], [<a>1</a>])
fn:deep-equal(<a b="b" c="c" />, <a b="b" />)
fn:deep-equal([['a', 'b', 'c']], [['a', 'b', 'c']])
fn:deep-equal([['a', 'b', 'c']], [['A', 'B', 'C']])
fn:deep-equal(<a> {/bib/node()} </a>/node(), <b> {/bib/node()} </b>/node() )
fn:deep-equal(<a> {/bib/node(), /bib/node()} </a>/node(), <b> {/bib/node(), <difference/>, /bib/node()} </b>/node() )
fn:deep-equal(<a> {/node(), <diff x='1'/>, /node()} </a>/node(), <b> {/node(), <diff x='2'/>, /node()} </b>/node() )
fn:deep-equal(<a> {/node(), <diff x='1'/>, /node()} </a>/node(), <b> {/node(), <diff xx='1'/>, /node()} </b>/node() )
fn:deep-equal(<a> {/node(), /node()} </a>/node(), <b> {/node(), 'difference', /node()} </b>/node() )
fn:deep-equal(fn:innermost( / ), / )
fn:deep-equal( fn:innermost( ($doc1//node(), $doc2//node()) ),                            let $nodes := ($doc1//node(), $doc2//node())                            return $nodes except $nodes/ancestor::node() )
fn:deep-equal( fn:innermost( //comment() ),                            //comment() )
fn:deep-equal( fn:innermost( //* ),                             let $nodes := //*                            return $nodes except $nodes/ancestor::node() )
fn:deep-equal( fn:innermost( //node() ),                             let $nodes := //node()                            return $nodes except $nodes/ancestor::node() )
fn:deep-equal( fn:innermost( //processing-instruction() ),                            //processing-instruction() )
fn:deep-equal( fn:innermost( /root/descendant::node() ),                             let $nodes := /root/descendant::node()                            return $nodes except $nodes/ancestor::node() )
fn:deep-equal( fn:innermost( /root/level[1]/following-sibling::node() ),                             let $nodes := /root/level[1]/following-sibling::node()                            return $nodes except $nodes/ancestor::node() )
fn:deep-equal( fn:innermost( /root/level[1]/level[1]/ancestor::node() ),                             let $nodes := /root/level[1]/level[1]/ancestor::node()                            return $nodes except $nodes/ancestor::node() )
fn:deep-equal( fn:innermost( /root/level[1]/level[1]/following::node() ),                             let $nodes := /root/level[1]/level[1]/following::node()                            return $nodes except $nodes/ancestor::node() )
fn:deep-equal( fn:innermost( /root/level[1]/level[last()]/preceding::node() ),                             let $nodes := /root/level[1]/level[last()]/preceding::node()                            return $nodes except $nodes/ancestor::node() )
fn:deep-equal( fn:innermost( /root/level[1]/level[last()]/preceding-sibling::node() ),                             let $nodes := /root/level[1]/level[last()]/preceding-sibling::node()                            return $nodes except $nodes/ancestor::node() )
fn:deep-equal( fn:innermost( /root/node() ),                             let $nodes := /root/node()                            return $nodes except $nodes/ancestor::node() )
fn:deep-equal( fn:innermost( /root/node()/.. ),                             let $nodes := /root/node()/..                            return $nodes except $nodes/ancestor::node() )
fn:deep-equal( fn:innermost( //text() ),                            //text() )
fn:deep-equal(fn:outermost( / ), / )
fn:deep-equal( fn:outermost( ($doc1//node(), $doc2//node()) ),                            let $nodes := ($doc1//node(), $doc2//node())                            return $nodes except $nodes/descendant::node() )
fn:deep-equal( fn:outermost( //comment() ),                            //comment() )
fn:deep-equal( fn:outermost( //* ),                             let $nodes := //*                            return $nodes except $nodes/descendant::node() )
fn:deep-equal( fn:outermost( //node() ),                             let $nodes := //node()                            return $nodes except $nodes/descendant::node() )
fn:deep-equal( fn:outermost( //processing-instruction() ),                            //processing-instruction() )
fn:deep-equal( fn:outermost( /root/descendant::node() ),                             let $nodes := /root/descendant::node()                            return $nodes except $nodes/descendant::node() )
fn:deep-equal( fn:outermost( /root/level[1]/following-sibling::node() ),                             let $nodes := /root/level[1]/following-sibling::node()                            return $nodes except $nodes/descendant::node() )
fn:deep-equal( fn:outermost( /root/level[1]/level[1]/ancestor::node() ),                             let $nodes := /root/level[1]/level[1]/ancestor::node()                            return $nodes except $nodes/descendant::node() )
fn:deep-equal( fn:outermost( /root/level[1]/level[1]/following::node() ),                             let $nodes := /root/level[1]/level[1]/following::node()                            return $nodes except $nodes/descendant::node() )
fn:deep-equal( fn:outermost( /root/level[1]/level[last()]/preceding::node() ),                             let $nodes := /root/level[1]/level[last()]/preceding::node()                            return $nodes except $nodes/descendant::node() )
fn:deep-equal( fn:outermost( /root/level[1]/level[last()]/preceding-sibling::node() ),                             let $nodes := /root/level[1]/level[last()]/preceding-sibling::node()                            return $nodes except $nodes/descendant::node() )
fn:deep-equal( fn:outermost( /root/node() ),                             let $nodes := /root/node()                            return $nodes except $nodes/descendant::node() )
fn:deep-equal( fn:outermost( /root/node()/.. ),                             let $nodes := /root/node()/..                            return $nodes except $nodes/descendant::node() )
fn:deep-equal( fn:outermost( //text() ),                            //text() )
fn:deep-equal([map{1:1, 2:2}], [map{2:2, 1:1}])
fn:deep-equal(map{12:[1,2,3]}, map{12.0:[1.0, 2.0, 3.0]})
fn:deep-equal(map{12:[1,2,3]}, map{12:[3,2,1]})
fn:deep-equal(map{12:<a x='2' y='3'>23</a>}, map{12:<a y='3' x='2'>23</a>})
fn:deep-equal(map{12:<a x='2' y='3'>23</a>}, map{12:<a y='3' x='2' z='1'>23</a>})
fn:deep-equal(map{1:2}, map{})
fn:deep-equal(map{1:'a', 2:'b'}, map{2:'b', 1:'a'})
fn:deep-equal(map{1:"A"}, map:remove(map{1:"A", 2:"B"}, 2))
fn:deep-equal(map{1:true(), 2:false()}, map{2:false(), 1:true()})
fn:deep-equal(map{1:true()}, map{1.0e0:true()})
fn:deep-equal(map{1:true()}, map{1.0:true()})
fn:deep-equal([map{}], [map{}])
fn:deep-equal(map{}, map{})
fn:deep-equal(map{}, map{1:()})
fn:deep-equal(map{xs:double('NaN'):true()}, map{xs:double('NaN'):true()})
fn:deep-equal(map{xs:double('NaN'):true()}, map{xs:float('NaN'):true()})
fn:deep-equal(/works[1]/employee[12]/following::employee,/works[1]/employee[12]/following::employee)
fn:deep-equal(/works[1]/employee[12]/following-sibling::employee,/works[1]/employee[12]/following-sibling::employee)
fn:deep-equal(/works[1]/employee[12]/preceding::employee,/works[1]/employee[12]/preceding::employee)
fn:deep-equal(/works[1]/employee[12]/preceding-sibling::employee,/works[1]/employee[12]/preceding-sibling::employee)
fn:deep-equal(/works/employee[12]/overtime/ancestor-or-self::works,/works/employee[12]/overtime/ancestor-or-self::works)
fn:deep-equal(/works/employee[12]/overtime/ancestor::works,/works/employee[12]/overtime/ancestor::works)
fn:deep-equal( xs:anyURI("www.example.com") , "www.example.com")
fn:deep-equal( xs:anyURI("www.example.com") , xs:string("www.example.com"))
fn:deep-equal( xs:boolean("0") , xs:boolean("false"))
fn:deep-equal( xs:boolean("1") , xs:boolean("true"))
fn:deep-equal( xs:boolean("false") , false())
fn:deep-equal( xs:boolean("true") , true())
fn:deep-equal( xs:boolean("true") , xs:boolean("true"))
fn:deep-equal( xs:date("1993-03-31") , "1993-03-31")
fn:deep-equal( xs:date("1993-03-31") , xs:string("1993-03-31"))
fn:deep-equal(xs:dateTime("1972-12-31T00:00:00"), "1972-12-31T00:00:00")
fn:deep-equal( xs:decimal(1.01) , xs:double(1.01))
fn:deep-equal( xs:decimal(1.01) , xs:float(1.01))
fn:deep-equal((xs:decimal("617375191608514839")),(xs:decimal("-999999999999999999")))
fn:deep-equal((xs:decimal("-999999999999999999")),(xs:decimal("617375191608514839")))
fn:deep-equal((xs:decimal("-999999999999999999")),(xs:decimal("-999999999999999999")))
fn:deep-equal((xs:decimal("-999999999999999999")),(xs:decimal("999999999999999999")))
fn:deep-equal((xs:decimal("999999999999999999")),(xs:decimal("-999999999999999999")))
fn:deep-equal((xs:double("0")),(xs:double("-1.7976931348623157E308")))
fn:deep-equal((xs:double("-1.7976931348623157E308")),(xs:double("0")))
fn:deep-equal((xs:double("-1.7976931348623157E308")),(xs:double("-1.7976931348623157E308")))
fn:deep-equal((xs:double("-1.7976931348623157E308")),(xs:double("1.7976931348623157E308")))
fn:deep-equal((xs:double("1.7976931348623157E308")),(xs:double("-1.7976931348623157E308")))
fn:deep-equal((xs:float("0")),(xs:float("-3.4028235E38")))
fn:deep-equal((xs:float("-3.4028235E38")),(xs:float("0")))
fn:deep-equal((xs:float("-3.4028235E38")),(xs:float("-3.4028235E38")))
fn:deep-equal((xs:float("-3.4028235E38")),(xs:float("3.4028235E38")))
fn:deep-equal((xs:float("3.4028235E38")),(xs:float("-3.4028235E38")))
fn:deep-equal( xs:float("-INF") , xs:double("-INF"))
fn:deep-equal( xs:float("INF") , xs:double("INF"))
fn:deep-equal( xs:float("NaN") , xs:double("NaN"))
fn:deep-equal((xs:int("-1873914410")),(xs:int("-2147483648")))
fn:deep-equal((xs:int("2147483647")),(xs:int("-2147483648")))
fn:deep-equal((xs:int("-2147483648")),(xs:int("-1873914410")))
fn:deep-equal((xs:int("-2147483648")),(xs:int("2147483647")))
fn:deep-equal((xs:int("-2147483648")),(xs:int("-2147483648")))
fn:deep-equal( xs:integer(1) , xs:decimal(1.0))
fn:deep-equal( xs:integer(1) , xs:double(1.0))
fn:deep-equal( xs:integer(1) , xs:float(1.0))
fn:deep-equal( xs:integer(1) , xs:integer(-1))
fn:deep-equal((xs:nonNegativeInteger("0")),(xs:nonNegativeInteger("0")))
fn:deep-equal((xs:positiveInteger("1")),(xs:positiveInteger("1")))
fn:deep-equal((xs:short("32767")),(xs:short("-32768")))
fn:deep-equal((xs:short("-32768")),(xs:short("32767")))
fn:deep-equal((xs:short("-32768")),(xs:short("-32768")))
fn:deep-equal((xs:short("-32768")),(xs:short("-5324")))
fn:deep-equal((xs:short("-5324")),(xs:short("-32768")))
fn:deep-equal( xs:string("") , (""))
fn:deep-equal( xs:string("A") , "a")
fn:deep-equal( xs:string("A") , "A")
fn:deep-equal( xs:string("A") , ("A"))
fn:deep-equal(xs:string("abc"), xs:string("cba"))
fn:deep-equal(xs:time("12:30:00"), "12:30:00")
fn:deep-equal((xs:unsignedLong("0")),(xs:unsignedLong("0")))
fn:deep-equal((xs:unsignedShort("0")),(xs:unsignedShort("0")))
fn:deep-equal((xs:unsignedShort("0")),(xs:unsignedShort("44633")))
fn:deep-equal((xs:unsignedShort("0")),(xs:unsignedShort("65535")))
fn:deep-equal((xs:unsignedShort("44633")),(xs:unsignedShort("0")))
fn:deep-equal((xs:unsignedShort("65535")),(xs:unsignedShort("0")))
fn:empty("")
fn:empty([])
fn:empty((1,2,3)[10])
fn:empty(fn:remove(("hello", "world"), 1))
fn:empty(fn:string-to-codepoints(()))
fn:empty(fn:string-to-codepoints("A String"))
fn:empty(map{})
fn:empty((xs:decimal("617375191608514839")))
fn:empty((xs:decimal("-999999999999999999")))
fn:empty((xs:decimal("999999999999999999")))
fn:empty((xs:double("0")))
fn:empty((xs:double("-1.7976931348623157E308")))
fn:empty((xs:double("1.7976931348623157E308")))
fn:empty((xs:float("0")))
fn:empty((xs:float("-3.4028235E38")))
fn:empty((xs:float("3.4028235E38")))
fn:empty((xs:int("-1873914410")))
fn:empty((xs:int("2147483647")))
fn:empty((xs:int("-2147483648")))
fn:empty((xs:negativeInteger("-1")))
fn:empty((xs:nonNegativeInteger("0")))
fn:empty((xs:nonPositiveInteger("0")))
fn:empty((xs:positiveInteger("1")))
fn:empty((xs:short("32767")))
fn:empty((xs:short("-32768")))
fn:empty((xs:short("-5324")))
fn:empty((xs:unsignedLong("0")))
fn:empty((xs:unsignedShort("0")))
fn:empty((xs:unsignedShort("44633")))
fn:empty((xs:unsignedShort("65535")))
(fn:encode-for-uri("example"))
(fn:encode-for-uri("examples0123456789example"))
(fn:encode-for-uri("examples example"))
(fn:encode-for-uri("examples!example"))
(fn:encode-for-uri("examples#example"))
(fn:encode-for-uri("examples'example"))
(fn:encode-for-uri("examples(example"))
(fn:encode-for-uri("examples)example"))
(fn:encode-for-uri("examples*example"))
(fn:encode-for-uri("examples-example"))
(fn:encode-for-uri("examples.example"))
(fn:encode-for-uri("examples/example"))
(fn:encode-for-uri("examples_example"))
(fn:encode-for-uri("examples~example"))
(fn:encode-for-uri("http%20examples"))
(fn:encode-for-uri("http:examples"))
fn:encode-for-uri ("http://www.example.com/00/Weather/CA/Los%20Angeles#ocean")
fn:encode-for-uri("http://www.example.com/00/Weather/CA/Los%20Angeles#ocean")
fn:ends-with ((), ())
fn:ends-with("","")
fn:ends-with("",())
fn:ends-with((),"")
fn:ends-with("a","A")
fn:ends-with("A","a")
fn:ends-with(" ","AAAAABBBBB")
fn:ends-with("AAAAABBBBB"," ")
fn:ends-with("AAAAABBBBBCCCCC","BBBBB")
fn:ends-with("","A Character String")
fn:ends-with("A Character String","")
fn:ends-with("A Character String",())
fn:ends-with((),"A Character String")
fn:ends-with("A",xs:string("A"))
fn:ends-with(fn:prefix-from-QName(xs:QName("foo:bar")),"f")
fn:ends-with("Query","ry") eq xs:boolean("false")
fn:ends-with ( "tattoo", "atto")
fn:ends-with ( "tattoo", "tattoo")
fn:ends-with(xs:string("A"),"A")
fn:ends-with(xs:string("This is a characte"),xs:string("This is a characte"))
fn:error(fn:QName('http://www.example.com/HR', 'myerr:toohighsal'),                   'Does not apply because salary is too high')
fn:escape-uri("http:/example.com/")
fn:exactly-one((1,2))
fn:exactly-one(xs:double("0"))
fn:exactly-one(xs:double("-1.7976931348623157E308"))
fn:exactly-one(xs:double("1.7976931348623157E308"))
fn:exactly-one(xs:float("0"))
fn:exactly-one(xs:float("-3.4028235E38"))
fn:exactly-one(xs:float("3.4028235E38"))
fn:exactly-one(xs:int("-1873914410"))
fn:exactly-one(xs:int("2147483647"))
fn:exactly-one(xs:int("-2147483648"))
fn:exactly-one(xs:negativeInteger("-1"))
fn:exactly-one(xs:nonNegativeInteger("0"))
fn:exactly-one(xs:nonPositiveInteger("0"))
fn:exactly-one(xs:positiveInteger("1"))
fn:exactly-one(xs:short("32767"))
fn:exactly-one(xs:short("-32768"))
fn:exactly-one(xs:short("-5324"))
fn:exactly-one(xs:unsignedLong("0"))
fn:exactly-one(xs:unsignedShort("0"))
fn:exactly-one(xs:unsignedShort("44633"))
fn:exactly-one(xs:unsignedShort("65535"))
fn:exists("")
fn:exists([])
fn:exists( fn:filter#2 )
fn:exists( fn:has-children#0 )
fn:exists( fn:has-children#1 )
fn:exists( fn:innermost#1 )
fn:exists( fn:outermost#1 )
fn:exists(fn:remove(("hello"), 1))
fn:exists(fn:remove(("hello", "world"), 1))
fn:exists(fn:string-to-codepoints(()))
fn:exists(fn:string-to-codepoints("A String"))
fn:exists(map{})
fn:exists((xs:decimal("617375191608514839")))
fn:exists((xs:decimal("-999999999999999999")))
fn:exists((xs:decimal("999999999999999999")))
fn:exists((xs:double("0")))
fn:exists((xs:double("-1.7976931348623157E308")))
fn:exists((xs:double("1.7976931348623157E308")))
fn:exists( xs:error#1 )
fn:exists((xs:float("0")))
fn:exists((xs:float("-3.4028235E38")))
fn:exists((xs:float("3.4028235E38")))
fn:exists((xs:int("-1873914410")))
fn:exists((xs:int("2147483647")))
fn:exists((xs:int("-2147483648")))
fn:exists((xs:negativeInteger("-1")))
fn:exists((xs:nonNegativeInteger("0")))
fn:exists((xs:nonPositiveInteger("0")))
fn:exists((xs:positiveInteger("1")))
fn:exists((xs:short("32767")))
fn:exists((xs:short("-32768")))
fn:exists((xs:short("-5324")))
fn:exists((xs:unsignedLong("0")))
fn:exists((xs:unsignedShort("0")))
fn:exists((xs:unsignedShort("44633")))
fn:exists((xs:unsignedShort("65535")))
fn:false()
fn:false() and fn:false()
fn:false() eq fn:false()
(fn:false(),fn:false())
fn:false() != fn:false()
fn:false() < fn:false()
fn:false() <= fn:false()
fn:false() = fn:false()
fn:false() > fn:false()
fn:false() >= fn:false()
(fn:false(),fn:true(),fn:false())[fn:not(xs:boolean(.))]
fn:false() ge fn:false()
fn:false() gt fn:false()
fn:false() le fn:false()
fn:false() lt fn:false()
fn:false() ne fn:false()
fn:false() or fn:false()
fn:filter()
fn:filter#0
fn:filter#1
fn:filter( ("1", "2", "3"), function($arg as xs:integer) as xs:boolean { $arg eq 100 } )
fn:filter(1 to 10, function($a) {$a mod 2 = 0})
fn:filter( 1 to 10, function($arg) { if ($arg eq 100) then 0 else fn:true()})
fn:filter( 1 to 10, function($arg) { if ($arg eq 100) then () else fn:true()})
fn:filter( 1 to 10, function($arg) { if ($arg eq 100) then (fn:true(), fn:false()) else fn:true()})
fn:filter( 1 to 10, function($arg) { if ($arg eq 10) then 0 else fn:true()})
fn:filter( 1 to 10, function($arg) { if ($arg eq 10) then () else fn:true()})
fn:filter( 1 to 10, function($arg) { if ($arg eq 10) then (fn:true(), fn:false()) else fn:true()})
fn:filter( fn:boolean#1 )
fn:filter( (), fn:string#1 )
fn:filter( (), fn:true() )
fn:filter( (), function($a as item()) as xs:boolean? { () } )
fn:filter( (), function($a as item()) as xs:boolean* { fn:boolean($a), fn:boolean($a) } )
fn:floor(-10.5)
fn:floor(10.5)
fn:floor(xs:double("0"))
fn:floor(xs:double("-1.7976931348623157E308"))
fn:floor(xs:double("1.7976931348623157E308"))
fn:floor(xs:float("0"))
fn:floor(xs:float("-3.4028235E38"))
fn:floor(xs:float("3.4028235E38"))
fn:floor(xs:int("-1873914410"))
fn:floor(xs:int("2147483647"))
fn:floor(xs:int("-2147483648"))
fn:floor(xs:negativeInteger("-1"))
fn:floor(xs:nonNegativeInteger("0"))
fn:floor(xs:nonPositiveInteger("0"))
fn:floor(xs:positiveInteger("1"))
fn:floor(xs:short("32767"))
fn:floor(xs:short("-32768"))
fn:floor(xs:short("-5324"))
fn:floor(xs:unsignedLong("0"))
fn:floor(xs:unsignedShort("0"))
fn:floor(xs:unsignedShort("44633"))
fn:floor(xs:unsignedShort("65535"))
fn:fold-left(1 to 5, "$zero", fn:concat("$f(", ?, ", ", ?, ")"))
fn:fold-left(1 to 5, 0, function($a, $b) { $a + $b                   })
fn:fold-left(1 to 5, "", fn:concat(?, ".", ?))
fn:fold-left(1 to 5, (), function($a, $b) {($b,                   $a)})
fn:fold-left(1 to 5, map{}, function($map, $n) {map:put($map, $n, $n*2)})
fn:fold-left((2,3,5,7), 1, function($a, $b) { $a * $b                   })
fn:fold-left((true(), false(), false()), false(), function($a, $b) {                   $a and $b })
fn:fold-left((true(), false(), false()), false(), function($a, $b) {                   $a or $b })
fn:fold-right(1 to 5, "$zero", concat("$f(", ?, ", ", ?,                   ")"))
fn:fold-right(1 to 5, 0, function($a, $b) { $a + $b                   })
fn:fold-right(1 to 5, "", fn:concat(?, ".", ?))
fn:for-each(1 to 5, function($a) { $a * $a })
fn:for-each(("23", "29"), xs:int#1)
fn:for-each(("john", "jane"),                   fn:string-to-codepoints#1)
fn:for-each(("we", "th"),                 map{"su":"Sunday","mo":"Monday","tu":"Tuesday","we":"Wednesday","th":"Thursday","fr":"Friday","sa":"Saturday"}             )
fn:func-does-not-exist(1, 2, 3)
fn:function-arity(fn:substring#2)
fn:function-arity(function($node){name($node)})
fn:function-lookup()
fn:function-lookup#0
fn:function-lookup#1
fn:function-lookup( (), 1 )
fn:function-lookup#3
( fn:function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'node-name'),                                  if (current-date() eq xs:date('1900-01-01'))                                  then ()                                  else 1 ),               fn:function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'node-name'),                                  if (current-date() eq xs:date('1900-01-01'))                                  then 1                                  else () ) )
fn:function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'node-name'),                                if ( fn:current-dateTime() eq                                     fn:dateTime( fn:current-date(),                                                  fn:current-time() ))                                then ()                                else 1 )
( fn:function-lookup((if (current-date() eq xs:date('1900-01-01'))                                   then fn:QName('http://www.w3.org/2005/xpath-functions', 'node-name')                                   else ()), 1),               fn:function-lookup((if (current-date() eq xs:date('1900-01-01'))                                   then ()                                   else fn:QName('http://www.w3.org/2005/xpath-functions', 'node-name')), 1))
fn:function-lookup(xs:QName('fn:substring'), 2)('abcd',                   2)
fn:function-name( () )
fn:function-name()
fn:function-name#0
fn:function-name( 1 )
fn:function-name#2
fn:function-name( concat#99 )
fn:function-name( dateTime#2 )
fn:function-name( (fn:dateTime#2, fn:dateTime#2) )
fn:function-name( fn:dateTime#2, fn:dateTime#2 )
fn:function-name( fn:substring#2 )
fn:function-name(fn:substring#2)
fn:function-name( function($arg1, $arg2)                                { subsequence($arg1, $arg2, 1) } )
fn:function-name(function($node){count($node/*)})
fn:function-name( function($node){name($node)} )
( fn:function-name( if (current-date() eq xs:date('1900-01-01'))                                 then fn:dateTime#2                                 else 1 ),               fn:function-name( if (current-date() eq xs:date('1900-01-01'))                                 then 1                                 else fn:dateTime#2 ) )
fn:function-name( math:pow#2 )
/fn:has-children()
fn:has-children( (.,.) )
fn:has-children( / )
fn:has-children()
fn:has-children(.)
fn:has-children(1)
fn:has-children#2
fn:has-children(fn:concat#2)
fn:has-children( fn:contains#2, fn:contains#2 )
fn:has-children( /root )
fn:has-children( /root/@attribute )
fn:has-children( /root/comment() )
fn:has-children( /root/empty )
fn:has-children( /root/non-empty )
fn:has-children( /root/processing-instruction() )
fn:has-children( /root/text() )
fn:head(())
fn:head([1,2,3])
fn:head(1 to 5)
fn:head(("a", "b", "c"))
fn:hours-from-dateTime(fn:current-dateTime())
fn:hours-from-dateTime(fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00")))
fn:hours-from-dateTime(xs:dateTime("1970-01-01T00:00:00"))
fn:hours-from-dateTime(xs:dateTime("1970-01-01T00:00:00Z")) + fn:hours-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:hours-from-dateTime(xs:dateTime("1970-01-01T00:00:00Z")) - fn:hours-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:hours-from-dateTime(xs:dateTime("1970-01-01T02:00:00Z")) div fn:hours-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:hours-from-dateTime(xs:dateTime("1970-01-01T02:00:00Z")) * fn:hours-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
+fn:hours-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
-fn:hours-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:hours-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) eq fn:hours-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:hours-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) ge fn:hours-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:hours-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) idiv fn:hours-from-dateTime(xs:dateTime("1970-01-01T02:00:00Z"))
fn:hours-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) le fn:hours-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:hours-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) mod fn:hours-from-dateTime(xs:dateTime("1970-01-01T03:00:00Z"))
fn:hours-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) ne fn:hours-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:hours-from-dateTime(xs:dateTime("1996-04-07T01:40:52"))
fn:hours-from-dateTime(xs:dateTime("1999-05-31T00:20:00-05:00"))
fn:hours-from-dateTime(xs:dateTime("1999-05-31T08:20:00-05:00"))
fn:hours-from-dateTime(xs:dateTime("1999-05-31T23:20:00-05:00"))
fn:hours-from-dateTime(xs:dateTime("1999-12-31T12:00:00"))
fn:hours-from-dateTime(xs:dateTime("1999-12-31T21:20:00-05:00"))
fn:hours-from-dateTime(xs:dateTime("1999-12-31T24:00:00"))
fn:hours-from-dateTime(xs:dateTime("2030-12-31T23:59:59"))
fn:hours-from-duration(xs:dayTimeDuration("P01DT01H"))
fn:hours-from-duration(xs:dayTimeDuration("P0DT0H0M0S"))
fn:hours-from-duration(xs:dayTimeDuration("P10DT10H")) mod fn:hours-from-duration(xs:dayTimeDuration("P03DT02H"))
fn:hours-from-duration(xs:dayTimeDuration("P15DT11H59M59S"))
-fn:hours-from-duration(xs:dayTimeDuration("P20DT02H"))
fn:hours-from-duration(xs:dayTimeDuration("P20DT03H")) le fn:hours-from-duration(xs:dayTimeDuration("P21DT01H"))
fn:hours-from-duration(xs:dayTimeDuration("P20DT05H")) * fn:hours-from-duration(xs:dayTimeDuration("P03DT08H"))
fn:hours-from-duration(xs:dayTimeDuration("P20DT10H")) div fn:hours-from-duration(xs:dayTimeDuration("P05DT05H"))
fn:hours-from-duration(xs:dayTimeDuration("P21DT07H")) ge fn:hours-from-duration(xs:dayTimeDuration("P20DT08H"))
+fn:hours-from-duration(xs:dayTimeDuration("P21DT10H"))
fn:hours-from-duration(xs:dayTimeDuration("P21DT10H")) + fn:hours-from-duration(xs:dayTimeDuration("P22DT20H"))
fn:hours-from-duration(xs:dayTimeDuration("P22DT09H")) eq fn:hours-from-duration(xs:dayTimeDuration("P22DT09H"))
fn:hours-from-duration(xs:dayTimeDuration("P23DT07H")) ne fn:hours-from-duration(xs:dayTimeDuration("P12DT05H"))
fn:hours-from-duration(xs:dayTimeDuration("P25DT10H")) idiv fn:hours-from-duration(xs:dayTimeDuration("P05DT02H"))
fn:hours-from-duration(xs:dayTimeDuration("P30DT10H")) - fn:hours-from-duration(xs:dayTimeDuration("P10DT02H"))
fn:hours-from-duration(xs:dayTimeDuration("P31DT23H59M59S"))
fn:hours-from-duration(xs:dayTimeDuration("-P3DT10H"))
fn:hours-from-duration(xs:dayTimeDuration("P3DT10H"))
fn:hours-from-duration(xs:dayTimeDuration("P3DT12H32M12S"))
fn:hours-from-duration(xs:dayTimeDuration("PT123H"))
fn:hours-from-duration(xs:duration("P1Y2M3DT10H30M"))
fn:hours-from-duration(xs:yearMonthDuration('P1Y'))
fn:hours-from-time(fn:current-time())
fn:hours-from-time(xs:time("00:00:00Z"))
fn:hours-from-time(xs:time("00:20:00Z"))
fn:hours-from-time(xs:time("00:59:00Z"))
fn:hours-from-time(xs:time("01:23:00+05:00"))
fn:hours-from-time(xs:time("02:00:00Z")) * fn:hours-from-time(xs:time("10:00:00Z"))
fn:hours-from-time(xs:time("02:00:00Z")) + fn:hours-from-time(xs:time("10:00:00Z"))
fn:hours-from-time(xs:time("08:03:35Z"))
+fn:hours-from-time(xs:time("10:00:00Z"))
-fn:hours-from-time(xs:time("10:00:00Z"))
fn:hours-from-time(xs:time("10:00:00Z")) eq fn:hours-from-time(xs:time("10:00:00Z"))
fn:hours-from-time(xs:time("10:00:00Z")) - fn:hours-from-time(xs:time("09:00:00Z"))
fn:hours-from-time(xs:time("10:00:00Z")) ge fn:hours-from-time(xs:time("10:00:00Z"))
fn:hours-from-time(xs:time("10:00:00Z")) idiv fn:hours-from-time(xs:time("02:00:00Z"))
fn:hours-from-time(xs:time("10:00:00Z")) le fn:hours-from-time(xs:time("10:00:00Z"))
fn:hours-from-time(xs:time("10:00:00Z")) mod fn:hours-from-time(xs:time("03:00:00Z"))
fn:hours-from-time(xs:time("10:00:00Z")) ne fn:hours-from-time(xs:time("01:00:00Z"))
fn:hours-from-time(xs:time("11:23:00"))
fn:hours-from-time(xs:time("11:23:00Z"))
fn:hours-from-time(xs:time("21:23:00"))
fn:hours-from-time(xs:time("21:23:00Z"))
fn:hours-from-time(xs:time("22:00:00Z")) div fn:hours-from-time(xs:time("02:00:00Z"))
fn:hours-from-time(xs:time("23:20:00Z"))
fn:hours-from-time(xs:time("23:59:59Z"))
fn:hours-from-time(xs:time("24:00:00"))
fn:id("argument1", "A")
fn:id("argument 1", / ,"Argument 3")
fn:id('id', <a />)
fn:id("", /IDS[1])
fn:id("p1:id5", /IDS[1])
fn:idref("argument1",.)
fn:idref("argument1", "A")
fn:idref("argument 1", / ,"Argument 3")
fn:idref("nomatchingid", /IDS[1])
fn:implicit-timezone()
fn:implicit-timezone("Argument 1")
fn:implicit-timezone() * xs:double(2)
fn:index-of((),"")
fn:index-of ((10, 20, 30, 30, 20, 10), 20)
fn:index-of((10, 20, 30, 30, 20, 10), 20)
fn:index-of ((10, 20, 30, 40), 35)
fn:index-of((10, 20, 30, 40), 35)
fn:index-of(((1),(1), (2,1), (0,1)),1)
fn:index-of((1, (1,2,3)),1)
fn:index-of((1,2,3,4))
fn:index-of([1, [5, 6], [6, 7]], 6)
fn:index-of (("a", "sport", "and", "a", "pastime"), "a")
fn:index-of(("a", "sport", "and", "a", "pastime"),                   "a")
fn:index-of((/bib/book/publisher), "Addison-Wesley")
fn:index-of((/bib/book/publisher), /bib/book[1]/publisher[1]/text() cast as xs:string)
fn:index-of((),fn:exactly-one(xs:untypedAtomic('')))
fn:index-of(("sport"), "")
fn:index-of(("sport", "", "and", "", "", "pastime"), "")
fn:index-of((xs:decimal('9.99999999999999999999999999')), fn:exactly-one(xs:decimal('9.99999999999999999999999999')))
fn:index-of((xs:double('-INF')), fn:exactly-one(xs:double('-INF')))
fn:index-of((xs:double('INF')), fn:exactly-one(xs:double('INF')))
fn:index-of((xs:double('NaN')), fn:exactly-one(xs:double('NaN')))
fn:index-of((xs:float('NaN')), fn:exactly-one(xs:float('NaN')))
fn:index-of((xs:negativeInteger('-2'), xs:negativeInteger('-1')), fn:exactly-one(xs:negativeInteger('-1')))
fn:index-of((xs:positiveInteger('1'),xs:positiveInteger('2')), fn:exactly-one(xs:positiveInteger('2')))
fn:innermost( / )
fn:innermost( //* )
fn:innermost( //*/@* )
fn:innermost()
fn:innermost( ($doc1//node(), $doc2//node()) )
fn:innermost#0
fn:innermost( (), 1 )
fn:innermost( 1 )
fn:innermost#2
fn:innermost( //comment() )
fn:innermost( //comment() ) ! string()
fn:innermost( fn:dateTime#2 )
( fn:innermost( if (current-date() eq xs:date('1900-01-01'))                                  then .                                  else 1 ),               fn:innermost( if (current-date() eq xs:date('1900-01-01'))                                  then 1                                  else . ) )
( fn:innermost( if (current-date() eq xs:date('1900-01-01'))                                  then .                                  else fn:dateTime#2 ),               fn:innermost( if (current-date() eq xs:date('1900-01-01'))                                  then fn:dateTime#2                                  else . ) )
fn:innermost( //* ) ! local-name(.)
fn:innermost( //node() )
fn:innermost( //processing-instruction() )
fn:innermost( //processing-instruction() ) ! local-name()
fn:innermost( /root/descendant::node() )
fn:innermost( /root/level[1]/following-sibling::node() )
fn:innermost( /root/level[1]/level[1]/ancestor::node() )
fn:innermost( /root/level[1]/level[1]/following::node() )
fn:innermost( /root/level[1]/level[last()]/preceding::node() )
fn:innermost( /root/level[1]/level[last()]/preceding-sibling::node() )
fn:innermost( /root/node() )
fn:innermost( /root/node()/.. )
fn:innermost( //*/@* ) ! string()
fn:innermost( //text() )
fn:innermost( //text() ) ! string()
fn:insert-before( ("a", "b", "c"),0, ())
fn:insert-before( ("a", "b", "c"),1, "z")
fn:insert-before( ("a", "b", "c"),2, ())
fn:insert-before( ("a", "b", "c"),2, xs:anyURI("www.example.com"))
fn:insert-before( ("a", "b", "c"),2, xs:boolean("0"))
fn:insert-before( ("a", "b", "c"),2, xs:boolean("1"))
fn:insert-before( ("a", "b", "c"),2, xs:boolean("false"))
fn:insert-before( ("a", "b", "c"),2, xs:boolean("true"))
fn:insert-before( ("a", "b", "c"),2, xs:decimal("1.1"))
fn:insert-before( ("a", "b", "c"),2, xs:double("INF"))
fn:insert-before( ("a", "b", "c"),2, xs:double("NaN"))
fn:insert-before( ("a", "b", "c"),2, xs:float("-0"))
fn:insert-before( ("a", "b", "c"),2, xs:float("1.1"))
fn:insert-before( ("a", "b", "c"),2, xs:float("-INF"))
fn:insert-before( ("a", "b", "c"),2, xs:float("NaN"))
fn:insert-before( ("a", "b", "c"),2, xs:integer("100"))
fn:insert-before( ("a", "b", "c"),2, xs:string(" "))
fn:insert-before( ("a", "b", "c"),4, xs:date("1993-03-31"))
fn:insert-before( ("a", "b", "c"),4, xs:dateTime("1972-12-31T00:00:00"))
fn:insert-before( ("a", "b", "c"),4, xs:time("12:30:00"))
fn:iri-to-uri("example")
fn:iri-to-uri("example$example")
fn:iri-to-uri("example0123456789")
fn:iri-to-uri("example&amp;amp;example")
fn:iri-to-uri("example&amp;example")
fn:iri-to-uri("example example")
fn:iri-to-uri("example!example")
fn:iri-to-uri("example#example")
fn:iri-to-uri("example%example")
fn:iri-to-uri("example'example")
fn:iri-to-uri("example(example")
fn:iri-to-uri("example)example")
fn:iri-to-uri("example*example")
fn:iri-to-uri("example+example")
fn:iri-to-uri("example,example")
fn:iri-to-uri("example-example")
fn:iri-to-uri("example.example")
fn:iri-to-uri("example/example")
fn:iri-to-uri("example:example")
fn:iri-to-uri("example;example")
fn:iri-to-uri("example=example")
fn:iri-to-uri("example?example")
fn:iri-to-uri("example@example")
fn:iri-to-uri("example[example")
fn:iri-to-uri("example]example")
fn:iri-to-uri("example_example")
fn:iri-to-uri("example~example")
fn:iri-to-uri                   ("http://www.example.com/00/Weather/CA/Los%20Angeles#ocean")
fn:iri-to-uri ("http://www.example.com/~bébé")
fn:local-name-from-QName("")
fn:local-name-from-QName(((),()))
fn:local-name-from-QName(())
fn:local-name-from-QName()
fn:local-name-from-QName(fn:node-name(attribute attributeName {""}))
fn:local-name-from-QName(fn:node-name(attribute attributeName {"an attribute value"}))
fn:local-name-from-QName(fn:node-name(element elementName {}))
fn:local-name-from-QName(fn:node-name(element elementName { element achild {"some text"}}))
fn:local-name-from-QName(fn:node-name(<?format role="output" ?>))
fn:local-name-from-QName(fn:node-name(processing-instruction piName {"Processing Instruction content"}))
fn:local-name-from-QName(fn:node-name(<shoe size = "5"/>))
fn:local-name-from-QName(fn:node-name(/works[1]/employee[2]))
fn:local-name-from-QName(fn:QName("http://www.example.com/example",                   "person"))
fn:local-name-from-QName(fn:QName("http://www.example.com/QNameXSD", exactly-one(xs:string(data((/root/elemQN)[1])))))
fn:local-name-from-QName(fn:QName("http://www.example.com/QNameXSD", exactly-one(xs:string(/root[1]/@attrDerivQN))))
fn:local-name-from-QName(fn:QName("http://www.example.com/QNameXSD", exactly-one(xs:string(/root[1]/@attrDerivQN)))) instance of xs:NCName ?
fn:local-name-from-QName(fn:QName("http://www.example.com/QNameXSD", exactly-one(xs:string(/root[1]/@attrQN))))
fn:local-name-from-QName(fn:QName("http://www.example.com/QNameXSD", exactly-one(xs:string((/root/derivQN)[1]))))
fn:local-name-from-QName(fn:QName("http://www.example.com/QNameXSD", exactly-one(xs:string((/root/elemQN)[1]))))
fn:local-name-from-QName( if( false() ) then fn:QName("http://www.example.com/QNameXSD", exactly-one(xs:string((/root/elemQN)[1]))) else fn:QName("http://www.example.com/QNameXSD", exactly-one(xs:string((/root/@attrQN)[1]))) )
fn:local-name-from-QName( if( true() ) then fn:QName("http://www.example.com/QNameXSD", exactly-one(xs:string((/root/elemQN)[1]))) else fn:QName("http://www.example.com/QNameXSD", exactly-one(xs:string((/root/@attrQN)[1]))) )
fn:local-name-from-QName(node-name(/*))
fn:local-name-from-QName(node-name((//@*)[1]))
fn:local-name-from-QName(/root/elemQN)
fn:local-name-from-qname((/root/elemQN)[1])
fn:local-name-from-Qname((/root/elemQN)[1])
fn:localnamefromQName((/root/elemQN)[1])
fn:local-name-from-QName(xs:integer("100"))
fn:local-name-from-QName(xs:time("12:00:00Z"))
fn:lower-case("*****")
fn:lower-case("%$#@!")
fn:lower-case("12345")
fn:lower-case("12345abcd")
fn:lower-case("abc") and fn:lower-case("abc")
fn:lower-case("ABc!D")
fn:lower-case("ABCD")
fn:lower-case("abcde")
fn:lower-case("ABCDEabcde")
fn:lower-case(fn:codepoints-to-string((97,32,115,116,114,105,110,103)))
fn:lower-case(fn:prefix-from-QName(xs:QName("FOO:bar")))
fn:lower-case("lower-case")
fn:lower-case(lower-case("zzzzz"))
fn:lower-case(upper-case("AbcDH"))
fn:lower-case(xs:string("This is a characte"))
fn:matches('1.0', '\i+')
fn:matches('1.0', '\I+')
fn:matches('a', '[a--]')
fn:matches('aa', '(a\1)')
fn:matches('aA', '(a)\99')
fn:matches("aaababaaabaa", "^(a*b?a*){3,3}$")
fn:matches("a", "a[^b]"), fn:matches("a ", "a[^b]")
fn:matches('-abba-', '[-ab]+')
fn:matches("#abc#1", "^((#)abc\1)$")
fn:matches("#abc#1", "^(#)abc[\1]1$")
fn:matches("#abc#1", "^(#)abc\2$")
fn:matches('abc', '\c+')
fn:matches('abc', '\C+')
fn:matches('abcdefghii', '(a)(b)(c)(d)(e)(f)(g)(h)(i\9)')
fn:matches('abcdefghijj', '(a)(b)(c)(d)(e)(f)(g)(h)(i)(j\10)')
fn:matches('abcdefghijk', '(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k\11)')
fn:matches("abcdefghijklmnopq", "(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)((m)(n)(o)(p)(q)\13)$")
fn:matches('abc', '\S+')
fn:matches("abracadabra", "**%%")
fn:matches("abracadabra", "^a.*a$")
fn:matches("abracadabra", "(?:abra(?:cad)?)*")
fn:matches("abracadabra(abracadabra", "\(")
fn:matches("abracadabra)abracadabra", "\)")
fn:matches("abracadabra*abracadabra", "\*")
fn:matches("abracadabra+abracadabra", "\+")
fn:matches("abracadabra-abracadabra", "\-")
fn:matches("abracadabra-abracadabra.", "\.")
fn:matches("abracadabra.abracadabra", "\.")
fn:matches("abracadabra?abracadabra", "\?")
fn:matches("abracadabra[abracadabra", "\[")
fn:matches("abracadabra\abracadabra", "\\")
fn:matches("abracadabra]abracadabra", "\]")
fn:matches("abracadabra^abracadabra", "\^")
fn:matches("abracadabra{abracadabra", "\{")
fn:matches("abracadabra|abracadabra", "\|")
fn:matches("abracadabra}abracadabra", "\}")
fn:matches("abracadabra-abracadabra-3", "(124|864|377|3)")
fn:matches("abracadabraabracadabra", "aa{1}")
fn:matches("abracadabraabracadabraabracadabra", "aa{1,}")
fn:matches("abracadabraabracadabraabracadabra", "aa{1,2}")
fn:matches("abracadabra abracadabra", "\n")
fn:matches("abracadabra abracadabra", "\t")
fn:matches("abracadabra", "^bra")
fn:matches("abracadabra", "bra")
fn:matches('a_:', '\i+')
fn:matches('a_:', '\I+')
fn:matches('  ', '\c+')
fn:matches(concat('abcd', codepoints-to-string(10), 'defg', codepoints-to-string(10)), "g$")
fn:matches(concat('Mary', codepoints-to-string(10), 'Jones'), 'Mary.Jones')
fn:matches(concat('Mary', codepoints-to-string(10)), 'Mary$')
fn:matches(concat('Mary', codepoints-to-string(13), 'Jones'), 'Mary.Jones')
fn:matches('foo', '[^]')
fn:matches('foo', '[a-\b]')
fn:matches('foo', 'a()b')
fn:matches('foo', '\P{C')
fn:matches('foo', '\P{C}')
fn:matches('foo', '\P{Ca}')
fn:matches('foo', '\P{Cc}')
fn:matches('foo', '\P{L')
fn:matches('foo', '\P{L}')
fn:matches('foo', '\P{La}')
fn:matches('foo', '\P{Lu}')
fn:matches('foo', '\P{M')
fn:matches('foo', '\P{M}')
fn:matches('foo', '\P{Ma}')
fn:matches('foo', '\P{Me}')
fn:matches('foo', '\P{N')
fn:matches('foo', '\P{N}')
fn:matches('foo', '\P{Na}')
fn:matches('foo', '\P{No}')
fn:matches('foo', '\P{P')
fn:matches('foo', '\P{P}')
fn:matches('foo', '\P{Pa}')
fn:matches('foo', '\P{Pf}')
fn:matches('foo', '\P{S')
fn:matches('foo', '\P{S}')
fn:matches('foo', '\P{Sa}')
fn:matches('foo', '\P{Sk}')
fn:matches('foo', '\P{Z')
fn:matches('foo', '\P{Z}')
fn:matches('foo', '\P{Za}')
fn:matches('foo', '\P{Zs}')
fn:matches("h", "(.)\2")
fn:matches("h", "(.)\3")
fn:matches("hello world", "\p{ IsBasicLatin}+")
fn:matches("input", "[0-9-.]*/")
fn:matches('   ', '\S+')
fn:matches(' ', '[\t]')
fn:matches("This is a characte","This is a characte")
fn:matches('&#x10000;', '&#x10000;')
fn:matches('&#x20;&#x9;&#xD;', '\c+')
fn:matches('&#x20;&#x9;&#xD;', '\C+')
fn:matches('&#x9;', '[\t]')
fn:matches('&#xD;&#x20;&#x9;', '\S+')
(fn:max((1,2)) to 5)
fn:max((1 to 5))
fn:max((3,4,5))
fn:max((3,4,"Zero"))
fn:max(("a", "b", "c"))
fn:max((fn:current-date(), xs:date("2100-01-01")))
fn:max(fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")))
fn:max((xs:decimal("617375191608514839")))
fn:max((xs:decimal("617375191608514839"),xs:decimal("-999999999999999999")))
fn:max((xs:decimal("-999999999999999999")))
fn:max((xs:decimal("999999999999999999")))
fn:max((xs:decimal("-999999999999999999"),xs:decimal("617375191608514839")))
fn:max((xs:decimal("-999999999999999999"),xs:decimal("-999999999999999999")))
fn:max((xs:decimal("-999999999999999999"),xs:decimal("999999999999999999")))
fn:max((xs:decimal("999999999999999999"),xs:decimal("-999999999999999999")))
fn:max((xs:double("0")))
fn:max((xs:double("0"),xs:double("-1.7976931348623157E308")))
fn:max((xs:double("-1.7976931348623157E308")))
fn:max((xs:double("1.7976931348623157E308")))
fn:max((xs:double("-1.7976931348623157E308"),xs:double("0")))
fn:max((xs:double("-1.7976931348623157E308"),xs:double("-1.7976931348623157E308")))
fn:max((xs:double("-1.7976931348623157E308"),xs:double("1.7976931348623157E308")))
fn:max((xs:double("1.7976931348623157E308"),xs:double("-1.7976931348623157E308")))
fn:max((xs:float("0")))
fn:max((xs:float("0"),xs:float("-3.4028235E38")))
fn:max((xs:float("-3.4028235E38")))
fn:max((xs:float("3.4028235E38")))
fn:max((xs:float("-3.4028235E38"),xs:float("0")))
fn:max((xs:float("-3.4028235E38"),xs:float("-3.4028235E38")))
fn:max((xs:float("-3.4028235E38"),xs:float("3.4028235E38")))
fn:max((xs:float("3.4028235E38"),xs:float("-3.4028235E38")))
fn:max((xs:int("-1873914410")))
fn:max((xs:int("-1873914410"),xs:int("-2147483648")))
fn:max((xs:int("2147483647")))
fn:max((xs:int("2147483647"),xs:int("-2147483648")))
fn:max((xs:int("-2147483648")))
fn:max((xs:int("-2147483648"),xs:int("-1873914410")))
fn:max((xs:int("-2147483648"),xs:int("2147483647")))
fn:max((xs:int("-2147483648"),xs:int("-2147483648")))
fn:max((xs:integer(5000000000),xs:double(3e0)))
fn:max((xs:integer(5), xs:float(5.0), xs:double(0)))
fn:max((xs:negativeInteger("-1")))
fn:max((xs:nonNegativeInteger("0")))
fn:max((xs:nonNegativeInteger("0"),xs:nonNegativeInteger("0")))
fn:max((xs:nonPositiveInteger("0")))
fn:max((xs:positiveInteger("1")))
fn:max((xs:positiveInteger("1"),xs:positiveInteger("1")))
fn:max((xs:short("32767")))
fn:max((xs:short("32767"),xs:short("-32768")))
fn:max((xs:short("-32768")))
fn:max((xs:short("-32768"),xs:short("32767")))
fn:max((xs:short("-32768"),xs:short("-32768")))
fn:max((xs:short("-32768"),xs:short("-5324")))
fn:max((xs:short("-5324")))
fn:max((xs:short("-5324"),xs:short("-32768")))
fn:max((xs:unsignedLong("0")))
fn:max((xs:unsignedLong("0"),xs:unsignedLong("0")))
fn:max((xs:unsignedShort("0")))
fn:max((xs:unsignedShort("0"),xs:unsignedShort("0")))
fn:max((xs:unsignedShort("0"),xs:unsignedShort("44633")))
fn:max((xs:unsignedShort("0"),xs:unsignedShort("65535")))
fn:max((xs:unsignedShort("44633")))
fn:max((xs:unsignedShort("44633"),xs:unsignedShort("0")))
fn:max((xs:unsignedShort("65535")))
fn:max((xs:unsignedShort("65535"),xs:unsignedShort("0")))
fn:max( (xs:yearMonthDuration('P1Y0M'), 1) )
(fn:min((1,2)) to 5)
(fn:min((1,2)) to fn:max((6,7)))
fn:min((1 to 5))
fn:min((3,4,5))
fn:min((3,4,"Zero"))
fn:min(("a", "b", "c"))
fn:min((fn:current-date(), xs:date("1900-01-01")))
fn:min(fn:timezone-from-dateTime(xs:dateTime("1970-01-01T02:00:00Z")))
fn:minutes-from-dateTime(fn:current-dateTime())
fn:minutes-from-dateTime(fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00")))
fn:minutes-from-dateTime(xs:dateTime("1970-01-01T00:00:00Z"))
fn:minutes-from-dateTime(xs:dateTime("1970-01-01T00:00:00Z")) + fn:minutes-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:minutes-from-dateTime(xs:dateTime("1970-01-01T00:00:00Z")) - fn:minutes-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:minutes-from-dateTime(xs:dateTime("1970-01-01T02:02:00Z")) * fn:minutes-from-dateTime(xs:dateTime("1970-01-01T10:03:00Z"))
fn:minutes-from-dateTime(xs:dateTime("1970-01-01T02:10:00Z")) div fn:minutes-from-dateTime(xs:dateTime("1970-01-01T10:05:00Z"))
+fn:minutes-from-dateTime(xs:dateTime("1970-01-01T10:10:00Z"))
-fn:minutes-from-dateTime(xs:dateTime("1970-01-01T10:10:00Z"))
fn:minutes-from-dateTime(xs:dateTime("1970-01-01T10:10:00Z")) eq fn:minutes-from-dateTime(xs:dateTime("1970-01-01T10:10:00Z"))
fn:minutes-from-dateTime(xs:dateTime("1970-01-01T10:10:00Z")) ge fn:minutes-from-dateTime(xs:dateTime("1970-01-01T10:10:00Z"))
fn:minutes-from-dateTime(xs:dateTime("1970-01-01T10:10:00Z")) idiv fn:minutes-from-dateTime(xs:dateTime("1970-01-01T02:05:00Z"))
fn:minutes-from-dateTime(xs:dateTime("1970-01-01T10:10:00Z")) le fn:minutes-from-dateTime(xs:dateTime("1970-01-01T10:10:00Z"))
fn:minutes-from-dateTime(xs:dateTime("1970-01-01T10:10:00Z")) mod fn:minutes-from-dateTime(xs:dateTime("1970-01-01T03:10:00Z"))
fn:minutes-from-dateTime(xs:dateTime("1970-01-01T10:10:00Z")) ne fn:minutes-from-dateTime(xs:dateTime("1970-01-01T10:10:00Z"))
fn:minutes-from-dateTime(xs:dateTime("1996-04-07T01:40:52Z"))
fn:minutes-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))
fn:minutes-from-dateTime(xs:dateTime("1999-05-31T13:30:00+05:30"))
fn:minutes-from-dateTime(xs:dateTime("1999-05-31T20:00:00-05:00"))
fn:minutes-from-dateTime(xs:dateTime("1999-05-31T23:59:00-05:00"))
fn:minutes-from-dateTime(xs:dateTime("1999-12-31T21:20:00-05:00")) le fn:minutes-from-dateTime(xs:dateTime("1999-12-31T21:20:00-05:00"))
fn:minutes-from-dateTime(xs:dateTime("1999-12-31T21:20:00-05:00")) lt fn:minutes-from-dateTime(xs:dateTime("1999-12-31T21:20:00-05:00"))
fn:minutes-from-dateTime(xs:dateTime("2030-12-31T23:59:59Z"))
fn:minutes-from-duration(xs:dayTimeDuration("P01DT01H01M"))
fn:minutes-from-duration(xs:dayTimeDuration("P0DT0H0M0S"))
fn:minutes-from-duration(xs:dayTimeDuration("P10DT10H20M")) mod fn:minutes-from-duration(xs:dayTimeDuration("P03DT03H03M"))
fn:minutes-from-duration(xs:dayTimeDuration("P15DT11H59M59S"))
fn:minutes-from-duration(xs:dayTimeDuration("P20DT03H09M")) le fn:minutes-from-duration(xs:dayTimeDuration("P21DT15H21M"))
-fn:minutes-from-duration(xs:dayTimeDuration("P20DT03H20M"))
fn:minutes-from-duration(xs:dayTimeDuration("P20DT09H04M")) * fn:minutes-from-duration(xs:dayTimeDuration("P03DT10H10M"))
fn:minutes-from-duration(xs:dayTimeDuration("P20DT10H10M")) div fn:minutes-from-duration(xs:dayTimeDuration("P05DT05H02M"))
fn:minutes-from-duration(xs:dayTimeDuration("P20DT20H20M")) lt fn:minutes-from-duration(xs:dayTimeDuration("P03DT02H10M"))
fn:minutes-from-duration(xs:dayTimeDuration("P21DT07H12M")) ge fn:minutes-from-duration(xs:dayTimeDuration("P20DT01H13M"))
+fn:minutes-from-duration(xs:dayTimeDuration("P21DT10H10M"))
fn:minutes-from-duration(xs:dayTimeDuration("P21DT10H10M")) + fn:minutes-from-duration(xs:dayTimeDuration("P22DT11H30M"))
fn:minutes-from-duration(xs:dayTimeDuration("P21DT10H10M")) le fn:minutes-from-duration(xs:dayTimeDuration("P22DT10H09M"))
fn:minutes-from-duration(xs:dayTimeDuration("P21DT10H65M"))
fn:minutes-from-duration(xs:dayTimeDuration("P22DT10H10M")) eq fn:minutes-from-duration(xs:dayTimeDuration("P22DT09H10M"))
fn:minutes-from-duration(xs:dayTimeDuration("P23DT08H20M")) ne fn:minutes-from-duration(xs:dayTimeDuration("P12DT05H22M"))
fn:minutes-from-duration(xs:dayTimeDuration("P25DT10H20M")) idiv fn:minutes-from-duration(xs:dayTimeDuration("P05DT02H04M"))
fn:minutes-from-duration(xs:dayTimeDuration("P30DT10H20M")) - fn:minutes-from-duration(xs:dayTimeDuration("P10DT09H10M"))
fn:minutes-from-duration(xs:dayTimeDuration("P31DT23H59M59S"))
fn:minutes-from-duration(xs:dayTimeDuration("P3DT10H"))
fn:minutes-from-duration(xs:dayTimeDuration("-P5DT12H30M"))
fn:minutes-from-duration(xs:duration("P1Y2M3DT10H30M"))
fn:minutes-from-duration(xs:yearMonthDuration('P1Y'))
fn:minutes-from-time(fn:current-time())
fn:minutes-from-time(xs:time("00:00:00Z"))
fn:minutes-from-time(xs:time("01:23:00Z")) gt fn:minutes-from-time(xs:time("01:23:00Z"))
fn:minutes-from-time(xs:time("02:00:00Z")) + fn:minutes-from-time(xs:time("10:00:00Z"))
fn:minutes-from-time(xs:time("02:02:00Z")) * fn:minutes-from-time(xs:time("10:08:00Z"))
fn:minutes-from-time(xs:time("08:03:35Z"))
+fn:minutes-from-time(xs:time("10:00:00Z"))
fn:minutes-from-time(xs:time("10:00:00Z")) le fn:minutes-from-time(xs:time("10:00:00Z"))
fn:minutes-from-time(xs:time("10:00:00Z")) ne fn:minutes-from-time(xs:time("01:01:00Z"))
fn:minutes-from-time(xs:time("10:02:00Z")) eq fn:minutes-from-time(xs:time("10:02:00Z"))
fn:minutes-from-time(xs:time("10:03:00Z")) ge fn:minutes-from-time(xs:time("10:04:00Z"))
-fn:minutes-from-time(xs:time("10:10:00Z"))
fn:minutes-from-time(xs:time("10:10:00Z")) - fn:minutes-from-time(xs:time("09:02:00Z"))
fn:minutes-from-time(xs:time("10:10:00Z")) mod fn:minutes-from-time(xs:time("03:03:00Z"))
fn:minutes-from-time(xs:time("10:12:00Z")) idiv fn:minutes-from-time(xs:time("02:02:00Z"))
fn:minutes-from-time(xs:time("13:00:00Z"))
fn:minutes-from-time(xs:time("21:23:00Z")) lt fn:minutes-from-time(xs:time("21:24:00Z"))
fn:minutes-from-time(xs:time("22:33:00Z")) div fn:minutes-from-time(xs:time("02:11:00Z"))
fn:minutes-from-time(xs:time("23:59:59Z"))
fn:min((xs:decimal("617375191608514839")))
fn:min((xs:decimal("617375191608514839"),xs:decimal("-999999999999999999")))
fn:min((xs:decimal("-999999999999999999")))
fn:min((xs:decimal("999999999999999999")))
fn:min((xs:decimal("-999999999999999999"),xs:decimal("617375191608514839")))
fn:min((xs:decimal("-999999999999999999"),xs:decimal("-999999999999999999")))
fn:min((xs:decimal("-999999999999999999"),xs:decimal("999999999999999999")))
fn:min((xs:decimal("999999999999999999"),xs:decimal("-999999999999999999")))
fn:min((xs:double("0")))
fn:min((xs:double("0"),xs:double("-1.7976931348623157E308")))
fn:min((xs:double("-1.7976931348623157E308")))
fn:min((xs:double("1.7976931348623157E308")))
fn:min((xs:double("-1.7976931348623157E308"),xs:double("0")))
fn:min((xs:double("-1.7976931348623157E308"),xs:double("-1.7976931348623157E308")))
fn:min((xs:double("-1.7976931348623157E308"),xs:double("1.7976931348623157E308")))
fn:min((xs:double("1.7976931348623157E308"),xs:double("-1.7976931348623157E308")))
fn:min((xs:float("0")))
fn:min((xs:float("0"),xs:float("-3.4028235E38")))
fn:min((xs:float("-3.4028235E38")))
fn:min((xs:float("3.4028235E38")))
fn:min((xs:float("-3.4028235E38"),xs:float("0")))
fn:min((xs:float("-3.4028235E38"),xs:float("-3.4028235E38")))
fn:min((xs:float("-3.4028235E38"),xs:float("3.4028235E38")))
fn:min((xs:float("3.4028235E38"),xs:float("-3.4028235E38")))
fn:min((xs:int("-1873914410")))
fn:min((xs:int("-1873914410"),xs:int("-2147483648")))
fn:min((xs:int("2147483647")))
fn:min((xs:int("2147483647"),xs:int("-2147483648")))
fn:min((xs:int("-2147483648")))
fn:min((xs:int("-2147483648"),xs:int("-1873914410")))
fn:min((xs:int("-2147483648"),xs:int("2147483647")))
fn:min((xs:int("-2147483648"),xs:int("-2147483648")))
fn:min((xs:integer(5000000),xs:double(3e8)))
fn:min((xs:integer(5), xs:float(5), xs:double(10)))
fn:min((xs:negativeInteger("-1")))
fn:min((xs:nonNegativeInteger("0")))
fn:min((xs:nonNegativeInteger("0"),xs:nonNegativeInteger("0")))
fn:min((xs:nonPositiveInteger("0")))
fn:min((xs:positiveInteger("1")))
fn:min((xs:positiveInteger("1"),xs:positiveInteger("1")))
fn:min((xs:short("32767")))
fn:min((xs:short("32767"),xs:short("-32768")))
fn:min((xs:short("-32768")))
fn:min((xs:short("-32768"),xs:short("32767")))
fn:min((xs:short("-32768"),xs:short("-32768")))
fn:min((xs:short("-32768"),xs:short("-5324")))
fn:min((xs:short("-5324")))
fn:min((xs:short("-5324"),xs:short("-32768")))
fn:min((xs:unsignedLong("0")))
fn:min((xs:unsignedLong("0"),xs:unsignedLong("0")))
fn:min((xs:unsignedShort("0")))
fn:min((xs:unsignedShort("0"),xs:unsignedShort("0")))
fn:min((xs:unsignedShort("0"),xs:unsignedShort("44633")))
fn:min((xs:unsignedShort("0"),xs:unsignedShort("65535")))
fn:min((xs:unsignedShort("44633")))
fn:min((xs:unsignedShort("44633"),xs:unsignedShort("0")))
fn:min((xs:unsignedShort("65535")))
fn:min((xs:unsignedShort("65535"),xs:unsignedShort("0")))
fn:min( (xs:yearMonthDuration('P1Y0M'), 1) )
fn:month-from-date(fn:current-date())
fn:month-from-dateTime(fn:current-dateTime())
fn:month-from-dateTime(fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00")))
fn:month-from-dateTime(xs:dateTime("0001-12-31T23:20:00Z"))
fn:month-from-dateTime(xs:dateTime("1000-10-01T02:00:00Z")) div fn:month-from-dateTime(xs:dateTime("0050-05-01T10:00:00Z"))
fn:month-from-dateTime(xs:dateTime("1970-01-01T00:00:00Z"))
fn:month-from-dateTime(xs:dateTime("1970-01-01T00:00:00Z")) + fn:month-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:month-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) eq fn:month-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:month-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) ne fn:month-from-dateTime(xs:dateTime("1970-02-01T10:00:00Z"))
fn:month-from-dateTime(xs:dateTime("1970-01-12T10:00:00Z")) idiv fn:month-from-dateTime(xs:dateTime("1970-02-01T02:00:00Z"))
fn:month-from-dateTime(xs:dateTime("1970-02-01T00:00:00Z")) - fn:month-from-dateTime(xs:dateTime("1969-01-01T10:00:00Z"))
-fn:month-from-dateTime(xs:dateTime("1970-02-01T10:00:00Z"))
fn:month-from-dateTime(xs:dateTime("1970-02-01T10:00:00Z")) le fn:month-from-dateTime(xs:dateTime("1971-01-01T10:00:00Z"))
fn:month-from-dateTime(xs:dateTime("1970-03-01T02:00:00Z")) * fn:month-from-dateTime(xs:dateTime("0002-02-01T10:00:00Z"))
fn:month-from-dateTime(xs:dateTime("1970-10-01T10:00:00Z")) mod fn:month-from-dateTime(xs:dateTime("1970-03-01T03:00:00Z"))
+fn:month-from-dateTime(xs:dateTime("1971-01-01T10:00:00Z"))
fn:month-from-dateTime(xs:dateTime("1971-01-01T10:00:00Z")) ge fn:month-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:month-from-dateTime(xs:dateTime("1996-04-07T01:40:52Z"))
fn:month-from-dateTime(xs:dateTime("-1999-01-31T00:20:00-05:00"))
fn:month-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))
fn:month-from-dateTime(xs:dateTime("1999-12-31T19:20:00-05:00"))
fn:month-from-dateTime(xs:dateTime("2030-12-31T23:59:59Z"))
fn:month-from-date(xs:date("1970-01-01+05:00")) ne fn:month-from-date(xs:date("1970-01-03+03:00"))
+fn:month-from-date(xs:date("1970-01-01Z"))
-fn:month-from-date(xs:date("1970-01-01Z"))
fn:month-from-date(xs:date("1970-01-01Z"))
fn:month-from-date(xs:date("1970-01-01Z")) div fn:month-from-date(xs:date("1970-01-01Z"))
fn:month-from-date(xs:date("1970-01-01Z")) eq fn:month-from-date(xs:date("1970-01-01Z"))
fn:month-from-date(xs:date("1970-01-01Z")) * fn:month-from-date(xs:date("0002-01-01Z"))
fn:month-from-date(xs:date("1970-01-01Z")) + fn:month-from-date(xs:date("1970-01-01Z"))
fn:month-from-date(xs:date("1970-01-01Z")) - fn:month-from-date(xs:date("1970-01-01Z"))
fn:month-from-date(xs:date("1970-01-01Z")) ge fn:month-from-date(xs:date("1970-01-01Z"))
fn:month-from-date(xs:date("1970-01-01Z")) idiv fn:month-from-date(xs:date("1970-01-01Z"))
fn:month-from-date(xs:date("1970-01-01Z")) le fn:month-from-date(xs:date("1970-01-01Z"))
fn:month-from-date(xs:date("1970-01-01Z")) mod fn:month-from-date(xs:date("1970-01-01Z"))
fn:month-from-date(xs:date("1970-01-01Z")) ne fn:month-from-date(xs:date("1970-01-01Z"))
fn:month-from-date(xs:date("1970-01-01Z")) ne fn:month-from-date(xs:date("1970-01-03Z"))
fn:month-from-date(xs:date("1970-01-31Z"))
fn:month-from-date(xs:date("1983-11-17Z"))
fn:month-from-date(xs:date("1999-05-31-05:00"))
fn:month-from-date(xs:date("1999-12-31Z"))
fn:month-from-date(xs:date("1999-12-31Z")) le fn:month-from-date(xs:date("1999-12-31Z"))
fn:month-from-date(xs:date("1999-12-31Z")) lt fn:month-from-date(xs:date("1999-12-31Z"))
fn:month-from-date(xs:date("2000-01-01+05:00"))
fn:month-from-date(xs:date("2030-12-31Z"))
fn:months-from-duration(xs:dayTimeDuration('P1D'))
fn:months-from-duration(xs:dayTimeDuration("-P2DT15H0M0S"))
fn:months-from-duration(xs:duration("P1Y2M3DT10H30M"))
fn:months-from-duration(xs:yearMonthDuration("P01Y01M"))
fn:months-from-duration(xs:yearMonthDuration("P0Y0M"))
fn:months-from-duration(xs:yearMonthDuration("P1000Y6M"))
fn:months-from-duration(xs:yearMonthDuration("P10Y10M")) mod fn:months-from-duration(xs:yearMonthDuration("P03Y03M"))
fn:months-from-duration(xs:yearMonthDuration("P2030Y12M"))
fn:months-from-duration(xs:yearMonthDuration("P20Y09M")) * fn:months-from-duration(xs:yearMonthDuration("P02Y10M"))
fn:months-from-duration(xs:yearMonthDuration("P20Y09M")) ge fn:months-from-duration(xs:yearMonthDuration("P20Y01M"))
fn:months-from-duration(xs:yearMonthDuration("P20Y10M")) div fn:months-from-duration(xs:yearMonthDuration("P05Y05M"))
fn:months-from-duration(xs:yearMonthDuration("P20Y15M"))
fn:months-from-duration(xs:yearMonthDuration("-P20Y18M"))
fn:months-from-duration(xs:yearMonthDuration("P20Y3M")) lt fn:months-from-duration(xs:yearMonthDuration("P21Y2M"))
fn:months-from-duration(xs:yearMonthDuration("P21Y01M")) le fn:months-from-duration(xs:yearMonthDuration("P21Y15M"))
+fn:months-from-duration(xs:yearMonthDuration("P21Y10M"))
fn:months-from-duration(xs:yearMonthDuration("P21Y10M")) + fn:months-from-duration(xs:yearMonthDuration("P22Y11M"))
fn:months-from-duration(xs:yearMonthDuration("P21Y10M")) le fn:months-from-duration(xs:yearMonthDuration("P22Y10M"))
fn:months-from-duration(xs:yearMonthDuration("P22Y10M")) eq fn:months-from-duration(xs:yearMonthDuration("P22Y09M"))
fn:months-from-duration(xs:yearMonthDuration("P22Y10M")) ne fn:months-from-duration(xs:yearMonthDuration("P23Y10M"))
-fn:months-from-duration(xs:yearMonthDuration("P25Y03M"))
fn:months-from-duration(xs:yearMonthDuration("P25Y10M")) idiv fn:months-from-duration(xs:yearMonthDuration("P05Y02M"))
fn:months-from-duration(xs:yearMonthDuration("P30Y10M")) - fn:months-from-duration(xs:yearMonthDuration("P10Y09M"))
fn:name()
fn:name(.)
fn:name(<anElement>Content</anElement>)
fn:name(<anElement name="attribute1">Content</anElement>)
fn:namespace-uri-from-QName("")
fn:namespace-uri-from-QName(((),()))
fn:namespace-uri-from-QName(())
fn:namespace-uri-from-QName()
fn:namespace-uri-from-QName(fn:node-name(<anelement xmlns = "http://example.com/examples"></anelement>))
fn:namespace-uri-from-QName(fn:QName("http://www.example.com/example",                   "person"))
fn:namespace-uri-from-QName(fn:QName("http://www.example.com/urn", exactly-one(xs:string(data((/root/elemQN))[1]))))
fn:namespace-uri-from-QName(fn:QName("http://www.example.com/urn", exactly-one(xs:string(/root[1]/@attrDerivQN)))) instance of xs:anyURI ?
fn:namespace-uri-from-QName(fn:QName("http://www.example.com/urn", exactly-one(xs:string((/root/@attrDerivQN)[1]))))
fn:namespace-uri-from-QName(fn:QName("http://www.example.com/urn", exactly-one(xs:string((/root/@attrQN)[1]))))
fn:namespace-uri-from-QName(fn:QName("http://www.example.com/urn", exactly-one(xs:string((/root/derivQN)[1]))))
fn:namespace-uri-from-QName(fn:QName("http://www.example.com/urn", exactly-one(xs:string((/root/elemQN)[1]))))
fn:namespace-uri-from-QName( if( false() ) then fn:QName("http://www.example.com/urn", exactly-one(xs:string((/root/elemQN)[1]))) else fn:QName("http://www.example.com/urn", exactly-one(xs:string((/root/@attrQN)[1]))) )
fn:namespace-uri-from-QName( if( true() ) then fn:QName("http://www.example.com/urn", exactly-one(xs:string((/root/elemQN[1])))) else fn:QName("http://www.example.com/urn", exactly-one(xs:string((/root/@attrQN))[1])) )
fn:namespace-uri-from-QName(/root/elemQN)
fn:namespace-uri-from-qname((/root/elemQN)[1])
fn:namespace-uri-from-Qname((/root/elemQN)[1])
fn:namespaceURIfromQName((/root/elemQN)[1])
fn:namespace-uri-from-QName(xs:integer("100"))
fn:namespace-uri-from-QName(xs:time("12:00:00Z"))
(fn:name(./works[1]/employee[1]))
(fn:name(./works[1]/employee[1]),fn:name(./works[1]/employee[2]))
(fn:name(./works[1]/employee[1]/@name))
fn:node-name(processing-instruction piName {"Processing Instruction content"},"A Second Argument")
fn:normalize-space("      ")
fn:normalize-space("    ")
fn:normalize-space(" ")
fn:normalize-space("")
fn:normalize-space(())
fn:normalize-space()
fn:normalize-space(" 12345")
fn:normalize-space(fn:normalize-space(" ABC"))
fn:normalize-space(fn:string(" ABC "))
fn:normalize-space(" The    wealthy curled darlings                                         of    our    nation. ")
fn:normalize-space(" The wealthy curled darlings of our nation. ")
fn:normalize-space("This is a ch")
fn:normalize-space("This is a charac")
fn:normalize-space("This text should contains no newline characters.")
fn:normalize-space("This text should contains no tab characters.")
fn:normalize-space("This text should contains no tabs")
fn:normalize-space("This  text  should  contains  no tabs or newline characters.")
fn:normalize-space("This text should contains no tabs or newline characters.")
fn:not(())
fn:not(7 lt 7) and xs:boolean("false")
fn:not(7 lt 7) eq xs:boolean("true")
fn:not(("ab" || "cde"))
fn:not(current-date() > xs:date("1997-01-01Z"))
fn:not("false")
fn:not(fn:codepoint-equal("a","a"))
fn:not(fn:codepoint-equal("a","b"))
fn:not(fn:concat("ab","cde"))
fn:not(fn:contains("A","A"))
fn:not(fn:contains("A","B"))
fn:not(fn:ends-with("A","A"))
fn:not(fn:ends-with("A","B"))
fn:not(fn:false())
fn:not(fn:lower-case("abcde"))
fn:not("fn:not()")
fn:not(fn:QName("http://www.example.com/example", "px1:person1") eq fn:QName("http://www.example.com/example","px2:person2"))
fn:not(fn:QName("http://www.example.com/example", "px1:person1") ne fn:QName("http://www.example.com/example","px2:person2"))
fn:not(fn:starts-with("A","A"))
fn:not(fn:starts-with("A","B"))
fn:not(fn:string(fn:current-date()))
fn:not(fn:string(fn:current-dateTime()))
fn:not(fn:string(fn:current-time()))
fn:not(fn:string(fn:timezone-from-date(xs:date("1970-01-03+02:00"))))
fn:not(fn:string(fn:timezone-from-time(xs:time("02:02:03Z"))))
fn:not(fn:string-join((),"A"))
fn:not(fn:string-join(("A"),"B"))
fn:not(fn:string-length("abcde"))
fn:not(fn:string(xs:date("1998-09-12Z") - xs:date("1998-09-21Z")))
fn:not(fn:string(xs:dateTime("1998-09-12T11:12:12Z") - xs:dateTime("1996-02-02T01:01:01Z")))
fn:not(fn:string(xs:dayTimeDuration("P11DT12H04M") * 2.0))
fn:not(fn:string(xs:dayTimeDuration("P11DT12H04M") div 2.0))
fn:not(fn:string(xs:dayTimeDuration("P11DT12H04M") + xs:dayTimeDuration("P02DT07H01M")))
fn:not(fn:string(xs:dayTimeDuration("P11DT12H04M") - xs:dayTimeDuration("P02DT07H01M")))
fn:not(fn:string(xs:time("13:00:00Z") - xs:time("14:00:00Z")))
fn:not(fn:string(xs:yearMonthDuration("P11Y04M") * 2.0))
fn:not(fn:string(xs:yearMonthDuration("P11Y04M") div 2.0))
fn:not(fn:string(xs:yearMonthDuration("P11Y04M") + xs:yearMonthDuration("P02Y11M")))
fn:not(fn:string(xs:yearMonthDuration("P11Y04M") - xs:yearMonthDuration("P02Y11M")))
fn:not(fn:substring("ABC",1))
fn:not(fn:substring-after("A","A"))
fn:not(fn:substring-after("A","B"))
fn:not(fn:substring-before("A","A"))
fn:not(fn:substring-before("A","B"))
fn:not(fn:true())
fn:not(fn:upper-case("abcde"))
fn:not(for $x in 1 to 10 return <e>{$x}</e>)
fn:not((/staff[1]/employee[1]/empnum[1]) is (/staff[1]/employee[1]/empnum[1]))
fn:not((/staff[1]/employee[1]/empnum[1]) << (/staff[1]/employee[1]/empnum[1]))
fn:not((/staff[1]/employee[1]/empnum[1]) >> (/staff[1]/employee[1]/empnum[1]))
fn:not("true")
fn:not("true") and fn:not("true")
fn:not("true") eq fn:not("true")
(fn:not("true"),fn:not("false"))
fn:not("true") != fn:not("true")
fn:not("true") < fn:not("true")
fn:not("true") <= fn:not("true")
fn:not("true") = fn:not("true")
fn:not("true") > fn:not("true")
fn:not("true") >= fn:not("true")
fn:not("true") ge fn:not("true")
fn:not("true") gt fn:not("true")
fn:not("true") le fn:not("true")
fn:not("true") lt fn:not("true")
fn:not("true") ne fn:not("true")
fn:not("true") or fn:not("true")
fn:not(xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") eq xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp"))
fn:not(xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") ne xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp"))
fn:not(xs:boolean("false") and xs:boolean("false")) eq xs:boolean("false")
fn:not(xs:boolean("false") and xs:boolean("true")) eq fn:not(xs:boolean("false") and xs:boolean("true"))
fn:not(xs:boolean("false")) eq fn:not(xs:boolean("false"))
fn:not(xs:boolean("false")) eq xs:boolean("false")
fn:not(xs:boolean("false")) ge xs:boolean("false")
fn:not(xs:boolean("false")) ge xs:boolean("true")
fn:not(xs:boolean("false")) gt xs:boolean("false")
fn:not(xs:boolean("false")) gt xs:boolean("true")
fn:not(xs:boolean("false")) le xs:boolean("false")
fn:not(xs:boolean("false")) le xs:boolean("true")
fn:not(xs:boolean("false")) lt xs:boolean("false")
fn:not(xs:boolean("false")) lt xs:boolean("true")
fn:not(xs:boolean("true") and xs:boolean("true")) eq xs:boolean("true")
fn:not(xs:boolean("true")) eq xs:boolean("false")
fn:not(xs:boolean("true")) eq xs:boolean("true")
fn:not(xs:boolean("true")) ge xs:boolean("false")
fn:not(xs:boolean("true")) ge xs:boolean("true")
fn:not(xs:boolean("true")) gt xs:boolean("false")
fn:not(xs:boolean("true")) gt xs:boolean("true")
fn:not(xs:boolean("true")) le xs:boolean("false")
fn:not(xs:boolean("true")) le xs:boolean("true")
fn:not(xs:boolean("true")) lt xs:boolean("false")
fn:not(xs:boolean("true")) lt xs:boolean("true")
fn:not(xs:date("2000-11-09Z") gt xs:date("2000-11-10Z"))
fn:not(xs:date("2000-12-25Z") lt xs:date("2000-11-25Z"))
fn:not(xs:date("2005-04-02Z") ge xs:date("2005-04-02Z"))
fn:not(xs:date("2005-04-02Z") le xs:date("2005-04-02Z"))
fn:not(xs:date("2005-10-23Z") ge xs:date("2005-10-25Z"))
fn:not(xs:date("2005-10-25Z") le xs:date("2005-10-23Z"))
fn:not((xs:date("2005-12-25Z") lt xs:date("2005-12-26Z")))
fn:not((xs:date("2005-12-26Z") gt xs:date("2005-12-25Z")))
fn:not(xs:dateTime("2002-04-02T12:00:00Z") ge xs:dateTime("2002-04-02T12:00:00Z"))
fn:not(xs:dateTime("2002-04-02T12:00:00Z") ge xs:dateTime("2008-04-02T12:00:00Z"))
fn:not(xs:dateTime("2002-04-02T12:00:00Z") gt xs:dateTime("2002-05-02T12:00:00Z"))
fn:not(xs:dateTime("2002-04-02T12:00:00Z") le xs:dateTime("2002-04-02T12:00:00Z"))
fn:not((xs:dateTime("2002-04-02T12:00:00Z") lt xs:dateTime("2003-04-02T12:00:00Z")))
fn:not(xs:dateTime("2002-05-02T12:00:00Z") lt xs:dateTime("2002-04-02T12:00:00Z"))
fn:not((xs:dateTime("2004-04-02T12:00:00Z") gt xs:dateTime("2003-04-02T12:00:00Z")))
fn:not(xs:dateTime("2004-04-02T12:00:00Z") le xs:dateTime("2002-04-02T12:00:00Z"))
fn:not(xs:dayTimeDuration("P07DT09H") ge xs:dayTimeDuration("P09DT09H"))
fn:not(xs:dayTimeDuration("P08DT10H") gt xs:dayTimeDuration("P9DT09H"))
fn:not(xs:dayTimeDuration("P10DT09H") le xs:dayTimeDuration("P09DT09H"))
fn:not(xs:dayTimeDuration("P10DT10H") lt xs:dayTimeDuration("P9DT09H"))
fn:not(xs:dayTimeDuration("P10DT110H") le xs:dayTimeDuration("P10DT11H"))
fn:not(xs:dayTimeDuration("P10DT11H") ge xs:dayTimeDuration("P10DT10H"))
fn:not(xs:dayTimeDuration("P11DT12H04M") div xs:dayTimeDuration("P02DT07H01M"))
fn:not((xs:dayTimeDuration("P13DT12H") lt xs:dayTimeDuration("P14DT11H")))
fn:not((xs:dayTimeDuration("P15DT12H") gt xs:dayTimeDuration("P14DT11H")))
fn:not(xs:decimal("617375191608514839"))
fn:not(xs:decimal("-999999999999999999"))
fn:not(xs:decimal("999999999999999999"))
fn:not(xs:double("0"))
fn:not(xs:double("-1.7976931348623157E308"))
fn:not(xs:double("1.7976931348623157E308"))
fn:not(xs:duration("P36D") eq xs:duration("P36D"))
fn:not(xs:duration("P36D") ne xs:duration("P36D"))
fn:not(xs:float("0"))
fn:not(xs:float("-3.4028235E38"))
fn:not(xs:float("3.4028235E38"))
fn:not(xs:gDay("---05Z") ne xs:gDay("---05Z"))
fn:not(xs:gDay("---05Z") ne xs:gDay("---06Z"))
fn:not(xs:gDay("---11Z") eq xs:gDay("---10Z"))
fn:not((xs:gDay("---12Z") eq xs:gDay("---12Z")))
fn:not(xs:gMonth("--05Z") ne xs:gMonth("--05Z"))
fn:not(xs:gMonth("--05Z") ne xs:gMonth("--06Z"))
fn:not(xs:gMonth("--11Z") eq xs:gMonth("--10Z"))
fn:not((xs:gMonth("--12Z") eq xs:gMonth("--12Z")))
fn:not(xs:gMonthDay("--05-01Z") ne xs:gMonthDay("--06-12Z"))
fn:not(xs:gMonthDay("--05-10Z") ne xs:gMonthDay("--05-10Z"))
fn:not(xs:gMonthDay("--11-10Z") eq xs:gMonthDay("--10-02Z"))
fn:not((xs:gMonthDay("--12-10Z") eq xs:gMonthDay("--12-10Z")))
fn:not((xs:gYear("1995Z") eq xs:gYear("1995Z")))
fn:not(xs:gYear("2000Z") eq xs:gYear("2001Z"))
fn:not(xs:gYear("2005Z") ne xs:gYear("2005Z"))
fn:not(xs:gYear("2005Z") ne xs:gYear("2006Z"))
fn:not((xs:gYearMonth("1995-02Z") eq xs:gYearMonth("1995-02Z")))
fn:not(xs:gYearMonth("2000-01Z") eq xs:gYearMonth("2001-04Z"))
fn:not(xs:gYearMonth("2005-01Z") ne xs:gYearMonth("2005-01Z"))
fn:not(xs:gYearMonth("2005-02Z") ne xs:gYearMonth("2006-03Z"))
fn:not((xs:hexBinary("786174616d61616772") eq xs:hexBinary("786174616d61616772")))
fn:not((xs:hexBinary("786174616d61616772") ne xs:hexBinary("786174616d61616772")))
fn:not(xs:int("-1873914410"))
fn:not(xs:int("2147483647"))
fn:not(xs:int("-2147483648"))
fn:not(xs:negativeInteger("-1"))
fn:not(xs:nonNegativeInteger("0"))
fn:not(xs:nonPositiveInteger("0"))
fn:not(xs:positiveInteger("1"))
fn:not(xs:short("32767"))
fn:not(xs:short("-32768"))
fn:not(xs:short("-5324"))
fn:not(xs:unsignedLong("0"))
fn:not(xs:unsignedShort("0"))
fn:not(xs:unsignedShort("44633"))
fn:not(xs:unsignedShort("65535"))
fn:not(xs:yearMonthDuration("P10Y07M") ge xs:yearMonthDuration("P10Y09M"))
fn:not(xs:yearMonthDuration("P10Y09M") le xs:yearMonthDuration("P10Y07M"))
fn:not(xs:yearMonthDuration("P11Y04M") div xs:yearMonthDuration("P02Y11M"))
fn:not(xs:yearMonthDuration("P20Y09M") gt xs:yearMonthDuration("P20Y10M"))
fn:not(xs:yearMonthDuration("P20Y10M") ge xs:yearMonthDuration("P20Y10M"))
fn:not(xs:yearMonthDuration("P20Y10M") le xs:yearMonthDuration("P20Y10M"))
fn:not(xs:yearMonthDuration("P20Y10M") lt xs:yearMonthDuration("P20Y09M"))
fn:not((xs:yearMonthDuration("P20Y10M") lt xs:yearMonthDuration("P20Y11M")))
fn:not((xs:yearMonthDuration("P20Y123M") gt xs:yearMonthDuration("P20Y11M")))
fn:number(())
fn:number()
fn:number(.)
fn:number(1.1) instance of xs:double
fn:number(1) eq 1
fn:number(1) instance of xs:double
fn:number("A String")
fn:number(fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")))
fn:number(fn:timezone-from-date(xs:date("1970-01-02+10:00")))
fn:number(fn:timezone-from-time(xs:time("10:12:15Z")))
fn:number(()) instance of xs:double
fn:number("NaN") instance of xs:double
fn:number("results in NaN") instance of xs:double
fn:number(xs:date("1988-01-28Z") - xs:date("2001-03-02"))
fn:number(xs:dateTime("1988-01-28T10:09:08Z") - xs:dateTime("1987-01-01T01:01:02Z"))
fn:number(xs:dayTimeDuration("P02DT06H09M") *2.0)
fn:number(xs:dayTimeDuration("P02DT06H09M") div 2.0)
fn:number(xs:dayTimeDuration("P02DT06H09M") div xs:dayTimeDuration("P02DT06H09M"))
fn:number(xs:dayTimeDuration("P02DT06H09M") + xs:dayTimeDuration("P10DT08H01M"))
fn:number(xs:dayTimeDuration("P02DT06H09M") - xs:dayTimeDuration("P10DT08H01M"))
fn:number(xs:decimal("617375191608514839")) eq 617375191608514839
fn:number(xs:double("0"))
fn:number(xs:double("-1.7976931348623157E308"))
fn:number(xs:double("1.7976931348623157E308"))
fn:number(xs:double(3)) instance of xs:double
fn:number(xs:float("0"))
fn:number(xs:float(3)) instance of xs:double
fn:number(xs:negativeInteger("-1"))
fn:number(xs:nonNegativeInteger("0"))
fn:number(xs:nonPositiveInteger("0"))
fn:number(xs:positiveInteger("1"))
fn:number(xs:short("32767"))
fn:number(xs:short("-32768"))
fn:number(xs:short("-5324"))
fn:number(xs:time("13:00:00Z") - xs:time("12:00:00Z"))
fn:number(xs:unsignedLong("0"))
fn:number(xs:unsignedShort("0"))
fn:number(xs:unsignedShort("44633"))
fn:number(xs:unsignedShort("65535"))
fn:number(xs:yearMonthDuration("P02Y09M") * 2.0)
fn:number(xs:yearMonthDuration("P02Y09M") div 2.0)
fn:number(xs:yearMonthDuration("P02Y09M") div xs:yearMonthDuration("P02Y09M"))
fn:number(xs:yearMonthDuration("P02Y09M") + xs:yearMonthDuration("P10Y01M"))
fn:number(xs:yearMonthDuration("P02Y09M") - xs:yearMonthDuration("P10Y01M"))
fn:one-or-more(())
fn:one-or-more(xs:double("0"))
fn:one-or-more(xs:double("-1.7976931348623157E308"))
fn:one-or-more(xs:double("1.7976931348623157E308"))
fn:one-or-more(xs:float("0"))
fn:one-or-more(xs:float("-3.4028235E38"))
fn:one-or-more(xs:float("3.4028235E38"))
fn:one-or-more(xs:int("-1873914410"))
fn:one-or-more(xs:int("2147483647"))
fn:one-or-more(xs:int("-2147483648"))
fn:one-or-more(xs:negativeInteger("-1"))
fn:one-or-more(xs:nonNegativeInteger("0"))
fn:one-or-more(xs:nonPositiveInteger("0"))
fn:one-or-more(xs:positiveInteger("1"))
fn:one-or-more(xs:short("32767"))
fn:one-or-more(xs:short("-32768"))
fn:one-or-more(xs:short("-5324"))
fn:one-or-more(xs:unsignedLong("0"))
fn:one-or-more(xs:unsignedShort("0"))
fn:one-or-more(xs:unsignedShort("44633"))
fn:one-or-more(xs:unsignedShort("65535"))
fn:outermost( / )
fn:outermost( //* )
fn:outermost( //*/@* )
fn:outermost()
fn:outermost( ($doc1//node(), $doc2//node()) )
fn:outermost#0
fn:outermost( (), 1 )
fn:outermost( 1 )
fn:outermost#2
fn:outermost( //comment() )
fn:outermost( //comment() ) ! string()
fn:outermost( fn:dateTime#2 )
( fn:outermost( if (current-date() eq xs:date('1900-01-01'))                                  then .                                  else 1 ),               fn:outermost( if (current-date() eq xs:date('1900-01-01'))                                  then 1                                  else . ) )
( fn:outermost( if (current-date() eq xs:date('1900-01-01'))                                  then .                                  else fn:dateTime#2 ),               fn:outermost( if (current-date() eq xs:date('1900-01-01'))                                  then fn:dateTime#2                                  else . ) )
fn:outermost( //* ) ! local-name(.)
fn:outermost( //node() )
fn:outermost( //processing-instruction() )
fn:outermost( //processing-instruction() ) ! local-name()
fn:outermost( /root/descendant::node() )
fn:outermost( /root/level[1]/following-sibling::node() )
fn:outermost( /root/level[1]/level[1]/ancestor::node() )
fn:outermost( /root/level[1]/level[1]/following::node() )
fn:outermost( /root/level[1]/level[last()]/preceding::node() )
fn:outermost( /root/level[1]/level[last()]/preceding-sibling::node() )
fn:outermost( /root/node() )
fn:outermost( /root/node()/.. )
fn:outermost( //*/@* ) ! string()
fn:outermost( //text() )
fn:outermost( //text() ) ! string()
fn:path(())
fn:path(/)
fn:path(/*)
fn:path(<a><b/><b/></a>/(b[2]))
fn:path(<a b="c"/>/@b)
fn:path((//*:all-of)[1])
fn:path(attribute name {"fred"})
fn:path((//comment())[2])
fn:path((//@idref)[1])
fn:path(//*[@name="fn-absintg1args-1"])
fn:path(//p)
fn:path(//processing-instruction()[1])
fn:path((//*:source)[3]/@xml:id)
fn:path(//text()[.='2147483647'][1])
fn:path(text{"fred"})
fn:prefix-from-QName("arg1","arg2")
fn:prefix-from-QName(node-name(/*))
fn:prefix-from-QName(node-name((//@*)[1]))
fn:prefix-from-QName(xs:integer(1))
fn:prefix-from-QName(xs:QName("foo:bar"))
fn:QName('', ' ')
fn:QName((), ())
fn:QName("", "ht:person")
fn:QName((), "ht:person")
fn:QName("http://www.example.com/example")
fn:QName("http://www.example.com/example", "1person")
fn:QName("http://www.example.com/example1", "person") eq fn:QName("http://www.example.com/example2", "person")
fn:QName("http://www.example.com/example1", "person") ne fn:QName("http://www.example.com/example2", "person")
fn:QName("http://www.example.com/example1", "px1:person1") eq fn:QName("http://www.example.com/example2","px2:person2")
fn:QName("http://www.example.com/example1", "px1:person1") ne fn:QName("http://www.example.com/example2","px2:person2")
fn:QName("http://www.example.com/example", "-person")
fn:QName("http://www.example.com/example", ":person")
fn:QName("http://www.example.com/example", "<person>")
fn:QName("http://www.example.com/example", "@person")
fn:QName("http://www.example.com/example", "person:")
fn:QName("http://www.example.com/example", "person1") eq fn:QName("http://www.example.com/example","person2")
fn:QName("http://www.example.com/example", "person1") ne fn:QName("http://www.example.com/example","person2")
fn:QName("http://www.example.com/example", "person") eq fn:QName("http://www.example.com/example", "person")
fn:QName("http://www.example.com/example", "person") eq fn:QName("","person")
fn:QName("http://www.example.com/example", "person") ne fn:QName("http://www.example.com/example", "person")
fn:QName("http://www.example.com/example", "person") ne fn:QName("","person")
fn:QName("http://www.example.com/example", "px1:person1") eq fn:QName("http://www.example.com/example","px2:person2")
fn:QName("http://www.example.com/example", "px1:person1") ne fn:QName("http://www.example.com/example","px2:person2")
fn:QName("http://www.example.com/example", "px1:person") eq fn:QName("http://www.example.com/example","px1:person")
fn:QName("http://www.example.com/example", "px1:person") eq fn:QName("http://www.example.com/example","px2:person")
fn:QName("http://www.example.com/example", "px1:person") ne fn:QName("http://www.example.com/example","px1:person")
fn:QName("http://www.example.com/example", "px1:person") ne fn:QName("http://www.example.com/example","px2:person")
(fn:QName("http://www.example.com/example", "px:person") eq fn:QName("http://www.example.com/example","px:person")) and fn:true()
(fn:QName("http://www.example.com/example", "px:person") ne fn:QName("http://www.example.com/example","px:person")) and fn:true()
fn:QName("http://www.example.com/example", xs:integer("100"))
fn:QName("person")
fn:QName("", "person") eq fn:QName("http://www.example.com/example","person")
fn:QName("", "person") eq fn:QName("","person")
fn:QName("", "person") ne fn:QName("http://www.example.com/example","person")
fn:QName("", "person") ne fn:QName("","person")
fn:QName( xs:integer("100"), "person" )
fn:remove ( ("a", "b", "c"), 0)
fn:remove ( ("a", "b", "c"), 1)
fn:remove ( ("a", "b", "c", true()), 3)
fn:remove( (xs:anyURI("www.example.com"), "a", (""), "b"), 10)
fn:remove( (xs:anyURI("www.example.com"), "a", (""), "b"), 2)
fn:remove( (xs:anyURI("www.example.com"), "a", (""), "b"), -20)
fn:remove( (xs:boolean("0")), 2 )
fn:remove( (xs:boolean("1"), xs:double("-INF"), "s"), 3)
fn:remove( (xs:boolean("true"), xs:date("1993-03-31"), 4, "a"),3)
fn:remove( (xs:dateTime("1972-12-31T00:00:00"), xs:boolean("false"), (), (" ")) ,3)
fn:remove( (xs:decimal("1.01"), xs:integer("12"), xs:anyURI("www.example.com")),3)
fn:remove( (xs:double("1.34"), xs:float("INF"), true()), 1)
fn:remove( (xs:double("INF"), 2, 3), 2)
fn:remove( (xs:double("NaN"), "a", "b"), 3)
fn:remove( (xs:float("1.01"), xs:string("a")), 2)
fn:remove( (xs:float("-INF"), xs:decimal("2.34"), "abc"), 2)
fn:remove( (xs:float("NaN"), 100, (), 2), 2)
fn:remove( (xs:integer("100"), xs:string("abc")), 1)
fn:remove ( (xs:string("xyz"), (), (), "a" , "b"), 2)
fn:remove( (xs:time("12:30:00"), xs:decimal("2.000003"), 2), 2)
fn:reverse(())
fn:reverse()
fn:reverse(10 to 15)
fn:reverse(1, 2)
fn:reverse([1,2,3])
fn:reverse(([1,2,3],[4,5,6]))
fn:reverse(1 to 10)
fn:reverse(("hello"))
fn:reverse((xs:decimal("617375191608514839")))
fn:reverse((xs:decimal("-999999999999999999")))
fn:reverse((xs:decimal("999999999999999999")))
fn:reverse((xs:double("0")))
fn:reverse((xs:double("-1.7976931348623157E308")))
fn:reverse((xs:double("1.7976931348623157E308")))
fn:reverse((xs:float("0")))
fn:reverse((xs:float("-3.4028235E38")))
fn:reverse((xs:float("3.4028235E38")))
fn:reverse((xs:int("-1873914410")))
fn:reverse((xs:int("2147483647")))
fn:reverse((xs:int("-2147483648")))
fn:reverse((xs:negativeInteger("-1")))
fn:reverse((xs:nonNegativeInteger("0")))
fn:reverse((xs:nonPositiveInteger("0")))
fn:reverse((xs:positiveInteger("1")))
fn:reverse((xs:short("32767")))
fn:reverse((xs:short("-32768")))
fn:reverse((xs:short("-5324")))
fn:reverse((xs:unsignedLong("0")))
fn:reverse((xs:unsignedShort("0")))
fn:reverse((xs:unsignedShort("44633")))
fn:reverse((xs:unsignedShort("65535")))
fn:root()
fn:root(.)
fn:root(<!-- A Comment Node -->)
fn:root(<anElement>An Element Content</anElement>)
fn:root(<!-- comment -->)
fn:root(<e/>)
fn:root(element anElement {attribute anAttribute {"Attribute Value"}})
fn:root(<?format role="output" ?>)
fn:root(<?target data?>)
fn:root(text {"A text Node"})
fn:root(text{"text node"})
fn:round(-0.43e0, 1)
fn:round(1.125, 2)
fn:round(-1234.567, -2)
fn:round(-12.567, 0)
fn:round(-12.567, 2)
fn:round(-12.567, 4)
fn:round(1.567, -3)
fn:round(2.4999)
fn:round(-2.5)
fn:round(2.5)
fn:round(3.1415e0, 2)
fn:round(8452, -2)
fn:round-half-to-even(0.5)
fn:round-half-to-even(12345, -2)
fn:round-half-to-even(12345, 2)
fn:round-half-to-even(12345.6, -2)
fn:round-half-to-even(12345.6, 2)
fn:round-half-to-even(123456e-2, -2)
fn:round-half-to-even(123456e-2, 2)
fn:round-half-to-even(123456e-2, "two")
fn:round-half-to-even(1.5)
fn:round-half-to-even(2.5)
fn:round-half-to-even(35612.25, -2)
fn:round-half-to-even(3.567812, 4294967296)
fn:round-half-to-even(3.567812e+3, 2)
fn:round-half-to-even(3.567812E+3, 4294967296)
fn:round-half-to-even(4.7564e-3, 2)
fn:round-half-to-even( (xs:dayTimeDuration("P42DT10H10M") div xs:dayTimeDuration("P10DT10H10M")) div (xs:dayTimeDuration("P20DT10H10M") div xs:dayTimeDuration("P18DT10H10M")) ,15)
fn:round-half-to-even(xs:decimal("617375191608514839"))
fn:round-half-to-even((xs:decimal("617375191608514839") div xs:decimal("-999999999999999999")),18)
fn:round-half-to-even(xs:decimal("-999999999999999999"))
fn:round-half-to-even(xs:decimal("999999999999999999"))
fn:round-half-to-even((xs:decimal("-999999999999999999") div xs:decimal("617375191608514839")),18)
fn:round-half-to-even(xs:double("0"))
fn:round-half-to-even(xs:double("-1.7976931348623157E308"))
fn:round-half-to-even(xs:double("1.7976931348623157E308"))
fn:round-half-to-even(xs:float("0"))
fn:round-half-to-even(xs:float(12345.6), -2)
fn:round-half-to-even(xs:float(12345.6), 2)
fn:round-half-to-even(xs:float("-3.4028235E38"))
fn:round-half-to-even(xs:float("3.4028235E38"))
fn:round-half-to-even(xs:int("-1873914410"))
fn:round-half-to-even((xs:int("-1873914410") div xs:int("-2147483648")),10)
fn:round-half-to-even(xs:int("2147483647"))
fn:round-half-to-even((xs:int("2147483647") div xs:int("-2147483648")),10)
fn:round-half-to-even(xs:int("-2147483648"))
fn:round-half-to-even((xs:int("-2147483648") div xs:int("-1873914410")),10)
fn:round-half-to-even((xs:int("-2147483648") div xs:int("2147483647")),10)
fn:round-half-to-even(xs:negativeInteger("-1"))
fn:round-half-to-even(xs:nonNegativeInteger("0"))
fn:round-half-to-even(xs:nonPositiveInteger("0"))
fn:round-half-to-even(xs:positiveInteger("1"))
fn:round-half-to-even(xs:short(12345), -2)
fn:round-half-to-even(xs:short(12345), 2)
fn:round-half-to-even(xs:short("32767"))
fn:round-half-to-even(xs:short("-32768"))
fn:round-half-to-even((xs:short("-32768") div xs:short("-5324")),5)
fn:round-half-to-even(xs:short("-5324"))
fn:round-half-to-even((xs:short("-5324") div xs:short("-32768")),5)
fn:round-half-to-even(xs:unsignedLong("0"))
fn:round-half-to-even(xs:unsignedShort("0"))
fn:round-half-to-even(xs:unsignedShort("44633"))
fn:round-half-to-even(xs:unsignedShort("65535"))
fn:round(xs:decimal("-12.1"))
fn:round(xs:decimal("12.1"))
fn:round(xs:decimal("-12.5"))
fn:round(xs:decimal("12.5"))
fn:round(xs:decimal("-12.7"))
fn:round(xs:decimal("12.7"))
fn:round(xs:decimal("617375191608514839"))
fn:round(xs:decimal("-999999999999999999"))
fn:round(xs:decimal("999999999999999999"))
fn:round(xs:double("0"))
fn:round(xs:double("-0.00"))
fn:round(xs:double("0.00"))
fn:round(xs:double("-0.01"))
fn:round(xs:double("0.01"))
fn:round(xs:double("-0.04"))
fn:round(xs:double("0.04"))
fn:round(xs:double("-0.05"))
fn:round(xs:double("0.05"))
fn:round(xs:double("-0.06"))
fn:round(xs:double("0.06"))
fn:round(xs:double("-0.09"))
fn:round(xs:double("0.09"))
fn:round(xs:double("-0.10"))
fn:round(xs:double("0.10"))
fn:round(xs:double("-0.100"))
fn:round(xs:double("0.100"))
fn:round(xs:double("-0.101"))
fn:round(xs:double("0.101"))
fn:round(xs:double("-0.104"))
fn:round(xs:double("0.104"))
fn:round(xs:double("-0.105"))
fn:round(xs:double("0.105"))
fn:round(xs:double("-0.106"))
fn:round(xs:double("0.106"))
fn:round(xs:double("-0.109"))
fn:round(xs:double("0.109"))
fn:round(xs:double("-0.11"))
fn:round(xs:double("0.11"))
fn:round(xs:double("-0.14"))
fn:round(xs:double("0.14"))
fn:round(xs:double("-0.15"))
fn:round(xs:double("0.15"))
fn:round(xs:double("-0.16"))
fn:round(xs:double("0.16"))
fn:round(xs:double("-0.19"))
fn:round(xs:double("0.19"))
fn:round(xs:double("-0.40"))
fn:round(xs:double("0.40"))
fn:round(xs:double("-0.41"))
fn:round(xs:double("0.41"))
fn:round(xs:double("-0.44"))
fn:round(xs:double("0.44"))
fn:round(xs:double("-0.45"))
fn:round(xs:double("0.45"))
fn:round(xs:double("-0.46"))
fn:round(xs:double("0.46"))
fn:round(xs:double("-0.49"))
fn:round(xs:double("0.49"))
fn:round(xs:double("-0.50"))
fn:round(xs:double("0.50"))
fn:round(xs:double("-0.51"))
fn:round(xs:double("0.51"))
fn:round(xs:double("-0.54"))
fn:round(xs:double("0.54"))
fn:round(xs:double("-0.55"))
fn:round(xs:double("0.55"))
fn:round(xs:double("-0.56"))
fn:round(xs:double("0.56"))
fn:round(xs:double("-0.59"))
fn:round(xs:double("0.59"))
fn:round(xs:double("-0.60"))
fn:round(xs:double("0.60"))
fn:round(xs:double("-0.61"))
fn:round(xs:double("0.61"))
fn:round(xs:double("-0.64"))
fn:round(xs:double("0.64"))
fn:round(xs:double("-0.65"))
fn:round(xs:double("0.65"))
fn:round(xs:double("-0.66"))
fn:round(xs:double("0.66"))
fn:round(xs:double("-0.69"))
fn:round(xs:double("0.69"))
fn:round(xs:double("-0.90"))
fn:round(xs:double("0.90"))
fn:round(xs:double("-0.91"))
fn:round(xs:double("0.91"))
fn:round(xs:double("-0.94"))
fn:round(xs:double("0.94"))
fn:round(xs:double("-0.95"))
fn:round(xs:double("0.95"))
fn:round(xs:double("-0.96"))
fn:round(xs:double("0.96"))
fn:round(xs:double("-0.99"))
fn:round(xs:double("0.99"))
fn:round(xs:double("-1.7976931348623157E308"))
fn:round(xs:double("1.7976931348623157E308"))
fn:round(xs:double("NaN"))
fn:round(xs:float("0"))
fn:round(xs:float("-0.00"))
fn:round(xs:float("0.00"))
fn:round(xs:float("-0.01"))
fn:round(xs:float("0.01"))
fn:round(xs:float("-0.04"))
fn:round(xs:float("0.04"))
fn:round(xs:float("-0.05"))
fn:round(xs:float("0.05"))
fn:round(xs:float("-0.06"))
fn:round(xs:float("0.06"))
fn:round(xs:float("-0.09"))
fn:round(xs:float("0.09"))
fn:round(xs:float("-0.10"))
fn:round(xs:float("0.10"))
fn:round(xs:float("-0.100"))
fn:round(xs:float("0.100"))
fn:round(xs:float("-0.101"))
fn:round(xs:float("0.101"))
fn:round(xs:float("-0.104"))
fn:round(xs:float("0.104"))
fn:round(xs:float("-0.105"))
fn:round(xs:float("0.105"))
fn:round(xs:float("-0.106"))
fn:round(xs:float("0.106"))
fn:round(xs:float("-0.109"))
fn:round(xs:float("0.109"))
fn:round(xs:float("-0.11"))
fn:round(xs:float("0.11"))
fn:round(xs:float(0.125), 2)
fn:round(xs:float("-0.14"))
fn:round(xs:float("0.14"))
fn:round(xs:float("-0.15"))
fn:round(xs:float("0.15"))
fn:round(xs:float("-0.16"))
fn:round(xs:float("0.16"))
fn:round(xs:float("-0.19"))
fn:round(xs:float("0.19"))
fn:round(xs:float("-0.40"))
fn:round(xs:float("0.40"))
fn:round(xs:float("-0.41"))
fn:round(xs:float("0.41"))
fn:round(xs:float(-0.43e0), 1)
fn:round(xs:float("-0.44"))
fn:round(xs:float("0.44"))
fn:round(xs:float("-0.45"))
fn:round(xs:float("0.45"))
fn:round(xs:float("-0.46"))
fn:round(xs:float("0.46"))
fn:round(xs:float("-0.49"))
fn:round(xs:float("0.49"))
fn:round(xs:float("-0.50"))
fn:round(xs:float("0.50"))
fn:round(xs:float("-0.51"))
fn:round(xs:float("0.51"))
fn:round(xs:float("-0.54"))
fn:round(xs:float("0.54"))
fn:round(xs:float("-0.55"))
fn:round(xs:float("0.55"))
fn:round(xs:float("-0.56"))
fn:round(xs:float("0.56"))
fn:round(xs:float("-0.59"))
fn:round(xs:float("0.59"))
fn:round(xs:float("-0.60"))
fn:round(xs:float("0.60"))
fn:round(xs:float("-0.61"))
fn:round(xs:float("0.61"))
fn:round(xs:float("-0.64"))
fn:round(xs:float("0.64"))
fn:round(xs:float("-0.65"))
fn:round(xs:float("0.65"))
fn:round(xs:float("-0.66"))
fn:round(xs:float("0.66"))
fn:round(xs:float("-0.69"))
fn:round(xs:float("0.69"))
fn:round(xs:float("-0.90"))
fn:round(xs:float("0.90"))
fn:round(xs:float("-0.91"))
fn:round(xs:float("0.91"))
fn:round(xs:float("-0.94"))
fn:round(xs:float("0.94"))
fn:round(xs:float("-0.95"))
fn:round(xs:float("0.95"))
fn:round(xs:float("-0.96"))
fn:round(xs:float("0.96"))
fn:round(xs:float("-0.99"))
fn:round(xs:float("0.99"))
fn:round(xs:float(1.125), 2)
fn:round(xs:float(3.1415e0), 2)
fn:round(xs:float("-3.4028235E38"))
fn:round(xs:float("3.4028235E38"))
fn:round(xs:float(8452), -2)
fn:round(xs:float("NaN"))
fn:round(xs:int("-1873914410"))
fn:round(xs:int("2147483647"))
fn:round(xs:int("-2147483648"))
fn:round(xs:negativeInteger("-1"))
fn:round(xs:nonNegativeInteger("0"))
fn:round(xs:nonPositiveInteger("0"))
fn:round(xs:positiveInteger("1"))
fn:round(xs:short("32767"))
fn:round(xs:short("-32768"))
fn:round(xs:short("-5324"))
fn:round(xs:unsignedLong("0"))
fn:round(xs:unsignedShort("0"))
fn:round(xs:unsignedShort("44633"))
fn:round(xs:unsignedShort("65535"))
fn:seconds-from-dateTime(fn:current-dateTime())
fn:seconds-from-dateTime(fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00")))
fn:seconds-from-dateTime(xs:dateTime("1970-01-01T00:00:00Z"))
fn:seconds-from-dateTime(xs:dateTime("1970-01-01T00:00:10Z")) - fn:seconds-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:seconds-from-dateTime(xs:dateTime("1970-01-01T00:00:10Z")) + fn:seconds-from-dateTime(xs:dateTime("1970-01-01T10:00:11Z"))
fn:seconds-from-dateTime(xs:dateTime("1970-01-01T02:02:02Z")) * fn:seconds-from-dateTime(xs:dateTime("1970-01-01T10:03:03Z"))
fn:seconds-from-dateTime(xs:dateTime("1970-01-01T02:10:10Z")) div fn:seconds-from-dateTime(xs:dateTime("1970-01-01T10:05:05Z"))
+fn:seconds-from-dateTime(xs:dateTime("1970-01-01T10:10:10Z"))
-fn:seconds-from-dateTime(xs:dateTime("1970-01-01T10:10:10Z"))
fn:seconds-from-dateTime(xs:dateTime("1970-01-01T10:10:10Z")) eq fn:seconds-from-dateTime(xs:dateTime("1970-01-01T10:10:10Z"))
fn:seconds-from-dateTime(xs:dateTime("1970-01-01T10:10:10Z")) ge fn:seconds-from-dateTime(xs:dateTime("1970-01-01T10:10:10Z"))
fn:seconds-from-dateTime(xs:dateTime("1970-01-01T10:10:10Z")) idiv fn:seconds-from-dateTime(xs:dateTime("1970-01-01T02:05:05Z"))
fn:seconds-from-dateTime(xs:dateTime("1970-01-01T10:10:10Z")) le fn:seconds-from-dateTime(xs:dateTime("1970-01-01T10:10:10Z"))
fn:seconds-from-dateTime(xs:dateTime("1970-01-01T10:10:10Z")) mod fn:seconds-from-dateTime(xs:dateTime("1970-01-01T03:10:10Z"))
fn:seconds-from-dateTime(xs:dateTime("1970-01-01T10:10:10Z")) ne fn:seconds-from-dateTime(xs:dateTime("1970-01-01T10:10:10Z"))
fn:seconds-from-dateTime(xs:dateTime("1996-04-07T01:40:52Z"))
fn:seconds-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))
fn:seconds-from-dateTime(xs:dateTime("1999-05-31T20:00:00-05:00"))
fn:seconds-from-dateTime(xs:dateTime("1999-05-31T23:59:59-05:00"))
fn:seconds-from-dateTime(xs:dateTime("1999-12-31T21:20:20-05:00")) le fn:seconds-from-dateTime(xs:dateTime("1999-12-31T21:20:20-05:00"))
fn:seconds-from-dateTime(xs:dateTime("1999-12-31T21:20:20-05:00")) lt fn:seconds-from-dateTime(xs:dateTime("1999-12-31T21:20:20-05:00"))
fn:seconds-from-dateTime(xs:dateTime("2030-12-31T23:59:59Z"))
fn:seconds-from-duration(xs:dayTimeDuration("P01DT01H01M01S"))
fn:seconds-from-duration(xs:dayTimeDuration("P0DT0H0M0S"))
fn:seconds-from-duration(xs:dayTimeDuration("P10DT10H20M10S")) mod fn:seconds-from-duration(xs:dayTimeDuration("P03DT03H03M03S"))
fn:seconds-from-duration(xs:dayTimeDuration("P15DT11H59M59S"))
fn:seconds-from-duration(xs:dayTimeDuration("P20DT03H09M20S")) le fn:seconds-from-duration(xs:dayTimeDuration("P21DT15H21M31S"))
-fn:seconds-from-duration(xs:dayTimeDuration("P20DT03H20M30S"))
fn:seconds-from-duration(xs:dayTimeDuration("P20DT09H04M20S")) * fn:seconds-from-duration(xs:dayTimeDuration("P03DT10H10M03S"))
fn:seconds-from-duration(xs:dayTimeDuration("P20DT10H10M30S")) div fn:seconds-from-duration(xs:dayTimeDuration("P05DT05H02M02S"))
fn:seconds-from-duration(xs:dayTimeDuration("P20DT20H20M10S")) lt fn:seconds-from-duration(xs:dayTimeDuration("P03DT02H10M20S"))
fn:seconds-from-duration(xs:dayTimeDuration("P21DT07H12M59S")) ge fn:seconds-from-duration(xs:dayTimeDuration("P20DT01H13M01S"))
fn:seconds-from-duration(xs:dayTimeDuration("P21DT10H10M09S")) + fn:seconds-from-duration(xs:dayTimeDuration("P22DT11H30M21S"))
fn:seconds-from-duration(xs:dayTimeDuration("P21DT10H10M09S")) le fn:seconds-from-duration(xs:dayTimeDuration("P22DT10H09M31S"))
+fn:seconds-from-duration(xs:dayTimeDuration("P21DT10H10M20S"))
fn:seconds-from-duration(xs:dayTimeDuration("P21DT10H10M90S"))
fn:seconds-from-duration(xs:dayTimeDuration("P22DT10H10M01S")) eq fn:seconds-from-duration(xs:dayTimeDuration("P22DT09H10M01S"))
fn:seconds-from-duration(xs:dayTimeDuration("P23DT08H20M02S")) ne fn:seconds-from-duration(xs:dayTimeDuration("P12DT05H22M03S"))
fn:seconds-from-duration(xs:dayTimeDuration("P25DT10H20M40S")) idiv fn:seconds-from-duration(xs:dayTimeDuration("P05DT02H04M20S"))
fn:seconds-from-duration(xs:dayTimeDuration("P30DT10H20M10S")) - fn:seconds-from-duration(xs:dayTimeDuration("P10DT09H10M02S"))
fn:seconds-from-duration(xs:dayTimeDuration("P31DT23H59M59S"))
fn:seconds-from-duration(xs:dayTimeDuration("P3DT10H12.5S"))
fn:seconds-from-duration(xs:dayTimeDuration("-PT256S"))
fn:seconds-from-duration(xs:duration("P1Y2M3DT10H30M911S"))
fn:seconds-from-duration(xs:yearMonthDuration('P1Y'))
fn:seconds-from-time(fn:current-time())
fn:seconds-from-time(xs:time("00:00:00Z"))
fn:seconds-from-time(xs:time("01:23:02Z")) gt fn:seconds-from-time(xs:time("01:23:03Z"))
fn:seconds-from-time(xs:time("02:00:00Z")) + fn:seconds-from-time(xs:time("10:00:10Z"))
fn:seconds-from-time(xs:time("02:02:03Z")) * fn:seconds-from-time(xs:time("10:08:09Z"))
fn:seconds-from-time(xs:time("08:03:35Z"))
fn:seconds-from-time(xs:time("10:00:00Z")) le fn:seconds-from-time(xs:time("10:00:00Z"))
+fn:seconds-from-time(xs:time("10:00:01Z"))
fn:seconds-from-time(xs:time("10:00:01Z")) ne fn:seconds-from-time(xs:time("01:01:00Z"))
fn:seconds-from-time(xs:time("10:02:01Z")) eq fn:seconds-from-time(xs:time("10:02:00Z"))
fn:seconds-from-time(xs:time("10:03:01Z")) ge fn:seconds-from-time(xs:time("10:04:02Z"))
-fn:seconds-from-time(xs:time("10:10:01Z"))
fn:seconds-from-time(xs:time("10:10:10Z")) - fn:seconds-from-time(xs:time("09:02:07Z"))
fn:seconds-from-time(xs:time("10:10:20Z")) mod fn:seconds-from-time(xs:time("03:03:02Z"))
fn:seconds-from-time(xs:time("10:12:15Z")) idiv fn:seconds-from-time(xs:time("02:02:03Z"))
fn:seconds-from-time(xs:time("13:20:10.5"))
fn:seconds-from-time(xs:time("21:23:04Z")) lt fn:seconds-from-time(xs:time("21:24:00Z"))
fn:seconds-from-time(xs:time("22:33:10Z")) div fn:seconds-from-time(xs:time("02:11:02Z"))
fn:seconds-from-time(xs:time("23:20:59Z"))
fn:seconds-from-time(xs:time("23:59:59Z"))
fn:starts-with ((), ())
fn:starts-with("","")
fn:starts-with("",())
fn:starts-with((),"")
fn:starts-with("a","A")
fn:starts-with("A","a")
fn:starts-with(" ","AAAAABBBBB")
fn:starts-with("AAAAABBBBB"," ")
fn:starts-with("AAAAABBBBBCCCCC","BBBBB")
fn:starts-with("","A Character String")
fn:starts-with("A Character String","")
fn:starts-with("A Character String",())
fn:starts-with((),"A Character String")
fn:starts-with("A",xs:string("A"))
fn:starts-with(fn:prefix-from-QName(xs:QName("foo:bar")),"f")
fn:starts-with("Query","Que") eq xs:boolean("false")
fn:starts-with ( "tattoo", "att")
fn:starts-with("tattoo", "tat")
fn:starts-with(xs:string("A"),"A")
fn:starts-with(xs:string("This is a characte"),xs:string("This is a characte"))
fn:string(())
fn:string()
fn:string(.)
fn:string(("abc" || "de"))
fn:string(attribute attr {'a', element a {}, 'b'})
fn:string(comment {'a', element a {}, 'b'})
fn:string(<elem>a<a/>b</elem>)
fn:string(element elem {'a', element a {}, 'b'})
fn:string(fn:concat("abc","de"))
fn:string(fn:current-date()) and fn:false()
fn:string(fn:current-date()) and fn:true()
fn:string(fn:current-date()) eq fn:string(fn:current-date())
fn:string(fn:current-date()) ge fn:string(fn:current-date())
fn:string(fn:current-date()) le fn:string(fn:current-date())
fn:string(fn:current-date()) ne fn:string(fn:current-date())
fn:string(fn:current-date()) or fn:false()
fn:string(fn:current-date()) or fn:true()
fn:string(fn:current-dateTime()) and fn:false()
fn:string(fn:current-dateTime()) and fn:true()
fn:string(fn:current-dateTime()) eq fn:string(fn:current-dateTime())
fn:string(fn:current-dateTime()) ge fn:string(fn:current-dateTime())
fn:string(fn:current-dateTime()) le fn:string(fn:current-dateTime())
fn:string(fn:current-dateTime()) ne fn:string(fn:current-dateTime())
fn:string(fn:current-dateTime()) or fn:false()
fn:string(fn:current-dateTime()) or fn:true()
fn:string(fn:current-time()) and fn:false()
fn:string(fn:current-time()) and fn:true()
fn:string(fn:current-time()) eq fn:string(fn:current-time())
fn:string(fn:current-time()) ge fn:string(fn:current-time())
fn:string(fn:current-time()) le fn:string(fn:current-time())
fn:string(fn:current-time()) ne fn:string(fn:current-time())
fn:string(fn:current-time()) or fn:false()
fn:string(fn:current-time()) or fn:true()
fn:string(fn:false())
fn:string(fn:implicit-timezone() * -0)
fn:string(fn:implicit-timezone() * 0)
fn:string(fn:implicit-timezone() * (0 div 0E0))
fn:string(fn:implicit-timezone() div -0 )
fn:string(fn:implicit-timezone() div 0 )
fn:string(fn:implicit-timezone() div ( 0 div 0E0))
fn:string(fn:implicit-timezone() div xs:dayTimeDuration("P0DT60M00S"))
fn:string(fn:implicit-timezone() div xs:double(2))
fn:string(fn:implicit-timezone() + fn:implicit-timezone())
fn:string(fn:implicit-timezone() - fn:implicit-timezone())
fn:string(fn:not("true"))
fn:string(fn:prefix-from-QName(xs:QName("foo:name")))
fn:string(fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")))
fn:string(fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))) and fn:string(fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")))
fn:string(fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))) or fn:string(fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")))
fn:string(fn:timezone-from-date(xs:date("1970-01-01Z")))
fn:string(fn:timezone-from-date(xs:date("1970-01-01Z"))) and fn:string(fn:timezone-from-date(xs:date("1970-01-01Z")))
fn:string(fn:timezone-from-date(xs:date("1970-01-01Z"))) or fn:string(fn:timezone-from-date(xs:date("1970-01-01Z")))
fn:string(fn:timezone-from-time(xs:time("10:00:01Z")))
fn:string(fn:timezone-from-time(xs:time("10:03:01Z"))) or fn:string(fn:timezone-from-time(xs:time("10:04:02Z")))
fn:string(fn:timezone-from-time(xs:time("10:10:01Z"))) and fn:string(fn:timezone-from-time(xs:time("10:10:01Z")))
fn:string(fn:translate("ABC", "ABC", "ABC"))
fn:string(fn:true())
fn:string-join("****","***")
fn:string-join(("1", "2", "3"))
fn:string-join("12345","1234")
fn:string-join(1 to 5, "")
fn:string-join(1 to 5, ', ')
fn:string-join(1 to 9)
fn:string-join((1 to 9)!string())
fn:string-join(("a"),"A")
fn:string-join(("A"),"a")
fn:string-join(("AAAAABBBBB")," ")
fn:string-join(("AAAAABBBBBCCCCC"),"BBBBB")
fn:string-join(("A"),xs:string("A"))
fn:string-join(('Blow, ', 'blow, ', 'thou ', 'winter ', 'wind!'),                   '')
fn:string-join(('Blow, ', 'blow, ', 'thou ', 'winter ', 'wind!'), '')
fn:string-join((current-date(), current-time(), current-dateTime()), '#')
fn:string-join((fn:codepoints-to-string((49,97)),'ab'),'')
fn:string-join((fn:prefix-from-QName(xs:QName("foo:bar")),":bar"),"")
fn:string-join(('Now', 'is', 'the', 'time', '...'),                   ' ')
fn:string-join(('Now', 'is', 'the', 'time', '...'), ' ')
fn:string-join((), 'separator')
fn:string-join("string-join","nioj-gnirts")
fn:string-join("string-join","string-join")
fn:string-join(("string-joinstring-join"),"string-join")
fn:string-join(string-to-codepoints('abc'), '-')
fn:string-join((xs:string#1, xs:gYear#1, xs:float#1, xs:double#1, xs:integer#1)!'1900', ',')
fn:string-join((xs:string("A")),"A")
fn:string-join(xs:string("This is a characte"),xs:string("This is a characte"))
fn:string-length("")
fn:string-length("*****")
fn:string-length(())
fn:string-length()
fn:string-length("%$#@!")
fn:string-length("12345")
fn:string-length("12345abcd")
fn:string-length("abc") and fn:string-length("abc")
fn:string-length("ABCD")
fn:string-length("abcde")
fn:string-length("ABCDEabcde")
fn:string-length(.//employee/@name )
fn:string-length(fn:codepoints-to-string((49,97)))
fn:string-length(fn:name(()))
fn:string-length(fn:name(.))
fn:string-length(fn:name(./works[1]/employee[2]/@name))
fn:string-length(fn:name(./works[1]/nonexistent[1]))
fn:string-length(fn:prefix-from-QName(xs:QName("foo:bar")))
fn:string-length(fn:string("AbcDH"))
fn:string-length(fn:translate("ABC","ABC","ABC"))
fn:string-length("Harp not on that string, madam; that is past.")
fn:string-length(if (2 != 3) then 'foo' else 'expanded-foo')
fn:string-length(string((<elem attr="&amp;&lt;&gt;"/>)/@attr))
fn:string-length("string-length")
fn:string-length(xs:date('2007-11-29'))
fn:string-length(xs:string(fn:false()))
fn:string-length(xs:string(fn:not("true")))
fn:string-length(xs:string(fn:prefix-from-QName(xs:QName("name"))))
fn:string-length(xs:string(fn:true()))
fn:string-length(xs:string("This is a characte"))
fn:string-length("zzzzz") + fn:string-length("zzzzz")
fn:string(processing-instruction pi {'a', element a {}, 'b'})
fn:string(text {'a', element a {}, 'b'})
fn:string-to-codepoints("")
fn:string-to-codepoints('#*^$')
fn:string-to-codepoints('1')
fn:string-to-codepoints('1a')
fn:string-to-codepoints('a')
fn:string-to-codepoints(fn:codepoints-to-string((49,97)))
fn:string-to-codepoints(fn:lower-case("A String"))
fn:string-to-codepoints(fn:lower-case(fn:codepoints-to-string(160 to 256)))
fn:string-to-codepoints(fn:lower-case(fn:codepoints-to-string(459)))
fn:string-to-codepoints(fn:upper-case("A String"))
fn:string-to-codepoints(fn:upper-case(fn:codepoints-to-string(160 to 256)))
fn:string-to-codepoints(fn:upper-case(fn:codepoints-to-string(223)))
fn:string-to-codepoints(fn:upper-case(fn:codepoints-to-string(459)))
fn:string-to-codepoints(fn:upper-case(fn:codepoints-to-string(64279)))
fn:string-to-codepoints('string-to-codepoints')
fn:string-to-codepoints("Thérèse")
fn:string-to-codepoints(xs:string("A String"))
fn:string-to-codepoints(xs:string("This is a characte"))
fn:string((xs:date("1977-12-12Z") - xs:date("1976-12-12Z"))) ge xs:string(xs:dayTimeDuration("P17DT10H02M"))
fn:string((xs:date("1978-12-12Z") - xs:date("1977-03-12Z"))) le xs:string(xs:dayTimeDuration("P17DT10H02M"))
fn:string((xs:date("1979-12-12Z") - xs:date("1979-11-11Z"))) ne xs:string(xs:dayTimeDuration("P17DT10H02M"))
fn:string((xs:date("1980-03-02Z") - xs:date("2001-09-11Z"))) and (fn:true())
fn:string((xs:date("1980-05-05Z") - xs:date("1981-12-03Z"))) eq xs:string(xs:dayTimeDuration("P17DT10H02M"))
fn:string((xs:date("1985-07-05Z") - xs:date("1977-12-02Z"))) or fn:string((xs:date("1985-07-05Z") - xs:date("1960-11-07Z")))
fn:string(xs:date("1989-07-05Z") - xs:date("1962-09-04Z"))
fn:string((xs:date("1993-12-09Z") - xs:date("1992-10-02Z"))) and fn:string((xs:date("1993-12-09Z") - xs:date("1980-10-20Z")))
fn:string((xs:date("1999-10-23Z") - xs:date("1998-09-09Z"))) or fn:false()
fn:string(xs:date("2000-12-12Z") - xs:date("2000-11-11Z")) and fn:false()
fn:string((xs:dateTime("1977-12-12T01:02:02Z") - xs:dateTime("1976-12-12T02:03:04Z"))) ge xs:string(xs:dayTimeDuration("P18DT02H02M"))
fn:string((xs:dateTime("1978-12-12T10:09:08Z") - xs:dateTime("1977-12-12T09:08:07Z"))) le xs:string(xs:dayTimeDuration("P17DT10H02M"))
fn:string((xs:dateTime("1979-12-12T16:16:16Z") - xs:dateTime("1978-12-12T17:17:17Z"))) ne xs:string(xs:dayTimeDuration("P17DT10H02M"))
fn:string((xs:dateTime("1980-03-02T11:11:11Z") - xs:dateTime("1981-12-12T12:12:12Z"))) and (fn:true())
fn:string((xs:dateTime("1980-05-05T13:13:13Z") - xs:dateTime("1979-10-05T14:14:14Z"))) eq xs:string(xs:dayTimeDuration("P17DT10H02M"))
fn:string((xs:dateTime("1985-07-05T07:07:07Z") - xs:dateTime("1984-07-05T08:08:08Z"))) or fn:string((xs:dateTime("1985-07-05T09:09:09Z") - xs:dateTime("1984-07-05T10:10:10Z")))
fn:string(xs:dateTime("1989-07-05T02:02:02Z") - xs:dateTime("1988-01-28T03:03:03Z"))
fn:string((xs:dateTime("1993-12-09T04:04:04Z") - xs:dateTime("1992-12-09T05:05:05Z"))) and fn:string((xs:dateTime("1993-12-09T01:01:01Z") - xs:dateTime("1992-12-09T06:06:06Z")))
fn:string((xs:dateTime("1999-10-23T03:02:01Z") - xs:dateTime("1998-09-09T04:04:05Z"))) or fn:false()
fn:string(xs:dateTime("2000-12-12T12:07:08Z") - xs:dateTime("1999-12-12T13:08:09Z")) and fn:false()
fn:string((xs:dayTimeDuration("P01DT02H01M") * 2.0)) and fn:string((xs:dayTimeDuration("P02DT03H03M") * 2.0 ))
fn:string((xs:dayTimeDuration("P01DT02H01M") div 2.0)) and fn:string((xs:dayTimeDuration("P02DT03H03M") div 2.0 ))
fn:string((xs:dayTimeDuration("P01DT02H01M") + xs:dayTimeDuration("P02DT09H02M"))) and fn:string((xs:dayTimeDuration("P02DT03H03M") + xs:dayTimeDuration("P04DT04H04M")))
fn:string((xs:dayTimeDuration("P01DT02H01M") - xs:dayTimeDuration("P02DT09H02M"))) and fn:string((xs:dayTimeDuration("P02DT03H03M") - xs:dayTimeDuration("P04DT04H04M")))
fn:string(xs:dayTimeDuration("P03DT04H08M") * 2.0)
fn:string(xs:dayTimeDuration("P03DT04H08M") div 2.0)
fn:string(xs:dayTimeDuration("P03DT04H08M") + xs:dayTimeDuration("P01DT09H02M"))
fn:string(xs:dayTimeDuration("P03DT04H08M") - xs:dayTimeDuration("P01DT09H02M"))
fn:string((xs:dayTimeDuration("P05DT09H02M") * 2.0)) or fn:string((xs:dayTimeDuration("P05DT05H03M") * 2.0))
fn:string((xs:dayTimeDuration("P05DT09H02M") div 2.0)) or fn:string((xs:dayTimeDuration("P05DT05H03M") div 2.0))
fn:string((xs:dayTimeDuration("P05DT09H02M") + xs:dayTimeDuration("P03DT01H04M"))) or fn:string((xs:dayTimeDuration("P05DT05H03M") + xs:dayTimeDuration("P01DT01H03M")))
fn:string((xs:dayTimeDuration("P05DT09H02M") - xs:dayTimeDuration("P03DT01H04M"))) or fn:string((xs:dayTimeDuration("P05DT05H03M") - xs:dayTimeDuration("P01DT01H03M")))
fn:string(xs:dayTimeDuration("P08DT06H08M") div xs:dayTimeDuration("P08DT06H08M"))
fn:string((xs:dayTimeDuration("P10DT08H11M") * 2.0)) and (fn:true())
fn:string((xs:dayTimeDuration("P10DT08H11M") div 2.0)) and (fn:true())
fn:string((xs:dayTimeDuration("P10DT08H11M") + xs:dayTimeDuration("P05DT08H11M"))) and (fn:true())
fn:string((xs:dayTimeDuration("P10DT08H11M") - xs:dayTimeDuration("P05DT08H11M"))) and (fn:true())
fn:string((xs:dayTimeDuration("P10DT10H11M")) * 2.0) and fn:false()
fn:string((xs:dayTimeDuration("P10DT10H11M")) div 2.0) and fn:false()
fn:string(xs:dayTimeDuration("P10DT10H11M") + xs:dayTimeDuration("P12DT10H07M")) and fn:false()
fn:string(xs:dayTimeDuration("P10DT10H11M") - xs:dayTimeDuration("P12DT10H07M")) and fn:false()
fn:string((xs:dayTimeDuration("P20DT20H10M") * 2.0)) or fn:false()
fn:string((xs:dayTimeDuration("P20DT20H10M") div 2.0)) or fn:false()
fn:string(xs:dayTimeDuration("P20DT20H10M") + xs:dayTimeDuration("P19DT13H10M")) or fn:false()
fn:string(xs:dayTimeDuration("P20DT20H10M") - xs:dayTimeDuration("P19DT13H10M")) or fn:false()
fn:string(xs:double("-0"))
fn:string(xs:double("0"))
fn:string(xs:double("-1.7976931348623157E308"))
fn:string(xs:double("1.7976931348623157E308"))
fn:string(xs:float("-0"))
fn:string(xs:float("0"))
fn:string(xs:float("-3.4028235E38"))
fn:string(xs:float("3.4028235E38"))
fn:string(xs:int("-1873914410"))
fn:string(xs:int("2147483647"))
fn:string(xs:int("-2147483648"))
fn:string(xs:negativeInteger("-1"))
fn:string(xs:nonNegativeInteger("0"))
fn:string(xs:nonPositiveInteger("0"))
fn:string(xs:positiveInteger("1"))
fn:string(xs:short("32767"))
fn:string(xs:short("-32768"))
fn:string(xs:short("-5324"))
fn:string((xs:time("13:00:00Z") - xs:time("12:00:00Z"))) and fn:string((xs:time("13:00:00Z") - xs:time("10:00:00Z")))
fn:string(xs:time("13:00:00Z") - xs:time("17:00:00Z"))
fn:string((xs:time("13:00:00Z") - xs:time("17:00:00Z"))) or fn:string((xs:time("13:00:00Z") - xs:time("17:00:00Z")))
fn:string((xs:time("17:00:00Z") - xs:time("13:00:00Z"))) and (fn:true())
fn:string(xs:unsignedLong("0"))
fn:string(xs:unsignedShort("0"))
fn:string(xs:unsignedShort("44633"))
fn:string(xs:unsignedShort("65535"))
fn:string((xs:yearMonthDuration("P01Y01M") * 2.0)) and fn:string((xs:yearMonthDuration("P02Y03M") * 2.0))
fn:string((xs:yearMonthDuration("P01Y01M") div 2.0)) and fn:string((xs:yearMonthDuration("P02Y03M") div 2.0))
fn:string((xs:yearMonthDuration("P01Y01M") + xs:yearMonthDuration("P02Y02M"))) and fn:string((xs:yearMonthDuration("P02Y03M") + xs:yearMonthDuration("P04Y04M")))
fn:string((xs:yearMonthDuration("P01Y01M") - xs:yearMonthDuration("P02Y02M"))) and fn:string((xs:yearMonthDuration("P02Y03M") - xs:yearMonthDuration("P04Y04M")))
fn:string(xs:yearMonthDuration("P03Y08M") * 2.0)
fn:string(xs:yearMonthDuration("P03Y08M") div 2.0)
fn:string(xs:yearMonthDuration("P03Y08M") div xs:yearMonthDuration("P03Y08M"))
fn:string(xs:yearMonthDuration("P03Y08M") + xs:yearMonthDuration("P01Y02M"))
fn:string(xs:yearMonthDuration("P03Y08M") - xs:yearMonthDuration("P01Y02M"))
fn:string((xs:yearMonthDuration("P05Y02M") * 2.0)) or fn:string((xs:yearMonthDuration("P05Y03M") * 2.0))
fn:string((xs:yearMonthDuration("P05Y02M") div 2.0)) or fn:string((xs:yearMonthDuration("P05Y03M") div 2.0))
fn:string((xs:yearMonthDuration("P05Y02M") + xs:yearMonthDuration("P03Y04M"))) or fn:string((xs:yearMonthDuration("P05Y03M") + xs:yearMonthDuration("P01Y03M")))
fn:string((xs:yearMonthDuration("P05Y02M") - xs:yearMonthDuration("P03Y04M"))) or fn:string((xs:yearMonthDuration("P05Y03M") - xs:yearMonthDuration("P01Y03M")))
fn:string((xs:yearMonthDuration("P10Y11M")) * 2.0) and fn:false()
fn:string((xs:yearMonthDuration("P10Y11M") * 2.0)) and (fn:true())
fn:string((xs:yearMonthDuration("P10Y11M") div 2.0)) and fn:false()
fn:string((xs:yearMonthDuration("P10Y11M") div 2.0)) and (fn:true())
fn:string((xs:yearMonthDuration("P10Y11M") + xs:yearMonthDuration("P05Y07M"))) and (fn:true())
fn:string((xs:yearMonthDuration("P10Y11M") - xs:yearMonthDuration("P05Y07M"))) and (fn:true())
fn:string(xs:yearMonthDuration("P10Y11M") + xs:yearMonthDuration("P12Y07M")) and fn:false()
fn:string(xs:yearMonthDuration("P10Y11M") - xs:yearMonthDuration("P12Y07M")) and fn:false()
fn:string((xs:yearMonthDuration("P20Y10M") * 2.0)) or fn:false()
fn:string((xs:yearMonthDuration("P20Y10M") div 2.0)) or fn:false()
fn:string(xs:yearMonthDuration("P20Y10M") + xs:yearMonthDuration("P19Y10M")) or fn:false()
fn:string(xs:yearMonthDuration("P20Y10M") - xs:yearMonthDuration("P19Y10M")) or fn:false()
fn:subsequence((1,2,3), 1.1, 1)
fn:subsequence((1,2,3), 1.4, 1.4)
fn:subsequence((1,2,3), 1.5, 1.5)
fn:subsequence((1,2,3), 1.8, 1)
fn:subsequence (1 to 10, xs:double('-INF'), xs:double('INF'))
fn:subsequence( ("a", "b", "c"), 1, 1)
fn:subsequence( ("a", (), (), "b", "c"), 1, 3)
fn:subsequence( ("a", "b", "c"), 3, 12)
fn:subsequence( ("a", xs:anyURI("www.example.com"),"b", "c"), 1, 3)
fn:subsequence ( ("a", xs:boolean("0"), "b", "c"), 2,1)
fn:subsequence ( ("a", xs:boolean("1"), "b", "c"), 1,2)
fn:subsequence ( ("a", xs:boolean("false"), "b", "c"), 1, 3)
fn:subsequence ( ("a", xs:boolean("true"), "b", "c"), 1,2)
fn:subsequence ( ("a", xs:date("1993-03-31"), "b", "c"), 1,2)
fn:subsequence ( ("a", xs:dateTime("1972-12-31T00:00:00"), "b", "c"), 0,2)
fn:subsequence( ("a", xs:decimal("-1.000000000001"), xs:integer("-100"), "b", "c"), 2,3)
fn:subsequence ( ("a", xs:double("1.01"), "b", "c"), 2,3)
fn:subsequence ( ("a", xs:double("INF"), "b", "c"), 2, 1)
fn:subsequence ( ("a", xs:double("-INF"), "b", "c"), 2,2)
fn:subsequence ( ("a", xs:double("NaN"), "b", "c"), 2, 20)
fn:subsequence ( ("a", xs:float("1.01"), "b", "c"), 2,4)
fn:subsequence ( ("a", xs:float("-INF"), "b", "c"), 1,2)
fn:subsequence( ("a", xs:float("INF"), "b", "c"),-2,3)
fn:subsequence ( ("a", xs:float("NaN"), "b", "c"), 0, 2)
fn:subsequence( ("a", xs:integer("100"), xs:integer("-100"), "b", "c"),2,4)
fn:subsequence( ("a", xs:string(""),"b", "c"), 1, 3)
fn:subsequence( ("a", xs:string("hello"),"b", "c"), 1, 3)
fn:subsequence ( ("a", xs:time("12:30:00"), "b", "c"), 1, 2)
fn:sub-sequence("http:/example.com/", 1, 1)
fn:substring("!@#$%^*()",1)
fn:substring("12345", 0, 3)
fn:substring("12345", 0 div 0E0, 3)
fn:substring("12345", 1, 0 div 0E0)
fn:substring("12345", 1.5, 2.6)
fn:substring("12345", -1 div 0E0, 1 div 0E0)
fn:substring("12345", -3, 5)
fn:substring("12345", -42, 1 div 0E0)
fn:substring("12345", 5, -3)
fn:substring((), 1, 3)
fn:substring("ABCDE",1+1)
fn:substring("ABCD",xs:double(1))
fn:substring-after("","")
fn:substring-after("",())
fn:substring-after("****","***")
fn:substring-after((), ())
fn:substring-after((),"")
fn:substring-after("12345","1234")
fn:substring-after("a","A")
fn:substring-after("A","a")
fn:substring-after(" ","AAAAABBBBB")
fn:substring-after("AAAAABBBBB"," ")
fn:substring-after("AAAAABBBBBCCCCC","BBBBB")
fn:substring-after("","A Character String")
fn:substring-after("A Character String","")
fn:substring-after("A Character String",())
fn:substring-after((),"A Character String")
fn:substring-after("A",xs:string("A"))
fn:substring-after(fn:prefix-from-QName(xs:QName("foo:bar")),"f")
fn:substring-after("substring-after","refta-gnirtsbus")
fn:substring-after("substring-after","substring-after")
fn:substring-after("substring-aftersubstring-after","substring-after")
fn:substring-after("tattoo", "tat")
fn:substring-after("tattoo", "tattoo")
fn:substring-after(xs:string("A"),"A")
fn:substring-before ((), ())
fn:substring-before("","")
fn:substring-before("",())
fn:substring-before("****","***")
fn:substring-before((),"")
fn:substring-before("12345","2345")
fn:substring-before("a","A")
fn:substring-before("A","a")
fn:substring-before(" ","AAAAABBBBB")
fn:substring-before("AAAAABBBBB"," ")
fn:substring-before("AAAAABBBBBCCCCC","BBBBB")
fn:substring-before("","A Character String")
fn:substring-before("A Character String","")
fn:substring-before("A Character String",())
fn:substring-before((),"A Character String")
fn:substring-before("A",xs:string("A"))
fn:substring-before(fn:prefix-from-QName(xs:QName("foo:bar")),"oo")
fn:substring-before("substring-before","erofeb-gnirtsbus")
fn:substring-before("substring-before","substring-before")
fn:substring-before("substring-beforesubstring-before","substring-before")
fn:substring-before ( "tattoo", "attoo")
fn:substring-before ( "tattoo", "tatto")
fn:substring-before(xs:string("A"),"A")
fn:substring(fn:prefix-from-QName(xs:QName("foo:bar")),2)
fn:substring(fn:substring("ABCDE",1),1)
fn:substring("metadata", 4, 3)
fn:substring("motor car", 6)
fn:substring("substring",1)
fn:sum(())
fn:sum((),())
fn:sum((1 to 100)[. lt 0], 0)
fn:sum((xs:decimal("0"),xs:decimal("0"),xs:decimal("617375191608514839")))
fn:sum((xs:decimal("617375191608514839")))
fn:sum((xs:decimal("617375191608514839"),xs:decimal("-999999999999999999")))
fn:sum((xs:decimal("-999999999999999999")))
fn:sum((xs:decimal("999999999999999999")))
fn:sum((xs:decimal("-999999999999999999"),xs:decimal("617375191608514839")))
fn:sum((xs:decimal("-999999999999999999"),xs:decimal("999999999999999999")))
fn:sum((xs:decimal("999999999999999999"),xs:decimal("-999999999999999999")))
fn:sum((xs:decimal("-999999999999999999"),xs:decimal("-999999999999999999"),xs:decimal("999999999999999999")))
fn:sum((xs:decimal("-999999999999999999"),xs:decimal("999999999999999999"),xs:decimal("-999999999999999999")))
fn:sum((xs:decimal("999999999999999999"),xs:decimal("-999999999999999999"),xs:decimal("-999999999999999999")))
fn:sum((xs:double("0")))
fn:sum((xs:double("0"),xs:double("0"),xs:double("0")))
fn:sum((xs:double("0"),xs:double("-1.7976931348623157E308")))
fn:sum((xs:double("0"),xs:double("-1.7976931348623157E308"),xs:double("-1.7976931348623157E308")))
fn:sum((xs:double("-1.7976931348623157E308")))
fn:sum((xs:double("1.7976931348623157E308")))
fn:sum((xs:double("-1.7976931348623157E308"),xs:double("0")))
fn:sum((xs:double("-1.7976931348623157E308"),xs:double("0"),xs:double("0")))
fn:sum((xs:double("-1.7976931348623157E308"),xs:double("1.7976931348623157E308")))
fn:sum((xs:double("1.7976931348623157E308"),xs:double("-1.7976931348623157E308")))
fn:sum((xs:double("-1.7976931348623157E308"),xs:double("-1.7976931348623157E308"),xs:double("1.7976931348623157E308")))
fn:sum((xs:double("-1.7976931348623157E308"),xs:double("1.7976931348623157E308"),xs:double("-1.7976931348623157E308")))
fn:sum((xs:double("1.7976931348623157E308"),xs:double("-1.7976931348623157E308"),xs:double("-1.7976931348623157E308")))
fn:sum((xs:float("0")))
fn:sum((xs:float("0"),xs:float("0"),xs:float("0")))
fn:sum((xs:float("0"),xs:float("-3.4028235E38")))
fn:sum((xs:float("-3.4028235E38")))
fn:sum((xs:float("3.4028235E38")))
fn:sum((xs:float("-3.4028235E38"),xs:float("0")))
fn:sum((xs:float("-3.4028235E38"),xs:float("0"),xs:float("0")))
fn:sum((xs:float("-3.4028235E38"),xs:float("3.4028235E38")))
fn:sum((xs:float("3.4028235E38"),xs:float("-3.4028235E38")))
fn:sum((xs:float("-3.4028235E38"),xs:float("-3.4028235E38"),xs:float("3.4028235E38")))
fn:sum((xs:float("-3.4028235E38"),xs:float("3.4028235E38"),xs:float("-3.4028235E38")))
fn:sum((xs:float("3.4028235E38"),xs:float("-3.4028235E38"),xs:float("-3.4028235E38")))
fn:sum((xs:int("0"),xs:int("0"),xs:int("-1873914410")))
fn:sum((xs:int("0"),xs:int("0"),xs:int("2147483647")))
fn:sum((xs:int("-1873914410")))
fn:sum((xs:int("-1873914410"),xs:int("-273569238")))
fn:sum((xs:int("-1873914410"),xs:int("-273569238"),xs:int("-273569238")))
fn:sum((xs:int("2147483647")))
fn:sum((xs:int("2147483647"),xs:int("-2147483648")))
fn:sum((xs:int("-2147483648")))
fn:sum((xs:int("-2147483648"),xs:int("2147483647")))
fn:sum((xs:int("-273569238"),xs:int("-1873914410")))
fn:sum((xs:int("-273569238"),xs:int("-1873914410"),xs:int("0")))
fn:sum((xs:negativeInteger("-1")))
fn:sum((xs:nonNegativeInteger("0")))
fn:sum((xs:nonNegativeInteger("0"),xs:nonNegativeInteger("0")))
fn:sum((xs:nonNegativeInteger("0"),xs:nonNegativeInteger("0"),xs:nonNegativeInteger("0")))
fn:sum((xs:nonPositiveInteger("0")))
fn:sum((xs:nonPositiveInteger("0"),xs:nonPositiveInteger("0"),xs:nonPositiveInteger("0")))
fn:sum((xs:positiveInteger("1")))
fn:sum((xs:positiveInteger("1"),xs:positiveInteger("1")))
fn:sum((xs:positiveInteger("1"),xs:positiveInteger("1"),xs:positiveInteger("1")))
fn:sum((xs:short("0"),xs:short("0"),xs:short("32767")))
fn:sum((xs:short("0"),xs:short("0"),xs:short("-5324")))
fn:sum((xs:short("-27444"),xs:short("-5324")))
fn:sum((xs:short("-27444"),xs:short("-5324"),xs:short("0")))
fn:sum((xs:short("32767")))
fn:sum((xs:short("32767"),xs:short("-32768")))
fn:sum((xs:short("-32768")))
fn:sum((xs:short("-32768"),xs:short("32767")))
fn:sum((xs:short("-5324")))
fn:sum((xs:short("-5324"),xs:short("-27444")))
fn:sum((xs:short("-5324"),xs:short("-27444"),xs:short("-27444")))
fn:sum((xs:unsignedLong("0")))
fn:sum((xs:unsignedLong("0"),xs:unsignedLong("0")))
fn:sum((xs:unsignedLong("0"),xs:unsignedLong("0"),xs:unsignedLong("0")))
fn:sum((xs:unsignedShort("0")))
fn:sum((xs:unsignedShort("0"),xs:unsignedShort("0")))
fn:sum((xs:unsignedShort("0"),xs:unsignedShort("0"),xs:unsignedShort("0")))
fn:sum((xs:unsignedShort("0"),xs:unsignedShort("0"),xs:unsignedShort("44633")))
fn:sum((xs:unsignedShort("0"),xs:unsignedShort("0"),xs:unsignedShort("65535")))
fn:sum((xs:unsignedShort("0"),xs:unsignedShort("44633")))
fn:sum((xs:unsignedShort("0"),xs:unsignedShort("44633"),xs:unsignedShort("0")))
fn:sum((xs:unsignedShort("0"),xs:unsignedShort("65535")))
fn:sum((xs:unsignedShort("0"),xs:unsignedShort("65535"),xs:unsignedShort("0")))
fn:sum((xs:unsignedShort("44633")))
fn:sum((xs:unsignedShort("44633"),xs:unsignedShort("0")))
fn:sum((xs:unsignedShort("44633"),xs:unsignedShort("0"),xs:unsignedShort("0")))
fn:sum((xs:unsignedShort("65535")))
fn:sum((xs:unsignedShort("65535"),xs:unsignedShort("0")))
fn:sum((xs:unsignedShort("65535"),xs:unsignedShort("0"),xs:unsignedShort("0")))
fn:sum( (xs:yearMonthDuration('P1Y0M'), 1) )
fn:tail(())
fn:tail([1,2,3])
fn:tail(1 to 5)
fn:tail("a")
fn:tail(("a", "b", "c"))
fn:timezone-from-date(current-date())
fn:timezone-from-dateTime(current-dateTime())
fn:timezone-from-dateTime(fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00")))
fn:timezone-from-dateTime(xs:dateTime("1970-01-01T00:00:00+04:00")) - fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:00:00+02:00"))
fn:timezone-from-dateTime(xs:dateTime("1970-01-01T00:02:00Z")) + fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:03:00Z"))
fn:timezone-from-dateTime(xs:dateTime("1970-01-01T02:00:00+10:00")) div fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:00:00+05:00"))
fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) eq fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) ge fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) le fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) ne fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:timezone-from-dateTime(xs:dateTime("1999-05-31T00:20:00+00:00"))
fn:timezone-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))
fn:timezone-from-dateTime(xs:dateTime("1999-05-31T23:20:00-00:00"))
fn:timezone-from-dateTime(xs:dateTime("1999-12-31T12:00:00+02:00")) le fn:timezone-from-dateTime(xs:dateTime("1999-12-30T12:00:00+03:00"))
fn:timezone-from-dateTime(xs:dateTime("2000-06-12T13:20:00Z"))
fn:timezone-from-dateTime(xs:dateTime("2004-08-27T00:00:00"))
fn:timezone-from-date(xs:date("1970-01-01+04:00")) le fn:timezone-from-date(xs:date("1970-01-02+02:00"))
fn:timezone-from-date(xs:date("1970-01-01+08:00")) + fn:timezone-from-date(xs:date("1970-01-01+03:00"))
fn:timezone-from-date(xs:date("1970-01-01+09:00")) - fn:timezone-from-date(xs:date("1970-01-01+10:00"))
fn:timezone-from-date(xs:date("1970-01-02+10:00")) div fn:timezone-from-date(xs:date("1970-01-01+05:00"))
fn:timezone-from-date(xs:date("1970-01-02+10:00")) eq fn:timezone-from-date(xs:date("1970-01-01+10:00"))
fn:timezone-from-date(xs:date("1970-01-03+02:00")) ge fn:timezone-from-date(xs:date("1970-01-01+01:00"))
fn:timezone-from-date(xs:date("1999-05-31+00:00"))
fn:timezone-from-date(xs:date("1999-05-31-05:00"))
fn:timezone-from-date(xs:date("1999-12-31-00:00"))
fn:timezone-from-date(xs:date("1999-12-31+01:00")) le fn:timezone-from-date(xs:date("1999-12-31+01:00"))
fn:timezone-from-date(xs:date("1999-12-31+05:00")) lt fn:timezone-from-date(xs:date("1999-12-31+06:00"))
fn:timezone-from-date(xs:date("2000-06-12Z"))
fn:timezone-from-time(current-time())
fn:timezone-from-time(xs:time("00:59:00+00:00"))
fn:timezone-from-time(xs:time("01:10:20Z")) le fn:timezone-from-time(xs:time("01:20:30Z"))
fn:timezone-from-time(xs:time("01:23:02Z")) gt fn:timezone-from-time(xs:time("01:23:03Z"))
fn:timezone-from-time(xs:time("02:00:00Z")) + fn:timezone-from-time(xs:time("10:00:10Z"))
fn:timezone-from-time(xs:time("10:00:00Z")) le fn:timezone-from-time(xs:time("10:00:00Z"))
fn:timezone-from-time(xs:time("10:00:01Z")) ne fn:timezone-from-time(xs:time("01:01:00Z"))
fn:timezone-from-time(xs:time("10:02:01Z")) eq fn:timezone-from-time(xs:time("10:02:00Z"))
fn:timezone-from-time(xs:time("10:03:01Z")) ge fn:timezone-from-time(xs:time("10:04:02Z"))
fn:timezone-from-time(xs:time("10:10:10Z")) - fn:timezone-from-time(xs:time("09:02:07Z"))
fn:timezone-from-time(xs:time("13:20:00"))
fn:timezone-from-time(xs:time("13:20:00-05:00"))
fn:timezone-from-time(xs:time("22:33:10+10:00")) div fn:timezone-from-time(xs:time("02:11:02+05:00"))
fn:timezone-from-time(xs:time("23:20:59-00:00"))
fn:tokenize("1,15,,24,50,", ",")
fn:tokenize("1, 15, 24, 50", ",\s*")
fn:tokenize('foo', () )
fn:tokenize(" red green blue ")
fn:tokenize(" red green blue ", "\s+")
fn:tokenize("The cat sat on the mat", "\s+")
fn:translate("123", "123", "123")
fn:translate("123ABC", "123ABC", "123ABC")
fn:translate("--aaa--","abc-","ABC")
fn:translate("ABC", "ABC", "ABC")
fn:translate("abcdabc", "abc", "AB")
fn:translate("ABCDEFGHIJKLMNOPQRSTUVWXYZ","ABCDEFGHIJKLMNOPQRSTUVWXYZ","abcdefghijklmnopqrstuvwxyz")
fn:translate("acdefghijklmnopqrstuvwxyz", "abcdefghijklmnopqrstuvwxyz", "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
fn:translate("arg", "mapString", ())
fn:translate("arg", (), "transString")
fn:translate("bar","abc","ABC")
fn:translate(fn:string("ABC"), fn:string("ABC"), fn:string("ABC"))
fn:true()
fn:true() and fn:true()
(fn:true() and fn:true(), fn:true())
fn:true() cast as xs:boolean
fn:true() cast as xs:decimal
fn:true() cast as xs:double
fn:true() cast as xs:float
fn:true() cast as xs:integer
fn:true() cast as xs:string
fn:true() eq fn:true()
(fn:true(),fn:false(),fn:true())[xs:boolean(.)]
(fn:true(),fn:false(),fn:true())[xs:boolean(.) and xs:boolean(.)]
(fn:true(),fn:false(),fn:true())[xs:boolean(.) or xs:boolean(.)]
(fn:true(),fn:false()) instance of xs:boolean*
(fn:true(),fn:false()) instance of xs:boolean+
(fn:true(),fn:false()) instance of xs:boolean?
(fn:true(),fn:true())
fn:true() != fn:true()
fn:true() < fn:true()
fn:true() <= fn:true()
fn:true() = fn:true()
fn:true() > fn:true()
fn:true() >= fn:true()
fn:true() ge fn:true()
fn:true() gt fn:true()
fn:true() le fn:true()
fn:true() lt fn:true()
fn:true() ne fn:true()
fn:true() or fn:true()
(fn:true() or fn:true()) and fn:false()
fn:true() or (fn:true() and fn:false())
(fn:true() or fn:true(), fn:true())
fn:upper-case("*****")
fn:upper-case("%$#@!")
fn:upper-case(1)
fn:upper-case("12345")
fn:upper-case("12345abcd")
fn:upper-case("abc") and fn:upper-case("abc")
fn:upper-case("ABc!D")
fn:upper-case("ABCD")
fn:upper-case("abCd0")
fn:upper-case("abcde")
fn:upper-case("ABCDEabcde")
(fn:upper-case("Abc") || fn:upper-case("DH"))
fn:upper-case(fn:codepoints-to-string((65,32,83,84,82,73,78,71)))
fn:upper-case(fn:prefix-from-QName(xs:QName("foo:bar")))
fn:upper-case(lower-case("AbcDH"))
fn:upper-case("upper-case")
fn:upper-case(upper-case("zzzzz"))
fn:upper-case(xs:string("This is a characte"))
fn:year-from-date(fn:current-date())
fn:year-from-dateTime(fn:current-dateTime())
fn:year-from-dateTime(fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00")))
fn:year-from-dateTime(xs:dateTime("0001-05-31T23:20:00-05:00"))
fn:year-from-dateTime(xs:dateTime("-0002-06-06T00:00:00"))
fn:year-from-dateTime(xs:dateTime("1000-01-01T02:00:00Z")) div fn:year-from-dateTime(xs:dateTime("0050-01-01T10:00:00Z"))
fn:year-from-dateTime(xs:dateTime("1970-01-01T00:00:00Z"))
fn:year-from-dateTime(xs:dateTime("1970-01-01T00:00:00Z")) - fn:year-from-dateTime(xs:dateTime("1969-01-01T10:00:00Z"))
fn:year-from-dateTime(xs:dateTime("1970-01-01T00:00:00Z")) + fn:year-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:year-from-dateTime(xs:dateTime("1970-01-01T02:00:00Z")) * fn:year-from-dateTime(xs:dateTime("0002-01-01T10:00:00Z"))
-fn:year-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:year-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) eq fn:year-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:year-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) idiv fn:year-from-dateTime(xs:dateTime("1970-01-01T02:00:00Z"))
fn:year-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) le fn:year-from-dateTime(xs:dateTime("1971-01-01T10:00:00Z"))
fn:year-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) mod fn:year-from-dateTime(xs:dateTime("1970-01-01T03:00:00Z"))
fn:year-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) ne fn:year-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
+fn:year-from-dateTime(xs:dateTime("1971-01-01T10:00:00Z"))
fn:year-from-dateTime(xs:dateTime("1971-01-01T10:00:00Z")) ge fn:year-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:year-from-dateTime(xs:dateTime("1996-04-07T01:40:52Z"))
fn:year-from-dateTime(xs:dateTime("-1999-05-31T00:20:00-05:00"))
fn:year-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))
fn:year-from-dateTime(xs:dateTime("1999-05-31T21:30:00-05:00"))
fn:year-from-dateTime(xs:dateTime("1999-12-31T19:20:00"))
fn:year-from-dateTime(xs:dateTime("2030-12-31T23:59:59Z"))
fn:year-from-date(xs:date("0001-05-31Z"))
fn:year-from-date(xs:date("-0002-06-01"))
+fn:year-from-date(xs:date("1970-01-01Z"))
-fn:year-from-date(xs:date("1970-01-01Z"))
fn:year-from-date(xs:date("1970-01-01Z"))
fn:year-from-date(xs:date("1970-01-01Z")) div fn:year-from-date(xs:date("1970-01-01Z"))
fn:year-from-date(xs:date("1970-01-01Z")) eq fn:year-from-date(xs:date("1970-01-01Z"))
fn:year-from-date(xs:date("1970-01-01Z")) * fn:year-from-date(xs:date("0002-01-01Z"))
fn:year-from-date(xs:date("1970-01-01Z")) + fn:year-from-date(xs:date("1970-01-01Z"))
fn:year-from-date(xs:date("1970-01-01Z")) - fn:year-from-date(xs:date("1970-01-01Z"))
fn:year-from-date(xs:date("1970-01-01Z")) ge fn:year-from-date(xs:date("1970-01-01Z"))
fn:year-from-date(xs:date("1970-01-01Z")) idiv fn:year-from-date(xs:date("1970-01-01Z"))
fn:year-from-date(xs:date("1970-01-01Z")) le fn:year-from-date(xs:date("1970-01-01Z"))
fn:year-from-date(xs:date("1970-01-01Z")) mod fn:year-from-date(xs:date("1970-01-01Z"))
fn:year-from-date(xs:date("1970-01-01Z")) ne fn:year-from-date(xs:date("1970-01-01Z"))
fn:year-from-date(xs:date("1983-11-17Z"))
fn:year-from-date(xs:date("1999-05-31"))
fn:year-from-date(xs:date("-1999-05-31Z"))
fn:year-from-date(xs:date("1999-05-31Z"))
fn:year-from-date(xs:date("1999-12-31Z")) le fn:year-from-date(xs:date("1999-12-31Z"))
fn:year-from-date(xs:date("1999-12-31Z")) lt fn:year-from-date(xs:date("1999-12-31Z"))
fn:year-from-date(xs:date("2000-01-01+05:00"))
fn:year-from-date(xs:date("2000-01-01Z"))
fn:year-from-date(xs:date("2030-12-31Z"))
fn:years-from-duration(xs:dayTimeDuration('P1D'))
fn:years-from-duration(xs:dayTimeDuration("-P2DT15H"))
fn:years-from-duration(xs:duration("P1Y2M3DT10H30M"))
fn:years-from-duration(xs:yearMonthDuration("P01Y10M"))
fn:years-from-duration(xs:yearMonthDuration("P0Y0M"))
fn:years-from-duration(xs:yearMonthDuration("P1000Y6M"))
fn:years-from-duration(xs:yearMonthDuration("P10Y10M")) mod fn:years-from-duration(xs:yearMonthDuration("P03Y10M"))
fn:years-from-duration(xs:yearMonthDuration("-P15M"))
fn:years-from-duration(xs:yearMonthDuration("P2030Y12M"))
fn:years-from-duration(xs:yearMonthDuration("P20Y10M")) div fn:years-from-duration(xs:yearMonthDuration("P05Y10M"))
fn:years-from-duration(xs:yearMonthDuration("P20Y10M")) * fn:years-from-duration(xs:yearMonthDuration("P02Y10M"))
fn:years-from-duration(xs:yearMonthDuration("P20Y10M")) ge fn:years-from-duration(xs:yearMonthDuration("P20Y10M"))
fn:years-from-duration(xs:yearMonthDuration("P20Y15M"))
fn:years-from-duration(xs:yearMonthDuration("P20Y3M")) lt fn:years-from-duration(xs:yearMonthDuration("P21Y2M"))
fn:years-from-duration(xs:yearMonthDuration("P21Y01M")) le fn:years-from-duration(xs:yearMonthDuration("P21Y15M"))
+fn:years-from-duration(xs:yearMonthDuration("P21Y10M"))
fn:years-from-duration(xs:yearMonthDuration("P21Y10M")) + fn:years-from-duration(xs:yearMonthDuration("P22Y10M"))
fn:years-from-duration(xs:yearMonthDuration("P21Y10M")) le fn:years-from-duration(xs:yearMonthDuration("P22Y10M"))
fn:years-from-duration(xs:yearMonthDuration("P22Y10M")) eq fn:years-from-duration(xs:yearMonthDuration("P22Y10M"))
fn:years-from-duration(xs:yearMonthDuration("P22Y10M")) ne fn:years-from-duration(xs:yearMonthDuration("P23Y10M"))
-fn:years-from-duration(xs:yearMonthDuration("P25Y10M"))
fn:years-from-duration(xs:yearMonthDuration("P25Y10M")) idiv fn:years-from-duration(xs:yearMonthDuration("P05Y10M"))
fn:years-from-duration(xs:yearMonthDuration("P30Y10M")) - fn:years-from-duration(xs:yearMonthDuration("P10Y10M"))
fn:zero-or-one((1,2))
fn:zero-or-one(xs:double("0"))
fn:zero-or-one(xs:double("-1.7976931348623157E308"))
fn:zero-or-one(xs:double("1.7976931348623157E308"))
fn:zero-or-one(xs:float("0"))
fn:zero-or-one(xs:float("-3.4028235E38"))
fn:zero-or-one(xs:float("3.4028235E38"))
fn:zero-or-one(xs:int("-1873914410"))
fn:zero-or-one(xs:int("2147483647"))
fn:zero-or-one(xs:int("-2147483648"))
fn:zero-or-one(xs:negativeInteger("-1"))
fn:zero-or-one(xs:nonNegativeInteger("0"))
fn:zero-or-one(xs:nonPositiveInteger("0"))
fn:zero-or-one(xs:positiveInteger("1"))
fn:zero-or-one(xs:short("32767"))
fn:zero-or-one(xs:short("-32768"))
fn:zero-or-one(xs:short("-5324"))
fn:zero-or-one(xs:unsignedLong("0"))
fn:zero-or-one(xs:unsignedShort("0"))
fn:zero-or-one(xs:unsignedShort("44633"))
fn:zero-or-one(xs:unsignedShort("65535"))
(//Folder)[1]/File[ if ( ./@name='File00000000000' ) then 2 else true() ]/FileName
fold-left((13, 14, 9, 6), (), function($a, $b){ if(empty($a)) then $b else ($a + $b) div 2 })
fold-left(1 to 13, 0, concat("(", ?, "+", ?, ")"))
fold-left(1 to 2, 1, function($a, $b){ ($a, $b) })
fold-left(1 to 5, "$zero", fn:concat("$f(", ?, ", ", ?, ")"))
fold-left(1 to 5, 0, function($a, $b) { $a + $b })
fold-left(1 to 5, 1, function($a, $b, $c){ $a + $b + $c })
fold-left(1 to 5, 1, function($a, $b as element(foo)) { $a + $b })
fold-left(1 to 5, 1, function($a as element(bar), $b) { $a + $b })
fold-left(1 to 5, [], array:append#2)
fold-left(1 to 5, "", fn:concat(?, ".", ?))
fold-left(1 to 5, "", function($a, $b) { $a + $b })
fold-left(1 to 5, (), function($a, $b) {($b, $a)})
fold-left((2,3,5,7), 1, function($a, $b) { $a * $b })
fold-left((true(), false(), false()), false(), function($a, $b) { $a and $b })
fold-left((true(), false(), false()), false(), function($a, $b) { $a or $b })
fold-right((1, 2, 2, 3, 3, 3, 4, 5, 5), (), function($a, $b){ if(exists($b[. eq $a])) then $b else ($a, $b) })
fold-right(1 to 10, (), function($a, $b){ if(empty($b)) then $a else if($a gt $b) then $b else $a })
fold-right( 1 to 10, (), function($a, $b){ if(empty($b)) then $a else if($a lt $b) then $b else $a })
fold-right((1 to 13), 0, concat("(", ?, "+", ?, ")"))
fold-right(1 to 5, "$zero", fn:concat("$f(", ?, ", ", ?, ")"))
fold-right(1 to 5, 0,function($a, $b) { $a + $b })
fold-right(1 to 5, 0, function($a, $b, $c){ $a + $b + $c })
fold-right(1 to 5, 0, function($a, $b as xs:string){ $a + $b })
fold-right(1 to 5, 0, function($a as xs:string, $b){ $a + $b })
fold-right(1 to 5, "", fn:concat(?, ".", ?))
fold-right((1 to 5), (), function($a, $b){ ($a, $a, $b) })
fold-right(1 to 5, "", function($a, $b){ $a + $b })
fold-right((1 to 5), (), function($a , $b){ ($b, $a) })
fold-right((2,3,5,7), 1,function($a, $b) { $a * $b })
fold-right(("Hello", "World"), 0, function($a, $b){ string-length($a) + $b })
fold-right((true(), false(), false()), false(),function($a, $b) { $a and $b })
fold-right((true(), false(), false()), false(),function($a, $b) { $a or $b })
"f"oo"
'f'oo'
(/)/(//)/foo
< foo/>
<foo
<foo /
<foo/ >
<foo><!
<foo><!-
<foo><!--
"foo" + 1
<foo a='1' b='2' c='3'> <bar>4</bar> <bar>5</bar> <bar>6</bar> </foo>/@a/following-sibling::node()
<foo a='1' b='2' c='3'> <bar>4</bar> <bar>5</bar> <bar>6</bar> </foo>/@c/preceding-sibling::node()
<foo> a <![CDATA[cdata section]]> in mixed content. a <!-- comment --> in mixed content. a <?processing instruction?> in mixed content. </foo>
<foo attr=
<foo attr="
<foo attr="""/>
<foo attr="{
<foo attr="{"
<foo attr="{{{"
<foo attr='''/>
<foo attr="<!-- a comment-->"/>
<foo attr="{'a string'}><<<"/>
<foo attr="<![CDATA[content]]>"/>
<foo attr="{<!-- comment -->}"/>
<foo attr(:comment:)="value" />
<foo attr=(:comment:)"value" />
<foo attr="content{1"/>
<foo attr="content<content"/>
<foo attr="content}content"/>
<foo attr="<foo/>"/>
<foo attr="{<foo attr="foo"/>}"/>
<foo > {attribute name {"content"}} <doo/> </foo>
<foo attr="<?target content?>"/>
<foo attr="{<?target dat a ?>}"/>
<foo attr="value" (:comment:) attr2="value" />
"  foobar  " castable as xs:NMTOKEN
<foo (:comment :)/>
<foo > <doo/> {attribute name {"content"}} </foo>
<foo > <doo/> </foo>
<foo><doo/> </foo>
<foo><doo/></foo>
<foo:elem/>
<foo:elem xmlns:foo="http://www.example.com/parent"><child xmlns:foo=""/></foo:elem>
(<foo:elem xmlns:foo="http://www.example.com/parent"><child xmlns:foo=""><grand-child/></child></foo:elem>)//grand-child
<foo:elem xmlns:foo="http://www.w3.org/XQueryTest/Construct" xmlns:bar="http://www.w3.org/XQueryTest/Construct"></bar:elem>
"fo""o" eq concat("fo", """", "o")
"f oo eq "f oo"
"f oo" eq "f oo
"f oo" eq f oo"
'fo''o' eq 'fo''o'
'foo' eq "foo"
f oo" eq "f oo"
< foo></foo>
<foo></foo>
<foo>< /foo>
foo- foo
for $AaBbCc.-_Dd in /MyComputer/Drive1/Folder return $AaBbCc.-_Dd/FolderName
for $AaBbCc.-_Dd in /MyComputer/Drive1/Folder where $AaBbCc.-_Dd/@creator = "Mani" return $AaBbCc.-_Dd/FolderName
for $a at $p1 in (1, 2), $b at $p2 in (1, 2), $c at $p3 in (1, 2) return 1, $p1
for $a at $p1 in (1, 2), $b at $p2 in (1, 2), $c at $p3 in (1, 2) return 1, $p2
for $a at $p1 in (1, 2), $b at $p2 in (1, 2), $c at $p3 in (1, 2) return 1, $p3
for $a at $p in (1, 2) return 1, $p
for $a at $pos1 in (1, 2, 3) return for $b at $pos2 in (4, 5, 6) return for $c at $pos3 in (7, 8, 9) return ($a, $pos1, $b, $pos2, $c, $pos2)
for $a at p1 in 1 return 1
for $a in $a/* return $a
for $a in (1, 2), $b in (1, 2), $c in (1, 2) return 1, $a
for $a in (1, 2), $b in (1, 2), $c in (1, 2) return 1, $b
for $a in (1, 2), $b in (1, 2), $c in (1, 2) return 1, $c
for $a in (1, 2, 3), $b in (1, 2, 3, $b) return $a, $b
for $a in (1, 2) return 1, $a
for $a in (1, 4, 2) let $i := (1, $a, 2) order by $i return $i
for $a in (1, 4, 2) let $i := (1, 3, 2) order by $a return $i
for $a in (1, 4, 2) let $i := (1, 3, 2) order by $i return 1
for $a in 1 satisfies 4
for $a in 1 where true(), true() return $a
for $a in 1 where true() where true() return $a
for $a in (2, 1) let $b := 1 where true() order by $a return $a
for $a in (3, 2, 1), $b in (6, 5, 4) order by $a return $a
for $a in (3, 2, 1), $b in (6, 5, 4) stable order by $b return $a
for $a in (3, 2, 1), $b in (6) stable order by $b return $a
for $a in (3, 2, 1, 1) stable order by $a return 5
for $a in (3, 2, 1, 1) stable order by 1 return $a
for $a in (3, 2, 1) let $a := ($a, 1), $b := (2, 1), $c := (2, 1), $d:= (2, 1) order by $a return $a
for $a in (3, 2, 1) let $b := (2, 1), $c := (2, 1), $d := (2, 1), $e := (2, 1) order by $a return $a
for $a in attribute { fn:QName("http://www.example.com/", "xml:foo") } { "bar" }         return name($a)
for $a in attribute { fn:QName("http://www.example.com/", "xmlns:foo") } { "bar" } return name($a)
for $a in attribute { fn:QName("http://www.w3.org/2000/xmlns/", "namespace:foo") } { "bar" } return name($a)
for $a in attribute { fn:QName("http://www.w3.org/XML/1998/namespace", "sgml:foo") } { "bar" }         return name($a)
for $a in attribute { "xmlns" } { "bar" } return name($a)
for $a in (/) return          for $b in $a/child::site return          for $c in $b/child::people return          for $d in $c/child::person return              if ((some $id in $d/attribute::id satisfies                      typeswitch ($id)                      case $n as node() return $id = "person0"                      default $d return ()))              then $d/child::name              else (),          for $b in /site/people/person where $b/@id="person0" return $b/name,          /site/people/person[@id eq "person0"]/name
for $a in ("test", "test1", "test2") return $a
for $b in //book         let $e := $b/*[contains(string(.), "Suciu") and ends-with(local-name(.), "or")]         where exists($e)         return <book> { $b/title } { $e } </book>
for $comment as comment() in //comment() return $comment
for $d in /MyComputer/Drive4 where $d/Folder[@id="128"] return <FolderName>{$d/Folder/@name}</FolderName>
(for $d in <people> <person id="person0"> <name>First</name> </person> <person> <name>Second</name> </person> </people>/person return if (some $id in 1 satisfies typeswitch ($d/@id) case $n as node() return $d/@id = "person0" default $d return ()) then $d/name else ())
for $d in person return $d
for $doc as document-node() in (/) return count( $doc )
for $file as element(File,xs:untyped) in (//Folder)[1]/File return $file/FileName
for $file as in (//Folder)[1]/File return $file
for $file as node() in (//Folder)[1]/File return $file/FileName
for $file at $offset in (//Folder)[1]/File return <File>{ $file/@name }{ attribute offset{ $offset }}</File>
for $file at $offset in (//Folder)[1]/File where $offset mod 2 = 1 return $file/FileName
for $file at $pos as element(Folder,xs:untyped) in (//Folder)[1]/File return (string($file/FileName[1]), $pos)
for $file at $pos in (//Folder)[1]/File, $pos2 in $pos+1 return (string($file/FileName[1]), $pos, $pos2)
for $file at $pos in (//Folder)[1]/File return (string($file/FileName[1]), $pos)
for $file (//Folder)[1]/File return $file/FileName
for $file in //File           let $namelen := string-length($file/FileName)          where ($namelen = 15 and $file//Allow/user = 'system\Hyungjeong')           return $file/FileName
for $file in //File           let $prefix := substring($file/FileName, 1, 4)          where ($prefix = 'File')          where ($file//Allow/user = 'system\Hyungjeong')          return $file/FileName
for $file in //File           where current-date() gt xs:date('1900-01-01')          let $prefix := substring($file/FileName, 1, 4)          where ($prefix = 'File')          where ($file//Allow/user = 'system\Hyungjeong')          return $file/FileName
for $file in (//Folder)[1]/File
for $file in (//Folder)[1]/File, $file in (//Folder)[2]/File return $file/FileName
for $file in (//Folder)[1]/File as element(Folder,xs:untypedAny) return $file/FileName
for $file in (//Folder)[1]/File at $pos return (string($file/FileName[1]), $pos)
for $file in (//Folder)[1]/File return $file/FileName
for $file in (//Folder)[1]/File return $file/parent::Folder/FolderName
for $file in (//Folder)[1]/File return $file return $file
for $file in (//Folder)[1]/File return ($file/Stream/StreamSize)[1] + 1
for $file in (//Folder)[1]/File return ($file/Stream/StreamSize)[1] > 1004
for $file in (//Folder)[1]/File return $undefined
for $file in (//Folder)[1]/File return 1
for $file in (//Folder)[1]/File return data( $file/FileName )
for $file in (//Folder)[1]/File return (//FileName)[1]
for $file in (//Folder)[1]/File return if( $file/FileName='File00000000000' ) then $file/FileName else data( $file/FileName )
for $file in (//Folder)[1]/File return if( $file/FileName='File00000000004' ) then 1 else data( $file/FileName )
for $file in (//Folder)[1]/File return return $file/FileName
for $file in (//Folder)[1]/File return xs:string( data( $file/FileName[1] ))
for $file in (//Folder)[1]/File where $file/SecurityObject/Denies/Deny/security/right="Change" return $file/FileName
for $file in (//Folder)[1]/File where $file/SecurityObject/Denies/Deny/security/right return $file/FileName
for $file in (//Folder)[1]/File where $undefined return $file/FileName
for $file in (//Folder)[1]/File where data( $file/SecurityObject//right ) return $file/FileName
for $file in (//Folder)[1]/File where true() return $file/FileName
for $file in (//Folder)[1]/File where_ true() return $file/FileName
for $file in (//Folder)[1]/File where true(), true() return $file/FileName
for $file in (//Folder)[1]/File where true() where false() return $file/FileName
for $file in for $folder in (//Folder)[1] return $folder/File return $file/FileName
for $fileName as attribute(name,xs:untypedAtomic) in (//Folder)[1]/File/@name return data($fileName)
for $fileName as item() in data( (//Folder)[1]/File/FileName ) return $fileName
for $fileName as text() in (//Folder)[1]/File/FileName/text() return string( $fileName )
for $fileName in //File/FileName,              $folderName in //Folder[contains(description, 'fren')]/FolderName          return ($folderName, $fileName)
for $fileName in //File/FileName for $folderName in //Folder/FolderName return $folderName return $fileName
for $fileName in for $file in //Folder/File return $file/FileName return string( $fileName )
for $f in (concat("one ", ?, " three"), substring-before("one two three", ?), matches(?, "t.*o"), xs:NCName(?))          return $f("two")
for $f in /MyComputer/Drive1/Folder[@creator="Mani"]/File[@creation_date="08/06/00"] return <file>{$f/../@creator}{$f/@creation_date}</file>
for $f in /MyComputer/Drive1/Folder[@creator="Mani"]/File where $f/@creation_date="08/06/00" return $f
for $f in /MyComputer/Drive4/Folder[@id="128"] return <FolderName>{$f/@name}</FolderName>
for $f in /MyComputer//File[@creation_date="08/06/00"]/SecurityObject/Denies/Deny[security/right] return $f/../../@name/string()
for $f in /MyComputer//File where $f/@creation_date="08/06/00" return $f/SecurityObject/Denies/Deny[security/right]/user/string()
(for $fn:name in (1, 1) return $fn:name) instance of xs:integer+
(for $fo in (1, 2, 3) where $fo eq 3 return $fo)
for $folder in $folder/File return <file name="{$folder/File/FileName}"/>
for $folder in //Folder, $file in $folder/File, return $file/FileName
for $folder in //Folder, $file in $folder/File return ( $folder/FolderName, $file/FileName )
for $folder in //Folder, $file in $folder//File return <File folder="{$folder/FolderName}">{string($file/FileName[1])}</File>
for $folder in //Folder, $index in (1, 2, 3) return $folder/File[$index]/FileName
for $folder in //Folder for $file in $folder//File return <File folder="{$folder/FolderName}">{string($file/FileName[1])}</File>
for $folder in //Folder return $folder return $folder
for $folder in //Folder return for $file in $folder/File return string( $file/FileName[1] )
for $folder in //Folder where $folde/@name = "ABC" return <folder/>
for $folder in in .//Folder return $folder
for $folder in /MyComputer/Drive1/Folder[1]          return <folder1> {$folder/FolderName} <files> {                      for $file in ($folder/File)[position() < 6]                      return <f>{$file/FileName/substring(.,13)}</f> } </files>                 </folder1>
for $folder in /MyComputer/Drive2//Folder return <newFolder>{ $folder/FolderName/text() }</newFolder>
for $folder in /MyComputer/Drive2//Folder return <newFolder>{ $folder/@name, $folder/FolderName/text() }</newFolder>
for $folder in /MyComputer/Drive4//Folder return <Folder>{ $folder/@name }{ for $file in /MyComputer/Drive4//File where $file/@idref = $folder/@id return <File>{ $file/@name }</File> }</Folder>
for $foo in ($foo, 2, 3) return 1
for $foo in $foo return 1
for $foo in 1, $bar in 2, $moo in 3, return 4
for $foo in (1, $foo, 3) return 1
for $foo in (1, 2, $foo) return 1
for $foo in 1 return $bar + (for $bar in 2 return $bar)
for $foo in 1 return $NOTEXIST
for $foo in ("a string", "another one") return 1 + subsequence($foo, 1, 1)
for $foo in "foo" return 1 + $foo
for $h in ( ($works//hours) | ($staff//grade[xs:integer(.) gt 12])) order by number($h) return $h
for $h in ( ($works//hours) except ($staff//grade)) order by number($h) return $h
for $h in ( ($works//hours) intersect ($works//hours, $staff//grade)) order by number($h) return $h
for $h in ( ($works//hours) union ($staff//grade[xs:integer(.) gt 12])) order by number($h) return $h
for $h in ( count(($works//hours) except ($staff//grade,$works//hours))) order by number($h) return $h
for $h in ( count((//hours) except (//hours))) order by number($h) return $h
for $h in ( (<hours>0</hours>,<hours>1</hours>) | //hours) order by number($h) return $h
for $h in ( (<hours>0</hours>,<hours>1</hours>) union (//hours)) order by number($h) return $h
for $h in ( (<hours>0</hours>,<hours>40</hours>) | (//hours)) order by number($h) return $h
for $h in ( (<hours>0</hours>,<hours>40</hours>) union (//hours)) order by number($h) return $h
for $h in ( (//hours) intersect (//hours[xs:integer(.) gt 12])) order by number($h) return $h
for $h in ( () | (//hours)) order by number($h) return $h
for $h in ( (//hours[xs:integer(.) le 20]) | (//hours[xs:integer(.) gt 20])) order by number($h) return $h
for $h in ( (//hours[xs:integer(.) le 20]) union (//hours[xs:integer(.) gt 20])) order by number($h) return $h
for $h in ( () union (//hours)) order by number($h) return $h
for $h in (/works[1]/employee[1]) return fn:count(($h/self::employee[1000]))
for $h in ./works[1]/employee[2] return          fn:string-length(fn:name($h/child::text()[last()]))
for $h in (/works/employee[10]) return $h/@name
for $h in (/works/employee[12]/overtime) return $h/day[not(position() = 1)]
for $h in (/works/employee[12]/overtime) return $h/day[not(position() = 1)]/string()
for $h in (/works/employee[12]/overtime) return $h/../@name
for $h in (/works/employee[12]/overtime) return $h/*[position() = position()]/string()
for $h in (/works/employee[12]) return $h/overtime[last() = 1]/*/string()
for $h in (/works/employee[12]) return $h/overtime[last() = last()]/*/string()
for $h in (/works/employee[12]) return ($h/overtime[position() and fn:false()])
for $h in (/works/employee[12]) return $h/overtime[position() and fn:false()]
for $h in (/works/employee[12]) return ($h/overtime[position() and fn:true()]/*/string())
for $h in (/works/employee[12]) return $h/overtime[position() or fn:false()]/*/string()
for $h in (/works/employee[12]) return $h/overtime[position() or fn:true()]/*/string()
for $h in (/works/employee[12]) return $h/overtime[position() = position()]/day/string()
for $h in (/works/employee[1]/hours) return $h/ancestor::employee
(for $h in (/works/employee[1]/hours) return $h/ancestor-or-self::employee)/@name
for $h in (/works/employee[1]/hours) return $h/parent::node()
for $h in (/works/employee[1]) return $h/child::*
for $h in (/works/employee[1]) return $h/child::node()
for $h in (/works/employee[1]) return $h/descendant-or-self::employee
for $h in (/works/employee[1]) return $h/self::employee
for $h in (/works/employee[2]/@name) return fn:name($h/parent::node())
for $h in (/works/employee[2]) return $h/child::node()
for $h in (/works/employee[2]) return $h/following-sibling::employee[fn:position() = 1]
for $h in (/works/employee[2]) return $h/preceding-sibling::employee[fn:position() = 1]
for $h in (/works/employee[2]) return fn:concat(fn:name($h),"A String")
for $h in (./works/employee[2]) return fn:lower-case(fn:name($h))
for $h in (./works/employee[2]) return fn:name($h/descendant::empnum[position() =          1])
for $h in (./works/employee[2]) return fn:name($h/descendant-or-self::empnum[position()          = 1])
for $h in (./works/employee[2]) return fn:name($h/parent::node())
for $h in (./works/employee[2]) return fn:name($h/self::employee)
for $h in (./works/employee[2]) return fn:substring(fn:name($h),2)
for $h in (./works/employee[2]) return fn:upper-case(fn:name($h))
for $h in (/works/employee[4]) return $h/hours/string()
for $h in (/works/employee[6]) return $h/child::*[self::empnum or self::pnum][fn:position() = fn:last()]
for $h in (/works/employee[7]) return $h/child::*[self::pnum or self::empnum]
for $h in (/works/employee) return $h/child::empnum
for $h in (/works/employee) return $h/child::hours[fn:position() > 1]
for $h in (/works/employee) return $h/descendant::empnum
for $h in (/works) return $h/child::*/child::pnum
for $h in (/works) return $h/child::employee[attribute::gender eq 'female'][fn:position() = 5]
for $h in (/works) return $h/child::employee[attribute::name eq "Jane Doe 11"]
for $h in (/works) return $h/child::employee[child::empnum = 'E3']
for $h in (/works) return $h/child::employee[child::status]
for $h in (/works) return $h/child::employee/descendant::empnum
for $h in (/works) return $h/child::employee[fn:position() = 1]
for $h in (/works) return $h/child::employee[fn:position() = fn:last()]
for $h in (/works) return $h/child::employee[fn:position() = fn:last()-1]
for $h in (/works) return $h/.//day/string()
for $h in (/works) return $h/descendant::employee/child::pnum
for $h in (/works) return $h/descendant::employee[fn:position() = 12]
for $h in (/works) return $h/descendant::pnum
for $h in (/works) return $h/employee[1]/@name
for $h in (/works) return $h/employee[5][@gender="female"]/@name
for $h in (/works) return $h/employee[fn:last()]/@name
for $h in (/works) return $h/employee[@gender="female"][5]/@name
for $h in (/works) return $h/employee//hours/string()
for $h in (/works) return $h/employee[last()] << $h/employee[last()]
for $h in (/works) return $h//employee[last() = 13][@name = "Jane Doe 13"]/string(@name)
for $h in (/works) return $h/employee[last()] is $h/employee[last()]
for $h in (/works) return $h/employee[last() = position()]/string(@name)
for $h in (/works) return $h//employee[last()]/string(@name)
for $h in (/works) return $h/employee[@name and @type]/@name
for $h in (/works) return $h/employee[@name="Jane Doe 11"]/@name
for $h in (/works) return $h//employee[@name="Jane Doe 13"][last() = 1]/string(@name)
for $h in (/works) return $h/employee[@name = "Jane Doe 13" or @type="FT"]/@name
for $h in (/works) return $h/employee[@name][position() = 1]/string(@name)
for $h in (/works) return $h/employee[overtime]/@name
for $h in (/works) return $h/employee[position() = 12]/overtime/*/string()
for $h in (/works) return $h/employee[position() = 13]/string(@name)
for $h in (/works) return $h/employee[position() = 1][@name]/string(@name)
for $h in (/works) return $h/employee[position() = 1]/string(@name)
for $h in (/works) return $h/employee[position() = (2 + 2)]/string(@name)
for $h in (/works) return $h/employee[position() = (3 * 2)]/string(@name)
for $h in (/works) return $h/employee[position() = (5 - 2)]/string(@name)
for $h in (/works) return $h/employee[position() = 5 to last()]/@name/string()
for $h in (/works) return $h/employee[position() = (6 div 2)]/string(@name)
for $h in (/works) return $h/employee[position() = (6 idiv 2)]/string(@name)
for $h in (/works) return $h/employee[position() = last()]/string(@name)
for $h in (/works) return $h/employee[status="active"]/@name
for $h in (/works) return $h/employee/(status|overtime)/day/string()
for $h in (/works) return $h/employee/(status union overtime)/day/string()
for $h in (/works) return $h/*/hours/string()
for $h in (/works) return $h//hours/string()
for $h in (/works) return $h//overtime/day/string()
for $i at $p in (1, 2, 3) return $p + "1"
for $i at $p in remove((1, 2, 3), 10) return $p
for $i at $pos in (3 to 6) let $let := $pos + 1 return ($let, $let - 1)
for $i in (1, 2), $j in (3, 4) return ($i, $j)
FOR $i IN (1, 2, 3)
for $i in (1, 2, 3) stable order by 1 return reverse(($i, "FO"))
for $i in (1, 2, current-time())[1] where xs:anyURI("example.com/") return true()
for $i in (1, 3, 2) let $c := 3 stable order by () return $i
for $i in (1, 3, 2) order by $i empty INVALID return ($i, 2)
for $i in (1, 3, 2) order by $i return $i
for $i in (1, 3, 2) order by $i return ($i, 2)
for $i in (1, 3, 2) stable order by () return $i
for $i in 1 to 3 return $i
for $i in 1 where count(($i, 2, timezone-from-time(current-time()))) return true()
(for $i in 1 where true() return $i) eq 1
for $i in (-2, -4, -10, -50, +50, +10, +4, +2) return (xs:yearMonthDuration("P5M") div $i)
for $i in (-3.9, -3.5, -3.1, -0.9, -0.5, -0.1, +0.1, +0.5, +0.9, +3.1, +3.5, +3.9) return xs:yearMonthDuration("P1M") * $i
(for $i in current-time() order by $i return $i) eq current-time()
for $i in <e/>/(., 4, 5, <e/>/((<e/>, 2))) return ($i, $i)
for $i in (false(), true(), true(), false(), true(), false()) order by $i return $i
for $int as xs:int in (xs:int(1), xs:int(2)) return $int
for $item in //news_item          where contains(string(exactly-one($item/content)), "Gorilla Corporation")          return <item_summary> { concat($item/title,". ") }                                { concat($item/date,". ") }                                { string(($item//par)[1]) }                 </item_summary>
for $j in (text{'Az'}, text{'Bx'}, text{'Cy'})           order by $j/substring(., $j/string-length(.))           return $j/string()
for $n in attribute return 1
for $n in attribute return {()} return 1
for $n in document return 1
for $n in element return {()} return 1
for $n in node return 1
for $n in processing-instruction return {()} return 1
for $node in ((//price/text()) , (//price/text())) intersect ((//price/text()) , (//price/text())) return <a> {$node} </a>
for $num as xs:decimal in (xs:integer(1), xs:decimal(2), xs:integer(3)) return $num
for $num as xs:decimal in (xs:integer(1), xs:integer(2), xs:integer(3)) return $num
for $num in ( <one/>, <two/>, <three/> ) return $num
for $PI as processing-instruction() in //processing-instruction() return $PI
for $p in //section[section.title = "Procedure"] where not(some $a in $p//anesthesia satisfies $a << ($p//incision)[1] ) return $p
for $Q{http://example.com/ns}x in 1 to 10 return $Q{http://example.com/ns}x + 1
for $Q{}T in 1 to 5 return $Q{  }T + $T
for $Q{ urn:foo bar }x in 1 to 5 return $Q{urn:foo   bar}x + $Q{urn:foo bar}x
(for $range in             tokenize('65-90;97-122;192-214;216-246;248-305;308-318;321-328;330-382;384-451;461-496;500-501;506-535;592-680;699-705;902-902;904-906;908-908;910-929;931-974;976-982;986-986;988-988;990-990;992-992;994-1011;1025-1036;1038-1103;1105-1116;1118-1153;1168-1220;1223-1224;1227-1228;1232-1259;1262-1269;1272-1273;1329-1366;1369-1369;1377-1414;1488-1514;1520-1522;1569-1594;1601-1610;1649-1719;1722-1726;1728-1742;1744-1747;1749-1749;1765-1766;2309-2361;2365-2365;2392-2401;2437-2444;2447-2448;2451-2472;2474-2480;2482-2482;2486-2489;2524-2525;2527-2529;2544-2545;2565-2570;'||             '2575-2576;2579-2600;2602-2608;2610-2611;2613-2614;2616-2617;2649-2652;2654-2654;2674-2676;2693-2699;2701-2701;2703-2705;2707-2728;2730-2736;2738-2739;2741-2745;2749-2749;2784-2784;2821-2828;2831-2832;2835-2856;2858-2864;2866-2867;2870-2873;2877-2877;2908-2909;2911-2913;2949-2954;2958-2960;2962-2965;2969-2970;2972-2972;2974-2975;2979-2980;2984-2986;2990-2997;2999-3001;3077-3084;3086-3088;3090-3112;3114-3123;3125-3129;3168-3169;3205-3212;3214-3216;3218-3240;3242-3251;3253-3257;3294-3294;3296-3297;3333-3340;3342-3344;3346-3368;3370-3385;3424-3425;3585-3630;3632-3632;'||             '3634-3635;3648-3653;3713-3714;3716-3716;3719-3720;3722-3722;3725-3725;3732-3735;3737-3743;3745-3747;3749-3749;3751-3751;3754-3755;3757-3758;3760-3760;3762-3763;3773-3773;3776-3780;3904-3911;3913-3945;4256-4293;4304-4342;4352-4352;4354-4355;4357-4359;4361-4361;4363-4364;4366-4370;4412-4412;4414-4414;4416-4416;4428-4428;4430-4430;4432-4432;4436-4437;4441-4441;4447-4449;4451-4451;4453-4453;4455-4455;4457-4457;4461-4462;4466-4467;4469-4469;4510-4510;4520-4520;4523-4523;4526-4527;4535-4536;4538-4538;4540-4546;4587-4587;4592-4592;4601-4601;7680-7835;7840-7929;7936-7957;'||             '7960-7965;7968-8005;8008-8013;8016-8023;8025-8025;8027-8027;8029-8029;8031-8061;8064-8116;8118-8124;8126-8126;8130-8132;8134-8140;8144-8147;8150-8155;8160-8172;8178-8180;8182-8188;8486-8486;8490-8491;8494-8494;8576-8578;12353-12436;12449-12538;12549-12588;44032-55203;19968-40869;12295-12295;12321-12329;48-57;1632-1641;1776-1785;2406-2415;2534-2543;2662-2671;2790-2799;2918-2927;3047-3055;3174-3183;3302-3311;3430-3439;3664-3673;3792-3801;3872-3881;768-837;864-865;1155-1158;1425-1441;1443-1465;1467-1469;1471-1471;1473-1474;1476-1476;1611-1618;1648-1648;1750-1764;1767-1768;'||             '1770-1773;2305-2307;2364-2364;2366-2381;2385-2388;2402-2403;2433-2435;2492-2492;2494-2500;2503-2504;2507-2509;2519-2519;2530-2531;2562-2562;2620-2620;2622-2626;2631-2632;2635-2637;2672-2673;2689-2691;2748-2748;2750-2757;2759-2761;2763-2765;2817-2819;2876-2876;2878-2883;2887-2888;2891-2893;2902-2903;2946-2947;3006-3010;3014-3016;3018-3021;3031-3031;3073-3075;3134-3140;3142-3144;3146-3149;3157-3158;3202-3203;3262-3268;3270-3272;3274-3277;3285-3286;3330-3331;3390-3395;3398-3400;3402-3405;3415-3415;3633-3633;3636-3642;3655-3662;3761-3761;3764-3769;3771-3772;3784-3789;3864-3865;'||             '3893-3893;3895-3895;3897-3897;3902-3903;3953-3972;3974-3979;3984-3989;3991-3991;3993-4013;4017-4023;4025-4025;8400-8412;8417-8417;12330-12335;12441-12442;183-183;720-721;903-903;1600-1600;3654-3654;3782-3782;12293-12293;12337-12341;12445-12446;12540-12542;58-58;95-95;45-46;65-90;97-122;192-214;216-246;248-305;308-318;321-328;330-382;384-451;461-496;500-501;506-535;592-680;699-705;902-902;904-906;908-908;910-929;931-974;976-982;986-986;988-988;990-990;992-992;994-1011;1025-1036;1038-1103;1105-1116;1118-1153;1168-1220;1223-1224;1227-1228;1232-1259;1262-1269;1272-1273;1329-1366;'||             '1369-1369;1377-1414;1488-1514;1520-1522;1569-1594;1601-1610;1649-1719;1722-1726;1728-1742;1744-1747;1749-1749;1765-1766;2309-2361;2365-2365;2392-2401;2437-2444;2447-2448;2451-2472;2474-2480;2482-2482;2486-2489;2524-2525;2527-2529;2544-2545;2565-2570;2575-2576;2579-2600;2602-2608;2610-2611;2613-2614;2616-2617;2649-2652;2654-2654;2674-2676;2693-2699;2701-2701;2703-2705;2707-2728;2730-2736;2738-2739;2741-2745;2749-2749;2784-2784;2821-2828;2831-2832;2835-2856;2858-2864;2866-2867;2870-2873;2877-2877;2908-2909;2911-2913;2949-2954;2958-2960;2962-2965;2969-2970;2972-2972;2974-2975;'||             '2979-2980;2984-2986;2990-2997;2999-3001;3077-3084;3086-3088;3090-3112;3114-3123;3125-3129;3168-3169;3205-3212;3214-3216;3218-3240;3242-3251;3253-3257;3294-3294;3296-3297;3333-3340;3342-3344;3346-3368;3370-3385;3424-3425;3585-3630;3632-3632;3634-3635;3648-3653;3713-3714;3716-3716;3719-3720;3722-3722;3725-3725;3732-3735;3737-3743;3745-3747;3749-3749;3751-3751;3754-3755;3757-3758;3760-3760;3762-3763;3773-3773;3776-3780;3904-3911;3913-3945;4256-4293;4304-4342;4352-4352;4354-4355;4357-4359;4361-4361;4363-4364;4366-4370;4412-4412;4414-4414;4416-4416;4428-4428;4430-4430;4432-4432;'||             '4436-4437;4441-4441;4447-4449;4451-4451;4453-4453;4455-4455;4457-4457;4461-4462;4466-4467;4469-4469;4510-4510;4520-4520;4523-4523;4526-4527;4535-4536;4538-4538;4540-4546;4587-4587;4592-4592;4601-4601;7680-7835;7840-7929;7936-7957;7960-7965;7968-8005;8008-8013;8016-8023;8025-8025;8027-8027;8029-8029;8031-8061;8064-8116;8118-8124;8126-8126;8130-8132;8134-8140;8144-8147;8150-8155;8160-8172;8178-8180;8182-8188;8486-8486;8490-8491;8494-8494;8576-8578;12353-12436;12449-12538;12549-12588;44032-55203;19968-40869;12295-12295;12321-12329;48-57;1632-1641;1776-1785;2406-2415;2534-2543;'||             '2662-2671;2790-2799;2918-2927;3047-3055;3174-3183;3302-3311;3430-3439;3664-3673;3792-3801;3872-3881;768-836;864-865;1155-1158;1425-1441;1443-1465;1467-1469;1471-1471;1473-1474;1476-1476;1611-1618;1648-1648;1750-1764;1767-1768;1770-1773;2305-2307;2364-2364;2366-2381;2385-2388;2402-2403;2433-2435;2492-2492;2494-2500;2503-2504;2507-2509;2519-2519;2530-2531;2562-2562;2620-2620;2622-2626;2631-2632;2635-2637;2672-2673;2689-2691;2748-2748;2750-2757;2759-2761;2763-2765;2817-2819;2876-2876;2878-2883;2887-2888;2891-2893;'||             '2902-2903;2946-2947;3006-3010;3014-3016;3018-3021;3031-3031;3073-3075;3134-3140;3142-3144;3146-3149;3157-3158;3202-3203;3262-3268;3270-3272;3274-3277;3285-3286;3330-3331;3390-3395;3398-3400;3402-3405;3415-3415;3633-3633;3636-3642;3655-3662;3761-3761;3764-3769;3771-3772;3784-3789;3864-3865;3893-3893;3895-3895;3897-3897;3902-3903;3953-3972;3974-3979;3984-3989;3991-3991;3993-4013;4017-4023;4025-4025;8400-8412;8417-8417;12330-12335;12441-12442;183-183;720-721;903-903;1600-1600;3654-3654;3782-3782;12293-12293;12337-12341;12445-12446;12540-12542;58-58;95-95;45-46', ';')             let $s := xs:integer(substring-before($range, '-'))              let $e := xs:integer(substring-after($range, '-'))              for $c in ($s to $e)!codepoints-to-string(.)             where not(matches($c, '^([\c])$'))              return string-to-codepoints($c)),                           (for $range in tokenize('161-161', ';')              let $s := xs:integer(substring-before($range, '-'))              let $e := xs:integer(substring-after($range, '-'))              for $c in ($s to $e)!codepoints-to-string(.)             where (matches($c, '^([\c])$'))              return string-to-codepoints($c))
for $s in //section[section.title = "Procedure"] return ($s//incision)[2]/instrument
for $s in //section[section.title = "Procedure"] return ($s//instrument)[position()<=2]
for $s in "var:QName" return QName($s)
for $string in ("  foobar  " cast as xs:NMTOKEN) return not(contains($string, ' ') or contains($string, ' ') or contains($string, ' ') or string-length($string) ne 6)
for $string in ("  foo   bar  " cast as xs:normalizedString)         return not(contains($string, ' ') or                     contains($string, ' ') or                     contains($string, ' ') or                     string-length($string) ne 13)
for $string in ("  foo   bar  " cast as xs:token)          return not(contains($string, ' ') or                     contains($string, ' ') or                     contains($string, ' ') or                     string-length($string) ne 7)
for $string in ("&#xD; foo &#x9; bar &#xA;" cast as xs:normalizedString)         return not(contains($string, '&#x9;') or                     contains($string, '&#xA;') or                     contains($string, '&#xD;') or                     string-length($string) ne 13)
for $string in ("&#xD; foo &#x9; bar &#xA;" cast as xs:token)          return not(contains($string, '&#x9;') or                     contains($string, '&#xA;') or                     contains($string, '&#xD;') or                     string-length($string) ne 7)
for $test as xs:anyAtomicType in ( 1, "string", 1e2, 0.3 ) return $test
for $test as xs:anyAtomicType in ( xs:boolean("true"), xs:base64Binary("abcd"), xs:hexBinary("1234"),                      xs:float("5.7"), xs:double("7.5"), xs:anyURI("http://foo") )          return $test
for $test as xs:anyAtomicType in ( xs:duration("P0Y1347M0D"), xs:dateTime("1999-05-31T13:20:00-05:00"),                      xs:time("13:00:00-05:00"), xs:date("1999-05-10Z"), xs:gYearMonth("2002-03"), xs:gYear("1999"),                      xs:gMonthDay("--05-10"), xs:gDay("---10"), xs:gMonth("--05") )          return $test
for $test as xs:anyAtomicType in ( xs:unsignedByte("10"), xs:short("20"), xs:positiveInteger("30"),                  xs:nonPositiveInteger("-40"), xs:decimal("5.5"), xs:ENTITY("entity1"), xs:NCName("foobar"),                  xs:language("en-US"), xs:string("foobar"), xs:hexBinary("ffff"), xs:gYear("1999") )          return $test
for $test as xs:decimal in ( 1, 0.3 ) return $test
for $test as xs:decimal in ( xs:integer("100"), xs:short("1"), xs:int("10000"),                  xs:nonPositiveInteger("-10"), xs:unsignedShort("100"), xs:positiveInteger("100"), xs:nonNegativeInteger("100") )          return $test
for $test as xs:integer in ( xs:byte("1"), xs:long("10000"), xs:negativeInteger("-10"),                          xs:short("100"), xs:positiveInteger("100"), xs:nonNegativeInteger("100") )          return $test
for $test as xs:normalizedString in ( xs:language("en-US"), xs:NCName("foobar"),              xs:NMTOKEN("token1"), xs:ENTITY("entity1") )          return $test
for $ti in <ti><rangeDate><initDate>17880505</initDate><terminatingDate>19550505</terminatingDate></rangeDate></ti> return <result> { fn:min(if ($ti/singleDate) then let $tmp:=$ti/singleDate/compute return xs:date(fn:concat(fn:substring($tmp, 1, 4), "-", fn:substring($tmp, 5, 2), "-", fn:substring($tmp, 7, 2))) else let $tmp:=$ti/rangeDate/initDate return xs:date(fn:concat(fn:substring($tmp, 1, 4), "-", fn:substring($tmp, 5, 2), "-", fn:substring($tmp, 7, 2)))) } </result>
for $var in (1,2), $var in (2,2) return $var * $var
for $var in (1,2) for $var in (2,2) return $var * $var
for $var in 1 return for $h in (/works) return $h/employee[position() = $var]/string(@name)
for $var in "1" return for $h in (/works) return $h/employee[position() = xs:integer($var)]/string(@name)
for $var in (/works/employee[1]) return $var/(exactly-one(hours) div exactly-one(hours))
for $var in (/works/employee[1]) return $var/(exactly-one(hours) * exactly-one(hours))
for $var in (/works/employee[1]) return $var/(exactly-one(hours) + exactly-one(hours))
for $var in (/works/employee[1]) return $var/(exactly-one(hours) - exactly-one(hours))
for $var in (/works/employee[1]) return $var/(exactly-one(hours) idiv exactly-one(hours))
for $var in (/works/employee[1]) return $var/(exactly-one(hours) mod exactly-one(hours))
for $var in (/works/employee[1]) return $var/fn:avg((hours,hours,hours))
for $var in (/works/employee[1]) return $var/fn:max((hours,exactly-one(hours) + 1,22))
for $var in (/works/employee[1]) return $var/fn:min((hours,hours,22))
for $var in (/works/employee[1]) return $var/fn:not(xs:boolean(exactly-one(hours) - 39))
for $var in (/works/employee[1]) return $var/fn:string-length(exactly-one(hours))
for $var in (/works/employee[1]) return $var/fn:sum((hours,hours))
for $var in (/works/employee[1]) return $var/xs:boolean(exactly-one(hours) - 39)
for $var in (/works/employee[1]) return $var/(xs:boolean(exactly-one(hours) - 39) and xs:boolean(exactly-one(hours) - 39))
for $var in (/works/employee[1]) return $var/(xs:boolean(exactly-one(hours) - 39) or xs:boolean(exactly-one(hours) - 39))
for $var in (/works/employee[1]) return $var/xs:decimal(exactly-one(hours))
for $var in (/works/employee[1]) return $var/xs:double(exactly-one(hours))
for $var in /works/employee[1] return $var/xs:float(exactly-one(hours))
for $var in (/works/employee[1]) return $var/xs:integer(exactly-one(hours))
for $var in /works/employee[1] return $var/xs:string(exactly-one(empnum))
for $x allowing empty in 1 to 5          where $x lt 0          return empty($x)
for $x as xs:error in () return fn:true()
for $x in (1,2,3,"cheese") for $y in (1,2,3,"cheese") where $x = $y return ($x, $y)
for $x in (1,2,3, xs:untypedAtomic("1")) for $y in (1,2,3,"cheese") where $x = $y return ($x, $y)
for $x in (1,2) return (if (($x eq 1)) then ($x) else ($x + 1))
for $x in (13), $y in (13,9,10) return codepoints-to-string($x to $y)
for $x in 13 to 13 return codepoints-to-string($x to $x)
for $x in 13 to 15 return codepoints-to-string($x to $x)
for $x in (1, 'hello', xs:date('2007-11-28')) order by $x return $x
for $x in 1 to 10, $y in 1 to 10 return concat('sum(',$x,' to ',$y,') = ',sum($x to $y))
for $x in (1 to 10)/string() order by $x collation ``[http://www.w3.org/2005/xpath-functions/collation/codepoint]`` return xs:integer($x)
(for $x in (1) where (fn:true()) order by ($x) return ($x))
for $x in (1, xs:decimal(2.5), xs:float(3), xs:double(4), xs:untypedAtomic(5))           return (+$x)
for $x in (1, xs:decimal(2.5), xs:float(3), xs:double(4), xs:untypedAtomic(5))          return (-$x)
for $x in 32 to 64 return boolean(codepoints-to-string($x to $x + 10))
for $x in 65 to 75 return boolean(codepoints-to-string($x[. mod 2 = 0] to ($x+9)[. mod 2 = 0]))
for $x in 65 to 75 return string-length(codepoints-to-string($x to $x+10))
for $x in 9 to 15 return codepoints-to-string($x to $x)
for $x in 9 to 9 return codepoints-to-string($x to $x+1)
for $x in <a/>, $y in <elem>{$x}</elem> return exactly-one($y/a) is $x
for $x in <a/>, $y in element elem {$x} return exactly-one($y/a) is $x
for $x in <a b="b"/>, $y in <elem>{$x/@b}</elem> return $y/@b is $x/@b
for $x in <a b="b"/>, $y in element elem {$x/@b} return $y/@b is $x/@b
for $x in <a>text</a>, $y in <elem>{$x/text()}</elem> return exactly-one($y/text()) is exactly-one($x/text())
for $x in <a>text</a>, $y in element elem {$x/text()} return exactly-one($y/text()) is exactly-one($x/text())
for $x in <!--comment-->, $y in <elem>{$x}</elem> return exactly-one($y/comment()) is $x
for $x in <!--comment-->, $y in element elem {$x} return exactly-one($y/comment()) is $x
for $x in (<e/>, 1, "x") return  typeswitch ($x)   case $i as xs:integer | xs:boolean | element() return 1  default $v return 0
for $x in <elem attr="value"/> return $x is $x/@attr/..
for $x in <parent1 xmlns:foo="http://www.example.com/parent1" foo:attr1="attr1"><child1 attr="child"/></parent1> return <new>{$x//*:child1}</new>
for $x in <parent1 xmlns:foo="http://www.example.com/parent1" foo:attr1="attr1"/> return <new xmlns:foo="http://www.example.com">{$x//@*:attr1}</new>
for $x in <parent2 xmlns:foo="http://www.example.com/parent2" foo:attr2="attr2"><child2 attr="child"/></parent2> return <new xmlns="http://www.example.com">{$x//*:child2}</new>
for $x in <parent3 xmlns:foo="http://www.example.com/parent3"><foo:child3/></parent3> return <new>{$x//*:child3}</new>
for $x in <parent4 xmlns="http://www.example.com/parent4"><child4/></parent4> return <new>{$x//*:child4}</new>
for $x in <?pi content?>, $y in <elem>{$x}</elem> return exactly-one($y/processing-instruction()) is $x
for $x in <?pi content?>, $y in element elem {$x} return exactly-one($y/processing-instruction()) is $x
for $x in <t><r><d>1</d><d>1</d><d>1</d></r><r><d>1</d><d>2</d><d>3</d></r><r><d>2</d><d>3</d><d>4</d></r></t>/r, $y in <t><r><d>1</d><d>1</d><d>1</d></r><r><d>2</d><d>4</d><d>6</d></r><r><d>3</d><d>2</d><d>1</d></r></t>/r where $x/d/string(.) = $y/d/string(.) return concat($x, '=', $y)
for $x in /works/employee[fn:position() lt 5][fn:position() mod 2 eq 1] return (fn:data($x/empnum), fn:data($x/pnum))
for $x in /works/employee[fn:position() mod 2 eq 1][fn:position() lt 5] return (fn:data($x/empnum), fn:data($x/pnum))
for $x in (xs:integer("123"), xs:integer("234")) for $y in (xs:integer("123"), xs:integer("456")) where $x = $y return $x
for $x in (xs:integer(1), xs:decimal(1)) return (((($x + 1) * 2) - 1) instance of xs:integer)
for $x in (xs:untypedAtomic("123"), xs:untypedAtomic("234")) for $y in (xs:string("123"), xs:float(123), xs:double(123)) where $x = $y return $x
for $x in (xs:untypedAtomic("2.0"), xs:untypedAtomic("3"), xs:double("3.0")) for $y in (xs:untypedAtomic("2"), xs:untypedAtomic("3"), xs:double("3")) where $x = $y return $x
for $x in zero-or-one((1 to 10)[. div 2 = 0]) return ()
(for $xs:name in (1, 1) return $xs:name) instance of xs:integer+
for-each((1,4,9,16,25), Q{http://www.w3.org/2005/xpath-functions/math}sqrt#1)
for-each((<a>1</a>, <b>22</b>, <c>33</c>),                     function($a as xs:string) as xs:integer {string-length($a)})
for-each(("aa", "bb", "cc", "dd", 12), ())
for-each(("aa", "bb", "cc", "dd", 12), upper-case#1)
for-each(("aa", "bb", "cc", "dd", "ee"), starts-with#2)
for-each(("aa", "bb", "cc", "dd", "ee"), upper-case#1)
for-each(for-each(("john", "mary", "jane", "anne", "peter", "ian"), function($n as xs:string){upper-case($n)}), function($e as xs:string) as xs:string { lower-case($e) })
for-each(("john", "jane"), string-to-codepoints#1)
for-each(("john", "mary", "jane", "anne", "peter", "ian"), function($x){$x[contains(., 'e')]})
for-each(("john", "mary", "jane", "anne", "peter", "ian"), function($x){upper-case($x)})
for-each(namespace-uri-from-QName(function-name(xs:int#1)), upper-case#1)
for-each((), round#1)
for for $folder in //Folder return $folder
for in 1 return 4
for return 4
<fragment-result>{ for $folder in /MyComputer/Drive3/Folder ,$file in /MyComputer/Drive3/Folder/File return <Folder>{ $folder/@name, $folder/@id }<file>{ $file/@idref }{ data($file/@name) }</file> </Folder> }</fragment-result>
<fragment-result>{ for $folder in /MyComputer/Drive3/Folder ,$file in /MyComputer/Drive3/Folder/File where $folder/@id = $file/@idref return <Folder> { $folder/@name, $folder/@id } <file>{ $file/@idref, $file/FileName/text() }</file> </Folder> }</fragment-result>
<frequent_bidder> {              for $u in $users//user_tuple              where every $item in $items//item_tuple                    satisfies some $b in $bids//bid_tuple                              satisfies ($item/itemno = $b/itemno and $u/userid = $b/userid)              return $u/name          } </frequent_bidder>
func-does-not-exist(1, 2, 3)
function()
function($a as xs:integer, $b as xs:double) as xs:double { $a * $b + 5 }(3, 2)
function($a as xs:integer) as xs:integer { $a + 5 }(3)
function($a) { "lala", $a }, $a
function($a) { let $a := "monkey" return ("lala", $a) }("gibbon")
function($in as xs:double*) as xs:double {sum($in, 0.0e0)}((1, xs:float(0.25), xs:decimal(0.5)))
function($in as xs:string*) as xs:string {string-join($in, ';')}((xs:anyURI('http://one.com/'), xs:anyURI('http://two.com/')))
function($Q{http://local/}foo, $Q{http://local/}bar, $fn:foo) {                 "lala", $Q{http://local/}foo, $Q{http://local/}bar }("gibbon", "monkey", "ape")
function($x, $y) {$x + $y} (12, 5)
function($x, $y) {$x + $y} [function-arity(.) = 2] (12, 5)
function() as xs:integer { 5 }()
function gt function
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'anyURI'), 1)('http://www.example.org/')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'banana'), 1)
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'base64Binary'), 1)('D74D35D35D35')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'boolean'), 1)('1')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'byte'), 1)('1')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'date'), 1)('1970-01-02Z')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'dateTime'), 1)('1970-01-02T04:05:06Z')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'dayTimeDuration'), 1)('PT15H')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'decimal'), 1)('1')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'double'), 1)('1')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'duration'), 1)('P5Y2M10DT15H')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'ENTITIES'), 1)('ENTITY1 ENTITY2 ENTITY3')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'ENTITY'), 1)('ENTITY')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'float'), 1)('1')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'gDay'), 1)('---01Z')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'gMonth'), 1)('--11Z')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'gMonthDay'), 1)('--11-01Z')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'gYear'), 1)('2012Z')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'gYearMonth'), 1)('2001-10Z')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'hexBinary'), 1)('0fb7')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'ID'), 1)('ID')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'IDREF'), 1)('IDREF')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'IDREFS'), 1)('ID1 ID2 ID3')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'int'), 1)('1')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'integer'), 1)('1')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'integer'), 2)
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'language'), 1)('en')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'long'), 1)('1')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'Name'), 1)('Name')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'NCName'), 1)('NCName')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'negativeInteger'), 1)('-1')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'NMTOKEN'), 1)('NMTOKEN')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'NMTOKENS'), 1)('NMTOKEN1 NMTOKEN2 NMTOKEN3')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'nonNegativeInteger'), 1)('1')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'nonPositiveInteger'), 1)('-1')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'normalizedString'), 1)('normalized string')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'positiveInteger'), 1)('1')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'QName'), 1)('fn:QName')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'short'), 1)('1')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'string'), 1)('string')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'time'), 1)('01:02:03Z')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'token'), 1)('token')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'unsignedByte'), 1)('1')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'unsignedInt'), 1)('1')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'unsignedLong'), 1)('1')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'unsignedShort'), 1)('1')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'untypedAtomic'), 1)('string')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'yearMonthDuration'), 1)('P1Y')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'abs'), 1)(-1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'append'), 2)([], 3)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'filter'), 2)(["A", "B", 1, 2], function($z) {$z instance of xs:integer})
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'flatten'), 1)([1, 4, 6, 5, 3])
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'fold-left'), 3)([1,2,3,4,5,6], 0, function($z,$a){$z + $a})
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'fold-right'), 3)([1,2,3,4,5,6], 0, function($a,$z){$a + $z})
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'for-each'), 2)(["A", "B", 1, 2], function($z) {$z instance of xs:integer})
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'for-each-pair'), 3)(["A", "B", "C"], [1, 2, 3], function($x, $y) {[$x, $y]})
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'get'), 2)([5,6,7], 1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'head'), 1)([5,6,7,8])
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'insert-before'), 3)(["a", "b", "c", "d"], 3, ("x", "y"))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'join'), 1)(([1,2],[3,4]))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'put'), 3)(["a", "b", "c", "d"], 3, ("x", "y"))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'remove'), 2)(["a","b","c","d"], 1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'reverse'), 1)(["a", "b", "c", "d"])
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'size'), 1)([1])
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'sort'), 1)(["Red", "green", "blUE", "PINK", "ORanGE"])
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'subarray'), 2)(["a", "b", "c", "d"], 2)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'subarray'), 3)([1, (2,2), 3], 3, 0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'tail'), 1)([5,6,7,8])
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'avg'), 1)((1, 3))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'banana'), 1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'boolean'), 1)("string")
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'ceiling'), 1)(0.9)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'codepoint-equal'), 2)('string', 'string')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'codepoints-to-string'), 1)((65, 66))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'compare'), 2)('string', 'string')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'concat'), 3)('a', 'bc', 'def')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'contains'), 2)('string', 'rin')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'count'), 1)((1, true()))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'current-date'), 0)()
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'current-dateTime'), 0)()
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'current-time'), 0)()
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'data'), 1)(/root/child[1])
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'dateTime'), 2)(xs:date('2012-01-01Z'), xs:time('00:00:00Z'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'day-from-date'), 1)(xs:date('2012-02-01Z'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'day-from-dateTime'), 1)(xs:dateTime('2012-04-03T02:01:00Z'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'days-from-duration'), 1)(xs:dayTimeDuration("P3DT10H"))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'deep-equal'), 2)((1, true()), (1, true()))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'empty'), 1)((1, true()))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'encode-for-uri'), 1)(' ')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'ends-with'), 2)('string', 'ing')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'exactly-one'), 1)(1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'exists'), 1)((1, true()))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'false'), 0)()
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'filter'), 2)(1 to 10, function($a) {$a mod 2 = 0})
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'floor'), 1)(1.1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'fold-left'), 3)(1 to 5, "", fn:concat(?, ".", ?))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'fold-right'), 3)(1 to 5, "", fn:concat(?, ".", ?))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'for-each'), 2)(("23", "29"), xs:int#1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'function-arity'), 1)(fn:abs#1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'function-lookup'), 2)(fn:QName('http://www.example.org', 'foo:bar'), 1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'function-name'), 1)(fn:abs#1)
/function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'has-children'), 0)()
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'has-children'), 1)(/)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'head'), 1)((1, true()))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'hours-from-dateTime'), 1)(xs:dateTime('2012-04-03T02:01:00Z'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'hours-from-duration'), 1)(xs:dayTimeDuration("P3DT10H"))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'hours-from-time'), 1)(xs:time('02:01:00Z'))
/function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'id'), 1)(('id1', 'id2'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'id'), 2)(('id1', 'id2'), /)
/function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'idref'), 1)(('id1', 'id2'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'idref'), 2)(('id1', 'id2'), /)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'implicit-timezone'), 0)()
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'innermost'), 1)(())
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'insert-before'), 3)((1, 2, 3), 2, ('a', 'b', 'c'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'iri-to-uri'), 1)('http://www.example.com/')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'local-name'), 1)(/root)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'local-name-from-QName'), 1)(fn:QName('http://www.example.org', 'foo:bar'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'lower-case'), 1)('STRING')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/map', 'contains'), 2)(map{}, 0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/map', 'for-each'), 2)(map{}, concat#2)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/map', 'get'), 2)(map{}, 1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/map', 'keys'), 1)(map{})
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/map', 'remove'), 2)(map{},1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/map', 'size'), 1)(map{})
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'matches'), 2)('string', 'string')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'acos'), 1)(1e0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'asin'), 1)(1e0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'atan'), 1)(1e0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'atan2'), 2)(1e0, 1e0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'cos'), 1)(1e0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'exp10'), 1)(1e0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'exp'), 1)(1e0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'log10'), 1)(1e0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'log'), 1)(1e0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'pi'), 0)()
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'pow'), 2)(1e0, 1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'sin'), 1)(1e0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'sqrt'), 1)(1e0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'tan'), 1)(1e0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'max'), 1)((1, 3))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'min'), 1)((1, 3))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'minutes-from-dateTime'), 1)(xs:dateTime('2012-04-03T02:01:00Z'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'minutes-from-duration'), 1)(xs:dayTimeDuration("P3DT10H"))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'minutes-from-time'), 1)(xs:time('02:01:00Z'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'month-from-date'), 1)(xs:date('2012-02-01Z'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'month-from-dateTime'), 1)(xs:dateTime('2012-04-03T02:01:00Z'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'months-from-duration'), 1)(xs:yearMonthDuration("P20Y15M"))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'name'), 1)(/root)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'name'), 2)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'namespace-uri'), 1)(/root/*[2])
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'namespace-uri-from-QName'), 1)(fn:QName('http://www.example.org', 'foo:bar'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'node-name'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'node-name'), ())
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'node-name'), 1, ())
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'node-name'), (1, 2))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'node-name'), 1)(/root)
function-lookup((fn:QName('http://www.w3.org/2005/xpath-functions', 'node-name'), fn:QName('http://www.w3.org/2005/xpath-functions', 'node-name')), 1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'normalize-space'), 1)(' string ')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'not'), 1)("string")
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'number'), 1)('1')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'one-or-more'), 1)(1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'outermost'), 1)(())
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'parse-json'), 1)( 'true' )
/function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'path'), 0)()
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'path'), 1)(/)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'prefix-from-QName'), 1)(fn:QName('http://www.example.org', 'foo:bar'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'QName'), 2)('http://www.example.org/', 'ns:local')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'remove'), 2)(('a', 'b', 'c'), 2)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'reverse'), 1)(1 to 3)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'root'), 1)(())
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'round'), 1)(1.1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'round'), 2)(1.1, 0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'round-half-to-even'), 1)(1.1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'round-half-to-even'), 2)(1.1, 0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'seconds-from-dateTime'), 1)(xs:dateTime('2012-04-03T02:01:00Z'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'seconds-from-duration'), 1)(xs:dayTimeDuration("P3DT10H12.5S"))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'seconds-from-time'), 1)(xs:time('02:01:00Z'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'starts-with'), 2)('string', 'str')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'string'), 1)(1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'string-join'), 1)(('abc', 'def'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'string-join'), 2)(('abc', 'def'), '-')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'string-length'), 1)('string')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'string-to-codepoints'), 1)('A')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'subsequence'), 2)((1, true()), 2e0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'subsequence'), 3)((1, true()), 1e0, 1e0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'substring'), 2)('string', 2e0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'substring'), 3)('string', 1e0, 1e0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'substring-after'), 2)('string', 'str')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'substring-before'), 2)('string', 'ing')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'sum'), 1)((1, 2))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'sum'), 2)((1, 2), 0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'tail'), 1)((1, true()))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'timezone-from-date'), 1)(xs:date('2012-01-01Z'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'timezone-from-dateTime'), 1)(xs:dateTime('2012-01-01T00:00:00Z'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'timezone-from-time'), 1)(xs:time('02:01:00Z'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'tokenize'), 1)('a b')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'tokenize'), 2)('string', 'i')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'trace'), 2)(1, 'label')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'translate'), 3)('string', 'i', 'o')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'true'), 0)()
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'unordered'), 1)(1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'upper-case'), 1)('string')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'year-from-date'), 1)(xs:date('2012-02-01Z'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'year-from-dateTime'), 1)(xs:dateTime('2012-04-03T02:01:00Z'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'years-from-duration'), 1)(xs:yearMonthDuration("P20Y15M"))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'zero-or-one'), 1)(1)
function-lookup(fn:QName('http://www.w3.org/2005/xquery-local-functions', 'missing'), 1)("arg")
function-lookup(QName("http://www.w3.org/2001/XMLSchema", "time"), 1)("12:30:00Z")
function-lookup(QName("http://www.w3.org/2005/xpath-functions", "abs"), 1)(-3)
function-lookup(QName("http://www.w3.org/2005/xpath-functions", "concat"), 3)("a", "b", "c")
function-lookup(QName("http://www.w3.org/2005/xpath-functions/math", "pi"), 0)() idiv 1
function-lookup(QName("http://www.w3.org/2005/xpath-functions", "round"), 2)(?, 3)(1.2345678)
function-lookup(QName("http://www.w3.org/2005/xpath-functions", "round"), 2) !                     (function-name(.) ! (namespace-uri-from-QName(.), local-name-from-QName(.)), function-arity(.))
function-lookup(QName("http://www.w3.org/2005/xquery-local-functions", "cube"), 1)
function-lookup(QName("", "round"), 2)
function-lookup(xs:QName('math:pi'), 0)()
function-name(function() { 5 })
function-name(function-name#1)
function-name(let $a := 92, $b := true() return function($c) { $a, $b, $c })
"gobbledygook" castable as xs:language
"&gt;"
head(3 to 10)
head(("a", "b", current-dateTime()))
head(/works/cucumber)
"He said, ""I don't like it."""
'He said, "I don''t like it."'
*(:hey:):(:hey:) ncname
*(:hey:):ncname
*:(:hey:)ncname
//hours => count()
hours-from-dateTime()
hours-from-dateTime(()) instance of xs:integer?
hours-from-dateTime((), "Wrong param")
hours-from-dateTime(xs:dateTime("2001-02-03T08:23:12.43")) eq 8
(hours-from-dateTime( xs:dateTime('2006-08-15T10:30:23')))
(hours-from-dateTime( xs:dateTime('2006-08-15T10:30:23-05:00')))
(hours-from-dateTime( xs:dateTime('2006-08-15T10:30:23')), hours-from-dateTime( xs:dateTime('2006-08-15T10:30:23-05:00')))
hours-from-duration()
hours-from-duration(()) instance of xs:integer?
hours-from-duration((), "Wrong param")
(hours-from-duration( xs:dayTimeDuration('P1DT5H')))
(hours-from-duration( xs:dayTimeDuration('P1DT5H')), hours-from-duration( xs:dayTimeDuration('-PT36H')), hours-from-duration( xs:dayTimeDuration('PT1H90M')), hours-from-duration( xs:dayTimeDuration('PT2H59M')), hours-from-duration( xs:dayTimeDuration('PT3600S')))
hours-from-duration(xs:dayTimeDuration("-P3DT8H2M1.03S")) eq -8
hours-from-duration(xs:dayTimeDuration("P3DT8H2M1.03S")) eq 8
(hours-from-duration( xs:dayTimeDuration('PT1H90M')))
(hours-from-duration( xs:dayTimeDuration('PT2H59M')))
(hours-from-duration( xs:dayTimeDuration('PT3600S')))
(hours-from-duration( xs:dayTimeDuration('-PT36H')))
hours-from-duration(xs:duration("-P3Y4M8DT1H23M2.34S")) eq -1
hours-from-time()
hours-from-time(()) instance of xs:integer?
hours-from-time((), "Wrong param")
(hours-from-time( xs:time('10:30:23')))
(hours-from-time( xs:time('10:30:23-05:00')))
(hours-from-time( xs:time('10:30:23')), hours-from-time( xs:time('10:30:23-05:00')))
hours-from-time(xs:time("23:11:12.43")) eq 23
"http://example.com?query=" cast as xs:anyURI
("http:\\invalid>URI\someURI") castable as xs:anyURI
id((), ())
() idiv 1
idref((), ())
if()
if((1, 2, 3, hours-from-time(current-time()))[1]) then true() else false()
if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else ()
if (2 != 4) then 1 else 0
(if(2) then 1 else 0) eq 1
( if (3 != 2) then 16 else 0 ) + ( if (8 = 7) then 4 else 1 )
(if (3 != 2) then 16 else 0) + (if (8 = 7) then 4 else 1)
if(5 < exactly-one((1 to 10)[. div 2 = 5])) then codepoints-to-string(32 to exactly-one((1 to 100)[. div 2 = 40])) else ()
if (//CompanyName) then <elem1/> else <elem2/>
if(count((1, 2, 3, current-time(), 4))) then true() else 4
if ( count( for $f in //* where $f/File return $f/File[1] ) = count( //File[1]) ) then <Same/> else <notSame/>
(if (current-date() gt xs:date('2000-12-31')) then upper-case#1 else lower-case#1)("Mike")
(if(current-time()) then 1 else 0) eq 1
if (/doc/widget1/@unit-cost = /doc/widget2/@unit-cost) then /doc/widget1/@name else /doc/widget2/@name
if(//(employee[location = "Denver"]/ancestor::*)) then 1 else 3
if(false()) then name() else true()
if(false()) then normalize-space() else true()
if(false()) then string-length() else true()
if //File[1] then "true" else "false"
if (fn:false()) then <elem1/> else <elem2/>
if (fn:true()) then <elem1/> else <elem2/>
if(for $i in <e> <a id="3"/> <b id="2"/> <c id="1"/> </e>/* order by xs:integer($i/@id) return $i) then 4 else 9
if (if (5 != 3) then fn:true() else fn:empty(/doc/widget1)) then "search" else "assume"
if (implicit-timezone() eq xs:dayTimeDuration('PT1H'))             then xs:gDay("---31+01:01") eq xs:gDay("---31")             else xs:gDay("---31+01:00") eq xs:gDay("---31")
if (implicit-timezone() eq xs:dayTimeDuration('PT1H'))             then xs:gDay("---31") eq xs:gDay("---31+01:01")             else xs:gDay("---31") eq xs:gDay("---31+01:00")
if (implicit-timezone() eq xs:dayTimeDuration('PT1M'))             then xs:gMonthDay("--12-30") eq xs:gMonthDay("--12-31+01:01")             else xs:gMonthDay("--12-30") eq xs:gMonthDay("--12-31+01:00")
if (implicit-timezone() eq xs:dayTimeDuration('PT1M'))             then xs:gMonthDay("--12-31+01:01") eq xs:gMonthDay("--12-30")             else xs:gMonthDay("--12-31+01:00") eq xs:gMonthDay("--12-30")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gDay("---30") eq xs:gDay("---31-09:01")             else xs:gDay("---30") eq xs:gDay("---31-09:00")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gDay("---30") eq xs:gDay("---31+09:01")             else xs:gDay("---30") eq xs:gDay("---31+09:00")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gDay("---30") ne xs:gDay("---31-09:01")             else xs:gDay("---30") ne xs:gDay("---31-09:00")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gDay("---30") ne xs:gDay("---31+09:01")             else xs:gDay("---30") ne xs:gDay("---31+09:00")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gDay("---31-09:01") eq xs:gDay("---30")             else xs:gDay("---31-09:00") eq xs:gDay("---30")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gDay("---31+09:01") eq xs:gDay("---30")             else xs:gDay("---31+09:00") eq xs:gDay("---30")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gDay("---31-09:01") ne xs:gDay("---30")             else xs:gDay("---31-09:00") ne xs:gDay("---30")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gDay("---31+09:01") ne xs:gDay("---30")             else xs:gDay("---31+09:00") ne xs:gDay("---30")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gMonth("--06-09:01") eq xs:gMonth("--06")             else xs:gMonth("--06-09:00") eq xs:gMonth("--06")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gMonth("--06+09:01") eq xs:gMonth("--06")             else xs:gMonth("--06+09:00") eq xs:gMonth("--06")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gMonth("--06-09:01") ne xs:gMonth("--06")             else xs:gMonth("--06-09:00") ne xs:gMonth("--06")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gMonth("--06+09:01") ne xs:gMonth("--06")             else xs:gMonth("--06+09:00") ne xs:gMonth("--06")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gMonth("--06") eq xs:gMonth("--06-09:01")             else xs:gMonth("--06") eq xs:gMonth("--06-09:00")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gMonth("--06") eq xs:gMonth("--06+09:01")             else xs:gMonth("--06") eq xs:gMonth("--06+09:00")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gMonth("--06") ne xs:gMonth("--06-09:01")             else xs:gMonth("--06") ne xs:gMonth("--06-09:00")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gMonth("--06") ne xs:gMonth("--06+09:01")             else xs:gMonth("--06") ne xs:gMonth("--06+09:00")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gMonthDay("--12-30") eq xs:gMonthDay("--12-31-09:01")             else xs:gMonthDay("--12-30") eq xs:gMonthDay("--12-31-09:00")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gMonthDay("--12-30") eq xs:gMonthDay("--12-31+09:01")             else xs:gMonthDay("--12-30") eq xs:gMonthDay("--12-31+09:00")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gMonthDay("--12-30") ne xs:gMonthDay("--12-31-09:01")             else xs:gMonthDay("--12-30") ne xs:gMonthDay("--12-31-09:00")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gMonthDay("--12-30") ne xs:gMonthDay("--12-31+09:01")             else xs:gMonthDay("--12-30") ne xs:gMonthDay("--12-31+09:00")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gMonthDay("--12-31-09:01") eq xs:gMonthDay("--12-30")             else xs:gMonthDay("--12-31-09:00") eq xs:gMonthDay("--12-30")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gMonthDay("--12-31+09:01") eq xs:gMonthDay("--12-30")             else xs:gMonthDay("--12-31+09:00") eq xs:gMonthDay("--12-30")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gMonthDay("--12-31-09:01") ne xs:gMonthDay("--12-30")             else xs:gMonthDay("--12-31-09:00") ne xs:gMonthDay("--12-30")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gMonthDay("--12-31+09:01") ne xs:gMonthDay("--12-30")             else xs:gMonthDay("--12-31+09:00") ne xs:gMonthDay("--12-30")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gYear("2008-09:01") eq xs:gYear("2008")             else xs:gYear("2008-09:00") eq xs:gYear("2008")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gYear("2008+09:01") eq xs:gYear("2008")             else xs:gYear("2008+09:00") eq xs:gYear("2008")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gYear("2008-09:01") ne xs:gYear("2008")             else xs:gYear("2008-09:00") ne xs:gYear("2008")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gYear("2008+09:01") ne xs:gYear("2008")             else xs:gYear("2008+09:00") ne xs:gYear("2008")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gYear("2008") eq xs:gYear("2008-09:01")             else xs:gYear("2008") eq xs:gYear("2008-09:00")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gYear("2008") eq xs:gYear("2008+09:01")             else xs:gYear("2008") eq xs:gYear("2008+09:00")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gYear("2008") ne xs:gYear("2008-09:01")             else xs:gYear("2008") ne xs:gYear("2008-09:00")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gYear("2008") ne xs:gYear("2008+09:01")             else xs:gYear("2008") ne xs:gYear("2008+09:00")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gYearMonth("2008-01-09:01") eq xs:gYearMonth("2008-01")             else xs:gYearMonth("2008-01-09:00") eq xs:gYearMonth("2008-01")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gYearMonth("2008-01+09:01") eq xs:gYearMonth("2008-01")             else xs:gYearMonth("2008-01+09:00") eq xs:gYearMonth("2008-01")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gYearMonth("2008-01-09:01") ne xs:gYearMonth("2008-01")             else xs:gYearMonth("2008-01-09:00") ne xs:gYearMonth("2008-01")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gYearMonth("2008-01+09:01") ne xs:gYearMonth("2008-01")             else xs:gYearMonth("2008-01+09:00") ne xs:gYearMonth("2008-01")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gYearMonth("2008-01") eq xs:gYearMonth("2008-01-09:01")             else xs:gYearMonth("2008-01") eq xs:gYearMonth("2008-01-09:00")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gYearMonth("2008-01") eq xs:gYearMonth("2008-01+09:01")             else xs:gYearMonth("2008-01") eq xs:gYearMonth("2008-01+09:00")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gYearMonth("2008-01") ne xs:gYearMonth("2008-01-09:01")             else xs:gYearMonth("2008-01") ne xs:gYearMonth("2008-01-09:00")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gYearMonth("2008-01") ne xs:gYearMonth("2008-01+09:01")             else xs:gYearMonth("2008-01") ne xs:gYearMonth("2008-01+09:00")
if (max(for $x in 1 to 10 return $x mod 9 = 0)) then true() else false()
if (//MissingNode) then <elem3/> else if (/Root/Customers[@CustomerID='ALFKI']//Country = "Germany") then <elem1/> else <elem2/>
if (//NodeDoesNotExist) then <elem1/> else <elem2/>
if(not(count(remove((1, 2, 3, current-time()), 1)))) then 3 else true()
if ( /Root/Customers[1]/@CustomerID = 'ALFKI' and /Root/Customers[1]/FullAddress/City = 'Berlin') then "pass" else "fail"
if (/Root/Customers[1]/@CustomerID = 'ALFKI' or /Root/Customers[1]/FullAddress/City = 'Non-Existent') then "pass" else "fail"
if(()) then false() else true()
if(!true()) then 2 else 3
if(true()) then true() else string()
"I love brownies&amp;cookies." eq "I love brownies&amp;cookies."
implicit-timezone() ge xs:dayTimeDuration('-PT14H') and implicit-timezone() le xs:dayTimeDuration('PT14H')
implicit-timezone("WRONG PARAM")
(implicit-timezone() + xs:dayTimeDuration('PT1S')) div (implicit-timezone() + xs:dayTimeDuration('PT1S'))
import gt import
import module "%gg"; true()
import module "http://www.example.org/foo"; import module "http://www.example.org/foo"; 1
import module namespace m="http://example.com/hof-003";          let $f := m:f#1 return $f(17)
import schema namespace NCName := "http://example.com/Dummy"; 1
index-of()
index-of(1)
index-of((1, 2, 3), 1, ())
index-of(1 to 10,(1 to 10)[. div 2 = 0][1])
index-of((1 to 10,(1 to 10)[. mod 2 = 0]),4)
index-of(1 to 5,4)
index-of(4, 4)
(index-of( (4, 5, 6, 4), 04.0))
(index-of( (4, 5, 6, 4), 4))
(index-of( (), 'a'))
(index-of( (<a>1</a>, <b>1</b>), <c>1</c> ))
(index-of( ('a', 'b', 'c'), 'a'))
(index-of( ('a', 'b', 'c'), 'd'))
index-of('a', 'b', 'http://www.cbcl.co.u,/collation')
index-of("a string", "a string", "http://www.example.com/COLLATION/NOT/SUPPORTED")
index-of("a string", "a string", "http://www.w3.org/2005/xpath-functions/collation/codepoint", "wrong param")
index-of(exactly-one((1 to 10)[. div 5 = 1]),5)
index-of(xs:untypedAtomic("example.com/"), xs:anyURI("example.com/"))
"inf" cast as xs:decimal
"-inF " cast as xs:decimal
"-inF" cast as xs:decimal
"inF " cast as xs:decimal
"inF" cast as xs:decimal
('Ingratitude, ' ||  'thou ' ||  'marble-hearted' ||  ' fiend!')
innermost(//*) except //*
innermost(//rubbish)
insert-before()
insert-before((), 1, 3) eq 3
insert-before((), 1, "a string") eq "a string"
insert-before((1 to 10,(20 to 30)[. mod 2 = 0],30 to 40),12,"blah")
insert-before(1 to 10,5,20 to 30)
insert-before((), 30, 7) eq 7
insert-before((), -31, "a string") eq "a string"
(insert-before( (), 3, ('a', 'b', 'c') ))
insert-before(9, 30, ()) eq 9
(insert-before( ('a', 'b', 'c'), 0, ('x', 'y')))
(insert-before( ('a', 'b', 'c'), 10, ('x', 'y')))
(insert-before( ('a', 'b', 'c'), 1, ('x', 'y')))
(insert-before( ('a', 'b', 'c'), 1, ('x', 'y')), insert-before( ('a', 'b', 'c'), 2, ('x', 'y')), insert-before( ('a', 'b', 'c'), 10, ('x', 'y')), insert-before( ('a', 'b', 'c'), 0, ('x', 'y')), insert-before( ('a', 'b', 'c'), 2, ()), insert-before( (), 3, ('a', 'b', 'c') ))
(insert-before( ('a', 'b', 'c'), 2, ()))
(insert-before( ('a', 'b', 'c'), 2, ('x', 'y')))
insert-before((), (), "a string")
insert-before("wrong params", 2)
insert-before("wrong params", 2, 3, 4)
(() ||  ()) instance of xs:string
(//integer[fn:not(fn:false())])
(//integer[fn:true()])
(//integer[fn:true() and fn:true()])
(//integer[fn:true() or fn:true()])
() intersect ()
<?invalid|char ?>
iri-to-uri(" ")
iri-to-uri("<> ""{}|\^`")
iri-to-uri('')
iri-to-uri('',())
iri-to-uri(())
iri-to-uri()
iri-to-uri(1)
iri-to-uri(12)
iri-to-uri("a string", "a string")
iri-to-uri(("a string", "a string"))
iri-to-uri(codepoints-to-string(15000 to 16000))
iri-to-uri(codepoints-to-string(32 to 294))
iri-to-uri(()) eq ""
(iri-to-uri( 'http://datypic.com/Sales Numbers.pdf'))
iri-to-uri("http://example.com/", "wrong param")
iri-to-uri("http://www.example.com/00/Weather/CA/Los%20Angeles#ocean")
iri-to-uri("http://www.example.com/~bébé")
iri-to-uri(xs:anyURI("a string"))
iri-to-uri(xs:untypedAtomic("a string"))
() is
is ()
item()
"it is " || 10 to 1 || "already"
key('func', "a value")
key("id")
<keywords> <ancestor-or-self/> <ancestor/> <and/> <as/> <ascending/> <at/> <attribute/>        <base-uri/> <boundary-space/> <by/>        <case/> <cast/> <castable/> <child/> <collation/> <comment/> <construction/> <copy-namespaces/>        <declare/> <default/> <descendant-or-self/> <descendant/> <descending/> <div/> <document-node/> <document/>        <element/> <else/> <empty-sequence/> <empty/> <encoding/> <eq/> <every/> <except/> <external/>        <following-sibling/> <following/> <for/> <function/>        <ge/> <greatest/> <gt/>        <idiv/> <if/> <import/> <in/> <inherit/> <instance/> <intersect/> <is/> <item/>        <lax/> <le/> <least/> <let/> <lt/>        <mod/> <module/> <module/>        <namespace/> <ne/> <no-inherit/> <no-preserve/> <node/>        <of/> <option/> <or/> <order/> <ordered/> <ordering/>        <parent/> <preceding-sibling/> <preceding/> <preserve/> <processing-instruction/>        <return/>        <satisfies/> <schema-attribute/> <schema-element/> <schema/> <self/> <some/> <stable/> <strict/> <strip/>        <text/> <then/> <to/> <treat/> <typeswitch/>        <union/> <unordered/>        <validate/> <variable/> <version/>        <where/>        <xquery/> </keywords>/name()
<keywords>            <exponent-separator/>         </keywords>/name()
<keywords>            <NaN/>            <allowing/>            <ancestor-or-self/>            <ancestor/>            <and/>            <as/>            <ascending/>            <at/>            <attribute/>            <base-uri/>            <boundary-space/>            <by/>            <case/>            <cast/>            <castable/>            <catch/>            <child/>            <collation/>            <comment/>            <construction/>            <context/>            <copy-namespaces/>            <count/>            <decimal-format/>            <decimal-separator/>            <declare/>            <default/>            <descendant-or-self/>            <descendant/>            <descending/>            <digit/>            <div/>            <document-node/>            <document/>            <element/>            <else/>            <empty-sequence/>            <empty/>            <encoding/>            <end/>            <eq/>            <every/>            <except/>            <external/>            <following-sibling/>            <following/>            <for/>            <function/>            <ge/>            <greatest/>            <group/>            <grouping-separator/>            <gt/>            <idiv/>            <if/>            <import/>            <in/>            <infinity/>            <inherit/>            <instance/>            <intersect/>            <is/>            <item/>            <lax/>            <le/>            <least/>            <let/>            <lt/>            <minus-sign/>            <mod/>            <module/>            <namespace-node/>            <namespace/>            <ne/>            <next/>            <no-inherit/>            <no-preserve/>            <node/>            <of/>            <only/>            <option/>            <or/>            <order/>            <ordered/>            <ordering/>            <parent/>            <pattern-separator/>            <per-mille/>            <percent/>            <preceding-sibling/>            <preceding/>            <preserve/>            <previous/>            <processing-instruction/>            <return/>            <satisfies/>            <schema-attribute/>            <schema-element/>            <schema/>            <self/>            <sliding/>            <some/>            <stable/>            <start/>            <strict/>            <strip/>            <switch/>            <text/>            <then/>            <to/>            <treat/>            <try/>            <tumbling/>            <type/>            <typeswitch/>            <union/>            <unordered/>            <validate/>            <variable/>            <version/>            <when/>            <where/>            <window/>            <xquery/>            <zero-digit/>         </keywords>/name()
last()
last(1)
let
let $a := $b return ($a)
let $a := 1 let $b := $a let $c := $a+$b return ($c)
let $a := 1 return                  for $b in 1 return                      if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else ()
(let $a := 92, $b := true() return function($c) { $a, $b, $c })("lala")
(let $a := 92, $b := true() return function($c) { $a, $b, $c })((xs:QName("foo"), 5.0e3))
let $A := ["A", "B", "C", "D"] return array:for-each-pair($A, array:tail($A), concat#2)
let $abc := ("a", "b", "c")                       return                   fn:insert-before($abc, 0, "z")
let $abc := ("a", "b", "c")                       return                   fn:insert-before($abc, 1, "z")
let $abc := ("a", "b", "c")                       return                   fn:insert-before($abc, 2, "z")
let $abc := ("a", "b", "c")                       return                   fn:insert-before($abc, 3, "z")
let $abc := ("a", "b", "c")                       return                   fn:insert-before($abc, 4, "z")
let $abc := ("a", "b", "c")                       return                   fn:remove($abc, 0)
let $abc := ("a", "b", "c")                       return                   fn:remove($abc, 1)
let $abc := ("a", "b", "c")                       return                   fn:remove($abc, 6)
let $abc := ("a", "b", "c")                       return                   fn:remove((), 3)
let $abc := ("a", "b", "c")                       return                   fn:reverse($abc)
let $abc := ("a", "b", "")                       return                   fn:boolean($abc[0])
let $abc := ("a", "b", "")                       return                   fn:boolean($abc[1])
let $abc := ("a", "b", "")                       return                   fn:boolean($abc[3])
let $add := function($x, $y){$x + $y} return $add(4, 2)
let $add := function($x, $y) {$x + $y} return function-arity($add)
let $add := function($x, $y) {$x + $y} return function-name($add)
let $add := function($x, $y) as xs:double {$x + $y}          return $add(3, 4)
let $add := function($x, $y) as xs:integer {$x + $y}          return $add(3, 4)
let $add := function($x, $y) as xs:integer {$x + $y}          return $add(3, 4.1)
let $add := function($x as xs:integer, $y as xs:integer){$x + $y}          return $add(3,4)
let $add := function($x as xs:integer, $y as xs:integer){$x + $y}          return $add(3,4.2)
let $add := %Q{http://example.com/speed}fast %Q{http://example.com/origin}author("Mike") function($x, $y) {$x + $y} return $add(2,2)
let $add := %Q{http://example.com/speed}fast() %Q{http://example.com/origin}author("Mike") function($x, $y) {$x + $y} return $add(2,2)
let $add := %Q{http://example.com/speed}fast(true())  function($x, $y) {$x + $y} return $add(2,2)
let $add := % Q{http://example.com/speed}speed (-1)  function($x, $y) {$x + $y} return $add(2,2)
let $add := % Q{http://example.com/speed}speed (())  function($x, $y) {$x + $y} return $add(2,2)
let $address := '123 Main Street Traverse City, MI 49684' return (matches($address, 'Main Street'))
let $address := '123 Main Street Traverse City, MI 49684' return (matches($address, 'street'))
let $address := '123 Main Street Traverse City, MI 49684' return (matches($address, 'Street$'))
let $address := '123 Main Street Traverse City, MI 49684' return (matches($address, 'Street.*City'))
let $address := '123 Main Street Traverse City, MI 49684' return (matches((), 'q' ))
let $address := '123 Main Street Traverse City, MI 49684' return (matches('query', '[a-z]{5}'))
let $address := '123 Main Street Traverse City, MI 49684' return (matches('query', 'q'))
let $address := '123 Main Street Traverse City, MI 49684' return (matches('query', 'q.*'))
let $address := '123 Main Street Traverse City, MI 49684' return (matches('query', '^qu'))
let $address := '123 Main Street Traverse City, MI 49684' return (matches('query', 'qu$'))
let $address := '123 Main Street Traverse City, MI 49684' return (matches('query', 'ue'))
let $address := '123 Main Street Traverse City, MI 49684' return (matches('query', '[ux]'))
let $a := (<elem1/>, <elem2/>, <elem3 att="test"/>) return <root>{$a}</root>
let $a := <elem/> let $b := <elem2/> return ($a,$b)
let $allbikes := $items//item_tuple [contains(exactly-one(description), "Bicycle") or contains(exactly-one(description), "Tricycle")]          let $bikebids := $bids//bid_tuple[itemno = $allbikes/itemno]          return <high_bid> { max($bikebids/bid) } </high_bid>
let $a := "monkey" return function($a) { "lala", $a }("gibbon")
let $ancestor-or-self := 1        let $ancestor := 1        let $and := 1        let $as := 1        let $ascending := 1        let $at := 1        let $attribute := 1        let $base-uri := 1        let $boundary-space := 1        let $by := 1        let $case := 1        let $cast := 1        let $castable := 1        let $child := 1        let $collation := 1        let $comment := 1        let $construction := 1        let $copy-namespaces := 1        let $declare := 1        let $default := 1        let $descendant-or-self := 1        let $descendant := 1        let $descending := 1        let $div := 1        let $document-node := 1        let $document := 1        let $element := 1        let $else := 1        let $empty-sequence := 1        let $empty := 1        let $encoding := 1        let $eq := 1 let $every := 1 let $except := 1 let $external := 1 let $following-sibling := 1        let $following := 1 let $for := 1 let $function := 1 let $ge := 1 let $greatest := 1        let $gt := 1 let $idiv := 1 let $if := 1 let $import := 1 let $in := 1 let $inherit := 1        let $instance := 1 let $intersect := 1 let $is := 1 let $item := 1 let $lax := 1        let $le := 1 let $least := 1 let $let := 1 let $lt := 1 let $mod := 1 let $module := 1        let $module := 1 let $namespace := 1 let $ne := 1 let $no-inherit := 1        let $no-preserve := 1 let $node := 1 let $of := 1 let $option := 1 let $or := 1        let $order := 1 let $ordered := 1 let $ordering := 1 let $parent := 1 let $preceding-sibling := 1        let $preceding := 1 let $preserve := 1 let $processing-instruction := 1 let $return := 1        let $satisfies := 1 let $schema-attribute := 1 let $schema-element := 1 let $schema := 1        let $self := 1 let $some := 1 let $stable := 1 let $strict := 1 let $strip := 1        let $text := 1 let $then := 1 let $to := 1 let $treat := 1 let $typeswitch := 1        let $union := 1 let $unordered := 1 let $validate := 1 let $variable := 1 let $version := 1        let $where := 1 let $xquery := 1 return 2
let $a := . return fn:count(.[/=$a])
let $a := . return fn:count(.[/ is $a])
let $array:= ['a','b','c','d','e'] return 3=>$array()
let $a := string-join(?, "")          return $a(("foo", "bar", "baz"))
let $at :=            <attendees> <name last='Parker'             first='Peter'/> <name last='Barker' first='Bob'/> <name last='Parker'             first='Peter'/> </attendees>            return                   fn:deep-equal($at, $at/*)
let $at :=            <attendees> <name last='Parker'             first='Peter'/> <name last='Barker' first='Bob'/> <name last='Parker'             first='Peter'/> </attendees>            return                   fn:deep-equal($at/name[1], $at/name[2])
let $at :=            <attendees> <name last='Parker'             first='Peter'/> <name last='Barker' first='Bob'/> <name last='Parker'             first='Peter'/> </attendees>            return                   fn:deep-equal($at/name[1], $at/name[3])
let $at :=            <attendees> <name last='Parker'             first='Peter'/> <name last='Barker' first='Bob'/> <name last='Parker'             first='Peter'/> </attendees>            return                   fn:deep-equal($at/name[1], 'Peter Parker')
let $attr1 := attribute attr { 'foo' } return let $attr2 := attribute attr { 'bar' } return <a>{$attr1, $attr2 }</a>
let $attribute as attribute(*) := attribute foo { } return count($attribute/self::*:bar)
let $attribute as attribute(*) := attribute foo { } return count($attribute/self::bar)
let $attribute as attribute(foo) := attribute foo { }              return count($attribute/self::*:bar)
let $attribute as attribute(foo) := attribute foo { } return count($attribute/self::bar)
let $a := /works/employee[@gender='female']/@name return tail($a)/string()
let $a := /works/employee return count(tail($a/z))
let $a := /works/* return (head($a) is $a[1])
let $a := /works return head($a/*)/string(@name)
let $a := /works return name(head($a))
let $bonus := 10,              $outer := function($x) {                 let $inner := function($y) {$y + $x + $bonus}                 return $inner(5)              }          return $outer(3)
let $calc := map{             "+" : function($a, $b) {$a + $b},             "-" : function($a, $b) {$a - $b},             "*" : function($a, $b) {$a * $b},             "/" : function($a, $b) {$a div $b}}          return $calc("*")(2,3)
let $cat := (/) return (data($cat//number))
let $cat := (/) return (data($cat//product[1]/colorChoices))
let $cat := (/) return (data($cat//product[1]/@dept))
let $cat := (/) return (data($cat//product[1]/number))
let $cat := (/) return (data($cat//product[4]/desc))
let $comment as comment() := <!--comment--> return count($comment/self::*)
let $comment as comment() := <!--comment--> return count($comment/self::*:foo)
let $comment as comment() := <!--comment--> return count($comment/self::foo)
let $data := (/employees)               return filter($data/emp, function($x as element(emp)){xs:int($x/@salary) lt 300})
let $d := codepoints-to-string(13) return (          (every $s in tokenize(' '||$d||'a '||$d||'b', ',') satisfies (matches($s, '^(?:\n\ra\n\rb)$'))) and          (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\n\ra\n\rb)$'))))
let $d := codepoints-to-string(13) return (         matches($d||$d||'a'||$d||$d||'b'||$d||$d,          '^\r\ra\r\rb\r\r$'),         matches($d||$d||'a'||$d||$d||'b'||$d||$d,          '^\r+a\r+b\r+$'),         matches($d||$d||'b'||$d||$d||'a'||$d||$d,          '^\r\ra\r\rb\r\r$'),         matches($d||$d||'a'||$d||$d||'b'||$d||' ',     '^\r\ra\r\rb\r\r$'))
let $d := codepoints-to-string(13) return (         matches('a'||$d||' b', '^(?:a\r\nb)$'), matches('ab', '^(?:a\r\nb)$'))
let $d := current-date() return (['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])?($d)
let $d := current-date() return (['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[ .?($d) = 'b']
let $d := current-date() return (['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[ ?($d) = 'b']
let $d := function($x) {$x + .?2} return $d(12)
let $d := function($x) {$x?2} return $d([12, 13])
let $doc1 := <?cheese brie?> let $doc2 := <?cheese stilton?> return deep-equal($doc1, $doc2)
let $doc1 := <doc><?processing-instruction content ?></doc> let $doc2 := <doc><!--comment--></doc> return deep-equal($doc1, $doc2)
let $doc1 := <?foo bar?> let $doc2 := <?foo bar?> return deep-equal($doc1, $doc2)
let $doc1 := <?foo test?> let $doc2 := <?bar test?> return deep-equal($doc1, $doc2)
let $doc :=     <catalog>        <product dept="WMN">         <number>557</number>         <name language="en">Fleece Pullover</name>         <colorChoices>navy black</colorChoices>        </product>        <product dept="ACC">         <number>563</number>         <name language="en">Floppy Sun Hat</name>        </product>        <product dept="ACC">         <number>443</number>         <name language="en">Deluxe Travel Bag</name>        </product>        <product dept="MEN">         <number>784</number>         <name language="en">Cotton Dress Shirt</name>         <colorChoices>white gray</colorChoices>         <desc>Our <i>favorite</i> shirt!</desc>        </product>    </catalog>    let $prods := $doc//product    for $prod in $prods    where $prod << $prods[@dept = $prod/@dept][last()]    return $prod
let $doc :=            <doc>   <chap>     <section xml:id="xyz"/>   </chap> </doc>            return                   $doc//section ! fn:string-join(ancestor-or-self::*/name(), '/')
let $doc :=            <doc>   <chap>     <section xml:id="xyz"/>   </chap> </doc>            return                   $doc//@xml:id ! fn:string-join((node-name(), '="', ., '"'))
let $doc := (/)          return (11 to 15)!             (for $file at $c in $doc//File             where $c = last()             return string($file/FileName))
let $e := (0,1) return $e eq 0
let $e := (1,2) return $e eq 0
let $e := <a attr1 = "abc1"/>        return exists($e/self::Q{}*)
let $e := <a attr1 = "abc1"/>        return exists($e/self::Q{}:*)
let $e := <a attr1 = "abc1"/>        return exists($e/self::Q{}a)
let $e := <a attr1 = "abc1" xmlns="http://example.org/nametest-19"/>        return exists($e/self::Q{http://example.org/nametest-19}*)
let $e := <a attr1 = "abc1" xmlns="http://example.org/nametest-19"/>        return exists($e/self::Q{http://example.org/nametest-19}a)
let $e := <e><a>1</a><b>2</b><c>3</c></e>          return fn:string-join($e/*)
let $e := <e><a>1</a><b></b><c>3</c></e>          return fn:string-join($e/*)
let $e := <e><a>1</a><b></b><c>3</c></e>          return fn:string-join($e/d)
let $element as element(foo) := <foo/> return count($element/self::*:bar)
let $element as element(foo) := <foo/> return count($element/self::bar)
let $element as element(*) := <foo/> return count($element/self::*:bar)
let $element as element(*) := <foo/> return count($element/self::bar)
let $emp :=                         <employee xml:id="ID21256">                <empnr>E21256</empnr>                <first>John</first>                <last>Brown</last>             </employee>                      return                   fn:path($emp)
let $emp :=                         <employee xml:id="ID21256">                <empnr>E21256</empnr>                <first>John</first>                <last>Brown</last>             </employee>                      return                   fn:path($emp/empnr)
let $emp :=                         <employee xml:id="ID21256">                <empnr>E21256</empnr>                <first>John</first>                <last>Brown</last>             </employee>                      return                   fn:path($emp/@xml:id)
let $ex :=    <bla><n>10</n>       <n>123</n>       <n> 1234 </n>       <n> 2345.6 </n>       <n>          1555       </n>       <n> 12345 </n>    </bla>    return    $ex//n[.>1000] ! xs:decimal(.)
let $ex :=    <bla><n> -2 </n>       <n> -3.0e5 </n>       <n> +2345.6e0 </n>       <n>          +5678e0       </n>       <n>          1.2345e4       </n>       <n>          5.6789e+4       </n>       <n>          INF       </n>    </bla>    return    $ex//n[.>1000] ! xs:double(.)
let $exponent-separator := 1         return 2
let $f:= (ceiling#1, floor#1, round#1, abs#1)=>head() return 4.54=>$f()
let $f:= "ceiling" return 5.4=>$f()
let $f := concat#123456, $n := function-name($f)          return (local-name-from-QName($n), namespace-uri-from-QName($n), function-arity($f))
let $f := concat#8 return $f('a','b','c','d','e','f','g','h')
let $f := false#0 return 3[$f()]
let $f := fn:concat#3(?, '*', ?) let $g := $f('[', ?) return <out>{$g(']')}</out>
let $f := fn:contains(?, "e")          return for $s in ("Mike", "John", "Dave", "Mary", "Jane") return $f($s)
let $f := fn:function-name#1, $n := function-name($f)          return (local-name-from-QName($n), namespace-uri-from-QName($n), function-arity($f))
let $f := fn:round#1 return $f(1.2345)
let $f := fn:substring-before#2(?, '-') return <out>{$f('the-end-of-the-world')}</out>
let $f := function($a, $b){($b, $a)} return fold-right(1 to 5, (), $f)
let $f := function($a as xs:integer, $b as xs:integer) as xs:integer {           data(<a>{$a}{$b}</a>)         }         return $f(12, 34)
let $f := function($a as xs:string, $b as xs:string) {              starts-with($a, $b) and ends-with($a, $b)}(?, 'a')          return <out>{$f('abracadabra')}</out>
let $f := function($a) { node-name(.), $a }          return <a/>/$f(5)
let $f := function($ff as (function(item()) as item()), $s as xs:string){$ff($ff($s))} return           for-each((upper-case#1, lower-case#1, normalize-space#1, concat(?, '!')), $f(?, ' Say NO! '))
let $f := function ($in as xs:boolean) as xs:boolean { $in }          return $f(<a>0</a>)
let $f := function($Q{''}a, $Q{http:}a) { $Q{''}a + $Q{http:}a }          return $f(15, 27)
let $f := function($x){$x+1} return $f(2)
let $f := function($x as xs:double) {1 to $x}          return $f(3)
let $f := function($x as xs:double*){for-each($x,round#1)} return $f((1.2345, 6.789))
let $f := function($x as xs:integer) as xs:integer { (: there's nothing here :) }          return $f(2)
let $f := function($x as xs:integer) as xs:integer? { (: there's nothing here :)}          return $f(2)
let $f := function($x as xs:string) as xs:string { upper-case($x) }          let $n := function-name($f)          return <a loc="{local-name-from-QName($n)}" uri="{namespace-uri-from-QName($n)}"          arity="{function-arity($f)}" eloc="{empty(local-name-from-QName($n))}" euri="{empty(namespace-uri-from-QName($n))}"/>
let $f := function($x) {}          return $f(2)
let $f := function($x) { (: there's nothing here :)}          return $f(2)
let $f := function() { fn:boolean(.) } return $f()
let $f := function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'dateTimeStamp'), 1)       return if (exists($f)) then year-from-dateTime($f('2012-05-25T11:42:00+01:00')) else 2012
let $f := function-lookup(QName("http://exist-db.org/xquery/datetime", "days-in-month"), 1)         return if (exists($f)) then $f(xs:date("2012-02-28")) else "not-available"
let $f := function-lookup(QName("http://exslt.org/dates-and-times", "month-abbreviation"), 1)         return if (exists($f)) then $f("2012-02-28") else "not-available"
let $f :=function() { subsequence((1, 2, 3), 1) } return $f()
let $f :=function() { subsequence(subsequence((1, 2, 3, 4), 3, 1), 1, 4) } return $f()
let $f := if (current-date() gt xs:date('1900-01-01')) then head#1 else (abs#1, abs#1, abs#1, abs#1)         return $f[1](/works/cucumber)
let $f := if (current-date() gt xs:date('1900-01-01')) then head#1 else count#1         return $f(5 to 10)
let $firstSeq := (<a/>, <b/>, <e><c/></e>) let $secondSeq := (<a attr=""/>, <b>text</b>, <e><c/></e>) return some $i in $firstSeq satisfies $secondSeq[deep-equal(.,$i)]
let $f:= tokenize#1 return "the cat sat on the mat"=>$f()=>count()
let $f:= tokenize#2 return "the cat sat on the mat"=>($f)("\s+")=>count()
let $f:= tokenize#2 return "the cat sat on the mat"=>$f("\s+")=>count()
let $f := xs:date#1 return $f('2008-01-31')
let $f := xs:dateTime#1, $n := function-name($f)          return (local-name-from-QName($n), namespace-uri-from-QName($n), function-arity($f))
let $highbid := max($bids//bid_tuple/bid)          return <result> { for $item in $items//item_tuple,                                $b in $bids//bid_tuple[itemno = $item/itemno]                            where $b/bid = $highbid                            return <expensive_item> { $item/itemno } { $item/description }                                      <high_bid>{ $highbid }</high_bid>                                   </expensive_item>                 } </result>
let $hours := function ($emp as element(employee)) as xs:integer { sum($emp/hours/xs:integer(.)) },                 $highest := function ($f as function(item()) as xs:anyAtomicType, $seq as item()*)  {                                fold-left($seq, (), function($highestSoFar as item()*, $this as item()*) as item()* {                           if (empty($highestSoFar))                           then $this                           else let $thisValue := $f($this),                                    $highestValue := $f($highestSoFar[1])                                return if ($thisValue gt $highestValue)                                       then $this                                       else if ($thisValue eq $highestValue)                                            then ($highestSoFar, $this)                                            else $highestSoFar                        })             }                          return $highest($hours, /works/employee)
let $i := (1, 2, 3) order by $i return $i
let $i := (1, 2, 3) stable order by $i return $i
let $i := (1, 3, 2), $b := (4, 6, 5) order by $b return $b
let $i := (1, 3, 2) order by $i return $i
let $i := (1, 3, 2) stable order by $i return $i
let $i := (1, 3) return (['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])?($i)
let $i := (1, 3) return (['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[ .?($i) = 'b']
let $i := (1, 3) return (['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[ ?($i) = 'b']
let $i := 1 return (['a', 'b'], ['c', 'd'])?($i)
let $i := 1 return (['a', 'b'], ['c', 'd'])[.?($i) eq 'c']
let $i := 1 return (['a', 'b'], ['c', 'd'])[?($i) eq 'c']
let $i2 := (//incision)[2] for $a in (//action)[. >> $i2][position()<=2] return $a//instrument
let $i := 5, $j := 20 * $i return $i, $j
let $i = 5 return 3
let $i := (<e>1</e>, <e>3</e>, <e>2</e>) order by $i return $i
let $i := (<e>1</e>, <e>3</e>, <e>2</e>) order by 1 return $i
let $i := (<e>1</e>, <e>3</e>, <e>2</e>) stable order by $i return $i
let $i := <e/>/(., 4, 5, <e/>/((<e/>, 2))) return ($i, $i)
let $i := <e> <a/> <b/> <c/> </e>/a , $t := $i/following-sibling::b return (($i union ($i, $i)), (($t, $t) union $t))
let $i := <e><e/><e/><e/><e/><e/><e/><e/><b xml:id="foo"/><e/></e>return id("foo", $i)
let $i := <e xmlns:p="http://example.com" p:anAttribute="attrValue"/> return <a>{$i/@*}</a>
let $i := <e xml:space="preserve"/> return <a>{$i/@*}</a>
let $i := <html> <head/> <body> <p attr="foo"> </p> <p attr="boo"> </p> <p> </p> <p> </p> <p> </p> </body> </html>          return $i//p[1]/following::*
let $i in 5 return 3
let $in := <a><b>ABC</b><b>XYZ</b></a> return $in//string-to-codepoints(.)
let $index-of-node := function($seqParam as node()*, $srchParam as node()) as xs:integer*                                      { filter( 1 to count($seqParam), function($this as xs:integer) as xs:boolean                                               {$seqParam[$this] is $srchParam} ) },             $nodes := /*/*,             $perm := ($nodes[1], $nodes[2], $nodes[3], $nodes[1], $nodes[2], $nodes[4], $nodes[2], $nodes[1])              return $index-of-node($perm, $nodes[2])
let $in := for $x in //* order by local-name($x) return $x             return deep-equal(fn:innermost(($in, $in))/local-name(), fn:innermost(//*)/local-name())
let $in := for $x in //* order by local-name($x) return $x             return deep-equal(fn:innermost($in)/local-name(), fn:innermost(//*)/local-name())
let $in := for $x in //* order by local-name($x) return $x             return deep-equal(fn:outermost(($in, $in))/local-name(), fn:outermost(//*)/local-name())
let $in := for $x in //* order by local-name($x) return $x             return deep-equal(fn:outermost($in)/local-name(), fn:outermost(//*)/local-name())
let $initial := fn:substring(?, 1, 1) return                   fn:function-arity($initial)
let $initial := fn:substring(?, 1, 1)              return fn:function-name( $initial )
let $in := <r> <e xmlns="http://example.com/&lt;&gt;&quot;&apos;"""/> <e xmlns='http://example.com/&lt;&gt;&quot;&apos;'''/> <p:e xmlns:p="http://example.com/&lt;&gt;&quot;&apos;"""/> <p:e xmlns:p='http://example.com/&lt;&gt;&quot;&apos;'''/> </r> return <r>{for $n in $in/*/namespace-uri(.) return <e ns="{$n}"/>}</r>
let $in-xml-2 := <product dept="MEN"> <number>784</number> <name language="en">Cotton Dress Shirt</name> <colorChoices>white gray</colorChoices> <desc>Our <i>favorite</i> shirt!</desc> </product> return (string($in-xml-2/@dept))
let $in-xml-2 := <product dept="MEN"> <number>784</number> <name language="en">Cotton Dress Shirt</name> <colorChoices>white gray</colorChoices> <desc>Our <i>favorite</i> shirt!</desc> </product> return (string($in-xml-2/desc))
let $in-xml-2 := <product dept="MEN"> <number>784</number> <name language="en">Cotton Dress Shirt</name> <colorChoices>white gray</colorChoices> <desc>Our <i>favorite</i> shirt!</desc> </product> return (string($in-xml-2/number))
let $in-xml-2 := <product dept="MEN"> <number>784</number> <name language="en">Cotton Dress Shirt</name> <colorChoices>white gray</colorChoices> <desc>Our <i>favorite</i> shirt!</desc> </product> return (string($in-xml-2/number), string($in-xml-2/desc), string($in-xml-2/@dept))
let $in-xml := <a><x>123</x></a> return (root($in-xml/x))
let $in-xml := <in-xml> <a>1</a> <c>2</c> <a>3</a> <a>4</a> <a>5</a> </in-xml> return ($in-xml/a[position() > 2])
let $in-xml := <in-xml> <a>1</a> <c>2</c> <a>3</a> <a>4</a> <a>5</a> </in-xml> return ($in-xml/a[position() = 3])
let $in-xml := <in-xml> <a>1</a> <c>2</c> <a>3</a> <a>4</a> <a>5</a> </in-xml> return ($in-xml/*[position() > 2])
let $in-xml := <in-xml> <a>1</a> <c>2</c> <a>3</a> <a>4</a> <a>5</a> </in-xml> return ($in-xml/*[position() > 2], $in-xml/a[position() > 2], $in-xml/a[position() = 3])
let $in-xml := <in-xml> <a></a> <b/> <c>xyz</c> </in-xml> return (empty( () ))
let $in-xml := <in-xml> <a></a> <b/> <c>xyz</c> </in-xml> return (empty($in-xml/a))
let $in-xml := <in-xml> <a></a> <b/> <c>xyz</c> </in-xml> return (empty($in-xml/b))
let $in-xml := <in-xml> <a></a> <b/> <c>xyz</c> </in-xml> return (empty($in-xml/c))
let $in-xml := <in-xml> <a></a> <b/> <c>xyz</c> </in-xml> return (empty($in-xml/foo))
let $in-xml := <in-xml> <a></a> <b/> <c>xyz</c> </in-xml> return (empty(0))
let $in-xml := <in-xml> <a></a> <b/> <c>xyz</c> </in-xml> return (empty( ('a', 'b', 'c') ))
let $in-xml := <in-xml> <a></a> <b/> <c>xyz</c> </in-xml> return (empty( ('a', 'b', 'c') ), empty( () ), empty(0), empty($in-xml/a), empty($in-xml/b), empty($in-xml/c), empty($in-xml/foo))
let $item := $items//item_tuple [end_date >= xs:date("1999-03-01") and end_date <= xs:date("1999-03-31")]              return <item_count> { count($item) } </item_count>
let $items := for $x in 1 to 100 return $x mod 10, $distinct-items := for $y in 1 to (count($items) idiv 10) return $y mod 10 for $dist in $distinct-items return if ($dist = 0) then 0 else min( for $item in $items where $item = $dist return fn:round(1000 div $item))
let $i := (xs:date("2001-02-03"), xs:time("01:02:03Z")) order by $i return $i
let $i := (xs:date("2001-02-03"), xs:time("01:02:03Z")) stable order by $i return $i
let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) order by $i[1] return $i
let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) order by $i return $i
let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) stable order by $i[1] return $i
let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) stable order by $i return $i
let $i := (xs:hexBinary("FF"), xs:time("03:03:03Z"), xs:hexBinary("FF")) order by $i[1] return $i
let $i := (xs:hexBinary("FF"), xs:time("03:03:03Z"), xs:hexBinary("FF")) stable order by $i[1] return $i
let $k := 2 to 3 return ['A', 'B', 'C']?($k)
let $m := array {                 true(),                 true(),                 false(),                 true(),                 true(),                 false(),                 false() }           let $indices := (1 to 7)           return fn:filter($indices,$m)
let $m:= map{1:2, 2:4, 3:6} return 2=>$m()
let $m := map{'a':1} return map:size(map{$m?a:true()})
let $m := map {                 "Tuesday" : true(),                 "Wednesday" : true(),                 "Friday" : true(),                 "Monday" : true(),                 "Sunday" : false(),                 "Saturday" : false() }           let $days := ("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")                return fn:filter($days,$m)
let $m := map {                 "Tuesday" : true(),                 "Wednesday" : true(),                 "Thursday" : false(),                 "Friday" : true(),                 "Monday" : true(),                 "Sunday" : false(),                 "Saturday" : false() }           let $days := ("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")                return fn:filter($days,$m)
let $name := "ncname" return <e/>/processing-instruction($name))
let $NaN := 1         let $allowing := 1         let $ancestor-or-self := 1         let $ancestor := 1         let $and := 1         let $as := 1         let $ascending := 1         let $at := 1         let $attribute := 1         let $base-uri := 1         let $boundary-space := 1         let $by := 1         let $case := 1         let $cast := 1         let $castable := 1         let $catch := 1         let $child := 1         let $collation := 1         let $comment := 1         let $construction := 1         let $context := 1         let $copy-namespaces := 1         let $count := 1         let $decimal-format := 1         let $decimal-separator := 1         let $declare := 1         let $default := 1         let $descendant-or-self := 1         let $descendant := 1         let $descending := 1         let $digit := 1         let $div := 1         let $document-node := 1         let $document := 1         let $element := 1         let $else := 1         let $empty-sequence := 1         let $empty := 1         let $encoding := 1         let $end := 1         let $eq := 1         let $every := 1         let $except := 1         let $external := 1         let $following-sibling := 1         let $following := 1         let $for := 1         let $function := 1         let $ge := 1         let $greatest := 1         let $group := 1         let $grouping-separator := 1         let $gt := 1         let $idiv := 1         let $if := 1         let $import := 1         let $in := 1         let $infinity := 1         let $inherit := 1         let $instance := 1         let $intersect := 1         let $is := 1         let $item := 1         let $lax := 1         let $le := 1         let $least := 1         let $let := 1         let $lt := 1         let $minus-sign := 1         let $mod := 1         let $module := 1         let $namespace-node := 1         let $namespace := 1         let $ne := 1         let $next := 1         let $no-inherit := 1         let $no-preserve := 1         let $node := 1         let $of := 1         let $only := 1         let $option := 1         let $or := 1         let $order := 1         let $ordered := 1         let $ordering := 1         let $parent := 1         let $pattern-separator := 1         let $per-mille := 1         let $percent := 1         let $preceding-sibling := 1         let $preceding := 1         let $preserve := 1         let $previous := 1         let $processing-instruction := 1         let $return := 1         let $satisfies := 1         let $schema-attribute := 1         let $schema-element := 1         let $schema := 1         let $self := 1         let $sliding := 1         let $some := 1         let $stable := 1         let $start := 1         let $strict := 1         let $strip := 1         let $switch := 1         let $text := 1         let $then := 1         let $to := 1         let $treat := 1         let $try := 1         let $tumbling := 1         let $type := 1         let $typeswitch := 1         let $union := 1         let $unordered := 1         let $validate := 1         let $variable := 1         let $version := 1         let $when := 1         let $where := 1         let $window := 1         let $xquery := 1         let $zero-digit := 1         return 2
let $node := <a> <b/> <c/> </a>         return not(exactly-one($node/b[1]) << exactly-one($node/c[1]))
let $node := <a> <b/> <c/> </a>         return not(exactly-one($node/b[1]) >> exactly-one($node/c[1]))
let $node := <a> <b/> <c/> </a>         return not(exactly-one($node/b[1]) is exactly-one($node/c[1]))
let $node := <a> <b/> <c/> </a>         return not(not(exactly-one($node/b[1]) << exactly-one($node/c[1])))
let $node := <a> <b/> <c/> </a>         return not(not(exactly-one($node/b[1]) >> exactly-one($node/c[1])))
let $node := <a> <b/> <c/> </a>         return not(not(exactly-one($node/b[1]) is exactly-one($node/c[1])))
let $numbers := (1, 2, 1.3, 3e3, xs:double("NaN"), xs:double("-INF"), xs:double("INF")) return (for $i in $numbers order by $i empty least return $i, "SEP", for $i in $numbers order by $i empty greatest return $i)
let $numbers := (1, 2, 1.3, 3e3, xs:double("NaN"), xs:double("-INF"), xs:double("INF")) return (for $i in $numbers stable order by $i empty least return $i, "SEP", for $i in $numbers order by $i empty greatest return $i)
let $numbers := (<e>NaN</e>, <e/>, <e/>, <e>NaN</e>, <e>NaN</e>, <e>INF</e>, <e>NaN</e>, <e/>, <e>3</e>, comment{"3"}) return (for $i in $numbers order by xs:double($i/text()) empty least return xs:double($i/text()), "SEP", for $i in $numbers order by xs:double($i/text()) empty greatest return xs:double($i/text()))
let $numbers := (<e>NaN</e>, <e/>, <e/>, <e>NaN</e>, <e>NaN</e>, <e>INF</e>, <e>NaN</e>, <e/>, <e>3</e>, comment{"3"}) return (for $i in $numbers stable order by xs:double($i/text()) empty least return xs:double($i/text()), "SEP", for $i in $numbers stable order by xs:double($i/text()) empty greatest return xs:double($i/text()))
let $ops := substring-before(?, 2) return $ops('Michael Kay')
let $ops := substring-before('abc', ' ', (), ?) return $ops('Michael Kay')
let $ops := substring-before(?, ?) return $ops('Michael Kay')
let $ordDoc := (/) return (avg( () ))
let $ordDoc := (/) return (avg($ordDoc//item/@quantity))
let $ordDoc := (/) return (boolean( () ))
let $ordDoc := (/) return (boolean(''))
let $ordDoc := (/) return (boolean($ordDoc/noSuchChild))
let $ordDoc := (/) return (boolean($ordDoc/order[1]))
let $ordDoc := (/) return (boolean('0'))
let $ordDoc := (/) return (boolean(0))
let $ordDoc := (/) return (boolean(<a>false</a>))
let $ordDoc := (/) return (boolean( () ), boolean(''), boolean(0), boolean('0'), boolean('false'), boolean(xs:float('NaN')), boolean($ordDoc/order[1]), boolean($ordDoc/noSuchChild), boolean(<a>false</a>))
let $ordDoc := (/) return (boolean('false'))
let $ordDoc := (/) return (boolean(xs:float('NaN')))
let $ordDoc := (/) return (count( () ))
let $ordDoc := (/) return (count($ordDoc//item))
let $ordDoc := (/) return (count( (1, 2, 3) ))
let $ordDoc := (/) return (count( (1, 2, 3, () ) ))
let $ordDoc := (/) return (max($ordDoc//item/string(@dept)))
let $ordDoc := (/) return (max( 2 ))
let $ordDoc := (/) return (max( (2, 1, 5, 4, 3) ))
let $ordDoc := (/) return (max( (2, 1, 5, 4, 3) ), max( ('a', 'b', 'c') ), max( 2 ), max($ordDoc//item/string(@dept)))
let $ordDoc := (/) return (max( ('a', 'b', 'c') ))
let $ordDoc := (/) return (min($ordDoc//item/@color/string(.)))
let $ordDoc := (/) return (min($ordDoc//item//string(@color)))
let $ordDoc := (/) return (min( (2.0, 1, 3.5, 4) ))
let $ordDoc := (/) return (min( (2.0, 1, 3.5, 4) ), min( ('a', 'b', 'c') ), min($ordDoc//item//string(@color)), min($ordDoc//item/@color/string(.)))
let $ordDoc := (/) return (min( ('a', 'b', 'c') ))
let $ordDoc := (/) return (sum( () ))
let $ordDoc := (/) return (sum( (), () ))
let $ordDoc := (/) return (sum($ordDoc//item/@quantity))
let $ordDoc := (/) return (sum( (1, 2, 3) ))
let $ordDoc := (/) return (sum( (1, 2, 3, () ) ))
let $outer := function($x) {             let $inner := function($y) {$y + $x}             return $inner(5)          }          return $outer(3)
let $para :=             <para>In a hole in the ground there lived a <term author="Tolkien">hobbit</term>.</para>                      return                   data($para)
let $para :=             <para>In a hole in the ground there lived a <term author="Tolkien">hobbit</term>.</para>                      return                   data($para/term/@author)
let $para :=             <para>In a hole in the ground there lived a <term author="Tolkien">hobbit</term>.</para>                      return                   string($para)
let $pi := function(){3.14159} return $pi()
let $poem :=             <poem author="Wilhelm Busch"> Kaum hat dies der Hahn gesehen, Fängt er auch schon an zu krähen: Kikeriki! Kikikerikih!! Tak, tak, tak! - da kommen sie. </poem>            return                   fn:matches($poem, "^Kaum.*gesehen,$")
let $poem :=             <poem author="Wilhelm Busch"> Kaum hat dies der Hahn gesehen, Fängt er auch schon an zu krähen: Kikeriki! Kikikerikih!! Tak, tak, tak! - da kommen sie. </poem>            return                   fn:matches($poem, "Kaum.*krähen")
let $po :=            <PurchaseOrder> <line-item>          <description>Large widget</description> <price>8.95</price>          <quantity>5.0</quantity> </line-item> <line-item>          <description>Small widget</description> <price>3.99</price>          <quantity>2.0</quantity> </line-item> <line-item>          <description>Tiny widget</description> <price>1.49</price>a          <quantity>805</quantity> </line-item>          </PurchaseOrder>            return                     let $item1 := $po/line-item[1]                       return                   fn:number($item1/quantity)
let $po :=            <PurchaseOrder> <line-item>          <description>Large widget</description> <price>8.95</price>          <quantity>5.0</quantity> </line-item> <line-item>          <description>Small widget</description> <price>3.99</price>          <quantity>2.0</quantity> </line-item> <line-item>          <description>Tiny widget</description> <price>1.49</price>a          <quantity>805</quantity> </line-item>          </PurchaseOrder>            return                     let $item1 := $po/line-item[1]                       return                     let $item2 := $po/line-item[2]                       return                     let $seq1 := ($item1, $item2)                       return                   fn:count($seq1)
let $po :=            <PurchaseOrder> <line-item>          <description>Large widget</description> <price>8.95</price>          <quantity>5.0</quantity> </line-item> <line-item>          <description>Small widget</description> <price>3.99</price>          <quantity>2.0</quantity> </line-item> <line-item>          <description>Tiny widget</description> <price>1.49</price>a          <quantity>805</quantity> </line-item>          </PurchaseOrder>            return                     let $item2 := $po/line-item[2]                       return                   fn:number($item2/description)
let $priceDoc := (/) return ($priceDoc// prod/price[number() >          35])
let $priceDoc := (/) return (number( () ))
let $priceDoc := (/) return (number( $priceDoc//prod[1]/@currency))
let $priceDoc := (/) return (number( $priceDoc//prod[1]/price))
let $priceDoc := (/)           return (number( $priceDoc//prod[1]/price), number( $priceDoc//prod[1]/@currency),                            number('29.99'), number('ABC'), number( () ),                            $priceDoc// prod/price[number() > 35])
let $priceDoc := (/) return (number('29.99'))
let $priceDoc := (/) return (number('ABC'))
let $process := function($op, $x, $y) as function(*) {if ($op = "+") then function() {$x + $y} else function() {$x - $y}}          return $process("+", 3, 4)()
let $processing-instruction as processing-instruction() := <?processing instruction?>          return count($processing-instruction/self::*)
let $processing-instruction as processing-instruction() := <?processing instruction?>          return count($processing-instruction/self::*:processing)
let $processing-instruction as processing-instruction() := <?processing instruction?>          return count($processing-instruction/self::processing)
let $prod1 := <product dept='MEN' id='P123'> <number>784</number> </product> return let $prod2 := <product id='P123' dept='MEN'><!--comment--> <number>784</number> </product> return (deep-equal( $prod1, $prod2 ))
let $prod1 := <product dept='MEN' id='P123'> <number>784</number> </product> return let $prod2 := <product id='P123' dept='MEN'><!--comment--> <number>784</number> </product> return (deep-equal( $prod1/number, $prod2/number ))
let $prod1 := <product dept='MEN' id='P123'> <number>784</number> </product> return let $prod2 := <product id='P123' dept='MEN'><!--comment--> <number>784</number> </product> return (deep-equal( 1, 1 ))
let $prod1 := <product dept='MEN' id='P123'> <number>784</number> </product> return let $prod2 := <product id='P123' dept='MEN'><!--comment--> <number>784</number> </product> return (deep-equal( (1, 1), (1, 1) ))
let $prod1 := <product dept='MEN' id='P123'> <number>784</number> </product> return let $prod2 := <product id='P123' dept='MEN'><!--comment--> <number>784</number> </product> return (deep-equal( 1, 1 ), deep-equal( (1, 1), (1, 1) ), deep-equal( (1, 2), (1.0, 2.0) ), deep-equal( (1, 2), (2, 1) ), deep-equal( $prod1, $prod2 ), deep-equal( $prod1/number, $prod2/number ))
let $prod1 := <product dept='MEN' id='P123'> <number>784</number> </product> return let $prod2 := <product id='P123' dept='MEN'><!--comment--> <number>784</number> </product> return (deep-equal( (1, 2), (1.0, 2.0) ))
let $prod1 := <product dept='MEN' id='P123'> <number>784</number> </product> return let $prod2 := <product id='P123' dept='MEN'><!--comment--> <number>784</number> </product> return (deep-equal( (1, 2), (2, 1) ))
let $salary as xs:decimal := "cat" return $salary * 2
let $seq2 := (98.5, 98.3, 98.9)                       return                   fn:count($seq2)
let $seq2 := (98.5, 98.3, 98.9)                       return                   fn:count($seq2[. > 100])
let $seq3 := (3, 4, 5)                       return                   fn:avg($seq3)
let $seq3 := (3, 4, 5)                       return                   fn:avg(($seq3, xs:float('NaN')))
let $seq3 := (3, 4, 5)                       return                   fn:sum($seq3)
let $seq3 := ()                       return                   fn:count($seq3)
let $seq := ("item1", "item2", "item3", "item4", "item5")                       return                   fn:subsequence($seq, 3, 2)
let $seq := ("item1", "item2", "item3", "item4", "item5")                       return                   fn:subsequence($seq, 4)
let $string := ("&#xD;&#xA;&#x9; foobar &#xA;&#xD;&#x9;" cast as xs:NMTOKEN) return not(contains($string, '&#x9;') or contains($string, '&#xA;') or contains($string, '&#xD;') or string-length($string) ne 6)
let $text := "Peter Piper picked a peck of pickled peppers A peck of pickled peppers Peter Piper picked" let $tokens := tokenize($text, '\s') let $counter := function($result, $word){   let $word-count := $result[@value = $word]   return     if(empty($word-count)) then       ($result, <word value="{$word}" count="1" />)     else     (       $result except $word-count,       <word value="{$word-count/@value}" count="{number($word-count/@count) + 1}" />     ) } let $words := fold-left($tokens, (), $counter) return (   number($words[@value="Peter"]/@count),   number($words[@value="Piper"]/@count),   number($words[@value="pickled"]/@count) )
let $tree := <e> <a id="1"/> <a id="2"/> <a id="3"/> </e> for $i at $pos in ("a", "b", "c") return ($tree/a/@id = $pos, $pos)
let $tree := <e> <a id="1"/> <a id="2"/> <a id="3"/> </e> for $i at $pos in ("a", "b", "c") return ($tree/@id eq $pos, $pos)
let $t := true#0 return 3[$t()]
let $users := [map { "userid" : "W0342", "firstname" : "Walter", "lastname" : "Denisovich" }, map { "userid" : "M0535", "firstname" : "Mick", "lastname" : "Goulish" }]?*          let $holdings := [map { "userid" : "W0342", "ticker" : "DIS", "shares" : 153212312 }, map { "userid" : "M0535", "ticker" : "DIS", "shares" : 10 }, map { "userid" : "M0535", "ticker" : "AIG", "shares" : 23412 }]?*            return array {           for $u in $users           order by $u("userid")           return map { "userid" : $u("userid"),                         "first" :  $u("firstname"),                         "last" :   $u("lastname"),                         "holdings" : array {                           for $h in $holdings                           where $h("userid") = $u("userid")                           order by $h("ticker")         return map { "ticker" : $h("ticker"), "share" : $h("shares") }     }                  }         }
let $value := xs:byte(10.0) return $value cast as xs:float
let $value := xs:decimal(10.0) return $value cast as xs:float
let $value := xs:decimal(10E2) return $value cast as xs:double
let $value := xs:double(10E2) return $value cast as xs:decimal
let $value := xs:double(10E2) return $value cast as xs:int
let $value := xs:double(10E2) return $value cast as xs:integer
let $value := xs:double(10E2) return $value cast as xs:long
let $value := xs:double(10E2) return $value cast as xs:positiveInteger
let $value := xs:double(10E2) return $value cast as xs:short
let $value := xs:double(10E2) return $value cast as xs:unsignedLong
let $value := xs:float(10.0) return $value cast as xs:byte
let $value := xs:float(10.0) return $value cast as xs:decimal
let $value := xs:float(10.0) return $value cast as xs:int
let $value := xs:float(10.0) return $value cast as xs:long
let $value := xs:float(-10.0) return $value cast as xs:negativeInteger
let $value := xs:float(10.0) return $value cast as xs:nonNegativeInteger
let $value := xs:float(-10.0) return $value cast as xs:nonPositiveInteger
let $value := xs:float(10.0) return $value cast as xs:positiveInteger
let $value := xs:float(10.0) return $value cast as xs:short
let $value := xs:float(10.0) return $value cast as xs:unsignedByte
let $value := xs:float(10.0) return $value cast as xs:unsignedInt
let $value := xs:float(10.0) return $value cast as xs:unsignedLong
let $value := xs:float(10.0) return $value cast as xs:unsignedShort
let $value := xs:int(10.0) return $value cast as xs:float
let $value := xs:int(10E2) return $value cast as xs:double
let $value := xs:integer(10.0) return $value cast as xs:byte
let $value := xs:integer(10.0) return $value cast as xs:float
let $value := xs:integer(10.0) return $value cast as xs:int
let $value := xs:integer(10.0) return $value cast as xs:long
let $value := xs:integer(-10.0) return $value cast as xs:negativeInteger
let $value := xs:integer(10.0) return $value cast as xs:nonNegativeInteger
let $value := xs:integer(-10.0) return $value cast as xs:nonPositiveInteger
let $value := xs:integer(10.0) return $value cast as xs:positiveInteger
let $value := xs:integer(10.0) return $value cast as xs:short
let $value := xs:integer(10.0) return $value cast as xs:unsignedByte
let $value := xs:integer(10.0) return $value cast as xs:unsignedInt
let $value := xs:integer(10.0) return $value cast as xs:unsignedLong
let $value := xs:integer(10.0) return $value cast as xs:unsignedShort
let $value := xs:integer(10E2) return $value cast as xs:double
let $value := xs:long(10.0) return $value cast as xs:float
let $value := xs:long(10.0) return $value cast as xs:integer
let $value := xs:long(10.0) return $value cast as xs:nonNegativeInteger
let $value := xs:long(10E2) return $value cast as xs:double
let $value := xs:long(10) return $value cast as xs:byte
let $value := xs:long(10) return $value cast as xs:int
let $value := xs:long(-10) return $value cast as xs:negativeInteger
let $value := xs:long(10) return $value cast as xs:positiveInteger
let $value := xs:long(10) return $value cast as xs:short
let $value := xs:long(10) return $value cast as xs:unsignedInt
let $value := xs:long(10) return $value cast as xs:unsignedLong
let $value := xs:negativeInteger(-10.0) return $value cast as xs:float
let $value := xs:nonNegativeInteger(10.0) return $value cast as xs:float
let $value := xs:nonPositiveInteger(-10.0) return $value cast as xs:float
let $value := xs:positiveInteger(10.0) return $value cast as xs:float
let $value := xs:positiveInteger(10E2) return $value cast as xs:double
let $value := xs:short(10.0) return $value cast as xs:float
let $value := xs:short(10E2) return $value cast as xs:double
let $value := xs:unsignedByte(10.0) return $value cast as xs:float
let $value := xs:unsignedInt(10.0) return $value cast as xs:float
let $value := xs:unsignedLong(10.0) return $value cast as xs:float
let $value := xs:unsignedLong(10E2) return $value cast as xs:double
let $value := xs:unsignedShort(10.0) return $value cast as xs:float
let $var := 100 where fn:count(($var)) = 1 return fn:count(($var))
let $var := 100 where typeswitch($var) case $i as xs:string return fn:false() case $i as xs:integer return fn:true() default return fn:false() return $var
let $var := 1           where every $x in (1, 1) satisfies fn:string($var) = "1"           return fn:string($var )
let $var := 1           where some $x in (1, 2) satisfies fn:string($var) = "1"           return fn:string($var )
let $var := <a attr1 = "abc1"><b attr2 = "abc2">context2</b></a> return $var/b
let $var := <a attr1 = "abc1"><b attr2 = "abc2">context2</b></a> return $var/child::*
let $var := <a attr1 = "abc1"><b attr2 = "abc2">context2</b></a> return $var/child::*:b
let $var := <a attr1 = "abc1"><b attr2 = "abc2">context2</b></a> return $var/child::b
let $var := <a attr1 = "abc1"><b attr2 = "abc2">context2</b></a> return $var/child::pr:*
let $var := <a attr1 = "abc1"><b attr2 = "abc2">context2</b></a> return $var/child::pr:b
let $var := <a attr1 = "abc1"><b attr2 = "abc2">context2</b></a> return fn:count(($var/empty-node-list)[1])
let $var := <a attr1 = "abc1"><b attr2 = "abc2">context2</b></a> return fn:count(fn:namespace-uri(exactly-one($var/child::b)))
let $var := <a attr1 = "abc1"><b attr2 = "abc2">context2</b></a> return fn:node-name(exactly-one($var/b))
let $var := "abc" cast as xs:ENTITY return $var instance of xs:ENTITY
let $var := ("a","b","c") cast as xs:ENTITY return count($var) lt 10
let $var := <!-- A Comment Node --> return fn:root($var)
let $var := <anElement>An Element Content</anElement> return fn:root($var)
let $var := <!-- An Element Node --> return fn:count(fn:namespace-uri(fn:root($var)))
let $var := <anElement>Some content</anElement> return $var/20[child::text()]
let $var := <anElement>Some Content</anElement> return $var/ancestor-or-self::*
let $var := <anElement>Some Content</anElement> return fn:count($var/ancestor::*)
let $var := <anElement>Some Content</anElement> return fn:count($var/following::*)
let $var := <anElement>Some Content</anElement> return fn:count($var/preceding::*)
let $var := <anElement>Some Content</anElement> return fn:count($var/preceding-sibling::*)
let $var := <anElement>Some content</anElement> where $var is $var return $var is $var
let $var as xs:boolean := fn:false() return $var
let $var as xs:boolean := fn:not(fn:true()) return $var
let $var as xs:boolean := fn:true() and fn:true() return $var
let $var as xs:boolean := fn:true() return $var
let $var as xs:boolean := if (fn:true()) then fn:true() else fn:false() return $var
let $var as xs:dateTime := xs:dateTime("1999-05-31T13:20:00Z") return $var
let $var as xs:date := xs:date("1999-05-31Z") return $var
let $var as xs:decimal := 100 return $var
let $var as xs:double := 100E1 return $var
let $var as xs:float := xs:float(100) return $var
let $var as xs:integer := 100+200 return $var
let $var as xs:integer := 100 return $var
let $var as xs:integer := 100 return $var + 1
let $var as xs:integer := fn:count((100,200)) return $var
let $var as xs:integer := fn:string-length("A String") return $var
let $var as xs:string := "A String" return $var
let $var as xs:string := typeswitch(fn:true()) case $i as xs:boolean return "Test Passed" default return "Test failed" return $var
let $var as xs:string := xs:string(fn:true()) return $var
let $var as xs:string := xs:string((xs:decimal(100))) return $var
let $var as xs:string := xs:string((xs:double(100E2))) return $var
let $var as xs:string := xs:string((xs:integer(100))) return $var
let $var as xs:time := xs:time("21:23:00Z") return $var
let $var := element anElement {attribute anAttribute {"Attribute Value"}} return fn:root($var)
let $var := element anElement {"Element Content"} return fn:count(fn:namespace-uri(fn:root($var)))
let $var := element anElement {"Element Content"} return fn:root($var) is fn:root($var)
let $var := (fn:false()) where fn:not($var and fn:false()) return $var and fn:false()
let $var := (fn:false()) where fn:not($var or fn:false()) return $var or fn:false()
let $var := fn:max((xs:long(20),xs:short(13))) return $var instance of xs:integer
let $var := fn:min((xs:long(22),xs:short(10))) return $var instance of xs:integer
let $var := (fn:true()) where $var and fn:true() return $var and fn:true()
let $var := (fn:true()) where $var or fn:true() return $var or fn:true()
let $var := <?format role="output" ?> return fn:count(fn:namespace-uri(fn:root($var)))
let $var := <?format role="output" ?> return fn:root($var)
let $var := "String" where fn:string($var) = "String" return $var
let $var := "String" where fn:string-length($var) = 6 return fn:string-length($var)
let $var := text {"A text node"} return fn:count(fn:namespace-uri(fn:root($var)))
let $var := text {"a text Node"} return fn:root($var)
let $var := /works[1]/child::employee[12]/overtime return $var/child::* intersect $var/child::day
let $var := /works[1]/child::employee[12]/overtime return fn:count($var/child::* except $var/child::day)
let $var := /works/employee[12]/overtime return $var/child::*:day[1] | $var/child::*:day[2]
let $var := /works return fn:count($var/child::*)
let $var := /works return fn:count($var/child::*:employee)
let $var := /works return fn:count($var/child::employee)
let $var := xs:byte(120) cast as xs:unsignedByte return $var instance of xs:unsignedByte
let $var := xs:int(120) cast as xs:long return $var instance of xs:long
let $var := xs:long(120) cast as xs:int return $var instance of xs:int
let $var := xs:long(120) cast as xs:short return $var instance of xs:short
let $var := xs:nonNegativeInteger(120) cast as xs:positiveInteger return $var instance of xs:positiveInteger
let $var := xs:nonPositiveInteger(-120) cast as xs:negativeInteger return $var instance of xs:negativeInteger
let $var := xs:short(120) cast as xs:long return $var instance of xs:long
let $var := xs:short(120) cast as xs:unsignedShort return $var instance of xs:unsignedShort
let $var := xs:unsignedInt(120) cast as xs:unsignedShort return $var instance of xs:unsignedShort
let $var := xs:unsignedShort(120) cast as xs:unsignedInt return $var instance of xs:unsignedInt
let $void := function(){} return $void()
let $v := . return 1
let $week := map{0:"Sonntag", 1:"Montag", 2:"Dienstag",      3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Samstag"}                       return                   map:contains($week, 2)
let $week := map{0:"Sonntag", 1:"Montag", 2:"Dienstag",      3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Samstag"}                       return                   map:contains($week, 9)
let $week := map{0:"Sonntag", 1:"Montag", 2:"Dienstag",      3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Samstag"}                       return                   map:get($week, 4)
let $week := map{0:"Sonntag", 1:"Montag", 2:"Dienstag",      3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Samstag"}                       return                   map:get($week, 9)
let $week := map{0:"Sonntag", 1:"Montag", 2:"Dienstag",      3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Samstag"}                       return                   map:merge(($week, map{6:"Sonnabend"}), map{"duplicates":"combine"})
let $week := map{0:"Sonntag", 1:"Montag", 2:"Dienstag",      3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Samstag"}                       return                   map:merge(($week, map{6:"Sonnabend"}), map{"duplicates":"use-first"})
let $week := map{0:"Sonntag", 1:"Montag", 2:"Dienstag",      3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Samstag"}                       return                   map:merge(($week, map{6:"Sonnabend"}), map{"duplicates":"use-last"})
let $week := map{0:"Sonntag", 1:"Montag", 2:"Dienstag",      3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Samstag"}                       return                   map:merge(($week, map{7:"Unbekannt"}))
let $week := map{0:"Sonntag", 1:"Montag", 2:"Dienstag",        3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Samstag"}                       return                   map:put($week, -1, "Unbekannt")
let $week := map{0:"Sonntag", 1:"Montag", 2:"Dienstag",        3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Samstag"}                       return                   map:put($week, 6, "Sonnabend")
let $week := map{0:"Sonntag", 1:"Montag", 2:"Dienstag",        3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Samstag"}                       return                   map:remove($week, ())
let $week := map{0:"Sonntag", 1:"Montag", 2:"Dienstag",        3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Samstag"}                       return                   map:remove($week, (0, 6 to 7))
let $week := map{0:"Sonntag", 1:"Montag", 2:"Dienstag",        3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Samstag"}                       return                   map:remove($week, 23)
let $week := map{0:"Sonntag", 1:"Montag", 2:"Dienstag",        3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Samstag"}                       return                   map:remove($week, 4)
let $weirdo := function($x, $f) {if ($x=0) then 0 else $f($x - 1, $f)}           return $weirdo(12, $weirdo)
let $x := (0,0.1e-1,2.0,'a',"cat",'',true(), ('<a> <b> <c> 123 </c> </b> </a>')/a/b) return $x
let $x := (0,0.1e-1,2.0,'a',"cat",'',true()) return $x
let $x:=1, $y:=$x+1 return $x
let $x := "1", $y := $x+1 return $y
let $x:=1, $y:=<a>{$x+1}</a> return $y
let $x:=(1,2,3), $y:=$x+1 return $y
let $x := 1               let $array := [0,0,0]               for $i in 1 to array:size($array) + 1               return                  array:insert-before($array, $i, $x)
let $x := 1               let $array := [0,0,0]               for $i in 1 to array:size($array)               return                  array:put($array, $i, $x)
let $x :=(1 to 100)[. mod 5 eq 0], $y := $x[. mod 10 eq 0] return $y
let $x :=(1 to 100)[. mod 5 eq 0] return $x
let $x := (1 to 10)[. mod 2 = 0] return subsequence((0,$x),3,count($x) div 2)
let $x := 1 to 10          where $x = 1          return $x
let $x := 1 to 10          where count($x) = 1          return $x
let $x:= 4 return ($x<=3.2)=>boolean()
let $x:= 4 return $x<=3.2=>ceiling()
let $x := 92233720368547758+1 return $x
let $x := 92233720368547758 return $x
let $x := "92233720368547758" return $x
let $x:=<a>{1+1}</a> return $x
let $x := (<a> <b> <c> 123 </c> </b> </a>) return $x
let $x := <a><b/><c/><d/></a> return count(($x/(node() except b) | $x/(node() except b)))
let $x as xs:error := 1 return fn:true()
let $x := ( attribute a { "a" }, element b { "b" }, attribute c { "c" } ) return <foo> { $x } </foo>
let $x := <a xmlns="http://sj31/"><b/><c/><d/></a> return fn:string-join($x//*/node-name(), '-')
let $x := <c/>               let $array := [<a/>, <b/>]               let $insert1 := array:insert-before($array, 1, $x)               let $insert2 := array:insert-before($array, 2, $x)               for $element in (array:flatten($insert1) union array:flatten($insert2))               let $name := $element/name()               order by $name               return $name
let $x := <c/>               let $array := [<a/>, <b/>]               let $insert1 := array:put($array, 1, $x)               let $insert2 := array:put($array, 2, $x)               for $element in (array:flatten($insert1) union array:flatten($insert2))               let $name := $element/name()               order by $name               return $name
let $x := codepoints-to-string(12) return ($x = $x)
let $x := <e><f>1</f></e>        return $x/data()
let $x := exists((1 to 10)[. mod 2 = 0]) return (1 to 100)[position() mod 2 = 0 and position() mod 3 = 0 and $x]
let $x := function($a, $b) {$a + $b},               $y := function($a, $b) {$a - $b},              $c := function($x, $y) {$x = $y}          return $c($x, $y)
let $x:="hello", $y:=concat($x," there") return $y
let $x := map{"div":18} return $x?div
let $x := map{"div":81, "div-2":18} return $x?div-2
let $x := map{"else":18} return exists($x[?else = 18])
let $x := map{"else":81, "else-2":18} return exists($x[?else-2 = 18])
let $x := (/)        return $x /ancestor-or-self /ancestor /and /as /ascending /at /attribute        /base-uri /boundary-space /by        /case /cast /castable /child /collation /comment /construction /copy-namespaces        /declare /default /descendant-or-self /descendant /descending /div /document-node /document        /element /else /empty-sequence /empty /encoding /eq /every /except /external        /following-sibling /following /for /function        /ge /greatest /gt        /idiv /if /import /in /inherit /instance /intersect /is /item        /lax /le /least /let /lt         /mod /module /module         /namespace /ne /no-inherit /no-preserve /node         /of /option /or /order /ordered /ordering         /parent /preceding-sibling /preceding /preserve /processing-instruction         /return         /satisfies /schema-attribute /schema-element /schema /self /some /stable /strict /strip         /text /then /to /treat /typeswitch         /union /unordered         /validate /variable /version         /where        /xquery
let $x := (/)         return $x/exponent-separator
let $x := (/)         return $x         /NaN         /allowing         /ancestor-or-self         /ancestor         /and         /as         /ascending         /at         /attribute         /base-uri         /boundary-space         /by         /case         /cast         /castable         /catch         /child         /collation         /comment         /construction         /context         /copy-namespaces         /count         /decimal-format         /decimal-separator         /declare         /default         /descendant-or-self         /descendant         /descending         /digit         /div         /document-node         /document         /element         /else         /empty-sequence         /empty         /encoding         /end         /eq         /every         /except         /external         /following-sibling         /following         /for         /function         /ge         /greatest         /group         /grouping-separator         /gt         /idiv         /if         /import         /in         /infinity         /inherit         /instance         /intersect         /is         /item         /lax         /le         /least         /let         /lt         /minus-sign         /mod         /module         /namespace-node         /namespace         /ne         /next         /no-inherit         /no-preserve         /node         /of         /only         /option         /or         /order         /ordered         /ordering         /parent         /pattern-separator         /per-mille         /percent         /preceding-sibling         /preceding         /preserve         /previous         /processing-instruction         /return         /satisfies         /schema-attribute         /schema-element         /schema         /self         /sliding         /some         /stable         /start         /strict         /strip         /switch         /text         /then         /to         /treat         /try         /tumbling         /type         /typeswitch         /union         /unordered         /validate         /variable         /version         /when         /where         /window         /xquery         /zero-digit
let $x := (<x>1</x>, <y>2</y>) return $x / .?1
let $x := (<x>1</x>, <y>2</y>) return $x / ?1
let $x := <x/>            let $array := [<e/>, <f/>, <g/>]               for $i in 1 to array:size($array) + 1               return               array:insert-before($array, $i, $x)
let $x := <x/>            let $array := [<e/>, <f/>, <g/>]               for $i in 1 to array:size($array)               return               array:put($array, $i, $x)
let $x := xs:double("1.7976931348623157E308") return $x
let $x := year-from-date(current-date()) return count( 1 to $x ) = $x
let $x := zero-or-one((1 to 10)[. div 2 = 2])         return if(empty($x)) then () else xs:string($x)
let $x := zero-or-one((1 to 10)[. div 2 = 2])         return if(exists($x)) then xs:string($x) else ()
let $y := for $x in 1 to 10 return $x * $x return subsequence($y, count($y), 3)
let $z := (1 to 10)[. mod 2 = 0] return subsequence(for $x in $z return floor($x),2,4)
"line1 line2"
'line1 line2'
local:func-does-not-exist(1, 2, 3)
local:myFunction(1)
local-name(<elem attr="{attribute name {" content "}}"/>/@attr)
local-name(<elem attr="{comment {" content "}}"/>/@attr)
local-name(<elem attr="{processing-instruction name {" content "}}"/>/@attr)
(local-name-from-QName( () ))
local-name-from-QName()
local-name-from-QName(1, 2)
local-name-from-QName(function-name((upper-case#1, lower-case#1)[.("Mike") = "MIKE"]))
local-name-from-QName( QName("example.com/", "pre:lname")) eq "lname"
(local-name-from-QName( QName('http://datypic.com/prod', 'number')))
(local-name-from-QName( QName('http://datypic.com/prod', 'number')), local-name-from-QName(QName ('', 'number')), local-name-from-QName( () ))
(local-name-from-QName(QName ('', 'number')))
local-name(<?PREFIXxml content?>)
local-name(<?PREFIXxmlSUFFIX content?>)
local-name(unordered(<a><b/><c/></a>/*[1]))
::local:ncname
lower-case()
lower-case("ABc!D") eq "abc!d"
lower-case(()) eq ""
(lower-case('Query'))
(lower-case('QUERY'))
(lower-case('QUERY123'))
(lower-case('QUERY'), lower-case('Query'), lower-case('QUERY123'))
lower-case("string", "wrong param")
"&lt;"
"&lt; &gt; &amp; &quot; &apos; &#x48; &#48;" eq "< > &amp; "" ' &#x48; &#48;"
<!--<?&-&lt;&#x20;><![CDATA[x]]>-->
map()
(map{1.1:1, 2.2:2, 3.3:3},  map{1.1:2, 2.2:3, 3.3:4})?(2.2)
(map{1.1:1, 2.2:2, 3.3:3},  map{1.1:2, 2.2:3, 3.3:4})?2.2
(map{1.1:1, 2.2:2, 3.3:3},  map{1.1:2, 2.2:3, 3.3:4})[?2.2 = 3]
(map{1.1:1, 2.2:2, 3.3:3},  map{1.1:2, 2.2:3, 3.3:4})[?(2.2) = 3]?(3.3)
(map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})?()
(map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})[.?(1 to 2) = 3]
(map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})[?(1 to 2) = 3]
(map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})?2
(map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})[.?2 eq 3]
(map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})[?2 eq 3]
(map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})[.?* = 3]
(map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})[?* = 3]
(map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})[exists(.?())]
(map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})[exists(?())]
(map{1:1, 2:2, 3:3},  map{2:3, 3:4, 4:5})?(1 to 2)
map{1:1} eq 1
(map{'a-1':1, 'b-1':2, 'c-1':3},  map{'a-1':2, 'b-1':3, 'c-1':4})[.?b-1 eq 3]
(map{'a-1':1, 'b-1':2, 'c-1':3},  map{'a-1':2, 'b-1':3, 'c-1':4})[?b-1 eq 3]
(map{'a-1':1, 'b-1':2, 'c-1':3},  map{'a-1':2, 'b-1':3, 'c-1':4})?c-1
(map{'a-1':1, 'b-1':2, 'c-1':3},  map{'a-1':2, 'b-1':3, 'c-1':4})? (:confusing.?:) b-1
(map{'a-1':1, 'b-1':2, 'c-1':3},  map{'a-1':2, 'b-1':3, 'c-1':4})[.? (:confusing.?:) b-1 eq 3]
(map{'a-1':1, 'b-1':2, 'c-1':3},  map{'a-1':2, 'b-1':3, 'c-1':4})[? (:confusing?:) b-1 eq 3]
(map{'a':1, 'b':2, 'c':3},  map{'a':2, 'b':3, 'c':4})?b
(map{'a':1, 'b':2, 'c':3},  map{'a':2, 'b':3, 'c':4})[.?b eq 3]
(map{'a':1, 'b':2, 'c':3},  map{'a':2, 'b':3, 'c':4})[?b eq 3]
map:contains((), "a")
map:contains(("a", "b", "c"), "a")
map:contains(abs#1, "a")
map:contains(map{1:"Sunday",2:"Monday",3:"Tuesday",4.0e0:"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, 4)
map:contains(map{1:"Sunday",2:"Monday",3:"Tuesday",4:(),5:"Thursday",6:"Friday",7:"Saturday"}, 4)
map:contains(map{1:"Sunday",2:"Monday",3:"Tuesday",4:"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, 23)
map:contains(map{1:"Sunday",2:"Monday",3:"Tuesday",4:"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, 4)
map:contains(map{1:"Sunday",2:"Monday",3:"Tuesday",4:"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, 4.0e0)
map:contains(map{1:"Sunday",2:"Monday",3:"Tuesday",number('NaN'):"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, (1 to 5)[10])
map:contains(map{1:"Sunday",2:"Monday",3:"Tuesday",number('NaN'):"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, (1 to 5)[. mod 2 = 0])
map:contains(map{1:"Sunday",2:"Monday",3:"Tuesday",number('NaN'):"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, number('NaN'))
map:contains(map{1:"Sunday",2:"Monday",3:"Tuesday","urn:weds":"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, xs:anyURI("urn:weds"))
map:contains(map{1:"Sunday",2:"Monday",3:"Tuesday",xs:anyURI("urn:weds"):"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, number('NaN'))
map:contains(map{1:"Sunday",2:"Monday",3:"Tuesday",xs:anyURI("urn:weds"):"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, "urn:weds")
map:contains(map{}, 23)
map:contains(map{"abc":23, "xyz":()}, "xyz")
map:contains(map:entry(12, "bar"), xs:untypedAtomic("12"))
map:contains(map:entry("foo", "bar"), "baz")
map:contains(map:entry("foo", "bar"), "foo")
map:contains(map:entry("foo", "bar"), xs:untypedAtomic("foo"))
map:contains(map:entry(xs:untypedAtomic("12"), "bar"), 12)
map:contains(map:entry(xs:untypedAtomic("foo"), "bar"), "foo")
map:contains((map{}, map{"a":"b"}), "a")
map:contains(map{"su":"Sunday","mo":"Monday","tu":"Tuesday","we":"Wednesday","th":"Thursday","fr":"Friday","sa":"Saturday"}, "TH")
map:contains(map{}, "xyz")
map:contains(map{"xyz":23}, "xyz")
map{'decimal':true(), 'integer':true(), 'polygon':[11,22,33]}?polygon?2
[map{'decimal':true(), 'integer':true(), 'polygon':false()}, map{}] ?1?decimal
map{'decimal':true(), 'integer':true(), 'polygon':false()} ? Q{}integer
map:entry("M", "Monday")
map:entry(number('NaN'), 'NaN')
map:entry(xs:float('NaN'), 'NaN')
map{} eq ()
map{'f':floor#1, 'c':ceiling#1, 'r':round#1, 'a':abs#1}[1]?("c")(1.3)
map{'f':floor#1, 'c':ceiling#1, 'r':round#1, 'a':abs#1}?("c")(1.3)
map{'f':floor#1, 'c':ceiling#1, 'r':round#1, 'a':abs#1}?c(1.3)
map:for-each(map{"a":1, "b":2}, function($k,$v){$k})
map:for-each(map{"a":1, "b":2}, function($k,$v){$k||$v})
map:for-each(map{"a":1}, function($k,$v){$k})
map:for-each(map{}, concat#2)
map:for-each(map:entry("a", "1"), function($k,$v){$k})
map:for-each(map:merge(()), function($k,$v){$k||$v})
map:for-each(map:merge((map:entry("a",1), map:entry("a",2))), function($k,$v){$k})
map:for-each(map:merge((map:entry("a", "1"), map:entry("b", 2))), function($k,$v){$k})
map:for-each(map{number('NaN'):1,"b":2}, function($k,$v){$k})
map:for-each(map:remove(map{"a":1,"b":2}, "b"), function($k,$v){$k})
map:for-each(map:remove(map{"a":1,"b":2}, "c"), function($k,$v){$k})
map:for-each(map:remove(map:entry(1,2),1), function($k,$v){$k})
map:for-each(map:remove(map:remove(map{"a":1,"b":2},"b"),"a"), function($k,$v){$k})
map:get((), "a")
map:get(("a", "b", "c"), "a")
map:get(abs#1, "a")
map:get(map{1:"Sunday",2:"Monday",3:"Tuesday",4.0e0:"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, 4)
map:get(map{1:"Sunday",2:"Monday",3:"Tuesday",4:(),5:"Thursday",6:"Friday",7:"Saturday"}, 4)
map:get(map{1:"Sunday",2:"Monday",3:"Tuesday",4:"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, 23)
map:get(map{1:"Sunday",2:"Monday",3:"Tuesday",4:"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, 4)
map:get(map{1:"Sunday",2:"Monday",3:"Tuesday",4:"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, 4.0e0)
map:get(map{1:"Sunday",2:"Monday",3:"Tuesday",number('NaN'):"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, (1 to 5)[10])
map:get(map{1:"Sunday",2:"Monday",3:"Tuesday",number('NaN'):"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, (1 to 5)[. mod 2 = 0])
map:get(map{1:"Sunday",2:"Monday",3:"Tuesday",number('NaN'):"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, number('NaN'))
map:get(map{1:"Sunday",2:"Monday",3:"Tuesday","urn:weds":"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, xs:anyURI("urn:weds"))
map:get(map{1:"Sunday",2:"Monday",3:"Tuesday",xs:anyURI("urn:weds"):"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, number('NaN'))
map:get(map{1:"Sunday",2:"Monday",3:"Tuesday",xs:anyURI("urn:weds"):"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, "urn:weds")
map:get(map{}, 23)
map:get(map:entry(12, "bar"), xs:untypedAtomic("12"))
map:get(map:entry(7,()), 7)
map:get(map:entry("foo", "bar"), "baz")
map:get(map:entry("foo", "bar"), "foo")
map:get(map:entry("foo", "bar"), xs:untypedAtomic("foo"))
map:get(map:entry(xs:untypedAtomic("12"), "bar"), 12)
map:get(map:entry(xs:untypedAtomic("foo"), "bar"), "foo")
map:get(map{"foo":"bar", "bar":"foo"}, xs:untypedAtomic("foo"))
map:get((map{}, map{"a":"b"}), "a")
map:get(map{number('NaN'):100, 12e6:101}, xs:float('NaN'))
map:get(map{"su":"Sunday","mo":"Monday","tu":"Tuesday","we":"Wednesday","th":"Thursday","fr":"Friday","sa":"Saturday"}, "TH")
map:get(map{xs:untypedAtomic("foo"):"bar", xs:untypedAtomic("bar"):"foo"}, "foo")
map:keys(map{})
map:keys(map{"a":1})
map:keys(map{"a":1, "b":2})
map:keys(map:entry("a", "1"))
map:keys(map:merge(()))
map:keys(map:merge((map:entry("a",1), map:entry("a",2))))
map:keys(map:merge((map:entry("a", "1"), map:entry("b", 2))))
map:keys(map{number('NaN'):1,"b":2})
map:keys(map:remove(map{"a":1,"b":2}, "b"))
map:keys(map:remove(map{"a":1,"b":2}, "c"))
map:keys(map:remove(map:entry(1,2),1))
map:keys(map:remove(map:remove(map{"a":1,"b":2},"b"),"a"))
map{} => map:put(xs:double('NaN'), 10) => map:put(xs:float('NaN'), 20) => map:size()
map:merge(())
map:merge()
map:merge((map:entry(0, "no"), map:entry(1, "yes")))
map:merge((map:entry("foo", 3), map:entry("foo", 4)))
map:merge((map:entry("foo", 3), map:entry("foo", 4)), map{"duplicates": "reject"})
map:merge((map:entry("foo", 3), map:entry("foo", 4)), map{"duplicates": "use-any"})
map:merge(map:for-each(map{"a":1, "b":2}, function($k,$v){map{$v : $k}}))
map:merge(map:for-each(map{"a":1, "b":2}, function($k,                   $v){map:entry($k, $v+1)}))
map{'or':true(), 'and':true(), 'but':false()} ? or or 2 = 3
map:remove(map{}, 1)
map:remove(map{"a":1}, "a")
map:remove(map:entry("a", "1"), "b")
map:remove(map:merge(()), "abcd")
map:remove(map:merge((map:entry("a", "1"), map:entry("b", 2))), "b")
map:remove(map:merge((map:entry("a", "1"), map:entry("b", 2))), "c")
map:size(<a><b>x</b></a>/map{* :b})
map:size(<a><b>x</b></a>/map{b:2})
map:size(<a><b>x</b></a>/map{*:b:b})
map:size(<a><b>x</b></a>/map{self::a: b})
map:size(<a><self>x</self></a>/map{self:2})
map:size(map {})
map:size(map{     })
map:size(map{})
map:size(map{(1 to 5)[. gt year-from-date(current-date())]:93})
map:size(map{(1 to 5)[. lt year-from-date(current-date())]:93})
map:size(map {2:<a>x{25}y</a>})
map:size(map {2:<a>x</a>})
map:size(map{2:map{3:4}})
map:size(map{"a":1})
map:size(map{"a":1, "b":2})
map:size(map {"a":2, })
map:size(map {,"a":2})
map:size(map{ "a" : 2 })
map:size(map{"a":2})
map:size(map {"a":2,3})
map:size(map { "a" : 2 , "b" : 3 })
map:size(map{"a":2,"b":3})
map:size(map {"a","b":2})
map:size(map {<a>x</a>:2})
map:size(map:entry("a", "1"))
map:size(map:merge(()))
map:size(map:merge((map:entry("a",1), map:entry("a",2))))
map:size(map:merge((map:entry("a", "1"), map:entry("b", 2))))
map:size(map{number('NaN'):1,"b":2})
map:size(map:remove(map{"a":1,"b":(2,3), "c":1 to 5}, ())) = 3
map:size(map:remove(map{"a":1,"b":2}, "b"))
map:size(map:remove(map{"a":1,"b":2}, "c"))
map:size(map:remove(map:entry(1,2),1))
map:size(map:remove(map:remove(map{"a":1,"b":2},"b"),"a"))
map:size(map{"true":1, "false":0})
map{'xs:decimal':true(), 'xs:integer':true(), 'xs:polygon':false()} ? xs:integer
map{xs:double('1.25'):0}             => map:remove(xs:float('1.25'))              => map:size()
matches('$', '^\$$') and not(matches('\$', '^\$$'))
matches('$$9', '((((((((((.))))))))))(\11)9')
matches('$$9', '(.)(\2)')
matches('$$9', '(.)\2')
matches('$', '[\$]') and not(matches('\$', '^[\$]$'))
matches("abcd", "1[asd\0]")
matches("abcd", "(asd)[\1]")
matches("abcd", "(asd)[asd\0]")
matches("abcd", "(asd)[asd\1]")
matches("abc𝅗def", "abc.def")
matches("abc𝅗def", "abc[𝅖-𝅘]def")
matches("abc&#x1D157;def", "abc.def")
matches("abc&#x1D157;def", "abc[&#x1D156;-&#x1D158;]def")
matches('alpha', 'alp${2,4}ha')
matches('alpha', 'alp$?ha')
matches('alpha', 'alp^+ha')
matches('alpha', 'alp^?ha')
matches('alpha', 'alpha$+') and not(matches('alphax', 'alpha$+'))
matches('a&#xD;&#xA;b', '^(?:a\r\nb)$'), matches('ab', '^(?:a\r\nb)$')
matches(format-dateTime(current-dateTime(), "[M01]/[D01]/[Y0001] at [H01]:[m01]:[s01]"), "[0-1][0-9]/[0-3][0-9]/[0-9]{4} at [0-9]{2}:[0-9]{2}:[0-9]{2}")
matches(format-dateTime(current-dateTime(), "[M01]/[D01]/[Y0001] at [H01]:[m01]:[s01]", (), (), ()), "../../.... at ..:..:..")
matches(format-dateTime(current-dateTime(), "[Y0001]-[M01]-[D01]", (), (), ()), "....-..-..")
matches(format-dateTime(current-dateTime(), "[Y0001]-[M01]-[D01]"), "[0-9]{4}-[0-9]{2}-[0-9]{2}")
matches("input")
matches("input", ())
matches("input", "\3")
matches("input", "pattern", "", ())
matches('qwerty','(')
matches('qwerty','((?>[^()]+)|\([^()]*\))+')
matches('qwerty','([[.]+)')
matches('qwerty','([[:]+)')
matches('qwerty','([[=]+)')
matches('qwerty',')')
matches('qwerty','))((')
matches('qwerty','*')
matches('qwerty','+')
matches('qwerty','++')
matches('qwerty',':(?:')
matches('qwerty','?')
matches('qwerty','[')
matches('qwerty','[>-=]')
matches('qwerty','[\]')
matches('qwerty','\')
matches('qwerty','\060(\061)?\061')
matches('qwerty','[^0-9]+(?>[0-9]+)3')
matches('qwerty','\1')
matches('qwerty','\10((((((((((a))))))))))')
matches('qwerty','{1}a')
matches('qwerty','()?(?(1)a|b)')
matches('qwerty','(?(1)a|b)()?')
matches('qwerty','(?(1?)a|b)')
matches('qwerty','(?(1)a|b|c)')
matches('qwerty','\1(abc)')
matches('qwerty','(?(1)a|b)(x)?')
matches('qwerty','\1([a-c]*)')
matches('qwerty','\1a(\d*){0,2}')
matches('qwerty','\1a(\d*){0,2}?')
matches('qwerty','\1a(\d*){2,}')
matches('qwerty','\1a(\d*){2,}?')
matches('qwerty','()(?(1)b|a)')
matches('qwerty','()?(?(1)b|a)')
matches('qwerty','(?(1)b|a)()')
matches('qwerty','(?(1)b|a)()?')
matches('qwerty','(?(1)b|a)(x)?')
matches('qwerty','\1\d(ab)')
matches('qwerty','([1-\P{Ll}][\p{Ll}]*)\s([\P{Ll}][\p{Ll}]*)')
matches('qwerty','\2')
matches('qwerty','(\2b*?([a-c]))*')
matches('qwerty','(\2b*?([a-c])){3}')
matches('qwerty','^(?:?(2)(\())blah(\))?$')
matches('qwerty','^(?:?(2)(\())blah(\)+)?$')
matches('qwerty','((\3|b)\2(a)){2,}')
matches('qwerty','((\3|b)\2(a)x)+')
matches('qwerty','{5')
matches('qwerty','{5,')
matches('qwerty','{5,6')
matches('qwerty','([5-\D]*)bar')
matches('qwerty','((a)')
matches('qwerty','(?:(?:(?:(?:(?:(?:(?:(?:(?:(a))))))))))')
matches('qwerty','(?:..)*?a')
matches('qwerty','(?:..)*a')
matches('qwerty','(a))')
matches('qwerty','*a')
matches('qwerty','+a')
matches('qwerty','?a')
matches('qwerty','[a-;]')
matches('qwerty','[a-\[]')
matches('qwerty','[a-\\]')
matches('qwerty','a**')
matches('qwerty','a[')
matches('qwerty','a\')
matches('qwerty','a]')
matches('qwerty','[A-[]+')
matches('qwerty','a{1,0}')
matches('qwerty','(a\1|(?(1)\1)){0,2}')
matches('qwerty','(a\1|(?(1)\1)){0,2}?')
matches('qwerty','(a\1|(?(1)\1)){1,2}')
matches('qwerty','(a\1|(?(1)\1)){1,2}?')
matches('qwerty','(a\1|(?(1)\1)){2,}')
matches('qwerty','(a\1|(?(1)\1)){2,}?')
matches('qwerty','(a\1|(?(1)\1)){2}')
matches('qwerty','^(?:a(?(1)\1)){4}$')
matches('qwerty','^(?:a\1?){4}$')
matches('qwerty','(?=(a+?))(\1ab)')
matches('qwerty','^(?:?=(a+?))\1ab')
matches('qwerty','a{,2}')
matches('qwerty','a{2,1}')
matches('qwerty','((a)\3(\2|b)){2,}')
matches('qwerty','a{37,17}')
matches('qwerty','(a)|\6')
matches('qwerty','(?(?!a)a|b)')
matches('qwerty','(?(?=a)a|b)')
matches('qwerty','((?>a+)b)')
matches('qwerty','(?>(a+))b')
matches('qwerty','(?>a+)b')
matches('qwerty','[^[a-b]]')
matches('qwerty','[a--b]')
matches('qwerty','a(?!b).')
matches('qwerty','a[]]b')
matches('qwerty','a[]b')
matches('qwerty','^(?:?:a?b?)*$')
matches('qwerty','(ab){2,0}')
matches('qwerty','(?(?!a)b|a)')
matches('qwerty','(?(?=a)b|a)')
matches('qwerty','a[b-a]')
matches('qwerty','((a*(b*)((a))*(a))))')
matches('qwerty','(abbc)(?(1)111|222)')
matches('qwerty','(?:(?:(?:(?:(?:(?:(?:(?:(?:(a|b|c))))))))))')
matches('qwerty','(abc')
matches('qwerty','[a\-[\-\-bc]+')
matches('qwerty','[a\-[bc]+')
matches('qwerty','a[^]b]c')
matches('qwerty','abc)')
matches('qwerty','(a+)(?:b*)(ccc)')
matches('qwerty','[ab\-\[cd-[-[]]]]')
matches('qwerty','[ab\-\[cd-[[]]]]')
matches('qwerty','a(?:b|c|d)(.)')
matches('qwerty','a(?:b|c|d)*(.)')
matches('qwerty','a(?:b|c|d)+(.)')
matches('qwerty','a(?:b|c|d)+?(.)')
matches('qwerty','^[abcd]*+$')
matches('qwerty','^[abcd]*?+$')
matches('qwerty','^[abcd]+*$')
matches('qwerty','^[abcd]+?*$')
matches('qwerty','^[abcd]?*$')
matches('qwerty','^[abcd]??*$')
matches('qwerty','^[abcd]{0,16}*$')
matches('qwerty','^[abcd]{0,16}?*$')
matches('qwerty','^[abcd]*{0,5}$')
matches('qwerty','^[abcd]+{0,5}$')
matches('qwerty','^[abcd]?{0,5}$')
matches('qwerty','^[abcd]{1,}*$')
matches('qwerty','^[abcd]{1,}?*$')
matches('qwerty','^[abcd]{1}*$')
matches('qwerty','^[abcd]{1}?*$')
matches('qwerty','a(?:b|c|d){2}(.)')
matches('qwerty','a(?:b|c|d){4,5}(.)')
matches('qwerty','a(?:b|c|d){4,5}?(.)')
matches('qwerty','a(?:b|c|d){5,6}(.)')
matches('qwerty','a(?:b|c|d){5,6}?(.)')
matches('qwerty','a(?:b|c|d){5,7}(.)')
matches('qwerty','a(?:b|c|d){5,7}?(.)')
matches('qwerty','a(?:b|c|d){6,7}(.)')
matches('qwerty','a(?:b|c|d){6,7}?(.)')
matches('qwerty','[[abcd]-[bc]]+')
matches('qwerty','[abcd\-d\-[bc]+')
matches('qwerty','a(?:b|(c|e){1,2}?|d)+?(.)')
matches('qwerty','abc(?!XXX)\w+')
matches('qwerty','abc(?=XXX)\w+')
matches('qwerty','ab|(d))')
matches('qwerty','[a - c - [ b ] +')
matches('qwerty','[a - c - [ b ] ]+')
matches('qwerty','a(?=c|d).')
matches('qwerty','a(?=d).')
matches('qwerty','[a-d\-[b]+')
matches('qwerty','[\[\]a-f-[[]]+')
matches('qwerty','[\[\]a-f-[]]]+')
matches('qwerty','[a-f-[]]+')
matches('qwerty','\A(foo)\s+(bar)')
matches('qwerty','[^a-f-[\x00-\x60\u007B-\uFFFF]]+')
matches('qwerty','^a(?#xxx){3}c')
matches('qwerty','^a (?#xxx) (?#yyy) {3}c')
matches('qwerty','[a[:xyz:')
matches('qwerty','[a[:xyz:]')
matches('qwerty','([a[:xyz:]b]+)')
matches('qwerty','a\Z')
matches('qwerty','(*)b')
matches('qwerty','^(?:?:b|a(?=(.)))*\1')
matches('qwerty','ba\1(?=(a+?))$')
matches('qwerty','(ba\2)(?=(a+?))')
matches('qwerty','\ba\b')
matches('qwerty','\Ba\B')
matches('qwerty','[^-[bc]]')
matches('qwerty','(.)(?:b|c|d){2}a')
matches('qwerty','(.)(?:b|c|d){4,5}a')
matches('qwerty','(.)(?:b|c|d){4,5}?a')
matches('qwerty','(.)(?:b|c|d){5,6}a')
matches('qwerty','(.)(?:b|c|d){5,6}?a')
matches('qwerty','(.)(?:b|c|d){5,7}a')
matches('qwerty','(.)(?:b|c|d){5,7}?a')
matches('qwerty','(.)(?:b|c|d){6,7}a')
matches('qwerty','(.)(?:b|c|d){6,7}?a')
matches('qwerty','(.)(?:b|c|d)*a')
matches('qwerty','(.)(?:b|c|d)+?a')
matches('qwerty','(.)(?:b|c|d)+a')
matches('qwerty','(.)(?:b|c|d)a')
matches('qwerty','(.)(?:b|(c|e){1,2}?|d)+?a')
matches('qwerty','[B-D\u0130]+')
matches('qwerty','\b,foo')
matches('qwerty','\b@foo')
matches('qwerty','\b\[foo')
matches('qwerty','\B,foo')
matches('qwerty','\B@foo')
matches('qwerty','\B\[foo')
matches('qwerty','^(?:\()?blah(?(1)(\)))$')
matches('qwerty','^(?:\(+)?blah(?(1)(\)))$')
matches('qwerty','.*\B(SUCCESS)\B.*')
matches('qwerty','.*\b(\w+)\b')
matches('qwerty','\by\b')
matches('qwerty','\by\B')
matches('qwerty','\By\b')
matches('qwerty','\By\B')
matches('qwerty','b\z')
matches('qwerty','b\Z')
matches('qwerty','((c*)(?(1)a|b))')
matches('qwerty','(?:c|d)(?:)(?:aaaaaaaa(?:)(?:bbbbbbbb)(?:bbbbbbbb(?:))(?:bbbbbbbb(?:)(?:bbbbbbbb)))')
matches('qwerty','(?:c|d)(?:)(?:a(?:)(?:b)(?:b(?:))(?:b(?:)(?:b)))')
matches('qwerty','(?c:foo)')
matches('qwerty','(?>\d+)3')
matches('qwerty','(?e:foo)')
matches('qwerty','[-[e-g]+')
matches('qwerty','(?<first_name>\\S+)\\s(?<last_name>\\S+)')
matches('qwerty','(foo)(\040)')
matches('qwerty','(foo)(\077)')
matches('qwerty','(foo)(\300)')
matches('qwerty','(foo)(\377)')
matches('qwerty','(foo)(\40)')
matches('qwerty','(foo)(\400)')
matches('qwerty','(foo)(\477)')
matches('qwerty','foo([6-\s]*)bar')
matches('qwerty','(foo)(\7)')
matches('qwerty','(foo)(\77)')
matches('qwerty','(foo)(\777)')
matches('qwerty','(foo)(\7770)')
matches('qwerty','foo([7-\w]*)')
matches('qwerty','foo([a-\d]*)bar')
matches('qwerty','foo(?(?afdfoo)bar)')
matches('qwerty','foo([a-\W]*)bar')
matches('qwerty','(?:(f)(o)(o)|(b)(a)(r))*')
matches('qwerty','(foo)(\c?*)(bar)')
matches('qwerty','foo(?(?#COMMENT)foo)')
matches('qwerty','foo([c-\S]*)')
matches('qwerty','(foo) (?#foo) \s+ (?#followed by 1 or more whitespace')
matches('qwerty','(foo) (?#foo) \s+ (?#followed by 1 or more whitespace) (bar)  (?#followed by bar)')
matches('qwerty','(foo)([\o]*)(bar)')
matches('qwerty','(foo)\s+(bar)\z')
matches('qwerty','(foo)\s+(bar)\Z')
matches('qwerty','(foo)([\u0041]*)(bar)')
matches('qwerty','(foo)(\x2a*)(bar)')
matches('qwerty','(foo)(\x2A*)(bar)')
matches('qwerty','(foo)(\x2b*)(bar)')
matches('qwerty','(foo)(\x2B*)(bar)')
matches('qwerty','(foo)(\x2c*)(bar)')
matches('qwerty','(foo)(\x2C*)(bar)')
matches('qwerty','(foo)(\x2d*)(bar)')
matches('qwerty','(foo)(\x2D*)(bar)')
matches('qwerty','(foo)(\x2e*)(bar)')
matches('qwerty','(foo)(\x2E*)(bar)')
matches('qwerty','(foo)(\x2f*)(bar)')
matches('qwerty','(foo)(\x2F*)(bar)')
matches('qwerty','(foo)([\x41]*)(bar)')
matches('qwerty','([f-\p{Lu}]\w*)\s([\p{Lu}]\w*)')
matches('qwerty','((?-i)a)b')
matches('qwerty','((?-i:a))b')
matches('qwerty','((?-i:a.))b')
matches('qwerty','((?i)a)b')
matches('qwerty','((?i:a))b')
matches('qwerty','(?-i:a)b')
matches('qwerty','(?:(?-i)a)b')
matches('qwerty','(?:(?i)a)b')
matches('qwerty','(?i:a)b')
matches('qwerty','(?+i:foo)')
matches('qwerty','((?m)^b)')
matches('qwerty','(?m)^(b)')
matches('qwerty','(?m)^b')
matches('qwerty','((?m)^b$)')
matches('qwerty','(?n:(foo)(\s+)(bar))')
matches('qwerty','\n((?m)^b)')
matches('qwerty','(\p{')
matches('qwerty','[\p]')
matches('qwerty','[\P]')
matches('qwerty','([\pfoo])')
matches('qwerty','([\Pfoo])')
matches('qwerty','\p{Is}')
matches('qwerty','\P{Is}')
matches('qwerty','\p{IsaA0-a9}')
matches('qwerty','\p{klsak')
matches('qwerty','\p{\\L}')
matches('qwerty','(\p{Ll')
matches('qwerty','\p{Nd}{4}-\[{Nd}{2}')
matches('qwerty','((q*)(?(1)a|b))')
matches('qwerty','((q*)(?(1)b|a))')
matches('qwerty','(?r:foo)')
matches('qwerty','round\(((?>[^()]+))\)')
matches('qwerty','((?s)^a(.))((?m)^b$)')
matches('qwerty','((?s)b.)c(?!.)')
matches('qwerty','((?s).)c(?!.)')
matches('qwerty','((?s-i:a.))b')
matches('qwerty','(\u0034)')
matches('qwerty','[\u0100\u0102\u0104]+')
matches('qwerty','[\u013B\u013D\u013F]+')
matches('qwerty','[\u0554-\u0557]+')
matches('qwerty','(\w(?=aa)aa)')
matches('qwerty','(x)?(?(1)a|b)')
matches('qwerty','(x)?(?(1)b|a)')
matches('qwerty','(\x30\x31\x32)')
matches('qwerty','(x(a)\3(\2|b))+')
matches('qwerty','x(~~)*(?:(?:F)?)?')
matches('qwerty','[X-\u00C0]+')
matches('qwerty','[X-\u0533]+')
matches('qwerty','[-[xyz]]')
matches('qwerty','[^-[xyz]]')
matches('qwerty','z\1a(\d*){2,}?')
matches('&#xD;&#xD;a&#xD;&#xD;b&#xD;&#xD;',         '^\r\ra\r\rb\r\r$'),         matches('&#xD;&#xD;a&#xD;&#xD;b&#xD;&#xD;',         '^\r\ra\r\rb\r\r$'),         matches('&#xD;&#xD;a&#xD;&#xD;b&#xD;',              '^(?:\r\ra\r\rb\r\r)$'),         matches('&#xD;a&#xD;&#xD;b&#xD;&#xD;',              '^(?:\r\ra\r\rb\r\r)$'),         matches('&#xD;&#xD;a&#xD;&#xD;&#xD;&#xD;',          '^(?:\r\ra\r\rb\r\r)$'),         matches('&#xD;&#xD;a&#xD;&#xA;&#xD;b&#xD;&#xD;',    '^(?:\r\ra\r\rb\r\r)$')
math:acos(())
math:acos(0)
math:acos(-0.0e0)
math:acos(-1.0e0)
math:acos(1.0e0)
math:acos(2.0e0)
math:acos(xs:double('-INF'))
math:acos(xs:double('INF'))
math:acos(xs:double('NaN'))
math:asin(())
math:asin(0)
math:asin(-0.0e0)
math:asin(-1.0e0)
math:asin(1.0e0)
math:asin(2.0e0)
math:asin(xs:double('-INF'))
math:asin(xs:double('INF'))
math:asin(xs:double('NaN'))
math:atan(())
math:atan(0)
math:atan(-0.0e0)
math:atan(-1.0e0)
math:atan(1.0e0)
math:atan2(+0.0e0, -0.0e0)
math:atan2(+0.0e0, 0.0e0)
math:atan2(-0.0e0, -0.0e0)
math:atan2(-0.0e0, 0.0e0)
math:atan2(+0.0e0, +1)
math:atan2(+0.0e0, -1)
math:atan2(-0.0e0, +1)
math:atan2(-0.0e0, -1)
math:atan2(+1, 0.0e0)
math:atan2(-1, -0.0e0)
math:atan2(-1, 0.0e0)
math:atan(xs:double('-INF'))
math:atan(xs:double('INF'))
math:atan(xs:double('NaN'))
math:cos(())
math:cos(0)
math:cos(-0.0e0)
math:cos(math:pi())
math:cos(-math:pi() div 2)
math:cos(math:pi() div 2)
math:cos(xs:double('-INF'))
math:cos(xs:double('INF'))
math:cos(xs:double('NaN'))
math:exp(())
math:exp(0)
math:exp(-1)
math:exp(1)
math:exp10(())
math:exp10(0)
math:exp10(0.5)
math:exp10(-1)
math:exp10(1)
math:exp10(xs:double('-INF'))
math:exp10(xs:double('INF'))
math:exp10(xs:double('NaN'))
math:exp(xs:double('-INF'))
math:exp(xs:double('INF'))
math:exp(xs:double('NaN'))
math:log(())
math:log(0)
math:log(-1)
math:log10(())
math:log10(0)
math:log10(-1)
math:log10(1.0e-3)
math:log10(1.0e3)
math:log10(2)
math:log(1.0e-3)
math:log10(xs:double('-INF'))
math:log10(xs:double('INF'))
math:log10(xs:double('NaN'))
math:log(2)
math:log(math:exp(1))
math:log(xs:double('-INF'))
math:log(xs:double('INF'))
math:log(xs:double('NaN'))
math:pi()
math:pi#0()
math:pow(0, 0)
math:pow(0, -4)
math:pow(0, 4)
math:pow(-0e0, -3)
math:pow(-0e0, 3)
math:pow(0e0, -3)
math:pow(0e0, 3)
math:pow(-0e0, -3.0e0)
math:pow(-0e0, 3.0e0)
math:pow(0e0, -3.0e0)
math:pow(0e0, 3.0e0)
math:pow(-0e0, -3.1e0)
math:pow(-0e0, 3.1e0)
math:pow(0e0, -3.1e0)
math:pow(0e0, 3.1e0)
math:pow(0e0, -4)
math:pow(0e0, 4)
math:pow(16, 0.25e0)
math:pow(16, 0.5e0)
math:pow(-1, xs:double('-INF'))
math:pow(-1, xs:double('INF'))
math:pow(1, xs:double('-INF'))
math:pow(1, xs:double('INF'))
math:pow(1, xs:double('NaN'))
math:pow(2, 0)
math:pow(-2, -3)
math:pow(-2, 3)
math:pow(2, -3)
math:pow(2, 3)
math:pow(-2.5e0, 2.00000001e0)
math:pow(-2.5e0, 2.0e0)
math:pow((), 93.7)
math:pow(-math:pi(), 0)
math:pow(xs:double('INF'), 0)
math:pow(xs:double('NaN'), 0)
math:sin(())
math:sin(0)
math:sin(-0.0e0)
math:sin(math:pi())
math:sin(-math:pi() div 2)
math:sin(math:pi() div 2)
math:sin(math:pi()) lt 1e-15
math:sin(xs:double('-INF'))
math:sin(xs:double('INF'))
math:sin(xs:double('NaN'))
math:sqrt(())
math:sqrt(-0.0e0)
math:sqrt(0.0e0)
math:sqrt(1.0e6)
math:sqrt(-2.0e0)
math:sqrt(2.0e0)
math:sqrt(xs:double('-INF'))
math:sqrt(xs:double('INF'))
math:sqrt(xs:double('NaN'))
math:tan(())
math:tan(0)
math:tan(-0.0e0)
math:tan(math:pi())
math:tan(-math:pi() div 4)
math:tan(math:pi() div 4)
math:tan(-math:pi() div 4) + 1
math:tan(math:pi() div 4) - 1
math:tan(xs:double('-INF'))
math:tan(xs:double('INF'))
math:tan(xs:double('NaN'))
max()
max((1.0, 1, 1.0, 1, 1)) instance of xs:decimal
max((1.0, 1, 1, 1, 1)) instance of xs:decimal
max((1, 1, 1, 1, 1.0)) instance of xs:decimal
max((1, 1, 1, 1, 1, 3)) eq 3
max([1,2,3,4,5])
max((1, xs:float(2), xs:decimal(3))) instance of xs:float
max((1, xs:float(2), xs:untypedAtomic("3"))) eq 3
max((1, xs:float(2), xs:untypedAtomic("3"))) instance of xs:double
max((1, xs:untypedAtomic("3"), xs:float(2))) instance of xs:double
max((3, 1, 1, 1, 1, 1)) eq 3
max((3, 1, 5, 1, 1, 3)) eq 5
max((3, 3, 3, 3, 3, 3)) eq 3
max((3,4,5)) eq 5
max((3,4, "Zero"))
max((3, -5.0, 5, 1, -3, 3)) eq 5
max((3, 5.0e0)) eq 5.0e0
max((3, 5.0e0)) instance of xs:double
max((3, xs:double("NaN"))) instance of xs:double
max((5.0e0, 3)) eq 5.0e0
max((5.0e0, 3)) instance of xs:double
max((5.0e0, 5)) eq 5.0e0
max((5.0e0, 5)) instance of xs:double
max((5, 3.0e0)) instance of xs:double
max((5, 5.0e0)) eq 5.0e0
max((5, 5.0e0)) instance of xs:double
max(("a", "b", "c", "d"))
max(("a", "b", "c")) eq "c"
max(('a', 'b'), 'http://www.cbcl.co.u,/collation')
max(("a string")) eq "a string"
max("a string", "http://www.w3.org/2005/xpath-functions/collation/codepoint", "wrong param")
max(("a string", QName("example.com/", "ncname")))
max(("a string", xs:untypedAtomic("3")))
max((current-date(), xs:date("1999-01-01"))) eq current-date()
max(map{'decimal':12, 'integer':18, 'polygon':-4}?*)
max(("str1", "str2"), "http://example.com/UNSUPPORTED_COLLATION")
max(("str1", "str2"), "http://www.w3.org/2005/xpath-functions/collation/codepoint", ())
max(xs:anyURI("example.com/")) eq xs:anyURI("example.com/")
max((xs:anyURI("example.com/"), xs:anyURI("example.com/"))) eq xs:anyURI("example.com/")
max((xs:anyURI("http://a.com"), xs:anyURI("http://b.com")))
max((xs:anyURI("http://c.com"), "http://b.com"))
max((xs:anyURI("http://example.com/8"), xs:anyURI("http://example.com/4"))) eq xs:anyURI("http://example.com/8")
max((xs:anyURI("http://example.com/A"), xs:anyURI("http://example.com/A"))) eq xs:anyURI("http://example.com/A")
max((xs:anyURI("http://example.com/B"), xs:anyURI("http://example.com/A"))) eq xs:anyURI("http://example.com/B")
max(xs:anyURI("str1"), "max://example.com/UNSUPPORTED_COLLATION")
max((xs:date('1066-10-02'), xs:date('1588-08-08'), xs:date('2011-06-29')))
max((xs:dayTimeDuration("P1D"), xs:dayTimeDuration("PT2H"))) instance of xs:dayTimeDuration
max((xs:double("NaN"), 1, 1, 2, xs:float("NaN"))) instance of xs:double
max((xs:float(-3), xs:untypedAtomic("3"), xs:double("NaN"))) instance of xs:double
max((xs:float("NaN"), 1, 1, 2, xs:double("NaN"))) instance of xs:double
max((xs:float("NaN"), 1, xs:untypedAtomic("one")))
max((xs:float("NaN"), xs:untypedAtomic("3"), xs:float(2))) instance of xs:double
max((xs:NCName('c'), xs:ID('b'), xs:token('a')))
max((xs:positiveInteger(123), xs:unsignedShort(124)))
max(xs:unsignedShort("1")) instance of xs:unsignedShort
max((xs:untypedAtomic("3"), 1, 2)) instance of xs:double
max((xs:untypedAtomic("3"), "a string"))
max(xs:untypedAtomic("3")) eq 3
max(xs:untypedAtomic("3")) instance of xs:double
max((xs:untypedAtomic("one"), 1, xs:float("NaN")))
max(xs:untypedAtomic("three"))
max((xs:yearMonthDuration("P1Y"), xs:yearMonthDuration("P1M"))) instance of xs:yearMonthDuration
min()
min((1.0, 1, 1.0, 1, 1)) instance of xs:decimal
min((1.0, 1, 1, 1, 1)) instance of xs:decimal
min((1, 1, 1, 1, 1.0)) instance of xs:decimal
min((1, 1, 1, 1, 1, 3)) eq 1
min([1,2,3,4,5])
min((1, xs:float(2), xs:decimal(3))) instance of xs:float
min((3, 1, 1, 1, 1, 1)) eq 1
min((3, 1, 5, 1, 1, 3)) eq 1
min((3, 3, 3, 3, 3, 3)) eq 3
min((3,4,5)) eq 3
min((3,4, "Zero"))
min((3, -5.0, 5, 1, -3, 3)) eq -5.0
min((3, 5.0e0)) eq 3
min((3, 5.0e0)) instance of xs:double
min((3, xs:double("NaN"))) instance of xs:double
min((3, xs:float(2), xs:untypedAtomic("1"))) eq 1
min((3, xs:float(2), xs:untypedAtomic("1"))) instance of xs:double
min((3, xs:untypedAtomic("1"), xs:float(2))) instance of xs:double
min((5.0e0, 3)) eq 3
min((5.0e0, 3)) instance of xs:double
min((5.0e0, 5)) eq 5.0e0
min((5.0e0, 5)) instance of xs:double
min((5, 5.0e0)) eq 5.0e0
min((5, 5.0e0)) instance of xs:double
min(("a", "b", "c", "d"))
min(("a", "b", "c")) eq "a"
min(('a', 'b'), 'http://www.cbcl.co.u,/collation')
min(("a string")) eq "a string"
min("a string", "http://www.w3.org/2005/xpath-functions/collation/codepoint", "wrong param")
min(("a string", QName("example.com/", "ncname")))
min(("a string", xs:untypedAtomic("3")))
min(("str1", "str2"), "http://example.com/UNSUPPORTED_COLLATION")
min(("str1", "str2"), "http://www.w3.org/2005/xpath-functions/collation/codepoint", ())
minutes-from-dateTime()
minutes-from-dateTime(()) instance of xs:integer?
minutes-from-dateTime((), "Wrong param")
minutes-from-dateTime(xs:dateTime("2001-02-03T08:23:12.43")) eq 23
(minutes-from-dateTime( xs:dateTime('2006-08-15T10:30:23')))
minutes-from-duration()
minutes-from-duration(()) instance of xs:integer?
minutes-from-duration((), "Wrong param")
minutes-from-duration(xs:dayTimeDuration("-P3DT8H2M1.03S")) eq -2
minutes-from-duration(xs:dayTimeDuration("P3DT8H2M1.03S")) eq 2
(minutes-from-duration( xs:dayTimeDuration('PT1M90S')))
(minutes-from-duration( xs:dayTimeDuration('PT30M')))
(minutes-from-duration( xs:dayTimeDuration('PT30M')), minutes-from-duration( xs:dayTimeDuration('-PT90M')), minutes-from-duration( xs:dayTimeDuration('PT1M90S')), minutes-from-duration( xs:dayTimeDuration('PT3H')), minutes-from-duration( xs:dayTimeDuration('PT60M')))
(minutes-from-duration( xs:dayTimeDuration('PT3H')))
(minutes-from-duration( xs:dayTimeDuration('PT60M')))
(minutes-from-duration( xs:dayTimeDuration('-PT90M')))
minutes-from-duration(xs:duration("-P3Y4M8DT1H23M2.34S")) eq -23
minutes-from-time()
minutes-from-time(()) instance of xs:integer?
minutes-from-time((), "Wrong param")
(minutes-from-time(xs:time('10:30:23')))
minutes-from-time(xs:time("23:11:12.43")) eq 11
min(xs:anyURI("example.com/")) eq xs:anyURI("example.com/")
min((xs:anyURI("example.com/"), xs:anyURI("example.com/"))) eq xs:anyURI("example.com/")
min((xs:anyURI("http://a.com"), "http://b.com"))
min((xs:anyURI("http://a.com"), xs:anyURI("http://b.com")))
min((xs:anyURI("http://example.com/8"), xs:anyURI("http://example.com/4"))) eq xs:anyURI("http://example.com/4")
min((xs:anyURI("http://example.com/A"), xs:anyURI("http://example.com/A"))) eq xs:anyURI("http://example.com/A")
min((xs:anyURI("http://example.com/B"), xs:anyURI("http://example.com/A"))) eq xs:anyURI("http://example.com/A")
min(xs:anyURI("str1"), "http://example.com/UNSUPPORTED_COLLATION")
min((xs:date('1066-10-02'), xs:date('1588-08-08'), xs:date('2011-06-29')))
min((xs:date("2005-01-01"), xs:date("2001-01-01"))) eq xs:date("2001-01-01")
min((xs:dayTimeDuration("P1D"), xs:dayTimeDuration("PT2H"))) instance of xs:dayTimeDuration
min((xs:double("NaN"), 1, 1, 2, xs:float("NaN"))) instance of xs:double
min((xs:float(0.0E0), xs:float(-0.0E0))) eq xs:float("-0")
min((xs:float(-3), xs:untypedAtomic("3"), xs:double("NaN"))) instance of xs:double
min((xs:float("NaN"), 1, 1, 2, xs:double("NaN"))) instance of xs:double
min((xs:float("NaN"), xs:untypedAtomic("3"), xs:double(2))) instance of xs:double
min((xs:NCName('a'), xs:ID('b'), xs:token('c')))
min((xs:positiveInteger(123), xs:unsignedShort(124)))
min(xs:unsignedShort("1")) instance of xs:unsignedShort
min((xs:untypedAtomic("1"), 3, 2)) instance of xs:double
min((xs:untypedAtomic("3"), "a string"))
min(xs:untypedAtomic("3")) eq 3
min(xs:untypedAtomic("3")) instance of xs:double
min(xs:untypedAtomic("three"))
min((xs:yearMonthDuration("P1Y"), xs:yearMonthDuration("P1M"))) instance of xs:yearMonthDuration
() mod 1
module namespace prefix = "http://example.com"; declare function prefix:myFunction() { 1 };
module namespace prefix = "http://www.example.com/";
month-from-date()
month-from-date(()) instance of xs:integer?
month-from-dateTime()
month-from-dateTime(()) instance of xs:integer?
month-from-dateTime((), "Wrong param")
month-from-dateTime(xs:dateTime("2001-02-03T08:23:12.43")) eq 2
(month-from-dateTime( xs:dateTime('2006-08-15T10:30:23')))
month-from-date((), "Wrong param")
month-from-date(xs:date("2000-02-03")) eq 2
(month-from-date(xs:date('2006-08-15')))
months-from-duration()
months-from-duration(()) instance of xs:integer?
months-from-duration((), "Wrong param")
months-from-duration(xs:duration("-P3Y4M4DT1H23M2.34S")) eq -4
months-from-duration(xs:yearMonthDuration("-P0003Y2M")) eq -2
months-from-duration(xs:yearMonthDuration("P0003Y2M")) eq 2
(months-from-duration( xs:yearMonthDuration('P12M')))
(months-from-duration( xs:yearMonthDuration('-P18M')))
(months-from-duration( xs:yearMonthDuration('P1Y')))
(months-from-duration( xs:yearMonthDuration('P3M')))
(months-from-duration( xs:yearMonthDuration('P3M')), months-from-duration( xs:yearMonthDuration('-P18M')), months-from-duration( xs:yearMonthDuration('P1Y')), months-from-duration( xs:yearMonthDuration('P12M')))
-((<n>1</n> | ())[1])
name(/*)
name((//*[.='1983'])[1])
'N A M E' castable as xs:Name
name((//comment())[1]) = ''
(: Name: Excluded-char-2 :) (: Written by: Nicolae Brinza :) (: Description: The character #x0100 is excluded from the start of a Name :) (:              in XML 1.0 4th edition and older                          :) xquery version "1.0" encoding "utf-8"; < node/>
name(:hey:):*
name((//processing-instruction())[1])
<name>some, if(1) then else</name> instance of element()
namespace::*
namespace-node(1)
namespace-node {"p"} {"abc"}
namespace-uri(<e xmlns="http://example.com/{{1}}"/>)
namespace-uri(<e xmlns='http://ns.example.com/ns?val=''asd'/>)
(namespace-uri-from-QName( () ))
namespace-uri-from-QName()
namespace-uri-from-QName(1, 2)
namespace-uri-from-QName(node-name(exactly-one(<e xmlns="http://example.com/">{attribute attr {()} }/</e>/@attr))) eq ""
namespace-uri-from-QName( QName("example.com/", "pre:lname")) eq xs:anyURI("example.com/")
namespace-uri-from-QName( QName("example.com/", "pre:lname")) instance of xs:anyURI
(namespace-uri-from-QName( QName ('http://datypic.com/pre', 'prefixed')))
(namespace-uri-from-QName( QName ('http://datypic.com/pre', 'prefixed')), namespace-uri-from-QName( QName ('', 'unprefixed')), namespace-uri-from-QName( () ))
(namespace-uri-from-QName( QName ('', 'unprefixed')))
namespace-uri-from-QName(xs:QName("ncname"))
namespace-uri(<p:e xmlns:p="http://example.com/{{{{{{}}}}}}asd"/>)
namespace-uri(<p:e xmlns:p="http://ns.example.com/ns?val=""""""asd"/>)
namespace-uri(<p:e xmlns:p="http://ns.example.com/ns?val=""asd"/>)
namespace-uri(<p:e xmlns:p='http://ns.example.com/ns?val=''''''asd'/>)
name((//*:Start)[1]/@*)
nametest/
nametest//
nametest : nametest
nametest :nametest
nametest: nametest
name((//text())[1]) = ''
name((), "wrong param")
name((//@xml:*)[1])
<name xmlns:ns="http://example.com/NS"/>, ns:nametest
(: Name: XQueryComment001 :) (: Description: Simple use case for XQuery comments :) (: This is a comment :) <result/>
(: Name: XQueryComment002 :) (: Description: Simple use case for XQuery comments :) (: This is a comment :) (//fs:Folder)[1]/fs:File[1]/fs:FileName
(: Name: XQueryComment003 :) (: Description: Simple use case for XQuery comment containing '-' :) (:This is a comment-:) <result/>
(: Name: XQueryComment004 :) (: Description: Comment containing only '-' :) (:-:) <result/>
(: Name: XQueryComment004 :) (: Description: Empty comment :) (::) <result/>
(: Name: XQueryComment006 :) (: Description: Comment containing ':' :) (: this is a comment ::) <result/>
(: Name: XQueryComment007 :) (: Description: Comment containing ')' :) (: this is a comment ):) <result/>
(: Name: XQueryComment008 :) (: Description: Simple example of embedded comments :) (: this is a comment (: this is an embedded comment :):) <result/>
(: Name: XQueryComment009 :) (: Description: Comments inside a conditional expression :) if (:test (: yada (: neato :) :) :) (/fs:MyComputer)  then (: yada :) "true" else "false"
(: Name: XQueryComment010 :) (: Description: Comments inside a conditional expression :) if (: comment :)    ( //fs:Folder[1]/fs:FolderName/text() = "Folder00000000000" )  then (: this is the then case :) ( true() ) else (: this is the else case :) ( false() )
(: Name: XQueryComment011 :) (: Description: Comments inside a conditional expression :) if (:test:)(:t2:)(:t3:) (/fs:MyComputer)  then "true" else "false"
(: Name: XQueryComment012 :) (: Description: Comments that looks like a function call :) /south(: test :)
(: Name: XQueryComment013 :) (: Description: Comments inside a sequence expression :) (1, 2, (: comment :) 3, 4)
(: Name: XQueryComment015 :) (: Description: Incorrect comment syntax :) (! Wrong syntax :) <empty/>
(: Name: XQueryComment016 :) (: Description: Invalid comment :) (:) <empty/>
(: Name: XQueryComment017 :) (: Description: Invalid comment :) (:: ) <empty/>
(: Name: XQueryComment018 :) (: Description: Invalid comment :) -- Wrong comment format <empty/>
(: Name: XQueryComment019 :) (: Description: Old style comment syntax :) {-- Wrong comment format --} <empty/>
(: Name: XQueryComment020 :) (: Description: Comment containing an enclosed expression :) (: { "comment" } :) <result/>
" naN" cast as xs:decimal
"naN" cast as xs:decimal
* :ncname
::ncname
ncname :*
ncname: *
<ncname (:a misplaced comment:)/>
'NCName' castable as xs:Name
'NC:Name' castable as xs:NCName
'NCName' castable as xs:NCName
<ncname>content</ncname > = 'content'
ncname:(:hey:)*
<ncname></ ncname>
<ncname></ncname (:a misplaced comment:)>
<ncname></ncnameNOTBALANCED>
<new>{//*:child1}</new>
<new>{//*:child3}</new>
<new>{//*:child4}</new>
//news_item/title[contains(., "Foobar Corporation")]
<new xml:attr="foo"/>
<new xmlns:foo="http://www.example.com">{//@*:attr1}</new>
<new xmlns:foo="http://www.example.com">{//*:child1}</new>
<new xmlns:foo="http://www.example.com/parent1">{//*:child1}</new>
<new xmlns="http://www.example.com">{//*:child2}</new>
<new xmlns="http://www.example.com">{//*:child4}</new>
<new xmlns="http://www.example.com/parent4">{//*:child4}</new>
no-binding:*
node(*)
node(1)
node-name()
node-name(/*, ())
node-name(3.3)
node-name( (<a/>, <b/>))
node-name( (<a/>, "mystring"))
node-name(/*) instance of xs:QName
node-name( node-name(<a/>))
node-name("string")
node-name((), "wrong param")
<node xmlns="http://example.com/ns"/>/node-name()
<node xml:space="preserve" xmlns="http://example.com/ns"/>/@xml:space/node-name()
(normalize-space(' '))
(normalize-space(''))
(normalize-space(()))
normalize-space(())
normalize-space(" 143 1239 fhjkls ") eq "143 1239 fhjkls"
normalize-space("a string", "wrong param")
(normalize-space( <element> query </element>))
normalize-space(()) eq ""
normalize-space(" foo") eq "foo"
normalize-space("f o o ") eq "f o o"
normalize-space("foo ") eq "foo"
normalize-space("foo") eq "foo"
normalize-space(iri-to-uri(("somestring", current-time())[1])) eq "somestring"
normalize-space(normalize-space(("foo", current-time())[1])) eq "foo"
(normalize-space(' query '))
(normalize-space('query'))
(normalize-space('query'), normalize-space(' query '), normalize-space('xml query'), normalize-space('xml query'), normalize-space('xml query'), normalize-space(''), normalize-space(' '), normalize-space(()), normalize-space( <element> query </element>))
normalize-space(string((//*:Price)[1]))
(normalize-space('xml query'))
normalize-unicode("f oo") eq "f oo
(not(''))
(not(()))
not("")
not('')
not((() = ()))
not(() != () )
not(() < () )
not(() <= () )
not(() = ())
not(() > () )
not(() >= () )
not(())
not()
not(//*)
(not(0))
not(0)
not(0.0)
not(0.0e0)
not(0 = count((1, 2, timezone-from-time(current-time()))))
not(0 eq count((1, 2, timezone-from-time(current-time()))))
not(0 or 0)
not(0 or xs:anyURI(""))
not((() = 1))
not(() != 1 )
not(() < 1 )
not(() <= 1 )
not(() = 1 )
not(() > 1 )
not(() >= 1 )
not(1 != () )
not(1 < () )
not(1 <= () )
not(1 = ())
not(1 > () )
not(1 >= () )
not(((10)div(3)) instance of xs:integer)
not(1.1 instance of xs:integer)
not((1, 2, 1.1, 4, 5) instance of xs:integer*)
not((1, 2) = (3, 4))
not(1, 2, 3, 4, 5, 6)
not((1, 2, 3, 4, 5) instance of xs:integer)
not((1, 2, 3, 4, 5) instance of xs:integer?)
not((1, 2, 3) castable as xs:integer)
not((1, 2, "a string", 4, 5) instance of xs:integer*)
not((1, 2, "a string", 4, 5) instance of xs:string*)
not(1 ge xs:double("NaN"))
not(1 ge xs:float("NaN"))
not(1 gt xs:double("NaN"))
not(1 gt xs:float("NaN"))
not(1 instance of comment())
not(1 instance of element())
not(1 instance of node())
not(1 instance of processing-instruction())
not(1 instance of text())
not(1 le xs:double("NaN"))
not(1 le xs:float("NaN"))
not(1 lt xs:double("NaN"))
not(1 lt xs:float("NaN"))
not(1 != xs:untypedAtomic("1"))
not((/, 23))
not((23, /))
not("2" = xs:untypedAtomic("1"))
(not(32 >          20))
(not(32 > 20), not((/) //product), not(true()), not(()), not(''), not(0), not(<e>false</e>))
not("abc" eq concat("a", "bc"))
not("abc" eq string(/works/@id))
not("abc" eq /works/@id)
not("abc" eq xs:string(/works/@id))
not('abc' gt 'abc')
not('abc' le 'a')
not('abc' lt 'a')
not("abc" ne concat("a", "bc"))
not("abc" ne string(/works/@id))
not("abc" ne /works/@id)
not("abc" ne xs:string(/works/@id))
not(<!-- a comment --> instance of xs:string)
not(<!-- a comment --> instance of xs:untypedAtomic)
not('a' ge 'abc')
not("" and 0)
not("a string" != "a string")
not("a string" = "a stringDIFF")
not("a string" instance of xs:NOTATION)
not("a string" instance of xs:QName)
not("a string" instance of xs:untypedAtomic)
not("a string" != xs:untypedAtomic("a string"))
not("a string" = xs:untypedAtomic("a stringDIFF"))
"notation is abstract" castable as xs:NOTATION
"notation is abstract" castable as xs:NOTATION?
"notation is abstract" cast as xs:NOTATION
"notation is abstract" cast as xs:NOTATION?
not(//banana)
not(boolean(""))
not(boolean(()))
not(boolean(false()))
not(boolean(for $x in 1 to 10 return $x * $x))
not(boolean(xs:anyURI("")))
not(boolean(xs:untypedAtomic("")))
not(() castable as xs:integer)
not(() castable as xs:QName)
not(contains("", "a string"))
not(contains("tattoo", "ttt"))
not(count((1, 2, current-time(), 4))) eq false()
not(count((1, 2, current-time())) eq 0)
not(data(<!-- a comment -->) instance of xs:untypedAtomic)
not(data(<name>some text</name>) instance of xs:string)
not(data(<?target content?>) instance of xs:untypedAtomic)
not(deep-equal((), (1, 1, 1)))
not(deep-equal((1, 1, 1), ()))
not(deep-equal(((), 1, 1), (1, 1, 1)))
not(deep-equal((1, (), 1), (1, 1, 1)))
not(deep-equal((1, 1), (1, 1, 1)))
not(deep-equal((1, 1, ()), (1, 1, 1)))
not(deep-equal((1, 1, 1), ((), 1, 1)))
not(deep-equal((1, 1, 1), (1, (), 1)))
not(deep-equal((1, 1, 1), (1, 1)))
not(deep-equal((1, 1, 1), (1, 1, ())))
not(deep-equal((1, 1, 1), (1, 1, 3)))
not(deep-equal((1, 1, 1), (1, 3, 1)))
not(deep-equal((1, 1, 1), (3, 1, 1)))
not(deep-equal((1, 1, 3), (1, 1, 1)))
not(deep-equal((1, 2, 3), (1, 2, QName("example.com", "ncname"))))
not(deep-equal((1, 2, 3), (1, xs:hexBinary("FF"), 3)))
not(deep-equal((1, 2, 3), (xs:base64Binary("FFFF"), 2, 3)))
not(deep-equal((1, 2, xs:anyURI("example.com")), (1, 2, 3)))
not(deep-equal((1, 3, 1), (1, 1, 1)))
not(deep-equal((1, xs:decimal("2.2"), 3), (1, 2, 3)))
not(deep-equal((3, 1, 1), (1, 1, 1)))
not(deep-equal(current-time(), current-date()))
not(deep-equal(QName("example.com", "ncname"), 3e2))
not(deep-equal((true(), 2, 3), (1, 2, 3)))
not(deep-equal(xs:decimal("1"), xs:anyURI("example.com")))
not(deep-equal(xs:double(0), xs:double("NaN")))
not(deep-equal(xs:double("NaN"), xs:double(0)))
not(deep-equal(xs:float(0), xs:float("NaN")))
not(deep-equal(xs:float("NaN"), xs:float(0)))
(not(<e>false</e>))
not(empty(((), 1, 2)))
not(empty((1, 2)))
not(empty((1, 2, 3)[1]))
not(empty((1, 2, 3)[3]))
not(empty( ((), 1, "string") ))
not(empty((1, "string")))
not(empty((1, (), "string")))
not(empty(remove((current-time(), 1), 1)))
not(empty(reverse((1))))
not(empty("string"))
not(ends-with ((), "a string"))
not(ends-with("tattoo", "atto"))
not('equal' ne 'equal')
not(every $foo in 1 satisfies false())
not(every $var in (1, 2, 3) satisfies $var eq 3)
not(every $var in (false(), true(), true()) satisfies $var)
not(every $var in (true(), false(), true()) satisfies $var)
not(every $var in (true(), true(), false()) satisfies $var)
not(exists( ((), (), (), ()) ))
not(exists(()))
not(exists(remove(remove((current-time(), 1), 1), 1)))
not(exists(reverse(())))
not(false())
not(false() and false())
not("false" instance of xs:boolean)
not(false() != xs:untypedAtomic("false"))
not(false() > xs:untypedAtomic("true"))
not(fn:number(()))
not(fn:number("results in NaN"))
not(matches('', '^(?:\n\na\n\nb\n\n)$')) and          (every $s in tokenize(' a b; , a b; , a b; ', ',')                  satisfies not(matches($s, '^(?:\n\na\n\nb\n\n)$')))
not('nada' eq 'equalness')
not(<name>some text</name> instance of xs:untypedAtomic)
'not' ne 'equal'
not(not(true()))
not(not(xs:anyURI("example.com/")))
not(("one", "two") castable as xs:string?)
not("" or 0)
(not((/) //product))
not(QName("", "lname") castable as xs:integer)
not(reverse(()))
not(some $a as empty-sequence() in (), $b as xs:integer in $a satisfies $b)
not(some $foo in 1 satisfies false())
not(some $i in () satisfies $i)
not(some $var in (false(), false(), false()) satisfies $var)
not(starts-with("", "a string"))
not(starts-with("tattoo", "att"))
not('string' castable as xs:boolean)
not(string(current-time()) eq "now")
not(string(current-time()) ge "now")
not(string(current-time()) gt "now")
not(string(current-time()) le "now")
not(string(current-time()) lt "now")
not(string(current-time()) ne "now")
not(string(/works/@id) eq "abc")
not(string(/works/@id) ne "abc")
not(<?target content?> instance of xs:untypedAtomic)
not("three" castable as xs:decimal)
not("three" castable as xs:double)
not("three" castable as xs:float)
not("three" castable as xs:integer)
(not(true()))
not(true() cast as xs:boolean eq false())
not((true(), false()))
not(true() < xs:untypedAtomic("false"))
not(works/@id eq "abc")
not(works/@id ne "abc")
not(xs:anyURI(""))
not(xs:anyURI("") and xs:anyURI("example.com/"))
not(xs:anyURI("example.com/") and xs:anyURI(""))
not(xs:anyURI("example.com/") castable as xs:integer)
not(xs:anyURI("http://example.com/A") eq xs:anyURI("http://example.com/B"))
not(xs:anyURI("http://example.com/A") eq xs:string("http://example.com/B"))
not(xs:anyURI("http://example.com/A") gt xs:anyURI("http://example.com/B"))
not(xs:anyURI("http://example.com/A") ne xs:anyURI("http://example.com/A"))
not(xs:anyURI("http://example.com/A") ne xs:string("http://example.com/A"))
not(xs:anyURI("http://example.com/B") le xs:anyURI("http://example.com/A"))
not(xs:anyURI("http://example.com/B") le xs:string("http://example.com/A"))
not(xs:anyURI("http://example.com/B") lt xs:anyURI("http://example.com/A"))
not(xs:anyURI("http://example.com/B") lt xs:string("http://example.com/A"))
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:base64Binary)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:boolean)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:date)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:dateTime)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:dayTimeDuration)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:decimal)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:double)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:duration)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:float)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:gDay)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:gMonth)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:gMonthDay)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:gYear)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:gYearMonth)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:hexBinary)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:integer)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:NOTATION)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:time)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:yearMonthDuration)
not(xs:anyURI("http://www.example.com/") instance of xs:string)
not(xs:anyURI("") or 0)
not(xs:base64Binary("aaaa") castable as xs:anyURI)
not(xs:base64Binary("aaaa") castable as xs:boolean)
not(xs:base64Binary("aaaa") castable as xs:date)
not(xs:base64Binary("aaaa") castable as xs:dateTime)
not(xs:base64Binary("aaaa") castable as xs:dayTimeDuration)
not(xs:base64Binary("aaaa") castable as xs:decimal)
not(xs:base64Binary("aaaa") castable as xs:double)
not(xs:base64Binary("aaaa") castable as xs:duration)
not(xs:base64Binary("aaaa") castable as xs:float)
not(xs:base64Binary("aaaa") castable as xs:gDay)
not(xs:base64Binary("aaaa") castable as xs:gMonth)
not(xs:base64Binary("aaaa") castable as xs:gMonthDay)
not(xs:base64Binary("aaaa") castable as xs:gYear)
not(xs:base64Binary("aaaa") castable as xs:gYearMonth)
not(xs:base64Binary("aaaa") castable as xs:integer)
not(xs:base64Binary("aaaa") castable as xs:NOTATION)
not(xs:base64Binary("aaaa") castable as xs:time)
not(xs:base64Binary("aaaa") castable as xs:yearMonthDuration)
not(xs:boolean("true") castable as xs:anyURI)
not(xs:boolean("true") castable as xs:base64Binary)
not(xs:boolean("true") castable as xs:date)
not(xs:boolean("true") castable as xs:dateTime)
not(xs:boolean("true") castable as xs:dayTimeDuration)
not(xs:boolean("true") castable as xs:duration)
not(xs:boolean("true") castable as xs:gDay)
not(xs:boolean("true") castable as xs:gMonth)
not(xs:boolean("true") castable as xs:gMonthDay)
not(xs:boolean("true") castable as xs:gYear)
not(xs:boolean("true") castable as xs:gYearMonth)
not(xs:boolean("true") castable as xs:hexBinary)
not(xs:boolean("true") castable as xs:NOTATION)
not(xs:boolean("true") castable as xs:time)
not(xs:boolean("true") castable as xs:yearMonthDuration)
not(xs:date("2004-07-11") ge xs:date("2004-07-12"))
not(xs:date("2004-07-12") gt xs:date("2004-07-12"))
not(xs:date("2004-07-12") gt xs:date("2004-07-13"))
not(xs:date("2004-07-12") ne xs:date("2004-07-12"))
not(xs:date("2004-07-13") le xs:date("2004-07-12"))
not(xs:date("2004-07-13") lt xs:date("2004-07-12"))
not(xs:date("2004-07-13") lt xs:date("2004-07-13"))
not(xs:date("2004-08-12") eq xs:date("2003-08-12"))
not(xs:date("2004-10-13") castable as xs:anyURI)
not(xs:date("2004-10-13") castable as xs:base64Binary)
not(xs:date("2004-10-13") castable as xs:boolean)
not(xs:date("2004-10-13") castable as xs:dayTimeDuration)
not(xs:date("2004-10-13") castable as xs:decimal)
not(xs:date("2004-10-13") castable as xs:double)
not(xs:date("2004-10-13") castable as xs:duration)
not(xs:date("2004-10-13") castable as xs:float)
not(xs:date("2004-10-13") castable as xs:hexBinary)
not(xs:date("2004-10-13") castable as xs:integer)
not(xs:date("2004-10-13") castable as xs:NOTATION)
not(xs:date("2004-10-13") castable as xs:time)
not(xs:date("2004-10-13") castable as xs:yearMonthDuration)
not(xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:anyURI)
not(xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:base64Binary)
not(xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:boolean)
not(xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:dayTimeDuration)
not(xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:decimal)
not(xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:double)
not(xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:duration)
not(xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:float)
not(xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:hexBinary)
not(xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:integer)
not(xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:NOTATION)
not(xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:yearMonthDuration)
not(xs:dateTime("2004-07-11T23:01:04.12") ge xs:dateTime("2004-07-12T23:01:04.12"))
not(xs:dateTime("2004-07-12T23:01:04.12") gt xs:dateTime("2004-07-12T23:01:04.12"))
not(xs:dateTime("2004-07-12T23:01:04.12") gt xs:dateTime("2004-07-13T23:01:04.12"))
not(xs:dateTime("2004-07-12T23:01:04.12") ne xs:dateTime("2004-07-12T23:01:04.12"))
not(xs:dateTime("2004-07-13T23:01:04.12") le xs:dateTime("2004-07-12T23:01:04.12"))
not(xs:dateTime("2004-07-13T23:01:04.12") lt xs:dateTime("2004-07-12T23:01:04.12"))
not(xs:dateTime("2004-07-13T23:01:04.12") lt xs:dateTime("2004-07-13T23:01:04.12"))
not(xs:dateTime("2004-08-12T23:01:04.12") eq xs:dateTime("2004-08-12T23:01:04.13"))
not(xs:dayTimeDuration("P3DT08H34M12.043S") eq xs:dayTimeDuration("P3DT08H34M12.143S"))
not(xs:dayTimeDuration("P3DT08H34M12.143S") ge xs:dayTimeDuration("P3DT08H34M12.144S"))
not(xs:dayTimeDuration("P3DT08H34M12.143S") le xs:dayTimeDuration("P3DT08H34M12.142S"))
not(xs:dayTimeDuration("P3DT08H34M12.143S") lt xs:dayTimeDuration("P3DT08H34M12.143S"))
not(xs:dayTimeDuration("P3DT08H34M12.143S") ne xs:dayTimeDuration("P3DT08H34M12.143S"))
not(xs:dayTimeDuration("P3DT08H34M12.144S") gt xs:dayTimeDuration("P3DT08H34M12.144S"))
not(xs:dayTimeDuration("P3DT08H34M12.144S") gt xs:dayTimeDuration("P3DT08H34M12.145S"))
not(xs:dayTimeDuration("P3DT08H34M12.144S") lt xs:dayTimeDuration("P3DT08H34M12.143S"))
not(xs:dayTimeDuration("P3DT2H") castable as xs:anyURI)
not(xs:dayTimeDuration("P3DT2H") castable as xs:base64Binary)
not(xs:dayTimeDuration("P3DT2H") castable as xs:boolean)
not(xs:dayTimeDuration("P3DT2H") castable as xs:date)
not(xs:dayTimeDuration("P3DT2H") castable as xs:dateTime)
not(xs:dayTimeDuration("P3DT2H") castable as xs:decimal)
not(xs:dayTimeDuration("P3DT2H") castable as xs:double)
not(xs:dayTimeDuration("P3DT2H") castable as xs:float)
not(xs:dayTimeDuration("P3DT2H") castable as xs:gDay)
not(xs:dayTimeDuration("P3DT2H") castable as xs:gMonth)
not(xs:dayTimeDuration("P3DT2H") castable as xs:gMonthDay)
not(xs:dayTimeDuration("P3DT2H") castable as xs:gYear)
not(xs:dayTimeDuration("P3DT2H") castable as xs:gYearMonth)
not(xs:dayTimeDuration("P3DT2H") castable as xs:hexBinary)
not(xs:dayTimeDuration("P3DT2H") castable as xs:integer)
not(xs:dayTimeDuration("P3DT2H") castable as xs:NOTATION)
not(xs:dayTimeDuration("P3DT2H") castable as xs:time)
not(xs:decimal("10.01") castable as xs:anyURI)
not(xs:decimal("10.01") castable as xs:base64Binary)
not(xs:decimal("10.01") castable as xs:date)
not(xs:decimal("10.01") castable as xs:dateTime)
not(xs:decimal("10.01") castable as xs:dayTimeDuration)
not(xs:decimal("10.01") castable as xs:duration)
not(xs:decimal("10.01") castable as xs:gDay)
not(xs:decimal("10.01") castable as xs:gMonth)
not(xs:decimal("10.01") castable as xs:gMonthDay)
not(xs:decimal("10.01") castable as xs:gYear)
not(xs:decimal("10.01") castable as xs:gYearMonth)
not(xs:decimal("10.01") castable as xs:hexBinary)
not(xs:decimal("10.01") castable as xs:NOTATION)
not(xs:decimal("10.01") castable as xs:time)
not(xs:decimal("10.01") castable as xs:yearMonthDuration)
not(xs:double("3.3e3") castable as xs:anyURI)
not(xs:double("3.3e3") castable as xs:base64Binary)
not(xs:double("3.3e3") castable as xs:date)
not(xs:double("3.3e3") castable as xs:dateTime)
not(xs:double("3.3e3") castable as xs:dayTimeDuration)
not(xs:double("3.3e3") castable as xs:duration)
not(xs:double("3.3e3") castable as xs:gDay)
not(xs:double("3.3e3") castable as xs:gMonth)
not(xs:double("3.3e3") castable as xs:gMonthDay)
not(xs:double("3.3e3") castable as xs:gYear)
not(xs:double("3.3e3") castable as xs:gYearMonth)
not(xs:double("3.3e3") castable as xs:hexBinary)
not(xs:double("3.3e3") castable as xs:NOTATION)
not(xs:double("3.3e3") castable as xs:time)
not(xs:double("3.3e3") castable as xs:yearMonthDuration)
not(xs:double("NaN"))
not(xs:double('NaN'))
not(xs:double("NaN") ge 1)
not(xs:double("NaN") gt 1)
not(xs:double("NaN") le 1)
not(xs:double("NaN") lt 1)
not(xs:duration("P1999Y10M3DT08H34M12.043S") eq xs:duration("P1999Y10M3DT08H34M12.143S"))
not(xs:duration("P1999Y10M3DT08H34M12.143S") ne xs:duration("P1999Y10M3DT08H34M12.143S"))
not(xs:duration("P1Y2M3DT10H30M") castable as xs:anyURI)
not(xs:duration("P1Y2M3DT10H30M") castable as xs:base64Binary)
not(xs:duration("P1Y2M3DT10H30M") castable as xs:boolean)
not(xs:duration("P1Y2M3DT10H30M") castable as xs:date)
not(xs:duration("P1Y2M3DT10H30M") castable as xs:dateTime)
not(xs:duration("P1Y2M3DT10H30M") castable as xs:decimal)
not(xs:duration("P1Y2M3DT10H30M") castable as xs:double)
not(xs:duration("P1Y2M3DT10H30M") castable as xs:float)
not(xs:duration("P1Y2M3DT10H30M") castable as xs:gDay)
not(xs:duration("P1Y2M3DT10H30M") castable as xs:gMonth)
not(xs:duration("P1Y2M3DT10H30M") castable as xs:gMonthDay)
not(xs:duration("P1Y2M3DT10H30M") castable as xs:gYear)
not(xs:duration("P1Y2M3DT10H30M") castable as xs:gYearMonth)
not(xs:duration("P1Y2M3DT10H30M") castable as xs:hexBinary)
not(xs:duration("P1Y2M3DT10H30M") castable as xs:integer)
not(xs:duration("P1Y2M3DT10H30M") castable as xs:NOTATION)
not(xs:duration("P1Y2M3DT10H30M") castable as xs:time)
not(xs:float("3.4e5") castable as xs:anyURI)
not(xs:float("3.4e5") castable as xs:base64Binary)
not(xs:float("3.4e5") castable as xs:date)
not(xs:float("3.4e5") castable as xs:dateTime)
not(xs:float("3.4e5") castable as xs:dayTimeDuration)
not(xs:float("3.4e5") castable as xs:duration)
not(xs:float("3.4e5") castable as xs:gDay)
not(xs:float("3.4e5") castable as xs:gMonth)
not(xs:float("3.4e5") castable as xs:gMonthDay)
not(xs:float("3.4e5") castable as xs:gYear)
not(xs:float("3.4e5") castable as xs:gYearMonth)
not(xs:float("3.4e5") castable as xs:hexBinary)
not(xs:float("3.4e5") castable as xs:NOTATION)
not(xs:float("3.4e5") castable as xs:time)
not(xs:float("3.4e5") castable as xs:yearMonthDuration)
not(xs:float("NaN"))
not(xs:float('NaN'))
not(xs:float("NaN") ge 1)
not(xs:float("NaN") gt 1)
not(xs:float("NaN") le 1)
not(xs:float("NaN") lt 1)
not(xs:gDay("---01") ne xs:gDay("---01"))
not(xs:gDay("---03") castable as xs:anyURI)
not(xs:gDay("---03") castable as xs:base64Binary)
not(xs:gDay("---03") castable as xs:boolean)
not(xs:gDay("---03") castable as xs:date)
not(xs:gDay("---03") castable as xs:dateTime)
not(xs:gDay("---03") castable as xs:dayTimeDuration)
not(xs:gDay("---03") castable as xs:decimal)
not(xs:gDay("---03") castable as xs:double)
not(xs:gDay("---03") castable as xs:duration)
not(xs:gDay("---03") castable as xs:float)
not(xs:gDay("---03") castable as xs:gMonth)
not(xs:gDay("---03") castable as xs:gMonthDay)
not(xs:gDay("---03") castable as xs:gYear)
not(xs:gDay("---03") castable as xs:gYearMonth)
not(xs:gDay("---03") castable as xs:hexBinary)
not(xs:gDay("---03") castable as xs:integer)
not(xs:gDay("---03") castable as xs:NOTATION)
not(xs:gDay("---03") castable as xs:time)
not(xs:gDay("---03") castable as xs:yearMonthDuration)
not(xs:gDay("---31") eq xs:gDay("---01"))
not(xs:gMonth("--03") ne xs:gMonth("--03"))
not(xs:gMonth("--11") castable as xs:anyURI)
not(xs:gMonth("--11") castable as xs:base64Binary)
not(xs:gMonth("--11") castable as xs:boolean)
not(xs:gMonth("--11") castable as xs:date)
not(xs:gMonth("--11") castable as xs:dateTime)
not(xs:gMonth("--11") castable as xs:dayTimeDuration)
not(xs:gMonth("--11") castable as xs:decimal)
not(xs:gMonth("--11") castable as xs:double)
not(xs:gMonth("--11") castable as xs:duration)
not(xs:gMonth("--11") castable as xs:float)
not(xs:gMonth("--11") castable as xs:gDay)
not(xs:gMonth("--11") castable as xs:gMonthDay)
not(xs:gMonth("--11") castable as xs:gYear)
not(xs:gMonth("--11") castable as xs:gYearMonth)
not(xs:gMonth("--11") castable as xs:hexBinary)
not(xs:gMonth("--11") castable as xs:integer)
not(xs:gMonth("--11") castable as xs:NOTATION)
not(xs:gMonth("--11") castable as xs:time)
not(xs:gMonth("--11") castable as xs:yearMonthDuration)
not(xs:gMonth("--11") eq xs:gMonth("--01"))
not(xs:gMonthDay("--03-03") eq xs:gMonthDay("--04-03"))
not(xs:gMonthDay("--04-11") ne xs:gMonthDay("--04-11"))
not(xs:gMonthDay("--11-13") castable as xs:anyURI)
not(xs:gMonthDay("--11-13") castable as xs:base64Binary)
not(xs:gMonthDay("--11-13") castable as xs:boolean)
not(xs:gMonthDay("--11-13") castable as xs:date)
not(xs:gMonthDay("--11-13") castable as xs:dateTime)
not(xs:gMonthDay("--11-13") castable as xs:dayTimeDuration)
not(xs:gMonthDay("--11-13") castable as xs:decimal)
not(xs:gMonthDay("--11-13") castable as xs:double)
not(xs:gMonthDay("--11-13") castable as xs:duration)
not(xs:gMonthDay("--11-13") castable as xs:float)
not(xs:gMonthDay("--11-13") castable as xs:gDay)
not(xs:gMonthDay("--11-13") castable as xs:gMonth)
not(xs:gMonthDay("--11-13") castable as xs:gYear)
not(xs:gMonthDay("--11-13") castable as xs:gYearMonth)
not(xs:gMonthDay("--11-13") castable as xs:hexBinary)
not(xs:gMonthDay("--11-13") castable as xs:integer)
not(xs:gMonthDay("--11-13") castable as xs:NOTATION)
not(xs:gMonthDay("--11-13") castable as xs:time)
not(xs:gMonthDay("--11-13") castable as xs:yearMonthDuration)
not(xs:gYear("1956") eq xs:gYear("1958"))
not(xs:gYear("1956") ne xs:gYear("1956"))
not(xs:gYear("1999") castable as xs:anyURI)
not(xs:gYear("1999") castable as xs:base64Binary)
not(xs:gYear("1999") castable as xs:boolean)
not(xs:gYear("1999") castable as xs:date)
not(xs:gYear("1999") castable as xs:dateTime)
not(xs:gYear("1999") castable as xs:dayTimeDuration)
not(xs:gYear("1999") castable as xs:decimal)
not(xs:gYear("1999") castable as xs:double)
not(xs:gYear("1999") castable as xs:duration)
not(xs:gYear("1999") castable as xs:float)
not(xs:gYear("1999") castable as xs:gDay)
not(xs:gYear("1999") castable as xs:gMonth)
not(xs:gYear("1999") castable as xs:gMonthDay)
not(xs:gYear("1999") castable as xs:gYearMonth)
not(xs:gYear("1999") castable as xs:hexBinary)
not(xs:gYear("1999") castable as xs:integer)
not(xs:gYear("1999") castable as xs:NOTATION)
not(xs:gYear("1999") castable as xs:time)
not(xs:gYear("1999") castable as xs:yearMonthDuration)
not(xs:gYearMonth("1995-11") ne xs:gYearMonth("1995-11"))
not(xs:gYearMonth("1999-11") castable as xs:anyURI)
not(xs:gYearMonth("1999-11") castable as xs:base64Binary)
not(xs:gYearMonth("1999-11") castable as xs:boolean)
not(xs:gYearMonth("1999-11") castable as xs:date)
not(xs:gYearMonth("1999-11") castable as xs:dateTime)
not(xs:gYearMonth("1999-11") castable as xs:dayTimeDuration)
not(xs:gYearMonth("1999-11") castable as xs:decimal)
not(xs:gYearMonth("1999-11") castable as xs:double)
not(xs:gYearMonth("1999-11") castable as xs:duration)
not(xs:gYearMonth("1999-11") castable as xs:float)
not(xs:gYearMonth("1999-11") castable as xs:gDay)
not(xs:gYearMonth("1999-11") castable as xs:gMonth)
not(xs:gYearMonth("1999-11") castable as xs:gMonthDay)
not(xs:gYearMonth("1999-11") castable as xs:gYear)
not(xs:gYearMonth("1999-11") castable as xs:hexBinary)
not(xs:gYearMonth("1999-11") castable as xs:integer)
not(xs:gYearMonth("1999-11") castable as xs:NOTATION)
not(xs:gYearMonth("1999-11") castable as xs:time)
not(xs:gYearMonth("1999-11") castable as xs:yearMonthDuration)
not(xs:gYearMonth("2001-03") eq xs:gYearMonth("2000-03"))
not(xs:hexBinary("0FB7") castable as xs:anyURI)
not(xs:hexBinary("0FB7") castable as xs:boolean)
not(xs:hexBinary("0FB7") castable as xs:date)
not(xs:hexBinary("0FB7") castable as xs:dateTime)
not(xs:hexBinary("0FB7") castable as xs:dayTimeDuration)
not(xs:hexBinary("0FB7") castable as xs:decimal)
not(xs:hexBinary("0FB7") castable as xs:double)
not(xs:hexBinary("0FB7") castable as xs:duration)
not(xs:hexBinary("0FB7") castable as xs:float)
not(xs:hexBinary("0FB7") castable as xs:gDay)
not(xs:hexBinary("0FB7") castable as xs:gMonth)
not(xs:hexBinary("0FB7") castable as xs:gMonthDay)
not(xs:hexBinary("0FB7") castable as xs:gYear)
not(xs:hexBinary("0FB7") castable as xs:gYearMonth)
not(xs:hexBinary("0FB7") castable as xs:integer)
not(xs:hexBinary("0FB7") castable as xs:NOTATION)
not(xs:hexBinary("0FB7") castable as xs:time)
not(xs:hexBinary("0FB7") castable as xs:yearMonthDuration)
not(xs:hexBinary("FF") eq xs:hexBinary("aa"))
not(xs:integer("6789") castable as xs:anyURI)
not(xs:integer("6789") castable as xs:base64Binary)
not(xs:integer("6789") castable as xs:date)
not(xs:integer("6789") castable as xs:dateTime)
not(xs:integer("6789") castable as xs:dayTimeDuration)
not(xs:integer("6789") castable as xs:duration)
not(xs:integer("6789") castable as xs:gDay)
not(xs:integer("6789") castable as xs:gMonth)
not(xs:integer("6789") castable as xs:gMonthDay)
not(xs:integer("6789") castable as xs:gYear)
not(xs:integer("6789") castable as xs:gYearMonth)
not(xs:integer("6789") castable as xs:hexBinary)
not(xs:integer("6789") castable as xs:NOTATION)
not(xs:integer("6789") castable as xs:time)
not(xs:integer("6789") castable as xs:yearMonthDuration)
not(xs:NOTATION("prefix:local") castable as xs:anyURI)
not(xs:NOTATION("prefix:local") castable as xs:base64Binary)
not(xs:NOTATION("prefix:local") castable as xs:boolean)
not(xs:NOTATION("prefix:local") castable as xs:date)
not(xs:NOTATION("prefix:local") castable as xs:dateTime)
not(xs:NOTATION("prefix:local") castable as xs:dayTimeDuration)
not(xs:NOTATION("prefix:local") castable as xs:decimal)
not(xs:NOTATION("prefix:local") castable as xs:double)
not(xs:NOTATION("prefix:local") castable as xs:duration)
not(xs:NOTATION("prefix:local") castable as xs:float)
not(xs:NOTATION("prefix:local") castable as xs:gDay)
not(xs:NOTATION("prefix:local") castable as xs:gMonth)
not(xs:NOTATION("prefix:local") castable as xs:gMonthDay)
not(xs:NOTATION("prefix:local") castable as xs:gYear)
not(xs:NOTATION("prefix:local") castable as xs:gYearMonth)
not(xs:NOTATION("prefix:local") castable as xs:hexBinary)
not(xs:NOTATION("prefix:local") castable as xs:integer)
not(xs:NOTATION("prefix:local") castable as xs:NOTATION)
not(xs:NOTATION("prefix:local") castable as xs:QName)
not(xs:NOTATION("prefix:local") castable as xs:string)
not(xs:NOTATION("prefix:local") castable as xs:time)
not(xs:NOTATION("prefix:local") castable as xs:untypedAtomic)
not(xs:NOTATION("prefix:local") castable as xs:yearMonthDuration)
not(xs:QName("ncname") castable as xs:anyURI)
not(xs:QName("ncname") castable as xs:base64Binary)
not(xs:QName("ncname") castable as xs:boolean)
not(xs:QName("ncname") castable as xs:date)
not(xs:QName("ncname") castable as xs:dateTime)
not(xs:QName("ncname") castable as xs:dayTimeDuration)
not(xs:QName("ncname") castable as xs:decimal)
not(xs:QName("ncname") castable as xs:double)
not(xs:QName("ncname") castable as xs:duration)
not(xs:QName("ncname") castable as xs:float)
not(xs:QName("ncname") castable as xs:gDay)
not(xs:QName("ncname") castable as xs:gMonth)
not(xs:QName("ncname") castable as xs:gMonthDay)
not(xs:QName("ncname") castable as xs:gYear)
not(xs:QName("ncname") castable as xs:gYearMonth)
not(xs:QName("ncname") castable as xs:hexBinary)
not(xs:QName("ncname") castable as xs:integer)
not(xs:QName("ncname") castable as xs:NOTATION)
not(xs:QName("ncname") castable as xs:time)
not(xs:QName("ncname") castable as xs:yearMonthDuration)
not(xs:string("an arbitrary string") castable as xs:NOTATION)
not(xs:string("http://example.com/A") eq xs:anyURI("http://example.com/B"))
not(xs:string("http://example.com/A") gt xs:anyURI("http://example.com/B"))
not(xs:string("http://example.com/A") ne xs:anyURI("http://example.com/A"))
not(xs:string(/works/@id) eq "abc")
not(xs:string(/works/@id) ne "abc")
not(xs:time("03:20:00-05:00") castable as xs:anyURI)
not(xs:time("03:20:00-05:00") castable as xs:base64Binary)
not(xs:time("03:20:00-05:00") castable as xs:boolean)
not(xs:time("03:20:00-05:00") castable as xs:date)
not(xs:time("03:20:00-05:00") castable as xs:dateTime)
not(xs:time("03:20:00-05:00") castable as xs:dayTimeDuration)
not(xs:time("03:20:00-05:00") castable as xs:decimal)
not(xs:time("03:20:00-05:00") castable as xs:double)
not(xs:time("03:20:00-05:00") castable as xs:duration)
not(xs:time("03:20:00-05:00") castable as xs:float)
not(xs:time("03:20:00-05:00") castable as xs:gDay)
not(xs:time("03:20:00-05:00") castable as xs:gMonth)
not(xs:time("03:20:00-05:00") castable as xs:gMonthDay)
not(xs:time("03:20:00-05:00") castable as xs:gYear)
not(xs:time("03:20:00-05:00") castable as xs:gYearMonth)
not(xs:time("03:20:00-05:00") castable as xs:hexBinary)
not(xs:time("03:20:00-05:00") castable as xs:integer)
not(xs:time("03:20:00-05:00") castable as xs:NOTATION)
not(xs:time("03:20:00-05:00") castable as xs:yearMonthDuration)
not(xs:untypedAtomic("1") != 1)
not((xs:untypedAtomic("1"), xs:untypedAtomic("2")) = (xs:untypedAtomic("2.0"), 3.0))
not(xs:untypedAtomic("2") = 1)
not(xs:untypedAtomic("an arbitrary string(untypedAtomic source)") castable as xs:NOTATION)
not(xs:untypedAtomic("a string") and xs:untypedAtomic(""))
not(xs:untypedAtomic("a string") != "a string")
not(xs:untypedAtomic("a string") = "a stringDIFF")
not(xs:untypedAtomic(current-time()) eq xs:untypedAtomic("now"))
not(xs:untypedAtomic(current-time()) ge xs:untypedAtomic("now"))
not(xs:untypedAtomic(current-time()) gt xs:untypedAtomic("now"))
not(xs:untypedAtomic(current-time()) le xs:untypedAtomic("now"))
not(xs:untypedAtomic(current-time()) lt xs:untypedAtomic("now"))
not(xs:untypedAtomic(current-time()) ne xs:untypedAtomic("now"))
not(xs:untypedAtomic("false") != false())
not(xs:untypedAtomic("false") > true())
not(xs:untypedAtomic("true") < false())
not(xs:untypedAtomic("true") = false())
not(xs:yearMonthDuration("P1999Y10M") gt xs:yearMonthDuration("P1999Y10M"))
not(xs:yearMonthDuration("P1999Y10M") gt xs:yearMonthDuration("P1999Y11M"))
not(xs:yearMonthDuration("P1999Y10M") le xs:yearMonthDuration("P1999Y9M"))
not(xs:yearMonthDuration("P1999Y10M") lt xs:yearMonthDuration("P1999Y10M"))
not(xs:yearMonthDuration("P1999Y10M") lt xs:yearMonthDuration("P1999Y9M"))
not(xs:yearMonthDuration("P1999Y10M") ne xs:yearMonthDuration("P1999Y10M"))
not(xs:yearMonthDuration("P1999Y9M") ge xs:yearMonthDuration("P1999Y10M"))
not(xs:yearMonthDuration("P1999Y") eq xs:yearMonthDuration("P1999Y10M"))
not(xs:yearMonthDuration("P1Y12M") castable as xs:anyURI)
not(xs:yearMonthDuration("P1Y12M") castable as xs:base64Binary)
not(xs:yearMonthDuration("P1Y12M") castable as xs:boolean)
not(xs:yearMonthDuration("P1Y12M") castable as xs:date)
not(xs:yearMonthDuration("P1Y12M") castable as xs:dateTime)
not(xs:yearMonthDuration("P1Y12M") castable as xs:decimal)
not(xs:yearMonthDuration("P1Y12M") castable as xs:double)
not(xs:yearMonthDuration("P1Y12M") castable as xs:float)
not(xs:yearMonthDuration("P1Y12M") castable as xs:gDay)
not(xs:yearMonthDuration("P1Y12M") castable as xs:gMonth)
not(xs:yearMonthDuration("P1Y12M") castable as xs:gMonthDay)
not(xs:yearMonthDuration("P1Y12M") castable as xs:gYear)
not(xs:yearMonthDuration("P1Y12M") castable as xs:gYearMonth)
not(xs:yearMonthDuration("P1Y12M") castable as xs:hexBinary)
not(xs:yearMonthDuration("P1Y12M") castable as xs:integer)
not(xs:yearMonthDuration("P1Y12M") castable as xs:NOTATION)
not(xs:yearMonthDuration("P1Y12M") castable as xs:time)
number(1, 2)
number("  -22e0  ")
number("+22e0")
number( (/atomic:root/atomic:integer) except (/atomic:root/atomic:string))
number(false())
number(implicit-timezone())
number(true())
number(xs:untypedAtomic("1000"))
of
one-or-more( () )
one-or-more()
one-or-more(1, 2)
one-or-more((1 to 10)[. div 2 = 0])
(one-or-more('a'))
(one-or-more( ('a', 'b') ))
(one-or-more('a'), one-or-more( ('a', 'b') ))
one-or-more("one")
("one", "two") castable as xs:string+
("one two three four five" => Q{http://www.w3.org/2005/xpath-functions}tokenize(" ")) ! upper-case(.)
"one two three four five" => tokenize(" ") ! upper-case(.)
("one two three four five" => tokenize(" ")) ! upper-case(.)
<! oo -->
<!- oo -->
<!-- oo ->
<!--- oo ->
"" or ''
() or ()
() or (0)
() or (1)
"" or 'a'
order eq order
ordering eq ordering
<out>{1, <!-- content -->/ancestor-or-self::node(), 1}</out>
<out>{1, <e attr=""/>/descendant-or-self::node(), 1}</out>
<out>{1, <e/>/descendant-or-self::node(), 1}</out>
<out>{1, <element/>/ancestor-or-self::node(), 1}</out>
<out>{1, <?target data?>/ancestor-or-self::node(), 1}</out>
<out>{[<a/>, [<b/>, <c/>]]}</out>
<out>{array:flatten((<a/>, <b/>, <c/>))}</out>
<out>{array:flatten([<a/>, [<b/>, <c/>]])}</out>
<out>{ (<a xmlns:ex="http://www.example.com/ ns"><ex:b>93.7</ex:b></a>) /Q{ http://www.example.com/ ns }b/namespace-uri() }</out>
<out>{ (<a xmlns:ex="http://www.example.com/ns?p='23'"><ex:b>93.7</ex:b></a>) /Q{http://www.example.com/ns?p='23'}:b }</out>
<out>{ (<a xmlns:ex="http://www.example.com/ns?p='23'"><ex:b>93.7</ex:b></a>) /Q{http://www.example.com/ns?p='23'}}b }</out>
<out>{ (<a xmlns:ex="http://www.example.com/ns?p='23'"><ex:b>93.7</ex:b></a>) /Q{http://www.example.com/ns?p='23'}b }</out>
outermost(//*) except //*
outermost(//rubbish)
<out>{fn:count(//center/comment())}</out>
<out>{fn:count(//center/processing-instruction('a-pi'))}</out>
<out>{fn:count(//center/processing-instruction())}</out>
<out>{fn:count(//center/text())}</out>
<out>{fn:count(//comment())}</out>
<out>{fn:count(//processing-instruction('a-pi'))}</out>
<out>{fn:count(//processing-instruction())}</out>
<out>{ if (1 != 0) then if (4 != 5) then 1 else 2 else 3 }</out>
<out>{ (<my:a xmlns:my="http://www.example.com/ns/my"><my:b>42</my:b></my:a>) / Q{http://www.example.com/ns/my}* + 5 }</out>
<out>{ (<my:a xmlns:my="http://www.example.com/ns/my"><my:b>42</my:b></my:a>) / Q{http://www.example.com/ns/my}b }</out>
<out>{ <Q{http://www.example.com/ns}/> }</out>
<out xmlns="http://www.example.com/one">{ (<my:a xmlns:my="http://www.example.com/ns/my"><my:b>42</my:b><b xmlns="">93</b></my:a>) / Q{}* + 5 }</out>
"P11768614336404564651D" cast as xs:dayTimeDuration
"-P11768614336404564651D" cast as xs:duration
"-P768614336404564651Y" cast as xs:duration
"P768614336404564651Y" cast as xs:duration
"-P768614336404564651Y" cast as xs:yearMonthDuration
"P768614336404564651Y" cast as xs:yearMonthDuration
parent::
<parent><child xmlns:cm="http://www.example.com"/><child>{count(//cm:b)}</child></parent>
parent::self()
parse-json("[]")
parse-json("{}")
parse-json('')
parse-json('["\""]')
parse-json('["\"]')
parse-json('["\/"]')
parse-json('["\\"]')
parse-json('[00.00]')
parse-json('[01]')
parse-json('[-0.123]')
parse-json('[0.123]')
parse-json('[-0.123e+2]')
parse-json('[-0.123e-2[')
parse-json('[-0.123e-2]')
parse-json('[-0.123e2]')
parse-json('["\1"]')
parse-json('"111\333"')
parse-json('[1, 2, [], [1], [1,2], [1,2,3]]')
parse-json('[1,2,3,]')
parse-json("[12345]")
parse-json('[1.234f0]')
parse-json('         [   1,     2,  3,          "abc",  "def",   true,          false,  null ]         ')
parse-json('[1,2,3, "abc", "def", true, false, null]')
parse-json('[+23]')
parse-json('23,24')
parse-json('[.3]')
parse-json('3.14eg')
parse-json('314eg')
parse-json('3.14Eg')
parse-json('[(5)]')
parse-json('[{5}]')
parse-json('93.7')
parse-json('{"a"')
parse-json('{"a":=13}')
parse-json('{"a":13')
parse-json('{"a":13,,"b":15}')
parse-json('"aaa\"')
parse-json('["aa\u0030aa"]')
parse-json('{"a" "b"}')
parse-json('{"a":{"b":12}')
parse-json('{"a":{"b":12}}}')
parse-json('["abc]')
parse-json('{"abc":12e0}')
parse-json('{"abc":-1.2e0}')
parse-json('"abcd"')
parse-json('["abcd"]')
parse-json('{"abc":false}')
parse-json('{"abc":null}')
parse-json('{"abc":true}')
parse-json('    {   "abc"   :   true    ,             "xyz"   :   false                }   ')
parse-json(' { "abc" : true , "xyz" : false } ')
parse-json('{"abc":true,"xyz":false}')
parse-json('{"'||codepoints-to-string((10, 37))||'":"x", "yyy":"y"}')
parse-json("[false]")
parse-json('[false')
parse-json('false')
parse-json('[falsehood]')
parse-json('["\n"]')
parse-json("[null]")
parse-json('null')
parse-json('["\r"]')
parse-json('["\s"]')
parse-json("[true]")
parse-json('true')
parse-json('["\u123u"]')
parse-json('["\u2"]')
parse-json('["\uD834\udD1E"]')
parse-json("['wrong']")
parse-json('{"x":[12,3], "y":[14,9]}')
parse-json('[{"x":12,"y":5}, {"x":13,"y":6}]')
parse-json('{"x":1, "y":[3,4,5]}')
parse-json('["\x20"]')
parse-json('[{x:23}]')
parse-json('{"x":"\\", "y":"\u0025"}')
<people id=""/>/(some $id in @id satisfies true())
<p>FA&#18446744073709551862;IL</p>
<p>FA&#4294967542;IL</p>
<p>FA&#xFF000000F6;IL</p>
<p>FA&#xFFFFFFFF000000F6;IL</p>
p:f:lname()
<?pi ?>
<?pi ?>?>
<?pi content?>
<?pi <?&--&lt;&#x20;><![CDATA[x]]> ?>
<pi>{string-to-codepoints(<?pi x ?>)}</pi>
<pi>{string-to-codepoints(<?pi x?>)}</pi>
pod_pod
position()
position(1)
preceding-or-ancestor::*
preceeding::node()
prefix:
<prefix: foo/>
<prefix:foo
prefix-from-QName()
prefix-from-QName(1, 2)
prefix-from-QName( QName("example.com/", "pre:lname")) eq "pre"
((//price/text()) , (//price/text())) except (//price/text())
/processing-instruction()
processing-instruction(*)
processing-instruction(1)
processing-instruction {123} {'text'}
processing-instruction {1,2} {'text'}
processing-instruction {//a} {'text'}
/processing-instruction() | /bib/book[2]/title
(/processing-instruction() except /bib/book[2]/title)/name()
/processing-instruction() except /processing-instruction()
(/processing-instruction() except /processing-instruction(PI1))/name()
/processing-instruction() intersect /bib/book[2]/title
(/processing-instruction() intersect /processing-instruction())/name()
processing-instruction "name" {"content"}
processing-instruction('ncname')
processing-instruction {//*:NCName[1]} {'text'}
processing-instruction {'one', 'two'} {'text'}
processing-instruction pi {''}
processing-instruction pi {'?>'}
processing-instruction pi {()}
processing-instruction pi {., .}
processing-instruction pi {1,'',2}
processing-instruction pi {1,<a/>,2}
/processing-instruction(PI1) | /bib/book[3]/title
(/processing-instruction(PI1) except /bib/book)/name()
/processing-instruction(PI1) intersect /bib/book
(/processing-instruction(PI1) intersect /processing-instruction())/name()
processing-instruction pi {1,'string',3.14,xs:float('1.2345e-2'),xs:dateTime('2002-04-02T12:00:00-01:00')}
/processing-instruction(PI1) union /bib/book[3]/title
processing-instruction(``[pi-action]``)
processing-instruction {'pi'[current-date() lt xs:date('1900-01-01')]} {'text'}
processing-instruction {('pi'[current-date() lt xs:date('1900-01-01')], xs:anyURI('pi'))} {'text'}
processing-instruction {('pi'[current-date() lt xs:date('1900-01-01')], xs:duration('P1D'))} {'text'}
processing-instruction pi {<elem>123</elem>, (<elem attr='456'/>)/@attr, (<elem>789</elem>)/text()}
processing-instruction pi {/root}
processing-instruction {'p i'} {'text'}
processing-instruction {'pi', ()} {'text'}
processing-instruction {'pi'} {'text'}
processing-instruction {(), 'pi'} {'text'}
processing-instruction pi {'?>text'}
processing-instruction pi {'text'}
processing-instruction pi {'text?>text'}
processing-instruction {//*:QName} {'text'}
processing-instruction target { '?>' }
processing-instruction {()} {'text'}
processing-instruction {"thename"} {"asdas?>"}
/processing-instruction() union /bib/book[2]/title
processing-instruction {"xml"} {"content"}
processing-instruction {'xml'} {'pi'}
processing-instruction xml {'pi'}
processing-instruction {'XmL'} {'pi'}
processing-instruction XmL {'pi'}
processing-instruction {xs:dateTime("1999-05-31T13:20:00")} {'text'}
processing-instruction {xs:untypedAtomic('one'), xs:untypedAtomic('two')} {'text'}
processing-instruction {xs:untypedAtomic('p i')} {'text'}
processing-instruction {xs:untypedAtomic('pi')} {'text'}
[//product,( "a", "b", "c"),"d"]
(: Purpoose: For each person, list the number of items currently on sale           whose price does not exceed 0.02% of the person's income. :)           <XMark-result-Q11> {              let $auction := (/) return              for $p in $auction/site/people/person              let $l := for $i in $auction/site/open_auctions/open_auction/initial              where $p/profile/@income > 5000 * exactly-one($i/text())              return $i return <items name="{$p/name/text()}">{count($l)}</items> } </XMark-result-Q11>
(: Purpose: For each richer-than-average person, list the           number of items currently on sale whose price does not exceed 0.02% of the person's income. :)           <XMark-result-Q12> {              let $auction := (/) return              for $p in $auction/site/people/person              let $l := for $i in $auction/site/open_auctions/open_auction/initial              where $p/profile/@income > 5000.0 * exactly-one($i/text())              return $i where $p/profile/@income > 50000.0              return <items person="{$p/profile/@income}">{count($l)}</items> } </XMark-result-Q12>
(: Purpose: Give an alphabetically ordered list of all items along with their location. :)           <XMark-result-Q19> {              let $auction := (/) return              for $b in $auction/site/regions//item              let $k := $b/name/text() stable order by zero-or-one($b/location) ascending empty greatest              return <item name="{$k}">{$b/location/text()}</item> } </XMark-result-Q19>
(: Purpose: List the names of items registered in Australia along with their descriptions. :)           <XMark-result-Q13> {              let $auction := (/) return              for $i in $auction/site/regions/australia/item              return <item name="{$i/name/text()}">{$i/description}</item> } </XMark-result-Q13>
(: Purpose: List the names of persons and the names of the items           they bought in Europe(joins person, closed auction, item). :)           <XMark-result-Q9> {              let $auction := (/)              return let $ca := $auction/site/closed_auctions/closed_auction              return let $ei := $auction/site/regions/europe/item              for $p in $auction/site/people/person              let $a := for $t in $ca where $p/@id = $t/buyer/@person              return let $n := for $t2 in $ei where $t/itemref/@item = $t2/@id              return $t2 return <item>{$n/name/text()}</item>              return <person name="{$p/name/text()}">{$a}</person> } </XMark-result-Q9>
(: Purpose: List the names of persons and the number of items they bought. (joins person, closed\_auction). :)           <XMark-result-Q8> { let $auction := (/) return           for $p in $auction/site/people/person           let $a := for $t in $auction/site/closed_auctions/closed_auction           where $t/buyer/@person = $p/@id return $t           return <item person="{$p/name/text()}">{count($a)}</item> } </XMark-result-Q8>
(: Purpose: List the reserves of those open auctions where a certain person issued a bid before another person. :)          <XMark-result-Q4> {              let $auction := (/) return              for $b in $auction/site/open_auctions/open_auction              where some $pr1 in $b/bidder/personref[@person = "person20"], $pr2 in $b/bidder/personref[@person = "person51"] satisfies $pr1 << $pr2              return <history>{$b/reserve/text()}</history> }          </XMark-result-Q4>
(: Purpose: Return the IDs of all open auctions whose current increase is at least twice as high as the initial increase. :)          <XMark-result-Q3> {              let $auction := (/)              return for $b in $auction/site/open_auctions/open_auction              where zero-or-one($b/bidder[1]/increase/text()) * 2.0 <= $b/bidder[last()]/increase/text()                  return <increase first="{$b/bidder[1]/increase/text()}" last="{$b/bidder[last()]/increase/text()}"/> }          </XMark-result-Q3>
(: Purpose: Return the IDs of those auctions that have one or more keywords in emphasis. (cf. Q15) :)           <XMark-result-Q16> {              let $auction := (/) return              for $a in $auction/site/closed_auctions/closed_auction              where not( empty( $a/annotation/description/parlist/listitem/parlist/listitem/text/emph/ keyword/ text() ) )              return <person id="{$a/seller/@person}"/> } </XMark-result-Q16>
(: Purpose: Return the names of all items whose description contains the word `gold'. :)           <XMark-result-Q14> {              let $auction := (/) return              for $i in $auction/site//item              where contains(string(exactly-one($i/description)), "gold")              return $i/name/text() } </XMark-result-Q14>
/Q{%gg}SomeElement
/Q{  http://www.example.com/AuctionWatch}AuctionWatchList/          Q{   http://www.example.com/AuctionWatch}Auction[2]/          @Q{  http://www.example.com/auctioneers          #yabadoo}ID
Q{http://www.w3.org/2001/XMLSchema}anyURI#1('http://www.example.org/')
Q{http://www.w3.org/2001/XMLSchema}base64Binary#1('D74D35D35D35')
Q{http://www.w3.org/2001/XMLSchema}boolean#1('1')
Q{http://www.w3.org/2001/XMLSchema}byte#1('1')
Q{http://www.w3.org/2001/XMLSchema}date#1('1970-01-02Z')
Q{http://www.w3.org/2001/XMLSchema}dateTime#1('1970-01-02T04:05:06Z')
Q{http://www.w3.org/2001/XMLSchema}dayTimeDuration#1('PT15H')
Q{http://www.w3.org/2001/XMLSchema}decimal#1('1')
Q{http://www.w3.org/2001/XMLSchema}double#1('1')
Q{http://www.w3.org/2001/XMLSchema}duration#1('P5Y2M10DT15H')
Q{http://www.w3.org/2001/XMLSchema}ENTITIES#1('ENTITY1 ENTITY2 ENTITY3')
Q{http://www.w3.org/2001/XMLSchema}ENTITY#1('ENTITY')
Q{http://www.w3.org/2001/XMLSchema}float#1('1')
Q{http://www.w3.org/2001/XMLSchema}gDay#1('---01Z')
Q{http://www.w3.org/2001/XMLSchema}gMonth#1('--11Z')
Q{http://www.w3.org/2001/XMLSchema}gMonthDay#1('--11-01Z')
Q{http://www.w3.org/2001/XMLSchema}gYear#1('2012Z')
Q{http://www.w3.org/2001/XMLSchema}gYearMonth#1('2001-10Z')
Q{http://www.w3.org/2001/XMLSchema}hexBinary#1('0fb7')
Q{http://www.w3.org/2001/XMLSchema}ID#1('ID')
Q{http://www.w3.org/2001/XMLSchema}IDREF#1('IDREF')
Q{http://www.w3.org/2001/XMLSchema}IDREFS#1('ID1 ID2 ID3')
Q{http://www.w3.org/2001/XMLSchema}int#1('1')
Q{http://www.w3.org/2001/XMLSchema}integer#1('1')
Q{http://www.w3.org/2001/XMLSchema}language#1('en')
Q{http://www.w3.org/2001/XMLSchema}long#1('1')
Q{http://www.w3.org/2001/XMLSchema}Name#1('Name')
Q{http://www.w3.org/2001/XMLSchema}NCName#1('NCName')
Q{http://www.w3.org/2001/XMLSchema}negativeInteger#1('-1')
Q{http://www.w3.org/2001/XMLSchema}NMTOKEN#1('NMTOKEN')
Q{http://www.w3.org/2001/XMLSchema}NMTOKENS#1('NMTOKEN1 NMTOKEN2 NMTOKEN3')
Q{http://www.w3.org/2001/XMLSchema}nonNegativeInteger#1('1')
Q{http://www.w3.org/2001/XMLSchema}nonPositiveInteger#1('-1')
Q{http://www.w3.org/2001/XMLSchema}normalizedString#1('normalized string')
Q{http://www.w3.org/2001/XMLSchema}positiveInteger#1('1')
Q{http://www.w3.org/2001/XMLSchema}QName#1('fn:QName')
Q{http://www.w3.org/2001/XMLSchema}short#1('1')
Q{http://www.w3.org/2001/XMLSchema}string#1('string')
Q{http://www.w3.org/2001/XMLSchema}time#1('01:02:03Z')
Q{http://www.w3.org/2001/XMLSchema}token#1('token')
Q{http://www.w3.org/2001/XMLSchema}unsignedByte#1('1')
Q{http://www.w3.org/2001/XMLSchema}unsignedInt#1('1')
Q{http://www.w3.org/2001/XMLSchema}unsignedLong#1('1')
Q{http://www.w3.org/2001/XMLSchema}unsignedShort#1('1')
Q{http://www.w3.org/2001/XMLSchema}untypedAtomic#1('string')
Q{http://www.w3.org/2001/XMLSchema}yearMonthDuration#1('P1Y')
Q{http://www.w3.org/2005/xpath-functions}abs#1(-1)
Q{http://www.w3.org/2005/xpath-functions}avg#1((1, 3))
Q{http://www.w3.org/2005/xpath-functions}boolean#1("string")
Q{http://www.w3.org/2005/xpath-functions}ceiling#1(0.9)
Q{http://www.w3.org/2005/xpath-functions}codepoint-equal#2('string', 'string')
Q{http://www.w3.org/2005/xpath-functions}codepoints-to-string#1((65, 66))
Q{http://www.w3.org/2005/xpath-functions}compare#2('string', 'string')
Q{http://www.w3.org/2005/xpath-functions}concat#3('a', 'bc', 'def')
Q{http://www.w3.org/2005/xpath-functions}contains#2('string', 'rin')
Q{http://www.w3.org/2005/xpath-functions}count#1((1, true()))
Q{http://www.w3.org/2005/xpath-functions}current-date#0()
Q{http://www.w3.org/2005/xpath-functions}current-dateTime#0()
Q{http://www.w3.org/2005/xpath-functions}current-time#0()
Q{http://www.w3.org/2005/xpath-functions}data#1(/root/child[1])
Q{http://www.w3.org/2005/xpath-functions}dateTime#2(xs:date('2012-01-01Z'), xs:time('00:00:00Z'))
Q{http://www.w3.org/2005/xpath-functions}day-from-date#1(xs:date('2012-02-01Z'))
Q{http://www.w3.org/2005/xpath-functions}day-from-dateTime#1(xs:dateTime('2012-04-03T02:01:00Z'))
Q{http://www.w3.org/2005/xpath-functions}days-from-duration#1(xs:dayTimeDuration("P3DT10H"))
Q{http://www.w3.org/2005/xpath-functions}deep-equal#2((1, true()), (1, true()))
Q{http://www.w3.org/2005/xpath-functions}empty#1((1, true()))
Q{http://www.w3.org/2005/xpath-functions}encode-for-uri#1(' ')
Q{http://www.w3.org/2005/xpath-functions}ends-with#2('string', 'ing')
Q{http://www.w3.org/2005/xpath-functions}exactly-one#1(1)
Q{http://www.w3.org/2005/xpath-functions}exists#1((1, true()))
Q{http://www.w3.org/2005/xpath-functions}false#0()
Q{http://www.w3.org/2005/xpath-functions}filter#2(1 to 10, function($a) {$a mod 2 = 0})
Q{http://www.w3.org/2005/xpath-functions}floor#1(1.1)
Q{http://www.w3.org/2005/xpath-functions}fold-left#3(1 to 5, "", fn:concat(?, ".", ?))
Q{http://www.w3.org/2005/xpath-functions}fold-right#3(1 to 5, "", fn:concat(?, ".", ?))
Q{http://www.w3.org/2005/xpath-functions}for-each#2(("23", "29"), xs:int#1)
Q{http://www.w3.org/2005/xpath-functions}function-arity#1(fn:abs#1)
Q{http://www.w3.org/2005/xpath-functions}function-lookup#2(fn:QName('http://www.example.org', 'foo:bar'), 1)
Q{http://www.w3.org/2005/xpath-functions}function-name#1(fn:abs#1)
/Q{http://www.w3.org/2005/xpath-functions}has-children#0()
Q{http://www.w3.org/2005/xpath-functions}has-children#1(/)
Q{http://www.w3.org/2005/xpath-functions}head#1((1, true()))
Q{http://www.w3.org/2005/xpath-functions}hours-from-dateTime#1(xs:dateTime('2012-04-03T02:01:00Z'))
Q{http://www.w3.org/2005/xpath-functions}hours-from-duration#1(xs:dayTimeDuration("P3DT10H"))
Q{http://www.w3.org/2005/xpath-functions}hours-from-time#1(xs:time('02:01:00Z'))
/Q{http://www.w3.org/2005/xpath-functions}id#1(('id1', 'id2'))
Q{http://www.w3.org/2005/xpath-functions}id#2(('id1', 'id2'), /)
/Q{http://www.w3.org/2005/xpath-functions}idref#1(('id1', 'id2'))
Q{http://www.w3.org/2005/xpath-functions}idref#2(('id1', 'id2'), /)
Q{http://www.w3.org/2005/xpath-functions}implicit-timezone#0()
Q{http://www.w3.org/2005/xpath-functions}innermost#1(())
Q{http://www.w3.org/2005/xpath-functions}insert-before#3((1, 2, 3), 2, ('a', 'b', 'c'))
Q{http://www.w3.org/2005/xpath-functions}iri-to-uri#1('http://www.example.com/')
Q{http://www.w3.org/2005/xpath-functions}local-name#1(/root)
Q{http://www.w3.org/2005/xpath-functions}local-name-from-QName#1(fn:QName('http://www.example.org', 'foo:bar'))
Q{http://www.w3.org/2005/xpath-functions}lower-case#1('STRING')
Q{http://www.w3.org/2005/xpath-functions}matches#2('string', 'string')
Q{http://www.w3.org/2005/xpath-functions/math}acos#1(1e0)
Q{http://www.w3.org/2005/xpath-functions/math}asin#1(1e0)
Q{http://www.w3.org/2005/xpath-functions/math}atan#1(1e0)
Q{http://www.w3.org/2005/xpath-functions/math}atan2#2(1e0, 1e0)
Q{http://www.w3.org/2005/xpath-functions/math}cos#1(1e0)
Q{http://www.w3.org/2005/xpath-functions/math}exp10#1(1e0)
Q{http://www.w3.org/2005/xpath-functions/math}log10#1(1e0)
Q{http://www.w3.org/2005/xpath-functions/math}log#1(1e0)
Q{            http://www.w3.org/2005/xpath-functions/math          }pi()
Q{  http://www.w3.org/2005/xpath-functions/math}pi()
Q{{http://www.w3.org/2005/xpath-functions/math}pi()
Q{http://www.w3.org/2005/xpath-functions/math   }pi()
Q{http://www.w3.org/2005/xpath-functions/math pi()
Q{http://www.w3.org/2005/xpath-functions/math}}pi()
Q{http://www.w3.org/2005/xpath-functions/math}pi()
Q{http://www.w3.org/2005/ xpath-functions/math}pi()
Q{http://www.w3.org/2005/xpath-functions/math}pi#0()
Q{http://www.w3.org/2005/xpath-functions/math}pow#2(1e0, 1)
Q{http://www.w3.org/2005/xpath-functions/math}sin#1(1e0)
Q{http://www.w3.org/2005/xpath-functions/math}sqrt#1(1e0)
Q{http://www.w3.org/2005/xpath-functions/math}tan#1(1e0)
Q{http://www.w3.org/2005/xpath-functions}max#1((1, 3))
Q{http://www.w3.org/2005/xpath-functions}min#1((1, 3))
Q{http://www.w3.org/2005/xpath-functions}minutes-from-dateTime#1(xs:dateTime('2012-04-03T02:01:00Z'))
Q{http://www.w3.org/2005/xpath-functions}minutes-from-duration#1(xs:dayTimeDuration("P3DT10H"))
Q{http://www.w3.org/2005/xpath-functions}minutes-from-time#1(xs:time('02:01:00Z'))
Q{http://www.w3.org/2005/xpath-functions}month-from-date#1(xs:date('2012-02-01Z'))
Q{http://www.w3.org/2005/xpath-functions}month-from-dateTime#1(xs:dateTime('2012-04-03T02:01:00Z'))
Q{http://www.w3.org/2005/xpath-functions}months-from-duration#1(xs:yearMonthDuration("P20Y15M"))
Q{http://www.w3.org/2005/xpath-functions}name#1(/root)
Q{http://www.w3.org/2005/xpath-functions}namespace-uri#1(/root/*[2])
Q{http://www.w3.org/2005/xpath-functions}namespace-uri-from-QName#1(fn:QName('http://www.example.org', 'foo:bar'))
Q{http://www.w3.org/2005/xpath-functions}node-name#1(/root)
Q{http://www.w3.org/2005/xpath-functions}normalize-space#1(' string ')
Q{http://www.w3.org/2005/xpath-functions}not#1("string")
Q{http://www.w3.org/2005/xpath-functions}number#1('1')
Q{http://www.w3.org/2005/xpath-functions}one-or-more#1(1)
Q{http://www.w3.org/2005/xpath-functions}outermost#1(())
/Q{http://www.w3.org/2005/xpath-functions}path#0()
Q{http://www.w3.org/2005/xpath-functions}path#1(/)
Q{http://www.w3.org/2005/xpath-functions}prefix-from-QName#1(fn:QName('http://www.example.org', 'foo:bar'))
Q{http://www.w3.org/2005/xpath-functions}QName#2('http://www.example.org/', 'ns:local')
Q{http://www.w3.org/2005/xpath-functions}remove#2(('a', 'b', 'c'), 2)
Q{http://www.w3.org/2005/xpath-functions}reverse#1(1 to 3)
Q{http://www.w3.org/2005/xpath-functions}root#1(())
Q{http://www.w3.org/2005/xpath-functions}round#1(1.1)
Q{http://www.w3.org/2005/xpath-functions}round#2(1.1, 0)
Q{http://www.w3.org/2005/xpath-functions}round-half-to-even#1(1.1)
Q{http://www.w3.org/2005/xpath-functions}round-half-to-even#2(1.1, 0)
Q{http://www.w3.org/2005/xpath-functions}seconds-from-dateTime#1(xs:dateTime('2012-04-03T02:01:00Z'))
Q{http://www.w3.org/2005/xpath-functions}seconds-from-duration#1(xs:dayTimeDuration("P3DT10H12.5S"))
Q{http://www.w3.org/2005/xpath-functions}seconds-from-time#1(xs:time('02:01:00Z'))
Q{http://www.w3.org/2005/xpath-functions}starts-with#2('string', 'str')
Q{http://www.w3.org/2005/xpath-functions}string#1(1)
Q{http://www.w3.org/2005/xpath-functions}string-join#1(('abc', 'def'))
Q{http://www.w3.org/2005/xpath-functions}string-join#2(('abc', 'def'), '-')
Q{http://www.w3.org/2005/xpath-functions}string-length#1('string')
Q{http://www.w3.org/2005/xpath-functions}string-to-codepoints#1('A')
Q{http://www.w3.org/2005/xpath-functions}subsequence#2((1, true()), 2e0)
Q{http://www.w3.org/2005/xpath-functions}subsequence#3((1, true()), 1e0, 1e0)
Q{http://www.w3.org/2005/xpath-functions}substring#2('string', 2e0)
Q{http://www.w3.org/2005/xpath-functions}substring#3('string', 1e0, 1e0)
Q{http://www.w3.org/2005/xpath-functions}substring-after#2('string', 'str')
Q{http://www.w3.org/2005/xpath-functions}substring-before#2('string', 'ing')
Q{http://www.w3.org/2005/xpath-functions}sum#1((1, 2))
Q{http://www.w3.org/2005/xpath-functions}sum#2((1, 2), 0)
() => (Q{http://www.w3.org/2005/xpath-functions}sum#2(?, 'foo'))()
Q{http://www.w3.org/2005/xpath-functions}tail#1((1, true()))
Q{http://www.w3.org/2005/xpath-functions}timezone-from-date#1(xs:date('2012-01-01Z'))
Q{http://www.w3.org/2005/xpath-functions}timezone-from-dateTime#1(xs:dateTime('2012-01-01T00:00:00Z'))
Q{http://www.w3.org/2005/xpath-functions}timezone-from-time#1(xs:time('02:01:00Z'))
Q{http://www.w3.org/2005/xpath-functions}tokenize#1('a b c ')
Q{http://www.w3.org/2005/xpath-functions}tokenize#2('string', 'i')
Q{http://www.w3.org/2005/xpath-functions}trace#1(1)
Q{http://www.w3.org/2005/xpath-functions}trace#2(1, 'label')
Q{http://www.w3.org/2005/xpath-functions}translate#3('string', 'i', 'o')
Q{http://www.w3.org/2005/xpath-functions}true#0()
Q{http://www.w3.org/2005/xpath-functions}unordered#1(1)
Q{http://www.w3.org/2005/xpath-functions}upper-case#1('string')
Q{http://www.w3.org/2005/xpath-functions}year-from-date#1(xs:date('2012-02-01Z'))
Q{http://www.w3.org/2005/xpath-functions}year-from-dateTime#1(xs:dateTime('2012-04-03T02:01:00Z'))
Q{http://www.w3.org/2005/xpath-functions}years-from-duration#1(xs:yearMonthDuration("P20Y15M"))
Q{http://www.w3.org/2005/xpath-functions}zero-or-one#1(1)
QName()
QName("", "2localName")
QName("", "error:ncname")
QName((), "error:ncname")
QName("example.com/", "p:ncname") eq QName("example.com/", "pdifferent:ncname")
QName("example.com/", "p:ncname") eq QName("example.com/", "p:ncname")
QName("example.com/", "p:ncname") eq xs:anyURI("org")
QName("example.com/", "p:ncname") ge QName("example.com/", "p:ncname")
QName("example.com/", "p:ncname") gt QName("example.com/", "p:ncname")
QName("example.com/", "p:ncname") le QName("example.com/", "p:ncname")
QName("example.com/", "p:ncname") lt 1
QName("example.com/", "p:ncname") lt QName("example.com/", "p:ncname")
QName("example.com/", "p:ncname") ne QName("example.com/Nope", "p:ncname")
QName("example.com/", "p:ncname") ne QName("example.com/", "p:ncnameNope")
(QName('http://datypic.com/prod', 'pre:product'))
(QName('http://datypic.com/prod','product'))
(QName('http://datypic.com/prod','product'), QName('http://datypic.com/prod', 'pre:product'), QName('', 'product'))
(QName("http://example.com/ANamespace", "ncname"), QName("http://example.com/ANamespace", "ncname2"), QName("http://example.com/ANamespace", "ncname3")) castable as xs:QName
(QName("http://example.com/ANamespace", "ncname"), QName("http://example.com/ANamespace", "ncname2"), QName("http://example.com/ANamespace", "ncname3")) castable as xs:QName?
QName("http://www.example.com/")
QName("http://www.example.com/", "1asd:error")
QName("http://www.example.com/", "ncname", "error")
QName("http://www.w3.org/", "1")
QName("http://www.w3.org/", "1prefix:localName")
QName("http://www.w3.org/2005/xpath-functions", "prefix:local") eq xs:QName("fn:local")
QName("http://www.w3.org/", "prefix:2localName")
QName("", "lname") castable as xs:QName
QName("", "local") eq xs:QName("local")
QName((), "local") eq xs:QName("local")
QName("my:qName", "http://example.com/MyErrorNS")
QName("", "prefix:localName")
(QName('', 'product'))
/Q{###}SomeElement
"&quot;"
Q{&#x7D;http://www.w3.org/2005/xpath-functions/math}pi()
<r> <a> <b> <c/> </b> </a> </r>/a/b/c/(ancestor::*[1], ancestor::*[2], ancestor::*[last()], ancestor::*[10])
<r> <a> <b> <c/> </b> </a> </r>/a/b/c/(ancestor-or-self::*[1], ancestor-or-self::*[2], ancestor-or-self::*[last()], ancestor-or-self::*[10])
random-number-generator()?number
("red", "blue", "green")!position()
("red", "blue", "green")!(position() = last())
("red", "blue", "green")!string-length()
("red", "blue", "green") ! string-length() ! (.+1)
remove()
remove((1, 2, 3, current-time()), 4)[last()]
remove((1, 2, 3, current-time()), 4)[last() - 1]
remove((1, 2, 3, current-time()), 9)[last() - 1]
remove((1, 2, "three"), 3) instance of xs:integer+
remove(1, 2, "wrong param")
remove(1 to 10, "1")
remove(1 to 10, 1.0)
remove(1 to 10, 1.0e0)
remove(1 to 10,4)
remove(1 to 10,exactly-one((1 to 10)[. div 2 = 2]))
remove((1 to 10)[. mod 2 = 0],4)
remove(((1 to 10)[. mod 2 = 0],"blah",(1 to 10)[. mod 2 = 0]),4)
(remove((1, "two"), 2) + 1) eq 2
(remove((1, "two"), 2) + xs:untypedAtomic("1")) eq 2
remove((1, "two", 3), 2) instance of xs:integer+
remove((3.1, "four"), 1)
(remove((5, 1e0), 2) + 1) eq 6
remove((5, 1e0), 2) eq 5
remove((6, "a string"), 1) = 6
remove((6, "a string"), 2) = xs:untypedAtomic("6")
(remove( ('a', 'b', 'c'), 0))
(remove( ('a', 'b', 'c'), 10))
(remove( ('a', 'b', 'c'), 2) )
(remove( ('a', 'b', 'c'), 2) , remove( ('a', 'b', 'c'), 10), remove( ('a', 'b', 'c'), 0))
remove(("one", 2, 3), 1) instance of xs:integer+
(remove((xs:untypedAtomic("1"), "two"), 2) + 1) eq 2
(remove((xs:untypedAtomic("6"), "a string"), 2)) = 6
<r> { //(employee[location = "Denver"] except //employee[last()])/./location } </r>
<r> { //(employee[location = "Denver"] union //employee[last()])/./location } </r>
<result> { <a><b/></a>/*/following::*[2] } </result>
<result> {/bib/book/editor/affiliation/text()} </result>
<result> { (((//chapter)[2]//section)[3]//para)[2] } </result>
<result> { <e> <a>1</a> <b>2</b> </e>/(b, a)/. } </result>
<result> { for $c in //chapter where empty($c/intro) return $c/section/intro/para } </result>
<result> {              for $highbid in $bids//bid_tuple,                  $user in $users//user_tuple              where $user/userid = $highbid/userid and $highbid/bid = max($bids//bid_tuple[itemno=$highbid/itemno]/bid)              order by exactly-one($highbid/itemno)              return <high_bid> { $highbid/itemno } { $highbid/bid }                       <bidder>{ $user/name/text() }</bidder>                     </high_bid>          } </result>
<result> { for $id in //xref/@xrefid return //topic[@topicid = $id] } </result>
<result> {              for $i in $items//item_tuple              let $b := $bids//bid_tuple[itemno = $i/itemno]              where contains(exactly-one($i/description), "Bicycle")              order by $i/itemno              return <item_tuple> { $i/itemno } { $i/description } <high_bid>{ max($b/bid) }</high_bid> </item_tuple> }          </result>
<result> {              for $i in $items//item_tuple              where $i/start_date <= xs:date("1999-01-31")                  and $i/end_date >= xs:date("1999-01-31")                  and contains(exactly-one($i/description), "Bicycle")              order by $i/itemno              return <item_tuple> { $i/itemno } { $i/description } </item_tuple> }          </result>
<result> {              for $i in $items//item_tuple              where empty ($bids//bid_tuple[itemno = $i/itemno])              return <no_bid_item> { $i/itemno } { $i/description } </no_bid_item>          } </result>
<result> { for $i in //intro/para[1] return <first_letter>{ substring(string($i), 1, 1) }</first_letter> } </result>
<result> {              for $item in $items//item_tuple              let $b := $bids//bid_tuple[itemno = $item/itemno]              let $z := max($b/bid)              where exactly-one($item/reserve_price) * 2 < $z              return <successful_item> { $item/itemno } { $item/description } { $item/reserve_price }                      <high_bid>{$z }</high_bid>                     </successful_item>          } </result>
<result> { for $s in //section/@shorttitle return <stitle>{ $s }</stitle> } </result>
<result> {              for $u in $users//user_tuple              for $i in $items//item_tuple              where $u/rating > "C" and $i/reserve_price > 1000 and $i/offered_by = $u/userid              return <warning> { $u/name } { $u/rating } { $i/description } { $i/reserve_price } </warning> }          </result>
<result> {              for $u in $users//user_tuple              let $b := $bids//bid_tuple[userid=$u/userid and bid>=100]              where count($b) > 1              return <big_spender>{ $u/name/text() }</big_spender>          } </result>
<result> {              for $u in $users//user_tuple              let $b := $bids//bid_tuple[userid = $u/userid]              order by exactly-one($u/userid)              return <user> { $u/userid } { $u/name } {                  if (empty($b))                  then <status>inactive</status>                  else <status>active</status> } </user>          } </result>
<result> { //intro/para } </result>
<result> { let $x := //xref[@xrefid = "top4"], $t := //title[. << exactly-one($x)] return $t[last()] } </result>
<result> { (//node())[last()]/preceding::node(), empty((//node())[last()]/preceding::node()) } </result>
<result> { (//node())[last()]/preceding::node() } </result>
<result> {//overtime/node() and fn:false()} </result>
<result> {//overtime/node() and fn:true()} </result>
<result> {//overtime/node() or fn:false()} </result>
<result> {//overtime/node() or fn:true()} </result>
<result> { //para[@security = "c"] } </result>
<result> { //report//para } </result>
<result> { //section[.//title[contains(., "is SGML")]] } </result>
<result> { //section[.//title/text()[contains(., "is SGML")]] } </result>
<results> {         for $b in /bib/book, $t in $b/title, $a in $b/author         return <result> { $t } { $a } </result> }         </results>
<results> {         for $b in /bib/book         return <result> { $b/title } { $b/author } </result> }         </results>
<results> {         for $t in //(chapter | section)/title         where contains(exactly-one($t/text()), "XML")         return $t }         </results>
<results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by string($x) ascending return string($x) } </results>
<results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by string($x) return string($x) } </results>
<results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by (xs:decimal($x) * -1) descending return (xs:decimal($x) * -1) } </results>
<results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by (xs:decimal($x) * -1) return (xs:decimal($x) * -1) } </results>
<results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by xs:decimal($x) ascending return xs:decimal($x) } </results>
<results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by xs:decimal($x) ascending return xs:decimal($x) } </results>
<results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by xs:decimal($x) descending return xs:decimal($x) } </results>
<results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by xs:decimal($x) descending return xs:decimal($x) } </results>
<results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by xs:decimal($x) return xs:decimal($x) } </results>
<results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by xs:decimal($x) return xs:decimal($x) } </results>
<results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by (xs:decimal($x) + xs:decimal($x)) descending return xs:decimal($x) + xs:decimal($x) } </results>
<results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by (xs:decimal($x) + xs:decimal($x)) descending return xs:decimal($x) + xs:decimal($x) } </results>
<results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by (xs:decimal($x) + xs:decimal($x)) return xs:decimal($x) + xs:decimal($x) } </results>
<results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by (xs:decimal($x) + xs:decimal($x)) return xs:decimal($x) + xs:decimal($x) } </results>
<results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by xs:integer($x) descending return xs:integer($x) } </results>
<results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by xs:integer($x) descending return xs:integer($x) } </results>
<results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by xs:integer($x) return xs:integer($x) } </results>
<results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by xs:integer($x) return xs:integer($x) } </results>
<results>{ for $x in (<a>0.000000000000000001</a>,<a>0.00000000000000001</a>,<a>0.0000000000000001</a>,<a>0.000000000000001</a>,<a>0.00000000000001</a>,<a>0.0000000000001</a>,<a>0.000000000001</a>,<a>0.00000000001</a>,<a>0.0000000001</a>,<a>0.000000001</a>,<a>0.00000001</a>,<a>0.0000001</a>,<a>0.000001</a>,<a>0.00001</a>,<a>0.0001</a>,<a>0.001</a>,<a>0.01</a>,<a>0.1</a>,<a>0.0</a>) order by $x is $x ascending return $x is $x}</results>
<results>{ for $x in (<a>0.000000000000000001</a>,<a>0.00000000000000001</a>,<a>0.0000000000000001</a>,<a>0.000000000000001</a>,<a>0.00000000000001</a>,<a>0.0000000000001</a>,<a>0.000000000001</a>,<a>0.00000000001</a>,<a>0.0000000001</a>,<a>0.000000001</a>,<a>0.00000001</a>,<a>0.0000001</a>,<a>0.000001</a>,<a>0.00001</a>,<a>0.0001</a>,<a>0.001</a>,<a>0.01</a>,<a>0.1</a>,<a>0.0</a>) order by $x is $x descending return $x is $x }</results>
<results> { for $x in (<a>A String</a>,<a>B String</a>,<a>C String</a>,<a>D String</a>,<a>E String</a>,<a>F String</a>,<a>G String</a>,<a>H String</a>,<a>I String</a>, <a>J String</a>,<a>K String</a>,<a>L String</a>,<a>M String</a>,<a>N String</a>,<a>O String</a>,<a>P String</a>,<a>R String</a>,<a>S String</a>,<a>T String</a>, <a>U String</a>,<a>V String</a>,<a>W String</a>,<a>X String</a>,<a>Y String</a>,<a>Z String</a>) order by $x is $x return $x is $x } </results>
<results> { for $x in (<a>A String</a>,<a>B String</a>,<a>C String</a>,<a>D String</a>,<a>E String</a>,<a>F String</a>,<a>G String</a>,<a>H String</a>,<a>I String</a>, <a>J String</a>,<a>K String</a>,<a>L String</a>,<a>M String</a>,<a>N String</a>,<a>O String</a>,<a>P String</a>,<a>R String</a>,<a>S String</a>,<a>T String</a>, <a>U String</a>,<a>V String</a>,<a>W String</a>,<a>X String</a>,<a>Y String</a>,<a>Z String</a>) order by string-length($x) return string-length($x) } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat("another String Before",xs:string($x)) ascending return concat("another String Before",xs:string($x)) } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat("another String Before",xs:string($x)) descending return concat("another String Before",xs:string($x)) } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat("another String Before",xs:string($x)) return concat("another String Before",xs:string($x)) } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"another String After") ascending return concat(xs:string($x),"another String After") } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"another String After") descending return concat(xs:string($x),"another String After") } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"another String After") return concat(xs:string($x),"another String After") } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String",         "I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String",         "U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"()")          ascending return concat(xs:string($x),"()") } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat("",xs:string($x)) ascending return concat("",xs:string($x)) } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"") ascending return concat(xs:string($x),"") } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat("",xs:string($x)) descending return concat("",xs:string($x)) } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"") descending return concat(xs:string($x),"") } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"()") descending return concat(xs:string($x),"()") } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat("",xs:string($x)) return concat("",xs:string($x)) } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"") return concat(xs:string($x),"") } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"()") return concat(xs:string($x),"()") } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),xs:string($x)) ascending return concat(xs:string($x),xs:string($x)) } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),xs:string($x)) return concat(xs:string($x),xs:string($x)) } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by count(xs:string($x)) ascending return count(xs:string($x)) } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by count(xs:string($x)) return count(xs:string($x)) } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by string-length(xs:string($x)) ascending return string-length(xs:string($x)) } </results>
<results> { for $x in("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by string-length(xs:string($x)) ascending return string-length(xs:string($x)) } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String",         "I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String",         "U String","V String","W String","X String","Y String","Z String") order by xs:string($x)          ascending return xs:string($x) } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String",         "I String","J String","K String","L String","M String","N String","O String","P String","R String","S String",         "T String","U String","V String","W String","X String","Y String","Z String") order by xs:string($x)          descending return xs:string($x) } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by xs:string($x) return xs:string($x) } </results>
<results> { for $x in (<orderData>-0.000000000000000001</orderData>,<orderData>-0.00000000000000001</orderData>,<orderData>-0.0000000000000001</orderData>,<orderData>-0.000000000000001</orderData>,<orderData>-0.00000000000001</orderData>,<orderData>-0.0000000000001</orderData>, <orderData>-0.000000000001</orderData>,<orderData>-0.00000000001</orderData>,<orderData>-0.0000000001</orderData>,<orderData>-0.000000001</orderData>, <orderData>-0.00000001</orderData>,<orderData>-0.0000001</orderData>,<orderData>-0.000001</orderData>,<orderData>-0.00001</orderData>,<orderData>-0.0001</orderData>,<orderData>-0.001</orderData>,<orderData>-0.01</orderData>,<orderData>-0.0</orderData>, <orderData>-0.1</orderData>) order by $x is $x return $x is $x } </results>
<results> { for $x in (<orderData>0.000000000000000001</orderData>,<orderData>0.00000000000000001</orderData>,<orderData>0.0000000000000001</orderData>,<orderData>0.000000000000001</orderData>, <orderData>0.00000000000001</orderData>,<orderData>0.0000000000001</orderData>,<orderData>0.000000000001</orderData>,<orderData>0.00000000001</orderData>,<orderData>0.0000000001</orderData>, <orderData>0.000000001</orderData>,<orderData>0.00000001</orderData>,<orderData>0.0000001</orderData>,<orderData>0.000001</orderData>,<orderData>0.00001</orderData>, <orderData>0.0001</orderData>,<orderData>0.001</orderData>,<orderData>0.01</orderData>,<orderData>0.1</orderData>,<orderData>0.0</orderData>) order by $x is $x return $x is $x } </results>
<results> { for $x in (<orderData>-100000000000000000</orderData>,<orderData>-10000000000000000</orderData>,<orderData>-1000000000000000</orderData>,<orderData>-100000000000000</orderData>, <orderData>-10000000000000</orderData>,<orderData>-1000000000000</orderData>,<orderData>-100000000000</orderData>,<orderData>-10000000000</orderData>,<orderData>-1000000000</orderData>, <orderData>-100000000</orderData>,<orderData>-10000000</orderData>,<orderData>-1000000</orderData>,<orderData>-100000</orderData>,<orderData>-10000</orderData>,<orderData>-1000</orderData>, <orderData>-100</orderData>,<orderData>-10</orderData>,<orderData>-1</orderData>,<orderData>-0</orderData>) order by $x is $x return $x is $x } </results>
<results> { for $x in (<orderData>100000000000000000</orderData>,<orderData>10000000000000000</orderData>,<orderData>1000000000000000</orderData>, <orderData>100000000000000</orderData>,<orderData>10000000000000</orderData>,<orderData>1000000000000</orderData>,<orderData>100000000000</orderData>, <orderData>10000000000</orderData>,<orderData>1000000000</orderData>,<orderData>100000000</orderData>,<orderData>10000000</orderData>, <orderData>1000000</orderData>,<orderData>100000</orderData>,<orderData>10000</orderData>,<orderData>1000</orderData>,<orderData>100</orderData>, <orderData>10</orderData>,<orderData>1</orderData>,<orderData>0</orderData>) order by $x is $x return $x is $x } </results>
<result>{ ("test1", "test2") }</result>
<result> {//text() and fn:false()} </result>
<result> {//text() and fn:true()} </result>
<result> {//text() or fn:false()} </result>
<result> {//text() or fn:true()} </result>
<result> {              unordered (                  for $seller in $users//user_tuple,                      $buyer in $users//user_tuple,                      $item in $items//item_tuple,                      $highbid in $bids//bid_tuple                  where $seller/name = "Tom Jones"                    and $seller/userid = $item/offered_by                    and contains(exactly-one($item/description), "Bicycle")                    and $item/itemno = $highbid/itemno                    and $highbid/userid = $buyer/userid                    and $highbid/bid = max( $bids//bid_tuple [itemno = $item/itemno]/bid )                  return <jones_bike> { $item/itemno } { $item/description }                          <high_bid>{ $highbid/bid }</high_bid>                          <high_bidder>{ $buyer/name }</high_bidder>                         </jones_bike> )          } </result>
return 1
(reverse( () ))
reverse()
reverse(1, 2)
(reverse( (1, 2, 3, 4, 5) ))
(reverse( (1, 2, 3, 4, 5) ), reverse( (6, 2, 4) ), reverse( () ))
reverse((1, 2, 3))[last() - 1]
reverse((1, 2, 3))[last() - 2]
reverse((1, 2, 3))[last()] eq 1
reverse((1, 2, current-time(), 3))[last() - 0]
reverse((1, 2, current-time(), 3))[last() - 1]
reverse((1, current-time())[1])
(reverse( (6, 2, 4) ))
reverse((<a> <b> <c/> <d/> </b> <e/> </a> , <f/>))
<r>{<e xml:lang="ene"/>/(ancestor-or-self::*/@xml:lang)[last()]}</r>
<r> { for $i in 1 order by () return () } </r>
<r> { for $i in attribute name {()} order by () return () } </r>
<r> { let $i := <e> <a/> <b/> <c/> </e>/a , $t := $i/following-sibling::b return (($i except ($i, $i)), (($t, $t) except $t)) } </r>
<r> { let $i := <e> <a/> <b/> <c/> </e>/a , $t := $i/following-sibling::b return (($i intersect ($i, $i)), (($t, $t) intersect $t)) } </r>
<r> { let $i := <e> <a/> <b/> </e> let $b := ($i/b, $i/a, $i/b, $i/a) return ()/$b } </r>
<r> { let $i := <e> <a/> <b/> </e> let $b := ($i/b, $i/a, $i/b, $i/a) return $b/. } </r>
<r> { let $i := <e> <a/> <b/> </e> let $b := ($i/b, $i/a, $i/b, $i/a) return <e/>/./$b } </r>
<r> { let $i := <e> <a/> <b/> </e> let $b := ($i/b, $i/a, $i/b, $i/a) return <e/>/$b } </r>
<r> { let $i := <e> <a/> <b/> </e> return () | ($i/b, $i/a, $i/b, $i/a) } </r>
<r> { let $i := <e> <a/> <b/> </e> return ($i/b, $i/a, $i/b, $i/a) | () } </r>
root(2)
Root(2)
/root/*[2]/function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'namespace-uri'), 0)()
/root/*[2]/Q{http://www.w3.org/2005/xpath-functions}namespace-uri#0()
/root/@attribute/fn:has-children()
(/root/boolean[xs:boolean(.) = fn:true()])
<root> <child/> <child/> <child attr="foo" attr2="foo"/> </root>/child[1]/following-sibling::node()
<root> <child/> <child/> <child/> </root>/child[1]/following-sibling::node()
/root/child/function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'data'), 0)()
/root/child/function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'normalize-space'), 0)()
/root/child/function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'number'), 0)()
/root/child/function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'string'), 0)()
/root/child/function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'string-length'), 0)()
/root/child/Q{http://www.w3.org/2005/xpath-functions}data#0()
/root/child/Q{http://www.w3.org/2005/xpath-functions}normalize-space#0()
/root/child/Q{http://www.w3.org/2005/xpath-functions}number#0()
/root/child/Q{http://www.w3.org/2005/xpath-functions}string#0()
/root/child/Q{http://www.w3.org/2005/xpath-functions}string-length#0()
/root/comment()/fn:has-children()
<root> {//Customers} </root>
(/root/date[xs:date(.) = xs:date("2000-01-01+05:00")])
(/root/decimal[(xs:decimal(.) = 12678967.543233)])
(/root/decimal[xs:decimal(.) = 12678967.543233])
<root> {/doc/part/*/text()/..} </root>
(/root/double[xs:double(.) = 1267.43233E12])
/root/empty/fn:has-children()
(/root/float[xs:float(.) = xs:float(1267.43233E12)])
/root/fn:has-children()
/root/function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'local-name'), 0)()
/root/function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'name'), 0)()
/root/function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'node-name'), 0)()
/root/function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'root'), 0)()
(/root/integer[xs:integer(.) = 12678967543233])
/root/node()/fn:has-children()
/root/node()/fn:has-children(.)
/root/non-empty/fn:has-children()
/root/processing-instruction()/fn:has-children()
/root/Q{http://www.w3.org/2005/xpath-functions}local-name#0()
/root/Q{http://www.w3.org/2005/xpath-functions}name#0()
/root/Q{http://www.w3.org/2005/xpath-functions}node-name#0()
/root/Q{http://www.w3.org/2005/xpath-functions}root#0()
<root> {//@*/..} </root>
(/root/string[xs:string(.) = "A String Function"])
/root/text()/fn:has-children()
round()
round(1.1) eq 1
round(1, 2)
round(1) eq 1
round(2.4999) eq 2
round(-2.5) eq -2
(round(5))
(round(5.1))
(round(-5.5))
(round(5.5))
(round(-5.51))
(round(5), round(5.1), round(5.5), round(-5.5), round(-5.51))
round-half-to-even()
round-half-to-even(0.5) eq 0
round-half-to-even(1.000005e0, 2)
round-half-to-even(1.0) eq 1
round-half-to-even(1.1, 3, "wrong param")
round-half-to-even(-123.355, 2)
round-half-to-even(123.355, 2)
round-half-to-even(-123.365, 2)
round-half-to-even(123.365, 2)
round-half-to-even(-123.375, 2)
round-half-to-even(123.375, 2)
round-half-to-even(-123.385, 2)
round-half-to-even(123.385, 2)
round-half-to-even(1.234567, 2)
round-half-to-even(-12350.00, -2)
round-half-to-even(12350.00, -2)
round-half-to-even(-12350, -2)
round-half-to-even(12350, -2)
round-half-to-even(-12350e0, -2)
round-half-to-even(12350e0, -2)
round-half-to-even(-12450.00, -2)
round-half-to-even(12450.00, -2)
round-half-to-even(-12450, -2)
round-half-to-even(12450, -2)
round-half-to-even(-12450e0, -2)
round-half-to-even(12450e0, -2)
round-half-to-even(-12550.00, -2)
round-half-to-even(12550.00, -2)
round-half-to-even(-12550, -2)
round-half-to-even(12550, -2)
round-half-to-even(-12550e0, -2)
round-half-to-even(12550e0, -2)
round-half-to-even(1.5) eq 2
round-half-to-even(1) eq 1
round-half-to-even(2.5) eq 2
round-half-to-even(35612.25, -2) eq 35600
round-half-to-even(3.567812E+3, 2) eq 3567.81E0
round-half-to-even(4561.000005e0, 0)
round-half-to-even(4561.000005e0, -2)
round-half-to-even(4561.234567, 0)
round-half-to-even(4561234567, 0)
round-half-to-even(4561.234567, -2)
round-half-to-even(4561234567, -2)
round-half-to-even(4.7564E-3, 2) eq 0.0E0
(round-half-to-even(5.5))
(round-half-to-even(5.5), round-half-to-even(6.5), round-half-to-even(9372.253, 2), round-half-to-even(9372.253, 0), round-half-to-even(9372.253, -3))
(round-half-to-even(6.5))
(round-half-to-even(9372.253, 0))
(round-half-to-even(9372.253, 2))
(round-half-to-even(9372.253, -3))
round-half-to-even("a string")
round-half-to-even(xs:byte("0")) instance of xs:byte
round-half-to-even(xs:double("-0"))
round-half-to-even(xs:double("-1.75e-3") cast as xs:decimal,5)
round-half-to-even(xs:double("-INF"))
round-half-to-even(xs:double("INF"))
round-half-to-even(xs:double("NaN"))
round-half-to-even(xs:float("-0"))
round-half-to-even(xs:float('1.000005e0'), 2)
round-half-to-even(xs:float("-1.75e-3") cast as xs:decimal,5)
round-half-to-even(xs:float('3.75'), 1)
round-half-to-even(xs:float('4561.000005e0'), 0)
round-half-to-even(xs:float('4561.000005e0'), -2)
round-half-to-even(xs:float("-INF"))
round-half-to-even(xs:float("INF"))
round-half-to-even(xs:float("NaN"))
round-half-to-even(xs:int("0")) instance of xs:int
round-half-to-even(xs:long("0")) instance of xs:long
round-half-to-even(xs:negativeInteger("-1")) instance of xs:negativeInteger
round-half-to-even(xs:nonNegativeInteger("0")) instance of xs:nonNegativeInteger
round-half-to-even(xs:nonPositiveInteger("0")) instance of xs:nonPositiveInteger
round-half-to-even(xs:positiveInteger("1")) instance of xs:positiveInteger
round-half-to-even(xs:short("0")) instance of xs:short
round-half-to-even(xs:unsignedByte("0")) instance of xs:unsignedByte
round-half-to-even(xs:unsignedInt("0")) instance of xs:unsignedInt
round-half-to-even(xs:unsignedLong("0")) instance of xs:unsignedLong
round-half-to-even(xs:unsignedShort("0")) instance of xs:unsignedShort
round-half-to-even( (xs:yearMonthDuration("P42Y10M") div xs:yearMonthDuration("P20Y10M")) div (xs:yearMonthDuration("P20Y11M") div xs:yearMonthDuration("P18Y11M")), 15)
round(xs:byte(.)) instance of xs:byte
round(xs:double("-0"))
round(xs:double("0"))
round(xs:double(1)) eq 1
round(xs:double("-INF"))
round(xs:double("INF"))
round(xs:float("-0"))
round(xs:float("0"))
round(xs:float(1)) eq 1
round(xs:float("-INF"))
round(xs:float("INF"))
round(xs:int(.)) instance of xs:int
round(xs:long(.)) instance of xs:long
round(xs:negativeInteger(.)) instance of xs:negativeInteger
round(xs:nonNegativeInteger(.)) instance of xs:nonNegativeInteger
round(xs:nonPositiveInteger(.)) instance of xs:nonPositiveInteger
round(xs:positiveInteger(.)) instance of xs:positiveInteger
round(xs:short(.)) instance of xs:short
round(xs:unsignedByte(.)) instance of xs:unsignedByte
round(xs:unsignedInt(.)) instance of xs:unsignedInt
round(xs:unsignedLong(.)) instance of xs:unsignedLong
round(xs:unsignedShort(.)) instance of xs:unsignedShort
<r> <xs:element/> <local:element/> <fn:element/> <xml:element/> </r>
schema-attribute()
schema-attribute(*)
schema-attribute("quotesAreNotAllowed")
schema-element()
schema-element(*)
schema-element("quotesAreNotAllowed")
schema gt schema
seconds-from-dateTime()
seconds-from-dateTime(()) instance of xs:decimal?
seconds-from-dateTime((), "Wrong param")
seconds-from-dateTime(xs:dateTime("2001-02-03T08:23:12.43")) eq 12.43
(seconds-from-dateTime( xs:dateTime('2006-08-15T10:30:23.5')))
seconds-from-duration()
seconds-from-duration(implicit-timezone()) le 0 or seconds-from-duration(implicit-timezone()) gt 0
seconds-from-duration(()) instance of xs:decimal?
seconds-from-duration((), "Wrong param")
(seconds-from-duration( xs:dayTimeDuration('PT1M')))
(seconds-from-duration( xs:dayTimeDuration('PT30.5S')))
(seconds-from-duration( xs:dayTimeDuration('PT30.5S')), seconds-from-duration( xs:dayTimeDuration('-PT90.5S')), seconds-from-duration( xs:dayTimeDuration('PT1M')), seconds-from-duration( xs:dayTimeDuration('PT60S')))
(seconds-from-duration( xs:dayTimeDuration('PT60S')))
(seconds-from-duration( xs:dayTimeDuration('-PT90.5S')))
seconds-from-time()
seconds-from-time(()) instance of xs:decimal?
seconds-from-time((), "Wrong param")
(seconds-from-time(xs:time('10:30:23.5')))
seconds-from-time(xs:time("23:11:12.43")) eq 12.43
<section_count>{ count(//section) }</section_count>, <figure_count>{ count(//figure) }</figure_count>
<section_list> { for $s in //section let $f := $s/figure return <section title="{ $s/title/text() }" figcount="{ count($f) }"/> } </section_list>
<shoe name=" """" "/>
<shoe name=" '''''''' "/>
some $aaa in (1, 2, 3), $bbb in (3, 2, 1) satisfies $aaa + $bbb eq 4
some $a as empty-sequence()? in (1, 2) satisfies $a
some $a as item() at $p in (1, 2) satisfies $a
some $a as item()* in (1, 2), $b as item()* in $a satisfies $b
some $a as item()+ in (1, 2), $b as item()+ in $a satisfies $b
some $a as item()? in (1, 2), $b as item()? in $a satisfies $b
some $a as xs:integer in (1, 2), $b as xs:integer in $a satisfies $b
some $a at $p in (1, 2) satisfies $a
some $a in (1, 2), $b in $a satisfies $b
some $a in (1, 2), $b in (1, 2), $c in (1, 2) satisfies 1, $a
some $a in (1, 2), $b in (1, 2), $c in (1, 2) satisfies 1, $b
some $a in (1, 2), $b in (1, 2), $c in (1, 2) satisfies 1, $c
some $a in (1, 2), $b in (1, 2) satisfies 1, $b
some $a in (1, 2, 3), $b in ($a, 4) satisfies $b gt 0
some $a in (1, 2, 3), $b in (1, 2, 3, $b) satisfies $a eq $b
some $foo in ($foo, 2, 3) satisfies 1
some $foo in $foo satisfies 1
some $foo in (1, $2) return 1
some $foo in (1, $foo, 3) satisfies 1
some $foo in (1, $foo) satisfies 1
some $foo in (1, 2, $foo) satisfies 1
some $foo in 1 satisfies $bar + (every $bar in 2 satisfies $bar)
some $foo in 1 satisfies $bar + (some $bar in 2 satisfies $bar)
some $foo in 1 satisfies $foo eq "1"
some $foo in 1 satisfies $NOTEXIST
some $foo in 1 satisfies 1
some $foo in 1 satisfies "a string"
some $foo in 1 satisfies QName("example.com/", "ncname")
some $foo in 1 satisfies true()
some $id in attribute::id satisfies $id
some $i in (0, 2, 3) satisfies count($i)
SOME $i in (1, 2, 3) satisfies $i
some $i in (1, 2, 3) satisfies ($i, $i)
some $var in (1, 2, 3) satisfies $var eq 1 or $var eq 2 or $var eq 3
some $var in (1, 2, 3) satisfies $var eq 3
some $var in (false(), true(), true()) satisfies $var
some $var in (false(), xs:hexBinary("FF"), true()) satisfies $var
some $var in (true(), false(), true()) satisfies $var
some $var in (true(), true(), false()) satisfies $var
some $var in (true(), true(), true()) satisfies $var
some $var in (true(), true(), xs:hexBinary("FF")) satisfies $var
some $var in (xs:hexBinary("FF"), false(), true()) satisfies $var
some $x as xs:integer in (1, 2, 3), $y as xs:float in (xs:float(2), xs:float(3)) satisfies $x + $y = 5
some $x as xs:integer in (1, 2, 3) , $y as xs:integer in (2, 3, 4) satisfies $x + $y = 4
some $x as xs:string in ("cat","dog","rat") satisfies fn:string-length($x) = 3
some $x in (1,2,3), $y in (4,5,6) satisfies $x * $y = 10
some $x in (1,2,3), $y in (4,5,6) satisfies $x + $y = 5
some $x in (1,2,3), $y in (4,5,6) satisfies $x - $y = 5
some $x in (1,2,3), $y in (4,5,6) satisfies $x div $y = 2
some $x in (1,2,3), $y in (4,5,6) satisfies $x idiv $y = 2
some $x in (1,2,3), $y in (4,5,6) satisfies fn:string($x) = fn:string($y)
some $x in (1,2,3), $y in (4,5,6) satisfies xs:decimal($x) = xs:decimal($y)
some $x in (1,2,3), $y in (4,5,6) satisfies xs:double($x) = xs:double($y)
some $x in (1,2,3), $y in (4,5,6) satisfies xs:float($x) = xs:float($y)
some $x in (1,2,3), $y in (4,5,6) satisfies xs:integer($x) = xs:integer($y)
some $x in (1, 2) satisfies $x + $x = 2
some $x in (1, 2) satisfies $x + $x = 3
some $x in (1, 2) satisfies $x = 1 and ($x +1) = 2
some $x in (1, 2) satisfies $x = 1 or $x = 2
some $x in (1, 2) satisfies $x - 2 = 0
some $x in (1, 2) satisfies $x - 2 = 2
some $x in (1, 2) satisfies $x * 2 = 4
some $x in (1, 2) satisfies $x div 2 = 1
some $x in (1, 2) satisfies $x idiv 2 = 1
some $x in (1, 2) satisfies fn:avg(($x, 1)) = 1
some $x in (1, 2) satisfies fn:count(($x)) = 1
some $x in (1, 2) satisfies fn:false()
some $x in (1, 2) satisfies fn:not($x)
some $x in (1, 2) satisfies fn:string($x) = "1"
some $x in (1, 2) satisfies fn:string-length(xs:string($x)) = 1
some $x in (1, 2) satisfies fn:true()
some $x in ("1980-05-05T13:13:13Z", "1980-05-05T13:13:13Z"), $y in ("1980-05-05T13:13:13Z","1980-05-05T13:13:13Z") satisfies xs:dateTime($x) = xs:dateTime($y)
some $x in ("1985-07-05Z", "1985-07-05Z"), $y in ("1985-07-05Z","1985-07-05Z") satisfies xs:date($x) = xs:date($y)
some $x in (1 to 10)[. div 2 = 11] satisfies true()
some $x in ("A","B","C") satisfies $x = "A"
some $x in map{'decimal':true(), 'integer':true(), 'polygon':false()}?* satisfies $x
some $x in ("true", "false"), $y in ("false","true") satisfies xs:boolean($x) = xs:boolean($y)
<!-- some - - - - content - - - >>>>> << >>><>& ;& --> eq " some - - - - content - - - >>>>> << >>><>&amp; ;&amp; "
<? spaceIsNotAllowedBefore ?>
(/staff[1]/employee[1]/empnum[1]) << <a>50000</a>
(/staff[1]/employee[1]/empnum[1]) >> <a>50000</a>
(/staff[1]/employee[1]/empnum[1]) is <a>50000</a>
(/staff[1]/employee[1]/empnum[1]) is (/staff[1]/employee[1]/empnum[1])
((/staff[1]/employee[1]/empnum[1]) is (/staff[1]/employee[1]/empnum[1])) ge ((/staff[1]/employee[1]/empnum[1]) is (/staff[1]/employee[1]/empnum[1]))
((/staff[1]/employee[1]/empnum[1]) is (/staff[1]/employee[1]/empnum[1])) gt ((/staff[1]/employee[1]/empnum[1]) is (/staff[1]/employee[1]/empnum[1]))
(/staff[1]/employee[1]/empnum[1]) is (/staff[1]/employee[1]/empnum[1]) is (/staff[1]/employee[1]/empnum[1])
((/staff[1]/employee[1]/empnum[1]) is (/staff[1]/employee[1]/empnum[1])) le ((/staff[1]/employee[1]/empnum[1]) is (/staff[1]/employee[1]/empnum[1]))
((/staff[1]/employee[1]/empnum[1]) is (/staff[1]/employee[1]/empnum[1])) lt ((/staff[1]/employee[1]/empnum[1]) is (/staff[1]/employee[1]/empnum[1]))
(/staff[1]/employee[1]/empnum[1]) << (/staff[1]/employee[1]/empnum[1])
(/staff[1]/employee[1]/empnum[1]) >> (/staff[1]/employee[1]/empnum[1])
((/staff[1]/employee[1]/empnum[1]) << (/staff[1]/employee[1]/empnum[1]))           ge          ((/staff[1]/employee[1]/empnum[1]) << (/staff[1]/employee[1]/empnum[1]))
((/staff[1]/employee[1]/empnum[1]) >> (/staff[1]/employee[1]/empnum[1]))           ge ((/staff[1]/employee[1]/empnum[1]) >> (/staff[1]/employee[1]/empnum[1]))
((/staff[1]/employee[1]/empnum[1]) << (/staff[1]/employee[1]/empnum[1]))           gt ((/staff[1]/employee[1]/empnum[1]) << (/staff[1]/employee[1]/empnum[1]))
((/staff[1]/employee[1]/empnum[1]) >> (/staff[1]/employee[1]/empnum[1]))           gt ((/staff[1]/employee[1]/empnum[1]) >> (/staff[1]/employee[1]/empnum[1]))
((/staff[1]/employee[1]/empnum[1]) << (/staff[1]/employee[1]/empnum[1]))           le ((/staff[1]/employee[1]/empnum[1]) << (/staff[1]/employee[1]/empnum[1]))
((/staff[1]/employee[1]/empnum[1]) >> (/staff[1]/employee[1]/empnum[1]))           le ((/staff[1]/employee[1]/empnum[1]) >> (/staff[1]/employee[1]/empnum[1]))
((/staff[1]/employee[1]/empnum[1]) << (/staff[1]/employee[1]/empnum[1]))           lt           ((/staff[1]/employee[1]/empnum[1]) << (/staff[1]/employee[1]/empnum[1]))
((/staff[1]/employee[1]/empnum[1]) >> (/staff[1]/employee[1]/empnum[1]))           lt ((/staff[1]/employee[1]/empnum[1]) >> (/staff[1]/employee[1]/empnum[1]))
(starts-with('', ''))
starts-with(())
starts-with((), ())
starts-with()
starts-with('a', 'b', 'http://www.cbcl.co.u,/collation')
starts-with("a string", ())
starts-with("a string", "a string", "http://www.example.com/COLLATION/NOT/SUPPORTED")
starts-with("foo", "foo")
starts-with((), (), "http://www.w3.org/2005/xpath-functions/collation/codepoint", "wrong param")
(starts-with('', 'query'))
(starts-with('query', ''))
(starts-with('query', ()))
(starts-with(' query', 'q'))
(starts-with('query', 'que'))
(starts-with('query', 'query'))
(starts-with('query', 'que'), starts-with('query', 'query'), starts-with('query', 'u'), starts-with('query', ''), starts-with('', 'query'), starts-with('', ''), starts-with('query', ()), starts-with(' query', 'q'))
(starts-with('query', 'u'))
starts-with("tattoo", "tat")
((), (), ((), (), ((), (), ("str")), ()), (), (())) eq "str"
"string" * 1
"string" + 1
"string" - 1
"string" << 1
"string" >> 1
string([1])
string( (1, 2) )
string(1, 2)
string((1, 2, 3))
string([[1, 2], [3, 4]])
string(1) eq "1"
string(23)
string(3 * xs:double("NaN")) eq "NaN"
string(3 + xs:double("NaN")) eq "NaN"
string(3 - xs:double("NaN")) eq "NaN"
string(3 * xs:float("NaN")) eq "NaN"
string(3 + xs:float("NaN")) eq "NaN"
string(3 - xs:float("NaN")) eq "NaN"
string(<a> {1} <b> {1} </b> </a>)
string(<a>aaaa<b/>aaaa</a>)
string(<a attr="content"><!-- NOTINC -->1<b>2<c><!-- NOTINC -->34</c><!-- NOTINC --><d/>56</b>7</a>) eq "1234567"
string(abs#1)
string(array{})
string(avg((1, 2, 3, xs:double("NaN")))) eq "NaN"
string(avg((1, 2, 3, xs:float("NaN")))) eq "NaN"
string(avg((1, 2, xs:double("NaN"), 1, 2, 3))) eq "NaN"
string(avg((1, 2, xs:float("NaN"), 1, 2, 3))) eq "NaN"
string(avg((3, 3, xs:double("NaN")))) eq "NaN"
string(avg(((3, 4, 5), xs:float('NaN')))) eq "NaN"
string(avg((3, xs:double("NaN"), 3))) eq "NaN"
string(avg((xs:double("NaN"), 1, 2, 3))) eq "NaN"
string(avg((xs:double("NaN"), 3, 3))) eq "NaN"
string(avg((xs:float('INF'), xs:float('-INF')))) eq "NaN"
string(avg((xs:float("NaN"), 1, 2, 3))) eq "NaN"
'string' castable as attribute()
'string' castable as empty-sequence()
'string' castable as item()
'string' castable as node()
'string' castable as xs:anyAtomicType
'string' castable as xs:anySimpleType
'string' castable as xs:anyType*
'string' castable as xs:string*
'string' castable as xs:string+
'string' cast as attribute()
'string' cast as empty-sequence()
'string' cast as item()
'string' cast as node()
'string' cast as xs:anyAtomicType
'string' cast as xs:anySimpleType
'string' cast as xs:anyType*
'string' cast as xs:string*
'string' cast as xs:string+
string((//comment())[1])
string(<!-- content&amp;amp;ss&amp;amp;#00; &amp;#x2014;-->) eq " content&amp;amp;amp;ss&amp;amp;amp;#00; &amp;amp;#x2014;"
string(current-date())
string(dateTime(xs:date("2011-06-29"), xs:time("24:00:00")))
"string" div 1
string(<e>123<!-- a comment -->ab<!-- another comment -->c</e>)
string(<e>123<b>XX</b>abc</e>)
string(<e>123<?target content ?>ab<?target2 content?>c</e>)
string(<e>{1}A{1}</e>)
string(<e/>)/3
string(<e> &#32; </e>)
string(<e>'a''a'''a"a""a"""a"</e>) eq "'a''a'''a""a""""a""""""a"""
string(<e>a<!--data tar-->b</e>)
string(<e> <![CDATA[ ]]> </e>)
string(<e>]]></e>)
string(<e>e<b>ddd</b></e>)
string(<eg> (: an (:example:) </eg>)
string(<elem>{1}{text{""}}{2}</elem>)
string(<elem attr="{attribute name {" content "}}"/>/@attr)
string(<elem attr="{comment {" content "}}"/>/@attr)
string(<elem><![CDATA[cdata&<>'"< ]]>asda <?target content?>asdad</elem>) eq "cdata&amp;<>'""&lt;&#x20;asda asdad"
string(<elem><![CDATA[cdat]]><!-- a comment --><?target content?></elem>)
string(<elem><![CDATA[con<<< ]] >""'*"*">>tent]]&#00;&#x12;&amp;&quot;&notrecognized;&apos]]></elem>) eq "con&lt;&lt;&lt; ]] &gt;""""'*""*""&gt;&gt;tent]]&amp;#00;&amp;#x12;&amp;amp;&amp;quot;&amp;notrecognized;&amp;apos"
string(<elem> <![CDATA[]]> </elem>)
string(<elem><![CDATA[str]]>str<![CDATA[str]]><![CDATA[str]]><![CDATA[str]]>strstr{ "str", "str", "strstr", "str"}strstr<![CDATA[str]]>s<?target str?>tr</elem>) eq "strstrstrstrstrstrstrstr str strstr strstrstrstrstr"
string(<elem> content <![CDATA[ content ]]> content </elem>)
string(()) eq ""
"string" eq 1
string(<e>text</e>)
string(exactly-one((for $fo in (1, 2, 3) where $fo eq 3 return $fo)))
string(false())
string(<foo attr=""""/>/@attr)
string(<foo attr="''"/>/@attr)
string(<foo attr='""'/>/@attr)
string(<foo attr=''''/>/@attr)
string(for $i in current-date() order by $i return $i)
string(function($a, $b) {$a + $b})
"string" ge 1
"string" gt 1
"string" idiv 1
"string" is 1
(string-join((), '/*'))
string-join#1(("a", "b", "c", "d", "e", "f", "g", "h", "i", "j"))
string-join#1 eq string-join#1
string-join#1 is string-join#1
(string-join( 'a', '/*'))
(string-join( ('a', 'b', 'c'), ''))
(string-join( ('a', 'b', 'c'), '/*'))
string-join(("abc", "def"), "") eq "abcdef"
(string-join( ('a', 'b', 'c'), ''), string-join( ('a', 'b', 'c'), '/*'), string-join( ('a', '', 'c'), '/*'), string-join( 'a', '/*'), string-join((), '/*'))
(string-join( ('a', '', 'c'), '/*'))
string-join(<a foo="3" bar="5" xml:space="preserve"/> / @Q{}*, '.')
string-join("a string")
string-join("a string", ())
string-join("a string", "a string", "wrong param")
string-join((<a>X</a>, <a>Y</a>, <a>Z</a>), '')
string-join(('Blow, ', 'blow, ', 'thou ', 'winter ', 'wind!'), '') eq "Blow, blow, thou winter wind!"
string-join((/comment() intersect /comment()), "|")
string-join(for $code in string-to-codepoints("example.com/") return string($code), "") eq "10112097109112108101469911110947"
string-join((for $node in /bib/book/title/text() except /bib/book[3]/title/text() return $node/string()), "|")
string-join((for $node in ((//price/text()) , (//price/text())) except (//price) return $node)/string(), "|")
string-join(for $node in ((//price/text()) , (//price/text())) union ((//price/text()) , (//price/text())) return $node, "|")
string-join(('Now', 'is', 'the', 'time', '...'), ' ') eq "Now is the time ..."
string-join(reverse(((//*:Open)[1])/ancestor-or-self::*/local-name()), '~')
string-join((), 'separator') eq ""
string-join(("START",         string(QName("http://example.com",         "prefix:localName")),         string(QName("http://example.com", "localName")),         string(QName("http://example.com", "localName")),         string(QName("", "localName")),         string(QName((), "localName")),         "END"), " ")
string-join(("START",         string(QName("http://example.com", "prefix:localName")),         string(QName("http://example.com", "localName")),         string(QName("http://example.com", "localName")),         string(QName("", "localName")),         string(QName((), "localName")),         "END"), " ")
string-join(tokenize( 'a    b c', '\s'), '|')
string-join( (xs:anyURI('http://www.microsoft.com'), xs:anyURI('http://www.google.com/')), ' ')
"string" le 1
(string-length(''))
(string-length(()))
string-length("abc𝅖def")
string-length("abc&#x1D156;def")
string-length("a string", "wrong param")
string-length("ebv") eq 3
string-length("ebv") instance of xs:integer
string-length("") eq 0
string-length(()) eq 0
string-length("Harp not on that string, madam; that is past.") eq 45
string-length(()) instance of xs:integer
(string-length(normalize-space(' query ')))
string-length(("one", "two"))
(string-length('  query  '))
(string-length('query'))
(string-length('query'), string-length('  query   '), string-length(normalize-space('   query   ')), string-length('xml query'), string-length(''), string-length(()))
string-length(string(xs:string(current-time()))) gt 2
(string-length('xml query'))
string-length(xs:token(' '))
string-length(xs:token('&#x9;'))
string-length("𐀂")
string(map{})
string(map{1:2})
string(map:entry("a","string"))
string(max((1, xs:untypedAtomic("NaN"), xs:float(2)))) eq "NaN"
string(max((3, xs:double("NaN")))) eq "NaN"
string(max((3, xs:float("NaN")))) eq "NaN"
string(max(xs:double("NaN"))) eq "NaN"
string(max((xs:double("NaN"), xs:double("NaN")))) eq "NaN"
string(max((xs:float(-3), xs:untypedAtomic("3"), xs:double("NaN")))) eq "NaN"
string(max(xs:float("NaN"))) eq "NaN"
string(max((xs:float("NaN"), xs:float("NaN")))) eq "NaN"
string(max((xs:float("NaN"), xs:untypedAtomic("3"), xs:float(2)))) eq "NaN"
string(min((1, xs:untypedAtomic("NaN"), xs:float(2)))) eq "NaN"
string(min((3, xs:double("NaN")))) eq "NaN"
string(min((3, xs:float("NaN")))) eq "NaN"
string(min(xs:double("NaN"))) eq "NaN"
string(min((xs:double("NaN"), xs:double("NaN")))) eq "NaN"
string(min((xs:float(-3), xs:untypedAtomic("3"), xs:double("NaN")))) eq "NaN"
string(min(xs:float("NaN"))) eq "NaN"
string(min((xs:float("NaN"), xs:float("NaN")))) eq "NaN"
string(min((xs:float("NaN"), xs:untypedAtomic("3"), xs:float(2)))) eq "NaN"
"string" mod 1
"string" ne 1
string(number("1")) eq "1"
string(number(xs:anyURI("1"))) eq "NaN"
string(number(xs:anyURI("example.com/"))) eq "NaN"
string(number(xs:gYear("2005"))) eq "NaN"
string((//*:Open)[1])
string("Paris")
string(<pi>{<?pi x?>}</pi>) eq ""
string((//processing-instruction())[1])
string(processing-instruction {"thename"} {"asdas? >"})
string(processing-instruction {"thename"} {"content {1+ } {"})
string(          /Q{  http://www.example.com/AuctionWatch}AuctionWatchList/          Q{   http://www.example.com/AuctionWatch}Auction[2]/          @Q{  http://www.example.com/auctioneers#yabadoo}ID)
string((//Q{  http://www.example.com/AuctionWatch  }Start)[1])
string((//Q{http://www.example.com/AuctionWatch}Start)[1])
string(QName("http://www.w3.org/", "test:example"))
string((//*:Start)[1]/@*)
string(["string"])
string(string#1)
string(sum((1, 2, 3, xs:double("NaN")))) eq "NaN"
string(sum((1, 2, 3, xs:float("NaN")))) eq "NaN"
string(sum((1, 2, xs:double("NaN"), 1, 2, 3))) eq "NaN"
string(sum((1, 2, xs:float("NaN"), 1, 2, 3))) eq "NaN"
string(sum((xs:double("NaN"), 1, 2, 3))) eq "NaN"
string(sum((xs:float("NaN"), 1, 2, 3))) eq "NaN"
string(<?target ""''content&amp;amp;ss&amp;#00; &amp;#x2014;?>) eq """""''content&amp;amp;amp;ss&amp;amp;#00; &amp;amp;#x2014;"
string(<?target content ?>) eq "content "
string(text {""}) eq ""
string((//text())[normalize-space(.)][1])
(string-to-codepoints(''))
string-to-codepoints(())
string-to-codepoints()
string-to-codepoints(12)
(string-to-codepoints('a'))
(string-to-codepoints('abc'))
string-to-codepoints('abc','def')
(string-to-codepoints('abc'), string-to-codepoints('a'), string-to-codepoints(''))
string-to-codepoints(<a>   |&#xD; &#xD;&#xA;</a>)
string-to-codepoints('bßڒき豈')
string-to-codepoints(codepoints-to-string(14))
string-to-codepoints(codepoints-to-string(31))
string-to-codepoints("e")
string-to-codepoints(<elem>&amp;</elem>)
string-to-codepoints(<elem>&apos;</elem>)
string-to-codepoints(<elem>&gt;</elem>)
string-to-codepoints(<elem>&lt;</elem>)
string-to-codepoints(<elem>&quot;</elem>)
string-to-codepoints("str", "INVALID")
string-to-codepoints(substring("􏰀A", 2, 1))
string-to-codepoints(substring("&#x10FC00;A", 2, 1))
string-to-codepoints("Thérèse")[0 + last()]
string-to-codepoints("Thérèse")[last()]
string-to-codepoints("Thérèse")[last() - 0]
string-to-codepoints("Thérèse")[last() - 1]
string-to-codepoints("Thérèse")[last() - 2]
string-to-codepoints("Thérèse")[last() - 6]
string-to-codepoints(xs:normalizedString(codepoints-to-string((32, 09, 48, 13, 10, 48, 160, 32, 09))))
string-to-codepoints(xs:token(codepoints-to-string((32, 09, 48, 13, 10, 48, 160, 32, 09))))
string(/works/@id) eq "abc"
string(/works/@id) ne "abc"
string((//@xml:*)[1])
string(xs:dateTime("2000-08-01T12:44:05")) eq "2000-08-01T12:44:05"
string(xs:double("NaN") * 3) eq "NaN"
string(xs:double("NaN") + 3) eq "NaN"
string(xs:double("NaN") - 3) eq "NaN"
string(xs:duration("P24M"))
string(xs:float("NaN") * 3) eq "NaN"
string(xs:float("NaN") + 3) eq "NaN"
string(xs:float("NaN") - 3) eq "NaN"
string(xs:time("12:44:05")) eq "12:44:05"
string(xs:time("24:00:00"))
string(xs:time("24:00:00")) eq "00:00:00"
subsequence()
subsequence(1)
subsequence(1, 1, 1, 1)
subsequence((1, 2, 3), 1, 0)
subsequence((1, 2, 3), 1, 1) eq 1
subsequence((1, 2, 3.1, "four"), 1, 1)
subsequence(("1", 2, 3.1, "four"), 1, 1) eq 1
subsequence((1, 2, 3.1, "four"), 3, 1) instance of xs:decimal
subsequence((1, 2, 3.1, "four"), 4)
subsequence((1, 2, 3.1, "four"), 4, 1)
subsequence((1, 2, 3), 1, "string")
subsequence((1, 2, 3), 3) eq 3
subsequence((1, 2, 3, 4, 5), 4, -1)
subsequence((1, 2, 3, current-time(), 5, 6, 7), 1, 1)[1]
subsequence((1, 2, 3, current-time(), 5, 6, 7), 4)[last() - 1]
subsequence((1, 2, 3, current-time(), 5, 6, 9), 7)[last()]
subsequence((1, 2, for $x in 1 to 10 return 2*$x), -1, sum((1 to 10)[. mod 10 = 3]))
subsequence((1, 2, for $x in 1 to 10 return 2*$x), 2, year-from-date(current-date()))
subsequence(1 to 100, 99, 2147483648)
subsequence((1 to 100)[. mod 2 = 0],1,xs:double(string-join(('I','N','F')[position() mod 2 >= 0],'')))
subsequence((1 to 10)[. mod 2 = 0] instance of xs:integer+,1)
subsequence((1 to 20)[. mod 2 = 0][position() < 5],2)
(subsequence( (), 3))
subsequence(-3 to -1, 1, 1) eq -3
subsequence(-3 to -1, 3, 1) eq -1
subsequence((5, 6, 7, 8), 2, 1) eq 6
(subsequence( ('a', 'b', 'c', 'd', 'e'), 10))
(subsequence( ('a', 'b', 'c', 'd', 'e'), -2, 5))
(subsequence( ('a', 'b', 'c', 'd', 'e'), 3) )
(subsequence( ('a', 'b', 'c', 'd', 'e'), 3, 10))
(subsequence( ('a', 'b', 'c', 'd', 'e'), 3, 2))
(subsequence( ('a', 'b', 'c', 'd', 'e'), 3) , subsequence( ('a', 'b', 'c', 'd', 'e'), 3, 2), subsequence( ('a', 'b', 'c', 'd', 'e'), 3, 10), subsequence( ('a', 'b', 'c', 'd', 'e'), 10), subsequence( ('a', 'b', 'c', 'd', 'e'), -2, 5), subsequence( (), 3))
subsequence("a string", 1, 1) + 1
subsequence(("dummy", 1.1, xs:anyURI("http://www.example.com/an/arbitrary/URI.ext")), 3, 1) instance of xs:anyURI
subsequence(("dummy", 1.1, xs:base64Binary("aaaa")), 3, 1) instance of xs:base64Binary
subsequence(("dummy", 1.1, xs:boolean("true")), 3, 1) instance of xs:boolean
subsequence(("dummy", 1.1, xs:date("2004-10-13")), 3, 1) instance of xs:date
subsequence(("dummy", 1.1, xs:dateTime("2002-10-10T12:00:00-05:00")), 3, 1) instance of xs:dateTime
subsequence(("dummy", 1.1, xs:dayTimeDuration("P3DT2H")), 3, 1) instance of xs:dayTimeDuration
subsequence(("dummy", 1.1, xs:decimal("10.01")), 3, 1) instance of xs:decimal
subsequence(("dummy", 1.1, xs:double("3.3e3")), 3, 1) instance of xs:double
subsequence(("dummy", 1.1, xs:duration("P1Y2M3DT10H30M")), 3, 1) instance of xs:duration
subsequence(("dummy", 1.1, xs:float("3.4e5")), 3, 1) instance of xs:float
subsequence(("dummy", 1.1, xs:gDay("---03")), 3, 1) instance of xs:gDay
subsequence(("dummy", 1.1, xs:gMonth("--11")), 3, 1) instance of xs:gMonth
subsequence(("dummy", 1.1, xs:gMonthDay("--11-13")), 3, 1) instance of xs:gMonthDay
subsequence(("dummy", 1.1, xs:gYear("1999")), 3, 1) instance of xs:gYear
subsequence(("dummy", 1.1, xs:gYearMonth("1999-11")), 3, 1) instance of xs:gYearMonth
subsequence(("dummy", 1.1, xs:hexBinary("0FB7")), 3, 1) instance of xs:hexBinary
subsequence(("dummy", 1.1, xs:integer("6789")), 3, 1) instance of xs:integer
subsequence(("dummy", 1.1, xs:QName("ncname")), 3, 1) instance of xs:QName
subsequence(("dummy", 1.1, xs:string("an arbitrary string")), 3, 1) instance of xs:string
subsequence(("dummy", 1.1, xs:time("03:20:00-05:00")), 3, 1) instance of xs:time
subsequence(("dummy", 1.1, xs:untypedAtomic("an arbitrary string(untypedAtomic source)")), 3, 1) instance of xs:untypedAtomic
subsequence(("dummy", 1.1, xs:yearMonthDuration("P1Y12M")), 3, 1) instance of xs:yearMonthDuration
subsequence(for $x in (1 to 100) return -$x, 3, 5)
subsequence(for $x in 1 to 10 return $x * $x,2)
subsequence(for $x in 1 to 10 return $x[. mod 2 = 0],2)
subsequence(for $x in 1 to 10 return $x[. mod 2 = 0],2,4)
subsequence(for $x in 1 to 10 return 1 to $x, 1.2, xs:double("INF"))
subsequence(for $x in 1 to 10 return 1 to $x, 4.2, xs:double("INF"))
subsequence( for $x in 1 to 10 return 1 to $x, count(for $x in 0 to 10 return 1 to $x), 1)
subsequence(reverse(1 to 3), 1, 1) eq 3
subsequence(reverse(1 to 3), 3, 1) eq 1
subsequence(reverse(1 to 4), 2, 1) eq 3
subsequence(reverse(1 to 4), 3, 1) eq 2
subsequence(reverse(-4 to -1), 2, 1) eq -2
(substring('', 1))
(substring((), 1))
substring("12345", 0, 3) eq "12"
substring("12345", 0 div 0E0, 3) eq ""
substring("12345", 1, 0 div 0E0) eq ""
substring("12345", 1.5, 2.6) eq "234"
substring("12345", -1 div 0E0, 1 div 0E0) eq ""
substring("12345", -3.1e0, 5.2e0) eq "1"
substring("12345", -3, 5) eq "1"
substring("12345", -42, 1 div 0E0) eq "12345"
substring("12345", 5, -3) eq ""
substring((), 1, 2) eq ""
substring((), 1, 3) eq ""
substring((), 1) eq ""
substring("abc𝅖def", 4)
substring("abc𝅖def", 5)
substring("abcd𐀁efgh", 5, 2)
substring("abcd𐀁efgh", 6)
substring("abc&#x1D156;def", 4)
substring("abc&#x1D156;def", 5)
substring-after(())
substring-after()
substring-after("abc𝅖def", "𝅖")
substring-after("abcdefgedij", "def") eq "gedij"
substring-after("abc&#x1D156;def", "&#x1D156;")
substring-after("a string", ()) eq "a string"
substring-after("a string", "not in other") eq ""
substring-after((), ()) eq ""
substring-after((), (), "http://www.w3.org/2005/xpath-functions/collation/codepoint", "wrong param")
(substring-after('query', ''))
(substring-after('queryquery', 'ue'))
(substring-after('query', 'u'))
(substring-after('query', 'u'), substring-after('queryquery', 'ue'), substring-after('query', 'y'), substring-after('query', 'x'), substring-after('query', ''), substring-after('', 'x'))
(substring-after('query', 'x'))
(substring-after('query', 'y'))
substring-after("tattoo", "tat") eq "too"
substring-after("tattoo", "tattoo") eq ""
(substring-after('', 'x'))
substring-after("𐀁𐀂𐀃", "𐀂")
sub-string("a string")
sub-string("a string", 1, 2, "wrong param")
substring-before(())
substring-before()
substring-before("abc𝅖def", "𝅖")
substring-before("abc𝅖def", "f")
substring-before("abc&#x1D156;def", "f")
substring-before("abc&#x1D156;def", "&#x1D156;")
substring-before("a string", "") eq ""
substring-before("a string", "not in other") eq ""
substring-before((), ()) eq ""
substring-before((), (), "http://www.w3.org/2005/xpath-functions/collation/codepoint",          "wrong param")
(substring-before('query', ''))
(substring-before('query', ()))
(substring-before('query', 'ery'))
(substring-before('query', 'query'))
(substring-before('queryquery', 'ery'))
(substring-before('query', 'r'))
(substring-before('query', 'r'), substring-before('query', 'ery'), substring-before('queryquery', 'ery'), substring-before('query', 'query'), substring-before('query', 'x'), substring-before('query', ''), substring-before('query', ()))
(substring-before('query', 'x'))
substring-before("tattoo", "attoo") eq "t"
substring-before("tattoo", "tatto") eq ""
substring-before("𐀁𐀂𐀃", "𐀂")
substring("metadata", 4, 3) eq "ada"
substring("motor car", 6) eq " car"
(substring('query', 1))
(substring('query', 1, 0))
(substring('query', 1, 1))
(substring('query', 1), substring('query', 3), substring('query', 1, 1), substring('query', 2, 3), substring('query', 2, 850), substring('query', 6, 2), substring('query', -2), substring('query', -2, 5), substring('query', 1, 0), substring('', 1), substring((), 1))
(substring('query', -2))
(substring('query', 2, 3))
(substring('query', -2, 5))
(substring('query', 2, 850))
(substring('query', 3))
(substring('query', 6, 2))
substring("𐀁", 0, 2)
substring("𐀁", 0, 3)
substring("𐀁", 1, 2)
substring("𐀁", 2, 1)
substring("𐀁𐀁", 0)
substring("𐀁𐀁", 3)
sum((), ())
sum()
sum((), 0.0) eq 0.0
sum((), 0.0) instance of xs:decimal
sum(1, 1, "wrong param")
sum((1, 2, 3, xs:anyURI("a string"), xs:double("NaN")))
sum((1, 2, 3, xs:anyURI("a string"), xs:double("NaN")), 3)
sum((1, 2, xs:untypedAtomic("3"))) eq 6
sum((1, 2, xs:untypedAtomic("3"))) instance of xs:double
sum((1,exactly-one((1 to 10)[. div 2 = 2])))
sum(1 to 10)
sum((1 to 100)[. < 0], 0) eq 0
sum((1 to 5)[. gt year-from-date(current-date())], "No data")
sum((1 to 5)[. lt year-from-date(current-date())], 17)
sum((1 to 5)[. lt year-from-date(current-date())], "bonkers")
sum((3, 4, 5)) eq 12
sum((), 3) eq 3
sum((), 3) instance of xs:integer
sum((-5, -0, -3, -6)) eq -14
sum("a string")
sum(((),())) eq 0
sum(()) eq 0
sum(for $i in 1 to 6 return              let $add := function($x){$x + $i} return $add(4))
sum(for $x in 1 to 10 return 5)
sum(()) instance of xs:integer
sum(remove((1.0, xs:float(1), 2, xs:untypedAtomic("3")), 1)) eq 6
sum(sum((1 to 10)[. mod 2 = 0],()))
sum(xs:anyURI("a string"))
sum((), xs:dayTimeDuration("PT0S"))
sum((), xs:duration("P0M"))
sum(xs:duration("P1Y1M1D"))
sum(xs:duration("P1Y1M1D"), xs:duration("PT0S"))
sum((xs:float(1), 2, xs:untypedAtomic("3"))) eq 6
sum((xs:float(1), 2, xs:untypedAtomic("3"))) instance of xs:double
sum((xs:float('NaN'), 2, 3.3, 4, xs:double('NaN'))) instance of xs:double
sum((xs:float('NaN'), 2, 3, 4, xs:double('NaN'))) instance of xs:double
sum(xs:untypedAtomic("3")) instance of xs:double
sum((), xs:yearMonthDuration("P0M"))
sum((xs:yearMonthDuration("P1Y"), xs:dayTimeDuration("P1D")))
sum((xs:yearMonthDuration("P20Y"), (3, 4, 5)))
sum((xs:yearMonthDuration("P20Y"), xs:yearMonthDuration("P10M")) [. < xs:yearMonthDuration("P3M")], xs:yearMonthDuration("P0M")) eq xs:yearMonthDuration("P0M")
switch()
system-property("property")
system-property("xsl:vendor")
tail(12 to 15)
tail(("a", "b", "c"))
<?target ]]>?>
<?target {1 + 1}?>
<?target 1?> eq 1
<?target content?> instance of processing-instruction()
"t" eq "t"
"t" eq "&#x74;"
"test
"test"
"test'
'test
'test"
'test'
<test check='He said, "I don''t like it."' />
//test:comparable[1]/test:int eq //test:comparable[2]/test:int
<?test data?>/node-name()
<test>{ 'He said, "I don''t like it."' }</test>
(:*******************************************************:) (: Test: K2-DirectConElemAttr-75                         :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:21+01:00                       :) (: Purpose: Mix several ways for creating text for various kinds of nodes. This test is useful if an implementation is performing normalization of such constructors. :) (:*******************************************************:) <e attribute="{ "abc", "def", "ghi", 1, 2, 3, xs:untypedAtomic("abc"), text {"a text node"}, text {"a text node"}, xs:untypedAtomic("def"), xs:untypedAtomic("ghi"), xs:hexBinary("FF"), xs:untypedAtomic("abc"), xs:string("def"), xs:untypedAtomic("ghi") } textNode {"xs:string"} textNode {"xs:string"} textNode {"xs:string"} text {"a text node"}, {"xs:string"} {"xs:string"}textnode"> {  attribute name { text {"a text node"}, text {"a text node"}, "abc", "def", text {"a text node"}, "ghi", 1, 2, text {"a text node"}, 3, xs:untypedAtomic("abc"), xs:untypedAtomic("def"), text {"a text node"}, xs:untypedAtomic("ghi"), xs:hexBinary("FF"), xs:untypedAtomic("abc"), xs:string("def"), xs:untypedAtomic("ghi"), "xs:string", xs:untypedAtomic("ghi"), "xs:string", "xs:string", "xs:string", xs:untypedAtomic("ghi") } } { text {"a text node"}, text {"a text node"}, "abc", "def", text {"a text node"}, "ghi", 1, 2, text {"a text node"}, 3, xs:untypedAtomic("abc"), text {"a text node"}, xs:untypedAtomic("def"), xs:untypedAtomic("ghi"), xs:hexBinary("FF"), xs:untypedAtomic("abc"), xs:string("def"), xs:untypedAtomic("ghi") } textNode {"xs:string"} textNode {"xs:string"} textNode {"xs:string"} {"xs:string"} {"xs:string"} text {"a text node"}, text {"a text node"}, text {"a text node"}, text {"a text node"}, { comment { "abc", "def", "ghi", 1, 2, 3, xs:untypedAtomic("abc"), xs:untypedAtomic("def"), xs:untypedAtomic("ghi"), xs:hexBinary("FF"), xs:untypedAtomic("abc"), xs:string("def"), xs:untypedAtomic("ghi"), "xs:string", "xs:string", xs:untypedAtomic("ghi"), "xs:string", text {"a text node"}, text {"a text node"}, "xs:string", xs:untypedAtomic("ghi"), "xs:string" }, processing-instruction target { "abc", "def", "ghi", 1, 2, 3, xs:untypedAtomic("abc"), xs:untypedAtomic("def"), xs:untypedAtomic("ghi"), text {"a text node"}, text {"a text node"}, xs:hexBinary("FF"), xs:untypedAtomic("abc"), xs:string("def"), xs:untypedAtomic("ghi"), "xs:string", "xs:string", xs:untypedAtomic("ghi"), "xs:string", "xs:string", xs:untypedAtomic("ghi"), text {"a text node"}, "xs:string" }, text { text {"a text node"}, text {"a text node"}, text {"a text node"}, text {"a text node"}, "abc", "def", "ghi", 1, 2, text {"a text node"}, 3, xs:untypedAtomic("abc"), text {"a text node"}, xs:untypedAtomic("def"), xs:untypedAtomic("ghi"), xs:hexBinary("FF"), xs:untypedAtomic("abc"), xs:string("def"), xs:untypedAtomic("ghi"), "xs:string", "xs:string", xs:untypedAtomic("ghi"), "xs:string", "xs:string", xs:untypedAtomic("ghi"), "xs:string", text {"a text node"} } } </e>
(:*******************************************************:) (: Test: K2-DirectConOther-49                            :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:21+01:00                       :) (: Purpose: Check that an attribute value's value is properly read and serialized. Since the whitespace is expressed with character references they are preserved and hence aren't subject to for instance end-of-line handling. Subsequently, the serialization process must escape such characters in order to not have the parser normalize the values when being read back in. :) (:*******************************************************:) <e attr="&#x20;&#xD;&#xA;&#x9;&#xD;&#xD;&#xD;&#xD;      &#xD; &#xD;     &#xD;&#xA; &#xD;&#xA; &#xD;&#xA;"/>
(:*******************************************************:) (: Test: K2-DirectConOther-50                            :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:21+01:00                       :) (: Purpose: Ensure that EOL-normalization also takes place in CDATA sections. :) (:*******************************************************:) string(<e><![CDATA[ ]]></e>) eq "&#xA;"
(:*******************************************************:) (: Test: K2-DirectConOther-51                            :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:21+01:00                       :) (: Purpose: Ensure that EOL-normalization also takes place in CDATA sections(#2). :) (:*******************************************************:) string(<e><![CDATA[ ]]></e>) eq "&#xA;"
(:*******************************************************:) (: Test: K2-DirectConOther-52                            :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:21+01:00                       :) (: Purpose: Ensure that EOLs are normalized in text nodes. :) (:*******************************************************:) <e>a    string literal  </e>
(:*******************************************************:) (: Test: K2-DirectConOther-53                            :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:21+01:00                       :) (: Purpose: Ensure that EOLs are normalized in comment nodes. :) (:*******************************************************:) <e><!--a    string literal  --></e>
(:*******************************************************:) (: Test: K2-DirectConOther-54                            :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:21+01:00                       :) (: Purpose: Ensure that EOLs are normalized in processing instructions. :) (:*******************************************************:) <e><?target a    string literal  ?></e>
(:*******************************************************:) (: Test: K2-Literals-28                                  :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:21+01:00                       :) (: Purpose: Ensure that EOLs are normalized in string literals. :) (:*******************************************************:) "a   string literal  "
(:*******************************************************:) (: Test: K2-Literals-39                                  :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:21+01:00                       :) (: Purpose: Ensure that EOLs are normalized in string literals, using single quotes. :) (:*******************************************************:) 'a    string literal  '
(:*******************************************************:) (: Test: K2-XQueryComment-1                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:21+01:00                       :) (: Purpose: An invalid comment after a name test.        :) (:*******************************************************:) let $i := <e>                                             <b/>                                             <b/>                                             <b/>                                         </e>                               return $i/b(:
(:*******************************************************:) (: Test: K2-XQueryComment-2                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:21+01:00                       :) (: Purpose: An invalid comment after a name test(#2).    :) (:*******************************************************:) let $i := <e>                                             <b/>                                             <b/>                                             <b/>                                         </e>                               return $i/b(: some : content (:some content
(:*******************************************************:) (: Test: K2-XQueryComment-3                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:21+01:00                       :) (: Purpose: Have a computed comment constructor as a last step. :) (:*******************************************************:) let $i := <e>                                             <b/>                                             <b/>                                             <b/>                                         </e>                                         return $i/b/comment(: some : content (:some content:):){"content"}
(:*******************************************************:) (: Test: K2-XQueryComment-4                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:21+01:00                       :) (: Purpose: Have a direct comment constructor as a last step. :) (:*******************************************************:) let $i := <e>                                             <b/>                                             <b/>                                             <b/>                                         </e>                                         return $i/(: some : content (:some content:):)<!--content-->
(:*******************************************************:) (: Test: K2-XQueryComment-5                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:21+01:00                       :) (: Purpose: Have a direct comment constructor as a last step(#2). :) (:*******************************************************:) let $i := <e>                                             <b/>                                             <b/>                                             <b/>                                         </e>                                         return $i/b/(: some : content (:some content:):)<!--content-->
(:*******************************************************:) (: Test: K-XQueryComment-10                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: An empty comment at the very beginning of an expression. :) (:*******************************************************:) (::) 1 eq 1
(:*******************************************************:) (: Test: K-XQueryComment-11                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: An empty comment after a function's paranteses. :) (:*******************************************************:) true()(::)
(:*******************************************************:) (: Test: K-XQueryComment-12                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: A for loop with a comment inbetween.         :) (:*******************************************************:) for (: set up loop :) $i in 3 return $i eq 3
(:*******************************************************:) (: Test: K-XQueryComment-13                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: A test whose essence is: `if((: comment inbetween :)) then 1 else 1`. :) (:*******************************************************:) if((: comment inbetween :)) then 1 else 1
(:*******************************************************:) (: Test: K-XQueryComment-14                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: A syntactically invalid comment that never ends. :) (:*******************************************************:) 1(: this comment does not end:
(:*******************************************************:) (: Test: K-XQueryComment-15                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: A comment inside a comment that isn't terminated. :) (:*******************************************************:) 1(: content (: this comment does not end :)
(:*******************************************************:) (: Test: K-XQueryComment-16                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: A comment inside a comment that does not start properly. :) (:*******************************************************:) 1(: content this comment does not start properly :) :)
(:*******************************************************:) (: Test: K-XQueryComment-17                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: Colons and paranteses appearing freely in comment content. :) (:*******************************************************:) 1(: ((( : )) ))ladl:  :(): ()()(dahsi ()()( dad: ) :) eq 1
(:*******************************************************:) (: Test: K-XQueryComment-18                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: Three comments appearing serially inside a comment. :) (:*******************************************************:) 1(: (:one comment:) content (:another comment:) content (:a third:):)    eq 1
(:*******************************************************:) (: Test: K-XQueryComment-19                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: A test stressing many nested comments.       :) (:*******************************************************:) 1(:(:(:(:(:(:(:(::):):):):):):):) eq 1
(:*******************************************************:) (: Test: K-XQueryComment-1                               :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: A test whose essence is: `(3(: comment inbetween :)- 1) eq 2`. :) (:*******************************************************:) (3(: comment inbetween :)- 1) eq 2
(:*******************************************************:) (: Test: K-XQueryComment-20                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: A syntactically invalid comment that doesn't properly start. :) (:*******************************************************:) : :) 1
(:*******************************************************:) (: Test: K-XQueryComment-2                               :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: A test whose essence is: `1 (: a (: nested :) comment :) eq 1`. :) (:*******************************************************:) 1 (: a (: nested :) comment :) eq 1
(:*******************************************************:) (: Test: K-XQueryComment-3                               :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: A test whose essence is: `1 (: comment (: inside :) comment :) eq 1`. :) (:*******************************************************:) 1 (: comment (: inside :) comment :) eq 1
(:*******************************************************:) (: Test: K-XQueryComment-4                               :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: Comparison of two string literals, whose content reminds of comments. :) (:*******************************************************:) "reminds of a comment :)" eq     "reminds of a comment :)"
(:*******************************************************:) (: Test: K-XQueryComment-5                               :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: A test whose essence is: `5 instance (: strange place for a comment :) of item()`. :) (:*******************************************************:) 5 instance (: strange place for a comment :) of item()
(:*******************************************************:) (: Test: K-XQueryComment-6                               :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: A test whose essence is: `1 (: simple comment :) eq 1`. :) (:*******************************************************:) 1 (: simple comment :) eq 1
(:*******************************************************:) (: Test: K-XQueryComment-7                               :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: A test whose essence is: `1 (: comment (: inside :) NEW LINE comment :) eq 1`. :) (:*******************************************************:) 1 (: comment (: inside :) NEW LINE comment :) eq 1
(:*******************************************************:) (: Test: K-XQueryComment-8                               :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: A test whose essence is: `(: "recursive comments must be balanced, this one is not :)" :)`. :) (:*******************************************************:) (: "recursive comments must be  balanced, this one is not :)" :)
(:*******************************************************:) (: Test: K-XQueryComment-9                               :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: An empty comment inbetween the 'eq' operator and a number literal. :) (:*******************************************************:) 1 eq (::)1
text {., .}
text(*)
text{}
text(1)
text {1,'',2}
text {1,<a/>,2}
text {1,'string',3.14,xs:float('1.2345e-2'),xs:dateTime('2002-04-02T12:00:00-01:00')}
text {<elem>123</elem>, (<elem attr='456'/>)/@attr, (<elem>789</elem>)/text()}
text{ "He said, ""I don't like it.""" }
text{ 'He said, "I don''t like it."' }
text {"name"} {"content"}
text name {"content"}
text {/root}
text {text {'one', text {'two'}}, 'three', text {'four'}}
"the cat sat on the mat"=>tokenize("\s+")=>count()
(:      This query opens a C++ GCC-XML output file, and outputs a report describing the use     of globals variables. :) declare variable $inputDocument := (/); (: Determines whether the type by ID @p typeId is a complex type such as QString. :) declare function local:isComplexType($typeID as xs:string) as xs:boolean {     (: We're being a bit crude here and only checks whether it's a class. We        actually should check whether it has non-synthesized,         constructors, I believe. :)          exists($inputDocument/xml/Class[@id = $typeID])     or     (: We also want const-qualified variables. :)     exists($inputDocument/xml/Class[@id = $inputDocument/xml/CvQualifiedType[@id = $typeID]/@type]) }; declare function local:isPrimitive($typeId as xs:string) as xs:boolean {     exists($inputDocument/xml/FundamentalType[@id = $typeId]) }; (: Returns a string for human consumption that describes    the location of @p block. :) declare function local:location($block as element()) as xs:string {     concat($inputDocument/xml/File[@id = $block/@file]/@name, " at line ", $block/@line) }; declare function local:report() as element()+ {             let $complexVariables as element(Variable)* := $inputDocument/xml/Variable[local:isComplexType(@type)]             return if(exists($complexVariables)) (: Is the length larger than zero? :)                    then (<p xmlns="http://www.w3.org/1999/xhtml/">The following global, complex variables were found:</p>,                          <ol xmlns="http://www.w3.org/1999/xhtml/">                             {                                 (: For each Variable in $complexVariables... :)                                 for $v in $complexVariables                                 return $v/<li><span class="variableName">{string(@name)}</span> in {local:location(.)}</li>                             }                          </ol>)                    else <p xmlns="http://www.w3.org/1999/xhtml/">No global variables that are of complex types were found.</p>             ,             (: List primitive, mutable types. :)             let $primitiveVariables as element(Variable)+ := $inputDocument/xml/Variable[local:isPrimitive(@type)]             return if(exists($primitiveVariables))                    then (<p xmlns="http://www.w3.org/1999/xhtml/">The following mutable primitives were found:</p>,                          <ol xmlns="http://www.w3.org/1999/xhtml/">                             {                                 (: For each Variable in $complexVariables... :)                                 for $v in $primitiveVariables                                 return $v/<li><span class="variableName">{string(@name)}</span> in {local:location(.)}</li>                             }                          </ol>)                    else <p xmlns="http://www.w3.org/1999/xhtml/">No global variables that are of complex types were found.</p> }; <html xmlns="http://www.w3.org/1999/xhtml/" xml:lang="en" lang="en">     <head>         <title>Global variables report for {"Globals.cpp"}</title>     </head>     <style type="text/css">         .details         {{             text-align: center;             font-size: 80%;             color: gray         }}         .variableName         {{             font-family: courier         }}     </style>     <body>         {             (: We don't want simple types that are const, but all other types.                One could frown upon const integers and say enums should be used instead, but                let's be gentle. :)             local:report()         }         <p class="details">This report was generated on</p>     </body> </html>
"this, that and the other"=>contains("the")
('Thy ' ||  () ||  'old ' ||  "groans" ||  "" ||  ' ring' ||  ' yet' ||  ' in' ||  ' my' ||  ' ancient' || ' ears.')
timezone-from-date()
timezone-from-date(()) instance of xs:dayTimeDuration?
timezone-from-dateTime()
timezone-from-dateTime(()) instance of xs:dayTimeDuration?
timezone-from-dateTime((), "Wrong param")
timezone-from-dateTime(xs:dateTime("2004-10-12T23:43:12-08:23")) eq xs:dayTimeDuration("-PT8H23M")
timezone-from-dateTime(xs:dateTime("2004-10-12T23:43:12Z")) eq xs:dayTimeDuration("PT0S")
(timezone-from-dateTime( xs:dateTime('2006-08-15T10:30:23')))
(timezone-from-dateTime( xs:dateTime('2006-08-15T10:30:23-05:00')))
(timezone-from-dateTime( xs:dateTime('2006-08-15T10:30:23-05:00')), timezone-from-dateTime( xs:dateTime('2006-08-15T10:30:23')))
timezone-from-date((), "Wrong param")
timezone-from-date(xs:date("2004-10-12-08:23")) eq xs:dayTimeDuration("-PT8H23M")
timezone-from-date(xs:date("2004-10-12Z")) eq xs:dayTimeDuration("PT0S")
(timezone-from-date( xs:date('2006-08-15')))
(timezone-from-date( xs:date('2006-08-15-05:00')))
(timezone-from-date( xs:date('2006-08-15-05:00')), timezone-from-date( xs:date('2006-08-15')))
timezone-from-time()
timezone-from-time(()) instance of xs:dayTimeDuration?
timezone-from-time((), "Wrong param")
(timezone-from-time( xs:time('09:54:00')))
(timezone-from-time( xs:time('09:54:00+05:00')))
(timezone-from-time( xs:time('09:54:00-05:00')))
(timezone-from-time( xs:time('09:54:00-05:00')), timezone-from-time( xs:time('09:54:00+05:00')), timezone-from-time( xs:time('09:54:00Z')), timezone-from-time( xs:time('09:54:00')))
(timezone-from-time( xs:time('09:54:00Z')))
timezone-from-time(xs:time("23:43:12.765-08:23")) eq xs:dayTimeDuration("-PT8H23M")
timezone-from-time(xs:time("23:43:12.765Z")) eq xs:dayTimeDuration("PT0S")
(tokenize( '2006-12-25T12:15:00', '[\-T:]'))
(tokenize( ' a b c '))
(tokenize( 'a b c'))
(tokenize( 'a,b,,c', ','))
(tokenize( 'a,b,c', ','))
(tokenize( 'a b c', '\s'))
(tokenize( 'a b c', '\s+'))
(tokenize( 'a, b, c', '[,\s]+'))
(tokenize( 'abc', '\s'))
(tokenize( 'a b c', '\s'), tokenize( 'a b c', '\s'), tokenize( 'a b c', '\s+'), tokenize( ' b c', '\s'), tokenize( 'a,b,c', ','), tokenize( 'a,b,,c', ','), tokenize( 'a, b, c', '[,\s]+'), tokenize( '2006-12-25T12:15:00', '[\-T:]'), tokenize( 'Hello, there.', '\W+'), tokenize( (), '\s+'), tokenize( 'abc', '\s'), tokenize( 'a,xb,xc', ',|,x'))
(tokenize( 'a,xb,xc', ',|,x'))
(tokenize( ' b c', '\s'))
(tokenize( 'Hello, there.', '\W+'))
(tokenize( (), '\s+'))
<top_section_count> { count(/book/section) } </top_section_count>
translate()
(translate('1999/01/02', '/', '-'))
(translate('1999/01/02', '/', '-'), translate('xml query', 'qlmx', 'QLMX'), translate('xml query', 'qlmx ', 'Q'), translate('xml query', 'qlmx ', ''), translate('xml query', 'abcd', 'ABCD'), translate('', 'qlmx ', 'Q'), translate((), 'qlmx ', 'Q'))
translate(1,'-','x')
translate("--aaa--","abc-","ABC") eq "AAA"
translate("--aaa--","bbb++","") eq "--aaa--"
translate("--aaa--","-","") eq "aaa"
translate('abc')
translate('abc',1,'x')
translate('---abcABCxyz---','-abcABCxyz','1ABCabcXYZ')
translate("abcdabc", "abc", "AB") eq "ABdAB"
translate("abc𝅖def", "𝅖", "#")
translate("abc𝅖def", "𝅖de", "#DE")
translate("abc𝅖def", "def", "𝅖EF")
translate("abcd", "xa", "𐀁y")
translate("abcd", "𐀁a", "xy")
translate("abcd𐀄e", "a𐀄e", "XYZ")
translate("abcd𐀄e", "a𐀄e", "𐀆YZ")
translate('abc','x',1)
translate("abc&#x1D156;def", "def", "&#x1D156;EF")
translate("abc&#x1D156;def", "&#x1D156;", "#")
translate("abc&#x1D156;def", "&#x1D156;de", "#DE")
translate("arg", "map string", "transString", "wrong param")
translate("argstr", "", "matrs") eq "argstr"
translate("bar","abc","ABC") eq "BAr"
translate(codepoints-to-string(65536 to 65537),codepoints-to-string(65536 to 65537),"l")
translate((), "map", "trans") eq ""
translate('newline tab space ','  ','123')
(translate('', 'qlmx ', 'Q'))
(translate((), 'qlmx ', 'Q'))
translate("string", "map string")
translate('','-','x')
translate((),'-','x')
(translate('xml query', 'abcd', 'ABCD'))
(translate('xml query', 'qlmx ', ''))
(translate('xml query', 'qlmx ', 'Q'))
(translate('xml query', 'qlmx', 'QLMX'))
(true())
true()
true(1)
true() and count((1, 2, 3, timezone-from-time(current-time()), 4))
true() and false()
true() and true()
'true' castable as xs:boolean
'true' cast as xs:boolean eq true()
true() cast as xs:string eq "true"
true() cast as xs:untypedAtomic eq xs:untypedAtomic("true")
true() cast as xs:untypedAtomic instance of xs:untypedAtomic
true() eq (every $a in 1 satisfies $a)
true() eq (every $fn:name in (1, 2) satisfies $fn:name)
true() eq (every $xs:name in (1, 2) satisfies $xs:name)
true() eq (some $a in 1 satisfies $a)
true() eq (some $fn:name in (1, 2) satisfies $fn:name)
true() eq (some $xs:name in (1, 2) satisfies $xs:name)
true() eq true()
((true() eq true()) eq true()) eq true()
true() eq true() eq true() eq true()
true() ge false()
true() ge true()
true() gt false()
true() le true()
true() ne false()
true() or false()
true() or true()
(true() < true()) < true()
true() < true() < true()
((true() = true()) = true()) = true()
true() = true() = true() = true()
true() > xs:untypedAtomic("false")
true() >= xs:untypedAtomic("false")
(true() = xs:untypedAtomic("true"))
true() <= xs:untypedAtomic("true")
()("two")
typeswitch()
typeswitch (10)  case $i as xs:integer return 1  default $v return 0
typeswitch (1, 2, 3) case $i as node() return <e/> case xs:integer* return $i default return true()
typeswitch(123)          case $i as xs:string return <wrap>test failed</wrap>          case $i as xs:double return <wrap>test failed</wrap>          case $i as xs:anyURI return <wrap>test failed</wrap>          default return <wrap>test passed - 123 is an integer (not an option on any cases)</wrap>
typeswitch(123)          case $i as xs:string return <wrap>test failed</wrap>          case $i as xs:double return <wrap>test failed</wrap>          case $i as xs:integer return <wrap>test passed - If a dynamic error is generated, then test failed.</wrap>          default return 12 div 0
typeswitch (1, 2, 3) case node() return $i case $i as xs:integer return 1 default return true()
typeswitch (1, 2, 3) case node() return <e/> case $i as xs:integer return 1 default return $i
typeswitch (1, 2, 3) case node() return <e/> case $i as xs:integer return 3 default return 1, $i
typeswitch (1, 2, 3) case node() return <e/> case xs:integer* return $i default $i return 1
typeswitch (1, 2, 3) case node() return <e/> case xs:integer return 3 default $i as item() return 1
typeswitch (1, 2, 3) case node() return <e/> case xs:integer return 3 default $i return 1, $i
typeswitch (1, 2, 3) case node() return <e/> default $i return 1 , typeswitch (1, 2, 3) case xs:integer* return $i default return 1
(typeswitch(1, 2, 3) case xs:string+ return -1 case xs:integer+ return 1 default return -2) eq 1
typeswitch (1267.43233E12)          case $i as xs:string return <wrap>test failed</wrap>          case $i as xs:integer return <wrap>test failed</wrap>          case $i as xs:double return <wrap>test passed - 1267.43233E12 is a double type</wrap>          default return <wrap>test failed</wrap>
typeswitch(1 > 2) case $i as xs:string return <wrap>test failed</wrap>          case $i as xs:integer return <wrap>test failed</wrap>          case $i as xs:boolean return <wrap>test passed - 1 > 2 is a boolean type</wrap>          default return <wrap>test failed</wrap>
(typeswitch((1, 2)) case xs:integer return -1 case xs:integer+ return 1 default return -2) eq 1
(typeswitch(1, 2, current-time()) case element() return -1 case document-node() return -2 default return 1) eq 1
(typeswitch((1, "a string")) case xs:integer return -1 case xs:string return -2 case xs:anyAtomicType+ return 1 default return -3) eq 1
typeswitch (1)          case $i as xs:double return <wrap>test failed</wrap>          case $i as xs:integer return 10 div 2          case $i as xs:string return <wrap>test failed</wrap>          default return <wrap>test failed</wrap>
typeswitch (1)          case $i as xs:double return <wrap>test failed</wrap>          case $i as xs:integer return 10 idiv 2          case $i as xs:string return <wrap>test failed</wrap>          default return <wrap>test failed</wrap>
typeswitch (1)          case $i as xs:double return <wrap>test failed</wrap>          case $i as xs:integer return 5 * 2          case $i as xs:string return <wrap>test failed</wrap>          default return <wrap>test failed</wrap>
typeswitch (1)          case $i as xs:double return <wrap>test failed</wrap>          case $i as xs:integer return 5 - 3          case $i as xs:string return <wrap>test failed</wrap>          default return <wrap>test failed</wrap>
typeswitch (1)          case $i as xs:double return <wrap>test failed</wrap>          case $i as xs:integer return fn:count((1, 2, 3))          case $i as xs:string return <wrap>test failed</wrap>          default return <wrap>test failed</wrap>
typeswitch 1 case node() return 0 case xs:integer return 3 default return true()
(typeswitch(((1, current-time())[1])) case element() return -1 case xs:integer return 1 default return -2) eq 1
typeswitch ((1 to 10)[. mod 2 = 0]) case xs:integer+ return false() default return true()
typeswitch ((1 to 10)[. mod 2 = 0]) case xs:integer+ return true() default return true()
typeswitch (5.1)          case $i as xs:decimal return <wrap>test passed - 5.1 is a decimal type</wrap>          case $i as xs:float return <wrap>test failed</wrap>          case $i as xs:integer return <wrap>test failed</wrap>          case $i as xs:double return <wrap>test failed</wrap>          default return <wrap>test failed</wrap>
typeswitch (5.1)          case $i as xs:decimal return xs:decimal(1.1 + 3.1)          case $i as xs:float return <wrap>test failed</wrap>          case $i as xs:integer return <wrap>test failed</wrap>          case $i as xs:double return <wrap>test failed</wrap>          default return <wrap>test failed</wrap>
typeswitch (5.1E2)          case $i as xs:integer return <wrap>test failed2</wrap>          case $i as xs:double return <wrap>test passed - 5.1E2 is a double type</wrap>          default return <wrap>test failed</wrap>
typeswitch (5.1E2)          case $i as xs:integer return <wrap>test failed2</wrap>          case $i as xs:double return xs:double(5.1E2 + 1.1E2)          default return <wrap>test failed</wrap>
typeswitch (5)          case $i as xs:integer return <wrap>test passed - integer data type</wrap>          case $i as xs:date return <wrap>test failed</wrap>          case $i as xs:time return <wrap>test failed</wrap>          case $i as xs:string return <wrap>test failed</wrap>          default return <wrap>test failed</wrap>
typeswitch (5)          case $i as xs:integer return xs:integer(1 + 1)          case $i as xs:date return <wrap>test failed</wrap>          case $i as xs:time return <wrap>test failed</wrap>          case $i as xs:string return <wrap>test failed</wrap>          default return <wrap>test failed</wrap>
typeswitch ("A String")          case $i as xs:decimal return <wrap>test failed</wrap>          case $i as xs:integer return <wrap>test failed</wrap>          case $i as xs:string return <wrap>test passed - "A String" is a string type</wrap>          default return <wrap>test failed</wrap>
(typeswitch("a string") case xs:anyURI return -1 case xs:string return 1 default return -2) eq 1
(typeswitch("a string") case xs:untypedAtomic return -1 case xs:string return 1 default return -2) eq 1
typeswitch(current-time()) case node() return 0 case xs:integer return 3 case xs:anyAtomicType return true()
typeswitch (<e/>)   case xs:integer | xs:string return 1  default $v return 0
typeswitch(fn:true() and fn:true())          case $i as xs:string return <wrap>test failed</wrap>          case $i as xs:double return <wrap>test failed</wrap>          case $i as xs:boolean return <wrap>test passed - "fn:true() and fn:true()" should evaluate to boolean type</wrap>          default return <wrap>test failed</wrap>
typeswitch(fn:true() or fn:false())          case $i as xs:string return <wrap>test failed</wrap>          case $i as xs:double return <wrap>test failed</wrap>          case $i as xs:boolean return <wrap>test passed - "fn:true() or fn:false()" should evaluate to boolean type</wrap>          default return <wrap>test failed</wrap>
typeswitch(if (1 lt 2) then 3 else 4.5E4)          case $i as xs:string return <wrap>test failed</wrap>          case $i as xs:double return <wrap>test failed</wrap>          case $i as xs:integer return <wrap>test passed - "(1 lt 2) then 3 else 4.5E4" should evaluate to an integer</wrap>          default return <wrap>test failed</wrap>
typeswitch(xs:anyURI("http://example.com"))          case $i as xs:string return <wrap>test failed</wrap>          case $i as xs:integer return <wrap>test failed</wrap>          case $i as xs:anyURI return <wrap>test passed - xs:anyURI("http://www.example.com")is of anyURI type</wrap>          default return <wrap>test failed</wrap>
typeswitch(xs:date("1999-05-31"))          case $i as xs:string return <wrap>test failed</wrap>          case $i as xs:integer return <wrap>test failed</wrap>          case $i as xs:date return <wrap>test passed - xs:date("1999-05-31")is of date type</wrap>          default return <wrap>test failed</wrap>
typeswitch(xs:dateTime("1999-12-31T19:20:00"))          case $i as xs:string return <wrap>test failed</wrap>          case $i as xs:integer return <wrap>test failed</wrap>          case $i as xs:dateTime return <wrap>test passed - xs:dateTime("1999-12-31T19:20:00")is of dateTime type</wrap>          default return <wrap>test failed</wrap>
typeswitch (xs:error(1))              case xs:error return fn:true()             default return false()
typeswitch(xs:time("12:00:00"))          case $i as xs:string return <wrap>test failed</wrap>          case $i as xs:integer return <wrap>test failed</wrap>          case $i as xs:time return <wrap>test passed - xs:time("12:00:00")is of time type</wrap>          default return <wrap>test failed</wrap>
('un' ||  'grateful')
@unknownprefix:*
unknownprefix:*
unordered()
unordered(1, 2)
unordered(1) eq 1
unparsed-entity-public-id("entity")
unparsed-entity-public-id("str")
unparsed-entity-uri("example.com/file.ext")
unparsed-entity-uri("str")
"untyped a " cast as xs:untypedAtomic eq xs:untypedAtomic("untyped a ")
upper-case()
upper-case("abCd0") eq "ABCD0"
upper-case(()) eq ""
(upper-case('query'))
(upper-case('Query'))
(upper-case('QUERY'))
(upper-case('query-123'))
(upper-case('query'), upper-case('QUERY'), upper-case('Query'), upper-case('query-123'))
upper-case("string", "wrong param")
upper-case(typeswitch ((1 to 10)[. div 2 = 0]) case xs:integer+ return "int" default return "false")
upper-case(typeswitch ((1 to 10)[. mod 2 = 0]) case xs:integer+ return "int" default return "false")
validate { }
validate lax { }
validate strict { }
<?validchar content a b c asdada dad ?> eq "content a b c asdada dad "
<?validchar content ?> eq "content "
<?validchar ???<<???? <? >?hm???> eq "???<<???? <? >?hm??"
variable lt variable
" white space left alone" cast as xs:string eq xs:string(" white space left alone")
(/works[1]/employee[11]/following::employee[1]) << (/works[1]/employee[13])
(/works[1]/employee[12]/following::employee) and fn:false()
(/works[1]/employee[12]/following::employee) and fn:true()
(/works[1]/employee[12]/following::employee) or fn:false()
(/works[1]/employee[12]/following::employee) or fn:true()
(/works[1]/employee[12]/following-sibling::employee) and fn:false()
(/works[1]/employee[12]/following-sibling::employee) and fn:true()
(/works[1]/employee[12]/following-sibling::employee) or fn:false()
(/works[1]/employee[12]/following-sibling::employee) or fn:true()
(/works[1]/employee[12]/overtime[1]/day[1]/following::day) intersect (/works[1]/employee[12]/overtime[1]/day[1]/following::day)
(/works[1]/employee[12]/overtime[1]/day[1]/following-sibling::day) intersect (/works[1]/employee[12]/overtime[1]/day[1]/following-sibling::day)
(/works[1]/employee[12]/overtime[1]/day[2]/preceding::day) intersect (/works[1]/employee[12]/overtime[1]/day[2]/preceding::day)
(/works[1]/employee[12]/overtime[1]/day[2]/preceding-sibling::day) intersect (/works[1]/employee[12]/overtime[1]/day[2]/preceding-sibling::day)
(/works[1]/employee[12]/overtime/day) except (/works[1]/employee[12]/overtime/day[1]/following::day)
(/works[1]/employee[12]/overtime/day) except (/works[1]/employee[12]/overtime/day[1]/following-sibling::day)
(/works[1]/employee[12]/overtime/day) except (/works[1]/employee[12]/overtime/day[2]/preceding::day)
(/works[1]/employee[12]/overtime/day) except (/works[1]/employee[12]/overtime/day[2]/preceding-sibling::day)
(/works[1]/employee[12]/preceding::employee) and fn:false()
(/works[1]/employee[12]/preceding::employee) and fn:true()
(/works[1]/employee[12]/preceding::employee) or fn:false()
(/works[1]/employee[12]/preceding::employee) or fn:true()
(/works[1]/employee[12]/preceding-sibling::employee) and fn:false()
(/works[1]/employee[12]/preceding-sibling::employee) and fn:true()
(/works[1]/employee[12]/preceding-sibling::employee) or fn:false()
(/works[1]/employee[12]/preceding-sibling::employee) or fn:true()
/works[1]/employee[1]/empnum[1] << <a>50000</a>
/works[1]/employee[1]/empnum[1] >> <a>50000</a>
/works[1]/employee[1]/empnum[1] is <a>50000</a>
/works[1]/employee[1]/empnum[1] is /works[1]/employee[1]/empnum[1]
/works[1]/employee[1]/empnum[1] << /works[1]/employee[1]/empnum[1]
/works[1]/employee[1]/empnum[1] >> /works[1]/employee[1]/empnum[1]
/works[1]/employee[2]/preceding::employee
(/works[1]//employee[empnum != "E1" and empnum != "E4"])
(/works//day[xs:string(.) ne "Monday"])
./works/employee[1]
works/employee[1]
((/works/employee[12]/*/day[1]/ancestor-or-self::overtime) | (/works/employee[12]/*/day[2]/ancestor-or-self::overtime))/count(*)
(/works/employee[12]/*/day[1]/ancestor::overtime) | (/works/employee[12]/*/day[2]/ancestor::overtime)
(/works/employee[12]/*/day[1]/following::day) | (/works/employee[12]/*/day[1])
(/works/employee[12]/*/day[1]/following::day) | (/works/employee[12]/*/day[1]/following::day)
(/works/employee[12]/*/day[1]/following-sibling::day) | (/works/employee[12]/*/day[1])
(/works/employee[12]/*/day[1]/following-sibling::day) | (/works/employee[12]/*/day[1]/following-sibling::day)
(/works/employee[12]/*/day[2]/preceding::day) | (/works/employee[12]/*/day[2])
(/works/employee[12]/*/day[2]/preceding::day) | (/works/employee[12]/*/day[2]/preceding::day)
(/works/employee[12]/*/day[2]/preceding-sibling::day) | (/works/employee[12]/*/day[2])
(/works/employee[12]/*/day[2]/preceding-sibling::day) | (/works/employee[12]/*/day[2]/preceding-sibling::day)
((/works/employee[12]/*/day/ancestor-or-self::overtime) | (/works/employee[12]/*/day/ancestor-or-self::overtime))/count(*)
(/works/employee[12]/*/day/ancestor::overtime) | (/works/employee[12]/*/day/ancestor::overtime)
(/works/employee[12]/overtime/day/ancestor::employee) intersect (/works/employee[12]/overtime/day/ancestor::employee)
((/works/employee[12]/overtime/day/ancestor-or-self::employee) intersect (/works/employee[12]/overtime/day/ancestor-or-self::employee))/@name
(/works/employee[12]/overtime/day[ancestor-or-self::overtime]) and fn:false()
(/works/employee[12]/overtime/day[ancestor-or-self::overtime]) and fn:true()
(/works/employee[12]/overtime/day[ancestor-or-self::overtime]) except (/works/employee[12]/overtime/day[1])
(/works/employee[12]/overtime/day[ancestor-or-self::overtime]) or fn:false()
(/works/employee[12]/overtime/day[ancestor-or-self::overtime]) or fn:true()
(/works/employee[12]/overtime/day[ancestor::overtime]) and fn:false()
(/works/employee[12]/overtime/day[ancestor::overtime]) and fn:true()
(/works/employee[12]/overtime/day[ancestor::overtime]) except (/works/employee[12]/overtime/day[1])
(/works/employee[12]/overtime/day[ancestor::overtime]) or fn:false()
(/works/employee[12]/overtime/day[ancestor::overtime]) or fn:true()
() != (/works/employee[1]/hours[1])
() < (/works/employee[1]/hours[1])
() <= (/works/employee[1]/hours[1])
() = (/works/employee[1]/hours[1])
() > (/works/employee[1]/hours[1])
() >= (/works/employee[1]/hours[1])
(/works/employee[1]/hours[1]) != ()
(/works/employee[1]/hours[1]) < ()
(/works/employee[1]/hours[1]) <= ()
(/works/employee[1]/hours[1]) = ()
(/works/employee[1]/hours[1]) > ()
(/works/employee[1]/hours[1]) >= ()
(/works/employee[1]/hours[1]) != 10000
(/works/employee[1]/hours[1]) < 10000
(/works/employee[1]/hours[1]) <= 10000
(/works/employee[1]/hours[1]) = 10000
(/works/employee[1]/hours[1]) > 10000
(/works/employee[1]/hours[1]) >= 10000
(/works/employee[1]/hours[1]) != (10000,50000)
(/works/employee[1]/hours[1]) < (10000,50000)
(/works/employee[1]/hours[1]) <= (10000,50000)
(/works/employee[1]/hours[1]) = (10000,50000)
(/works/employee[1]/hours[1]) > (10000,50000)
(/works/employee[1]/hours[1]) >= (10000,50000)
(/works/employee[1]/hours[1]) != (50000)
(/works/employee[1]/hours[1]) < (50000)
(/works/employee[1]/hours[1]) <= (50000)
(/works/employee[1]/hours[1]) = (50000)
(/works/employee[1]/hours[1]) > (50000)
(/works/employee[1]/hours[1]) >= (50000)
(/works/employee[1]/hours[1]) != (<a>10000</a>)
(/works/employee[1]/hours[1]) != <a>10000</a>
(/works/employee[1]/hours[1]) < (<a>10000</a>)
(/works/employee[1]/hours[1]) < <a>10000</a>
(/works/employee[1]/hours[1]) <= (<a>10000</a>)
(/works/employee[1]/hours[1]) <= <a>10000</a>
(/works/employee[1]/hours[1]) = (<a>10000</a>)
(/works/employee[1]/hours[1]) = <a>10000</a>
(/works/employee[1]/hours[1]) > (<a>10000</a>)
(/works/employee[1]/hours[1]) > <a>10000</a>
(/works/employee[1]/hours[1]) >= (<a>10000</a>)
(/works/employee[1]/hours[1]) >= <a>10000</a>
(/works/employee[1]/hours[1]) != (<a>10000</a>,<b>50000</b>)
(/works/employee[1]/hours[1]) < (<a>10000</a>,<b>50000</b>)
(/works/employee[1]/hours[1]) <= (<a>10000</a>,<b>50000</b>)
(/works/employee[1]/hours[1]) = (<a>10000</a>,<b>50000</b>)
(/works/employee[1]/hours[1]) > (<a>10000</a>,<b>50000</b>)
(/works/employee[1]/hours[1]) >= (<a>10000</a>,<b>50000</b>)
(/works/employee[1]/hours[1]) != (/works/employee[1]/hours[1])
(/works/employee[1]/hours[1]) < (/works/employee[1]/hours[1])
(/works/employee[1]/hours[1]) <= (/works/employee[1]/hours[1])
(/works/employee[1]/hours[1]) = (/works/employee[1]/hours[1])
(/works/employee[1]/hours[1]) > (/works/employee[1]/hours[1])
(/works/employee[1]/hours[1]) >= (/works/employee[1]/hours[1])
(/works/employee[1]/hours[1]) != (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(/works/employee[1]/hours[1]) < (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(/works/employee[1]/hours[1]) <= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(/works/employee[1]/hours[1]) = (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(/works/employee[1]/hours[1]) > (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(/works/employee[1]/hours[1]) >= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
() != (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
() < (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
() <= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
() = (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
() > (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
() >= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) != ()
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) < ()
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) <= ()
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) = ()
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) > ()
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) >= ()
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) != 10000
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) < 10000
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) <= 10000
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) = 10000
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) > 10000
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) >= 10000
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) != (10000,50000)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) < (10000,50000)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) <= (10000,50000)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) = (10000,50000)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) > (10000,50000)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) >= (10000,50000)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) != (50000)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) < (50000)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) <= (50000)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) = (50000)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) > (50000)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) >= (50000)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) != (<a>10000</a>)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) != <a>10000</a>
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) < (<a>10000</a>)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) < <a>10000</a>
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) <= (<a>10000</a>)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) <= <a>10000</a>
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) = (<a>10000</a>)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) = <a>10000</a>
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) > (<a>10000</a>)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) > <a>10000</a>
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) >= (<a>10000</a>)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) >= <a>10000</a>
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) != (<a>10000</a>,<b>50000</b>)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) < (<a>10000</a>,<b>50000</b>)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) <= (<a>10000</a>,<b>50000</b>)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) = (<a>10000</a>,<b>50000</b>)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) > (<a>10000</a>,<b>50000</b>)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) >= (<a>10000</a>,<b>50000</b>)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) != (/works/employee[1]/hours[1])
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) < (/works/employee[1]/hours[1])
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) <= (/works/employee[1]/hours[1])
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) = (/works/employee[1]/hours[1])
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) > (/works/employee[1]/hours[1])
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) >= (/works/employee[1]/hours[1])
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) != (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) < (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) <= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) = (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) > (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) >= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
/ works ! employee[2] ! hours[2] ! number()
(/works/employee[2], /works/employee[1], /works/employee[2]) ! @name ! string()
/ works ! employee[4] ! preceding-sibling::*[1] ! string(@name)
/works/employee[5]/hours[2]
/works/employee/*/last()
(/works/employee[@name="Jane Doe 11"])
/works/employee[@name=/works/employee[1]/@name]/@name/string()
/works/employee/*/position()
(/works/employee[xs:integer(hours[1]) gt 20])
(/works//hours[xs:integer(.) <= 12])
(/works//hours[xs:integer(.) = 12])
(/works//hours[xs:integer(.) < 13])
(/works//hours[xs:integer(.) > 79])
(/works//hours[xs:integer(.) >= 80])
(/works//hours[xs:integer(.) ge 80])
(/works//hours[xs:integer(.) gt 79])
(/works//hours[xs:integer(.) le 12])
(/works//hours[xs:integer(.) lt 13])
works/@id eq "abc"
works/@id ne "abc"
'&#x;'
'&#x0;'
"&#x00;"
'&#x100000000'
'&#x100000000x'
"&#x+20;"
"&#x-20;"
"&#X4A;"
"&#x9;" castable as xs:normalizedString
"&#x9;" castable as xs:token
"&#xD;&#xA;&#x9; foobar &#xA;&#xD;&#x9;" castable as xs:NMTOKEN
<XMark-result-Q15> {              let $auction := (/) return              for $a in $auction/site/closed_auctions/closed_auction/annotation/description/parlist/                 listitem/ parlist/ listitem/ text/ emph/ keyword/ text()              return <text>{$a}</text> } </XMark-result-Q15>
<XMark-result-Q17> {              let $auction := (/)              return for $p in $auction/site/people/person              where empty($p/homepage/text())              return <person name="{$p/name/text()}"/> } </XMark-result-Q17>
<XMark-result-Q1> {              let $auction := (/)             return for $b in $auction/site/people/person[@id = "person0"]              return $b/name/text() } </XMark-result-Q1>
<XMark-result-Q20> {              let $auction := (/) return                 <result>                    <preferred> {count($auction/site/people/person/profile[@income >= 100000.0])} </preferred>                   <standard> { count( $auction/site/people/person/ profile[@income < 100000.0 and @income >= 30000.0] ) } </standard>                   <challenge> {count($auction/site/people/person/profile[@income < 30000.0])} </challenge>                   <na> { count( for $p in $auction/site/people/person where empty($p/profile/@income) return $p ) } </na>                </result> } </XMark-result-Q20>
<XMark-result-Q2> {              let $auction := (/)              return for $b in $auction/site/open_auctions/open_auction              return <increase>{$b/bidder[1]/increase/text()}</increase> } </XMark-result-Q2>
<XMark-result-Q5> {            let $auction := (/) return count(             for $i in $auction/site/closed_auctions/closed_auction              where $i/price/text() >= 40.0 return $i/price) }          </XMark-result-Q5>
<XMark-result-Q6> {              let $auction := (/) return for $b in $auction//site/regions return count($b//item) }          </XMark-result-Q6>
<XMark-result-Q7> { let $auction := (/) return for $p in $auction/site return count($p//description) + count($p//annotation) + count($p//emailaddress) } </XMark-result-Q7>
<?xml ?>
<?xml?>
<?xMl?>
<?XmL ?>
<?XmL?>
<?XML ?>
<?XML?>
<?xml:char ?>
<xml:new/>
@xmlns:*
xmlns:*
@xmlns:ncname
xmlns:ncname
xquery encoding "utf-8"; 1 eq 1
xquery encoding "utf-8" version "3.0"; 1
xquery gt xquery
xquery version; 1
xquery version "1.0"; <bib/>
"xquery version '1.0' encoding 'UTF-8|#%';" eq "xquery version '1.0' encoding 'UTF-8|#%';"
'xquery version "1.0" encoding "UTF-8|#%";' eq 'xquery version "1.0" encoding "UTF-8|#%";'
xquery version "1.0" (:encoding "utf-8xx":); 1,2
xquery version '1.0' encoding 'UTF&#x2d;8'; true()
xquery version '1&#x2e;0' encoding 'UTF-8'; true()
xquery version "2.0"; 1.2
xquery version "3.0"; 1,2
xquery version "3.0" ; 1 eq 1
xquery version "3.0"; <bib/>
xquery version "3.0";        declare function local:square($i as xs:integer) as xs:integer { $i*$i };         function-lookup(QName("http://www.w3.org/2005/xquery-local-functions", "square"), 1)(13)
xquery version "3.0";        declare %private function local:square($i as xs:integer) as xs:integer { $i*$i };         function-lookup(QName("http://www.w3.org/2005/xquery-local-functions", "square"), 1)(13)
xquery version "3.0";        declare %private function local:square($i as xs:integer) as xs:integer { $i*$i };         function-lookup(QName("http://www.w3.org/2005/xquery-local-functions", "square"), 1)(13, 12)
xquery version "3.0";        declare %private function local:square($i as xs:integer) as xs:integer { $i*$i };         function-lookup(QName("http://www.w3.org/2005/xquery-local-functions", "square"), 1)("banana")
xquery version "3.0" default; 1
xquery version "3.0" encoding "US-ASCII"; 1,2
xquery version "3.0" encoding "utf-8"; 1,2
xquery version "3.1"; 1,2
xquery version "3.1" ; 1 eq 1
xquery version "3.1"; <bib/>
xquery, version, encoding, default, declare, function, option, collation, schema, import
xs:anyAtomic("1")
xs:anyURI("〜")
xs:anyURI(())
xs:anyURI()
xs:anyURI("0") < 1
xs:anyURI("2") > 1
xs:anyURI("") eq xs:anyURI("")
(xs:anyURI("example.com/"), 1, QName("example.com", "ncname"), false(), xs:hexBinary("FF")) = (xs:anyURI("example.com/NOT"), 0, QName("example.com", "p:ncname"), true(), xs:hexBinary("EF"))
xs:anyURI("example.com/") and xs:anyURI("example.com/")
xs:anyURI("example.com/") cast as xs:anyURI eq xs:anyURI('example.com/')
xs:anyURI("example.com/") eq xs:anyURI("example.com/")
xs:anyURI("example.com/") eq xs:string("example.com/")
xs:anyURI("example.com/") eq xs:untypedAtomic("example.com/")
xs:anyURI("example.com/") != false()
xs:anyURI("example.com/") = false()
xs:anyURI("example.com/") ne xs:anyURI("example.com/No")
xs:anyURI("example.com/") ne xs:string("example.com/No")
xs:anyURI("example.com/") ne xs:untypedAtomic("example.com/No")
xs:anyURI("example.com/") or 0
xs:anyURI("foo://")
xs:anyURI("http://!$&'()*+,;=/")
xs:anyURI("http://!$&amp;'()*+,;=/")
xs:anyURI("http://%0Ad%E2%9C%90%F0%98%9A%A0/")
xs:anyURI("http://example.com/A") eq xs:anyURI("http://example.com/A")
xs:anyURI("http://example.com/A") eq xs:string("http://example.com/A")
xs:anyURI("http://example.com/A") le xs:anyURI("http://example.com/A")
xs:anyURI("http://example.com/A") le xs:anyURI("http://example.com/B")
xs:anyURI("http://example.com/A") lt xs:anyURI("http://example.com/B")
xs:anyURI("http://example.com/A") ne xs:anyURI("http://example.com/B")
xs:anyURI("http://example.com/A") ne xs:string("http://example.com/B")
xs:anyURI("http://example.com/B") ge xs:anyURI("http://example.com/A")
xs:anyURI("http://example.com/B") gt xs:anyURI("http://example.com/A")
xs:anyURI("http://example.com/B") gt xs:string("http://example.com/A")
xs:anyURI(" http://example.com/ foo.xml ")
xs:anyURI("http:\\invalid>URI\someURI")
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:anyURI
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:string
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:untypedAtomic
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:anyURI eq xs:anyURI("http://www.example.com/an/arbitrary/URI.ext")
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:base64Binary
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:boolean
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:date
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:dateTime
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:dayTimeDuration
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:decimal
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:double
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:duration
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:float
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:gDay
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:gMonth
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:gMonthDay
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:gYear
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:gYearMonth
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:hexBinary
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:integer
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:string ne xs:string("an arbitrary string")
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:time
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:untypedAtomic       ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:yearMonthDuration
xs:anyURI(" http://www.example.com/an/arbitrary/URI.ext ") eq xs:anyURI(" http://www.example.com/an/arbitrary/URI.ext ")
xs:anyURI( "http://www.example.com/an/arbitrary/URI.ext" , "http://www.example.com/an/arbitrary/URI.ext" )
xs:anyURI("http://www.example.com") instance of xs:anyURI
xs:anyURI("http://www.example.com/") instance of xs:anyURI
xs:anyURI("http://www.example.com") instance of xs:boolean
xs:anyURI("http://www.example.com") instance of xs:date
xs:anyURI("http://www.example.com") instance of xs:dateTime
xs:anyURI("http://www.example.com") instance of xs:decimal
xs:anyURI("http://www.example.com") instance of xs:double
xs:anyURI("http://www.example.com") instance of xs:float
xs:anyURI("http://www.example.com") instance of xs:int
xs:anyURI("http://www.example.com") instance of xs:integer
xs:anyURI("http://www.example.com") instance of xs:string
xs:anyURI("http://www.example.com") instance of xs:time
(xs:anyURI("http://www.example.com"),xs:anyURI("http://www.example1.com"))
(xs:anyURI("http://www.example/com")) < (xs:anyURI("http://www.example/com"))
(xs:anyURI("http://www.example/com")) <= (xs:anyURI("http://www.example/com"))
(xs:anyURI("http://www.example/com")) > (xs:anyURI("http://www.example/com"))
(xs:anyURI("http://www.example/com")) >= (xs:anyURI("http://www.example/com"))
xs:anyURI("http://www.example.org/#:@")
xs:anyURI("http://www.example.org/:/@/")
xs:anyURI("http://www.example.org/?:@")
xs:anyURI("http://www.example.org/!/$/&/'/(/)/*/+/,/;/=/")
xs:anyURI("http://www.example.org/#!$&'()*+,;=")
xs:anyURI("http://www.example.org/?!$&'()*+,;=")
xs:anyURI("http://www.example.org/#!$&amp;'()*+,;=")
xs:anyURI("http://www.example.org/?!$&amp;'()*+,;=")
xs:anyURI("http://www.example.org/!/$/&amp;/'/(/)/*/+/,/;/=/")
xs:anyURI("http://www.example.org/#%0Ad%E2%9C%90%F0%98%9A%A0/")
xs:anyURI("http://www.example.org/%0Ad%E2%9C%90%F0%98%9A%A0/")
xs:anyURI("http://www.example.org/?%0Ad%E2%9C%90%F0%98%9A%A0/")
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:anyURI
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:base64Binary
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:boolean
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:date
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:dateTime
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:dayTimeDuration
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:decimal
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:double
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:duration
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:float
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:gDay
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:gMonth
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:gMonthDay
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:gYear
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:gYearMonth
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:hexBinary
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:integer
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:string
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:time
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:untypedAtomic
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:yearMonthDuration
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:anyURI
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:base64Binary
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:boolean
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:date
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:dateTime
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:dayTimeDuration
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:decimal
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:double
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:duration
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:float
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:gDay
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:gMonth
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:gMonthDay
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:gYear
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:gYearMonth
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:hexBinary
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:integer
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:string
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:time
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:untypedAtomic
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:yearMonthDuration
xs:anyURI("odd-scheme+1.://www.example.org/")
xs:anyURI("//server/share/dir1")
xs:anyURI("www.example.com") , xs:decimal("1.01")
xs:anyURI(xs:untypedAtomic( "http://www.example.com/an/arbitrary/URI.ext" ))        eq xs:anyURI("http://www.example.com/an/arbitrary/URI.ext")
xs:base64Binary("")
xs:base64Binary()
xs:base64Binary("00000000") castable as xs:hexBinary
xs:base64Binary("00000000") cast as xs:hexBinary
xs:base64Binary("01001010") castable as xs:base64Binary
xs:base64Binary("01001010") castable as xs:string
xs:base64Binary("01001010") castable as xs:untypedAtomic
xs:base64Binary("01001010") cast as xs:base64Binary
xs:base64Binary("01001010") cast as xs:string
xs:base64Binary("01001010") cast as xs:untypedAtomic
xs:base64Binary("0FB7") castable as xs:base64Binary
xs:base64Binary("0FB7") castable as xs:hexBinary
xs:base64Binary("0FB7") castable as xs:string
xs:base64Binary("0FB7") castable as xs:untypedAtomic
xs:base64Binary("0FB7") cast as xs:base64Binary
xs:base64Binary("0FB7") cast as xs:hexBinary
xs:base64Binary("0FB7") cast as xs:string
xs:base64Binary("0FB7") cast as xs:untypedAtomic
xs:base64Binary("10010101") castable as xs:anyURI
xs:base64Binary("10010101") castable as xs:boolean
xs:base64Binary("10010101") castable as xs:date
xs:base64Binary("10010101") castable as xs:dateTime
xs:base64Binary("10010101") castable as xs:dayTimeDuration
xs:base64Binary("10010101") castable as xs:decimal
xs:base64Binary("10010101") castable as xs:double
xs:base64Binary("10010101") castable as xs:duration
xs:base64Binary("10010101") castable as xs:float
xs:base64Binary("10010101") castable as xs:gDay
xs:base64Binary("10010101") castable as xs:gMonth
xs:base64Binary("10010101") castable as xs:gMonthDay
xs:base64Binary("10010101") castable as xs:gYear
xs:base64Binary("10010101") castable as xs:gYearMonth
xs:base64Binary("10010101") castable as xs:hexBinary
xs:base64Binary("10010101") castable as xs:integer
xs:base64Binary("10010101") castable as xs:time
xs:base64Binary("10010101") castable as xs:yearMonthDuration
xs:base64Binary("10010101") cast as xs:anyURI
xs:base64Binary("10010101") cast as xs:boolean
xs:base64Binary("10010101") cast as xs:date
xs:base64Binary("10010101") cast as xs:dateTime
xs:base64Binary("10010101") cast as xs:dayTimeDuration
xs:base64Binary("10010101") cast as xs:decimal
xs:base64Binary("10010101") cast as xs:double
xs:base64Binary("10010101") cast as xs:duration
xs:base64Binary("10010101") cast as xs:float
xs:base64Binary("10010101") cast as xs:gDay
xs:base64Binary("10010101") cast as xs:gMonth
xs:base64Binary("10010101") cast as xs:gMonthDay
xs:base64Binary("10010101") cast as xs:gYear
xs:base64Binary("10010101") cast as xs:gYearMonth
xs:base64Binary("10010101") cast as xs:hexBinary
xs:base64Binary("10010101") cast as xs:integer
xs:base64Binary("10010101") cast as xs:time
xs:base64Binary("10010101") cast as xs:yearMonthDuration
xs:base64Binary( "aaaa" , "aaaa" )
xs:base64Binary("aaaa") castable as xs:base64Binary
xs:base64Binary("aaaa") castable as xs:hexBinary
xs:base64Binary("aaaa") castable as xs:string
xs:base64Binary("aaaa") castable as xs:untypedAtomic
xs:base64Binary("aaaa") cast as xs:anyURI
xs:base64Binary("aaaa") cast as xs:base64Binary eq xs:base64Binary("aaaa")
xs:base64Binary("aaaa") cast as xs:boolean
xs:base64Binary("aaaa") cast as xs:date
xs:base64Binary("aaaa") cast as xs:dateTime
xs:base64Binary("aaaa") cast as xs:dayTimeDuration
xs:base64Binary("aaaa") cast as xs:decimal
xs:base64Binary("aaaa") cast as xs:double
xs:base64Binary("aaaa") cast as xs:duration
xs:base64Binary("aaaa") cast as xs:float
xs:base64Binary("aaaa") cast as xs:gDay
xs:base64Binary("aaaa") cast as xs:gMonth
xs:base64Binary("aaaa") cast as xs:gMonthDay
xs:base64Binary("aaaa") cast as xs:gYear
xs:base64Binary("aaaa") cast as xs:gYearMonth
xs:base64Binary("aaaa") cast as xs:hexBinary ne xs:hexBinary("0FB7")
xs:base64Binary("aaaa") cast as xs:integer
xs:base64Binary("aaaa") cast as xs:string ne xs:string("an arbitrary string")
xs:base64Binary("aaaa") cast as xs:time
xs:base64Binary("aaaa") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:base64Binary("aaaa") cast as xs:yearMonthDuration
xs:base64Binary(" aaaa ") eq xs:base64Binary(" aaaa ")
xs:base64Binary("aA+zZ/09") castable as xs:hexBinary
xs:base64Binary("AP9=")
xs:base64Binary("=AQI")
xs:base64Binary("AQ=I")
xs:base64Binary("AQI")
xs:base64Binary("Ay==")
xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") eq xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q")
xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") eq xs:base64Binary("cW9kanZzY3ZlaWthYXVreGxibm11dW91ZmllZGplbXZza2FqcGlwdWlxcG5xbHR4dmFjcWFjbGN1Z3BqYmVuZWhsdHhzeHZs")
xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") eq xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp")
(xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") eq xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp")) and fn:false()
(xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") eq xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp")) and fn:true()
(xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") eq xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp")) and (xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") eq xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp"))
(xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") eq xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp")) or fn:false()
(xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") eq xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp")) or fn:true()
xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") eq xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp") or xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") eq xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp")
xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") ne xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q")
xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") ne xs:base64Binary("cW9kanZzY3ZlaWthYXVreGxibm11dW91ZmllZGplbXZza2FqcGlwdWlxcG5xbHR4dmFjcWFjbGN1Z3BqYmVuZWhsdHhzeHZs")
xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") ne xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp")
(xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") ne xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp")) and fn:false()
(xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") ne xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp")) and fn:true()
(xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") ne xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp")) or fn:false()
(xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") ne xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp")) or fn:true()
(xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") ne xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp")) or (xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") ne xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp"))
xs:base64Binary(codepoints-to-string((119070, 119070, 119070, 119070) (:treble clef:)))
xs:base64Binary("cW9kanZzY3ZlaWthYXVreGxibm11dW91ZmllZGplbXZza2FqcGlwdWlxcG5xbHR4dmFjcWFjbGN1Z3BqYmVuZWhsdHhzeHZs") eq xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q")
xs:base64Binary("cW9kanZzY3ZlaWthYXVreGxibm11dW91ZmllZGplbXZza2FqcGlwdWlxcG5xbHR4dmFjcWFjbGN1Z3BqYmVuZWhsdHhzeHZs") ne xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q")
xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp") eq xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q")
xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp") ne xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q")
xs:base64Binary("") eq xs:base64Binary("")
xs:base64Binary("frfhforlksid745323==")
xs:base64Binary("gMA-")
xs:base64Binary("qrvM====")
xs:base64Binary(xs:hexBinary(""))
xs:base64Binary(xs:hexBinary("00"))
xs:base64Binary(xs:hexBinary("0000"))
xs:base64Binary(xs:hexBinary("00ff"))
xs:base64Binary(xs:hexBinary("01"))
xs:base64Binary(xs:hexBinary("010203"))
xs:base64Binary(xs:hexBinary("01020304"))
xs:base64Binary(xs:hexBinary("0102030405"))
xs:base64Binary(xs:hexBinary("010203040506"))
xs:base64Binary(xs:hexBinary("01020304050607"))
xs:base64Binary(xs:hexBinary("0102030405060708090A0B0C0D0E0F10111213131415161718191A1B1C1D1F202122232425262728292A2B2C2D2E2F"))
xs:base64Binary(xs:hexBinary("03")) eq xs:base64Binary(xs:hexBinary("03"))
xs:base64Binary(xs:hexBinary("03")) ne xs:base64Binary(xs:hexBinary("13"))
xs:base64Binary(xs:hexBinary("80c0"))
xs:base64Binary(xs:hexBinary("aabbcc"))
xs:base64Binary(xs:hexBinary("ff"))
xs:base64Binary(xs:untypedAtomic( "aaaa" )) eq xs:base64Binary("aaaa")
xs:boolean("")
xs:boolean()
xs:boolean(0.0E0) eq false()
xs:boolean('0') cast as xs:string eq 'false'
xs:boolean(+0) eq false()
xs:boolean(-0) eq false()
xs:boolean("0") eq xs:boolean("false")
xs:boolean("0") eq xs:boolean("true")
xs:boolean("0") ge xs:boolean("false")
xs:boolean("0") ge xs:boolean("true")
xs:boolean("0") gt xs:boolean("false")
xs:boolean("0") gt xs:boolean("true")
xs:boolean("0") le xs:boolean("false")
xs:boolean("0") le xs:boolean("true")
xs:boolean("0") lt xs:boolean("false")
xs:boolean("0") lt xs:boolean("true")
xs:boolean("1") eq xs:boolean("false")
xs:boolean("1") eq xs:boolean("true")
xs:boolean("1") ge xs:boolean("false")
xs:boolean("1") ge xs:boolean("true")
xs:boolean("1") gt xs:boolean("false")
xs:boolean("1") gt xs:boolean("true")
xs:boolean("1") le xs:boolean("false")
xs:boolean("1") le xs:boolean("true")
xs:boolean("1") lt xs:boolean("false")
xs:boolean("1") lt xs:boolean("true")
xs:boolean(<a>0</a>)
xs:boolean("false") castable as xs:boolean
xs:boolean("false") castable as xs:decimal
xs:boolean("false") castable as xs:double
xs:boolean("false") castable as xs:float
xs:boolean("false") castable as xs:integer
xs:boolean("false") cast as xs:boolean
xs:boolean("false") cast as xs:decimal
xs:boolean("false") cast as xs:double
xs:boolean("false") cast as xs:float
xs:boolean("false") cast as xs:integer
xs:boolean("false") eq false()
xs:boolean("false") eq true()
xs:boolean("false") eq xs:boolean("0")
xs:boolean("false") eq xs:boolean('0')
xs:boolean('false') eq xs:boolean('0')
xs:boolean("false") eq xs:boolean("1")
xs:boolean('false') eq xs:boolean('1')
xs:boolean("false") eq xs:boolean("false")
xs:boolean("false") eq xs:boolean("true")
xs:boolean("false") ge xs:boolean("0")
xs:boolean("false") ge xs:boolean("1")
xs:boolean("false") ge xs:boolean("false")
xs:boolean("false") ge xs:boolean("true")
xs:boolean("false") gt xs:boolean("0")
xs:boolean("false") gt xs:boolean("1")
xs:boolean("false") gt xs:boolean("false")
xs:boolean("false") gt xs:boolean("true")
xs:boolean("false") le xs:boolean("0")
xs:boolean("false") le xs:boolean("1")
xs:boolean("false") le xs:boolean("false")
xs:boolean("false") le xs:boolean("true")
xs:boolean("false") lt xs:boolean("0")
xs:boolean("false") lt xs:boolean("1")
xs:boolean("false") lt xs:boolean("false")
xs:boolean("false") lt xs:boolean("true")
xs:boolean("false"), xs:boolean("1")
xs:boolean(fn:codepoint-equal("aa","aa"))
xs:boolean(fn:false())
xs:boolean(fn:not("true"))
xs:boolean(fn:true())
(xs:boolean(fn:true()), fn:false(), fn:true())
(xs:boolean("true") and xs:boolean("true")) eq (xs:boolean("false") and xs:boolean("false"))
xs:boolean("true") castable as xs:anyURI
xs:boolean("true") castable as xs:base64Binary
xs:boolean("true") castable as xs:boolean
xs:boolean("true") castable as xs:date
xs:boolean("true") castable as xs:dateTime
xs:boolean("true") castable as xs:dayTimeDuration
xs:boolean("true") castable as xs:decimal
xs:boolean("true") castable as xs:double
xs:boolean("true") castable as xs:duration
xs:boolean("true") castable as xs:float
xs:boolean("true") castable as xs:gDay
xs:boolean("true") castable as xs:gMonth
xs:boolean("true") castable as xs:gMonthDay
xs:boolean("true") castable as xs:gYear
xs:boolean("true") castable as xs:gYearMonth
xs:boolean("true") castable as xs:hexBinary
xs:boolean("true") castable as xs:integer
xs:boolean("true") castable as xs:string
xs:boolean("true") castable as xs:time
xs:boolean("true") castable as xs:untypedAtomic
xs:boolean("true") castable as xs:yearMonthDuration
xs:boolean("true") cast as xs:anyURI
xs:boolean("true") cast as xs:base64Binary
xs:boolean("true") cast as xs:boolean
xs:boolean("true") cast as xs:boolean eq xs:boolean("true")
xs:boolean("true") cast as xs:date
xs:boolean("true") cast as xs:dateTime
xs:boolean("true") cast as xs:dayTimeDuration
xs:boolean("true") cast as xs:decimal
xs:boolean("true") cast as xs:decimal ne xs:decimal("10.01")
xs:boolean("true") cast as xs:double
xs:boolean("true") cast as xs:double ne xs:double("3.3e3")
xs:boolean("true") cast as xs:duration
xs:boolean("true") cast as xs:float
xs:boolean("true") cast as xs:float ne xs:float("3.4e5")
xs:boolean("true") cast as xs:gDay
xs:boolean("true") cast as xs:gMonth
xs:boolean("true") cast as xs:gMonthDay
xs:boolean("true") cast as xs:gYear
xs:boolean("true") cast as xs:gYearMonth
xs:boolean("true") cast as xs:hexBinary
xs:boolean("true") cast as xs:integer
xs:boolean("true") cast as xs:integer ne xs:integer("6789")
xs:boolean("true") cast as xs:string
xs:boolean("true") cast as xs:string ne xs:string("an arbitrary string")
xs:boolean("true") cast as xs:time
xs:boolean("true") cast as xs:untypedAtomic
xs:boolean("true") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:boolean("true") cast as xs:yearMonthDuration
xs:boolean("true") eq false()
xs:boolean("true") eq true()
xs:boolean("true") eq xs:boolean("0")
xs:boolean('true') eq xs:boolean('0')
xs:boolean("true") eq xs:boolean("1")
xs:boolean("true") eq xs:boolean('1')
xs:boolean('true') eq xs:boolean('1')
xs:boolean("true") eq xs:boolean("false")
xs:boolean(" true ") eq xs:boolean(" true ")
xs:boolean("true") eq xs:boolean("true")
xs:boolean("true") ge xs:boolean("0")
xs:boolean("true") ge xs:boolean("1")
xs:boolean("true") ge xs:boolean("false")
xs:boolean("true") ge xs:boolean("true")
xs:boolean("true") gt xs:boolean("0")
xs:boolean("true") gt xs:boolean("1")
xs:boolean("true") gt xs:boolean("false")
xs:boolean("true") gt xs:boolean("true")
xs:boolean("true") instance of xs:anyURI
xs:boolean("true") instance of xs:boolean
xs:boolean("true") instance of xs:date
xs:boolean("true") instance of xs:dateTime
xs:boolean("true") instance of xs:decimal
xs:boolean("true") instance of xs:double
xs:boolean("true") instance of xs:float
xs:boolean("true") instance of xs:int
xs:boolean("true") instance of xs:integer
xs:boolean("true") instance of xs:string
xs:boolean("true") instance of xs:time
xs:boolean("true") le xs:boolean("0")
xs:boolean("true") le xs:boolean("1")
xs:boolean("true") le xs:boolean("false")
xs:boolean("true") le xs:boolean("true")
xs:boolean("true") lt xs:boolean("0")
xs:boolean("true") lt xs:boolean("1")
xs:boolean("true") lt xs:boolean("false")
xs:boolean("true") lt xs:boolean("true")
xs:boolean( "true" , "true" )
xs:boolean("true") , xs:boolean("0"), xs:integer("0")
xs:boolean(xs:decimal(0.0)) eq false()
xs:boolean(xs:decimal(0)) eq false()
xs:boolean(xs:decimal(3)) eq true()
xs:boolean(xs:double(+0)) eq false()
xs:boolean(xs:double(-0)) eq false()
xs:boolean(xs:double(0)) eq false()
xs:boolean(xs:double(3)) eq true()
xs:boolean(xs:double("NaN")) eq false()
xs:boolean(xs:duration("P36D") eq xs:duration("P36D"))
xs:boolean(xs:duration("P36D") ne xs:duration("P36D"))
xs:boolean(xs:float("NaN")) eq false()
xs:boolean(xs:integer(0)) eq false()
xs:boolean(xs:integer(3)) eq true()
xs:boolean(xs:string(0)) eq false()
xs:boolean(xs:string(1)) eq true()
xs:boolean(xs:untypedAtomic( "true" )) eq xs:boolean("true")
xs:byte("")
xs:byte("000000001")
xs:byte(0) and xs:byte(0)
xs:byte(0) and xs:byte(1)
xs:byte(0) instance of xs:byte
xs:byte("0") instance of xs:short
xs:byte(0) or xs:byte(0)
xs:byte(0) or xs:byte(1)
xs:byte("-0x128")
xs:byte("127")
xs:byte(127) and xs:byte(0)
xs:byte(127) and xs:byte(-1)
xs:byte(127) and xs:byte(-128)
xs:byte(127) or xs:byte(0)
xs:byte(127) or xs:byte(-1)
xs:byte(127) or xs:byte(-128)
xs:byte("-128")
xs:byte("128")
xs:byte(128)
xs:byte(-128) and xs:byte(0)
xs:byte(-128) and xs:byte(1)
xs:byte(-128) or xs:byte(0)
xs:byte(-128) or xs:byte(1)
xs:byte("-129")
xs:byte(-129)
xs:byte(-1) and xs:byte(0)
xs:byte(1) and xs:byte(-1)
xs:byte(-1) or xs:byte(0)
xs:byte(1) or xs:byte(-1)
xs:byte("3.0")
xs:byte("+ 5")
xs:byte("- 5")
xs:byte(false())
xs:byte(true())
xs:byte(xs:double("1")) instance of xs:byte
xs:byte(xs:double("-INF"))
xs:byte(xs:double("INF"))
xs:byte(xs:double("NaN"))
xs:byte(xs:float("1")) instance of xs:byte
xs:byte(xs:float("-INF"))
xs:byte(xs:float("INF"))
xs:byte(xs:float("NaN"))
xs:date("")
xs:date()
xs:date("00004-08-01")
xs:date("-0012-12-03-05:00") castable as xs:date
xs:date("-0012-12-03-05:00") castable as xs:gMonth
xs:date("-0012-12-03-05:00") castable as xs:gMonthDay
xs:date("-0012-12-03-05:00") castable as xs:gYear
xs:date("-0012-12-03-05:00") castable as xs:string
xs:date("-0012-12-03-05:00") castable as xs:untypedAtomic
xs:date("-0012-12-03-05:00") cast as xs:date
xs:date("-0012-12-03-05:00") cast as xs:gMonth
xs:date("-0012-12-03-05:00") cast as xs:gMonthDay
xs:date("-0012-12-03-05:00") cast as xs:gYear
xs:date("-0012-12-03-05:00") cast as xs:string
xs:date("-0012-12-03-05:00") cast as xs:untypedAtomic
xs:date("02004-08-01")
xs:date("0x10-11-11")
xs:date(1)
xs:date(" +11-11-11")
xs:date(" 111-11-11")
xs:date("+111-11-11")
xs:date("-111-11-11")
xs:date("111 -11-11")
xs:date("1111- 1-11")
xs:date("1111-+1-11")
xs:date("1111--1-11")
xs:date("1111-1 -11")
xs:date("1111-11- 1")
xs:date("1111-11-+1")
xs:date("1111-11--1")
xs:date("1111-11-1 ")
xs:date("1111-11-1F")
xs:date("1970-01-01Z") eq xs:date("1970-01-01Z")
xs:date("1970-01-01Z") eq xs:date("1983-11-17Z")
xs:date("1970-01-01Z") eq xs:date("2030-12-31Z")
xs:date("1970-01-01Z") ge xs:date("1970-01-01Z")
xs:date("1970-01-01Z") ge xs:date("1983-11-17Z")
xs:date("1970-01-01Z") ge xs:date("2030-12-31Z")
xs:date("1970-01-01Z") gt xs:date("1970-01-01Z")
xs:date("1970-01-01Z") gt xs:date("1983-11-17Z")
xs:date("1970-01-01Z") gt xs:date("2030-12-31Z")
xs:date("1970-01-01Z") le xs:date("1970-01-01Z")
xs:date("1970-01-01Z") le xs:date("1983-11-17Z")
xs:date("1970-01-01Z") le xs:date("2030-12-31Z")
xs:date("1970-01-01Z") lt xs:date("1970-01-01Z")
xs:date("1970-01-01Z") lt xs:date("1983-11-17Z")
xs:date("1970-01-01Z") lt xs:date("2030-12-31Z")
xs:date("1970-01-01Z") ne xs:date("1970-01-01Z")
xs:date("1970-01-01Z") ne xs:date("1983-11-17Z")
xs:date("1970-01-01Z") ne xs:date("2030-12-31Z")
(xs:date("1976-10-25Z") ge xs:date("1976-10-28Z")) or (xs:date("1980-08-11Z") ge xs:date("1980-08-10Z"))
(xs:date("1976-10-25Z") le xs:date("1976-10-28Z")) or (xs:date("1980-08-11Z") le xs:date("1980-08-10Z"))
(xs:date("1978-12-12Z") - xs:date("1978-12-12Z")) div xs:dayTimeDuration("P17DT10H02M")
(xs:date("1980-01-01Z") gt xs:date("1980-10-01Z")) or (fn:false())
(xs:date("1980-01-01Z") lt xs:date("1980-10-01Z")) or (fn:false())
(xs:date("1980-05-18Z") gt xs:date("1980-05-17Z")) or (fn:true())
(xs:date("1980-05-18Z") lt xs:date("1980-05-17Z")) or (fn:true())
(xs:date("1980-10-25Z") ge xs:date("1980-10-26Z")) or (fn:false())
(xs:date("1980-10-25Z") le xs:date("1980-10-26Z")) or (fn:false())
xs:date("1983-11-17Z") eq xs:date("1970-01-01Z")
xs:date("1983-11-17Z") ge xs:date("1970-01-01Z")
xs:date("1983-11-17Z") gt xs:date("1970-01-01Z")
xs:date("1983-11-17Z") le xs:date("1970-01-01Z")
xs:date("1983-11-17Z") lt xs:date("1970-01-01Z")
xs:date("1983-11-17Z") ne xs:date("1970-01-01Z")
xs:date("1993-03-31") , xs:boolean("true"), xs:string("abc")
xs:date("1999-05-31") castable as xs:anyURI
xs:date("1999-05-31") castable as xs:base64Binary
xs:date("1999-05-31") castable as xs:boolean
xs:date("1999-05-31") castable as xs:date
xs:date("1999-05-31") castable as xs:dateTime
xs:date("1999-05-31") castable as xs:dayTimeDuration
xs:date("1999-05-31") castable as xs:double
xs:date("1999-05-31") castable as xs:duration
xs:date("1999-05-31") castable as xs:float
xs:date("1999-05-31") castable as xs:gMonthDay
xs:date("1999-05-31") castable as xs:gYear
xs:date("1999-05-31") castable as xs:gYearMonth
xs:date("1999-05-31") castable as xs:hexBinary
xs:date("1999-05-31") castable as xs:integer
xs:date("1999-05-31") castable as xs:string
xs:date("1999-05-31") castable as xs:time
xs:date("1999-05-31") castable as xs:untypedAtomic
xs:date("1999-05-31") castable as xs:yearMonthDuration
xs:date("1999-05-31") cast as xs:anyURI
xs:date("1999-05-31") cast as xs:base64Binary
xs:date("1999-05-31") cast as xs:boolean
xs:date("1999-05-31") cast as xs:date
xs:date("1999-05-31") cast as xs:dateTime
xs:date("1999-05-31") cast as xs:dayTimeDuration
xs:date("1999-05-31") cast as xs:double
xs:date("1999-05-31") cast as xs:duration
xs:date("1999-05-31") cast as xs:float
xs:date("1999-05-31") cast as xs:gMonthDay
xs:date("1999-05-31") cast as xs:gYear
xs:date("1999-05-31") cast as xs:gYearMonth
xs:date("1999-05-31") cast as xs:hexBinary
xs:date("1999-05-31") cast as xs:integer
xs:date("1999-05-31") cast as xs:string
xs:date("1999-05-31") cast as xs:time
xs:date("1999-05-31") cast as xs:untypedAtomic
xs:date("1999-05-31") cast as xs:yearMonthDuration
xs:date("1999-05-31Z") castable as xs:date
xs:date("1999-05-31Z") castable as xs:double
xs:date("1999-05-31Z") castable as xs:gDay
xs:date("1999-05-31Z") castable as xs:gMonth
xs:date("1999-05-31Z") castable as xs:gMonthDay
xs:date("1999-05-31Z") castable as xs:gYear
xs:date("1999-05-31Z") cast as xs:date
xs:date("1999-05-31Z") cast as xs:double
xs:date("1999-05-31Z") cast as xs:gDay
xs:date("1999-05-31Z") cast as xs:gMonth
xs:date("1999-05-31Z") cast as xs:gMonthDay
xs:date("1999-05-31Z") cast as xs:gYear
xs:date("1999-07-19") - xs:date("1969-11-30") eq xs:dayTimeDuration("P10823D")
xs:date("1999-07-19") - xs:date("1999-07-19") eq xs:dayTimeDuration("PT0S")
xs:date("1999-10-12") div xs:date("1999-10-12")
xs:date("1999-10-12") mod xs:date("1999-10-12")
xs:date("1999-10-12") * xs:date("1999-10-12")
xs:date("1999-10-12") + xs:date("1999-10-12")
(xs:date("1999-10-23Z") - xs:date("1998-09-09Z")) + xs:dayTimeDuration("P17DT10H02M")
(xs:date("1999-10-23Z") - xs:date("1998-09-09Z")) * xs:decimal(2.0)
xs:date("1999-12-01+10:60")
xs:date("1999-12-01-10:60")
xs:date("1999-12-01+15:00")
xs:date("1999-12-01-15:00")
xs:date("1999-12-04-00:00") eq xs:date("1999-12-04+00:00")
xs:date("1999-12-04+00:00") eq xs:date("1999-12-04Z")
xs:date("1999-12-04-00:00") eq xs:date("1999-12-04Z")
xs:date("1999-12-04") eq xs:dateTime("1999-12-04T12:12:23")
xs:date("1999-12-04") ge xs:dateTime("1999-12-04T12:12:23")
xs:date("1999-12-04") gt xs:dateTime("1999-12-04T12:12:23")
xs:date("1999-12-04") le xs:dateTime("1999-12-04T12:12:23")
xs:date("1999-12-04") lt xs:dateTime("1999-12-04T12:12:23")
xs:date("1999-12-04") ne xs:dateTime("1999-12-04T12:12:23")
xs:date("1999-12-04Z") eq xs:date("1999-12-04Z")
xs:date("2000-01-01+05:00") instance of xs:anyURI
xs:date("2000-01-01+05:00") instance of xs:boolean
xs:date("2000-01-01+05:00") instance of xs:date
xs:date("2000-01-01+05:00") instance of xs:dateTime
xs:date("2000-01-01+05:00") instance of xs:decimal
xs:date("2000-01-01+05:00") instance of xs:double
xs:date("2000-01-01+05:00") instance of xs:float
xs:date("2000-01-01+05:00") instance of xs:int
xs:date("2000-01-01+05:00") instance of xs:integer
xs:date("2000-01-01+05:00") instance of xs:string
xs:date("2000-01-01+05:00") instance of xs:time
(xs:date("2000-01-01Z") gt xs:date("2000-01-01Z")) and (xs:date("2001-02-02Z") gt xs:date("2001-03-02Z"))
(xs:date("2000-01-01Z") lt xs:date("2000-01-01Z")) and (xs:date("2001-02-02Z") lt xs:date("2001-03-02Z"))
(xs:date("2000-01-25Z") ge xs:date("2000-10-26Z")) and (xs:date("1975-10-26Z") ge xs:date("1975-10-28Z"))
(xs:date("2000-01-25Z") le xs:date("2000-10-26Z")) and (xs:date("1975-10-26Z") le xs:date("1975-10-28Z"))
xs:date("2000-10-15-05:00") - xs:date("2000-10-10+02:00")
(xs:date("2000-10-25Z") ge xs:date("2000-10-26Z")) or (fn:true())
(xs:date("2000-10-25Z") le xs:date("2000-10-26Z")) or (fn:true())
(xs:date("2000-10-26Z") gt xs:date("2000-10-28Z")) or (xs:date("1976-10-28Z") gt xs:date("1976-10-28Z"))
(xs:date("2000-10-26Z") lt xs:date("2000-10-28Z")) or (xs:date("1976-10-28Z") lt xs:date("1976-10-28Z"))
xs:date("2000-10-30+05:00") - xs:date("1999-11-28Z")
xs:date("2000-10-30") - xs:date("1999-11-28")
xs:date("2002-002-15")
xs:date("--2002-02-15")
xs:date("2002-02-150")
xs:date("2002-02-15T08:12:12")
xs:date("+2002-12-11")
xs:date("2002-12-31+01:00") - xs:date("2008-12-31") - implicit-timezone()
xs:date("2004-07-12") ge xs:date("2004-07-12")
xs:date("2004-07-12") le xs:date("2004-07-12")
xs:date("2004-07-12") lt xs:date("2004-07-13")
xs:date("2004-07-13") ge xs:date("2004-07-12")
xs:date("2004-07-13") gt xs:date("2004-07-12")
xs:date("+2004-08-01")
xs:date("2004-08-12") eq xs:date("2004-08-12")
xs:date("2004-08-12") ne xs:date("2004-07-12")
xs:date( "2004-10-13" , "2004-10-13" )
xs:date("2004-10-13") castable as xs:date
xs:date("2004-10-13") castable as xs:dateTime
xs:date("2004-10-13") castable as xs:gDay
xs:date("2004-10-13") castable as xs:gMonth
xs:date("2004-10-13") castable as xs:gMonthDay
xs:date("2004-10-13") castable as xs:gYear
xs:date("2004-10-13") castable as xs:gYearMonth
xs:date("2004-10-13") castable as xs:string
xs:date("2004-10-13") castable as xs:untypedAtomic
xs:date("2004-10-13") cast as xs:anyURI
xs:date("2004-10-13") cast as xs:base64Binary
xs:date("2004-10-13") cast as xs:boolean
xs:date("2004-10-13") cast as xs:date eq xs:date("2004-10-13")
xs:date("2004-10-13") cast as xs:dateTime ne xs:dateTime("2002-10-10T12:00:00-05:00")
xs:date("2004-10-13") cast as xs:dayTimeDuration
xs:date("2004-10-13") cast as xs:decimal
xs:date("2004-10-13") cast as xs:double
xs:date("2004-10-13") cast as xs:duration
xs:date("2004-10-13") cast as xs:float
xs:date("2004-10-13") cast as xs:gDay ne xs:gDay("---03")
xs:date("2004-10-13") cast as xs:gMonthDay ne xs:gMonthDay("--11-13")
xs:date("2004-10-13") cast as xs:gMonth ne xs:gMonth("--11")
xs:date("2004-10-13") cast as xs:gYearMonth ne xs:gYearMonth("1999-11")
xs:date("2004-10-13") cast as xs:gYear ne xs:gYear("1999")
xs:date("2004-10-13") cast as xs:hexBinary
xs:date("2004-10-13") cast as xs:integer
xs:date("2004-10-13") cast as xs:string ne xs:string("an arbitrary string")
xs:date("2004-10-13") cast as xs:time
xs:date("2004-10-13") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:date("2004-10-13") cast as xs:yearMonthDuration
xs:date(" 2004-10-13 ") eq xs:date(" 2004-10-13 ")
(xs:date("2004-12-25-12:00") gt xs:date("2004-12-26+12:00"))
(xs:date("2004-12-25-12:00") le xs:date("2004-12-26+12:00"))
(xs:date("2004-12-25Z") gt xs:date("2004-12-25+07:00"))
(xs:date("2004-12-25Z") lt xs:date("2004-12-25-05:00"))
(xs:date("2004-12-25Z"),xs:date("2004-12-26Z"))
xs:date("2004-32-01")
xs:date("2008-01-30") eq xs:date("2008-01-31+09:00")
xs:date("2008-01-30") ge xs:date("2008-01-31+09:00")
xs:date("2008-01-30") le xs:date("2008-01-31+09:00")
xs:date("2008-01-30") lt xs:date("2008-01-31+09:00")
xs:date("2008-01-30") ne xs:date("2008-01-31+09:00")
xs:date("2008-01-31+09:00") eq xs:date("2008-01-30")
xs:date("2008-01-31+09:00") eq xs:date("2008-01-31")
xs:date("2008-01-31+09:00") ge xs:date("2008-01-30")
xs:date("2008-01-31+09:00") ge xs:date("2008-01-31")
xs:date("2008-01-31+09:00") le xs:date("2008-01-30")
xs:date("2008-01-31+09:00") le xs:date("2008-01-31")
xs:date("2008-01-31+09:00") lt xs:date("2008-01-30")
xs:date("2008-01-31+09:00") lt xs:date("2008-01-31")
xs:date("2008-01-31+09:00") ne xs:date("2008-01-30")
xs:date("2008-01-31+09:00") ne xs:date("2008-01-31")
xs:date("2008-01-31") eq xs:date("2008-01-31+09:00")
xs:date("2008-01-31") ge xs:date("2008-01-31+09:00")
xs:date("2008-01-31") le xs:date("2008-01-31+09:00")
xs:date("2008-01-31") lt xs:date("2008-01-31+09:00")
xs:date("2008-01-31") ne xs:date("2008-01-31+09:00")
xs:date("2008-12-31") - xs:date("2002-12-31+01:00") + implicit-timezone()
xs:date('2017-07-19-00:30')
xs:date("2030-12-31Z") eq xs:date("1970-01-01Z")
xs:date("2030-12-31Z") ge xs:date("1970-01-01Z")
xs:date("2030-12-31Z") gt xs:date("1970-01-01Z")
xs:date("2030-12-31Z") le xs:date("1970-01-01Z")
xs:date("2030-12-31Z") lt xs:date("1970-01-01Z")
xs:date("2030-12-31Z") ne xs:date("1970-01-01Z")
xs:date("-25252734927766554-12-31") - xs:date("25252734927766554-12-31")
xs:date("-25252734927766554-12-31") - xs:date("25252734927766554-12-31+01:00")
xs:date("-25252734927766555-06-07+02:00") < xs:date("25252734927766555-07-28")
xs:date("-25252734927766555-06-07+02:00") <= xs:date("25252734927766555-07-28")
xs:date("-25252734927766555-06-07+02:00") = xs:date("25252734927766555-07-28")
xs:date("25252734927766555-07-28-14:00") - xs:date("-25252734927766555-07-28-14:00")
xs:date("25252734927766555-07-28-14:00") + xs:dayTimeDuration("PT24H")
xs:date("25252734927766555-07-28-14:00") - xs:dayTimeDuration("-PT24H")
xs:date("25252734927766555-07-28-14:00") + xs:yearMonthDuration("P1Y0M")
xs:date("25252734927766555-07-28-14:00") - xs:yearMonthDuration("-P1Y0M")
xs:date("25252734927766555-07-28") != xs:date("-25252734927766555-06-07+02:00")
xs:date("25252734927766555-07-28") > xs:date("-25252734927766555-06-07+02:00")
xs:date("25252734927766555-07-28") >= xs:date("-25252734927766555-06-07+02:00")
xs:dateTime("")
xs:dateTime()
xs:dateTime("00004-08-01T12:44:05")
xs:dateTime("02004-08-01T12:44:05")
xs:dateTime("1970-01-01T00:00:00Z") eq xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("1970-01-01T00:00:00Z") eq xs:dateTime("1996-04-07T01:40:52Z")
xs:dateTime("1970-01-01T00:00:00Z") eq xs:dateTime("2030-12-31T23:59:59Z")
xs:dateTime("1970-01-01T00:00:00Z") ge xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("1970-01-01T00:00:00Z") ge xs:dateTime("1996-04-07T01:40:52Z")
xs:dateTime("1970-01-01T00:00:00Z") ge xs:dateTime("2030-12-31T23:59:59Z")
xs:dateTime("1970-01-01T00:00:00Z") gt xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("1970-01-01T00:00:00Z") gt xs:dateTime("1996-04-07T01:40:52Z")
xs:dateTime("1970-01-01T00:00:00Z") gt xs:dateTime("2030-12-31T23:59:59Z")
xs:dateTime("1970-01-01T00:00:00Z") le xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("1970-01-01T00:00:00Z") le xs:dateTime("1996-04-07T01:40:52Z")
xs:dateTime("1970-01-01T00:00:00Z") le xs:dateTime("2030-12-31T23:59:59Z")
xs:dateTime("1970-01-01T00:00:00Z") lt xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("1970-01-01T00:00:00Z") lt xs:dateTime("1996-04-07T01:40:52Z")
xs:dateTime("1970-01-01T00:00:00Z") lt xs:dateTime("2030-12-31T23:59:59Z")
xs:dateTime("1970-01-01T00:00:00Z") ne xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("1970-01-01T00:00:00Z") ne xs:dateTime("1996-04-07T01:40:52Z")
xs:dateTime("1970-01-01T00:00:00Z") ne xs:dateTime("2030-12-31T23:59:59Z")
(xs:dateTime("1970-04-02T12:00:20Z") ge xs:dateTime("1980-04-02T12:00:20Z")) or (fn:true())
(xs:dateTime("1970-04-02T12:00:20Z") le xs:dateTime("1980-04-02T12:00:20Z")) or (fn:true())
xs:dateTime("1972-12-15T00:00:00+12:00") eq xs:dateTime("1972-12-15T00:00:01")
xs:dateTime("1972-12-15T00:00:00+12:00") ne xs:dateTime("1972-12-15T00:00:01")
xs:dateTime("1972-12-31T00:00:00Z") , (())
(xs:dateTime("1976-04-03T12:00:00Z") ge xs:dateTime("2002-07-02T12:00:30Z")) or (fn:false())
(xs:dateTime("1976-04-03T12:00:00Z") le xs:dateTime("2002-07-02T12:00:30Z")) or (fn:false())
(xs:dateTime("1981-04-02T12:00:00Z") gt xs:dateTime("2003-04-02T12:10:00Z")) or (fn:false())
(xs:dateTime("1981-04-02T12:00:00Z") lt xs:dateTime("2003-04-02T12:10:00Z")) or (fn:false())
(xs:dateTime("1985-07-05T07:07:07Z") - xs:dateTime("1985-07-05T07:07:07Z")) div xs:dayTimeDuration("P05DT08H11M")
(xs:dateTime("1990-04-02T12:00:10Z") gt xs:dateTime("2006-06-02T12:10:00Z")) or (fn:true())
(xs:dateTime("1990-04-02T12:00:10Z") lt xs:dateTime("2006-06-02T12:10:00Z")) or (fn:true())
xs:dateTime("1996-04-07T01:40:52Z") eq xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("1996-04-07T01:40:52Z") ge xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("1996-04-07T01:40:52Z") gt xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("1996-04-07T01:40:52Z") le xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("1996-04-07T01:40:52Z") lt xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("1996-04-07T01:40:52Z") ne xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("1999-05-31T13:20:00-05:00") cast as xs:date
xs:dateTime("1999-05-31T13:20:00-05:00") cast as xs:dateTime
xs:dateTime("1999-05-31T13:20:00-05:00") cast as xs:string
xs:dateTime("1999-05-31T13:20:00-05:00") cast as xs:time
xs:dateTime("-1999-05-31T13:20:00+14:00") castable as xs:date
xs:dateTime("-1999-05-31T13:20:00+14:00") castable as xs:gDay
xs:dateTime("-1999-05-31T13:20:00+14:00") castable as xs:gMonth
xs:dateTime("-1999-05-31T13:20:00+14:00") castable as xs:gMonthDay
xs:dateTime("-1999-05-31T13:20:00+14:00") castable as xs:gYear
xs:dateTime("-1999-05-31T13:20:00+14:00") castable as xs:gYearMonth
xs:dateTime("-1999-05-31T13:20:00+14:00") castable as xs:string
xs:dateTime("-1999-05-31T13:20:00+14:00") castable as xs:time
xs:dateTime("-1999-05-31T13:20:00+14:00") castable as xs:untypedAtomic
xs:dateTime("-1999-05-31T13:20:00+14:00") cast as xs:date
xs:dateTime("-1999-05-31T13:20:00+14:00") cast as xs:gDay
xs:dateTime("-1999-05-31T13:20:00+14:00") cast as xs:gMonth
xs:dateTime("-1999-05-31T13:20:00+14:00") cast as xs:gMonthDay
xs:dateTime("-1999-05-31T13:20:00+14:00") cast as xs:gYear
xs:dateTime("-1999-05-31T13:20:00+14:00") cast as xs:gYearMonth
xs:dateTime("-1999-05-31T13:20:00+14:00") cast as xs:string
xs:dateTime("-1999-05-31T13:20:00+14:00") cast as xs:time
xs:dateTime("-1999-05-31T13:20:00+14:00") cast as xs:untypedAtomic
xs:dateTime("1999-05-31T13:20:00") castable as xs:anyURI
xs:dateTime("1999-05-31T13:20:00") castable as xs:base64Binary
xs:dateTime("1999-05-31T13:20:00") castable as xs:boolean
xs:dateTime("1999-05-31T13:20:00") castable as xs:date
xs:dateTime("1999-05-31T13:20:00") castable as xs:dateTime
xs:dateTime("1999-05-31T13:20:00") castable as xs:dayTimeDuration
xs:dateTime("1999-05-31T13:20:00") castable as xs:decimal
xs:dateTime("1999-05-31T13:20:00") castable as xs:duration
xs:dateTime("1999-05-31T13:20:00") castable as xs:float
xs:dateTime("1999-05-31T13:20:00") castable as xs:gDay
xs:dateTime("1999-05-31T13:20:00") castable as xs:gMonth
xs:dateTime("1999-05-31T13:20:00") castable as xs:gMonthDay
xs:dateTime("1999-05-31T13:20:00") castable as xs:gYear
xs:dateTime("1999-05-31T13:20:00") castable as xs:gYearMonth
xs:dateTime("1999-05-31T13:20:00") castable as xs:hexBinary
xs:dateTime("1999-05-31T13:20:00") castable as xs:integer
xs:dateTime("1999-05-31T13:20:00") castable as xs:string
xs:dateTime("1999-05-31T13:20:00") castable as xs:time
xs:dateTime("1999-05-31T13:20:00") castable as xs:untypedAtomic
xs:dateTime("1999-05-31T13:20:00") castable as xs:yearMonthDuration
xs:dateTime("1999-05-31T13:20:00") cast as xs:anyURI
xs:dateTime("1999-05-31T13:20:00") cast as xs:base64Binary
xs:dateTime("1999-05-31T13:20:00") cast as xs:boolean
xs:dateTime("1999-05-31T13:20:00") cast as xs:date
xs:dateTime("1999-05-31T13:20:00") cast as xs:dateTime
xs:dateTime("1999-05-31T13:20:00") cast as xs:dayTimeDuration
xs:dateTime("1999-05-31T13:20:00") cast as xs:decimal
xs:dateTime("1999-05-31T13:20:00") cast as xs:duration
xs:dateTime("1999-05-31T13:20:00") cast as xs:float
xs:dateTime("1999-05-31T13:20:00") cast as xs:gDay
xs:dateTime("1999-05-31T13:20:00") cast as xs:gMonth
xs:dateTime("1999-05-31T13:20:00") cast as xs:gMonthDay
xs:dateTime("1999-05-31T13:20:00") cast as xs:gYear
xs:dateTime("1999-05-31T13:20:00") cast as xs:gYearMonth
xs:dateTime("1999-05-31T13:20:00") cast as xs:hexBinary
xs:dateTime("1999-05-31T13:20:00") cast as xs:integer
xs:dateTime("1999-05-31T13:20:00") cast as xs:string
xs:dateTime("1999-05-31T13:20:00") cast as xs:time
xs:dateTime("1999-05-31T13:20:00") cast as xs:untypedAtomic
xs:dateTime("1999-05-31T13:20:00") cast as xs:yearMonthDuration
xs:dateTime("1999-07-19T08:23:12.765") - xs:dateTime("1999-07-19T08:23:12.765") eq xs:dayTimeDuration("PT0S")
xs:dateTime("1999-10-12T08:01:23") div xs:dateTime("1999-10-12T08:01:23")
xs:dateTime("1999-10-12T08:01:23") mod xs:dateTime("1999-10-12T08:01:23")
xs:dateTime("1999-10-12T08:01:23") * xs:dateTime("1999-10-12T08:01:23")
xs:dateTime("1999-10-12T08:01:23") + xs:dateTime("1999-10-12T08:01:23")
(xs:dateTime("1999-10-23T01:01:01Z") - xs:dateTime("1998-09-09T02:02:02Z")) * xs:decimal(2.0)
(xs:dateTime("1999-10-23T09:08:07Z") - xs:dateTime("1998-09-09T04:03:02Z")) + xs:dayTimeDuration("P17DT10H02M")
(xs:dateTime("1999-11-28T09:00:00Z"),xs:dateTime("1998-11-28T09:00:00Z"))
xs:dateTime("1999-12-01-03")
xs:dateTime("1999-12-01T23:59:12.432+10:60")
xs:dateTime("1999-12-01T23:59:12.432-10:60")
xs:dateTime("1999-12-01T23:59:12.432+15:00")
xs:dateTime("1999-12-01T23:59:12.432-15:00")
xs:dateTime("1999-12-01T23:59:12.999-00")
xs:dateTime("1999-12-04T12:12:23") eq xs:date("1999-12-04")
xs:dateTime("1999-12-04T12:12:23") eq xs:time("22:12:04")
xs:dateTime("1999-12-04T12:12:23") ge xs:date("1999-12-04")
xs:dateTime("1999-12-04T12:12:23") ge xs:time("22:12:04")
xs:dateTime("1999-12-04T12:12:23") gt xs:date("1999-12-04")
xs:dateTime("1999-12-04T12:12:23") gt xs:time("22:12:04")
xs:dateTime("1999-12-04T12:12:23") le xs:date("1999-12-04")
xs:dateTime("1999-12-04T12:12:23") le xs:time("22:12:04")
xs:dateTime("1999-12-04T12:12:23") lt xs:date("1999-12-04")
xs:dateTime("1999-12-04T12:12:23") lt xs:time("22:12:04")
xs:dateTime("1999-12-04T12:12:23") ne xs:date("1999-12-04")
xs:dateTime("1999-12-04T12:12:23") ne xs:time("22:12:04")
xs:dateTime("1999-12-04T16:00:12.345-00:00") eq xs:dateTime("1999-12-04T16:00:12.345+00:00")
xs:dateTime("1999-12-04T16:00:12.345+00:00") eq xs:dateTime("1999-12-04T16:00:12.345Z")
xs:dateTime("1999-12-04T16:00:12.345-00:00") eq xs:dateTime("1999-12-04T16:00:12.345Z")
xs:dateTime("1999-12-04T16:00:12.345Z") eq xs:dateTime("1999-12-04T16:00:12.345Z")
xs:dateTime("2000-01-16T00:00:00Z") castable as xs:float
xs:dateTime("2000-01-16T00:00:00Z") cast as xs:float
xs:dateTime("2000-02-03T02:09:07-06:00") - xs:dateTime("1998-02-03T02:09:07-06:00")
xs:dateTime("2000-10-30T06:12:00-05:00") - xs:dateTime("1999-11-28T09:00:00Z")
xs:dateTime("2000-12-12T09:08:07+05:00") - xs:dateTime("1999-12-12T09:08:07+05:00")
xs:dateTime("2002-002-15T12:44:05")
xs:dateTime("2002-02-150T12:44:05")
xs:dateTime("--2002-02-15T21:01:23")
xs:dateTime("2002-02-15T21:01:60")
xs:dateTime("2002-02-15T21:60:00")
xs:dateTime("2002-02-15T24:00:00.001")
xs:dateTime("2002-02-15T24:01:00")
xs:dateTime("2002-02-15T25:01:00")
xs:dateTime("2002-03-06T00:00:00Z") ne xs:dateTime("2002-03-05T00:00:00+03:00")
(xs:dateTime("2002-04-02T12:00:00Z") ge xs:dateTime("2005-04-02T12:00:20Z")) and (xs:dateTime("2002-04-02T12:10:00Z") ge xs:dateTime("2002-04-03T12:00:00Z"))
(xs:dateTime("2002-04-02T12:00:00Z") gt xs:dateTime("2002-04-02T12:01:00Z")) and (xs:dateTime("2003-04-02T12:00:00Z") gt xs:dateTime("2002-04-02T12:00:00Z"))
xs:dateTime("2002-04-02T12:00:00Z") instance of xs:anyURI
xs:dateTime("2002-04-02T12:00:00Z") instance of xs:boolean
xs:dateTime("2002-04-02T12:00:00Z") instance of xs:date
xs:dateTime("2002-04-02T12:00:00Z") instance of xs:dateTime
xs:dateTime("2002-04-02T12:00:00Z") instance of xs:decimal
xs:dateTime("2002-04-02T12:00:00Z") instance of xs:double
xs:dateTime("2002-04-02T12:00:00Z") instance of xs:float
xs:dateTime("2002-04-02T12:00:00Z") instance of xs:int
xs:dateTime("2002-04-02T12:00:00Z") instance of xs:integer
xs:dateTime("2002-04-02T12:00:00Z") instance of xs:string
xs:dateTime("2002-04-02T12:00:00Z") instance of xs:time
(xs:dateTime("2002-04-02T12:00:00Z") le xs:dateTime("2005-04-02T12:00:20Z")) and (xs:dateTime("2002-04-02T12:10:00Z") le xs:dateTime("2002-04-03T12:00:00Z"))
(xs:dateTime("2002-04-02T12:00:00Z") lt xs:dateTime("2002-04-02T12:01:00Z")) and (xs:dateTime("2003-04-02T12:00:00Z") lt xs:dateTime("2002-04-02T12:00:00Z"))
(xs:dateTime("2002-04-03T12:00:10Z") ge xs:dateTime("1990-04-02T12:10:00Z")) or (xs:dateTime("1975-04-03T12:10:00Z") ge xs:dateTime("2000-02-02T12:00:09Z"))
(xs:dateTime("2002-04-03T12:00:10Z") le xs:dateTime("1990-04-02T12:10:00Z")) or (xs:dateTime("1975-04-03T12:10:00Z") le xs:dateTime("2000-02-02T12:00:09Z"))
(xs:dateTime("2002-06-02T12:00:10Z") gt xs:dateTime("2000-04-04T12:00:00Z")) or (xs:dateTime("2002-04-02T13:00:10Z") gt xs:dateTime("2001-04-02T10:00:00Z"))
(xs:dateTime("2002-06-02T12:00:10Z") lt xs:dateTime("2000-04-04T12:00:00Z")) or (xs:dateTime("2002-04-02T13:00:10Z") lt xs:dateTime("2001-04-02T10:00:00Z"))
xs:dateTime( "2002-10-10T12:00:00-05:00" , "2002-10-10T12:00:00-05:00" )
xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:date
xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:dateTime
xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:gDay
xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:gMonth
xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:gMonthDay
xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:gYear
xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:gYearMonth
xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:string
xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:time
xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:untypedAtomic
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:anyURI
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:base64Binary
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:boolean
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:date ne xs:date("2004-10-13")
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:dateTime eq xs:dateTime("2002-10-10T12:00:00-05:00")
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:dayTimeDuration
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:decimal
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:double
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:duration
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:float
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:gDay ne xs:gDay("---03")
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:gMonthDay ne xs:gMonthDay("--11-13")
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:gMonth ne xs:gMonth("--11")
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:gYearMonth ne xs:gYearMonth("1999-11")
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:gYear ne xs:gYear("1999")
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:hexBinary
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:integer
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:string ne xs:string("an arbitrary string")
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:time ne xs:time("03:20:00-05:00")
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:yearMonthDuration
xs:dateTime(" 2002-10-10T12:00:00-05:00 ") eq xs:dateTime(" 2002-10-10T12:00:00-05:00 ")
xs:dateTime("2002-11-23")
xs:dateTime("2002-12-31T12:00:00+01:00") - xs:dateTime("2008-12-31T12:00:00") - implicit-timezone()
xs:dateTime("2004-07-12T23:01:04.12") ge xs:dateTime("2004-07-12T23:01:04.12")
xs:dateTime("2004-07-12T23:01:04.12") le xs:dateTime("2004-07-12T23:01:04.12")
xs:dateTime("2004-07-12T23:01:04.12") lt xs:dateTime("2004-07-13T23:01:04.12")
xs:dateTime("2004-07-13T23:01:04.12") ge xs:dateTime("2004-07-12T23:01:04.12")
xs:dateTime("2004-07-13T23:01:04.12") gt xs:dateTime("2004-07-12T23:01:04.12")
xs:dateTime("+2004-08-01T12:44:05")
xs:dateTime("2004-08-12T23:01:04.12") eq xs:dateTime("2004-08-12T23:01:04.12")
xs:dateTime("2004-08-12T23:01:05.12") ne xs:dateTime("2004-08-12T23:01:04.12")
xs:dateTime("2004-32-01T12:44:05")
xs:dateTime("2008-01-30T00:01:00") eq xs:dateTime("2008-01-31T01:00:00+09:00")
xs:dateTime("2008-01-30T00:01:00") ge xs:dateTime("2008-01-31T00:01:00+09:00")
xs:dateTime("2008-01-30T00:01:00") gt xs:dateTime("2008-01-31T01:00:00+09:00")
xs:dateTime("2008-01-30T00:01:00") le xs:dateTime("2008-01-31T00:01:00+09:00")
xs:dateTime("2008-01-30T00:01:00") lt xs:dateTime("2008-01-31T01:00:00+09:00")
xs:dateTime("2008-01-30T00:01:00") ne xs:dateTime("2008-01-31T00:01:00+09:00")
xs:dateTime("2008-01-31T00:01:00+09:00") eq xs:dateTime("2008-01-30T00:01:00")
xs:dateTime("2008-01-31T00:01:00+09:00") eq xs:dateTime("2008-01-31T00:01:00")
xs:dateTime("2008-01-31T00:01:00+09:00") ge xs:dateTime("2008-01-30T00:01:00")
xs:dateTime("2008-01-31T00:01:00+09:00") ge xs:dateTime("2008-01-31T00:01:00")
xs:dateTime("2008-01-31T00:01:00+09:00") gt xs:dateTime("2008-01-30T00:01:00")
xs:dateTime("2008-01-31T00:01:00+09:00") gt xs:dateTime("2008-01-31T00:01:00")
xs:dateTime("2008-01-31T00:01:00+09:00") le xs:dateTime("2008-01-30T00:01:00")
xs:dateTime("2008-01-31T00:01:00+09:00") le xs:dateTime("2008-01-31T00:01:00")
xs:dateTime("2008-01-31T00:01:00+09:00") lt xs:dateTime("2008-01-30T00:01:00")
xs:dateTime("2008-01-31T00:01:00+09:00") lt xs:dateTime("2008-01-31T00:01:00")
xs:dateTime("2008-01-31T00:01:00+09:00") ne xs:dateTime("2008-01-30T00:01:00")
xs:dateTime("2008-01-31T00:01:00+09:00") ne xs:dateTime("2008-01-31T00:01:00")
xs:dateTime("2008-01-31T00:01:00") eq xs:dateTime("2008-01-31T00:01:00+09:00")
xs:dateTime("2008-01-31T00:01:00") ge xs:dateTime("2008-01-31T00:01:00+09:00")
xs:dateTime("2008-01-31T00:01:00") gt xs:dateTime("2008-01-31T00:01:00+09:00")
xs:dateTime("2008-01-31T00:01:00") le xs:dateTime("2008-01-31T00:01:00+09:00")
xs:dateTime("2008-01-31T00:01:00") lt xs:dateTime("2008-01-31T00:01:00+09:00")
xs:dateTime("2008-01-31T00:01:00") ne xs:dateTime("2008-01-31T00:01:00+09:00")
xs:dateTime("2008-12-31T12:00:00") - xs:dateTime("2002-12-31T12:00:00+01:00") + implicit-timezone()
xs:dateTime('2017-07-19T12:00:00-00:30')
xs:dateTime("2030-12-31T23:59:59Z") eq xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("2030-12-31T23:59:59Z") ge xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("2030-12-31T23:59:59Z") gt xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("2030-12-31T23:59:59Z") le xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("2030-12-31T23:59:59Z") lt xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("2030-12-31T23:59:59Z") ne xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("-25252734927766554-12-31T12:00:00") - xs:dateTime("25252734927766554-12-31T12:00:00")
xs:dateTime("-25252734927766554-12-31T12:00:00") - xs:dateTime("25252734927766554-12-31T12:00:00+01:00")
xs:dateTime("25252734927766555-07-28T23:59:59-14:00") - xs:dateTime("-25252734927766555-07-28T23:59:59-14:00")
xs:dateTime("25252734927766555-07-28T23:59:59-14:00") + xs:dayTimeDuration("PT14H")
xs:dateTime("25252734927766555-07-28T23:59:59-14:00") - xs:dayTimeDuration("-PT14H")
xs:dateTime("25252734927766555-07-28T23:59:59-14:00") + xs:yearMonthDuration("P1Y0M")
xs:dateTime("25252734927766555-07-28T23:59:59-14:00") - xs:yearMonthDuration("-P1Y0M")
xs:dateTime("9999-12-31T23:59:59.9999999") cast as xs:string
xs:dateTimeStamp("2011-07-28T12:34:56")
xs:dateTime("T23:59:12.999-03")
xs:dateTime(xs:date("2002-11-23-00:00")) eq xs:dateTime("2002-11-23T00:00:00.000Z")
xs:dateTime(xs:date("2002-11-23-13:37")) eq xs:dateTime("2002-11-23T00:00:00.000-13:37")
xs:dateTime(xs:untypedAtomic( "2002-10-10T12:00:00-05:00" )) eq xs:dateTime("2002-10-10T12:00:00-05:00")
xs:date(xs:dateTime("2002-11-23T22:12:23.867-00:00")) eq xs:date("2002-11-23Z")
xs:date(xs:dateTime("2002-11-23T22:12:23.867-13:37")) eq xs:date("2002-11-23-13:37")
xs:date(xs:untypedAtomic( "2004-10-13" )) eq xs:date("2004-10-13")
xs:dayTimeDuration("")
xs:dayTimeDuration()
xs:dayTimeDuration("3DT10H")
(xs:dayTimeDuration("P01DT02H01M") div xs:dayTimeDuration("P02DT09H02M")) and (xs:dayTimeDuration("P01DT02H01M") div xs:dayTimeDuration("P02DT09H02M"))
(xs:dayTimeDuration("P05DT09H02M") div xs:dayTimeDuration("P03DT01H04M")) or (xs:dayTimeDuration("P05DT05H03M") div xs:dayTimeDuration("P01DT01H03M"))
xs:dayTimeDuration("P0DT0H0M0S") div xs:dayTimeDuration("P0DT0H0M01S")
xs:dayTimeDuration("P0DT0H0M0S") div xs:dayTimeDuration("P15DT11H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") div xs:dayTimeDuration("P31DT23H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") div xs:double("0.1")
xs:dayTimeDuration("P0DT0H0M0S") div xs:double("-1.7976931348623157E308")
xs:dayTimeDuration("P0DT0H0M0S") div xs:double("1.7976931348623157E308")
xs:dayTimeDuration("P0DT0H0M0S") eq xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P0DT0H0M0S") eq xs:dayTimeDuration("P15DT11H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") eq xs:dayTimeDuration("P31DT23H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") ge xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P0DT0H0M0S") ge xs:dayTimeDuration("P15DT11H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") ge xs:dayTimeDuration("P31DT23H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") gt xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P0DT0H0M0S") gt xs:dayTimeDuration("P15DT11H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") gt xs:dayTimeDuration("P31DT23H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") le xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P0DT0H0M0S") le xs:dayTimeDuration("P15DT11H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") le xs:dayTimeDuration("P31DT23H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") lt xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P0DT0H0M0S") lt xs:dayTimeDuration("P15DT11H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") lt xs:dayTimeDuration("P31DT23H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") ne xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P0DT0H0M0S") ne xs:dayTimeDuration("P15DT11H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") ne xs:dayTimeDuration("P31DT23H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") + xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P0DT0H0M0S") - xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P0DT0H0M0S") + xs:dayTimeDuration("P15DT11H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") - xs:dayTimeDuration("P15DT11H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") + xs:dayTimeDuration("P31DT23H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") - xs:dayTimeDuration("P31DT23H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") * xs:double("0")
xs:dayTimeDuration("P0DT0H0M0S") * xs:double("-1.7976931348623157E308")
xs:dayTimeDuration("P0DT0H0M0S") * xs:double("1.7976931348623157E308")
(xs:dayTimeDuration("P10DT01H01M") * -2.0)
(xs:dayTimeDuration("P10DT01H01M") div -2.0)
(xs:dayTimeDuration("P10DT01H01M") div xs:dayTimeDuration("-P10DT01H01M"))
(xs:dayTimeDuration("P10DT01H01M") + xs:dayTimeDuration("-P11DT02H02M"))
(xs:dayTimeDuration("P10DT01H01M") - xs:dayTimeDuration("P11DT02H02M"))
(xs:dayTimeDuration("P10DT01H") ge xs:dayTimeDuration("P09DT05H")) or (fn:true())
(xs:dayTimeDuration("P10DT01H") ge xs:dayTimeDuration("P09DT06H")) or (xs:dayTimeDuration("P15DT01H") ge xs:dayTimeDuration("P02DT04H"))
(xs:dayTimeDuration("P10DT01H") le xs:dayTimeDuration("P09DT05H")) or (fn:true())
(xs:dayTimeDuration("P10DT01H") le xs:dayTimeDuration("P09DT06H")) or (xs:dayTimeDuration("P15DT01H") le xs:dayTimeDuration("P02DT04H"))
(xs:dayTimeDuration("P10DT02H") gt xs:dayTimeDuration("P01DT10H")) or (fn:true())
(xs:dayTimeDuration("P10DT02H") lt xs:dayTimeDuration("P01DT10H")) or (fn:true())
(xs:dayTimeDuration("P10DT05H") ge xs:dayTimeDuration("P20DT10H")) or (fn:false())
(xs:dayTimeDuration("P10DT05H") le xs:dayTimeDuration("P20DT10H")) or (fn:false())
(xs:dayTimeDuration("P10DT08H11M") div xs:dayTimeDuration("P05DT08H11M")) and (fn:true())
(xs:dayTimeDuration("P10DT08H") gt xs:dayTimeDuration("P10DT07H")) or (xs:dayTimeDuration("P10DT09H") gt xs:dayTimeDuration("P10DT09H"))
(xs:dayTimeDuration("P10DT08H") lt xs:dayTimeDuration("P10DT07H")) or (xs:dayTimeDuration("P10DT09H") lt xs:dayTimeDuration("P10DT09H"))
(xs:dayTimeDuration("P10DT09H") ge xs:dayTimeDuration("P10DT01H")) and (xs:dayTimeDuration("P02DT04H") ge xs:dayTimeDuration("P09DT07H"))
(xs:dayTimeDuration("P10DT09H") gt xs:dayTimeDuration("P09DT10H")) and (xs:dayTimeDuration("P10DT01H") gt xs:dayTimeDuration("P08DT06H"))
(xs:dayTimeDuration("P10DT09H") le xs:dayTimeDuration("P10DT01H")) and (xs:dayTimeDuration("P02DT04H") le xs:dayTimeDuration("P09DT07H"))
(xs:dayTimeDuration("P10DT09H") lt xs:dayTimeDuration("P09DT10H")) and (xs:dayTimeDuration("P10DT01H") lt xs:dayTimeDuration("P08DT06H"))
(xs:dayTimeDuration("P10DT10H01M") * 2.0) le xs:dayTimeDuration("P17DT10H02M")
(xs:dayTimeDuration("P10DT10H01M") div 2.0) le xs:dayTimeDuration("P17DT10H02M")
(xs:dayTimeDuration("P10DT10H01M") div xs:dayTimeDuration("P17DT10H02M")) le xs:decimal(2.0)
(xs:dayTimeDuration("P10DT10H01M") + xs:dayTimeDuration("P17DT10H02M")) le xs:dayTimeDuration("P17DT10H02M")
(xs:dayTimeDuration("P10DT10H01M") - xs:dayTimeDuration("P17DT10H02M")) le xs:dayTimeDuration("P17DT10H02M")
xs:dayTimeDuration("P10DT10H11M") div xs:dayTimeDuration("P12DT10H07M") and fn:false()
(xs:dayTimeDuration("P13DT09H09M") * 2.0) ge xs:dayTimeDuration("P18DT02H02M")
(xs:dayTimeDuration("P13DT09H09M") div 2.0) ge xs:dayTimeDuration("P18DT02H02M")
(xs:dayTimeDuration("P13DT09H09M") div xs:dayTimeDuration("P18DT02H02M")) ge xs:decimal(2.0)
(xs:dayTimeDuration("P13DT09H09M") + xs:dayTimeDuration("P18DT02H02M")) ge xs:dayTimeDuration("P18DT02H02M")
(xs:dayTimeDuration("P13DT09H09M") - xs:dayTimeDuration("P18DT02H02M")) ge xs:dayTimeDuration("P18DT02H02M")
xs:dayTimeDuration("P14D") castable as xs:dayTimeDuration
xs:dayTimeDuration("P14D") cast as xs:dayTimeDuration
xs:dayTimeDuration("P15DT11H59M59S") div xs:dayTimeDuration("P0DT0H0M01S")
xs:dayTimeDuration("P15DT11H59M59S") eq xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P15DT11H59M59S") ge xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P15DT11H59M59S") gt xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P15DT11H59M59S") le xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P15DT11H59M59S") lt xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P15DT11H59M59S") ne xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P15DT11H59M59S") + xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P15DT11H59M59S") - xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P15DT11H59M59S") * xs:double("0")
xs:dayTimeDuration("P1DT2H") eq xs:duration("P1DT2H")
xs:dayTimeDuration("P1DT2H") ne xs:duration("P1M1DT2H")
xs:dayTimeDuration("P1Y12M1D")
xs:dayTimeDuration("P20DT20H10M") div xs:dayTimeDuration("P19DT13H10M") or fn:false()
(xs:dayTimeDuration("P21DT08H12M") * 2.0) ne xs:dayTimeDuration("P08DT08H05M")
(xs:dayTimeDuration("P21DT08H12M") div 2.0) ne xs:dayTimeDuration("P08DT08H05M")
(xs:dayTimeDuration("P21DT08H12M") div xs:dayTimeDuration("P08DT08H05M")) ne xs:decimal(2.0)
(xs:dayTimeDuration("P21DT08H12M") + xs:dayTimeDuration("P08DT08H05M")) ne xs:dayTimeDuration("P08DT08H05M")
(xs:dayTimeDuration("P21DT08H12M") - xs:dayTimeDuration("P08DT08H05M")) ne xs:dayTimeDuration("P08DT08H05M")
(xs:dayTimeDuration("P23DT11H11M") * 2.0) eq xs:dayTimeDuration("P23DT11H11M")
(xs:dayTimeDuration("P23DT11H11M") div 2.0) eq xs:dayTimeDuration("P23DT11H11M")
(xs:dayTimeDuration("P23DT11H11M") div xs:dayTimeDuration("P23DT11H11M")) eq xs:decimal(2.0)
(xs:dayTimeDuration("P23DT11H11M") + xs:dayTimeDuration("P23DT11H11M")) eq xs:dayTimeDuration("P23DT11H11M")
(xs:dayTimeDuration("P23DT11H11M") - xs:dayTimeDuration("P23DT11H11M")) eq xs:dayTimeDuration("P23DT11H11M")
xs:dayTimeDuration("P24M1D")
xs:dayTimeDuration("P2DT12H5M") + xs:dayTimeDuration("P5DT12H")
xs:dayTimeDuration("P2DT12H") - xs:dayTimeDuration("P1DT10H30M")
xs:dayTimeDuration("-P2DT5H") ne xs:dayTimeDuration("P2DT5H")
(xs:dayTimeDuration("P30DT10H") gt xs:dayTimeDuration("P01DT02H")) or (fn:false())
(xs:dayTimeDuration("P30DT10H") lt xs:dayTimeDuration("P01DT02H")) or (fn:false())
xs:dayTimeDuration("P31D") ne xs:yearMonthDuration("P1M")
xs:dayTimeDuration("P31DT23H59M59S") div xs:dayTimeDuration("P0DT0H0M01S")
xs:dayTimeDuration("P31DT23H59M59S") eq xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P31DT23H59M59S") ge xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P31DT23H59M59S") gt xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P31DT23H59M59S") le xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P31DT23H59M59S") lt xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P31DT23H59M59S") ne xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P31DT23H59M59S") + xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P31DT23H59M59S") - xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P31DT23H59M59S") * xs:double("0")
xs:dayTimeDuration("P3D") div xs:double("-0")
xs:dayTimeDuration("P3D") div xs:double("-INF") eq xs:dayTimeDuration("PT0S")
xs:dayTimeDuration("P3D") div xs:double("INF") eq xs:dayTimeDuration("PT0S")
xs:dayTimeDuration("P3D") div xs:duration("P3Y3M")
xs:dayTimeDuration("P3D") div xs:yearMonthDuration("P3Y3M")
xs:dayTimeDuration("P3DT08H34M12.142S") lt xs:dayTimeDuration("P3DT08H34M12.143S")
xs:dayTimeDuration("P3DT08H34M12.143S") eq xs:dayTimeDuration("P3DT08H34M12.143S")
xs:dayTimeDuration("P3DT08H34M12.143S") ge xs:dayTimeDuration("P3DT08H34M12.143S")
xs:dayTimeDuration("P3DT08H34M12.143S") ge xs:duration("P1999Y10M3DT08H34M12.143S")
xs:dayTimeDuration("P3DT08H34M12.143S") ge xs:yearMonthDuration("P1999Y10M")
xs:dayTimeDuration("P3DT08H34M12.143S") gt xs:duration("P1999Y10M3DT08H34M12.143S")
xs:dayTimeDuration("P3DT08H34M12.143S") gt xs:yearMonthDuration("P1999Y10M")
xs:dayTimeDuration("P3DT08H34M12.143S") le xs:dayTimeDuration("P3DT08H34M12.143S")
xs:dayTimeDuration("P3DT08H34M12.143S") le xs:duration("P1999Y10M3DT08H34M12.143S")
xs:dayTimeDuration("P3DT08H34M12.143S") le xs:yearMonthDuration("P1999Y10M")
xs:dayTimeDuration("P3DT08H34M12.143S") lt xs:duration("P1999Y10M3DT08H34M12.143S")
xs:dayTimeDuration("P3DT08H34M12.143S") lt xs:yearMonthDuration("P1999Y10M")
xs:dayTimeDuration("P3DT08H34M12.143S") = xs:untypedAtomic("P3DT08H34M12.143S")
xs:dayTimeDuration("P3DT08H34M12.144S") ge xs:dayTimeDuration("P3DT08H34M12.143S")
xs:dayTimeDuration("P3DT08H34M12.144S") gt xs:dayTimeDuration("P3DT08H34M12.143S")
xs:dayTimeDuration("+P3DT10H")
xs:dayTimeDuration("P3DT10H+08:00")
xs:dayTimeDuration("P3DT10H30M") castable as xs:anyURI
xs:dayTimeDuration("P3DT10H30M") castable as xs:base64Binary
xs:dayTimeDuration("P3DT10H30M") castable as xs:boolean
xs:dayTimeDuration("P3DT10H30M") castable as xs:date
xs:dayTimeDuration("P3DT10H30M") castable as xs:dateTime
xs:dayTimeDuration("P3DT10H30M") castable as xs:dayTimeDuration
xs:dayTimeDuration("P3DT10H30M") castable as xs:decimal
xs:dayTimeDuration("P3DT10H30M") castable as xs:double
xs:dayTimeDuration("P3DT10H30M") castable as xs:duration
xs:dayTimeDuration("P3DT10H30M") castable as xs:float
xs:dayTimeDuration("P3DT10H30M") castable as xs:gDay
xs:dayTimeDuration("P3DT10H30M") castable as xs:gMonth
xs:dayTimeDuration("P3DT10H30M") castable as xs:gMonthDay
xs:dayTimeDuration("P3DT10H30M") castable as xs:gYear
xs:dayTimeDuration("P3DT10H30M") castable as xs:gYearMonth
xs:dayTimeDuration("P3DT10H30M") castable as xs:hexBinary
xs:dayTimeDuration("P3DT10H30M") castable as xs:integer
xs:dayTimeDuration("P3DT10H30M") castable as xs:string
xs:dayTimeDuration("P3DT10H30M") castable as xs:time
xs:dayTimeDuration("P3DT10H30M") castable as xs:untypedAtomic
xs:dayTimeDuration("P3DT10H30M") castable as xs:yearMonthDuration
xs:dayTimeDuration("P3DT10H30M") cast as xs:anyURI
xs:dayTimeDuration("P3DT10H30M") cast as xs:base64Binary
xs:dayTimeDuration("P3DT10H30M") cast as xs:boolean
xs:dayTimeDuration("P3DT10H30M") cast as xs:date
xs:dayTimeDuration("P3DT10H30M") cast as xs:dateTime
xs:dayTimeDuration("P3DT10H30M") cast as xs:dayTimeDuration
xs:dayTimeDuration("P3DT10H30M") cast as xs:decimal
xs:dayTimeDuration("P3DT10H30M") cast as xs:double
xs:dayTimeDuration("P3DT10H30M") cast as xs:duration
xs:dayTimeDuration("P3DT10H30M") cast as xs:float
xs:dayTimeDuration("P3DT10H30M") cast as xs:gDay
xs:dayTimeDuration("P3DT10H30M") cast as xs:gMonth
xs:dayTimeDuration("P3DT10H30M") cast as xs:gMonthDay
xs:dayTimeDuration("P3DT10H30M") cast as xs:gYear
xs:dayTimeDuration("P3DT10H30M") cast as xs:gYearMonth
xs:dayTimeDuration("P3DT10H30M") cast as xs:hexBinary
xs:dayTimeDuration("P3DT10H30M") cast as xs:integer
xs:dayTimeDuration("P3DT10H30M") cast as xs:string
xs:dayTimeDuration("P3DT10H30M") cast as xs:time
xs:dayTimeDuration("P3DT10H30M") cast as xs:untypedAtomic
xs:dayTimeDuration("P3DT10H30M") cast as xs:yearMonthDuration
xs:dayTimeDuration('P3DT10H30M') div xs:double('NaN')
xs:dayTimeDuration('P3DT10H30M') * xs:double('NaN')
xs:dayTimeDuration("P3DT2H") castable as xs:dayTimeDuration
xs:dayTimeDuration("P3DT2H") castable as xs:duration
xs:dayTimeDuration("P3DT2H") castable as xs:string
xs:dayTimeDuration("P3DT2H") castable as xs:untypedAtomic
xs:dayTimeDuration("P3DT2H") castable as xs:yearMonthDuration
xs:dayTimeDuration("P3DT2H") cast as xs:anyURI
xs:dayTimeDuration("P3DT2H") cast as xs:base64Binary
xs:dayTimeDuration("P3DT2H") cast as xs:boolean
xs:dayTimeDuration("P3DT2H") cast as xs:date
xs:dayTimeDuration("P3DT2H") cast as xs:dateTime
xs:dayTimeDuration("P3DT2H") cast as xs:dayTimeDuration eq xs:dayTimeDuration("P3DT2H")
xs:dayTimeDuration("P3DT2H") cast as xs:decimal
xs:dayTimeDuration("P3DT2H") cast as xs:double
xs:dayTimeDuration("P3DT2H") cast as xs:duration ne xs:duration("P1Y2M3DT10H30M")
xs:dayTimeDuration("P3DT2H") cast as xs:float
xs:dayTimeDuration("P3DT2H") cast as xs:gDay
xs:dayTimeDuration("P3DT2H") cast as xs:gMonth
xs:dayTimeDuration("P3DT2H") cast as xs:gMonthDay
xs:dayTimeDuration("P3DT2H") cast as xs:gYear
xs:dayTimeDuration("P3DT2H") cast as xs:gYearMonth
xs:dayTimeDuration("P3DT2H") cast as xs:hexBinary
xs:dayTimeDuration("P3DT2H") cast as xs:integer
xs:dayTimeDuration("P3DT2H") cast as xs:string ne xs:string("an arbitrary string")
xs:dayTimeDuration("P3DT2H") cast as xs:time
xs:dayTimeDuration("P3DT2H") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:dayTimeDuration("P3DT2H") cast as xs:yearMonthDuration ne xs:yearMonthDuration("P1Y12M")
xs:dayTimeDuration(" P3DT2H ") eq xs:dayTimeDuration(" P3DT2H ")
xs:dayTimeDuration( "P3DT2H" , "P3DT2H" )
xs:dayTimeDuration("P3DT4H3M3.100S") * 0 eq xs:dayTimeDuration("PT0S")
xs:dayTimeDuration("P3DT4H3M3.100S") div 0
xs:dayTimeDuration("P3DT4H3M3.100S") div xs:double("NaN")
xs:dayTimeDuration("P3DT4H3M3.100S") + xs:dayTimeDuration("PT0S") eq xs:dayTimeDuration("P3DT4H3M3.100S")
xs:dayTimeDuration("P3DT4H3M3.100S") - xs:dayTimeDuration("PT0S") eq xs:dayTimeDuration("P3DT4H3M3.100S")
xs:dayTimeDuration("P3DT4H3M3.100S") * xs:double("-0") eq xs:dayTimeDuration("PT0S")
xs:dayTimeDuration("P3DT4H3M3.100S") * xs:double("-INF")
xs:dayTimeDuration("P3DT4H3M3.100S") * xs:double("INF")
xs:dayTimeDuration("P3DT4H3M3.100S") * xs:double("NaN")
xs:dayTimeDuration("P3D") - xs:date("1999-08-12")
xs:dayTimeDuration("P3D") - xs:dateTime("1999-08-12T08:01:23")
xs:dayTimeDuration("P3D") * xs:dayTimeDuration("P3D")
xs:dayTimeDuration("P3D") + xs:duration("P3Y3M")
xs:dayTimeDuration("P3D") - xs:duration("P3Y3M")
xs:dayTimeDuration("P3D") - xs:time("08:01:23")
xs:dayTimeDuration("P3D") * xs:yearMonthDuration("P3Y3M")
xs:dayTimeDuration("P3D") + xs:yearMonthDuration("P3Y3M")
xs:dayTimeDuration("P3D") - xs:yearMonthDuration("P3Y3M")
(xs:dayTimeDuration("P42DT10H10M") * 2.0) div (xs:dayTimeDuration("P42DT10H10M") * 2.0)
(xs:dayTimeDuration("P42DT10H10M") div 2.0) div (xs:dayTimeDuration("P42DT10H10M") div 2.0)
(xs:dayTimeDuration("P42DT10H10M") - xs:dayTimeDuration("P10DT10H10M")) div (xs:dayTimeDuration("P20DT10H10M") - xs:dayTimeDuration("P18DT10H10M"))
(xs:dayTimeDuration("P42DT10H10M") + xs:dayTimeDuration("P10DT10H10M")) div (xs:dayTimeDuration("P42DT10H10M") + xs:dayTimeDuration("P10DT10H10M"))
xs:dayTimeDuration('P5999999999999999999DT00H00M01S') * 2
xs:dayTimeDuration('P5999999999999999999DT00H00M01S') div 0.5
xs:dayTimeDuration('P5999999999999999999DT00H00M01S') div xs:dayTimeDuration('P0DT00H00M0.000001S')
xs:dayTimeDuration('P5999999999999999999DT00H00M01S') + xs:dayTimeDuration('P4999999999999999999DT00H00M01S')
xs:dayTimeDuration('P5999999999999999999DT00H00M01S') - xs:dayTimeDuration('-P5999999999999999999DT00H00M01S')
xs:dayTimeDuration("P6DT16H34M59.613999S") eq xs:dayTimeDuration("P6DT16H34M59.613999S")
xs:dayTimeDuration("P8DT4H4M4.400S") div 4 eq xs:dayTimeDuration("P2DT1H1M1.1S")
xs:dayTimeDuration("P9223372036854775806D") div xs:dayTimeDuration("P4611686018427387903D")
xs:dayTimeDuration("P9223372036854775807D") div 0.5
xs:dayTimeDuration("P9223372036854775807D") div xs:dayTimeDuration("P0D")
xs:dayTimeDuration("P9223372036854775807D") div xs:dayTimeDuration("P0DT0H0M0.000000001S")
xs:dayTimeDuration("PDT3H2M10.001S")
xs:dayTimeDuration("PT08H34M12.143S") ne xs:dayTimeDuration("P3DT08H34M12.143S")
xs:dayTimeDuration("-PT0S") eq xs:dayTimeDuration("PT0S")
xs:dayTimeDuration("PT0S") eq xs:dayTimeDuration("PT0S")
xs:dayTimeDuration("PT0S") eq xs:duration("PT0S")
xs:dayTimeDuration("PT0S") eq xs:yearMonthDuration("P0M")
xs:dayTimeDuration("PT0S") + xs:dayTimeDuration("P3DT4H3M3.100S") eq xs:dayTimeDuration("P3DT4H3M3.100S")
xs:dayTimeDuration("PT0S") - xs:dayTimeDuration("P3DT4H3M3.100S") eq xs:dayTimeDuration("-P3DT4H3M3.100S")
xs:dayTimeDuration("-PT100M") castable as xs:dayTimeDuration
xs:dayTimeDuration("-PT100M") castable as xs:duration
xs:dayTimeDuration("-PT100M") castable as xs:string
xs:dayTimeDuration("-PT100M") castable as xs:untypedAtomic
xs:dayTimeDuration("-PT100M") cast as xs:dayTimeDuration
xs:dayTimeDuration("-PT100M") cast as xs:duration
xs:dayTimeDuration("-PT100M") cast as xs:string
xs:dayTimeDuration("-PT100M") cast as xs:untypedAtomic
xs:dayTimeDuration("PT24H") castable as xs:duration
xs:dayTimeDuration("PT24H") cast as xs:duration
xs:dayTimeDuration("PT2H10M") * 2.1
(xs:dayTimeDuration("PT8M") div xs:dayTimeDuration("PT2M")) eq 4
xs:dayTimeDuration(xs:untypedAtomic( "P3DT2H" )) eq xs:dayTimeDuration("P3DT2H")
xs:decimal("")
xs:decimal()
-xs:decimal(0)
xs:decimal(0) and xs:decimal(0)
xs:decimal(0) and xs:decimal(1)
xs:decimal(0) or xs:decimal(0)
xs:decimal(0) or xs:decimal(1)
xs:decimal("0") * xs:decimal("617375191608514839")
xs:decimal("0") - xs:decimal("-999999999999999999")
xs:decimal("0") - xs:decimal("999999999999999999")
xs:decimal("-1.0000000000") * xs:decimal("-999999999999999999")
xs:decimal("-1.0000000000") * xs:decimal("999999999999999999")
xs:decimal( "10.01" , "10.01" )
xs:decimal("10.01") castable as xs:boolean
xs:decimal("10.01") castable as xs:decimal
xs:decimal("10.01") castable as xs:double
xs:decimal("10.01") castable as xs:float
xs:decimal("10.01") castable as xs:integer
xs:decimal("10.01") castable as xs:string
xs:decimal("10.01") castable as xs:untypedAtomic
xs:decimal("10.01") cast as xs:anyURI
xs:decimal("10.01") cast as xs:base64Binary
xs:decimal("10.01") cast as xs:boolean eq xs:boolean("true")
xs:decimal("10.01") cast as xs:date
xs:decimal("10.01") cast as xs:dateTime
xs:decimal("10.01") cast as xs:dayTimeDuration
xs:decimal("10.01") cast as xs:decimal eq xs:decimal("10.01")
xs:decimal("10.01") cast as xs:double ne xs:double("3.3e3")
xs:decimal("10.01") cast as xs:duration
xs:decimal("10.01") cast as xs:float ne xs:float("3.4e5")
xs:decimal("10.01") cast as xs:gDay
xs:decimal("10.01") cast as xs:gMonth
xs:decimal("10.01") cast as xs:gMonthDay
xs:decimal("10.01") cast as xs:gYear
xs:decimal("10.01") cast as xs:gYearMonth
xs:decimal("10.01") cast as xs:hexBinary
xs:decimal("10.01") cast as xs:integer ne xs:integer("6789")
xs:decimal("10.01") cast as xs:string ne xs:string("an arbitrary string")
xs:decimal("10.01") cast as xs:time
xs:decimal("10.01") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:decimal("10.01") cast as xs:yearMonthDuration
xs:decimal(" 10.01 ") eq xs:decimal(" 10.01 ")
xs:decimal("-1.1234") castable as xs:anyURI
xs:decimal("-1.1234") castable as xs:base64Binary
xs:decimal("-1.1234") castable as xs:boolean
xs:decimal("-1.1234") castable as xs:date
xs:decimal("-1.1234") castable as xs:dateTime
xs:decimal("-1.1234") castable as xs:dayTimeDuration
xs:decimal("-1.1234") castable as xs:decimal
xs:decimal("-1.1234") castable as xs:double
xs:decimal("-1.1234") castable as xs:duration
xs:decimal("-1.1234") castable as xs:float
xs:decimal("-1.1234") castable as xs:gDay
xs:decimal("-1.1234") castable as xs:gMonth
xs:decimal("-1.1234") castable as xs:gMonthDay
xs:decimal("-1.1234") castable as xs:gYear
xs:decimal("-1.1234") castable as xs:gYearMonth
xs:decimal("-1.1234") castable as xs:hexBinary
xs:decimal("-1.1234") castable as xs:integer
xs:decimal("-1.1234") castable as xs:string
xs:decimal("-1.1234") castable as xs:time
xs:decimal("-1.1234") castable as xs:untypedAtomic
xs:decimal("-1.1234") castable as xs:yearMonthDuration
xs:decimal("-1.1234") cast as xs:anyURI
xs:decimal("-1.1234") cast as xs:base64Binary
xs:decimal("-1.1234") cast as xs:boolean
xs:decimal("-1.1234") cast as xs:date
xs:decimal("-1.1234") cast as xs:dateTime
xs:decimal("-1.1234") cast as xs:dayTimeDuration
xs:decimal("-1.1234") cast as xs:decimal
xs:decimal("-1.1234") cast as xs:double
xs:decimal("-1.1234") cast as xs:duration
xs:decimal("-1.1234") cast as xs:float
xs:decimal("-1.1234") cast as xs:gDay
xs:decimal("-1.1234") cast as xs:gMonth
xs:decimal("-1.1234") cast as xs:gMonthDay
xs:decimal("-1.1234") cast as xs:gYear
xs:decimal("-1.1234") cast as xs:gYearMonth
xs:decimal("-1.1234") cast as xs:hexBinary
xs:decimal("-1.1234") cast as xs:integer
xs:decimal("-1.1234") cast as xs:string
xs:decimal("-1.1234") cast as xs:time
xs:decimal("-1.1234") cast as xs:untypedAtomic
xs:decimal("-1.1234") cast as xs:yearMonthDuration
xs:decimal(-1.1) eq xs:decimal(-1.1)
xs:decimal(1.1) eq xs:decimal(1.1)
xs:decimal(1.1) ne xs:decimal(2.1)
(xs:decimal(1), 2, 3)
xs:decimal(-123456789.123456789123456789) and xs:decimal(1)
xs:decimal(-123456789.123456789123456789) or xs:decimal(1)
xs:decimal(12678967.543233) cast as xs:boolean
xs:decimal(12678967.543233) cast as xs:decimal
xs:decimal(12678967.543233) cast as xs:integer
xs:decimal(12678967.543233) cast as xs:string
xs:decimal(-1) and xs:decimal(0)
xs:decimal(1) and xs:decimal(-1)
xs:decimal(1) ge xs:decimal(1)
xs:decimal(1) gt xs:decimal(-1)
xs:decimal(-1) le xs:decimal(1)
xs:decimal(-1) lt xs:decimal(1)
xs:decimal(-1) or xs:decimal(0)
xs:decimal(1) or xs:decimal(-1)
xs:decimal(3.1) eq 3.1
xs:decimal("-382624808391485160") - xs:decimal("617375191608514839")
xs:decimal(3) eq 3
xs:decimal("5.5432") castable as xs:integer
xs:decimal("5.5432") cast as xs:integer
xs:decimal(5) div xs:decimal(2) eq 2.5
xs:decimal(5) div xs:decimal(2) ne 2.6
(xs:decimal(5) mod xs:untypedAtomic("3")) eq 2
+(xs:decimal("617375191608514839"))
-(xs:decimal("617375191608514839"))
xs:decimal("617375191608514839") eq xs:decimal("-999999999999999999")
xs:decimal("617375191608514839") ge xs:decimal("-999999999999999999")
xs:decimal("617375191608514839") gt xs:decimal("-999999999999999999")
xs:decimal("617375191608514839") idiv xs:decimal("-999999999999999999")
xs:decimal("617375191608514839") lt xs:decimal("-999999999999999999")
xs:decimal("617375191608514839") ne xs:decimal("-999999999999999999")
xs:decimal("617375191608514839") * xs:decimal("0")
xs:decimal("617375191608514839") + xs:decimal("-999999999999999999")
xs:decimal(6.1) + xs:decimal(2.1) eq 8.2
xs:decimal(6) div xs:decimal(2) eq 3
(xs:decimal(6) div xs:decimal(2)) instance of xs:decimal
(xs:decimal(6) div xs:double(2)) instance of xs:double
(xs:decimal(6) div xs:integer(2)) instance of xs:decimal
(xs:decimal(6) idiv xs:decimal(2)) instance of xs:integer
(xs:decimal(6) idiv xs:double(2)) instance of xs:integer
(xs:decimal(6) idiv xs:float(2)) instance of xs:integer
(xs:decimal(6) idiv xs:integer(2)) instance of xs:integer
xs:decimal(6) instance of xs:decimal
(xs:decimal(6) mod xs:decimal(2)) instance of xs:decimal
(xs:decimal(6) mod xs:double(2)) instance of xs:double
(xs:decimal(6) mod xs:integer(2)) instance of xs:decimal
xs:decimal(6) * xs:decimal(2) eq 12
xs:decimal(6) - xs:decimal(2) eq 4
xs:decimal(6) + xs:decimal(2) eq 8
(xs:decimal(6) * xs:decimal(2)) instance of xs:decimal
(xs:decimal(6) + xs:decimal(2)) instance of xs:decimal
(xs:decimal(6) - xs:decimal(2)) instance of xs:decimal
(xs:decimal(6) * xs:double(2)) instance of xs:double
(xs:decimal(6) + xs:double(2)) instance of xs:double
(xs:decimal(6) - xs:double(2)) instance of xs:double
(xs:decimal(6) * xs:integer(2)) instance of xs:decimal
(xs:decimal(6) + xs:integer(2)) instance of xs:decimal
(xs:decimal(6) - xs:integer(2)) instance of xs:decimal
+(xs:decimal("-999999999999999999"))
+(xs:decimal("999999999999999999"))
-(xs:decimal("-999999999999999999"))
-(xs:decimal("999999999999999999"))
xs:decimal(9.99999999999999999999999999) and xs:decimal(0)
xs:decimal(9.99999999999999999999999999) and xs:decimal(-123456789.123456789123456789)
xs:decimal(9.99999999999999999999999999) or xs:decimal(0)
xs:decimal(9.99999999999999999999999999) or xs:decimal(-123456789.123456789123456789)
xs:decimal("-999999999999999999") div xs:decimal("-999999999999999999")
xs:decimal("-999999999999999999") div xs:decimal("999999999999999999")
xs:decimal("999999999999999999") div xs:decimal("-999999999999999999")
xs:decimal("-999999999999999999") eq xs:decimal("617375191608514839")
xs:decimal("-999999999999999999") eq xs:decimal("-999999999999999999")
xs:decimal("-999999999999999999") eq xs:decimal("999999999999999999")
xs:decimal("999999999999999999") eq xs:decimal("-999999999999999999")
xs:decimal("-999999999999999999") ge xs:decimal("617375191608514839")
xs:decimal("-999999999999999999") ge xs:decimal("-999999999999999999")
xs:decimal("-999999999999999999") ge xs:decimal("999999999999999999")
xs:decimal("999999999999999999") ge xs:decimal("-999999999999999999")
xs:decimal("-999999999999999999") gt xs:decimal("617375191608514839")
xs:decimal("-999999999999999999") gt xs:decimal("-999999999999999999")
xs:decimal("-999999999999999999") gt xs:decimal("999999999999999999")
xs:decimal("999999999999999999") gt xs:decimal("-999999999999999999")
xs:decimal("-999999999999999999") idiv xs:decimal("617375191608514839")
xs:decimal("-999999999999999999") idiv xs:decimal("-999999999999999999")
xs:decimal("-999999999999999999") idiv xs:decimal("999999999999999999")
xs:decimal("999999999999999999") idiv xs:decimal("-999999999999999999")
xs:decimal("-999999999999999999") lt xs:decimal("617375191608514839")
xs:decimal("-999999999999999999") lt xs:decimal("-999999999999999999")
xs:decimal("-999999999999999999") lt xs:decimal("999999999999999999")
xs:decimal("999999999999999999") lt xs:decimal("-999999999999999999")
xs:decimal("-999999999999999999") mod xs:decimal("617375191608514839")
xs:decimal("-999999999999999999") mod xs:decimal("999999999999999999")
xs:decimal("-999999999999999999") ne xs:decimal("617375191608514839")
xs:decimal("-999999999999999999") ne xs:decimal("-999999999999999999")
xs:decimal("-999999999999999999") ne xs:decimal("999999999999999999")
xs:decimal("999999999999999999") ne xs:decimal("-999999999999999999")
xs:decimal("999999999999999999") * xs:decimal("-1.0000000000")
xs:decimal("-999999999999999999") + xs:decimal("617375191608514839")
xs:decimal("-999999999999999999") + xs:decimal("999999999999999999")
xs:decimal("-999999999999999999") - xs:decimal("-999999999999999999")
xs:decimal("999999999999999999") + xs:decimal("-999999999999999999")
xs:decimal(99e100)
xs:decimal(fn:translate("123","123","123"))
xs:decimal("inf")
xs:decimal("inF")
xs:decimal("+Inf")
xs:decimal("-Inf")
xs:decimal("Inf")
xs:decimal("+InF")
xs:decimal("-InF")
xs:decimal("InF")
xs:decimal("+ INF")
xs:decimal("+INF")
xs:decimal("- INF")
xs:decimal("INF")
xs:decimal("nan")
xs:decimal("naN")
xs:decimal("NaN")
xs:decimal(remove((1, 2, 3), 1))
(xs:decimal(remove((3e3, 1.1), 1))) eq 1.1
xs:decimal(xs:byte(3))
xs:decimal(xs:double("-INF"))
xs:decimal(xs:double("INF"))
xs:decimal(xs:double("NaN"))
xs:decimal(xs:float("-INF"))
xs:decimal(xs:float("INF"))
xs:decimal(xs:float("NaN"))
xs:decimal(xs:int(3))
xs:decimal(xs:long(3))
xs:decimal(xs:negativeInteger(-3))
xs:decimal(xs:nonNegativeInteger(3))
xs:decimal(xs:nonPositiveInteger(0))
xs:decimal(xs:short(3))
xs:decimal(xs:unsignedByte(3))
xs:decimal(xs:unsignedInt(3))
xs:decimal(xs:unsignedLong(3))
xs:decimal(xs:unsignedShort(3))
xs:decimal(xs:untypedAtomic( "10.01" )) eq xs:decimal("10.01")
xs:double("")
xs:double()
+(xs:double("0"))
-(xs:double("0"))
-xs:double(0)
xs:double(-0.0)
xs:double("-0.0E0") castable as xs:decimal
xs:double("-0.0E0") castable as xs:float
xs:double("-0.0E0") castable as xs:integer
xs:double("-0.0E0") cast as xs:decimal
xs:double("-0.0E0") cast as xs:float
xs:double("-0.0E0") cast as xs:integer
xs:double(0) and xs:double(0)
xs:double(0) and xs:double(1)
xs:double("0") div xs:double("-1.7976931348623157E308")
xs:double("0") eq xs:double("-1.7976931348623157E308")
xs:double("0") ge xs:double("-1.7976931348623157E308")
xs:double("0") gt xs:double("-1.7976931348623157E308")
xs:double("0") lt xs:double("-1.7976931348623157E308")
xs:double("-0") mod 3
xs:double("0") mod 3
xs:double("-0") mod xs:double("-0")
xs:double("-0") mod xs:double("4")
xs:double("0") mod xs:double("4")
xs:double("-0") mod xs:double("-INF")
xs:double("-0") mod xs:double("INF")
xs:double("0") mod xs:double("-INF")
xs:double("0") mod xs:double("INF")
xs:double("0") ne xs:double("-1.7976931348623157E308")
xs:double("0") ne xs:double("-INF")
xs:double("0") ne xs:double("INF")
xs:double(0) ne xs:double("NaN")
xs:double(0) or xs:double(0)
xs:double(0) or xs:double(1)
xs:double("-0") * xs:dayTimeDuration("P3DT4H3M3.100S") eq xs:dayTimeDuration("PT0S")
(xs:double("0")||xs:double("-1.7976931348623157E308"))
xs:double("0") * xs:double("-1.7976931348623157E308")
xs:double("0") + xs:double("-1.7976931348623157E308")
xs:double("0") - xs:double("-1.7976931348623157E308")
xs:double("0") - xs:double("1.7976931348623157E308")
xs:double("-1.0000000000") * xs:double("-1.7976931348623157E308")
xs:double("-1.0000000000") * xs:double("1.7976931348623157E308")
xs:double("-10000000") mod xs:double("-10000000")
xs:double("-10000000") mod xs:double("10000000")
xs:double("10000000") mod xs:double("-10000000")
xs:double("10000000") mod xs:double("10000000")
xs:double(-1.1) eq xs:double(-1.1)
xs:double(1.1) eq xs:double(1.1)
(xs:double(1.1) idiv 1.1) instance of xs:integer
xs:double(1.1) ne xs:double(2.1)
xs:double(1.1) + xs:double(2.2) ne 3.3
xs:double(1267.43233E12) cast as xs:boolean
(xs:double(1267.43233E12) cast as xs:float) eq xs:float(1267.43233E12)
xs:double("12.78e-2") idiv xs:double("3")
(xs:double(1.2E2), 2.2E2, 3.3E2)
xs:double(1.5) idiv xs:decimal(1)
xs:double("-1.75e-3") castable as xs:decimal
xs:double("-1.75e-3") castable as xs:float
xs:double("-1.75e-3") castable as xs:integer
xs:double("-1.75e-3") cast as xs:float
xs:double("-1.75e-3") cast as xs:integer
+(xs:double("-1.7976931348623157E308"))
+(xs:double("1.7976931348623157E308"))
-(xs:double("-1.7976931348623157E308"))
-(xs:double("1.7976931348623157E308"))
xs:double("-1.7976931348623157E308") div xs:double("-1.7976931348623157E308")
xs:double("-1.7976931348623157E308") div xs:double("1.7976931348623157E308")
xs:double("1.7976931348623157E308") div xs:double("-1.7976931348623157E308")
xs:double("-1.7976931348623157E308") eq xs:double("0")
xs:double("-1.7976931348623157E308") eq xs:double("-1.7976931348623157E308")
xs:double("-1.7976931348623157E308") eq xs:double("1.7976931348623157E308")
xs:double("1.7976931348623157E308") eq xs:double("-1.7976931348623157E308")
xs:double("-1.7976931348623157E308") ge xs:double("0")
xs:double("-1.7976931348623157E308") ge xs:double("-1.7976931348623157E308")
xs:double("-1.7976931348623157E308") ge xs:double("1.7976931348623157E308")
xs:double("1.7976931348623157E308") ge xs:double("-1.7976931348623157E308")
xs:double("-1.7976931348623157E308") gt xs:double("0")
xs:double("-1.7976931348623157E308") gt xs:double("-1.7976931348623157E308")
xs:double("-1.7976931348623157E308") gt xs:double("1.7976931348623157E308")
xs:double("1.7976931348623157E308") gt xs:double("-1.7976931348623157E308")
xs:double("-1.7976931348623157E308") lt xs:double("0")
xs:double("-1.7976931348623157E308") lt xs:double("-1.7976931348623157E308")
xs:double("-1.7976931348623157E308") lt xs:double("1.7976931348623157E308")
xs:double("1.7976931348623157E308") lt xs:double("-1.7976931348623157E308")
xs:double("-1.7976931348623157E308") mod xs:double("1.7976931348623157E308")
xs:double("-1.7976931348623157E308") ne xs:double("0")
xs:double("-1.7976931348623157E308") ne xs:double("-1.7976931348623157E308")
xs:double("-1.7976931348623157E308") ne xs:double("1.7976931348623157E308")
xs:double("1.7976931348623157E308") ne xs:double("-1.7976931348623157E308")
(xs:double("-1.7976931348623157E308") || xs:double("0"))
xs:double("-1.7976931348623157E308") * xs:double("0")
xs:double("-1.7976931348623157E308") + xs:double("0")
xs:double("-1.7976931348623157E308") - xs:double("0")
xs:double("1.7976931348623157E308") * xs:double("-1.0000000000")
(xs:double("-1.7976931348623157E308") || xs:double("1.7976931348623157E308"))
(xs:double("-1.7976931348623157E308")||xs:double("-1.7976931348623157E308"))
(xs:double("1.7976931348623157E308")||xs:double("-1.7976931348623157E308"))
xs:double("-1.7976931348623157E308") + xs:double("1.7976931348623157E308")
xs:double("-1.7976931348623157E308") - xs:double("-1.7976931348623157E308")
xs:double("1.7976931348623157E308") + xs:double("-1.7976931348623157E308")
xs:double(-1) and xs:double(0)
xs:double(1) and xs:double(-1)
xs:double("1e5") castable as xs:anyURI
xs:double("1e5") castable as xs:base64Binary
xs:double("1e5") castable as xs:boolean
xs:double("1e5") castable as xs:date
xs:double("1e5") castable as xs:dateTime
xs:double("1e5") castable as xs:dayTimeDuration
xs:double("1e5") castable as xs:double
xs:double("1e5") castable as xs:duration
xs:double("1e5") castable as xs:float
xs:double("1e5") castable as xs:gDay
xs:double("1e5") castable as xs:gMonth
xs:double("1e5") castable as xs:gMonthDay
xs:double("1e5") castable as xs:gYear
xs:double("1e5") castable as xs:gYearMonth
xs:double("1e5") castable as xs:hexBinary
xs:double("1e5") castable as xs:integer
xs:double("1e5") castable as xs:time
xs:double("1e5") castable as xs:untypedAtomic
xs:double("1e5") castable as xs:yearMonthDuration
xs:double("1e5") cast as xs:anyURI
xs:double("1e5") cast as xs:base64Binary
xs:double("1e5") cast as xs:boolean
xs:double("1e5") cast as xs:date
xs:double("1e5") cast as xs:dateTime
xs:double("1e5") cast as xs:dayTimeDuration
xs:double("1e5") cast as xs:double
xs:double("1e5") cast as xs:duration
xs:double("1e5") cast as xs:float
xs:double("1e5") cast as xs:gDay
xs:double("1e5") cast as xs:gMonth
xs:double("1e5") cast as xs:gMonthDay
xs:double("1e5") cast as xs:gYear
xs:double("1e5") cast as xs:gYearMonth
xs:double("1e5") cast as xs:hexBinary
xs:double("1e5") cast as xs:integer
xs:double("1e5") cast as xs:time
xs:double("1e5") cast as xs:untypedAtomic
xs:double("1e5") cast as xs:yearMonthDuration
xs:double("1e8") castable as xs:string
xs:double(1) ge xs:double(1)
xs:double(1) gt xs:double(-1)
xs:double("1") idiv xs:double("0.0E0")
xs:double("1") idiv xs:double("NaN")
xs:double(-1) le xs:double(1)
xs:double(-1) lt xs:double(1)
xs:double(-1) ne xs:double(1)
xs:double(-1) or xs:double(0)
xs:double(1) or xs:double(-1)
(xs:double(1), xs:double(2), xs:double(3)) castable as xs:double*
xs:double("2.2250738585072012e-308")
xs:double(3.1) eq 3.1
xs:double( "3.3e3" , "3.3e3" )
xs:double("3.3e3") castable as xs:boolean
xs:double("3.3e3") castable as xs:double
xs:double("3.3e3") castable as xs:float
xs:double("3.3e3") castable as xs:string
xs:double("3.3e3") castable as xs:untypedAtomic
xs:double("3.3e3") cast as xs:anyURI
xs:double("3.3e3") cast as xs:base64Binary
xs:double("3.3e3") cast as xs:boolean eq xs:boolean("true")
xs:double("3.3e3") cast as xs:date
xs:double("3.3e3") cast as xs:dateTime
xs:double("3.3e3") cast as xs:dayTimeDuration
xs:double("3.3e3") cast as xs:double eq xs:double("3.3e3")
xs:double("3.3e3") cast as xs:duration
xs:double("3.3e3") cast as xs:float ne xs:float("3.4e5")
xs:double("3.3e3") cast as xs:gDay
xs:double("3.3e3") cast as xs:gMonth
xs:double("3.3e3") cast as xs:gMonthDay
xs:double("3.3e3") cast as xs:gYear
xs:double("3.3e3") cast as xs:gYearMonth
xs:double("3.3e3") cast as xs:hexBinary
xs:double("3.3e3") cast as xs:string ne xs:string("an arbitrary string")
xs:double("3.3e3") cast as xs:time
xs:double("3.3e3") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:double("3.3e3") cast as xs:yearMonthDuration
xs:double(" 3.3e3 ") eq xs:double(" 3.3e3 ")
xs:double(3) div "3"
(xs:double(3) div xs:untypedAtomic("3")) eq 1
xs:double(3) eq 3
xs:double("3") gt xs:double("NaN")
xs:double("3") idiv xs:double("-INF") eq xs:double(0)
xs:double("3") idiv xs:double("INF") eq xs:double(0)
xs:double("5.4321E-1001") castable as xs:decimal
xs:double("5.4321E-1001") castable as xs:float
xs:double("5.4321E-1001") cast as xs:decimal
xs:double("5.4321E-1001") cast as xs:float
xs:double(5) div xs:double(2) eq 2.5
xs:double(5) div xs:double(2) ne 2.6
(xs:double(6) div xs:decimal(2)) instance of xs:double
xs:double(6) div xs:double(2) eq 3
(xs:double(6) div xs:double(2)) instance of xs:double
(xs:double(6) div xs:float(2)) instance of xs:double
(xs:double(6) div xs:integer(2)) instance of xs:double
(xs:double(6) idiv xs:decimal(2)) instance of xs:integer
(xs:double(6) idiv xs:double(2)) instance of xs:integer
(xs:double(6) idiv xs:float(2)) instance of xs:integer
(xs:double(6) idiv xs:integer(2)) instance of xs:integer
xs:double(6) instance of xs:double
(xs:double(6) mod xs:decimal(2)) instance of xs:double
(xs:double(6) mod xs:double(2)) instance of xs:double
(xs:double(6) mod xs:float(2)) instance of xs:double
(xs:double(6) mod xs:integer(2)) instance of xs:double
(xs:double(6) * xs:decimal(2)) instance of xs:double
(xs:double(6) + xs:decimal(2)) instance of xs:double
(xs:double(6) - xs:decimal(2)) instance of xs:double
xs:double(6) * xs:double(2) eq 12
xs:double(6) - xs:double(2) eq 4
xs:double(6) + xs:double(2) eq 8
(xs:double(6) * xs:double(2)) instance of xs:double
(xs:double(6) + xs:double(2)) instance of xs:double
(xs:double(6) - xs:double(2)) instance of xs:double
(xs:double(6) * xs:float(2)) instance of xs:double
(xs:double(6) + xs:float(2)) instance of xs:double
(xs:double(6) - xs:float(2)) instance of xs:double
(xs:double(6) * xs:integer(2)) instance of xs:double
(xs:double(6) + xs:integer(2)) instance of xs:double
(xs:double(6) - xs:integer(2)) instance of xs:double
xs:double(fn:translate("123","123","123"))
xs:double("inf")
xs:double("inF")
xs:double("+Inf")
xs:double("-Inf")
xs:double("Inf")
xs:double("+InF")
xs:double("-InF")
xs:double("InF")
xs:double(" INF ")
xs:double("+ INF")
xs:double("+INF")
xs:double("- INF")
xs:double('-INF') and xs:double(0)
xs:double('INF') and xs:double(0)
xs:double('-INF') and xs:double(1)
xs:double('INF') and xs:double(1)
xs:double('-INF') and xs:double('INF')
xs:double('-INF') and xs:double('NaN')
xs:double('INF') and xs:double('NaN')
xs:double("INF") castable as xs:decimal
xs:double('-INF') castable as xs:decimal
xs:double('INF') castable as xs:decimal
xs:double("INF") castable as xs:double
xs:double("INF") castable as xs:integer
xs:double("INF") castable as xs:string
xs:double("INF") castable as xs:untypedAtomic
xs:double("INF") cast as xs:decimal
xs:double("INF") cast as xs:double
xs:double("INF") cast as xs:integer
xs:double("INF") cast as xs:string
xs:double("INF") cast as xs:untypedAtomic
xs:double("-INF") eq xs:double("-INF")
xs:double("INF") eq xs:double("INF")
xs:double("INF") gt 0
xs:double("INF") idiv xs:double("0")
xs:double("-INF") idiv xs:double("1")
xs:double("-INF") idiv xs:double(3)
xs:double("INF") idiv xs:double(3)
xs:double('INF') idiv xs:integer(2)
xs:double("-INF") lt 0
xs:double("-INF") mod 3
xs:double("INF") mod 3
xs:double("-INF") mod xs:double("-INF")
xs:double("INF") mod xs:double("INF")
xs:double("-INF") ne xs:double("0")
xs:double("INF") ne xs:double("0")
xs:double("-INF") ne xs:double("INF")
xs:double("INF") ne xs:double("-INF")
xs:double('-INF') or xs:double(0)
xs:double('INF') or xs:double(0)
xs:double('-INF') or xs:double(1)
xs:double('INF') or xs:double(1)
xs:double('-INF') or xs:double('INF')
xs:double('-INF') or xs:double('NaN')
xs:double('INF') or xs:double('NaN')
xs:double('-INF')[string() = '-INF']
xs:double("INF"), xs:double("-INF"), xs:float("-INF")
xs:double("nan")
xs:double("naN")
xs:double(" NaN ")
xs:double('NaN') and xs:double(0)
xs:double('NaN') and xs:double(1)
xs:double('NaN') and xs:double('NaN')
xs:double('NaN') castable as xs:decimal
xs:double("NaN") castable as xs:float
xs:double("NaN") castable as xs:integer
xs:double("NaN") cast as xs:float
xs:double("NaN") cast as xs:integer
xs:double("NaN") idiv 1
xs:double("NaN") mod 3
xs:double("NaN") mod xs:double("NaN")
xs:double("NaN") ne xs:double(0)
xs:double("NaN") ne xs:double("NaN")
xs:double('NaN') or xs:double(0)
xs:double('NaN') or xs:double(1)
xs:double('NaN') or xs:double('NaN')
xs:double('NaN') * xs:yearMonthDuration("P2Y")
xs:double(xs:byte(3))
xs:double(xs:int(3))
xs:double(xs:long(3))
xs:double(xs:negativeInteger(-3))
xs:double(xs:nonNegativeInteger(3))
xs:double(xs:nonPositiveInteger(0))
xs:double(xs:positiveInteger("52"))
xs:double(xs:short(3))
xs:double(xs:unsignedByte(3))
xs:double(xs:unsignedInt(3))
xs:double(xs:unsignedLong(3))
xs:double(xs:unsignedShort(3))
xs:double(xs:untypedAtomic( "3.3e3" )) eq xs:double("3.3e3")
xs:duration("")
xs:duration()
xs:duration("1Y2M123DT10H30M99S")
xs:duration("P12M") eq xs:duration("P12M")
xs:duration("P12M") ne xs:duration("P12M")
xs:duration("P1999Y01M3DT08H34M12.143S") ne xs:duration("P1999Y10M3DT08H34M12.143S")
xs:duration("P1999Y10M3DT08H34M12.142S") lt xs:duration("P1999Y10M3DT08H34M12.143S")
xs:duration("P1999Y10M3DT08H34M12.143S") eq xs:duration("P1999Y10M3DT08H34M12.143S")
xs:duration("P1999Y10M3DT08H34M12.143S") ge xs:dayTimeDuration("P3DT08H34M12.143S")
xs:duration("P1999Y10M3DT08H34M12.143S") ge xs:duration("P1999Y10M3DT08H34M12.143S")
xs:duration("P1999Y10M3DT08H34M12.143S") gt xs:dayTimeDuration("P3DT08H34M12.143S")
xs:duration("P1999Y10M3DT08H34M12.143S") le xs:dayTimeDuration("P3DT08H34M12.143S")
xs:duration("P1999Y10M3DT08H34M12.143S") le xs:duration("P1999Y10M3DT08H34M12.143S")
xs:duration("P1999Y10M3DT08H34M12.143S") lt xs:dayTimeDuration("P3DT08H34M12.143S")
xs:duration("P1999Y10M3DT08H34M12.144S") gt xs:duration("P1999Y10M3DT08H34M12.143S")
xs:duration("P1DT2H") eq xs:dayTimeDuration("P1DT2H")
xs:duration("P1M1DT2H") ne xs:dayTimeDuration("P1DT2H")
xs:duration("P1M") ne xs:duration("P31D")
xs:duration("P1Y12M0D") eq xs:yearMonthDuration("P1Y12M")
xs:duration("+P1Y2M123DT10H30M99S")
xs:duration("P1Y2M123DT10H30M99S+08:00")
xs:duration("P1Y2M3DT10H30M23S") castable as xs:anyURI
xs:duration("P1Y2M3DT10H30M23S") castable as xs:base64Binary
xs:duration("P1Y2M3DT10H30M23S") castable as xs:boolean
xs:duration("P1Y2M3DT10H30M23S") castable as xs:date
xs:duration("P1Y2M3DT10H30M23S") castable as xs:dateTime
xs:duration("P1Y2M3DT10H30M23S") castable as xs:dayTimeDuration
xs:duration("P1Y2M3DT10H30M23S") castable as xs:decimal
xs:duration("P1Y2M3DT10H30M23S") castable as xs:double
xs:duration("P1Y2M3DT10H30M23S") castable as xs:duration
xs:duration("P1Y2M3DT10H30M23S") castable as xs:float
xs:duration("P1Y2M3DT10H30M23S") castable as xs:gDay
xs:duration("P1Y2M3DT10H30M23S") castable as xs:gMonth
xs:duration("P1Y2M3DT10H30M23S") castable as xs:gMonthDay
xs:duration("P1Y2M3DT10H30M23S") castable as xs:gYear
xs:duration("P1Y2M3DT10H30M23S") castable as xs:gYearMonth
xs:duration("P1Y2M3DT10H30M23S") castable as xs:hexBinary
xs:duration("P1Y2M3DT10H30M23S") castable as xs:integer
xs:duration("P1Y2M3DT10H30M23S") castable as xs:string
xs:duration("P1Y2M3DT10H30M23S") castable as xs:time
xs:duration("P1Y2M3DT10H30M23S") castable as xs:untypedAtomic
xs:duration("P1Y2M3DT10H30M23S") castable as xs:yearMonthDuration
xs:duration("P1Y2M3DT10H30M23S") cast as xs:anyURI
xs:duration("P1Y2M3DT10H30M23S") cast as xs:base64Binary
xs:duration("P1Y2M3DT10H30M23S") cast as xs:boolean
xs:duration("P1Y2M3DT10H30M23S") cast as xs:date
xs:duration("P1Y2M3DT10H30M23S") cast as xs:dateTime
xs:duration("P1Y2M3DT10H30M23S") cast as xs:dayTimeDuration
xs:duration("P1Y2M3DT10H30M23S") cast as xs:decimal
xs:duration("P1Y2M3DT10H30M23S") cast as xs:double
xs:duration("P1Y2M3DT10H30M23S") cast as xs:duration
xs:duration("P1Y2M3DT10H30M23S") cast as xs:float
xs:duration("P1Y2M3DT10H30M23S") cast as xs:gDay
xs:duration("P1Y2M3DT10H30M23S") cast as xs:gMonth
xs:duration("P1Y2M3DT10H30M23S") cast as xs:gMonthDay
xs:duration("P1Y2M3DT10H30M23S") cast as xs:gYear
xs:duration("P1Y2M3DT10H30M23S") cast as xs:gYearMonth
xs:duration("P1Y2M3DT10H30M23S") cast as xs:hexBinary
xs:duration("P1Y2M3DT10H30M23S") cast as xs:integer
xs:duration("P1Y2M3DT10H30M23S") cast as xs:string
xs:duration("P1Y2M3DT10H30M23S") cast as xs:time
xs:duration("P1Y2M3DT10H30M23S") cast as xs:untypedAtomic
xs:duration("P1Y2M3DT10H30M23S") cast as xs:yearMonthDuration
xs:duration("P1Y2M3DT10H30M") castable as xs:dayTimeDuration
xs:duration("P1Y2M3DT10H30M") castable as xs:duration
xs:duration("P1Y2M3DT10H30M") castable as xs:string
xs:duration("P1Y2M3DT10H30M") castable as xs:untypedAtomic
xs:duration("P1Y2M3DT10H30M") castable as xs:yearMonthDuration
xs:duration("P1Y2M3DT10H30M") cast as xs:anyURI
xs:duration("P1Y2M3DT10H30M") cast as xs:base64Binary
xs:duration("P1Y2M3DT10H30M") cast as xs:boolean
xs:duration("P1Y2M3DT10H30M") cast as xs:date
xs:duration("P1Y2M3DT10H30M") cast as xs:dateTime
xs:duration("P1Y2M3DT10H30M") cast as xs:dayTimeDuration ne xs:dayTimeDuration("P3DT2H")
xs:duration("P1Y2M3DT10H30M") cast as xs:decimal
xs:duration("P1Y2M3DT10H30M") cast as xs:double
xs:duration("P1Y2M3DT10H30M") cast as xs:duration eq xs:duration("P1Y2M3DT10H30M")
xs:duration("P1Y2M3DT10H30M") cast as xs:float
xs:duration("P1Y2M3DT10H30M") cast as xs:gDay
xs:duration("P1Y2M3DT10H30M") cast as xs:gMonth
xs:duration("P1Y2M3DT10H30M") cast as xs:gMonthDay
xs:duration("P1Y2M3DT10H30M") cast as xs:gYear
xs:duration("P1Y2M3DT10H30M") cast as xs:gYearMonth
xs:duration("P1Y2M3DT10H30M") cast as xs:hexBinary
xs:duration("P1Y2M3DT10H30M") cast as xs:integer
xs:duration("P1Y2M3DT10H30M") cast as xs:string ne xs:string("an arbitrary string")
xs:duration("P1Y2M3DT10H30M") cast as xs:time
xs:duration("P1Y2M3DT10H30M") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:duration("P1Y2M3DT10H30M") cast as xs:yearMonthDuration ne xs:yearMonthDuration("P1Y12M")
xs:duration(" P1Y2M3DT10H30M ") eq xs:duration(" P1Y2M3DT10H30M ")
xs:duration( "P1Y2M3DT10H30M" , "P1Y2M3DT10H30M" )
xs:duration("P1Y3M") * 3
xs:duration("-P1Y3M4DT08H4M33S") ne xs:duration("P1Y3M4DT08H4M33S")
xs:duration("P1Y3M") div 3
xs:duration("P1Y") eq xs:duration("P12M")
xs:duration("P1Y") eq xs:duration("P1Y")
xs:duration("P1Y") eq xs:duration("P365D")
xs:duration("P1Y") ne xs:duration("P1Y")
xs:duration("P1Y") ne xs:duration("P365D")
xs:duration("P24H")
xs:duration("P24M") castable as xs:dayTimeDuration
xs:duration("P24M") castable as xs:yearMonthDuration
xs:duration("P24M") cast as xs:dayTimeDuration
xs:duration("P24M") cast as xs:yearMonthDuration
xs:duration("P31D") ne xs:yearMonthDuration("P1M")
xs:duration("P365D") eq xs:duration("P365D")
xs:duration("P365D") ne xs:duration("P365D")
(xs:duration("P36D") eq xs:duration("P36D")) and fn:false()
(xs:duration("P36D") eq xs:duration("P36D")) and fn:true()
(xs:duration("P36D") eq xs:duration("P36D")) or fn:false()
(xs:duration("P36D") eq xs:duration("P36D")) or fn:true()
xs:duration("P36D") eq xs:duration("P39D")
(xs:duration("P36D") ne xs:duration("P36D")) and fn:false()
(xs:duration("P36D") ne xs:duration("P36D")) and fn:true()
(xs:duration("P36D") ne xs:duration("P36D")) or fn:false()
(xs:duration("P36D") ne xs:duration("P36D")) or fn:true()
xs:duration("P36D") ne xs:duration("P39D")
xs:duration("P3D") div xs:yearMonthDuration("P3Y3M")
xs:duration("P3DT08H34M12.143S") ge xs:yearMonthDuration("P1999Y10M")
xs:duration("P3DT08H34M12.143S") gt xs:yearMonthDuration("P1999Y10M")
xs:duration("P3DT08H34M12.143S") le xs:yearMonthDuration("P1999Y10M")
xs:duration("P3DT08H34M12.143S") lt xs:yearMonthDuration("P1999Y10M")
xs:duration("P3D") + xs:yearMonthDuration("P3Y3M")
xs:duration("P3D") - xs:yearMonthDuration("P3Y3M")
xs:duration("P3Y3M") div xs:dayTimeDuration("P3D")
xs:duration("P3Y3M") + xs:dayTimeDuration("P3D")
xs:duration("P3Y3M") - xs:dayTimeDuration("P3D")
xs:duration("PT0S") eq xs:dayTimeDuration("PT0S")
xs:duration("-PT0S") eq xs:duration("PT0S")
xs:duration("PT0S") eq xs:duration("PT0S")
xs:duration("PT0S") eq xs:yearMonthDuration("P0M")
xs:duration("PT10H") castable as xs:dayTimeDuration
xs:duration("PT10H") castable as xs:duration
xs:duration("PT10H") castable as xs:yearMonthDuration
xs:duration("PT10H") cast as xs:dayTimeDuration
xs:duration("PT10H") cast as xs:duration
xs:duration("PT10H") cast as xs:yearMonthDuration
xs:duration("PT24H") eq xs:duration("P1D")
xs:duration("PT24H") eq xs:duration("PT24H")
xs:duration("PT24H") ne xs:duration("PT24H")
xs:duration(xs:untypedAtomic( "P1Y2M3DT10H30M" )) eq xs:duration("P1Y2M3DT10H30M")
xs:ENTITY("")
xs:ENTITY("NCName") instance of xs:ENTITY
xs:ENTITY("ncname") instance of xs:IDREF
xs:ENTITY("ncname") instance of xs:NCName
xs:error( () )
xs:error( (), () )
xs:error("")
xs:error()
xs:error#0
xs:error(1)
xs:error(1.0)
xs:error(1) castable as xs:error
xs:error(1) castable as xs:integer
xs:error(1) cast as xs:error
xs:error(1) cast as xs:integer
xs:error(1e0)
xs:error(1) instance of xs:error
xs:error#2
xs:error(()) castable as xs:error
xs:error(()) castable as xs:error?
xs:error(()) cast as xs:error
xs:error(()) cast as xs:error?
xs:error(xs:untypedAtomic(""))
xs:float("")
xs:float()
+(xs:float("0"))
-(xs:float("0"))
-xs:float(0)
xs:float(-0.0)
xs:float("-0.0E0") castable as xs:boolean
xs:float("-0.0E0") castable as xs:decimal
xs:float("-0.0E0") castable as xs:double
xs:float("-0.0E0") castable as xs:integer
xs:float("-0.0E0") castable as xs:string
xs:float("-0.0E0") cast as xs:boolean
xs:float("-0.0E0") cast as xs:decimal
xs:float("-0.0E0") cast as xs:double
xs:float("-0.0E0") cast as xs:integer
xs:float("-0.0E0") cast as xs:string
xs:float(0) and xs:float(0)
xs:float(0) and xs:float(1)
xs:float("0") div xs:float("-3.4028235E38")
xs:float("0") eq xs:float("-3.4028235E38")
xs:float("0") ge xs:float("-3.4028235E38")
xs:float("0") gt xs:float("-3.4028235E38")
xs:float("0") lt xs:float("-3.4028235E38")
xs:float("-0") mod 3
xs:float("0") mod 3
xs:float("-0") mod xs:float("-0")
xs:float("-0") mod xs:float("4")
xs:float("0") mod xs:float("4")
xs:float("-0") mod xs:float("-INF")
xs:float("-0") mod xs:float("INF")
xs:float("0") mod xs:float("-INF")
xs:float("0") mod xs:float("INF")
xs:float("0") ne xs:float("-3.4028235E38")
xs:float("0") ne xs:float("-INF")
xs:float("0") ne xs:float("INF")
xs:float(0) ne xs:float("NaN")
xs:float(0) or xs:float(0)
xs:float(0) or xs:float(1)
(xs:float("0") || xs:float("-3.4028235E38"))
xs:float("0") * xs:float("-3.4028235E38")
xs:float("0") + xs:float("-3.4028235E38")
xs:float("0") - xs:float("-3.4028235E38")
xs:float("0") - xs:float("3.4028235E38")
xs:float("-1.0000000000") * xs:float("-3.4028235E38")
xs:float("-1.0000000000") * xs:float("3.4028235E38")
xs:float("-10000000") mod xs:float("-10000000")
xs:float("-10000000") mod xs:float("10000000")
xs:float("10000000") mod xs:float("-10000000")
xs:float("10000000") mod xs:float("10000000")
xs:float("1.01"), xs:float("NaN")
xs:float(1.0e0) idiv xs:float(0.0e0)
xs:float(-1.0e0) mod xs:float(-9223372036854775808)
(xs:float(1.1), 2.2, 3.3)
xs:float(-1.1) eq xs:float(-1.1)
xs:float(1.1) eq xs:float(1.1)
xs:float(1.1) ne xs:float(2.1)
xs:float(1.1) + xs:float(2.2) ne 3.3
xs:float(1.5) idiv xs:decimal(1)
xs:float("-1.75e-3") castable as xs:decimal
xs:float("-1.75e-3") castable as xs:duration
xs:float("-1.75e-3") castable as xs:float
xs:float("-1.75e-3") cast as xs:duration
xs:float("-1.75e-3") cast as xs:float
xs:float(-1) and xs:float(0)
xs:float(1) and xs:float(-1)
xs:float(1) castable as xs:float
xs:float(1) castable as xs:string
xs:float(1) castable as xs:untypedAtomic
xs:float("1e5") castable as xs:boolean
xs:float("1e5") castable as xs:decimal
xs:float("1e5") castable as xs:integer
xs:float("1e5") castable as xs:untypedAtomic
xs:float("1e5") cast as xs:boolean
xs:float("1e5") cast as xs:decimal
xs:float("1e5") cast as xs:integer
xs:float("1e5") cast as xs:untypedAtomic
xs:float(1) ge xs:float(1)
xs:float(1) gt xs:float(-1)
xs:float("1") idiv xs:float("0")
xs:float("1") idiv xs:float("NaN")
xs:float(-1) le xs:float(1)
xs:float(-1) lt xs:float(1)
xs:float(-1) or xs:float(0)
xs:float(1) or xs:float(-1)
xs:float(2.1E3) cast as xs:boolean
xs:float(2.1E3) cast as xs:double
xs:float(2.1E3) cast as xs:float
xs:float(2.1E3) cast as xs:string
xs:float(3.1) eq 3.1
+(xs:float("-3.4028235E38"))
+(xs:float("3.4028235E38"))
-(xs:float("-3.4028235E38"))
-(xs:float("3.4028235E38"))
xs:float("-3.4028235E38") div xs:float("-3.4028235E38")
xs:float("-3.4028235E38") div xs:float("3.4028235E38")
xs:float("3.4028235E38") div xs:float("-3.4028235E38")
xs:float("-3.4028235E38") eq xs:float("0")
xs:float("-3.4028235E38") eq xs:float("-3.4028235E38")
xs:float("-3.4028235E38") eq xs:float("3.4028235E38")
xs:float("3.4028235E38") eq xs:float("-3.4028235E38")
xs:float("-3.4028235E38") ge xs:float("0")
xs:float("-3.4028235E38") ge xs:float("-3.4028235E38")
xs:float("-3.4028235E38") ge xs:float("3.4028235E38")
xs:float("3.4028235E38") ge xs:float("-3.4028235E38")
xs:float("-3.4028235E38") gt xs:float("0")
xs:float("-3.4028235E38") gt xs:float("-3.4028235E38")
xs:float("-3.4028235E38") gt xs:float("3.4028235E38")
xs:float("3.4028235E38") gt xs:float("-3.4028235E38")
xs:float("-3.4028235E38") lt xs:float("0")
xs:float("-3.4028235E38") lt xs:float("-3.4028235E38")
xs:float("-3.4028235E38") lt xs:float("3.4028235E38")
xs:float("3.4028235E38") lt xs:float("-3.4028235E38")
xs:float("-3.4028235E38") mod xs:float("3.4028235E38")
xs:float("-3.4028235E38") ne xs:float("0")
xs:float("-3.4028235E38") ne xs:float("-3.4028235E38")
xs:float("-3.4028235E38") ne xs:float("3.4028235E38")
xs:float("3.4028235E38") ne xs:float("-3.4028235E38")
(xs:float("-3.4028235E38") || xs:float("0"))
xs:float("-3.4028235E38") * xs:float("0")
xs:float("-3.4028235E38") + xs:float("0")
xs:float("-3.4028235E38") - xs:float("0")
xs:float("3.4028235E38") * xs:float("-1.0000000000")
(xs:float("-3.4028235E38") || xs:float("-3.4028235E38"))
(xs:float("-3.4028235E38") || xs:float("3.4028235E38"))
(xs:float("3.4028235E38") || xs:float("-3.4028235E38"))
xs:float("-3.4028235E38") + xs:float("3.4028235E38")
xs:float("-3.4028235E38") - xs:float("-3.4028235E38")
xs:float("3.4028235E38") + xs:float("-3.4028235E38")
xs:float('-3.402823e38') castable as xs:decimal
xs:float('3.402823e38') castable as xs:decimal
xs:float('-3.402823e38') castable as xs:integer
xs:float('3.402823e38') castable as xs:integer
xs:float( "3.4e5" , "3.4e5" )
xs:float("3.4e5") castable as xs:boolean
xs:float("3.4e5") castable as xs:double
xs:float("3.4e5") castable as xs:float
xs:float("3.4e5") castable as xs:string
xs:float("3.4e5") castable as xs:untypedAtomic
xs:float("3.4e5") cast as xs:anyURI
xs:float("3.4e5") cast as xs:base64Binary
xs:float("3.4e5") cast as xs:boolean eq xs:boolean("true")
xs:float("3.4e5") cast as xs:date
xs:float("3.4e5") cast as xs:dateTime
xs:float("3.4e5") cast as xs:dayTimeDuration
xs:float("3.4e5") cast as xs:double ne xs:double("3.3e3")
xs:float("3.4e5") cast as xs:duration
xs:float("3.4e5") cast as xs:float eq xs:float("3.4e5")
xs:float("3.4e5") cast as xs:gDay
xs:float("3.4e5") cast as xs:gMonth
xs:float("3.4e5") cast as xs:gMonthDay
xs:float("3.4e5") cast as xs:gYear
xs:float("3.4e5") cast as xs:gYearMonth
xs:float("3.4e5") cast as xs:hexBinary
xs:float("3.4e5") cast as xs:string ne xs:string("an arbitrary string")
xs:float("3.4e5") cast as xs:time
xs:float("3.4e5") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:float("3.4e5") cast as xs:yearMonthDuration
xs:float(" 3.4e5 ") eq xs:float(" 3.4e5 ")
xs:float("-3.5") idiv xs:float("3")
xs:float(3e3) < <e>1.1</e>
xs:float(3) eq 3
xs:float("3") idiv xs:float("-INF") eq xs:float(0)
xs:float("3") idiv xs:float("INF") eq xs:float(0)
xs:float("3") lt xs:float("NaN")
xs:float("5.4321E-100") castable as xs:anyURI
xs:float("5.4321E-100") castable as xs:base64Binary
xs:float("5.4321E-100") castable as xs:date
xs:float("5.4321E-100") castable as xs:dateTime
xs:float("5.4321E-100") castable as xs:dayTimeDuration
xs:float("5.4321E-100") castable as xs:decimal
xs:float("5.4321E-100") castable as xs:float
xs:float("5.4321E-100") castable as xs:gDay
xs:float("5.4321E-100") castable as xs:gMonth
xs:float("5.4321E-100") castable as xs:gMonthDay
xs:float("5.4321E-100") castable as xs:gYear
xs:float("5.4321E-100") castable as xs:gYearMonth
xs:float("5.4321E-100") castable as xs:hexBinary
xs:float("5.4321E-100") castable as xs:time
xs:float("5.4321E-100") castable as xs:yearMonthDuration
xs:float("5.4321E-100") cast as xs:anyURI
xs:float("5.4321E-100") cast as xs:base64Binary
xs:float("5.4321E-100") cast as xs:date
xs:float("5.4321E-100") cast as xs:dateTime
xs:float("5.4321E-100") cast as xs:dayTimeDuration
xs:float("5.4321E-100") cast as xs:gDay
xs:float("5.4321E-100") cast as xs:gMonth
xs:float("5.4321E-100") cast as xs:gMonthDay
xs:float("5.4321E-100") cast as xs:gYear
xs:float("5.4321E-100") cast as xs:gYearMonth
xs:float("5.4321E-100") cast as xs:hexBinary
xs:float("5.4321E-100") cast as xs:time
xs:float("5.4321E-100") cast as xs:yearMonthDuration
xs:float(5) div xs:float(2) eq 2.5
xs:float(5) div xs:float(2) ne 2.6
xs:float(5) - xs:float(1) eq 4
(xs:float(6) div xs:double(2)) instance of xs:double
xs:float(6) div xs:float(2) eq 3
(xs:float(6) div xs:float(2)) instance of xs:float
(xs:float(6) idiv xs:decimal(2)) instance of xs:integer
(xs:float(6) idiv xs:double(2)) instance of xs:integer
(xs:float(6) idiv xs:float(2)) instance of xs:integer
(xs:float(6) idiv xs:integer(2)) instance of xs:integer
xs:float(6) instance of xs:float
(xs:float(6) mod xs:double(2)) instance of xs:double
(xs:float(6) mod xs:float(2)) instance of xs:float
(xs:float(6) * xs:double(2)) instance of xs:double
(xs:float(6) + xs:double(2)) instance of xs:double
(xs:float(6) - xs:double(2)) instance of xs:double
xs:float(6) * xs:float(2) eq 12
xs:float(6) + xs:float(2) eq 8
(xs:float(6) * xs:float(2)) instance of xs:float
(xs:float(6) + xs:float(2)) instance of xs:float
(xs:float(6) - xs:float(2)) instance of xs:float
(xs:float(9) idiv xs:untypedAtomic("5")) eq 1
(xs:float(9) idiv xs:untypedAtomic("five")) eq 1
xs:float(fn:translate("123","123","123"))
xs:float("inf")
xs:float("inF")
xs:float("+Inf")
xs:float("-Inf")
xs:float("Inf")
xs:float("+InF")
xs:float("-InF")
xs:float("InF")
xs:float(" INF ")
xs:float("+ INF")
xs:float("+INF")
xs:float("- INF")
xs:float('-INF') and xs:float(0)
xs:float('INF') and xs:float(0)
xs:float('-INF') and xs:float(1)
xs:float('INF') and xs:float(1)
xs:float('-INF') and xs:float('INF')
xs:float('-INF') and xs:float('NaN')
xs:float('INF') and xs:float('NaN')
xs:float("-INF") castable as xs:boolean
xs:float('-INF') castable as xs:decimal
xs:float('INF') castable as xs:decimal
xs:float("-INF") castable as xs:double
xs:float("INF") castable as xs:float
xs:float("INF") castable as xs:integer
xs:float("-INF") castable as xs:untypedAtomic
xs:float("-INF") cast as xs:boolean
xs:float("-INF") cast as xs:double
xs:float("INF") cast as xs:float
xs:float("INF") cast as xs:integer
xs:float('INF') cast as xs:integer
xs:float("-INF") cast as xs:untypedAtomic
xs:float("-INF") eq xs:float("-INF")
xs:float("INF") eq xs:float("INF")
xs:float("INF") gt 0
xs:float("INF") idiv xs:float("0")
xs:float("-INF") idiv xs:float("1")
xs:float("-INF") idiv xs:float(3)
xs:float("INF") idiv xs:float(3)
xs:float("-INF") lt 0
xs:float("-INF") mod 3
xs:float("INF") mod 3
xs:float("-INF") mod xs:float("-INF")
xs:float("INF") mod xs:float("INF")
xs:float("-INF") ne xs:float("0")
xs:float("INF") ne xs:float("0")
xs:float("-INF") ne xs:float("INF")
xs:float("INF") ne xs:float("-INF")
xs:float('-INF') or xs:float(0)
xs:float('INF') or xs:float(0)
xs:float('-INF') or xs:float(1)
xs:float('INF') or xs:float(1)
xs:float('-INF') or xs:float('INF')
xs:float('-INF') or xs:float('NaN')
xs:float('INF') or xs:float('NaN')
xs:float("INF") , xs:double("NaN")
xs:float("nan")
xs:float("naN")
xs:float(" NaN ")
xs:float('NaN') and xs:float(0)
xs:float('NaN') and xs:float(1)
xs:float('NaN') and xs:float('NaN')
xs:float("NaN") castable as xs:boolean
xs:float('NaN') castable as xs:decimal
xs:float("NaN") castable as xs:string
xs:float("NaN") cast as xs:boolean
xs:float("NaN") cast as xs:string
xs:float("NaN") idiv 1
xs:float("NaN") instance of xs:float
xs:float("NaN") mod 3
xs:float("NaN") mod xs:float("NaN")
xs:float("NaN") ne xs:float(0)
xs:float("NaN") ne xs:float("NaN")
xs:float('NaN') or xs:float(0)
xs:float('NaN') or xs:float(1)
xs:float('NaN') or xs:float('NaN')
xs:float(xs:byte(3))
xs:float(xs:double('-INF')),xs:float(xs:double('INF'))
xs:float(xs:int(3))
xs:float(xs:long(3))
xs:float(xs:negativeInteger(-3))
xs:float(xs:nonNegativeInteger(3))
xs:float(xs:nonPositiveInteger(0))
xs:float(xs:short(3))
xs:float(xs:unsignedByte(3))
xs:float(xs:unsignedInt(3))
xs:float(xs:unsignedLong(3))
xs:float(xs:unsignedShort(3))
xs:float(xs:untypedAtomic( "3.4e5" )) eq xs:float("3.4e5")
xs:func-does-not-exist(1, 2, 3)
xs:gDay("")
xs:gDay()
xs:gDay("---00")
xs:gDay("---001")
xs:gDay("---01-")
xs:gDay("--01")
xs:gDay("-01")
xs:gDay("---01-00:00") eq xs:gDay("---01+00:00")
xs:gDay("---01+00:00") eq xs:gDay("---01Z")
xs:gDay("---01-00:00") eq xs:gDay("---01Z")
xs:gDay("---01E")
xs:gDay("---01") ne xs:gDay("---10")
xs:gDay("---01Z") eq xs:gDay("---01Z")
xs:gDay("---01Z") eq xs:gDay("---14Z")
xs:gDay("---01Z") eq xs:gDay("---31Z")
xs:gDay("---01Z") ne xs:gDay("---01Z")
xs:gDay("---01Z") ne xs:gDay("---14Z")
xs:gDay("---01Z") ne xs:gDay("---31Z")
(xs:gDay("---02Z") eq xs:gDay("---02Z")) or (xs:gDay("---06Z") eq xs:gDay("---06Z"))
xs:gDay( "---03" , "---03" )
xs:gDay("---03-05:00") castable as xs:gDay
xs:gDay("---03-05:00") cast as xs:gDay
xs:gDay("---03") castable as xs:gDay
xs:gDay("---03") castable as xs:string
xs:gDay("---03") castable as xs:untypedAtomic
xs:gDay("---03") cast as xs:anyURI
xs:gDay("---03") cast as xs:base64Binary
xs:gDay("---03") cast as xs:boolean
xs:gDay("---03") cast as xs:date
xs:gDay("---03") cast as xs:dateTime
xs:gDay("---03") cast as xs:dayTimeDuration
xs:gDay("---03") cast as xs:decimal
xs:gDay("---03") cast as xs:double
xs:gDay("---03") cast as xs:duration
xs:gDay("---03") cast as xs:float
xs:gDay("---03") cast as xs:gDay eq xs:gDay("---03")
xs:gDay("---03") cast as xs:gMonth
xs:gDay("---03") cast as xs:gMonthDay
xs:gDay("---03") cast as xs:gYear
xs:gDay("---03") cast as xs:gYearMonth
xs:gDay("---03") cast as xs:hexBinary
xs:gDay("---03") cast as xs:integer
xs:gDay("---03") cast as xs:string ne xs:string("an arbitrary string")
xs:gDay("---03") cast as xs:time
xs:gDay("---03") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:gDay("---03") cast as xs:yearMonthDuration
xs:gDay(" ---03 ") eq xs:gDay(" ---03 ")
(xs:gDay("---03Z") eq xs:gDay("---01Z")) or (fn:true())
(xs:gDay("---04Z") eq xs:gDay("---02Z")) and (xs:gDay("---01Z") eq xs:gDay("---12Z"))
(xs:gDay("---05Z") eq xs:gDay("---05Z")) or (fn:false())
(xs:gDay("---06Z") ne xs:gDay("---06Z")) or (xs:gDay("---08Z") ne xs:gDay("---09Z"))
xs:gDay("+---08")
xs:gDay("+--08")
xs:gDay("---08-10")
xs:gDay("---08+10:60")
xs:gDay("---08-10:60")
xs:gDay("---08+15:00")
xs:gDay("---08-15:00")
xs:gDay("---08 Z")
(xs:gDay("---08Z") ne xs:gDay("---07Z")) or (fn:true())
(xs:gDay("---09Z") ne xs:gDay("---09Z")) or (fn:false())
xs:gDay("10")
xs:gDay('---12-00:30')
(xs:gDay("---12-05:00") eq xs:gDay("---12Z"))
(xs:gDay("---12Z") ne xs:gDay("---03Z")) and (xs:gDay("---05Z") ne xs:gDay("---08Z"))
xs:gDay("---14Z") eq xs:gDay("---01Z")
xs:gDay("---14Z") ne xs:gDay("---01Z")
xs:gDay("---30-12:00") eq xs:gDay("---31+12:00")
xs:gDay("---30-12:00") ne xs:gDay("---31+12:00")
xs:gDay("---31+12:00") eq xs:gDay("---30-12:00")
xs:gDay("---31+12:00") ne xs:gDay("---30-12:00")
xs:gDay("---31") castable as xs:anyURI
xs:gDay("---31") castable as xs:base64Binary
xs:gDay("---31") castable as xs:boolean
xs:gDay("---31") castable as xs:date
xs:gDay("---31") castable as xs:dateTime
xs:gDay("---31") castable as xs:dayTimeDuration
xs:gDay("---31") castable as xs:decimal
xs:gDay("---31") castable as xs:double
xs:gDay("---31") castable as xs:duration
xs:gDay("---31") castable as xs:float
xs:gDay("---31") castable as xs:gDay
xs:gDay("---31") castable as xs:gMonth
xs:gDay("---31") castable as xs:gMonthDay
xs:gDay("---31") castable as xs:gYear
xs:gDay("---31") castable as xs:gYearMonth
xs:gDay("---31") castable as xs:hexBinary
xs:gDay("---31") castable as xs:integer
xs:gDay("---31") castable as xs:string
xs:gDay("---31") castable as xs:time
xs:gDay("---31") castable as xs:untypedAtomic
xs:gDay("---31") castable as xs:yearMonthDuration
xs:gDay("---31") cast as xs:anyURI
xs:gDay("---31") cast as xs:base64Binary
xs:gDay("---31") cast as xs:boolean
xs:gDay("---31") cast as xs:date
xs:gDay("---31") cast as xs:dateTime
xs:gDay("---31") cast as xs:dayTimeDuration
xs:gDay("---31") cast as xs:decimal
xs:gDay("---31") cast as xs:double
xs:gDay("---31") cast as xs:duration
xs:gDay("---31") cast as xs:float
xs:gDay("---31") cast as xs:gDay
xs:gDay("---31") cast as xs:gMonth
xs:gDay("---31") cast as xs:gMonthDay
xs:gDay("---31") cast as xs:gYear
xs:gDay("---31") cast as xs:gYearMonth
xs:gDay("---31") cast as xs:hexBinary
xs:gDay("---31") cast as xs:integer
xs:gDay("---31") cast as xs:string
xs:gDay("---31") cast as xs:time
xs:gDay("---31") cast as xs:untypedAtomic
xs:gDay("---31") cast as xs:yearMonthDuration
xs:gDay(" ---31 ") eq xs:gDay("---31")
xs:gDay("---31Z") castable as xs:gDay
xs:gDay("---31Z") cast as xs:gDay
xs:gDay("---31Z") eq xs:gDay("---01Z")
xs:gDay("---31Z") ne xs:gDay("---01Z")
xs:gDay("---32")
xs:gDay("---321")
xs:gDay("E---01")
xs:gDay(xs:date("2002-11-23-00:00")) eq xs:gDay("---23Z")
xs:gDay(xs:date("2002-11-23-13:37")) eq xs:gDay("---23-13:37")
xs:gDay(xs:dateTime("2002-11-23T22:12:23.867-00:00")) eq xs:gDay("---23Z")
xs:gDay(xs:dateTime("2002-11-23T22:12:23.867-13:37")) eq xs:gDay("---23-13:37")
xs:gDay(xs:untypedAtomic( "---03" )) eq xs:gDay("---03")
xs:gMonth("")
xs:gMonth()
xs:gMonth("--00")
xs:gMonth("+--01")
xs:gMonth("---01")
xs:gMonth("-01")
xs:gMonth("--01-00:00") eq xs:gMonth("--01+00:00")
xs:gMonth("--01+00:00") eq xs:gMonth("--01Z")
xs:gMonth("--01-00:00") eq xs:gMonth("--01Z")
xs:gMonth("--01Z") eq xs:gMonth("--01Z")
xs:gMonth("--01Z") eq xs:gMonth("--07Z")
xs:gMonth("--01Z") eq xs:gMonth("--12Z")
xs:gMonth("--01Z") ne xs:gMonth("--01Z")
xs:gMonth("--01Z") ne xs:gMonth("--07Z")
xs:gMonth("--01Z") ne xs:gMonth("--12Z")
xs:gMonth("--02--")
(xs:gMonth("--02Z") eq xs:gMonth("--02Z")) or (xs:gMonth("--06Z") eq xs:gMonth("--06Z"))
(xs:gMonth("--03Z") eq xs:gMonth("--01Z")) or (fn:true())
(xs:gMonth("--04Z") eq xs:gMonth("--02Z")) and (xs:gMonth("--01Z") eq xs:gMonth("--12Z"))
xs:gMonth("--05") castable as xs:anyURI
xs:gMonth("--05") castable as xs:base64Binary
xs:gMonth("--05") castable as xs:boolean
xs:gMonth("--05") castable as xs:date
xs:gMonth("--05") castable as xs:dateTime
xs:gMonth("--05") castable as xs:dayTimeDuration
xs:gMonth("--05") castable as xs:decimal
xs:gMonth("--05") castable as xs:double
xs:gMonth("--05") castable as xs:duration
xs:gMonth("--05") castable as xs:float
xs:gMonth("--05") castable as xs:gDay
xs:gMonth("--05") castable as xs:gMonth
xs:gMonth("--05") castable as xs:gMonthDay
xs:gMonth("--05") castable as xs:gYear
xs:gMonth("--05") castable as xs:gYearMonth
xs:gMonth("--05") castable as xs:hexBinary
xs:gMonth("--05") castable as xs:integer
xs:gMonth("--05") castable as xs:string
xs:gMonth("--05") castable as xs:time
xs:gMonth("--05") castable as xs:untypedAtomic
xs:gMonth("--05") castable as xs:yearMonthDuration
xs:gMonth("--05") cast as xs:anyURI
xs:gMonth("--05") cast as xs:base64Binary
xs:gMonth("--05") cast as xs:boolean
xs:gMonth("--05") cast as xs:date
xs:gMonth("--05") cast as xs:dateTime
xs:gMonth("--05") cast as xs:dayTimeDuration
xs:gMonth("--05") cast as xs:decimal
xs:gMonth("--05") cast as xs:double
xs:gMonth("--05") cast as xs:duration
xs:gMonth("--05") cast as xs:float
xs:gMonth("--05") cast as xs:gDay
xs:gMonth("--05") cast as xs:gMonth
xs:gMonth("--05") cast as xs:gMonthDay
xs:gMonth("--05") cast as xs:gYear
xs:gMonth("--05") cast as xs:gYearMonth
xs:gMonth("--05") cast as xs:hexBinary
xs:gMonth("--05") cast as xs:integer
xs:gMonth("--05") cast as xs:string
xs:gMonth("--05") cast as xs:time
xs:gMonth("--05") cast as xs:untypedAtomic
xs:gMonth("--05") cast as xs:yearMonthDuration
xs:gMonth("--05Z") castable as xs:gMonth
xs:gMonth("--05Z") cast as xs:gMonth
(xs:gMonth("--05Z") eq xs:gMonth("--05Z")) or (fn:false())
(xs:gMonth("--06Z") ne xs:gMonth("--06Z")) or (xs:gMonth("--08Z") ne xs:gMonth("--09Z"))
xs:gMonth('--07-00:30')
xs:gMonth("--07Z") eq xs:gMonth("--01Z")
xs:gMonth("--07Z") ne xs:gMonth("--01Z")
xs:gMonth("--08-10")
xs:gMonth("--08+10:60")
xs:gMonth("--08-10:60")
xs:gMonth("--08+15:00")
xs:gMonth("--08-15:00")
(xs:gMonth("--08Z") ne xs:gMonth("--07Z")) or (fn:true())
(xs:gMonth("--09Z") ne xs:gMonth("--09Z")) or (fn:false())
xs:gMonth("--11-")
xs:gMonth( "--11" , "--11" )
xs:gMonth("--11") castable as xs:gMonth
xs:gMonth("--11") castable as xs:string
xs:gMonth("--11") castable as xs:untypedAtomic
xs:gMonth("--11") cast as xs:anyURI
xs:gMonth("--11") cast as xs:base64Binary
xs:gMonth("--11") cast as xs:boolean
xs:gMonth("--11") cast as xs:date
xs:gMonth("--11") cast as xs:dateTime
xs:gMonth("--11") cast as xs:dayTimeDuration
xs:gMonth("--11") cast as xs:decimal
xs:gMonth("--11") cast as xs:double
xs:gMonth("--11") cast as xs:duration
xs:gMonth("--11") cast as xs:float
xs:gMonth("--11") cast as xs:gDay
xs:gMonth("--11") cast as xs:gMonthDay
xs:gMonth("--11") cast as xs:gMonth eq xs:gMonth("--11")
xs:gMonth("--11") cast as xs:gYear
xs:gMonth("--11") cast as xs:gYearMonth
xs:gMonth("--11") cast as xs:hexBinary
xs:gMonth("--11") cast as xs:integer
xs:gMonth("--11") cast as xs:string ne xs:string("an arbitrary string")
xs:gMonth("--11") cast as xs:time
xs:gMonth("--11") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:gMonth("--11") cast as xs:yearMonthDuration
xs:gMonth(" --11 ") eq xs:gMonth(" --11 ")
xs:gMonth("--11 ") eq xs:gMonth("--11")
xs:gMonth("--12-05:00") castable as xs:gMonth
xs:gMonth("--12-05:00") cast as xs:gMonth
(xs:gMonth("--12-05:00") eq xs:gMonth("--12Z"))
xs:gMonth("--12") ne xs:gMonth("--10")
xs:gMonth("--12Z") eq xs:gMonth("--01Z")
xs:gMonth("--12Z") ne xs:gMonth("--01Z")
(xs:gMonth("--12Z") ne xs:gMonth("--03Z")) and (xs:gMonth("--05Z") ne xs:gMonth("--08Z"))
xs:gMonth("--13")
xs:gMonth("--431")
xs:gMonthDay("")
xs:gMonthDay()
xs:gMonthDay("--00-01")
xs:gMonthDay("--01-00")
xs:gMonthDay("--01-01+10:60")
xs:gMonthDay("--01-01-10:60")
xs:gMonthDay("--01-01+15:00")
xs:gMonthDay("--01-01-15:00")
xs:gMonthDay("--01-01Z") eq xs:gMonthDay("--01-01Z")
xs:gMonthDay("--01-01Z") eq xs:gMonthDay("--04-10Z")
xs:gMonthDay("--01-01Z") eq xs:gMonthDay("--12-31Z")
xs:gMonthDay("--01-01Z") ne xs:gMonthDay("--01-01Z")
xs:gMonthDay("--01-01Z") ne xs:gMonthDay("--04-10Z")
xs:gMonthDay("--01-01Z") ne xs:gMonthDay("--12-31Z")
xs:gMonthDay("+--01-12")
xs:gMonthDay("--01--12")
xs:gMonthDay("-01-12")
xs:gMonthDay("01-12-")
xs:gMonthDay("--01-30-12:00") eq xs:gMonthDay("--01-31+12:00")
xs:gMonthDay("--01-30-12:00") ne xs:gMonthDay("--01-31+12:00")
xs:gMonthDay("--01-31+12:00") eq xs:gMonthDay("--01-30-12:00")
xs:gMonthDay("--01-31+12:00") ne xs:gMonthDay("--01-30-12:00")
(xs:gMonthDay("--02-01Z") eq xs:gMonthDay("--02-10Z")) or (xs:gMonthDay("--06-02Z") eq xs:gMonthDay("--06-03Z"))
xs:gMonthDay("--02-29+00:00") eq xs:gMonthDay("--02-29+00:00")
xs:gMonthDay("--03-01-00:00") eq xs:gMonthDay("--03-01+00:00")
xs:gMonthDay("--03-01+00:00") eq xs:gMonthDay("--03-01Z")
xs:gMonthDay("--03-01-00:00") eq xs:gMonthDay("--03-01Z")
xs:gMonthDay("--03-01Z") eq xs:gMonthDay("--03-01Z")
(xs:gMonthDay("--03-04Z") eq xs:gMonthDay("--01-07Z")) or (fn:true())
xs:gMonthDay("--04-01 ") eq xs:gMonthDay("--04-01")
(xs:gMonthDay("--04-02Z") eq xs:gMonthDay("--02-03Z")) and (xs:gMonthDay("--01-07Z") eq xs:gMonthDay("--12-10Z"))
xs:gMonthDay("--04-10Z") eq xs:gMonthDay("--01-01Z")
xs:gMonthDay("--04-10Z") ne xs:gMonthDay("--01-01Z")
xs:gMonthDay("--04-12") ne xs:gMonthDay("--04-11")
(xs:gMonthDay("--05-05Z") eq xs:gMonthDay("--05-05Z")) or (fn:false())
xs:gMonthDay("--05-31") castable as xs:anyURI
xs:gMonthDay("--05-31") castable as xs:base64Binary
xs:gMonthDay("--05-31") castable as xs:boolean
xs:gMonthDay("--05-31") castable as xs:date
xs:gMonthDay("--05-31") castable as xs:dateTime
xs:gMonthDay("--05-31") castable as xs:dayTimeDuration
xs:gMonthDay("--05-31") castable as xs:decimal
xs:gMonthDay("--05-31") castable as xs:double
xs:gMonthDay("--05-31") castable as xs:duration
xs:gMonthDay("--05-31") castable as xs:float
xs:gMonthDay("--05-31") castable as xs:gDay
xs:gMonthDay("--05-31") castable as xs:gMonth
xs:gMonthDay("--05-31") castable as xs:gMonthDay
xs:gMonthDay("--05-31") castable as xs:gYear
xs:gMonthDay("--05-31") castable as xs:gYearMonth
xs:gMonthDay("--05-31") castable as xs:hexBinary
xs:gMonthDay("--05-31") castable as xs:integer
xs:gMonthDay("--05-31") castable as xs:string
xs:gMonthDay("--05-31") castable as xs:time
xs:gMonthDay("--05-31") castable as xs:untypedAtomic
xs:gMonthDay("--05-31") castable as xs:yearMonthDuration
xs:gMonthDay("--05-31") cast as xs:anyURI
xs:gMonthDay("--05-31") cast as xs:base64Binary
xs:gMonthDay("--05-31") cast as xs:boolean
xs:gMonthDay("--05-31") cast as xs:date
xs:gMonthDay("--05-31") cast as xs:dateTime
xs:gMonthDay("--05-31") cast as xs:dayTimeDuration
xs:gMonthDay("--05-31") cast as xs:decimal
xs:gMonthDay("--05-31") cast as xs:double
xs:gMonthDay("--05-31") cast as xs:duration
xs:gMonthDay("--05-31") cast as xs:float
xs:gMonthDay("--05-31") cast as xs:gDay
xs:gMonthDay("--05-31") cast as xs:gMonth
xs:gMonthDay("--05-31") cast as xs:gMonthDay
xs:gMonthDay("--05-31") cast as xs:gYear
xs:gMonthDay("--05-31") cast as xs:gYearMonth
xs:gMonthDay("--05-31") cast as xs:hexBinary
xs:gMonthDay("--05-31") cast as xs:integer
xs:gMonthDay("--05-31") cast as xs:string
xs:gMonthDay("--05-31") cast as xs:time
xs:gMonthDay("--05-31") cast as xs:untypedAtomic
xs:gMonthDay("--05-31") cast as xs:yearMonthDuration
xs:gMonthDay("--05-31Z") castable as xs:gMonthDay
xs:gMonthDay("--05-31Z") cast as xs:gMonthDay
(xs:gMonthDay("--06-02Z") ne xs:gMonthDay("--06-09Z")) or (xs:gMonthDay("--08-06Z") ne xs:gMonthDay("--09-01Z"))
xs:gMonthDay('--07-12-00:30')
(xs:gMonthDay("--08-04Z") ne xs:gMonthDay("--07-12Z")) or (fn:true())
(xs:gMonthDay("--09-09Z") ne xs:gMonthDay("--09-10Z")) or (fn:false())
xs:gMonthDay("--11-08-10")
xs:gMonthDay("--111-01")
xs:gMonthDay( "--11-13" , "--11-13" )
xs:gMonthDay("--11-13") castable as xs:gMonthDay
xs:gMonthDay("--11-13") castable as xs:string
xs:gMonthDay("--11-13") castable as xs:untypedAtomic
xs:gMonthDay("--11-13") cast as xs:anyURI
xs:gMonthDay("--11-13") cast as xs:base64Binary
xs:gMonthDay("--11-13") cast as xs:boolean
xs:gMonthDay("--11-13") cast as xs:date
xs:gMonthDay("--11-13") cast as xs:dateTime
xs:gMonthDay("--11-13") cast as xs:dayTimeDuration
xs:gMonthDay("--11-13") cast as xs:decimal
xs:gMonthDay("--11-13") cast as xs:double
xs:gMonthDay("--11-13") cast as xs:duration
xs:gMonthDay("--11-13") cast as xs:float
xs:gMonthDay("--11-13") cast as xs:gDay
xs:gMonthDay("--11-13") cast as xs:gMonth
xs:gMonthDay("--11-13") cast as xs:gMonthDay eq xs:gMonthDay("--11-13")
xs:gMonthDay("--11-13") cast as xs:gYear
xs:gMonthDay("--11-13") cast as xs:gYearMonth
xs:gMonthDay("--11-13") cast as xs:hexBinary
xs:gMonthDay("--11-13") cast as xs:integer
xs:gMonthDay("--11-13") cast as xs:string ne xs:string("an arbitrary string")
xs:gMonthDay("--11-13") cast as xs:time
xs:gMonthDay("--11-13") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:gMonthDay("--11-13") cast as xs:yearMonthDuration
xs:gMonthDay(" --11-13 ") eq xs:gMonthDay(" --11-13 ")
xs:gMonthDay("--12-03-05:00") castable as xs:gMonthDay
xs:gMonthDay("--12-03-05:00") cast as xs:gMonthDay
(xs:gMonthDay("--12-10Z") ne xs:gMonthDay("--03-11Z")) and (xs:gMonthDay("--05-12Z") ne xs:gMonthDay("--08-08Z"))
(xs:gMonthDay("--12-25Z") eq xs:gMonthDay("--12-26Z"))
xs:gMonthDay("--12-31Z") eq xs:gMonthDay("--01-01Z")
xs:gMonthDay("--12-31Z") ne xs:gMonthDay("--01-01Z")
xs:gMonthDay("--13-01")
xs:gMonthDay("--1967-01")
xs:gMonthDay(xs:date("2002-11-23-00:00")) eq xs:gMonthDay("--11-23Z")
xs:gMonthDay(xs:date("2002-11-23-13:37")) eq xs:gMonthDay("--11-23-13:37")
xs:gMonthDay(xs:dateTime("2002-11-23T22:12:23.867-00:00")) eq xs:gMonthDay("--11-23Z")
xs:gMonthDay(xs:dateTime("2002-11-23T22:12:23.867-13:37")) eq xs:gMonthDay("--11-23-13:37")
xs:gMonthDay(xs:untypedAtomic( "--11-13" )) eq xs:gMonthDay("--11-13")
xs:gMonth(xs:date("2002-11-23-00:00")) eq xs:gMonth("--11Z")
xs:gMonth(xs:date("2002-11-23-13:37")) eq xs:gMonth("--11-13:37")
xs:gMonth(xs:dateTime("2002-11-23T22:12:23.867-00:00")) eq xs:gMonth("--11Z")
xs:gMonth(xs:dateTime("2002-11-23T22:12:23.867-13:37")) eq xs:gMonth("--11-13:37")
xs:gMonth(xs:untypedAtomic( "--11" )) eq xs:gMonth("--11")
xs:gYear("")
xs:gYear()
xs:gYear("+0000")
xs:gYear("-0012-05:00") castable as xs:gYear
xs:gYear("-0012-05:00") cast as xs:gYear
xs:gYear("0040")
xs:gYear("02004")
xs:gYear("1")
xs:gYear("1 111")
xs:gYear("1111-")
xs:gYear("1111a")
xs:gYear("1111 Z")
xs:gYear("12")
xs:gYear("1956-00:00") eq xs:gYear("1956+00:00")
xs:gYear("1956+00:00") eq xs:gYear("1956Z")
xs:gYear("1956-00:00") eq xs:gYear("1956Z")
xs:gYear("1956-10")
xs:gYear("1956+10:60")
xs:gYear("1956-10:60")
xs:gYear("1956+15:00")
xs:gYear("1956-15:00")
xs:gYear(" 1956 ") eq xs:gYear("1956")
xs:gYear("1956") ne xs:gYear("1958")
xs:gYear("1956Z") eq xs:gYear("1956Z")
xs:gYear("1970Z") eq xs:gYear("1970Z")
xs:gYear("1970Z") eq xs:gYear("2012Z")
xs:gYear("1970Z") eq xs:gYear("2030Z")
xs:gYear("1970Z") ne xs:gYear("1970Z")
xs:gYear("1970Z") ne xs:gYear("2012Z")
xs:gYear("1970Z") ne xs:gYear("2030Z")
(xs:gYear("1976-05:00") eq xs:gYear("1976-05:00"))
(xs:gYear("1976Z") ne xs:gYear("1976Z")) or (xs:gYear("1980Z") ne xs:gYear("1980Z"))
(xs:gYear("1980Z") eq xs:gYear("1980Z")) or (fn:false())
(xs:gYear("1980Z") eq xs:gYear("1980Z")) or (fn:true())
(xs:gYear("1980Z") ne xs:gYear("1980Z")) or (fn:false())
xs:gYear("+1999")
xs:gYear( "1999" , "1999" )
xs:gYear("1999") castable as xs:anyURI
xs:gYear("1999") castable as xs:base64Binary
xs:gYear("1999") castable as xs:boolean
xs:gYear("1999") castable as xs:date
xs:gYear("1999") castable as xs:dateTime
xs:gYear("1999") castable as xs:decimal
xs:gYear("1999") castable as xs:double
xs:gYear("1999") castable as xs:duration
xs:gYear("1999") castable as xs:float
xs:gYear("1999") castable as xs:gDay
xs:gYear("1999") castable as xs:gMonth
xs:gYear("1999") castable as xs:gMonthDay
xs:gYear("1999") castable as xs:gYear
xs:gYear("1999") castable as xs:gYearMonth
xs:gYear("1999") castable as xs:hexBinary
xs:gYear("1999") castable as xs:integer
xs:gYear("1999") castable as xs:string
xs:gYear("1999") castable as xs:time
xs:gYear("1999") castable as xs:untypedAtomic
xs:gYear("1999") castable as xs:yearMonthDuration
xs:gYear("1999") cast as xs:anyURI
xs:gYear("1999") cast as xs:base64Binary
xs:gYear("1999") cast as xs:boolean
xs:gYear("1999") cast as xs:date
xs:gYear("1999") cast as xs:dateTime
xs:gYear("1999") cast as xs:dayTimeDuration
xs:gYear("1999") cast as xs:decimal
xs:gYear("1999") cast as xs:double
xs:gYear("1999") cast as xs:duration
xs:gYear("1999") cast as xs:float
xs:gYear("1999") cast as xs:gDay
xs:gYear("1999") cast as xs:gMonth
xs:gYear("1999") cast as xs:gMonthDay
xs:gYear("1999") cast as xs:gYear
xs:gYear("1999") cast as xs:gYear eq xs:gYear("1999")
xs:gYear("1999") cast as xs:gYearMonth
xs:gYear("1999") cast as xs:hexBinary
xs:gYear("1999") cast as xs:integer
xs:gYear("1999") cast as xs:string
xs:gYear("1999") cast as xs:string ne xs:string("an arbitrary string")
xs:gYear("1999") cast as xs:time
xs:gYear("1999") cast as xs:untypedAtomic
xs:gYear("1999") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:gYear("1999") cast as xs:yearMonthDuration
xs:gYear(" 1999 ") eq xs:gYear(" 1999 ")
xs:gYear("1999Z") castable as xs:gYear
xs:gYear("1999Z") cast as xs:gYear
(xs:gYear("2000Z") eq xs:gYear("2000Z")) and (xs:gYear("2001Z") eq xs:gYear("2001Z"))
(xs:gYear("2000Z") eq xs:gYear("2000Z")) or (xs:gYear("1976Z") eq xs:gYear("1976Z"))
(xs:gYear("2000Z") ne xs:gYear("2000Z")) and (xs:gYear("1975Z") ne xs:gYear("1975Z"))
(xs:gYear("2000Z") ne xs:gYear("2000Z")) or (fn:true())
(xs:gYear("2005-12:00") eq xs:gYear("2005+12:00"))
xs:gYear("2012Z") eq xs:gYear("1970Z")
xs:gYear("2012Z") ne xs:gYear("1970Z")
xs:gYear('2017-00:30')
xs:gYear("2030Z") eq xs:gYear("1970Z")
xs:gYear("2030Z") ne xs:gYear("1970Z")
xs:gYear("867")
xs:gYear("a1111")
xs:gYearMonth("")
xs:gYearMonth()
xs:gYearMonth("-0012-12-05:00") castable as xs:gYearMonth
xs:gYearMonth("-0012-12-05:00") cast as xs:gYearMonth
xs:gYearMonth("0040-01")
xs:gYearMonth("02004-08")
xs:gYearMonth("1970-01Z") eq xs:gYearMonth("1970-01Z")
xs:gYearMonth("1970-01Z") eq xs:gYearMonth("1984-12Z")
xs:gYearMonth("1970-01Z") eq xs:gYearMonth("2030-12Z")
xs:gYearMonth("1970-01Z") ne xs:gYearMonth("1970-01Z")
xs:gYearMonth("1970-01Z") ne xs:gYearMonth("1984-12Z")
xs:gYearMonth("1970-01Z") ne xs:gYearMonth("2030-12Z")
(xs:gYearMonth("1976-01Z") ne xs:gYearMonth("1976-02Z")) or (xs:gYearMonth("1980-03Z") ne xs:gYearMonth("1980-04Z"))
(xs:gYearMonth("1976-02-05:00") eq xs:gYearMonth("1976-03Z"))
(xs:gYearMonth("1976-03-05:00") eq xs:gYearMonth("1976-03Z"))
(xs:gYearMonth("1980-03Z") ne xs:gYearMonth("1980-03Z")) or (fn:false())
(xs:gYearMonth("1980-05Z") eq xs:gYearMonth("1980-05Z")) or (fn:true())
(xs:gYearMonth("1980-09Z") eq xs:gYearMonth("1980-09Z")) or (fn:false())
xs:gYearMonth("1984-12Z") eq xs:gYearMonth("1970-01Z")
xs:gYearMonth("1984-12Z") ne xs:gYearMonth("1970-01Z")
xs:gYearMonth("1999-00")
xs:gYearMonth("1999-01-00:00") eq xs:gYearMonth("1999-01+00:00")
xs:gYearMonth("1999-01+00:00") eq xs:gYearMonth("1999-01Z")
xs:gYearMonth("1999-01-00:00") eq xs:gYearMonth("1999-01Z")
xs:gYearMonth("1999-01+10:60")
xs:gYearMonth("1999-01-10:60")
xs:gYearMonth("1999-01+15:00")
xs:gYearMonth("1999-01-15:00")
xs:gYearMonth("1999-01Z") eq xs:gYearMonth("1999-01Z")
xs:gYearMonth("1999-05") castable as xs:double
xs:gYearMonth("1999-05") castable as xs:float
xs:gYearMonth("1999-05") castable as xs:gYearMonth
xs:gYearMonth("1999-05") castable as xs:string
xs:gYearMonth("1999-05") castable as xs:untypedAtomic
xs:gYearMonth("1999-05") cast as xs:double
xs:gYearMonth("1999-05") cast as xs:float
xs:gYearMonth("1999-05") cast as xs:gYearMonth
xs:gYearMonth("1999-05") cast as xs:string
xs:gYearMonth("1999-05") cast as xs:untypedAtomic
xs:gYearMonth("1999-05Z") castable as xs:anyURI
xs:gYearMonth("1999-05Z") castable as xs:base64Binary
xs:gYearMonth("1999-05Z") castable as xs:boolean
xs:gYearMonth("1999-05Z") castable as xs:date
xs:gYearMonth("1999-05Z") castable as xs:dateTime
xs:gYearMonth("1999-05Z") castable as xs:dayTimeDuration
xs:gYearMonth("1999-05Z") castable as xs:decimal
xs:gYearMonth("1999-05Z") castable as xs:double
xs:gYearMonth("1999-05Z") castable as xs:duration
xs:gYearMonth("1999-05Z") castable as xs:gDay
xs:gYearMonth("1999-05Z") castable as xs:gMonth
xs:gYearMonth("1999-05Z") castable as xs:gMonthDay
xs:gYearMonth("1999-05Z") castable as xs:gYear
xs:gYearMonth("1999-05Z") castable as xs:gYearMonth
xs:gYearMonth("1999-05Z") castable as xs:hexBinary
xs:gYearMonth("1999-05Z") castable as xs:integer
xs:gYearMonth("1999-05Z") castable as xs:time
xs:gYearMonth("1999-05Z") castable as xs:yearMonthDuration
xs:gYearMonth("1999-05Z") cast as xs:anyURI
xs:gYearMonth("1999-05Z") cast as xs:base64Binary
xs:gYearMonth("1999-05Z") cast as xs:boolean
xs:gYearMonth("1999-05Z") cast as xs:date
xs:gYearMonth("1999-05Z") cast as xs:dateTime
xs:gYearMonth("1999-05Z") cast as xs:dayTimeDuration
xs:gYearMonth("1999-05Z") cast as xs:decimal
xs:gYearMonth("1999-05Z") cast as xs:double
xs:gYearMonth("1999-05Z") cast as xs:duration
xs:gYearMonth("1999-05Z") cast as xs:gDay
xs:gYearMonth("1999-05Z") cast as xs:gMonth
xs:gYearMonth("1999-05Z") cast as xs:gMonthDay
xs:gYearMonth("1999-05Z") cast as xs:gYear
xs:gYearMonth("1999-05Z") cast as xs:gYearMonth
xs:gYearMonth("1999-05Z") cast as xs:hexBinary
xs:gYearMonth("1999-05Z") cast as xs:integer
xs:gYearMonth("1999-05Z") cast as xs:time
xs:gYearMonth("1999-05Z") cast as xs:yearMonthDuration
xs:gYearMonth("1999-08-10")
xs:gYearMonth( "1999-11" , "1999-11" )
xs:gYearMonth("1999-11") castable as xs:gYearMonth
xs:gYearMonth("1999-11") castable as xs:string
xs:gYearMonth("1999-11") castable as xs:untypedAtomic
xs:gYearMonth("1999-11") cast as xs:anyURI
xs:gYearMonth("1999-11") cast as xs:base64Binary
xs:gYearMonth("1999-11") cast as xs:boolean
xs:gYearMonth("1999-11") cast as xs:date
xs:gYearMonth("1999-11") cast as xs:dateTime
xs:gYearMonth("1999-11") cast as xs:dayTimeDuration
xs:gYearMonth("1999-11") cast as xs:decimal
xs:gYearMonth("1999-11") cast as xs:double
xs:gYearMonth("1999-11") cast as xs:duration
xs:gYearMonth("1999-11") cast as xs:float
xs:gYearMonth("1999-11") cast as xs:gDay
xs:gYearMonth("1999-11") cast as xs:gMonth
xs:gYearMonth("1999-11") cast as xs:gMonthDay
xs:gYearMonth("1999-11") cast as xs:gYear
xs:gYearMonth("1999-11") cast as xs:gYearMonth eq xs:gYearMonth("1999-11")
xs:gYearMonth("1999-11") cast as xs:hexBinary
xs:gYearMonth("1999-11") cast as xs:integer
xs:gYearMonth("1999-11") cast as xs:string ne xs:string("an arbitrary string")
xs:gYearMonth("1999-11") cast as xs:time
xs:gYearMonth("1999-11") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:gYearMonth("1999-11") cast as xs:yearMonthDuration
xs:gYearMonth(" 1999-11 ") eq xs:gYearMonth(" 1999-11 ")
xs:gYearMonth("+1999-12")
xs:gYearMonth("--1999-12")
xs:gYearMonth("1999--12")
xs:gYearMonth("1999-12-")
xs:gYearMonth("1999-13")
(xs:gYearMonth("2000-01Z") eq xs:gYearMonth("2000-03Z")) or (xs:gYearMonth("1976-06Z") eq xs:gYearMonth("1976-06Z"))
(xs:gYearMonth("2000-01Z") ne xs:gYearMonth("2000-01Z")) and (xs:gYearMonth("1975-01Z") ne xs:gYearMonth("1975-03Z"))
(xs:gYearMonth("2000-02Z") eq xs:gYearMonth("2000-03Z")) and (xs:gYearMonth("2001-01Z") eq xs:gYearMonth("2001-01Z"))
(xs:gYearMonth("2000-06Z") ne xs:gYearMonth("2000-07Z")) or (fn:true())
xs:gYearMonth("2001-01 ") eq xs:gYearMonth("2001-01")
xs:gYearMonth("2001-12") ne xs:gYearMonth("2001-11")
xs:gYearMonth('2017-07-00:30')
xs:gYearMonth("2030-12Z") eq xs:gYearMonth("1970-01Z")
xs:gYearMonth("2030-12Z") ne xs:gYearMonth("1970-01Z")
xs:gYearMonth(xs:date("2002-11-23-13:37")) eq xs:gYearMonth("2002-11-13:37")
xs:gYearMonth(xs:date("2002-11-23Z")) eq xs:gYearMonth("2002-11Z")
xs:gYearMonth(xs:dateTime("2002-11-23T23:12:23.867-00:00")) eq xs:gYearMonth("2002-11Z")
xs:gYearMonth(xs:dateTime("2002-11-23T23:12:23.867-13:37")) eq xs:gYearMonth("2002-11-13:37")
xs:gYearMonth(xs:untypedAtomic( "1999-11" )) eq xs:gYearMonth("1999-11")
xs:gYear(xs:date("2002-11-23-13:37")) eq xs:gYear("2002-13:37")
xs:gYear(xs:date("2002-11-23Z")) eq xs:gYear("2002Z")
xs:gYear(xs:dateTime("2002-11-23T23:12:23.867-00:00")) eq xs:gYear("2002Z")
xs:gYear(xs:dateTime("2002-11-23T23:12:23.867-13:37")) eq xs:gYear("2002-13:37")
xs:gYear(xs:untypedAtomic( "1999" )) eq xs:gYear("1999")
xs:hexBinary()
xs:hexBinary("00") eq xs:hexBinary("")
xs:hexBinary( "0FB7" , "0FB7" )
xs:hexBinary("0fb7") castable as xs:base64Binary
xs:hexBinary("0FB7") castable as xs:base64Binary
xs:hexBinary("0FB7") castable as xs:hexBinary
xs:hexBinary("0FB7") castable as xs:string
xs:hexBinary("0FB7") castable as xs:untypedAtomic
xs:hexBinary("0FB7") cast as xs:anyURI
xs:hexBinary("0fb7") cast as xs:base64Binary
xs:hexBinary("0FB7") cast as xs:base64Binary ne xs:base64Binary("aaaa")
xs:hexBinary("0FB7") cast as xs:boolean
xs:hexBinary("0FB7") cast as xs:date
xs:hexBinary("0FB7") cast as xs:dateTime
xs:hexBinary("0FB7") cast as xs:dayTimeDuration
xs:hexBinary("0FB7") cast as xs:decimal
xs:hexBinary("0FB7") cast as xs:double
xs:hexBinary("0FB7") cast as xs:duration
xs:hexBinary("0FB7") cast as xs:float
xs:hexBinary("0FB7") cast as xs:gDay
xs:hexBinary("0FB7") cast as xs:gMonth
xs:hexBinary("0FB7") cast as xs:gMonthDay
xs:hexBinary("0FB7") cast as xs:gYear
xs:hexBinary("0FB7") cast as xs:gYearMonth
xs:hexBinary("0FB7") cast as xs:hexBinary eq xs:hexBinary("0FB7")
xs:hexBinary("0FB7") cast as xs:integer
xs:hexBinary("0FB7") cast as xs:string ne xs:string("an arbitrary string")
xs:hexBinary("0FB7") cast as xs:time
xs:hexBinary("0FB7") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:hexBinary("0FB7") cast as xs:yearMonthDuration
xs:hexBinary(" 0FB7 ") eq xs:hexBinary(" 0FB7 ")
xs:hexBinary("0xFF")
xs:hexBinary("6e7875626264756366") eq xs:hexBinary("767479716c6a647663")
xs:hexBinary("6e7875626264756366") ne xs:hexBinary("767479716c6a647663")
xs:hexBinary("767479716c6a647663") eq xs:hexBinary("6e7875626264756366")
xs:hexBinary("767479716c6a647663") eq xs:hexBinary("767479716c6a647663")
xs:hexBinary("767479716c6a647663") eq xs:hexBinary("786174616d61616772")
xs:hexBinary("767479716c6a647663") ne xs:hexBinary("6e7875626264756366")
xs:hexBinary("767479716c6a647663") ne xs:hexBinary("767479716c6a647663")
xs:hexBinary("767479716c6a647663") ne xs:hexBinary("786174616d61616772")
xs:hexBinary("786174616d61616772") eq xs:hexBinary("767479716c6a647663")
(xs:hexBinary("786174616d61616772") eq xs:hexBinary("767479716c6a647663")) and fn:false()
(xs:hexBinary("786174616d61616772") eq xs:hexBinary("767479716c6a647663")) and fn:true()
(xs:hexBinary("786174616d61616772") eq xs:hexBinary("767479716c6a647663")) and (xs:hexBinary("786174616d61616772") eq xs:hexBinary("767479716c6a647663"))
(xs:hexBinary("786174616d61616772") eq xs:hexBinary("767479716c6a647663")) or fn:false()
(xs:hexBinary("786174616d61616772") eq xs:hexBinary("767479716c6a647663")) or fn:true()
(xs:hexBinary("786174616d61616772") eq xs:hexBinary("767479716c6a647663")) or (xs:hexBinary("786174616d61616772") eq xs:hexBinary("767479716c6a647663"))
xs:hexBinary("786174616d61616772") ne xs:hexBinary("767479716c6a647663")
(xs:hexBinary("786174616d61616772") ne xs:hexBinary("767479716c6a647663")) and fn:false()
(xs:hexBinary("786174616d61616772") ne xs:hexBinary("767479716c6a647663")) and fn:true()
(xs:hexBinary("786174616d61616772") ne xs:hexBinary("767479716c6a647663")) and (xs:hexBinary("786174616d61616772") ne xs:hexBinary("767479716c6a647663"))
(xs:hexBinary("786174616d61616772") ne xs:hexBinary("767479716c6a647663")) or fn:false()
(xs:hexBinary("786174616d61616772") ne xs:hexBinary("767479716c6a647663")) or fn:true()
(xs:hexBinary("786174616d61616772") ne xs:hexBinary("767479716c6a647663")) or (xs:hexBinary("786174616d61616772") ne xs:hexBinary("767479716c6a647663"))
xs:hexBinary("D74D35D35D35") castable as xs:anyURI
xs:hexBinary("D74D35D35D35") castable as xs:base64Binary
xs:hexBinary("D74D35D35D35") castable as xs:boolean
xs:hexBinary("D74D35D35D35") castable as xs:date
xs:hexBinary("D74D35D35D35") castable as xs:dateTime
xs:hexBinary("D74D35D35D35") castable as xs:dayTimeDuration
xs:hexBinary("D74D35D35D35") castable as xs:decimal
xs:hexBinary("D74D35D35D35") castable as xs:double
xs:hexBinary("D74D35D35D35") castable as xs:duration
xs:hexBinary("D74D35D35D35") castable as xs:float
xs:hexBinary("D74D35D35D35") castable as xs:gDay
xs:hexBinary("D74D35D35D35") castable as xs:gMonth
xs:hexBinary("D74D35D35D35") castable as xs:gMonthDay
xs:hexBinary("D74D35D35D35") castable as xs:gYear
xs:hexBinary("D74D35D35D35") castable as xs:gYearMonth
xs:hexBinary("d74d35d35d35") castable as xs:hexBinary
xs:hexBinary("D74D35D35D35") castable as xs:hexBinary
xs:hexBinary("D74D35D35D35") castable as xs:integer
xs:hexBinary("D74D35D35D35") castable as xs:string
xs:hexBinary("D74D35D35D35") castable as xs:time
xs:hexBinary("D74D35D35D35") castable as xs:untypedAtomic
xs:hexBinary("D74D35D35D35") castable as xs:yearMonthDuration
xs:hexBinary("D74D35D35D35") cast as xs:anyURI
xs:hexBinary("D74D35D35D35") cast as xs:base64Binary
xs:hexBinary("D74D35D35D35") cast as xs:boolean
xs:hexBinary("D74D35D35D35") cast as xs:date
xs:hexBinary("D74D35D35D35") cast as xs:dateTime
xs:hexBinary("D74D35D35D35") cast as xs:dayTimeDuration
xs:hexBinary("D74D35D35D35") cast as xs:decimal
xs:hexBinary("D74D35D35D35") cast as xs:double
xs:hexBinary("D74D35D35D35") cast as xs:duration
xs:hexBinary("D74D35D35D35") cast as xs:float
xs:hexBinary("D74D35D35D35") cast as xs:gDay
xs:hexBinary("D74D35D35D35") cast as xs:gMonth
xs:hexBinary("D74D35D35D35") cast as xs:gMonthDay
xs:hexBinary("D74D35D35D35") cast as xs:gYear
xs:hexBinary("D74D35D35D35") cast as xs:gYearMonth
xs:hexBinary("d74d35d35d35") cast as xs:hexBinary
xs:hexBinary("D74D35D35D35") cast as xs:hexBinary
xs:hexBinary("D74D35D35D35") cast as xs:integer
xs:hexBinary("D74D35D35D35") cast as xs:string
xs:hexBinary("D74D35D35D35") cast as xs:time
xs:hexBinary("D74D35D35D35") cast as xs:untypedAtomic
xs:hexBinary("D74D35D35D35") cast as xs:yearMonthDuration
xs:hexBinary("") eq xs:hexBinary("")
xs:hexBinary("") eq xs:hexBinary("01")
xs:hexBinary("F")
xs:hexBinary("FFF")
xs:hexBinary("FF") ne xs:hexBinary("aa")
xs:hexBinary("FFxF")
xs:hexBinary("x")
xs:hexBinary(xs:base64Binary("gMA="))
xs:hexBinary(xs:base64Binary("qrvM"))
xs:hexBinary(xs:base64Binary("/w=="))
xs:hexBinary(xs:base64Binary("/w==")) eq xs:hexBinary("FF")
xs:hexBinary(xs:base64Binary(xs:hexBinary("03"))) ne xs:hexBinary("13")
xs:hexBinary(xs:untypedAtomic( "0FB7" )) eq xs:hexBinary("0FB7")
xs:ID("")
xs:ID('id') castable as xs:NCName
xs:ID('id') cast as xs:NCName
xs:ID("NCName") instance of xs:ID
xs:ID("ncname") instance of xs:IDREF
xs:ID("ncname") instance of xs:NCName
xs:IDREF("")
xs:IDREF("NCName") instance of xs:IDREF
xs:IDREF("ncname") instance of xs:NCName
xs:int("")
xs:int("000000001")
xs:int(0) and xs:int(0)
xs:int(0) and xs:int(1)
xs:int(0) instance of xs:int
xs:int("0") instance of xs:long
xs:int(0) or xs:int(0)
xs:int(0) or xs:int(1)
xs:int("0x2147483647")
+(xs:int("-1873914410"))
-(xs:int("-1873914410"))
xs:int("-1873914410") eq xs:int("-2147483648")
xs:int("-1873914410") ge xs:int("-2147483648")
xs:int("-1873914410") gt xs:int("-2147483648")
xs:int("-1873914410") idiv xs:int("-2147483648")
xs:int("-1873914410") lt xs:int("-2147483648")
xs:int("-1873914410") ne xs:int("-2147483648")
xs:int("-1873914410") - xs:int("-2147483648")
xs:int("-1873914410")||xs:int("-2147483648")
xs:int("-1873914410") + xs:int("-273569238")
xs:int(-1) and xs:int(0)
xs:int(1) and xs:int(-1)
xs:int(-1) or xs:int(0)
xs:int(1) or xs:int(-1)
xs:int("-1") - xs:int("2147483647")
xs:int("-1") - xs:int("-2147483648")
+(xs:int("2147483647"))
-(xs:int("-2147483647"))
-(xs:int("2147483647"))
xs:int("2147483647")
xs:int(2147483647) and xs:int(0)
xs:int(2147483647) and xs:int(-1)
xs:int(2147483647) and xs:int(-2147483648)
xs:int("2147483647") eq xs:int("-2147483648")
xs:int("2147483647") ge xs:int("-2147483648")
xs:int("2147483647") gt xs:int("-2147483648")
xs:int("2147483647") idiv xs:int("-2147483648")
xs:int("2147483647") lt xs:int("-2147483648")
xs:int("2147483647") ne xs:int("-2147483648")
xs:int(2147483647) or xs:int(0)
xs:int(2147483647) or xs:int(-1)
xs:int(2147483647) or xs:int(-2147483648)
xs:int("2147483647") + xs:int("-2147483648")
xs:int("2147483647")||xs:int("-2147483648")
+(xs:int("-2147483648"))
xs:int("-2147483648")
xs:int("2147483648")
xs:int(2147483648)
xs:int(-2147483648) and xs:int(0)
xs:int(-2147483648) and xs:int(1)
xs:int("-2147483648") div xs:int("-2147483648")
xs:int("-2147483648") eq xs:int("-1873914410")
xs:int("-2147483648") eq xs:int("2147483647")
xs:int("-2147483648") eq xs:int("-2147483648")
xs:int("-2147483648") ge xs:int("-1873914410")
xs:int("-2147483648") ge xs:int("2147483647")
xs:int("-2147483648") ge xs:int("-2147483648")
xs:int("-2147483648") gt xs:int("-1873914410")
xs:int("-2147483648") gt xs:int("2147483647")
xs:int("-2147483648") gt xs:int("-2147483648")
xs:int("-2147483648") idiv xs:int("-1873914410")
xs:int("-2147483648") idiv xs:int("2147483647")
xs:int("-2147483648") idiv xs:int("-2147483648")
xs:int("-2147483648") lt xs:int("-1873914410")
xs:int("-2147483648") lt xs:int("2147483647")
xs:int("-2147483648") lt xs:int("-2147483648")
xs:int("-2147483648") mod xs:int("2147483647")
xs:int("-2147483648") ne xs:int("-1873914410")
xs:int("-2147483648") ne xs:int("2147483647")
xs:int("-2147483648") ne xs:int("-2147483648")
xs:int(-2147483648) or xs:int(0)
xs:int(-2147483648) or xs:int(1)
(xs:int("-2147483648")||xs:int("-1873914410"))
xs:int("-2147483648") - xs:int("-1873914410")
(xs:int("-2147483648")||xs:int("2147483647"))
xs:int("-2147483648") + xs:int("2147483647")
xs:int("-2147483648") - xs:int("-2147483648")
xs:int("-2147483648")||xs:int("-2147483648")
xs:int("-2147483649")
xs:int(-2147483649)
xs:int("-273569238") + xs:int("-1873914410")
xs:int("3.0")
xs:int("+ 5")
xs:int("- 5")
xs:integer("")
xs:integer()
-xs:integer(0)
xs:integer(0) and xs:integer(0)
xs:integer(0) and xs:integer(1)
xs:integer(0) or xs:integer(0)
xs:integer(0) or xs:integer(1)
xs:integer("-100") castable as xs:anyURI
xs:integer("-100") castable as xs:base64Binary
xs:integer("-100") castable as xs:boolean
xs:integer("-100") castable as xs:date
xs:integer("-100") castable as xs:dateTime
xs:integer("-100") castable as xs:dayTimeDuration
xs:integer("-100") castable as xs:decimal
xs:integer("-100") castable as xs:double
xs:integer("-100") castable as xs:duration
xs:integer("-100") castable as xs:float
xs:integer("-100") castable as xs:gDay
xs:integer("-100") castable as xs:gMonth
xs:integer("-100") castable as xs:gMonthDay
xs:integer("-100") castable as xs:gYear
xs:integer("-100") castable as xs:gYearMonth
xs:integer("-100") castable as xs:hexBinary
xs:integer("-100") castable as xs:integer
xs:integer("-100") castable as xs:string
xs:integer("-100") castable as xs:time
xs:integer("-100") castable as xs:yearMonthDuration
xs:integer("-100") cast as xs:anyURI
xs:integer("-100") cast as xs:base64Binary
xs:integer("-100") cast as xs:boolean
xs:integer("-100") cast as xs:date
xs:integer("-100") cast as xs:dateTime
xs:integer("-100") cast as xs:dayTimeDuration
xs:integer("-100") cast as xs:decimal
xs:integer("-100") cast as xs:double
xs:integer("-100") cast as xs:duration
xs:integer("-100") cast as xs:float
xs:integer("-100") cast as xs:gDay
xs:integer("-100") cast as xs:gMonth
xs:integer("-100") cast as xs:gMonthDay
xs:integer("-100") cast as xs:gYear
xs:integer("-100") cast as xs:gYearMonth
xs:integer("-100") cast as xs:hexBinary
xs:integer("-100") cast as xs:integer
xs:integer("-100") cast as xs:string
xs:integer("-100") cast as xs:time
xs:integer("-100") cast as xs:yearMonthDuration
(xs:integer(1), 2, 3)
xs:integer(12678967543233) cast as xs:boolean
xs:integer(12678967543233) cast as xs:decimal
(xs:integer(12678967543233) cast as xs:float) eq xs:float(12678967543233)
xs:integer(12678967543233) cast as xs:integer
xs:integer(12678967543233) cast as xs:string
xs:integer(-1) and xs:integer(0)
xs:integer(1) and xs:integer(-1)
xs:integer("1") castable as xs:untypedAtomic
xs:integer("1") cast as xs:untypedAtomic
xs:integer(-1) eq xs:integer(-1)
xs:integer(1) eq xs:integer(1)
xs:integer(1) ge xs:integer(1)
xs:integer(1) gt xs:integer(-1)
xs:integer(-1) le xs:integer(1)
xs:integer(-1) lt xs:integer(1)
xs:integer(1) ne xs:integer(2)
xs:integer(-1) or xs:integer(0)
xs:integer(1) or xs:integer(-1)
(xs:integer(1) to 5)
(xs:integer(1) to xs:integer(5))
xs:integer(2) idiv xs:decimal(1)
xs:integer(2) ne xs:decimal(2.6)
xs:integer(3.1) eq 3
xs:integer(3) eq 3
xs:integer(5) div xs:integer(2) eq 2.5
xs:integer(5) div xs:integer(2) ne 2.6
xs:integer( "6789" , "6789" )
xs:integer("6789") castable as xs:boolean
xs:integer("6789") castable as xs:decimal
xs:integer("6789") castable as xs:double
xs:integer("6789") castable as xs:float
xs:integer("6789") castable as xs:integer
xs:integer("6789") castable as xs:string
xs:integer("6789") castable as xs:untypedAtomic
xs:integer("6789") cast as xs:anyURI
xs:integer("6789") cast as xs:base64Binary
xs:integer("6789") cast as xs:boolean eq xs:boolean("true")
xs:integer("6789") cast as xs:date
xs:integer("6789") cast as xs:dateTime
xs:integer("6789") cast as xs:dayTimeDuration
xs:integer("6789") cast as xs:decimal ne xs:decimal("10.01")
xs:integer("6789") cast as xs:double ne xs:double("3.3e3")
xs:integer("6789") cast as xs:duration
xs:integer("6789") cast as xs:float ne xs:float("3.4e5")
xs:integer("6789") cast as xs:gDay
xs:integer("6789") cast as xs:gMonth
xs:integer("6789") cast as xs:gMonthDay
xs:integer("6789") cast as xs:gYear
xs:integer("6789") cast as xs:gYearMonth
xs:integer("6789") cast as xs:hexBinary
xs:integer("6789") cast as xs:integer eq xs:integer("6789")
xs:integer("6789") cast as xs:string ne xs:string("an arbitrary string")
xs:integer("6789") cast as xs:time
xs:integer("6789") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:integer("6789") cast as xs:yearMonthDuration
xs:integer(" 6789 ") eq xs:integer(" 6789 ")
(xs:integer(6) div xs:decimal(2)) instance of xs:decimal
(xs:integer(6) div xs:double(2)) instance of xs:double
xs:integer(6) div xs:integer(2) eq 3
(xs:integer(6) div xs:integer(2)) instance of xs:decimal
(xs:integer(6) idiv xs:decimal(2)) instance of xs:integer
(xs:integer(6) idiv xs:double(2)) instance of xs:integer
(xs:integer(6) idiv xs:float(2)) instance of xs:integer
(xs:integer(6) idiv xs:integer(2)) instance of xs:integer
xs:integer(6) instance of xs:decimal
xs:integer(6) instance of xs:integer
(xs:integer(6) mod xs:decimal(2)) instance of xs:decimal
(xs:integer(6) mod xs:double(2)) instance of xs:double
(xs:integer(6) mod xs:integer(2)) instance of xs:integer
(xs:integer(6) * xs:decimal(2)) instance of xs:decimal
(xs:integer(6) + xs:decimal(2)) instance of xs:decimal
(xs:integer(6) - xs:decimal(2)) instance of xs:decimal
(xs:integer(6) * xs:double(2)) instance of xs:double
(xs:integer(6) + xs:double(2)) instance of xs:double
(xs:integer(6) - xs:double(2)) instance of xs:double
xs:integer(6) * xs:integer(2) eq 12
xs:integer(6) - xs:integer(2) eq 4
xs:integer(6) + xs:integer(2) eq 8
(xs:integer(6) * xs:integer(2)) instance of xs:integer
(xs:integer(6) + xs:integer(2)) instance of xs:integer
(xs:integer(6) - xs:integer(2)) instance of xs:integer
xs:integer(99999999999999999) and xs:integer(0)
xs:integer(-99999999999999999) and xs:integer(1)
xs:integer(99999999999999999) and xs:integer(-99999999999999999)
xs:integer(99999999999999999) or xs:integer(0)
xs:integer(-99999999999999999) or xs:integer(1)
xs:integer(99999999999999999) or xs:integer(-99999999999999999)
xs:integer(fn:translate("123","123","123"))
xs:integer('INF')
xs:integer(/works/employee[830]/hours) eq 40
xs:integer(/works/employee[830]/hours) eq 40e0
xs:integer(xs:double("-INF"))
xs:integer(xs:double("INF"))
xs:integer(xs:double("NaN"))
xs:integer(xs:float("-INF"))
xs:integer(xs:float("INF"))
xs:integer(xs:float("NaN"))
xs:integer(xs:untypedAtomic( "6789" )) eq xs:integer("6789")
xs:int(false())
xs:int(true())
xs:int(xs:double("-4")) instance of xs:int
xs:int(xs:double("-INF"))
xs:int(xs:double("INF"))
xs:int(xs:double("NaN"))
xs:int(xs:float("-4")) instance of xs:int
xs:int(xs:float("-INF"))
xs:int(xs:float("INF"))
xs:int(xs:float("NaN"))
xs:language("")
xs:language("1")
xs:language(1)
xs:language("a")
xs:language("a1a")
xs:language("a*a")
xs:language("a.a")
xs:language("ab")
xs:language("abc")
xs:language("abc-")
xs:language("abc-a-1-1b01efil")
xs:language("abc-a-1-1b1efil")
xs:language("abc-a-1b1efikl")
xs:language("abc--ab")
xs:language("abc-ab-")
xs:language("abc-ab1efikl")
xs:language("abc-abcdefikl")
xs:language("abc-abcdef.k")
xs:language("abcd")
xs:language("abcde")
xs:language("abcdef")
xs:language("abcdefg")
xs:language("abcdefgh")
xs:language("abcdefgh-abcdefgh")
xs:language("abcdefjhl")
xs:language(current-date())
xs:language(current-dateTime())
xs:language(current-time())
xs:language('en-gb') castable as xs:language
xs:language('en-gb') cast as xs:language
xs:language(false())
xs:language("NCName") instance of xs:language
xs:language("ncname") instance of xs:NMTOKEN
xs:language("ncname") instance of xs:token
xs:language(QName("http://example.com/", "p:localName"))
xs:language(true())
xs:language(xs:base64Binary("1111"))
xs:language(xs:dayTimeDuration("P1DT4H"))
xs:language(xs:decimal("543"))
xs:language(xs:double("543"))
xs:language(xs:duration("P1M"))
xs:language(xs:float("543"))
xs:language(xs:gDay("---11"))
xs:language(xs:gMonth("--10"))
xs:language(xs:gMonthDay("--10-15"))
xs:language(xs:gYear("4004"))
xs:language(xs:hexBinary("11"))
xs:language(xs:integer("543"))
xs:language(xs:short("1"))
xs:language(xs:yearMonthDuration("P4Y5M"))
xs:long("")
xs:long("000000001")
xs:long(0) and xs:long(0)
xs:long(0) and xs:long(1)
xs:long("0") instance of xs:integer
xs:long(0) instance of xs:long
xs:long(0) or xs:long(0)
xs:long(0) or xs:long(1)
xs:long("0x9223372036854775807")
xs:long(10) + xs:unsignedLong(35)
xs:long(-1) and xs:long(0)
xs:long(1) and xs:long(-1)
xs:long("1") instance of xs:negativeInteger
xs:long("1") instance of xs:nonNegativeInteger
xs:long("1") instance of xs:nonPositiveInteger
xs:long("1") instance of xs:positiveInteger
xs:long(-1) or xs:long(0)
xs:long(1) or xs:long(-1)
xs:long("3.0")
xs:long("+ 5")
xs:long("- 5")
xs:long(9223372036854775808)
xs:long(-9223372036854775809)
xs:long(-99999999999999999) and xs:long(0)
xs:long(-99999999999999999) and xs:long(1)
xs:long(99999999999999999) and xs:long(-99999999999999999)
xs:long(-99999999999999999) or xs:long(0)
xs:long(-99999999999999999) or xs:long(1)
xs:long(99999999999999999) or xs:long(-99999999999999999)
xs:long(false())
xs:long(true())
xs:long(xs:double("-4")) instance of xs:long
xs:long(xs:double("-INF"))
xs:long(xs:double("INF"))
xs:long(xs:double("NaN"))
xs:long(xs:float("-4")) instance of xs:long
xs:long(xs:float("-INF"))
xs:long(xs:float("INF"))
xs:long(xs:float("NaN"))
xs:Name("")
xs:Name(":")
xs:Name("::::")
xs:Name("_")
xs:Name("1abc")
xs:Name(" a ")
xs:Name("a")
xs:Name("a1123-_--__-__--....-.--.-..12309asd")
xs:Name("ab|")
xs:Name("ab\c")
xs:Name("a c")
xs:name("input")
xs:Name("ncname") instance of xs:language
xs:Name("NCName") instance of xs:Name
xs:Name("ncname") instance of xs:token
xs:NCName("")
xs:NCName('entity') cast as xs:ENTITY
xs:NCName('id') cast as xs:ID
xs:NCName('idref') cast as xs:IDREF
xs:NCName('NCName') castable as xs:Name
xs:NCName('NCName') cast as xs:Name
xs:NCName("ncname") instance of xs:Name
xs:NCName("NCName") instance of xs:NCName
xs:negativeInteger("")
xs:negativeInteger("+0")
xs:negativeInteger("-0")
xs:negativeInteger("0")
xs:negativeInteger(0)
xs:negativeInteger("-000000001")
xs:negativeInteger("-0x1")
+(xs:negativeInteger("-1"))
-(xs:negativeInteger("-1"))
xs:negativeInteger("--1")
xs:negativeInteger("-1")
xs:negativeInteger(-1) and xs:negativeInteger(-1)
xs:negativeInteger(-1) instance of xs:negativeInteger
xs:negativeInteger("-1") instance of xs:nonPositiveInteger
xs:negativeInteger(-1) or xs:negativeInteger(-1)
xs:negativeInteger("- 3")
xs:negativeInteger("-3.0")
xs:negativeInteger(-99999999999999999) and xs:negativeInteger(-1)
xs:negativeInteger(-99999999999999999) and xs:negativeInteger(-99999999999999999)
xs:negativeInteger(-99999999999999999) or xs:negativeInteger(-1)
xs:negativeInteger(-99999999999999999) or xs:negativeInteger(-99999999999999999)
xs:negativeInteger(false())
xs:negativeInteger(true())
xs:negativeInteger(xs:double("-4")) instance of xs:negativeInteger
xs:negativeInteger(xs:double("-INF"))
xs:negativeInteger(xs:double("INF"))
xs:negativeInteger(xs:double("NaN"))
xs:negativeInteger(xs:float("-4")) instance of xs:negativeInteger
xs:negativeInteger(xs:float("-INF"))
xs:negativeInteger(xs:float("INF"))
xs:negativeInteger(xs:float("NaN"))
xs:NMTOKEN(" ")
xs:NMTOKEN("")
xs:NMTOKEN(";")
xs:NMTOKEN(" f f")
xs:NMTOKEN("NCName") instance of xs:NMTOKEN
xs:NMTOKEN("ncname") instance of xs:token
xs:NMTOKEN('NMTOKEN') castable as xs:NMTOKEN
xs:NMTOKEN('NMTOKEN') cast as xs:NMTOKEN
xs:NMTOKEN(" ::::...:SDA21455313 ")
xs:nonNegativeInteger("")
+(xs:nonNegativeInteger("0"))
-(xs:nonNegativeInteger("0"))
xs:nonNegativeInteger("+ 0")
xs:nonNegativeInteger("- 0")
xs:nonNegativeInteger("--0")
xs:nonNegativeInteger("-0")
xs:nonNegativeInteger("0")
xs:nonNegativeInteger("-00")
xs:nonNegativeInteger("000000001")
xs:nonNegativeInteger(0) and xs:nonNegativeInteger(0)
xs:nonNegativeInteger(0) and xs:nonNegativeInteger(1)
xs:nonNegativeInteger("0") eq xs:nonNegativeInteger("0")
xs:nonNegativeInteger("0") ge xs:nonNegativeInteger("0")
xs:nonNegativeInteger("0") gt xs:nonNegativeInteger("0")
xs:nonNegativeInteger("0") instance of xs:integer
xs:nonNegativeInteger(0) instance of xs:nonNegativeInteger
xs:nonNegativeInteger("0") lt xs:nonNegativeInteger("0")
xs:nonNegativeInteger("0") ne xs:nonNegativeInteger("0")
xs:nonNegativeInteger(0) or xs:nonNegativeInteger(0)
xs:nonNegativeInteger(0) or xs:nonNegativeInteger(1)
xs:nonNegativeInteger("0x0")
(xs:nonNegativeInteger("0") || xs:nonNegativeInteger("0"))
xs:nonNegativeInteger("0") * xs:nonNegativeInteger("0")
xs:nonNegativeInteger("0") + xs:nonNegativeInteger("0")
xs:nonNegativeInteger("0") - xs:nonNegativeInteger("0")
xs:nonNegativeInteger("++1")
xs:nonNegativeInteger("+1")
xs:nonNegativeInteger("-1")
xs:nonNegativeInteger(-1)
xs:nonNegativeInteger(10) + xs:short(15)
xs:nonNegativeInteger(1) and xs:nonNegativeInteger(0)
xs:nonNegativeInteger(1) and xs:nonNegativeInteger(1)
xs:nonNegativeInteger(1) and xs:nonNegativeInteger(99999999999999999)
xs:nonNegativeInteger("1") instance of xs:negativeInteger
xs:nonNegativeInteger("1") instance of xs:nonPositiveInteger
xs:nonNegativeInteger(1) or xs:nonNegativeInteger(0)
xs:nonNegativeInteger(1) or xs:nonNegativeInteger(1)
xs:nonNegativeInteger(1) or xs:nonNegativeInteger(99999999999999999)
xs:nonNegativeInteger("3.0")
xs:nonNegativeInteger(99999999999999999) and xs:nonNegativeInteger(99999999999999999)
xs:nonNegativeInteger(99999999999999999) or xs:nonNegativeInteger(0)
xs:nonNegativeInteger(99999999999999999) or xs:nonNegativeInteger(99999999999999999)
xs:nonNegativeInteger(9999999999) and xs:nonNegativeInteger(0)
xs:nonNegativeInteger(false())
xs:nonNegativeInteger(true())
xs:nonNegativeInteger(xs:double("4")) instance of xs:nonNegativeInteger
xs:nonNegativeInteger(xs:double("-INF"))
xs:nonNegativeInteger(xs:double("INF"))
xs:nonNegativeInteger(xs:double("NaN"))
xs:nonNegativeInteger(xs:float("4")) instance of xs:nonNegativeInteger
xs:nonNegativeInteger(xs:float("-INF"))
xs:nonNegativeInteger(xs:float("INF"))
xs:nonNegativeInteger(xs:float("NaN"))
xs:nonPositiveInteger("")
+(xs:nonPositiveInteger("0"))
-(xs:nonPositiveInteger("0"))
xs:nonPositiveInteger("+ 0")
xs:nonPositiveInteger("++0")
xs:nonPositiveInteger("+0")
xs:nonPositiveInteger("- 0")
xs:nonPositiveInteger("--0")
xs:nonPositiveInteger("-0")
xs:nonPositiveInteger("0")
xs:nonPositiveInteger("+00")
xs:nonPositiveInteger("-000000000")
xs:nonPositiveInteger("-000000001")
xs:nonPositiveInteger(0) and xs:nonPositiveInteger(0)
xs:nonPositiveInteger(0) and xs:nonPositiveInteger(-1)
xs:nonPositiveInteger("0") instance of xs:integer
xs:nonPositiveInteger(0) instance of xs:nonPositiveInteger
xs:nonPositiveInteger(0) or xs:nonPositiveInteger(0)
xs:nonPositiveInteger(0) or xs:nonPositiveInteger(-1)
xs:nonPositiveInteger("0x0")
xs:nonPositiveInteger("+1")
xs:nonPositiveInteger("--1")
xs:nonPositiveInteger("-1")
xs:nonPositiveInteger("1")
xs:nonPositiveInteger(1)
xs:nonPositiveInteger(-1) and xs:nonPositiveInteger(0)
xs:nonPositiveInteger(-1) and xs:nonPositiveInteger(-1)
xs:nonPositiveInteger(-1) and xs:nonPositiveInteger(-9999999999)
xs:nonPositiveInteger(-1) or xs:nonPositiveInteger(0)
xs:nonPositiveInteger(-1) or xs:nonPositiveInteger(-1)
xs:nonPositiveInteger(-1) or xs:nonPositiveInteger(-99999999999999999)
xs:nonPositiveInteger("-3.0")
xs:nonPositiveInteger(-99999999999999999) and xs:nonPositiveInteger(0)
xs:nonPositiveInteger(-99999999999999999) and xs:nonPositiveInteger(-99999999999999999)
xs:nonPositiveInteger(-99999999999999999) or xs:nonPositiveInteger(0)
xs:nonPositiveInteger(-99999999999999999) or xs:nonPositiveInteger(-99999999999999999)
xs:nonPositiveInteger(false())
xs:nonPositiveInteger(true())
xs:nonPositiveInteger(xs:double("0")) instance of xs:nonPositiveInteger
xs:nonPositiveInteger(xs:double("-INF"))
xs:nonPositiveInteger(xs:double("INF"))
xs:nonPositiveInteger(xs:double("NaN"))
xs:nonPositiveInteger(xs:float("0")) instance of xs:nonPositiveInteger
xs:nonPositiveInteger(xs:float("-INF"))
xs:nonPositiveInteger(xs:float("INF"))
xs:nonPositiveInteger(xs:float("NaN"))
xs:normalizedString("")
xs:normalizedString(' ')
xs:normalizedString(5)
xs:normalizedString("NCName") instance of xs:normalizedString
xs:normalizedString("ncname") instance of xs:string
xs:normalizedString("ncname") instance of xs:token
xs:normalizedString("test") castable as xs:normalizedString
xs:normalizedString('&#x9;')
xs:normalizedString(xs:normalizedString("test"))
xs:NOTATION()
xs:NOTATION( "prefix:local" , "prefix:local" )
xs:NOTATION(QName('example.com', 'p:foo'))
xs:NOTATION(xs:anyURI('example.com/'))
xs:positiveInteger("")
xs:positiveInteger("-0")
xs:positiveInteger("0")
xs:positiveInteger(0)
xs:positiveInteger("000000001")
xs:positiveInteger("0x1")
+(xs:positiveInteger("1"))
-(xs:positiveInteger("1"))
xs:positiveInteger("++1")
xs:positiveInteger("+1")
xs:positiveInteger("-1")
xs:positiveInteger("1")
xs:positiveInteger(10) + xs:negativeInteger(-5)
xs:positiveInteger(10) + xs:nonPositiveInteger(-15)
xs:positiveInteger(1) and xs:positiveInteger(1)
xs:positiveInteger("1") div xs:positiveInteger("1")
xs:positiveInteger("1") eq xs:positiveInteger("1")
xs:positiveInteger("1") ge xs:positiveInteger("1")
xs:positiveInteger("1") gt xs:positiveInteger("1")
xs:positiveInteger("1") idiv xs:positiveInteger("1")
xs:positiveInteger("1") instance of xs:negativeInteger
xs:positiveInteger("1") instance of xs:nonNegativeInteger
xs:positiveInteger("1") instance of xs:nonPositiveInteger
xs:positiveInteger(1) instance of xs:positiveInteger
xs:positiveInteger("1") lt xs:positiveInteger("1")
xs:positiveInteger("1") mod xs:positiveInteger("1")
xs:positiveInteger("1") ne xs:positiveInteger("1")
xs:positiveInteger(1) or xs:positiveInteger(1)
(xs:positiveInteger("1") || xs:positiveInteger("1"))
xs:positiveInteger("1") * xs:positiveInteger("1")
xs:positiveInteger("1") + xs:positiveInteger("1")
xs:positiveInteger("+ 3")
xs:positiveInteger("3.0")
xs:positiveInteger("52") castable as xs:double
xs:positiveInteger(99999999999999999) and xs:positiveInteger(1)
xs:positiveInteger(99999999999999999) and xs:positiveInteger(99999999999999999)
xs:positiveInteger(99999999999999999) or xs:positiveInteger(1)
xs:positiveInteger(99999999999999999) or xs:positiveInteger(99999999999999999)
xs:positiveInteger(false())
xs:positiveInteger(true())
xs:positiveInteger(xs:double("4")) instance of xs:positiveInteger
xs:positiveInteger(xs:float("4")) instance of xs:positiveInteger
xs:QName("")
xs:QName()
xs:QName(20)
(xs:QName("fn:local-name") cast as xs:string) eq "fn:local-name"
(xs:QName("fn:local-name") cast as xs:untypedAtomic) eq xs:untypedAtomic("fn:local-name")
(xs:QName("local-name") cast as xs:QName) eq xs:QName("local-name")
(xs:QName("local-name") cast as xs:string) eq "local-name"
(xs:QName("local-name") cast as xs:untypedAtomic) eq xs:untypedAtomic("local-name")
xs:QName("ncname") castable as xs:QName
xs:QName("ncname") castable as xs:string
xs:QName("ncname") castable as xs:untypedAtomic
xs:QName("ncname") cast as xs:anyURI
xs:QName("ncname") cast as xs:base64Binary
xs:QName("ncname") cast as xs:boolean
xs:QName("ncname") cast as xs:date
xs:QName("ncname") cast as xs:dateTime
xs:QName("ncname") cast as xs:dayTimeDuration
xs:QName("ncname") cast as xs:decimal
xs:QName("ncname") cast as xs:double
xs:QName("ncname") cast as xs:duration
xs:QName("ncname") cast as xs:float
xs:QName("ncname") cast as xs:gDay
xs:QName("ncname") cast as xs:gMonth
xs:QName("ncname") cast as xs:gMonthDay
xs:QName("ncname") cast as xs:gYear
xs:QName("ncname") cast as xs:gYearMonth
xs:QName("ncname") cast as xs:hexBinary
xs:QName("ncname") cast as xs:integer
xs:QName("ncname") cast as xs:string ne xs:string("an arbitrary string")
xs:QName("ncname") cast as xs:time
xs:QName("ncname") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:QName("ncname") cast as xs:yearMonthDuration
xs:QName(" ncname ") eq xs:QName(" ncname ")
xs:QName( "ncname" , "ncname" )
xs:QName('prefix:localName')
xs:short("")
xs:short("000000001")
xs:short(0) and xs:short(0)
xs:short(0) and xs:short(1)
xs:short("0") instance of xs:int
xs:short(0) instance of xs:short
xs:short(0) or xs:short(0)
xs:short(0) or xs:short(1)
xs:short("-0x32768")
xs:short(10) + xs:long(145)
xs:short(-1) and xs:short(0)
xs:short(1) and xs:short(-1)
xs:short(-1) or xs:short(0)
xs:short(1) or xs:short(-1)
xs:short("-1") - xs:short("32767")
xs:short("-1") - xs:short("-32768")
xs:short("-27444") + xs:short("-5324")
xs:short("3.0")
+(xs:short("32767"))
-(xs:short("32767"))
xs:short("32767")
xs:short(32767) and xs:short(0)
xs:short(32767) and xs:short(-1)
xs:short(32767) and xs:short(-32768)
xs:short("32767") div xs:short("-32768")
xs:short("32767") eq xs:short("-32768")
xs:short("32767") ge xs:short("-32768")
xs:short("32767") gt xs:short("-32768")
xs:short("32767") idiv xs:short("-32768")
xs:short("32767") lt xs:short("-32768")
xs:short("32767") ne xs:short("-32768")
xs:short(32767) or xs:short(0)
xs:short(32767) or xs:short(-1)
xs:short(32767) or xs:short(-32768)
(xs:short("32767") || xs:short("-32768"))
xs:short("32767") + xs:short("-32768")
+(xs:short("-32768"))
-(xs:short("-32768"))
xs:short("-32768")
xs:short("32768")
xs:short(32768)
xs:short(-32768) and xs:short(0)
xs:short(-32768) and xs:short(1)
xs:short("-32768") div xs:short("32767")
xs:short("-32768") div xs:short("-32768")
xs:short("-32768") eq xs:short("32767")
xs:short("-32768") eq xs:short("-32768")
xs:short("-32768") eq xs:short("-5324")
xs:short("-32768") ge xs:short("32767")
xs:short("-32768") ge xs:short("-32768")
xs:short("-32768") ge xs:short("-5324")
xs:short("-32768") gt xs:short("32767")
xs:short("-32768") gt xs:short("-32768")
xs:short("-32768") gt xs:short("-5324")
xs:short("-32768") idiv xs:short("32767")
xs:short("-32768") idiv xs:short("-32768")
xs:short("-32768") idiv xs:short("-5324")
xs:short("-32768") lt xs:short("32767")
xs:short("-32768") lt xs:short("-32768")
xs:short("-32768") lt xs:short("-5324")
xs:short("-32768") mod xs:short("32767")
xs:short("-32768") ne xs:short("32767")
xs:short("-32768") ne xs:short("-32768")
xs:short("-32768") ne xs:short("-5324")
xs:short(-32768) or xs:short(0)
xs:short(-32768) or xs:short(1)
(xs:short("-32768") || xs:short("32767"))
xs:short("-32768") + xs:short("32767")
(xs:short("-32768") || xs:short("-32768"))
xs:short("-32768") - xs:short("-32768")
(xs:short("-32768") || xs:short("-5324"))
xs:short("-32768") - xs:short("-5324")
xs:short("-32769")
xs:short(-32769)
xs:short("+ 5")
xs:short("- 5")
+(xs:short("-5324"))
-(xs:short("-5324"))
xs:short("-5324") eq xs:short("-32768")
xs:short("-5324") ge xs:short("-32768")
xs:short("-5324") gt xs:short("-32768")
xs:short("-5324") idiv xs:short("-32768")
xs:short("-5324") lt xs:short("-32768")
xs:short("-5324") ne xs:short("-32768")
xs:short("-5324") + xs:short("-27444")
(xs:short("-5324") || xs:short("-32768"))
xs:short("-5324") - xs:short("-32768")
xs:short(false())
xs:short(true())
xs:short(xs:double("-4")) instance of xs:short
xs:short(xs:double("-INF"))
xs:short(xs:double("INF"))
xs:short(xs:double("NaN"))
xs:short(xs:float("-4")) instance of xs:short
xs:short(xs:float("-INF"))
xs:short(xs:float("INF"))
xs:short(xs:float("NaN"))
xs:string()
xs:string("00000000") castable as xs:base64Binary
xs:string("00000000") cast as xs:base64Binary
xs:string("-0012-05:00") castable as xs:gYear
xs:string("-0012-05:00") cast as xs:gYear
xs:string("-0012-12-03-05:00") castable as xs:date
xs:string("-0012-12-03-05:00") cast as xs:date
xs:string("-0012-12-05:00") castable as xs:gYearMonth
xs:string("-0012-12-05:00") cast as xs:gYearMonth
xs:string("0.0") castable as xs:boolean
xs:string("0.0") cast as xs:boolean
xs:string("-0.0E0") castable as xs:decimal
xs:string("-0.0E0") castable as xs:double
xs:string("-0.0E0") castable as xs:float
xs:string("-0.0E0") castable as xs:integer
xs:string("0.0E0") castable as xs:string
xs:string("0.0E0") castable as xs:untypedAtomic
xs:string("-0.0E0") cast as xs:decimal
xs:string("-0.0E0") cast as xs:double
xs:string("-0.0E0") cast as xs:float
xs:string("-0.0E0") cast as xs:integer
xs:string("0.0E0") cast as xs:string
xs:string("0.0E0") cast as xs:untypedAtomic
xs:string("010010101") castable as xs:hexBinary
xs:string("010010101") cast as xs:hexBinary
xs:string("---03-05:00") castable as xs:gDay
xs:string("---03-05:00") cast as xs:gDay
xs:string("--05-31+14:00") castable as xs:gMonthDay
xs:string("--05-31+14:00") cast as xs:gMonthDay
xs:string("--05-31") castable as xs:gMonthDay
xs:string("--05-31") cast as xs:gMonthDay
xs:string("--05-31Z") castable as xs:gMonthDay
xs:string("--05-31Z") cast as xs:gMonthDay
xs:string("--05") castable as xs:gMonth
xs:string("--05") cast as xs:gMonth
xs:string("--05Z") castable as xs:gMonth
xs:string("--05Z") cast as xs:gMonth
xs:string("0") and xs:string('abc')
xs:string("0") castable as xs:boolean
xs:string("0") cast as xs:boolean
xs:string("0fb7") castable as xs:hexBinary
xs:string("0fb7") cast as xs:hexBinary
xs:string("0") or xs:string('abc')
xs:string("-10000000") castable as xs:double
xs:string("-10000000") castable as xs:float
xs:string("-1.1234") castable as xs:integer
xs:string("-1.1234") cast as xs:integer
xs:string("--12-05:00") castable as xs:gMonth
xs:string("--12-05:00") cast as xs:gMonth
xs:string(120) cast as xs:byte
xs:string(12) cast as xs:unsignedByte
xs:string(12) cast as xs:unsignedShort
xs:string("13:20:00-05:00") castable as xs:time
xs:string("13:20:00-05:00") cast as xs:time
xs:string("13:20:00Z") castable as xs:time
xs:string("13:20:00Z") cast as xs:time
xs:string("13:20:02.123") castable as xs:time
xs:string("13:20:02.123") cast as xs:time
xs:string("1999-05-31") castable as xs:date
xs:string("1999-05-31") cast as xs:date
xs:string("-1999-05-31T13:20:00+14:00") castable as xs:dateTime
xs:string("-1999-05-31T13:20:00+14:00") cast as xs:dateTime
xs:string("1999-05-31T13:20:00") castable as xs:dateTime
xs:string("1999-05-31T13:20:00") cast as xs:dateTime
xs:string("1999-05-31Z") castable as xs:date
xs:string("1999-05-31Z") cast as xs:date
xs:string("1999-05") castable as xs:gYearMonth
xs:string("1999-05") cast as xs:gYearMonth
xs:string("1999-05Z") castable as xs:gYearMonth
xs:string("1999-05Z") cast as xs:gYearMonth
xs:string("1999") castable as xs:gYear
xs:string("1999") cast as xs:gYear
xs:string("1999Z") castable as xs:gYear
xs:string("1999Z") cast as xs:gYear
xs:string("1e-5") castable as xs:decimal
xs:string("1e-5") castable as xs:double
xs:string("1e-5") castable as xs:float
xs:string("1e-5") castable as xs:integer
xs:string("1e-5") cast as xs:decimal
xs:string("1e-5") cast as xs:double
xs:string("1e-5") cast as xs:float
xs:string("1e-5") cast as xs:integer
xs:string((1 to 10)[. mod 2 = 0] instance of xs:integer+)
xs:string("2000-01-16T00:00:00Z") castable as xs:dateTime
xs:string("2000-01-16T00:00:00Z") cast as xs:dateTime
xs:string(200) cast as xs:nonNegativeInteger
xs:string(-201) cast as xs:negativeInteger
xs:string(20) cast as xs:int
xs:string(20) cast as xs:long
xs:string(-20) cast as xs:nonPositiveInteger
xs:string(20) cast as xs:unsignedLong
xs:string(300) cast as xs:positiveInteger
xs:string(300) cast as xs:unsignedInt
xs:string(30) cast as xs:short
xs:string("---31") castable as xs:gDay
xs:string("---31") cast as xs:gDay
xs:string("---31Z") castable as xs:gDay
xs:string("---31Z") cast as xs:gDay
xs:string("5.5432") castable as xs:decimal
xs:string("5.5432") cast as xs:decimal
xs:string("abc") and xs:string('')
(xs:string("ABC"), "D", "E")
xs:string("abc") or xs:string('')
xs:string( "an arbitrary string" , "an arbitrary string" )
xs:string("an arbitrary string") castable as xs:string
xs:string("an arbitrary string") castable as xs:untypedAtomic
xs:string("an arbitrary string") cast as xs:string eq xs:string("an arbitrary string")
xs:string("an arbitrary string") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:string(" an arbitrary string ") eq xs:string(" an arbitrary string ")
xs:string("") and xs:string('')
xs:string("") and xs:string('abc')
xs:string("A String") cast as xs:NOTATION
xs:string("a") , xs:anyURI("www.example.com")
xs:string("a") , xs:string("b")
xs:string("a") , (), "xyz"
xs:string("D74D35D35D35") castable as xs:base64Binary
xs:string("D74D35D35D35") castable as xs:hexBinary
xs:string("D74D35D35D35") cast as xs:base64Binary
xs:string("D74D35D35D35") cast as xs:hexBinary
xs:string(dateTime(xs:date("1999-12-31"), xs:time("24:00:00"))) eq "1999-12-31T00:00:00"
xs:string("") eq xs:string("")
xs:string("example.com/") eq xs:anyURI("example.com/")
xs:string("example.com/") ne xs:anyURI("example.com/No")
xs:string("example.org/") eq xs:anyURI("example.org/")
xs:string("example.org/") ne xs:anyURI("example.org/")
xs:string("false") != false()
xs:string("false") = false()
xs:string(fn:codepoints-to-string((65,32,83,116,114,105,110,103)))
xs:string(fn:current-date())
xs:string(fn:current-dateTime())
xs:string(fn:current-time())
xs:string(fn:prefix-from-QName(xs:QName("foo:name")))
xs:string("hello") , xs:integer("100"), xs:anyURI("www.example.com")
xs:string("http://example.com/A") eq xs:anyURI("http://example.com/A")
xs:string("http://example.com/A") le xs:anyURI("http://example.com/A")
xs:string("http://example.com/A") lt xs:anyURI("http://example.com/B")
xs:string("http://example.com/A") ne xs:anyURI("http://example.com/B")
xs:string("http://example.com/B") gt xs:anyURI("http://example.com/A")
xs:string("http://www.example.com/~b%C3%A9b%C3%A9") castable as xs:anyURI
xs:string("http://www.example.com/~b%C3%A9b%C3%A9") cast as xs:anyURI
xs:string("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:anyURI
xs:string("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:anyURI
xs:string("INF") castable as xs:string
xs:string("INF") castable as xs:untypedAtomic
xs:string("INF") cast as xs:string
xs:string("INF") cast as xs:untypedAtomic
((), "xs:string") instance of xs:string
xs:string("NaN") castable as xs:decimal
xs:string("NaN") castable as xs:double
xs:string("NaN") castable as xs:float
xs:string("NaN") castable as xs:integer
xs:string("NaN") cast as xs:decimal
xs:string("NaN") cast as xs:double
xs:string("NaN") cast as xs:float
xs:string("NaN") cast as xs:integer
xs:string("") or xs:string('')
xs:string("") or xs:string('abc')
xs:string("-P1Y1M1DT1H1M1.123S") castable as xs:dayTimeDuration
xs:string("-P1Y1M1DT1H1M1.123S") castable as xs:duration
xs:string("-P1Y1M1DT1H1M1.123S") castable as xs:yearMonthDuration
xs:string("-P1Y1M1DT1H1M1.123S") cast as xs:dayTimeDuration
xs:string("-P1Y1M1DT1H1M1.123S") cast as xs:yearMonthDuration
xs:string("P1Y2M3DT10H30M23S") castable as xs:duration
xs:string("P1Y2M3DT10H30M23S") cast as xs:duration
xs:string("-P21M") castable as xs:yearMonthDuration
xs:string("-P21M") cast as xs:yearMonthDuration
xs:string("P24M") castable as xs:yearMonthDuration
xs:string("P24M") cast as xs:yearMonthDuration
xs:string("P3DT10H30M") castable as xs:dayTimeDuration
xs:string("P3DT10H30M") cast as xs:dayTimeDuration
xs:string("-PT100M") castable as xs:dayTimeDuration
xs:string("-PT100M") cast as xs:dayTimeDuration
xs:string("true") castable as xs:anyURI
xs:string("true") castable as xs:base64Binary
xs:string("true") castable as xs:boolean
xs:string("true") castable as xs:date
xs:string("true") castable as xs:dateTime
xs:string("true") castable as xs:dayTimeDuration
xs:string("true") castable as xs:decimal
xs:string("true") castable as xs:double
xs:string("true") castable as xs:duration
xs:string("true") castable as xs:float
xs:string("true") castable as xs:gDay
xs:string("true") castable as xs:gMonth
xs:string("true") castable as xs:gMonthDay
xs:string("true") castable as xs:gYear
xs:string("true") castable as xs:gYearMonth
xs:string("true") castable as xs:hexBinary
xs:string("true") castable as xs:integer
xs:string("true") castable as xs:string
xs:string("true") castable as xs:time
xs:string("true") castable as xs:untypedAtomic
xs:string("true") castable as xs:yearMonthDuration
xs:string("true") cast as xs:anyURI
xs:string("true") cast as xs:base64Binary
xs:string("true") cast as xs:boolean
xs:string("true") cast as xs:date
xs:string("true") cast as xs:dateTime
xs:string("true") cast as xs:dayTimeDuration
xs:string("true") cast as xs:decimal
xs:string("true") cast as xs:double
xs:string("true") cast as xs:duration
xs:string("true") cast as xs:float
xs:string("true") cast as xs:gDay
xs:string("true") cast as xs:gMonth
xs:string("true") cast as xs:gMonthDay
xs:string("true") cast as xs:gYear
xs:string("true") cast as xs:gYearMonth
xs:string("true") cast as xs:hexBinary
xs:string("true") cast as xs:integer
xs:string("true") cast as xs:string
xs:string("true") cast as xs:time
xs:string("true") cast as xs:untypedAtomic
xs:string("true") cast as xs:yearMonthDuration
xs:string(/works/@id) eq "abc"
xs:string(/works/@id) ne "abc"
xs:string(xs:anyURI('example.com/')) eq 'example.com/'
xs:string(xs:base64Binary("0w==")) eq "0w=="
xs:string(xs:base64Binary("a"))
xs:string(xs:base64Binary("aaaa===="))
xs:string(xs:base64Binary("aaaaa======="))
xs:string(xs:base64Binary("aaaa=bcd"))
xs:string(xs:base64Binary("aaaabcd"))
xs:string(xs:base64Binary("aaaabcd|"))
xs:string(xs:base64Binary("=aaabbcd"))
xs:string(xs:base64Binary("aabbcd=a"))
xs:string(xs:base64Binary("aabb=d=="))
xs:string(xs:base64Binary("abcdefghi"))
xs:string(xs:base64Binary("")) eq ""
xs:string(xs:base64Binary("F==="))
xs:string(xs:base64Binary("frfhforlksid7453")) eq "frfhforlksid7453"
xs:string(xs:base64Binary(xs:hexBinary("03"))) eq "Aw=="
xs:string(xs:base64Binary(xs:hexBinary("0f3c"))) eq "Dzw="
xs:string(xs:base64Binary(xs:hexBinary("12"))) eq "Eg=="
xs:string(xs:base64Binary(xs:hexBinary("3B"))) eq "Ow=="
xs:string(xs:base64Binary(xs:hexBinary("69A69A"))) eq "aaaa"
xs:string(xs:base64Binary(xs:hexBinary("f0"))) eq "8A=="
xs:string(xs:base64Binary(xs:hexBinary("F43D1234ce8f"))) eq "9D0SNM6P"
xs:string(xs:base64Binary(xs:hexBinary("ffaabbddcceeff0134f001d8ca9bc77899c83e6f7d"))) eq "/6q73czu/wE08AHYypvHeJnIPm99"
xs:string(xs:base64Binary(xs:hexBinary("ffff34564321deac9876"))) eq "//80VkMh3qyYdg=="
xs:string(xs:base64Binary(xs:hexBinary("ffff"))) eq "//8="
xs:string(xs:byte(3))
xs:string(xs:date("1999-12-01+00:00")) eq "1999-12-01Z"
xs:string(xs:date("1999-12-01-00:00")) eq "1999-12-01Z"
xs:string(xs:date("2002-02-15")) eq "2002-02-15"
xs:string(xs:dateTime("1999-12-01T23:59:12.432+00:00")) eq "1999-12-01T23:59:12.432Z"
xs:string(xs:dateTime("1999-12-01T23:59:12.999-00:00")) eq "1999-12-01T23:59:12.999Z"
xs:string(xs:dateTime("2002-02-15T21:01:23.000")) eq "2002-02-15T21:01:23"
xs:string(xs:dateTime("2002-02-15T21:01:23.001")) eq "2002-02-15T21:01:23.001"
xs:string(xs:dateTime("2002-02-15T21:01:23.010")) eq "2002-02-15T21:01:23.01"
xs:string(xs:dateTime("2002-02-15T21:01:23.100")) eq "2002-02-15T21:01:23.1"
xs:string(xs:dateTime("2002-02-15T21:01:23.110")) eq "2002-02-15T21:01:23.11"
xs:string(xs:dateTime("2002-02-15T21:01:23.11")) eq "2002-02-15T21:01:23.11"
xs:string(xs:dateTime("2002-02-15T21:01:23.435")) eq "2002-02-15T21:01:23.435"
xs:string(xs:dayTimeDuration("-P0010DT0010H0010M0010S")) eq "-P10DT10H10M10S"
xs:string(xs:dayTimeDuration("P0010DT0010H0010M0010S")) eq "P10DT10H10M10S"
xs:string(xs:dayTimeDuration("P0DT00H00M00.000S")) eq "PT0S"
xs:string(xs:dayTimeDuration("P3D")) eq "P3D"
xs:string(xs:dayTimeDuration("-P5DT0H0M0.000S")) eq "-P5D"
xs:string(xs:dayTimeDuration("P9876DT1M")) eq "P9876DT1M"
xs:string(xs:dayTimeDuration("-PT0S")) eq "PT0S"
xs:string(xs:dayTimeDuration("PT6000M")) eq "P4DT4H"
xs:string(xs:dayTimeDuration("-PT8H23M0S")) eq "-PT8H23M"
xs:string(xs:dayTimeDuration("PT9876H1M")) eq "P411DT12H1M"
xs:string(xs:dayTimeDuration(xs:yearMonthDuration("-P543Y456M"))) eq "PT0S"
xs:string(xs:dayTimeDuration(xs:yearMonthDuration("P543Y456M"))) eq "PT0S"
() , xs:string(" ") , xs:decimal("2.000000000000002")
xs:string(xs:decimal(3)) eq '3'
xs:string(xs:double(3)) eq '3'
xs:string(xs:double("-INF")) eq "-INF"
xs:string(xs:double("INF")) eq "INF"
xs:string(xs:duration("-P0010DT0010H0010M0010S")) eq "-P10DT10H10M10S"
xs:string(xs:duration("P0010Y0010M0010DT0010H0010M0010S")) eq "P10Y10M10DT10H10M10S"
xs:string(xs:duration("P0Y0M0DT00H00M00.000S")) eq "PT0S"
xs:string(xs:duration("P12M")) eq "P1Y"
xs:string(xs:duration("-P2000Y11M5DT0H0M0.000S")) eq "-P2000Y11M5D"
xs:string(xs:duration("P31D")) eq "P31D"
xs:string(xs:duration("P365D")) eq "P365D"
xs:string(xs:duration("-PT0S")) eq "PT0S"
xs:string(xs:duration("-PT8H23M0S")) eq "-PT8H23M"
xs:string(xs:duration(xs:yearMonthDuration("-P543Y456M"))) eq "-P581Y"
xs:string(xs:duration(xs:yearMonthDuration("P543Y456M"))) eq "P581Y"
xs:string(xs:ENTITY("foo"))
xs:string(xs:float("-INF")) eq "-INF"
xs:string(xs:float("INF")) eq "INF"
xs:string(xs:gDay("---01+00:00")) eq "---01Z"
xs:string(xs:gDay("---01-00:00")) eq "---01Z"
xs:string(xs:gDay("---01Z")) eq "---01Z"
xs:string(xs:gMonth("--01+00:00")) eq "--01Z"
xs:string(xs:gMonth("--01-00:00")) eq "--01Z"
xs:string(xs:gMonth("--01Z")) eq "--01Z"
xs:string(xs:gMonthDay("--01-01+00:00")) eq "--01-01Z"
xs:string(xs:gMonthDay("--01-01-00:00")) eq "--01-01Z"
xs:string(xs:gMonthDay("--01-01Z")) eq "--01-01Z"
xs:string(xs:gYear("1999+00:00")) eq "1999Z"
xs:string(xs:gYear("1999-00:00")) eq "1999Z"
xs:string(xs:gYear("1999Z")) eq "1999Z"
xs:string(xs:gYearMonth("1999-01+00:00")) eq "1999-01Z"
xs:string(xs:gYearMonth("1999-01-00:00")) eq "1999-01Z"
xs:string(xs:gYearMonth("1999-01Z")) eq "1999-01Z"
xs:string(xs:hexBinary("031a34123b")) eq "031A34123B"
xs:string(xs:hexBinary("03")) eq "03"
xs:string(xs:hexBinary("0a")) eq "0A"
xs:string(xs:hexBinary("0b")) eq "0B"
xs:string(xs:hexBinary("0c")) eq "0C"
xs:string(xs:hexBinary("10")) eq "10"
xs:string(xs:hexBinary("3a")) eq "3A"
xs:string(xs:hexBinary("a0")) eq "A0"
xs:string(xs:hexBinary("a4")) eq "A4"
xs:string(xs:hexBinary("aa")) eq "AA"
xs:string(xs:hexBinary("c0")) eq "C0"
xs:string(xs:hexBinary("")) eq ""
xs:string(xs:hexBinary("fA")) eq "FA"
xs:string(xs:hexBinary(xs:base64Binary("aaa a"))) eq "69A69A"
xs:string(xs:hexBinary(xs:base64Binary("Ow=="))) eq "3B"
xs:string(xs:ID("foo"))
xs:string(xs:IDREF("foo"))
xs:string(xs:int(3))
xs:string(xs:integer(3)) eq '3'
xs:string(xs:language("foo"))
xs:string(xs:long(3))
xs:string(xs:Name("foo"))
xs:string(xs:NCName("foo"))
xs:string(xs:negativeInteger(-3))
xs:string(xs:NMTOKEN("foo"))
xs:string(xs:nonNegativeInteger(3))
xs:string(xs:nonPositiveInteger(0))
xs:string(xs:normalizedString("foo"))
xs:string(xs:short(3))
xs:string(xs:string(3)) eq '3'
("xs:string", (), "xs:string") instance of xs:string+
xs:string(xs:time("21:01:23.000")) eq "21:01:23"
xs:string(xs:time("21:01:23.001")) eq "21:01:23.001"
xs:string(xs:time("21:01:23.010")) eq "21:01:23.01"
xs:string(xs:time("21:01:23.100")) eq "21:01:23.1"
xs:string(xs:time("21:01:23.110")) eq "21:01:23.11"
xs:string(xs:time("21:01:23.11")) eq "21:01:23.11"
xs:string(xs:time("21:01:23.435")) eq "21:01:23.435"
xs:string(xs:time("23:59:12.432+00:00")) eq "23:59:12.432Z"
xs:string(xs:time("23:59:12.999-00:00")) eq "23:59:12.999Z"
xs:string(xs:token("foo"))
xs:string(xs:unsignedByte(3))
xs:string(xs:unsignedInt(3))
xs:string(xs:unsignedLong(3))
xs:string(xs:unsignedShort(3))
xs:string(xs:untypedAtomic( "an arbitrary string" )) eq xs:string("an arbitrary string")
xs:string(xs:yearMonthDuration("-P0010Y0010M")) eq "-P10Y10M"
xs:string(xs:yearMonthDuration("P0010Y0010M")) eq "P10Y10M"
xs:string(xs:yearMonthDuration("-P0M")) eq "P0M"
xs:string(xs:yearMonthDuration("P0Y0M")) eq "P0M"
xs:string(xs:yearMonthDuration("P2Y323M")) eq "P28Y11M"
xs:string(xs:yearMonthDuration("P3Y0M")) eq "P3Y"
xs:string(xs:yearMonthDuration("-P543Y456M")) eq "-P581Y"
xs:string(xs:yearMonthDuration(xs:dayTimeDuration("-P31DT3H2M10.001S"))) eq "P0M"
xs:string(xs:yearMonthDuration(xs:dayTimeDuration("P31DT3H2M10.001S"))) eq "P0M"
xs:string(xs:yearMonthDuration(xs:duration("-P3Y0M31DT3H2M10.001S"))) eq "-P3Y"
xs:string(xs:yearMonthDuration(xs:duration("P3Y0M31DT3H2M10.001S"))) eq "P3Y"
xs:time("")
xs:time()
xs:time("00:00:00Z") - xs:time("00:00:00Z")
xs:time("00:00:00Z") - xs:time("08:03:35Z")
xs:time("00:00:00Z") - xs:time("23:59:59Z")
xs:time("01:01:01-03:00") ne xs:time("01:01:01+03:00")
xs:time( "03:20:00-05:00" , "03:20:00-05:00" )
xs:time("03:20:00-05:00") castable as xs:string
xs:time("03:20:00-05:00") castable as xs:time
xs:time("03:20:00-05:00") castable as xs:untypedAtomic
xs:time("03:20:00-05:00") cast as xs:anyURI
xs:time("03:20:00-05:00") cast as xs:base64Binary
xs:time("03:20:00-05:00") cast as xs:boolean
xs:time("03:20:00-05:00") cast as xs:date
xs:time("03:20:00-05:00") cast as xs:dateTime
xs:time("03:20:00-05:00") cast as xs:dayTimeDuration
xs:time("03:20:00-05:00") cast as xs:decimal
xs:time("03:20:00-05:00") cast as xs:double
xs:time("03:20:00-05:00") cast as xs:duration
xs:time("03:20:00-05:00") cast as xs:float
xs:time("03:20:00-05:00") cast as xs:gDay
xs:time("03:20:00-05:00") cast as xs:gMonth
xs:time("03:20:00-05:00") cast as xs:gMonthDay
xs:time("03:20:00-05:00") cast as xs:gYear
xs:time("03:20:00-05:00") cast as xs:gYearMonth
xs:time("03:20:00-05:00") cast as xs:hexBinary
xs:time("03:20:00-05:00") cast as xs:integer
xs:time("03:20:00-05:00") cast as xs:string ne xs:string("an arbitrary string")
xs:time("03:20:00-05:00") cast as xs:time eq xs:time("03:20:00-05:00")
xs:time("03:20:00-05:00") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:time("03:20:00-05:00") cast as xs:yearMonthDuration
xs:time(" 03:20:00-05:00 ") eq xs:time(" 03:20:00-05:00 ")
(xs:time("08:00:00+09:00"),xs:time("08:00:00+10:00"))
xs:time("08:01:23") div xs:time("08:01:23")
xs:time("08:01:23") mod xs:time("08:01:23")
xs:time("08:01:23") * xs:time("08:01:23")
xs:time("08:01:23") + xs:time("08:01:23")
xs:time("08:03:35Z") - xs:time("00:00:00Z")
xs:time("08:12:32") - xs:time("08:12:32") eq xs:dayTimeDuration("PT0S")
xs:time("08:12:32") - xs:time("18:12:32") eq xs:dayTimeDuration("-PT10H")
xs:time("11")
xs:time("11:00:00-05:00") - xs:time("21:30:00+05:30")
xs:time("+1:11:11")
xs:time("-1:11:11")
xs:time("1 :11:11")
xs:time("11: 1:11")
xs:time("11:+1:11")
xs:time("11:-1:11")
xs:time("11:11: 1")
xs:time("11:11:+1")
xs:time("11:11:-1")
xs:time("11:11:1 ")
xs:time("11:11: 10")
xs:time("11:11:111")
xs:time("11:11:11. 11")
xs:time("11:11:11.+11")
xs:time("11:11:11.-11")
xs:time("11:11:11+ 1:11")
xs:time("11:11:11++1:11")
xs:time("11:11:11+-1:11")
xs:time("11:11:11+11: 1")
xs:time("11:11:11+11:+1")
xs:time("11:11:11+11:-1")
xs:time("11:11:11b33")
xs:time("11:11:1b0")
xs:time("11:11:1e0")
xs:time("11:11:1E0")
xs:time("11:12:00Z") - xs:time("04:00:00Z")
xs:time('12:00:00-00:30')
xs:time("12:00:00+01:00") - xs:time("12:00:00") - implicit-timezone()
xs:time("12:00:00") cast as xs:string
xs:time("12:00:00") cast as xs:time
xs:time("12:00:00") - xs:time("12:00:00+01:00") + implicit-timezone()
xs:time("12:30:00Z") , xs:string(" ") , xs:decimal("2.000000000000002")
(xs:time("13:00:00Z") - xs:time("17:00:00Z"))
(xs:time("13:00:00Z") - xs:time("17:00:00Z")) eq xs:dayTimeDuration("P20DT01H02M")
(xs:time("13:00:00Z") - xs:time("17:00:00Z")) ge xs:dayTimeDuration("P17DT10H02M")
(xs:time("13:00:00Z") - xs:time("17:00:00Z")) le xs:dayTimeDuration("P10DT02H10M")
(xs:time("13:00:00Z") - xs:time("17:00:00Z")) ne xs:dayTimeDuration("P10DT01H01M")
xs:time("13:20:00-05:00") castable as xs:anyURI
xs:time("13:20:00-05:00") castable as xs:base64Binary
xs:time("13:20:00-05:00") castable as xs:boolean
xs:time("13:20:00-05:00") castable as xs:date
xs:time("13:20:00-05:00") castable as xs:dateTime
xs:time("13:20:00-05:00") castable as xs:dayTimeDuration
xs:time("13:20:00-05:00") castable as xs:decimal
xs:time("13:20:00-05:00") castable as xs:double
xs:time("13:20:00-05:00") castable as xs:duration
xs:time("13:20:00-05:00") castable as xs:float
xs:time("13:20:00-05:00") castable as xs:gDay
xs:time("13:20:00-05:00") castable as xs:gMonth
xs:time("13:20:00-05:00") castable as xs:gMonthDay
xs:time("13:20:00-05:00") castable as xs:gYear
xs:time("13:20:00-05:00") castable as xs:gYearMonth
xs:time("13:20:00-05:00") castable as xs:hexBinary
xs:time("13:20:00-05:00") castable as xs:integer
xs:time("13:20:00-05:00") castable as xs:string
xs:time("13:20:00-05:00") castable as xs:time
xs:time("13:20:00-05:00") castable as xs:untypedAtomic
xs:time("13:20:00-05:00") castable as xs:yearMonthDuration
xs:time("13:20:00-05:00") cast as xs:anyURI
xs:time("13:20:00-05:00") cast as xs:base64Binary
xs:time("13:20:00-05:00") cast as xs:boolean
xs:time("13:20:00-05:00") cast as xs:date
xs:time("13:20:00-05:00") cast as xs:dateTime
xs:time("13:20:00-05:00") cast as xs:dayTimeDuration
xs:time("13:20:00-05:00") cast as xs:decimal
xs:time("13:20:00-05:00") cast as xs:double
xs:time("13:20:00-05:00") cast as xs:duration
xs:time("13:20:00-05:00") cast as xs:float
xs:time("13:20:00-05:00") cast as xs:gDay
xs:time("13:20:00-05:00") cast as xs:gMonth
xs:time("13:20:00-05:00") cast as xs:gMonthDay
xs:time("13:20:00-05:00") cast as xs:gYear
xs:time("13:20:00-05:00") cast as xs:gYearMonth
xs:time("13:20:00-05:00") cast as xs:hexBinary
xs:time("13:20:00-05:00") cast as xs:integer
xs:time("13:20:00-05:00") cast as xs:string
xs:time("13:20:00-05:00") cast as xs:time
xs:time("13:20:00-05:00") cast as xs:untypedAtomic
xs:time("13:20:00-05:00") cast as xs:yearMonthDuration
xs:time("13:20:00Z") castable as xs:time
xs:time("13:20:00Z") cast as xs:time
xs:time("13:20:02.123") castable as xs:time
xs:time("13:20:02.123") cast as xs:time
xs:time("13:20:10.5Z") instance of xs:anyURI
xs:time("13:20:10.5Z") instance of xs:boolean
xs:time("13:20:10.5Z") instance of xs:date
xs:time("13:20:10.5Z") instance of xs:dateTime
xs:time("13:20:10.5Z") instance of xs:decimal
xs:time("13:20:10.5Z") instance of xs:double
xs:time("13:20:10.5Z") instance of xs:float
xs:time("13:20:10.5Z") instance of xs:int
xs:time("13:20:10.5Z") instance of xs:integer
xs:time("13:20:10.5Z") instance of xs:string
xs:time("13:20:10.5Z") instance of xs:time
xs:time("17:00:00-06:00") - xs:time("08:00:00+09:00")
xs:time("2002-02-15T08:12:12")
xs:time("+21:01:50")
xs:time("-21:01:50")
xs:time("21:01:60")
xs:time("21:60:00")
xs:time("22:12:04") eq xs:dateTime("1999-12-04T12:12:23")
xs:time("22:12:04") ge xs:dateTime("1999-12-04T12:12:23")
xs:time("22:12:04") gt xs:dateTime("1999-12-04T12:12:23")
xs:time("22:12:04") le xs:dateTime("1999-12-04T12:12:23")
xs:time("22:12:04") lt xs:dateTime("1999-12-04T12:12:23")
xs:time("22:12:04") ne xs:dateTime("1999-12-04T12:12:23")
(xs:time("23:00:00Z") - xs:time("17:00:00Z")) div (xs:time("13:00:00Z") - xs:time("10:00:00Z"))
xs:time("23:59:12.432+10:60")
xs:time("23:59:12.432-10:60")
xs:time("23:59:12.432+15:00")
xs:time("23:59:12.432-15:00")
xs:time("23:59:59Z") - xs:time("00:00:00Z")
xs:time("24:00:00.001")
xs:time("24:00:00.1")
xs:time("24:00:01")
xs:time("24:01:00")
xs:time("25:01:00")
xs:time(xs:dateTime("2002-11-23T22:12:23.867-00:00")) eq xs:time("22:12:23.867Z")
xs:time(xs:dateTime("2002-11-23T22:12:23.867-13:37")) eq xs:time("22:12:23.867-13:37")
xs:time(xs:untypedAtomic( "03:20:00-05:00" )) eq xs:time("03:20:00-05:00")
xs:token("")
xs:token(5)
xs:token("ncname") instance of xs:NCName
xs:token("ncname") instance of xs:normalizedString
xs:token("NCName") instance of xs:token
xs:token("test") castable as xs:token
xs:token(xs:token("test"))
xs:unsignedByte("")
xs:unsignedByte("+0")
xs:unsignedByte("-0")
xs:unsignedByte("0")
xs:unsignedByte("-00")
xs:unsignedByte("000000001")
xs:unsignedByte(0) and xs:unsignedByte(0)
xs:unsignedByte(0) and xs:unsignedByte(1)
xs:unsignedByte(0) instance of xs:unsignedByte
xs:unsignedByte("0") instance of xs:unsignedShort
xs:unsignedByte(0) or xs:unsignedByte(0)
xs:unsignedByte(0) or xs:unsignedByte(1)
xs:unsignedByte("0x0")
xs:unsignedByte("-1")
xs:unsignedByte(-1)
xs:unsignedByte(1) and xs:unsignedByte(0)
xs:unsignedByte(1) and xs:unsignedByte(1)
xs:unsignedByte(1) or xs:unsignedByte(0)
xs:unsignedByte(1) or xs:unsignedByte(1)
xs:unsignedByte("255")
xs:unsignedByte(255) and xs:unsignedByte(0)
xs:unsignedByte(255) and xs:unsignedByte(1)
xs:unsignedByte(255) and xs:unsignedByte(255)
xs:unsignedByte(255) or xs:unsignedByte(0)
xs:unsignedByte(255) or xs:unsignedByte(1)
xs:unsignedByte(255) or xs:unsignedByte(255)
xs:unsignedByte("256")
xs:unsignedByte(256)
xs:unsignedByte("3.0")
xs:unsignedByte(false())
xs:unsignedByte(true())
xs:unsignedByte(xs:double("4")) instance of xs:unsignedByte
xs:unsignedByte(xs:double("-INF"))
xs:unsignedByte(xs:double("INF"))
xs:unsignedByte(xs:double("NaN"))
xs:unsignedByte(xs:float("4")) instance of xs:unsignedByte
xs:unsignedByte(xs:float("-INF"))
xs:unsignedByte(xs:float("INF"))
xs:unsignedByte(xs:float("NaN"))
xs:unsignedInt("")
xs:unsignedInt("+0")
xs:unsignedInt("-0")
xs:unsignedInt("0")
xs:unsignedInt("-00")
xs:unsignedInt("000000001")
xs:unsignedInt(0) and xs:unsignedInt(0)
xs:unsignedInt(0) and xs:unsignedInt(1)
xs:unsignedInt(0) instance of xs:unsignedInt
xs:unsignedInt("0") instance of xs:unsignedLong
xs:unsignedInt(0) or xs:unsignedInt(0)
xs:unsignedInt(0) or xs:unsignedInt(1)
xs:unsignedInt("0x0")
xs:unsignedInt("-1")
xs:unsignedInt(-1)
xs:unsignedInt(1) and xs:unsignedInt(0)
xs:unsignedInt(1) and xs:unsignedInt(1)
xs:unsignedInt(1) or xs:unsignedInt(0)
xs:unsignedInt(1) or xs:unsignedInt(1)
xs:unsignedInt("3.0")
xs:unsignedInt("4294967295")
xs:unsignedInt(4294967295) and xs:unsignedInt(0)
xs:unsignedInt(4294967295) and xs:unsignedInt(1)
xs:unsignedInt(4294967295) and xs:unsignedInt(4294967295)
xs:unsignedInt(4294967295) or xs:unsignedInt(0)
xs:unsignedInt(4294967295) or xs:unsignedInt(1)
xs:unsignedInt(4294967295) or xs:unsignedInt(4294967295)
xs:unsignedInt("4294967296")
xs:unsignedInt(4294967296)
xs:unsignedInteger(1)
xs:unsignedInt(false())
xs:unsignedInt(true())
xs:unsignedInt(xs:double("4")) instance of xs:unsignedInt
xs:unsignedInt(xs:double("-INF"))
xs:unsignedInt(xs:double("INF"))
xs:unsignedInt(xs:double("NaN"))
xs:unsignedInt(xs:float("4")) instance of xs:unsignedInt
xs:unsignedInt(xs:float("-INF"))
xs:unsignedInt(xs:float("INF"))
xs:unsignedInt(xs:float("NaN"))
xs:unsignedLong("")
+(xs:unsignedLong("0"))
-(xs:unsignedLong("0"))
xs:unsignedLong("+0")
xs:unsignedLong("-0")
xs:unsignedLong("0")
xs:unsignedLong("-00")
xs:unsignedLong("000000001")
xs:unsignedLong(0) and xs:unsignedLong(0)
xs:unsignedLong(0) and xs:unsignedLong(1)
xs:unsignedLong("0") eq xs:unsignedLong("0")
xs:unsignedLong("0") ge xs:unsignedLong("0")
xs:unsignedLong("0") gt xs:unsignedLong("0")
xs:unsignedLong("0") instance of xs:nonNegativeInteger
xs:unsignedLong(0) instance of xs:unsignedLong
xs:unsignedLong("0") lt xs:unsignedLong("0")
xs:unsignedLong("0") ne xs:unsignedLong("0")
xs:unsignedLong(0) or xs:unsignedLong(0)
xs:unsignedLong(0) or xs:unsignedLong(1)
xs:unsignedLong("0x0")
(xs:unsignedLong("0") || xs:unsignedLong("0"))
xs:unsignedLong("0") * xs:unsignedLong("0")
xs:unsignedLong("0") + xs:unsignedLong("0")
xs:unsignedLong("0") - xs:unsignedLong("0")
xs:unsignedLong("-1")
xs:unsignedLong(-1)
xs:unsignedLong(18446744073709551616)
xs:unsignedLong(1) and xs:unsignedLong(0)
xs:unsignedLong(1) and xs:unsignedLong(1)
xs:unsignedLong(1) or xs:unsignedLong(0)
xs:unsignedLong(1) or xs:unsignedLong(1)
xs:unsignedLong("3.0")
xs:unsignedLong(9223372036854775807) and xs:unsignedLong(0)
xs:unsignedLong(9223372036854775807) and xs:unsignedLong(1)
xs:unsignedLong(9223372036854775807) or xs:unsignedLong(0)
xs:unsignedLong(9223372036854775807) or xs:unsignedLong(1)
xs:unsignedLong("-9876")
xs:unsignedLong(99999999999999999) and xs:unsignedLong(99999999999999999)
xs:unsignedLong(99999999999999999) or xs:unsignedLong(99999999999999999)
xs:unsignedLong(false())
xs:unsignedLong(true())
xs:unsignedLong(xs:double("4")) instance of xs:unsignedLong
xs:unsignedLong(xs:double("-INF"))
xs:unsignedLong(xs:double("INF"))
xs:unsignedLong(xs:double("NaN"))
xs:unsignedLong(xs:float("4")) instance of xs:unsignedLong
xs:unsignedLong(xs:float("-INF"))
xs:unsignedLong(xs:float("INF"))
xs:unsignedLong(xs:float("NaN"))
xs:unsignedShort("")
+(xs:unsignedShort("0"))
-(xs:unsignedShort("0"))
xs:unsignedShort("+0")
xs:unsignedShort("-0")
xs:unsignedShort("0")
xs:unsignedShort("-00")
xs:unsignedShort("000000001")
xs:unsignedShort(0) and xs:unsignedShort(0)
xs:unsignedShort(0) and xs:unsignedShort(1)
xs:unsignedShort("0") div xs:unsignedShort("44633")
xs:unsignedShort("0") div xs:unsignedShort("65535")
xs:unsignedShort("0") eq xs:unsignedShort("0")
xs:unsignedShort("0") eq xs:unsignedShort("44633")
xs:unsignedShort("0") eq xs:unsignedShort("65535")
xs:unsignedShort("0") ge xs:unsignedShort("0")
xs:unsignedShort("0") ge xs:unsignedShort("44633")
xs:unsignedShort("0") ge xs:unsignedShort("65535")
xs:unsignedShort("0") gt xs:unsignedShort("0")
xs:unsignedShort("0") gt xs:unsignedShort("44633")
xs:unsignedShort("0") gt xs:unsignedShort("65535")
xs:unsignedShort("0") idiv xs:unsignedShort("44633")
xs:unsignedShort("0") idiv xs:unsignedShort("65535")
xs:unsignedShort("0") instance of xs:unsignedInt
xs:unsignedShort(0) instance of xs:unsignedShort
xs:unsignedShort("0") lt xs:unsignedShort("0")
xs:unsignedShort("0") lt xs:unsignedShort("44633")
xs:unsignedShort("0") lt xs:unsignedShort("65535")
xs:unsignedShort("0") mod xs:unsignedShort("44633")
xs:unsignedShort("0") mod xs:unsignedShort("65535")
xs:unsignedShort("0") ne xs:unsignedShort("0")
xs:unsignedShort("0") ne xs:unsignedShort("44633")
xs:unsignedShort("0") ne xs:unsignedShort("65535")
xs:unsignedShort(0) or xs:unsignedShort(0)
xs:unsignedShort(0) or xs:unsignedShort(1)
xs:unsignedShort("0x0")
(xs:unsignedShort("0") || xs:unsignedShort("0"))
xs:unsignedShort("0") * xs:unsignedShort("0")
xs:unsignedShort("0") + xs:unsignedShort("0")
xs:unsignedShort("0") - xs:unsignedShort("0")
(xs:unsignedShort("0") || xs:unsignedShort("44633"))
xs:unsignedShort("0") * xs:unsignedShort("44633")
xs:unsignedShort("0") + xs:unsignedShort("44633")
(xs:unsignedShort("0") || xs:unsignedShort("65535"))
xs:unsignedShort("0") * xs:unsignedShort("65535")
xs:unsignedShort("0") + xs:unsignedShort("65535")
xs:unsignedShort("-1")
xs:unsignedShort(-1)
xs:unsignedShort(1) and xs:unsignedShort(0)
xs:unsignedShort(1) and xs:unsignedShort(1)
xs:unsignedShort(1) or xs:unsignedShort(0)
xs:unsignedShort(1) or xs:unsignedShort(1)
xs:unsignedShort("3.0")
+(xs:unsignedShort("44633"))
-(xs:unsignedShort("44633"))
xs:unsignedShort("44633") eq xs:unsignedShort("0")
xs:unsignedShort("44633") ge xs:unsignedShort("0")
xs:unsignedShort("44633") gt xs:unsignedShort("0")
xs:unsignedShort("44633") lt xs:unsignedShort("0")
xs:unsignedShort("44633") ne xs:unsignedShort("0")
(xs:unsignedShort("44633") || xs:unsignedShort("0"))
xs:unsignedShort("44633") * xs:unsignedShort("0")
xs:unsignedShort("44633") + xs:unsignedShort("0")
xs:unsignedShort("44633") - xs:unsignedShort("0")
xs:unsignedShort("44633") - xs:unsignedShort("44633")
+(xs:unsignedShort("65535"))
-(xs:unsignedShort("65535"))
xs:unsignedShort("65535")
xs:unsignedShort(65535) and xs:unsignedShort(0)
xs:unsignedShort(65535) and xs:unsignedShort(1)
xs:unsignedShort(65535) and xs:unsignedShort(65535)
xs:unsignedShort("65535") eq xs:unsignedShort("0")
xs:unsignedShort("65535") ge xs:unsignedShort("0")
xs:unsignedShort("65535") gt xs:unsignedShort("0")
xs:unsignedShort("65535") lt xs:unsignedShort("0")
xs:unsignedShort("65535") ne xs:unsignedShort("0")
xs:unsignedShort(65535) or xs:unsignedShort(0)
xs:unsignedShort(65535) or xs:unsignedShort(1)
xs:unsignedShort(65535) or xs:unsignedShort(65535)
(xs:unsignedShort("65535") || xs:unsignedShort("0"))
xs:unsignedShort("65535") * xs:unsignedShort("0")
xs:unsignedShort("65535") + xs:unsignedShort("0")
xs:unsignedShort("65535") - xs:unsignedShort("0")
xs:unsignedShort("65535") - xs:unsignedShort("65535")
xs:unsignedShort("65536")
xs:unsignedShort(65536)
xs:unsignedShort(false())
xs:unsignedShort(true())
xs:unsignedShort(xs:double("4")) instance of xs:unsignedShort
xs:unsignedShort(xs:double("-INF"))
xs:unsignedShort(xs:double("INF"))
xs:unsignedShort(xs:double("NaN"))
xs:unsignedShort(xs:float("4")) instance of xs:unsignedShort
xs:unsignedShort(xs:float("-INF"))
xs:unsignedShort(xs:float("INF"))
xs:unsignedShort(xs:float("NaN"))
xs:untypedAtomic()
xs:untypedAtomic("00000000") castable as xs:base64Binary
xs:untypedAtomic("00000000") cast as xs:base64Binary
xs:untypedAtomic("-0012-05:00") castable as xs:gYear
xs:untypedAtomic("-0012-05:00") cast as xs:gYear
xs:untypedAtomic("-0012-12-03-05:00") castable as xs:date
xs:untypedAtomic("-0012-12-03-05:00") cast as xs:date
xs:untypedAtomic("-0012-12-05:00") castable as xs:gYearMonth
xs:untypedAtomic("-0012-12-05:00") cast as xs:gYearMonth
xs:untypedAtomic("0.0") castable as xs:boolean
xs:untypedAtomic("0.0") cast as xs:boolean
xs:untypedAtomic("-0.0E0") castable as xs:decimal
xs:untypedAtomic("-0.0E0") castable as xs:double
xs:untypedAtomic("-0.0E0") castable as xs:float
xs:untypedAtomic("-0.0E0") castable as xs:integer
xs:untypedAtomic("0.0E0") castable as xs:string
xs:untypedAtomic("0.0E0") castable as xs:untypedAtomic
xs:untypedAtomic("-0.0E0") cast as xs:decimal
xs:untypedAtomic("-0.0E0") cast as xs:double
xs:untypedAtomic("-0.0E0") cast as xs:float
xs:untypedAtomic("-0.0E0") cast as xs:integer
xs:untypedAtomic("0.0E0") cast as xs:string
xs:untypedAtomic("0.0E0") cast as xs:untypedAtomic
xs:untypedAtomic("010010101") castable as xs:hexBinary
xs:untypedAtomic("010010101") cast as xs:hexBinary
xs:untypedAtomic("---03-05:00") castable as xs:gDay
xs:untypedAtomic("---03-05:00") cast as xs:gDay
xs:untypedAtomic("--05-31+14:00") castable as xs:gMonthDay
xs:untypedAtomic("--05-31+14:00") cast as xs:gMonthDay
xs:untypedAtomic("--05-31") castable as xs:gMonthDay
xs:untypedAtomic("--05-31") cast as xs:gMonthDay
xs:untypedAtomic("--05-31Z") castable as xs:gMonthDay
xs:untypedAtomic("--05-31Z") cast as xs:gMonthDay
xs:untypedAtomic("--05") castable as xs:gMonth
xs:untypedAtomic("--05") cast as xs:gMonth
xs:untypedAtomic("--05Z") castable as xs:gMonth
xs:untypedAtomic("--05Z") cast as xs:gMonth
xs:untypedAtomic("0") castable as xs:boolean
xs:untypedAtomic("0") cast as xs:boolean
xs:untypedAtomic("0fb7") castable as xs:hexBinary
xs:untypedAtomic("0fb7") cast as xs:hexBinary
xs:untypedAtomic("0") = xs:dayTimeDuration("PT0S")
xs:untypedAtomic("-10000000") castable as xs:double
xs:untypedAtomic("-10000000") castable as xs:float
xs:untypedAtomic("1") = 1
xs:untypedAtomic("-1.1234") castable as xs:integer
xs:untypedAtomic("-1.1234") cast as xs:integer
xs:untypedAtomic("--12-05:00") castable as xs:gMonth
xs:untypedAtomic("--12-05:00") cast as xs:gMonth
xs:untypedAtomic("13:20:00-05:00") castable as xs:time
xs:untypedAtomic("13:20:00-05:00") cast as xs:time
xs:untypedAtomic("13:20:00Z") castable as xs:time
xs:untypedAtomic("13:20:00Z") cast as xs:time
xs:untypedAtomic("13:20:02.123") castable as xs:time
xs:untypedAtomic("13:20:02.123") cast as xs:time
xs:untypedAtomic("1999-05-31") castable as xs:date
xs:untypedAtomic("1999-05-31") cast as xs:date
xs:untypedAtomic("-1999-05-31T13:20:00+14:00") castable as xs:dateTime
xs:untypedAtomic("-1999-05-31T13:20:00+14:00") cast as xs:dateTime
xs:untypedAtomic("1999-05-31T13:20:00") castable as xs:dateTime
xs:untypedAtomic("1999-05-31T13:20:00") cast as xs:dateTime
xs:untypedAtomic("1999-05-31Z") castable as xs:date
xs:untypedAtomic("1999-05-31Z") cast as xs:date
xs:untypedAtomic("1999-05") castable as xs:gYearMonth
xs:untypedAtomic("1999-05") cast as xs:gYearMonth
xs:untypedAtomic("1999-05Z") castable as xs:gYearMonth
xs:untypedAtomic("1999-05Z") cast as xs:gYearMonth
xs:untypedAtomic("1999") castable as xs:gYear
xs:untypedAtomic("1999") cast as xs:gYear
xs:untypedAtomic("1999Z") castable as xs:gYear
xs:untypedAtomic("1999Z") cast as xs:gYear
xs:untypedAtomic("1e-5") castable as xs:decimal
xs:untypedAtomic("1e-5") castable as xs:double
xs:untypedAtomic("1e-5") castable as xs:float
xs:untypedAtomic("1e-5") castable as xs:integer
xs:untypedAtomic("1e-5") cast as xs:decimal
xs:untypedAtomic("1e-5") cast as xs:double
xs:untypedAtomic("1e-5") cast as xs:float
xs:untypedAtomic("1e-5") cast as xs:integer
(xs:untypedAtomic("1"), xs:anyURI("example.com")) = (xs:untypedAtomic("2.0"), 3.0)
(xs:untypedAtomic("1"), xs:untypedAtomic("2")) = (xs:untypedAtomic("2.0"), 2.0)
xs:untypedAtomic("2000-01-16T00:00:00Z") castable as xs:dateTime
xs:untypedAtomic("2000-01-16T00:00:00Z") cast as xs:dateTime
xs:untypedAtomic("2") != 1
(xs:untypedAtomic("3") - 1.1) instance of xs:double
xs:untypedAtomic("---31") castable as xs:gDay
xs:untypedAtomic("---31") cast as xs:gDay
xs:untypedAtomic("---31Z") castable as xs:gDay
xs:untypedAtomic("---31Z") cast as xs:gDay
xs:untypedAtomic("3") - "3"
(xs:untypedAtomic("3") + 3.0) eq 6
(xs:untypedAtomic("3") - 3) eq 0
(xs:untypedAtomic("3"), 3) eq 3
xs:untypedAtomic("3") + 3 eq 6
(xs:untypedAtomic(3) * 3) eq 9
(xs:untypedAtomic("3") + 3) instance of xs:double
(xs:untypedAtomic("3") div xs:double(3)) eq 1
(xs:untypedAtomic("3") - xs:untypedAtomic("3")) eq 0
(xs:untypedAtomic("3") - xs:untypedAtomic("3")) instance of xs:double
xs:untypedAtomic("5.5432") castable as xs:decimal
xs:untypedAtomic("5.5432") cast as xs:decimal
(xs:untypedAtomic("5") mod xs:double(3)) eq 2
xs:untypedAtomic("6") = remove(("a string", 6), 1)
(xs:untypedAtomic("9") idiv xs:float(5)) eq 1
xs:untypedAtomic('abc') and xs:untypedAtomic("")
xs:untypedAtomic('abc') and xs:untypedAtomic("0")
xs:untypedAtomic('abc') or xs:untypedAtomic("")
xs:untypedAtomic('abc') or xs:untypedAtomic("0")
xs:untypedAtomic( "an arbitrary string(untypedAtomic source)" , "an arbitrary string(untypedAtomic source)" )
xs:untypedAtomic("an arbitrary string(untypedAtomic source)") castable as xs:string
xs:untypedAtomic("an arbitrary string(untypedAtomic source)") castable as xs:untypedAtomic
xs:untypedAtomic("an arbitrary string(untypedAtomic source)") cast as xs:string ne xs:string("an arbitrary string")
xs:untypedAtomic("an arbitrary string(untypedAtomic source)") cast as xs:untypedAtomic eq xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:untypedAtomic(" an arbitrary string(untypedAtomic source) ") eq xs:untypedAtomic(" an arbitrary string(untypedAtomic source) ")
xs:untypedAtomic('') and xs:untypedAtomic("")
xs:untypedAtomic('') and xs:untypedAtomic("0")
xs:untypedAtomic("a string") and xs:untypedAtomic("a string")
xs:untypedAtomic("a string") = "a string"
xs:untypedAtomic("a string") != "a stringDIFF"
xs:untypedAtomic("a string") eq "a string"
xs:untypedAtomic("a string") or 0
xs:untypedAtomic("a string") = xs:untypedAtomic("a stringDIFF")
xs:untypedAtomic("D74D35D35D35") castable as xs:base64Binary
xs:untypedAtomic("D74D35D35D35") castable as xs:hexBinary
xs:untypedAtomic("D74D35D35D35") cast as xs:base64Binary
xs:untypedAtomic("D74D35D35D35") cast as xs:hexBinary
xs:untypedAtomic("") eq xs:untypedAtomic("")
xs:untypedAtomic("example.com/") cast as xs:anyURI eq xs:anyURI('example.com/')
xs:untypedAtomic("example.com/") eq xs:anyURI("example.com/")
xs:untypedAtomic("example.com/") ne xs:anyURI("example.com/No")
xs:untypedAtomic("falseERR") != false()
xs:untypedAtomic("falseERR") = false()
xs:untypedAtomic("false") <= false()
xs:untypedAtomic("false") = false()
xs:untypedAtomic("false") >= false()
xs:untypedAtomic("false") < true()
xs:untypedAtomic("http://www.example.com/~b%C3%A9b%C3%A9") castable as xs:anyURI
xs:untypedAtomic("http://www.example.com/~b%C3%A9b%C3%A9") cast as xs:anyURI
xs:untypedAtomic("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:anyURI
xs:untypedAtomic("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:anyURI
xs:untypedAtomic("INF") castable as xs:string
xs:untypedAtomic("INF") castable as xs:untypedAtomic
xs:untypedAtomic("INF") cast as xs:string
xs:untypedAtomic("INF") cast as xs:untypedAtomic
xs:untypedAtomic("NaN") castable as xs:decimal
xs:untypedAtomic("NaN") castable as xs:double
xs:untypedAtomic("NaN") castable as xs:float
xs:untypedAtomic("NaN") castable as xs:integer
xs:untypedAtomic("NaN") cast as xs:decimal
xs:untypedAtomic("NaN") cast as xs:double
xs:untypedAtomic("NaN") cast as xs:float
xs:untypedAtomic("NaN") cast as xs:integer
(xs:untypedAtomic("nine") idiv xs:float(5)) eq 1
xs:untypedAtomic('') or xs:untypedAtomic("")
xs:untypedAtomic('') or xs:untypedAtomic("0")
xs:untypedAtomic("P1999Y10M") = xs:yearMonthDuration("P1999Y10M")
xs:untypedAtomic("-P1Y1M1DT1H1M1.123S") castable as xs:dayTimeDuration
xs:untypedAtomic("-P1Y1M1DT1H1M1.123S") castable as xs:duration
xs:untypedAtomic("-P1Y1M1DT1H1M1.123S") castable as xs:yearMonthDuration
xs:untypedAtomic("-P1Y1M1DT1H1M1.123S") cast as xs:dayTimeDuration
xs:untypedAtomic("-P1Y1M1DT1H1M1.123S") cast as xs:yearMonthDuration
xs:untypedAtomic("P1Y2M3DT10H30M23S") castable as xs:duration
xs:untypedAtomic("P1Y2M3DT10H30M23S") cast as xs:duration
xs:untypedAtomic("-P21M") castable as xs:yearMonthDuration
xs:untypedAtomic("-P21M") cast as xs:yearMonthDuration
xs:untypedAtomic("P24M") castable as xs:yearMonthDuration
xs:untypedAtomic("P24M") cast as xs:yearMonthDuration
xs:untypedAtomic("P3DT10H30M") castable as xs:dayTimeDuration
xs:untypedAtomic("P3DT10H30M") cast as xs:dayTimeDuration
xs:untypedAtomic("-PT100M") castable as xs:dayTimeDuration
xs:untypedAtomic("-PT100M") cast as xs:dayTimeDuration
xs:untypedAtomic("three") != 3
xs:untypedAtomic("three") + 3
xs:untypedAtomic("three") = 3
xs:untypedAtomic("true") castable as xs:anyURI
xs:untypedAtomic("true") castable as xs:base64Binary
xs:untypedAtomic("true") castable as xs:boolean
xs:untypedAtomic("true") castable as xs:date
xs:untypedAtomic("true") castable as xs:dateTime
xs:untypedAtomic("true") castable as xs:dayTimeDuration
xs:untypedAtomic("true") castable as xs:decimal
xs:untypedAtomic("true") castable as xs:double
xs:untypedAtomic("true") castable as xs:duration
xs:untypedAtomic("true") castable as xs:float
xs:untypedAtomic("true") castable as xs:gDay
xs:untypedAtomic("true") castable as xs:gMonth
xs:untypedAtomic("true") castable as xs:gMonthDay
xs:untypedAtomic("true") castable as xs:gYear
xs:untypedAtomic("true") castable as xs:gYearMonth
xs:untypedAtomic("true") castable as xs:hexBinary
xs:untypedAtomic("true") castable as xs:integer
xs:untypedAtomic("true") castable as xs:string
xs:untypedAtomic("true") castable as xs:time
xs:untypedAtomic("true") castable as xs:untypedAtomic
xs:untypedAtomic("true") castable as xs:yearMonthDuration
xs:untypedAtomic("true") cast as xs:anyURI
xs:untypedAtomic("true") cast as xs:base64Binary
xs:untypedAtomic("true") cast as xs:boolean
xs:untypedAtomic("true") cast as xs:date
xs:untypedAtomic("true") cast as xs:dateTime
xs:untypedAtomic("true") cast as xs:dayTimeDuration
xs:untypedAtomic("true") cast as xs:decimal
xs:untypedAtomic("true") cast as xs:double
xs:untypedAtomic("true") cast as xs:duration
xs:untypedAtomic("true") cast as xs:float
xs:untypedAtomic("true") cast as xs:gDay
xs:untypedAtomic("true") cast as xs:gMonth
xs:untypedAtomic("true") cast as xs:gMonthDay
xs:untypedAtomic("true") cast as xs:gYear
xs:untypedAtomic("true") cast as xs:gYearMonth
xs:untypedAtomic("true") cast as xs:hexBinary
xs:untypedAtomic("true") cast as xs:integer
xs:untypedAtomic("true") cast as xs:string
xs:untypedAtomic("true") cast as xs:time
xs:untypedAtomic("true") cast as xs:untypedAtomic
xs:untypedAtomic("true") cast as xs:yearMonthDuration
xs:untypedAtomic("true") != false()
xs:untypedAtomic("true") > false()
xs:untypedAtomic(xs:anyURI('example.com/')) eq 'example.com/'
xs:untypedAtomic(xs:byte(3))
xs:untypedAtomic(xs:decimal(3)) eq '3'
xs:untypedAtomic(xs:double(3)) eq '3'
xs:untypedAtomic(xs:ENTITY("foo"))
xs:untypedAtomic(xs:ID("foo"))
xs:untypedAtomic(xs:IDREF("foo"))
xs:untypedAtomic(xs:int(3))
xs:untypedAtomic(xs:integer(3)) eq '3'
xs:untypedAtomic(xs:language("foo"))
xs:untypedAtomic(xs:long(3))
xs:untypedAtomic(xs:Name("foo"))
xs:untypedAtomic(xs:NCName("foo"))
xs:untypedAtomic(xs:negativeInteger(-3))
xs:untypedAtomic(xs:NMTOKEN("foo"))
xs:untypedAtomic(xs:nonNegativeInteger(3))
xs:untypedAtomic(xs:nonPositiveInteger(0))
xs:untypedAtomic(xs:normalizedString("foo"))
xs:untypedAtomic(xs:short(3))
xs:untypedAtomic(xs:string(3)) eq '3'
xs:untypedAtomic(xs:token("foo"))
xs:untypedAtomic(xs:unsignedByte(3))
xs:untypedAtomic(xs:unsignedInt(3))
xs:untypedAtomic(xs:unsignedLong(3))
xs:untypedAtomic(xs:unsignedShort(3))
xs:untypedAtomic(xs:untypedAtomic( "an arbitrary string(untypedAtomic source)" )) eq xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:yearMonthDuration("")
xs:yearMonthDuration()
xs:yearMonthDuration("20Y15M")
xs:yearMonthDuration("-P")
xs:yearMonthDuration("P")
(xs:yearMonthDuration("P01Y01M") div xs:yearMonthDuration("P02Y02M")) and (xs:yearMonthDuration("P02Y03M") div xs:yearMonthDuration("P04Y04M"))
(xs:yearMonthDuration("P05Y02M") div xs:yearMonthDuration("P03Y04M")) or (xs:yearMonthDuration("P05Y03M") div xs:yearMonthDuration("P01Y03M"))
xs:yearMonthDuration("P0M") eq xs:dayTimeDuration("PT0S")
xs:yearMonthDuration("P0M") eq xs:duration("PT0S")
xs:yearMonthDuration("P0M") eq xs:yearMonthDuration("P0M")
xs:yearMonthDuration("P0M") + xs:yearMonthDuration("P3Y3M") eq xs:yearMonthDuration("P3Y3M")
xs:yearMonthDuration("P0M") - xs:yearMonthDuration("P3Y3M") eq xs:yearMonthDuration("-P3Y3M")
xs:yearMonthDuration("P0Y0M") div xs:double("0.1")
xs:yearMonthDuration("P0Y0M") div xs:double("-1.7976931348623157E308")
xs:yearMonthDuration("P0Y0M") div xs:double("1.7976931348623157E308")
xs:yearMonthDuration("P0Y0M") div xs:yearMonthDuration("P0Y1M")
xs:yearMonthDuration("P0Y0M") div xs:yearMonthDuration("P1000Y6M")
xs:yearMonthDuration("P0Y0M") div xs:yearMonthDuration("P2030Y12M")
xs:yearMonthDuration("P0Y0M") eq xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P0Y0M") eq xs:yearMonthDuration("P1000Y6M")
xs:yearMonthDuration("P0Y0M") eq xs:yearMonthDuration("P2030Y12M")
xs:yearMonthDuration("P0Y0M") ge xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P0Y0M") ge xs:yearMonthDuration("P1000Y6M")
xs:yearMonthDuration("P0Y0M") ge xs:yearMonthDuration("P2030Y12M")
xs:yearMonthDuration("P0Y0M") gt xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P0Y0M") gt xs:yearMonthDuration("P1000Y6M")
xs:yearMonthDuration("P0Y0M") gt xs:yearMonthDuration("P2030Y12M")
xs:yearMonthDuration("P0Y0M") le xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P0Y0M") le xs:yearMonthDuration("P1000Y6M")
xs:yearMonthDuration("P0Y0M") le xs:yearMonthDuration("P2030Y12M")
xs:yearMonthDuration("P0Y0M") lt xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P0Y0M") lt xs:yearMonthDuration("P1000Y6M")
xs:yearMonthDuration("P0Y0M") lt xs:yearMonthDuration("P2030Y12M")
xs:yearMonthDuration("P0Y0M") ne xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P0Y0M") ne xs:yearMonthDuration("P1000Y6M")
xs:yearMonthDuration("P0Y0M") ne xs:yearMonthDuration("P2030Y12M")
xs:yearMonthDuration("P0Y0M") * xs:double("0")
xs:yearMonthDuration("P0Y0M") * xs:double("-1.7976931348623157E308")
xs:yearMonthDuration("P0Y0M") * xs:double("1.7976931348623157E308")
xs:yearMonthDuration("P0Y0M") + xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P0Y0M") - xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P0Y0M") + xs:yearMonthDuration("P1000Y6M")
xs:yearMonthDuration("P0Y0M") - xs:yearMonthDuration("P1000Y6M")
xs:yearMonthDuration("P0Y0M") + xs:yearMonthDuration("P2030Y12M")
xs:yearMonthDuration("P0Y0M") - xs:yearMonthDuration("P2030Y12M")
xs:yearMonthDuration('P0Y') eq xs:dayTimeDuration('P0D')
xs:yearMonthDuration("P1000Y6M") div xs:double("-1.7976931348623157E308")
xs:yearMonthDuration("P1000Y6M") div xs:yearMonthDuration("P0Y1M")
xs:yearMonthDuration("P1000Y6M") eq xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P1000Y6M") ge xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P1000Y6M") gt xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P1000Y6M") le xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P1000Y6M") lt xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P1000Y6M") ne xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P1000Y6M") * xs:double("-0")
xs:yearMonthDuration("P1000Y6M") + xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P1000Y6M") - xs:yearMonthDuration("P0Y0M")
(xs:yearMonthDuration("P10Y01M") * -2.0)
(xs:yearMonthDuration("P10Y01M") * 2.0) le xs:yearMonthDuration("P17Y02M")
(xs:yearMonthDuration("P10Y01M") div -2.0)
(xs:yearMonthDuration("P10Y01M") div 2.0) le xs:yearMonthDuration("P17Y02M")
(xs:yearMonthDuration("P10Y01M") div xs:yearMonthDuration("-P10Y01M"))
(xs:yearMonthDuration("P10Y01M") div xs:yearMonthDuration("P17Y02M")) le xs:decimal(2.0)
(xs:yearMonthDuration("P10Y01M") ge xs:yearMonthDuration("P09Y05M")) or (fn:true())
(xs:yearMonthDuration("P10Y01M") ge xs:yearMonthDuration("P09Y06M")) or (xs:yearMonthDuration("P15Y01M") ge xs:yearMonthDuration("P02Y04M"))
(xs:yearMonthDuration("P10Y01M") le xs:yearMonthDuration("P09Y05M")) or (fn:true())
(xs:yearMonthDuration("P10Y01M") le xs:yearMonthDuration("P09Y06M")) or (xs:yearMonthDuration("P15Y01M") le xs:yearMonthDuration("P02Y04M"))
(xs:yearMonthDuration("P10Y01M") + xs:yearMonthDuration("-P11Y02M"))
(xs:yearMonthDuration("P10Y01M") - xs:yearMonthDuration("P11Y02M"))
(xs:yearMonthDuration("P10Y01M") + xs:yearMonthDuration("P17Y02M")) le xs:yearMonthDuration("P17Y02M")
(xs:yearMonthDuration("P10Y01M") - xs:yearMonthDuration("P17Y02M")) le xs:yearMonthDuration("P17Y02M")
(xs:yearMonthDuration("P10Y02M") gt xs:yearMonthDuration("P01Y10M")) or (fn:true())
(xs:yearMonthDuration("P10Y02M") lt xs:yearMonthDuration("P01Y10M")) or (fn:true())
(xs:yearMonthDuration("P10Y05M") ge xs:yearMonthDuration("P20Y10M")) or (fn:false())
(xs:yearMonthDuration("P10Y05M") le xs:yearMonthDuration("P20Y10M")) or (fn:false())
(xs:yearMonthDuration("P10Y08M") gt xs:yearMonthDuration("P10Y07M")) or (xs:yearMonthDuration("P10Y09M") gt xs:yearMonthDuration("P10Y09M"))
(xs:yearMonthDuration("P10Y08M") lt xs:yearMonthDuration("P10Y07M")) or (xs:yearMonthDuration("P10Y09M") lt xs:yearMonthDuration("P10Y09M"))
(xs:yearMonthDuration("P10Y09M") ge xs:yearMonthDuration("P10Y01M")) and (xs:yearMonthDuration("P02Y04M") ge xs:yearMonthDuration("P09Y07M"))
(xs:yearMonthDuration("P10Y09M") gt xs:yearMonthDuration("P09Y10M")) and (xs:yearMonthDuration("P10Y01M") gt xs:yearMonthDuration("P08Y06M"))
(xs:yearMonthDuration("P10Y09M") le xs:yearMonthDuration("P10Y01M")) and (xs:yearMonthDuration("P02Y04M") le xs:yearMonthDuration("P09Y07M"))
(xs:yearMonthDuration("P10Y09M") lt xs:yearMonthDuration("P09Y10M")) and (xs:yearMonthDuration("P10Y01M") lt xs:yearMonthDuration("P08Y06M"))
(xs:yearMonthDuration("P10Y11M") div xs:yearMonthDuration("P05Y07M")) and (fn:true())
xs:yearMonthDuration("P10Y11M") div xs:yearMonthDuration("P12Y07M") and fn:false()
(xs:yearMonthDuration("P13Y09M") div 2.0) ge xs:yearMonthDuration("P18Y02M")
(xs:yearMonthDuration("P13Y09M") div xs:yearMonthDuration("P18Y02M")) ge xs:decimal(2.0)
xs:yearMonthDuration("P13Y09M") * fn:number(())
(xs:yearMonthDuration("P13Y09M") + xs:yearMonthDuration("P18Y02M")) ge xs:yearMonthDuration("P18Y02M")
(xs:yearMonthDuration("P13Y09M") - xs:yearMonthDuration("P18Y02M")) ge xs:yearMonthDuration("P18Y02M")
xs:yearMonthDuration("P1999Y01M") ne xs:yearMonthDuration("P1999Y10M")
xs:yearMonthDuration("P1999Y10M") eq xs:yearMonthDuration("P1999Y10M")
xs:yearMonthDuration("P1999Y10M") ge xs:dayTimeDuration("P3DT08H34M12.143S")
xs:yearMonthDuration("P1999Y10M") ge xs:duration("P3DT08H34M12.143S")
xs:yearMonthDuration("P1999Y10M") ge xs:yearMonthDuration("P1999Y10M")
xs:yearMonthDuration("P1999Y10M") gt xs:dayTimeDuration("P3DT08H34M12.143S")
xs:yearMonthDuration("P1999Y10M") gt xs:duration("P3DT08H34M12.143S")
xs:yearMonthDuration("P1999Y10M") gt xs:yearMonthDuration("P1999Y9M")
xs:yearMonthDuration("P1999Y10M") le xs:dayTimeDuration("P3DT08H34M12.143S")
xs:yearMonthDuration("P1999Y10M") le xs:duration("P3DT08H34M12.143S")
xs:yearMonthDuration("P1999Y10M") le xs:yearMonthDuration("P1999Y10M")
xs:yearMonthDuration("P1999Y10M") lt xs:dayTimeDuration("P3DT08H34M12.143S")
xs:yearMonthDuration("P1999Y10M") lt xs:duration("P3DT08H34M12.143S")
xs:yearMonthDuration("P1999Y11M") ge xs:yearMonthDuration("P1999Y10M")
xs:yearMonthDuration("P1999Y9M") le xs:yearMonthDuration("P1999Y10M")
xs:yearMonthDuration("P1999Y9M") lt xs:yearMonthDuration("P1999Y10M")
xs:yearMonthDuration("P1999Y") = xs:untypedAtomic("1999")
xs:yearMonthDuration("P1M") ne xs:dayTimeDuration("P31D")
xs:yearMonthDuration("P1M") ne xs:duration("P31D")
xs:yearMonthDuration("P1Y12M") castable as xs:dayTimeDuration
xs:yearMonthDuration("P1Y12M") castable as xs:duration
xs:yearMonthDuration("P1Y12M") castable as xs:string
xs:yearMonthDuration("P1Y12M") castable as xs:untypedAtomic
xs:yearMonthDuration("P1Y12M") castable as xs:yearMonthDuration
xs:yearMonthDuration("P1Y12M") cast as xs:anyURI
xs:yearMonthDuration("P1Y12M") cast as xs:base64Binary
xs:yearMonthDuration("P1Y12M") cast as xs:boolean
xs:yearMonthDuration("P1Y12M") cast as xs:date
xs:yearMonthDuration("P1Y12M") cast as xs:dateTime
xs:yearMonthDuration("P1Y12M") cast as xs:dayTimeDuration ne xs:dayTimeDuration("P3DT2H")
xs:yearMonthDuration("P1Y12M") cast as xs:decimal
xs:yearMonthDuration("P1Y12M") cast as xs:double
xs:yearMonthDuration("P1Y12M") cast as xs:duration ne xs:duration("P1Y2M3DT10H30M")
xs:yearMonthDuration("P1Y12M") cast as xs:float
xs:yearMonthDuration("P1Y12M") cast as xs:gDay
xs:yearMonthDuration("P1Y12M") cast as xs:gMonth
xs:yearMonthDuration("P1Y12M") cast as xs:gMonthDay
xs:yearMonthDuration("P1Y12M") cast as xs:gYear
xs:yearMonthDuration("P1Y12M") cast as xs:gYearMonth
xs:yearMonthDuration("P1Y12M") cast as xs:hexBinary
xs:yearMonthDuration("P1Y12M") cast as xs:integer
xs:yearMonthDuration("P1Y12M") cast as xs:string ne xs:string("an arbitrary string")
xs:yearMonthDuration("P1Y12M") cast as xs:time
xs:yearMonthDuration("P1Y12M") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:yearMonthDuration("P1Y12M") cast as xs:yearMonthDuration eq xs:yearMonthDuration("P1Y12M")
xs:yearMonthDuration("P1Y12M") eq xs:duration("P1Y12M0D")
xs:yearMonthDuration(" P1Y12M ") eq xs:yearMonthDuration(" P1Y12M ")
xs:yearMonthDuration( "P1Y12M" , "P1Y12M" )
xs:yearMonthDuration("P1Y24MT")
xs:yearMonthDuration("P1Y2M") castable as xs:anyURI
xs:yearMonthDuration("P1Y2M") castable as xs:base64Binary
xs:yearMonthDuration("P1Y2M") castable as xs:boolean
xs:yearMonthDuration("P1Y2M") castable as xs:date
xs:yearMonthDuration("P1Y2M") castable as xs:dateTime
xs:yearMonthDuration("P1Y2M") castable as xs:dayTimeDuration
xs:yearMonthDuration("P1Y2M") castable as xs:decimal
xs:yearMonthDuration("P1Y2M") castable as xs:double
xs:yearMonthDuration("P1Y2M") castable as xs:duration
xs:yearMonthDuration("P1Y2M") castable as xs:float
xs:yearMonthDuration("P1Y2M") castable as xs:gDay
xs:yearMonthDuration("P1Y2M") castable as xs:gMonth
xs:yearMonthDuration("P1Y2M") castable as xs:gMonthDay
xs:yearMonthDuration("P1Y2M") castable as xs:gYear
xs:yearMonthDuration("P1Y2M") castable as xs:gYearMonth
xs:yearMonthDuration("P1Y2M") castable as xs:hexBinary
xs:yearMonthDuration("P1Y2M") castable as xs:integer
xs:yearMonthDuration("P1Y2M") castable as xs:string
xs:yearMonthDuration("P1Y2M") castable as xs:time
xs:yearMonthDuration("P1Y2M") castable as xs:untypedAtomic
xs:yearMonthDuration("P1Y2M") castable as xs:yearMonthDuration
xs:yearMonthDuration("P1Y2M") cast as xs:anyURI
xs:yearMonthDuration("P1Y2M") cast as xs:base64Binary
xs:yearMonthDuration("P1Y2M") cast as xs:boolean
xs:yearMonthDuration("P1Y2M") cast as xs:date
xs:yearMonthDuration("P1Y2M") cast as xs:dateTime
xs:yearMonthDuration("P1Y2M") cast as xs:dayTimeDuration
xs:yearMonthDuration("P1Y2M") cast as xs:decimal
xs:yearMonthDuration("P1Y2M") cast as xs:double
xs:yearMonthDuration("P1Y2M") cast as xs:duration
xs:yearMonthDuration("P1Y2M") cast as xs:float
xs:yearMonthDuration("P1Y2M") cast as xs:gDay
xs:yearMonthDuration("P1Y2M") cast as xs:gMonth
xs:yearMonthDuration("P1Y2M") cast as xs:gMonthDay
xs:yearMonthDuration("P1Y2M") cast as xs:gYear
xs:yearMonthDuration("P1Y2M") cast as xs:gYearMonth
xs:yearMonthDuration("P1Y2M") cast as xs:hexBinary
xs:yearMonthDuration("P1Y2M") cast as xs:integer
xs:yearMonthDuration("P1Y2M") cast as xs:string
xs:yearMonthDuration("P1Y2M") cast as xs:time
xs:yearMonthDuration("P1Y2M") cast as xs:untypedAtomic
xs:yearMonthDuration("P1Y2M") cast as xs:yearMonthDuration
xs:yearMonthDuration('P1Y') eq xs:dayTimeDuration('P365D')
xs:yearMonthDuration("P2030Y12M") div xs:double("-1.7976931348623157E308")
xs:yearMonthDuration("P2030Y12M") div xs:yearMonthDuration("P0Y1M")
xs:yearMonthDuration("P2030Y12M") eq xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P2030Y12M") ge xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P2030Y12M") gt xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P2030Y12M") le xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P2030Y12M") lt xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P2030Y12M") ne xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P2030Y12M") * xs:double("-0")
xs:yearMonthDuration("P2030Y12M") + xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P2030Y12M") - xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P20Y10M") div xs:yearMonthDuration("P19Y10M") or fn:false()
(xs:yearMonthDuration("P20Y11M") * 2.0) div (xs:yearMonthDuration("P20Y11M") * 2.0)
(xs:yearMonthDuration("P20Y11M") div 2.0) div (xs:yearMonthDuration("P20Y11M") div 2.0)
xs:yearMonthDuration("+P20Y15M")
xs:yearMonthDuration("P20Y15M+08:00")
xs:yearMonthDuration("-P21M") castable as xs:yearMonthDuration
xs:yearMonthDuration("-P21M") cast as xs:yearMonthDuration
(xs:yearMonthDuration("P21Y12M") * 2.0) ne xs:yearMonthDuration("P08Y05M")
(xs:yearMonthDuration("P21Y12M") div 2.0) ne xs:yearMonthDuration("P08Y05M")
(xs:yearMonthDuration("P21Y12M") div xs:yearMonthDuration("P08Y05M")) ne xs:decimal(2.0)
(xs:yearMonthDuration("P21Y12M") + xs:yearMonthDuration("P08Y05M")) ne xs:yearMonthDuration("P08Y05M")
(xs:yearMonthDuration("P21Y12M") - xs:yearMonthDuration("P08Y05M")) ne xs:yearMonthDuration("P08Y05M")
(xs:yearMonthDuration("P23Y11M") * 2.0) eq xs:yearMonthDuration("P23Y11M")
(xs:yearMonthDuration("P23Y11M") div 2.0) eq xs:yearMonthDuration("P23Y11M")
(xs:yearMonthDuration("P23Y11M") div xs:yearMonthDuration("P23Y11M")) eq xs:decimal(2.0)
(xs:yearMonthDuration("P23Y11M") + xs:yearMonthDuration("P23Y11M")) eq xs:yearMonthDuration("P23Y11M")
(xs:yearMonthDuration("P23Y11M") - xs:yearMonthDuration("P23Y11M")) eq xs:yearMonthDuration("P23Y11M")
xs:yearMonthDuration("P2Y11M") * 2.3
(xs:yearMonthDuration("P2Y11M") div 1.5)
(xs:yearMonthDuration("P2Y11M") - xs:yearMonthDuration("P3Y3M"))
xs:yearMonthDuration("P2Y11M") + xs:yearMonthDuration("P3Y3M")
xs:yearMonthDuration("P2Y") * xs:double('NaN')
xs:yearMonthDuration("-P3")
(xs:yearMonthDuration("P30Y10M") gt xs:yearMonthDuration("P01Y02M")) or (fn:false())
(xs:yearMonthDuration("P30Y10M") lt xs:yearMonthDuration("P01Y02M")) or (fn:false())
xs:yearMonthDuration("P32Y43M") - xs:yearMonthDuration("P12Y13M") eq xs:yearMonthDuration("P22Y6M")
xs:yearMonthDuration("P32Y43M") + xs:yearMonthDuration("P12Y13M") eq xs:yearMonthDuration("P48Y8M")
xs:yearMonthDuration("P3Y36M") * 0 eq xs:yearMonthDuration("P0M")
xs:yearMonthDuration("P3Y36M") * 3 eq xs:yearMonthDuration("P18Y")
xs:yearMonthDuration("P3Y36M") div 0
xs:yearMonthDuration("P3Y36M") div 3 eq xs:yearMonthDuration("P2Y")
xs:yearMonthDuration("P3Y36M") div xs:double("-0")
xs:yearMonthDuration("P3Y36M") div xs:double("-INF") eq xs:yearMonthDuration("P0M")
xs:yearMonthDuration("P3Y36M") div xs:double("INF") eq xs:yearMonthDuration("P0M")
xs:yearMonthDuration("P3Y36M") div xs:double("NaN")
xs:yearMonthDuration("P3Y36M") div xs:yearMonthDuration("P60Y") eq 0.1
xs:yearMonthDuration("P3Y3M") div xs:dayTimeDuration("P3D")
xs:yearMonthDuration("P3Y3M") div xs:duration("P3D")
xs:yearMonthDuration("P3Y3M") * xs:dayTimeDuration("P3D")
xs:yearMonthDuration("P3Y3M") + xs:dayTimeDuration("P3D")
xs:yearMonthDuration("P3Y3M") - xs:dayTimeDuration("P3D")
xs:yearMonthDuration("P3Y3M") * xs:double("-INF")
xs:yearMonthDuration("P3Y3M") * xs:double("INF")
xs:yearMonthDuration("P3Y3M") * xs:double("NaN")
xs:yearMonthDuration("P3Y3M") + xs:duration("P3D")
xs:yearMonthDuration("P3Y3M") - xs:duration("P3D")
xs:yearMonthDuration("P3Y3M") + xs:yearMonthDuration("P0M") eq xs:yearMonthDuration("P3Y3M")
xs:yearMonthDuration("P3Y3M") - xs:yearMonthDuration("P0M") eq xs:yearMonthDuration("P3Y3M")
xs:yearMonthDuration("P3Y3M") * xs:yearMonthDuration("P3Y3M")
xs:yearMonthDuration("P3Y4M") div xs:yearMonthDuration("-P1Y4M")
xs:yearMonthDuration("-P3Y8M") ne xs:yearMonthDuration("P3Y8M")
(xs:yearMonthDuration("P42Y10M") - xs:yearMonthDuration("P20Y10M")) div (xs:yearMonthDuration("P20Y11M") - xs:yearMonthDuration("P18Y11M"))
(xs:yearMonthDuration("P42Y10M") + xs:yearMonthDuration("P28Y10M")) div (xs:yearMonthDuration("P10Y10M") + xs:yearMonthDuration("P60Y10M"))
xs:yearMonthDuration("P731D")
xs:yearMonthDuration('P768614336404564650Y0M') * 2
xs:yearMonthDuration('P768614336404564650Y0M') div 0.5
xs:yearMonthDuration('P768614336404564650Y0M') - xs:yearMonthDuration('-P768614336404564650Y0M')
xs:yearMonthDuration('P768614336404564650Y0M') + xs:yearMonthDuration('P768614336404564650Y1M')
xs:yearMonthDuration(xs:untypedAtomic( "P1Y12M" )) eq xs:yearMonthDuration("P1Y12M")
"&#xW20;"
<x> <x> <y id="0"/> </x> <y id="1"/> </x>/descendant-or-self::x/child::y
(<x/>, <?y?>)[self::processing-instruction()]
"xyz" , xs:string(" "), "b"
year-from-date()
year-from-date(current-date()) = 1 to 5000
year-from-date(current-date()) = 5000 to 10000
year-from-date(current-date()) to 4000 = 1500 to 2500
year-from-date(()) instance of xs:integer?
year-from-dateTime()
year-from-dateTime(()) instance of xs:integer?
year-from-dateTime((), "Wrong param")
year-from-dateTime(xs:dateTime("2001-02-03T08:23:12.43")) eq 2001
(year-from-dateTime( xs:dateTime('2006-08-15T10:30:23')))
year-from-date((), "Wrong param")
year-from-date(xs:date("2000-02-03")) eq 2000
(year-from-date(xs:date('2006-08-15')))
years-from-duration()
years-from-duration(()) instance of xs:integer?
years-from-duration((), "Wrong param")
years-from-duration(xs:duration("-P3Y4M4DT1H23M2.34S")) eq -3
years-from-duration(xs:yearMonthDuration("-P0003Y2M")) eq -3
years-from-duration(xs:yearMonthDuration("P0003Y2M")) eq 3
(years-from-duration( xs:yearMonthDuration('P12M')))
(years-from-duration( xs:yearMonthDuration('-P18M')))
(years-from-duration( xs:yearMonthDuration('P1Y18M')))
(years-from-duration( xs:yearMonthDuration('P3Y')))
(years-from-duration( xs:yearMonthDuration('P3Y11M')))
(years-from-duration( xs:yearMonthDuration('P3Y')), years-from-duration( xs:yearMonthDuration('P3Y11M')), years-from-duration( xs:yearMonthDuration('-P18M')), years-from-duration( xs:yearMonthDuration('P1Y18M')), years-from-duration( xs:yearMonthDuration('P12M')))
zero-or-more(1)
(zero-or-one( () ))
zero-or-one()
zero-or-one(1, 2)
zero-or-one( (1, 2, 3) )
(zero-or-one('a'))
zero-or-one(true())
(zero-or-one( () ), zero-or-one('a'))
(("zzz" || "zz") || "123")
